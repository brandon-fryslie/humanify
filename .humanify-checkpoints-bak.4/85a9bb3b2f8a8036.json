{
  "version": "2.0.0",
  "timestamp": 1763351162047,
  "inputHash": "85a9bb3b2f8a8036",
  "completedBatches": 83,
  "totalBatches": 119,
  "renames": {
    "cu9": "devToolsInitialization",
    "tj0": "devToolsConnection",
    "QS0": "rendererInstance",
    "AS0": "getDifferenceBetweenTwoObjects",
    "BS0": "cleanupYogaNode",
    "Ph": "renderComponent",
    "pu9": "getComputedWidthMinusPaddingAndBorders",
    "IS0": "calculateElementWidth",
    "ZS0": "borderStyles",
    "iu9": "colorPalette",
    "nu9": "lightAnsiColor",
    "au9": "darkAnsiColors",
    "su9": "lightDaltonizedColor",
    "ru9": "getDefaultColorPalette",
    "ou9": "areaDarkenedColorTheme",
    "WS0": "loadColorPalette",
    "tu9": "colorRegexPattern",
    "eu9": "ansiColorRegex",
    "CS0": "borderStyleMap",
    "Bm9": "_borderStyleMap",
    "VS0": "Renderer",
    "sZ1": "processAndDisplayNodes",
    "HS0": "initializeApplication",
    "Gm9": "processDelayedReactComponent",
    "Zm9": "isInsideStatic",
    "Ym9": "maxDigit",
    "tZ1": "extractInputColorChannels",
    "oZ1": "colorMapping",
    "US0": "customTransformation",
    "wS0": "colorSettings",
    "WPA": "colorManagementHelper",
    "AY1": "colorManagementSystem",
    "FPA": "Foreground_Pen_Actions",
    "BY1": "processManagement",
    "qS0": "connectionSource",
    "AyI": "InputProcessor",
    "Vm9": "formatText",
    "MS0": "initializeDevelopmentTools",
    "Dm9": "getModuleDetails",
    "Em9": "maxAllowedValue",
    "Hm9": "renderContainer",
    "zm9": "debuggingToolConnection",
    "CY1": "initializeAppState",
    "qm9": "defaultStyledChar",
    "Nm9": "emptySpace",
    "Om9": "SegmentColorer",
    "EPA": "terminalCursorControl",
    "myI": "isNodeEnvironment",
    "dyI": "isBunEnvironment",
    "cyI": "runtimeEnvironmentDetected",
    "pyI": "isElectronEnvironment",
    "lyI": "isRunningInJsdomEnvironment",
    "iyI": "isWebWorkerContext",
    "nyI": "isDedicatedWorkerGlobalScope",
    "ayI": "platformGlobalContext",
    "syI": "isServiceWorkerGlobalScope",
    "IJA": "getUserAgentPlatform",
    "ryI": "isMacOS",
    "oyI": "getOSInformation",
    "tyI": "isLinuxOS",
    "eyI": "isOperatingInMobileEnvironment",
    "AkI": "isAndroidPlatform",
    "CH": "terminalCommands",
    "DY1": "processModule",
    "xI": "escapeSequence",
    "ZJA": "decodingString",
    "D0A": "alert",
    "GJA": "handleDevToolsConnection",
    "_S0": "compositeColorTransformFunction",
    "Pm9": "formatTextCursorPosition",
    "jm9": "updateVisualization",
    "vS0": "cursorLeftPosition",
    "vm9": "setCursorToPosition",
    "bm9": "commitUpdate",
    "fm9": "getCursorPosition",
    "hm9": "cursorMoveToNextLine",
    "gm9": "cursorPreviousLine",
    "um9": "hideCursor",
    "EY1": "cursorShow",
    "dm9": "clearLine",
    "cm9": "eraseStartLine",
    "bS0": "clearTargetNode",
    "pm9": "removeChildFromContainer",
    "lm9": "eraseCharacters",
    "KY1": "clearScreen",
    "im9": "handleChildHostContext",
    "nm9": "connectToDevTools",
    "am9": "clearTerminal",
    "sm9": "clearTerminalDisplay",
    "rm9": "enterAlternativeScreenCommand",
    "om9": "exitAlternativeScreenAction",
    "tm9": "processScrollEvents",
    "Bd9": "getAndSetReactDevTools",
    "Qd9": "updateDefaultRenderer",
    "xk": "colorManagement",
    "Id9": "handleComponentInitialization",
    "Sh": "EventEmitter",
    "cS0": "processData",
    "pS0": "processState",
    "wY1": "_initializeDevelopmentTools",
    "lS0": "__initializeDevelopmentTools",
    "iS0": "rendererSetup",
    "wPA": "initializeReactDevTools",
    "nS0": "___initializeDevelopmentTools",
    "aS0": "____initializeDevelopmentTools",
    "$PA": "_processAndDisplayNodes",
    "rS0": "_initializeDevTools",
    "Fd9": "initializeDevToolsConnection",
    "By0": "__initializeDevTools",
    "Cd9": "_initializeDevToolsConnection",
    "Iy0": "initializeDebugTools",
    "NPA": "___initializeDevTools",
    "LY1": "__initializeDevToolsConnection",
    "S": "__processAndDisplayNodes",
    "MPA": "___initializeDevToolsConnection",
    "yh": "_initializeReactDevTools",
    "OY1": "____initializeDevToolsConnection",
    "Zy0": "_____initializeDevToolsConnection",
    "RPA": "DevToolsManager",
    "Xy0": "______initializeDevToolsConnection",
    "GX": "getDifferencesBetweenObjects",
    "SY1": "_______initializeDevToolsConnection",
    "Jy0": "________initializeDevToolsConnection",
    "Kd9": "_________initializeDevToolsConnection",
    "Dd9": "initializeRenderer",
    "Ed9": "__________initializeDevToolsConnection",
    "Hd9": "_____initializeDevelopmentTools",
    "TPA": "___________initializeDevToolsConnection",
    "Ud9": "____initializeDevTools",
    "wd9": "_initializeRenderer",
    "Cy0": "____________initializeDevToolsConnection",
    "Ky0": "_____initializeDevTools",
    "Dy0": "______initializeDevelopmentTools",
    "qd9": "______initializeDevTools",
    "Nd9": "_____________initializeDevToolsConnection",
    "PPA": "KeyPressHandler",
    "Ey0": "______________initializeDevToolsConnection",
    "jPA": "initializeDebuggerConnection",
    "Hy0": "_______initializeDevTools",
    "SPA": "SinglePageApplication",
    "cT": "_cleanupYogaNode",
    "Md9": "__initializeRenderer",
    "Od9": "________initializeDevTools",
    "Rd9": "_________initializeDevTools",
    "Td9": "_______initializeDevelopmentTools",
    "yPA": "InternalAppComponent",
    "JJA": "initializeDebuggingTools",
    "Uy0": "_______________initializeDevToolsConnection",
    "wy0": "__________initializeDevTools",
    "W_I": "________________initializeDevToolsConnection",
    "Ny0": "________initializeDevelopmentTools",
    "My0": "_________________initializeDevToolsConnection",
    "yd9": "___________initializeDevTools",
    "I5": "___initializeRenderer",
    "gY1": "retrieveColorSettings",
    "bd9": "initDevToolsConnection",
    "fd9": "__________________initializeDevToolsConnection",
    "u$": "devToolsHandler",
    "Py0": "___________________initializeDevToolsConnection",
    "jy0": "____________________initializeDevToolsConnection",
    "Sy0": "_____________________initializeDevToolsConnection",
    "yy0": "______________________initializeDevToolsConnection",
    "hd9": "_________initializeDevelopmentTools",
    "_y0": "devToolsInitializationHandler",
    "_h": "__________initializeDevelopmentTools",
    "mY1": "___________initializeDevelopmentTools",
    "h1": "renderAndSetupComponent",
    "md9": "____________initializeDevTools",
    "dY1": "renderingFunction1",
    "dd9": "_______________________initializeDevToolsConnection",
    "cd9": "____initializeRenderer",
    "cY1": "rendererInitialization",
    "xh": "_____________initializeDevTools",
    "gy0": "______________initializeDevTools",
    "xPA": "initializeColorPalette",
    "ly0": "_______________initializeDevTools",
    "ld9": "_____initializeRenderer",
    "ry0": "________________initializeDevTools",
    "ny0": "________________________initializeDevToolsConnection",
    "ay0": "_________________________initializeDevToolsConnection",
    "nY1": "_devToolsInitializationHandler",
    "id9": "__________________________initializeDevToolsConnection",
    "nd9": "initializeRendererComponent",
    "ad9": "___________________________initializeDevToolsConnection",
    "sd9": "_________________initializeDevTools",
    "aY1": "______initializeRenderer",
    "m$": "insertIndex",
    "hPA": "setupDevToolsConnection",
    "lT": "getLeftPadding",
    "uPA": "OrderedMap",
    "Qk0": "calculateObjectDifference",
    "rd9": "__________________initializeDevTools",
    "rV": "initializeRendering",
    "od9": "initializeDevToolsFromConnection",
    "dPA": "addDevicePixelDensity",
    "rY1": "initializeRenderTree",
    "oY1": "initializeRenderingProcess",
    "iT": "_______initializeRenderer",
    "Kk0": "___________________initializeDevTools",
    "Hk0": "____________________________initializeDevToolsConnection",
    "WJA": "_handleDevToolsConnection",
    "FJA": "_____________________________initializeDevToolsConnection",
    "nPA": "________initializeRenderer",
    "AJ1": "__initializeReactDevTools",
    "tk0": "_initializeDebugTools",
    "XJ1": "_________initializeRenderer",
    "KJ1": "______________________________initializeDevToolsConnection",
    "k_0": "calculateDifferencesBetweenObjects",
    "nvI": "colorFormatMappingFunction",
    "m_0": "colorConverter",
    "u_0": "colorKeywordMapping",
    "M2": "colorConversionMethods",
    "ovI": "createInputOptions",
    "a_0": "exportInputUtilities",
    "Ml9": "textAlignmentMap",
    "AbI": "processImageTransformations",
    "Zx0": "exportImageProcessingMethods",
    "Gx0": "PrecisionTypes",
    "A": "captureErrorStackTrace",
    "B": "_versionConstraint",
    "Q": "originalPrepareStackTrace",
    "G": "stackTraceInfo",
    "vvI": "parseSemverRange",
    "D_0": "EjaExport",
    "Cp9": "whitespacePattern",
    "V_0": "isPrereleaseVersion",
    "$p9": "isEmptyVersion",
    "K_0": "checkIntersection",
    "ND": "isWildcard",
    "rvI": "colorModelConstructor",
    "i_0": "ColorConverter",
    "l_0": "colorModelNames",
    "zJ1": "colorLabelMap",
    "JjA": "colorModelTransformations",
    "tvI": "setupImageManipulationOptions",
    "Ax0": "exportImageResizingMethods",
    "o_0": "directions",
    "t_0": "PositionMapping",
    "r_0": "imageProcessingOptions",
    "e_0": "resizePositionStrategy",
    "wJ1": "resamplingMethods",
    "yl9": "resizeFitOptions",
    "kl9": "imageFitOptions",
    "NvI": "createSemanticVersion",
    "ck0": "SemVer",
    "fvI": "createSharpModule",
    "xp9": "_createSharpModule",
    "MkI": "createErrorStackCleaner",
    "eS0": "createStackTraceCleaner",
    "Yd9": "currentWorkingDirectory",
    "process": "__logSemverDebug",
    "tS0": "nodeInternalPatterns",
    "Xd9": "stackTraceLinePattern",
    "Wd9": "functionNamePattern",
    "dvI": "createImageProcessor",
    "P_0": "ImageProcessor",
    "Gl9": "loadUtilModule",
    "VJ1": "StreamProcessingModule",
    "ivI": "_colorConverter",
    "h_0": "colorModule",
    "b_0": "objectHasOwnProperty",
    "f_0": "colorMap",
    "zJA": "colorMappingFunction",
    "cvI": "exportColorPalette",
    "S_0": "colorPaletteModule",
    "hvI": "processLibvipsSetup",
    "O_0": "moduleExports",
    "QjA": "spawnChildProcess",
    "vp9": "createHash",
    "mp9": "supportedPlatforms",
    "IjA": "spawnOptions",
    "dp9": "logInstallationError",
    "lp9": "getSharpLibvipsCPlusPlusDir",
    "N_0": "isUsingEmscripten",
    "WJ1": "handleGlobalLibvipsUsage",
    "I": "stackTraceLimit",
    "Z": "_stackTrace",
    "Y": "colorComponentLabels",
    "J": "___colorComponents",
    "X": "staticTextRenderer",
    "sT": "versionParser",
    "vk0": "initializeVersioningExports",
    "_c9": "processVersionPattern",
    "eY1": "ALPHANUMERIC_IDENTIFIER_PATTERN",
    "zvI": "detectLinuxLibc",
    "kk0": "initializeLinuxLibraryInfo",
    "Uk0": "childProcessModule",
    "nT": "libcDetectionCache",
    "aT": "glibcVersion",
    "fh": "fetchGlibcVersionInfo",
    "hh": "GLIBC_IDENTIFIER",
    "Mk0": "glibcVersionRegex",
    "z0A": "MUSL_LIBC",
    "Ec9": "isMuslLibc",
    "zk0": "extractGlibcVersion",
    "evI": "compositeImageOptions",
    "Qx0": "registerCompositeMethods",
    "qJ1": "blendModes",
    "uvI": "loadSharpModule",
    "T_0": "moduleExporter",
    "CJ1": "loadedSharpModule",
    "GjA": "errorList",
    "xvI": "createComparator",
    "F_0": "Comparator",
    "KJA": "SEMVER_ANY_SYMBOL",
    "W": "appendAsciiString",
    "F": "outputHeight",
    "V": "applyTextStyles",
    "K": "borderBottomDimColor",
    "D": "leftBorderDimColor",
    "E": "borderRightDimColor",
    "H": "terminateProcess",
    "C": "terminalScreen",
    "fxI": "manageProcessTermination",
    "py0": "handleProcessTermination",
    "cy0": "_childProcessModule",
    "L": "hasLeftBorder",
    "w": "hasBorderBottom",
    "WorkerGlobalScope": "GlobalExecutionContext",
    "DedicatedWorkerGlobalScope": "isRunningInDedicatedWorkerGlobalScope",
    "SharedWorkerGlobalScope": "platformGlobalContextCheck",
    "ServiceWorkerGlobalScope": "GlobalServiceWorkerContext",
    "DvI": "validateDataTypes",
    "Fk0": "validateInputExports",
    "QbI": "initializeColorTransform",
    "Fx0": "exportColorOptions",
    "Di9": "BooleanOperations",
    "BbI": "initializeColorSpaceExtensions",
    "Xx0": "initializeColourOptions",
    "Jx0": "colorSpaceOptions",
    "SSI": "generateBoxStyles",
    "lu9": "renderStylishBorders",
    "avI": "analyzeGraphTraversal",
    "d_0": "exportShortestPaths",
    "vPA": "formatRelativeTime",
    "svI": "initializeSignalValues",
    "p_0": "exportedData",
    "L0A": "dataProcessor",
    "MvI": "parseVersion",
    "ik0": "parseVersionString",
    "H0A": "TextBuffer",
    "XJA": "CircularBuffer",
    "_vI": "compareValuesBasedOnOperator",
    "G_0": "exportComparisonFunction",
    "pT": "formatTimestamp",
    "nZ1": "indentStringLines",
    "TvI": "createLRUCache",
    "ok0": "CacheManager",
    "rk0": "_CacheManager",
    "$m9": "parseColorCodes",
    "qvI": "compareNumericOrStringIdentifiers",
    "gk0": "compareNumericIdentifiers",
    "fk0": "numericRegex",
    "EvI": "initializePlatformReport",
    "Vk0": "_moduleExports",
    "Ck0": "isLinuxPlatform",
    "pPA": "getCachedProcessReport",
    "lvI": "processItems",
    "x_0": "processInputArray",
    "Wl9": "concatenateArrays",
    "Fl9": "extractArrayElements",
    "wl9": "createRounder",
    "Jl9": "createInstanceWithOptions",
    "FS0": "formatStringWithPadding",
    "KU": "formatDuration",
    "wvI": "initializeSemanticVersioning",
    "xk0": "semverConstants",
    "Oc9": "MAX_SAFE_INTEGER_DEFINED",
    "Rc9": "RELEASE_TYPES_ARRAY",
    "cPA": "TextSegment",
    "N": "isBorderRightEnabled",
    "lY1": "concatenateWithTruncation",
    "HvI": "moduleSetup",
    "Ek0": "initializeFileSystemModule",
    "Dk0": "fileSystemModule",
    "CG": "truncateStringWithEllipsis",
    "pvI": "validateArrayInput",
    "y_0": "isArrayOrArrayLike",
    "oy0": "createTaskResult",
    "mS0": "ViewportCursorManager",
    "Lm9": "compareTextStyle",
    "Ul9": "createFunctionWrapper",
    "Ui9": "addInputDescriptorsToJoinChannel",
    "LvI": "createInstance",
    "lk0": "_createInstance",
    "$vI": "handleInputValidation",
    "bk0": "exportConfiguredFunction",
    "bc9": "defaultBehaviorConfig",
    "fc9": "defaultEmptyObject",
    "fPA": "formatAndAppend",
    "UvI": "logSemverDebug",
    "_k0": "exportDebugLogger",
    "Mc9": "_logSemverDebug",
    "E0A": "EventPropagationHandler",
    "yZ": "formatNumberWithCompactNotation",
    "LkI": "escapeRegExp",
    "sS0": "escapeSpecialCharacters",
    "Gd9": "specialCharacterRegex",
    "Rm9": "areArraysEqualByCode",
    "iy0": "truncateArrayToSize",
    "bvI": "regexTest",
    "E_0": "exportFunctionForTesting",
    "zd9": "createKeyboardEventState",
    "sY": "validateIntegerInput",
    "oS0": "updateFilePath",
    "fS0": "areDimensionsValid",
    "ZjA": "_convertToHex",
    "dy0": "killProcessById",
    "UJ1": "replaceNonNumericWithZero",
    "Tl9": "concatInputBuffer",
    "OvI": "compareValuesBasedOnCriteria",
    "ak0": "compareNumbers",
    "$J1": "isImageTransformRequired",
    "Fc9": "generateTypeErrorMessage",
    "Nl9": "ensureArray",
    "PvI": "isEqualToZero",
    "ek0": "compareValues",
    "jvI": "isNotEqualToZero",
    "A_0": "checkNonZero",
    "RvI": "isConditionMet",
    "sk0": "isValueNonNegative",
    "kvI": "isLessThanOrEqualToZero",
    "I_0": "isQueryResultNonPositive",
    "SvI": "isGreaterThanZero",
    "B_0": "checkConditionAndExport",
    "yvI": "isLessThan",
    "Q_0": "isLessThanZero",
    "XY1": "isIntegerValidForChecks",
    "TS0": "calculatePositionBasedOnWidth",
    "Cl9": "calculateSquaredDistance",
    "Ly0": "isUndefinedCheck",
    "YW": "clampValueWithinRange",
    "rZ1": "isIntegerAndEven",
    "ed9": "isObjectType",
    "ySI": "getBorderStyles",
    "aZ1": "borderStylesExport",
    "Yi9": "setBackgroundTint",
    "jd9": "isWindowsTerminalSession",
    "Ak0": "invalidateSessionCache",
    "Dl9": "composeAndApply",
    "Yc9": "isValidNumber",
    "Ei9": "setOptionsToRemoveAlpha",
    "Pl9": "isInputBufferArray",
    "Wk0": "isDefinedAndNotNull",
    "nl9": "setOptionsToUnflatten",
    "Zc9": "isNonEmptyString",
    "WjA": "isDimensionsValid",
    "gh": "_clampValue",
    "Cc9": "copyMessage",
    "KPA": "isPointWithinBounds",
    "$": "borderOffset",
    "O": "topBorder",
    "Fi9": "convertToPipelineColourspace",
    "Gc9": "isArrayBuffer",
    "Ac9": "isFunction",
    "$l9": "formatNumberToDecimalPlaces",
    "_k": "concatenateCodeFromArray",
    "Bc9": "isBoolean",
    "Xc9": "isWithinRange",
    "td9": "_isObject",
    "Vi9": "convertToColourspace",
    "Qc9": "isBufferInstance",
    "Jc9": "isInteger",
    "ol9": "normalizeData",
    "Xi9": "convertToGreyscale",
    "Wc9": "isElementInArray",
    "Pd9": "initializeApp",
    "ej0": "_______________________________initializeDevToolsConnection",
    "GS0": "initializeCalculationForElementWidth",
    "JS0": "___initializeReactDevTools",
    "Am9": "colorFormatter",
    "XPA": "________________________________initializeDevToolsConnection",
    "Im9": "formatTextWithIndentation",
    "eZ1": "____________initializeDevelopmentTools",
    "AJA": "initializeColorManagementSystem",
    "BJA": "____________________initializeDevTools",
    "kS0": "_____________initializeDevelopmentTools",
    "Sm9": "______________initializeDevelopmentTools",
    "ym9": "_______________initializeDevelopmentTools",
    "xS0": "_____________________initializeDevTools",
    "km9": "________________initializeDevelopmentTools",
    "_m9": "_________________________________initializeDevToolsConnection",
    "xm9": "processColorString",
    "em9": "______________________initializeDevTools",
    "Ad9": "__________________________________initializeDevToolsConnection",
    "zPA": "____initializeReactDevTools",
    "UPA": "_____initializeReactDevTools",
    "$Y1": "_______________________initializeDevTools",
    "qPA": "__createInstance",
    "Ay0": "________________________initializeDevTools",
    "Qy0": "_getDifferenceBetweenTwoObjects",
    "Vd9": "___________________________________initializeDevToolsConnection",
    "LPA": "setupReactDevelopmentTools",
    "Yy0": "devToolsInitializer",
    "Fy0": "_________________initializeDevelopmentTools",
    "xY1": "____________________________________initializeDevToolsConnection",
    "vY1": "__________________initializeDevelopmentTools",
    "bY1": "_________________________initializeDevTools",
    "xd9": "______initializeReactDevTools",
    "vd9": "_____________________________________initializeDevToolsConnection",
    "uY1": "__________________________initializeDevTools",
    "gd9": "initializeConnectionToDevTools",
    "ud9": "______________________________________initializeDevToolsConnection",
    "hy0": "___________________initializeDevelopmentTools",
    "iY1": "processStyledInputArray",
    "Ik0": "_______________________________________initializeDevToolsConnection",
    "sY1": "__________initializeRenderer",
    "Yk0": "________________________________________initializeDevToolsConnection",
    "iPA": "appendChildToYogaNode",
    "w0A": "___________________________initializeDevTools",
    "v_0": "____________________________initializeDevTools",
    "DJ1": "____________________initializeDevelopmentTools",
    "Bx0": "_________________________________________initializeDevToolsConnection",
    "Ix0": "_____________________initializeDevelopmentTools",
    "Cx0": "______________________initializeDevelopmentTools",
    "$JA": "initializeColorMapping",
    "q0": "inputValidationUtil",
    "Z0": "___________initializeRenderer",
    "Vp9": "debugToolsInitializer",
    "Kp9": "____________initializeRenderer",
    "VG": "logDebugInfo",
    "Up9": "FLAG_INCLUDE_PRERELEASE",
    "wp9": "FLAG_LOOSE_MODE",
    "Sp9": "generateRangeString",
    "h2": "imageRenderer",
    "aPA": "_____________________________initializeDevTools",
    "uk0": "MAX_VERSION_LENGTH",
    "sPA": "maxSafeInteger",
    "uc9": "initializeSemanticVersion",
    "$0A": "compareVersions",
    "Zd9": "______________________________initializeDevTools",
    "Xk0": "TextWrapper",
    "Zl9": "initializeImageRenderer",
    "Yl9": "debugLogSharp",
    "UJA": "colorDatabase",
    "DU": "_colorConversionMethods",
    "hp9": "libvipsConfig",
    "z_0": "libvipsEngines",
    "gp9": "optionalDependencies",
    "ap9": "isRunningUnderRosetta",
    "U_0": "generateSHA512Hash",
    "rp9": "spawnNodeGypRebuild",
    "M_0": "getPkgConfigPath",
    "tY1": "MAX_SAFE_COMPONENT_LENGTH",
    "Tc9": "MAX_SAFE_BUILD_LENGTH",
    "Pc9": "MAX_SAFE_LENGTH",
    "jc9": "__handleDevToolsConnection",
    "Sc9": "regexpArray",
    "yc9": "safeRegExpCache",
    "jQ": "versionPatterns",
    "kc9": "safeSourcePatterns",
    "SQ": "_versionPatterns",
    "U0A": "isLinuxOperatingSystem",
    "wk0": "getLinuxLibraryInfo",
    "lPA": "lddPath",
    "$k0": "readFileFromFilePath",
    "qk0": "readFileSync",
    "Rk0": "detectLibcImplementation",
    "Tk0": "detectLibcType",
    "yk0": "extractGlibcVersionFromOutput",
    "h3": "_____________initializeRenderer",
    "Z_0": "______________initializeRenderer",
    "YJ1": "logDevToolConnection",
    "uy0": "_spawnChildProcess",
    "pd9": "execChildProcessCommand",
    "rT": "_renderer",
    "bk": "rendererInitializer",
    "Ld9": "processInputKey",
    "uS0": "updateCursorAndScreenPosition",
    "vk": "handleTimeoutLogic",
    "hk0": "compareIdentifiers",
    "Tm9": "processColorSegments",
    "Xl9": "calculateIfObjectHasDifferences",
    "CPA": "processCompoundPathAnalysis",
    "DY": "createColorTransformationFunction",
    "my0": "processAndTerminate",
    "QY1": "getColorCode",
    "Ic9": "isTypedArray",
    "sy0": "createStreamHandler",
    "K0A": "createScreen",
    "Kc9": "_readFileSync",
    "Dc9": "readFileAsync",
    "$d9": "processInputToString",
    "Jm9": "getColorRepresentation",
    "zS0": "processColorChannelData",
    "jM": "renderWithTransform",
    "XS0": "getColorPaletteBasedOnScheme",
    "Um9": "findCharacterPosition",
    "PS0": "updateCellInBounds",
    "hc9": "validateInputOrReturnDefault",
    "Km9": "extractSubstringAfterOffset",
    "vh": "formatTimestampRelative",
    "Sd9": "isRunningInWindowsTerminal",
    "Xm9": "findFirstValidCharacterIndex",
    "TY1": "_______________________________initializeDevTools",
    "Ry0": "ColorSettingsProvider",
    "DPA": "getCellFromGridCoordinates",
    "ty0": "initializeRendererAndDevToolsConnection",
    "HQ": "useThemeContext",
    "AF": "createInkTextWithRepeatedNewLines",
    "YS0": "borderStylesDefinition",
    "ql9": "createDecimalFormatter",
    "MY1": "setThemeForColorManagement",
    "k": "heightAdjustment",
    "iZ1": "initializeRendererInstance",
    "VPA": "initializeReactDevToolsConnection",
    "OS0": "_initializeReactDevToolsConnection",
    "mm9": "__________________________________________initializeDevToolsConnection",
    "HY1": "__initializeReactDevToolsConnection",
    "zY1": "_______________initializeRenderer",
    "qY1": "___________________________________________initializeDevToolsConnection",
    "Gy0": "____________________________________________initializeDevToolsConnection",
    "Ty0": "_____________________________________________initializeDevToolsConnection",
    "ky0": "______________________________________________initializeDevToolsConnection",
    "vy0": "___initializeReactDevToolsConnection",
    "fy0": "initializeDevelopmentToolsConnection",
    "Zk0": "_______________________________________________initializeDevToolsConnection",
    "oV": "____initializeReactDevToolsConnection",
    "g_0": "________________________________________________initializeDevToolsConnection",
    "c_0": "_________________________________________________initializeDevToolsConnection",
    "C_0": "debugToolsInstance",
    "VH": "semverRegexPatterns",
    "qD": "devToolFlags",
    "Ep9": "comparatorTrimReplacement",
    "Hp9": "tildeTrimReplacePattern",
    "zp9": "caretTrimReplace",
    "mk0": "safeRegex",
    "dk0": "safeRegExPatterns",
    "rPA": "_versionParser",
    "wJA": "createColorComponents",
    "H_0": "yogaNodeAppender",
    "up9": "libvipsVersion",
    "L_0": "getGlobalLibvipsVersion",
    "xc9": "VERSION_IDENTIFIER_INCLUDE",
    "Ok0": "detectLibraryImplementation",
    "Hc9": "detectLibcImplementationAsync",
    "zc9": "detectLibcVersionSync",
    "$c9": "_fetchGlibcVersion",
    "qc9": "getGlibcVersionSync",
    "Sk0": "getGlibcVersionRuntime",
    "tp9": "getLibvipsVersion",
    "ep9": "getSharpLibraryVersion",
    "Y_0": "comparatorPatterns",
    "J_0": "DevToolsInitialization",
    "_l9": "setImageResizeParameters",
    "cl9": "configureSharpeningOptions",
    "fl9": "validateAndComposeImages",
    "bPA": "executeProcessWithTimeoutHandler",
    "mPA": "useFocusManager",
    "dl9": "setAffineTransformation",
    "xl9": "setExtensionOptions",
    "YjA": "graphAdjacencyList",
    "EJ1": "developmentTools",
    "ll9": "setBlurringParameters",
    "Vy0": "processInputAndInitializeDevTools",
    "oPA": "versionPatternRegex",
    "tPA": "versionParseMethod",
    "Gi9": "initializeColorOptions",
    "Bk0": "loadSessionEnvironment",
    "Qi9": "setLinearOptionsAndInitialize",
    "rl9": "validateAndNormalizeRange",
    "tl9": "initializeClaheOptions",
    "bl9": "setTrimOptions",
    "vl9": "setPositionAndSize",
    "kh": "renderItemsWithDebuggerComponent",
    "n_0": "extractValidImageProperties",
    "RY1": "ThemeProvider",
    "el9": "validateConvolutionKernelOptions",
    "Ai9": "setImageThreshold",
    "al9": "setGammaValues",
    "gc9": "reverseCompareIdentifiers",
    "Ii9": "setRecombinationMatrix",
    "Rl9": "processInputData",
    "__0": "processAndFilterInputArray",
    "jS0": "compareGridStyling",
    "zi9": "setExtractChannel",
    "sl9": "initializeRendererWithOptions",
    "Hi9": "setAlphaValue",
    "Bi9": "BooleanExpressionConstructor",
    "HPA": "createTerminalDisplay",
    "pl9": "setMedianSize",
    "JY1": "_processAnsiAndCharItems",
    "wi9": "_setBooleanOperator",
    "Wm9": "extractSubstringUntilValidCharacter",
    "Jd9": "createNodeModulesRegex",
    "il9": "setFlattenOption",
    "fY1": "clearConsoleOutput",
    "Wi9": "_setColourspace",
    "Ci9": "__setColourspace",
    "wm9": "extractSubstringUntilCharacterPosition",
    "OB": "formatColorBasedOnActivity",
    "Ji9": "setGreyscale",
    "Cm9": "getReversedEndCodeString",
    "ul9": "setFlipOptionOrDefault",
    "ml9": "initializeFlopOption",
    "ey0": "initializeHookRenderer",
    "IY1": "processCompoundPathAnalysisInput",
    "Qm9": "renderWithBorders",
    "ZY1": "initializeReactDevelopmentToolsConnection",
    "YJA": "__________________________________________________initializeDevToolsConnection",
    "kY1": "_____initializeReactDevToolsConnection",
    "$y0": "___________________________________________________initializeDevToolsConnection",
    "_PA": "____________________________________________________initializeDevToolsConnection",
    "qi": "______initializeReactDevToolsConnection",
    "d$": "_____________________________________________________initializeDevToolsConnection",
    "HJ1": "______________________________________________________initializeDevToolsConnection",
    "Dp9": "initializeSemver",
    "Lp9": "parseTildeVersion",
    "Op9": "applyCaretRange",
    "Tp9": "replaceXRangesInSemver",
    "Pp9": "replaceWildcardVersions",
    "jp9": "replaceGTE0",
    "M0A": "_______________________________________________________initializeDevToolsConnection",
    "q_0": "getLibvipsABI",
    "vc9": "replacePatternWithMaxLength",
    "X_0": "_SemVer",
    "Hl9": "________________________________________________________initializeDevToolsConnection",
    "zl9": "developmentToolKeys",
    "dc9": "_______initializeReactDevToolsConnection",
    "WY1": "transformStringWithLimitedWidth",
    "U": "StyledText",
    "hY1": "processDataCommands",
    "Fm9": "parseStyledStringIntoComponents",
    "Gk0": "useSelectableOptions",
    "El9": "generateConversionPath",
    "pk0": "ReactDevToolsConnection",
    "Vl9": "initializeGraphNodes",
    "nk0": "________initializeReactDevToolsConnection",
    "GY1": "transformAndReverseCompoundPathAnalysisInput",
    "KS0": "_________initializeReactDevToolsConnection",
    "YY1": "__________initializeReactDevToolsConnection",
    "_Y1": "_________________________________________________________initializeDevToolsConnection",
    "qy0": "__________________________________________________________initializeDevToolsConnection",
    "xy0": "___________________________________________________________initializeDevToolsConnection",
    "by0": "___________initializeReactDevToolsConnection",
    "BJ1": "_initializeDevelopmentToolsConnection",
    "CJA": "____________initializeReactDevToolsConnection",
    "QJ1": "____________________________________________________________initializeDevToolsConnection",
    "IJ1": "_____________________________________________________________initializeDevToolsConnection",
    "VJA": "initializeAndConnectDevTools",
    "ePA": "_____________initializeReactDevToolsConnection",
    "AjA": "______________________________________________________________initializeDevToolsConnection",
    "XjA": "______________initializeReactDevToolsConnection",
    "Np9": "parseTildeVersions",
    "Mp9": "mapSemverToCaretRange",
    "Rp9": "replaceXRangesInVersion",
    "EU": "colorModelInfo",
    "cp9": "getRuntimePlatformArchitecture",
    "N0A": "getBuildPlatformArch",
    "c4": "defineVersionPattern",
    "yY1": "handleErrorDisplay",
    "cc9": "_______________________________________________________________initializeDevToolsConnection",
    "bh": "renderTooltipComponent",
    "$i": "processFormattedString",
    "Kl9": "traverseGraphFromNode",
    "mc9": "createReactDevToolsInstance",
    "P": "topBorderColoredOutput",
    "jh": "combineAndFilterDataResults",
    "lc9": "_compareValues",
    "ac9": "________________________________________________________________initializeDevToolsConnection",
    "rc9": "_________________________________________________________________initializeDevToolsConnection",
    "ic9": "__________________________________________________________________initializeDevToolsConnection",
    "Qp9": "___________________________________________________________________initializeDevToolsConnection",
    "tc9": "initializeAndCheckGreaterThanZero",
    "Ap9": "____________________________________________________________________initializeDevToolsConnection",
    "LS0": "_initializeReactDevelopmentToolsConnection",
    "GJ1": "_____________________________________________________________________initializeDevToolsConnection",
    "Yx0": "__initializeDevelopmentToolsConnection",
    "Wx0": "______________________________________________________________________initializeDevToolsConnection",
    "Ll9": "_______________initializeReactDevToolsConnection",
    "hl9": "initializeColorTools",
    "qp9": "parseAndMapSemver",
    "w_0": "___initializeDevelopmentToolsConnection",
    "bp9": "________________initializeReactDevToolsConnection",
    "pp9": "getSharpLibvipsIncludeDir",
    "ip9": "getSharpLibvipsLibDir",
    "l": "borderTextConfig",
    "b": "leftBorderContent",
    "x": "rightBorderString",
    "n": "bottomBorder",
    "o": "isTopBorderValue",
    "Zi9": "initializeColorComponents",
    "pc9": "_parseVersion",
    "Gp9": "_______________________________________________________________________initializeDevToolsConnection",
    "Zp9": "compareValuesUsingOperator",
    "Yp9": "compareValuesWithGreaterThan",
    "Jp9": "initializeReactDevToolsComparisonConnection",
    "Xp9": "compareValuesUsingLessThan",
    "Wp9": "initializeConnectionForLessThanOrEqual",
    "hS0": "renderScreenOutput",
    "gS0": "processOutputAndStyles",
    "NS0": "processStyledStringArray",
    "sc9": "_isEqualToZero",
    "oc9": "_isNotEqualToZero",
    "nc9": "isDevToolsConnectionSuccessful",
    "Ip9": "isQueryResultLessThanOrEqualToZero",
    "ec9": "isValueGreaterThanZero",
    "Bp9": "isValueLessThanZero",
    "FY1": "________________________________________________________________________initializeDevToolsConnection",
    "Ol9": "createInputImage",
    "UY1": "TerminalRenderer",
    "$_0": "minLibvipsVersion",
    "sp9": "calculateLibvipsIdentifier",
    "QJA": "TextRenderer",
    "ZJ1": "compareSemver",
    "m": "bottomBorderColoredOutput",
    "Fp9": "_compareValuesBasedOnOperator",
    "gl9": "setRotationOptions",
    "Ki9": "setBackgroundColor",
    "SS0": "__________________________________________________________________________________initializeDevToolsConnection",
    "dS0": "processAndDisplayElements",
    "op9": "checkGlobalLibvipsAvailability",
    "VY1": "createTerminalRenderer",
    "kPA": "TerminalController",
    "kd9": "___________________________________________________________________________________initializeDevToolsConnection",
    "_d9": "____________________________________________________________________________________initializeDevToolsConnection",
    "kp9": "Kp9TestInstance",
    "_p9": "_testInputAgainstKP9",
    "Vc9": "_getCachedProcessReport",
    "Nk0": "_fetchGlibcVersionInfo",
    "Lk0": "_getGlibcVersionSync",
    "Pk0": "detectLibcFamilyAsync",
    "jk0": "getLibraryImplementationSync",
    "Nc9": "___fetchGlibcVersion",
    "Lc9": "__getGlibcVersionSync",
    "Uc9": "isNonGlibcLinuxAsync",
    "wc9": "isNonGlibcLinuxSync",
    "pY1": "processAsyncData"
  },
  "partialCode": "var devToolsInitialization = {};\nvar devToolsConnection;\nvar _______________________________initializeDevToolsConnection = T(() => {\n  rj0();\n  devToolsConnection = IA(oj0(), 1);\n  devToolsConnection.default.connectToDevTools();\n});\nvar rendererInstance;\nvar getDifferenceBetweenTwoObjects = (mergeObjects, mergeObjectDifferences) => {\n  if (mergeObjects === mergeObjectDifferences) {\n    return;\n  }\n  if (!mergeObjects) {\n    return mergeObjectDifferences;\n  }\n  let diffObjectProperties = {};\n  let hasChanges = false;\n  for (let __propertyKey of Object.keys(mergeObjects)) {\n    if (mergeObjectDifferences ? !Object.hasOwn(mergeObjectDifferences, __propertyKey) : true) {\n      diffObjectProperties[__propertyKey] = undefined;\n      hasChanges = true;\n    }\n  }\n  if (mergeObjectDifferences) {\n    for (let key of Object.keys(mergeObjectDifferences)) {\n      if (mergeObjectDifferences[key] !== mergeObjects[key]) {\n        diffObjectProperties[key] = mergeObjectDifferences[key];\n        hasChanges = true;\n      }\n    }\n  }\n  if (hasChanges) {\n    return diffObjectProperties;\n  } else {\n    return undefined;\n  }\n};\nvar cleanupYogaNode = measureOperations => {\n  measureOperations?.unsetMeasureFunc();\n  measureOperations?.freeRecursive();\n};\nvar renderComponent;\nvar initializeRendererInstance = T(() => {\n  Ej0();\n  wi();\n  ZPA();\n  sj0();\n  rendererInstance = IA(Dj0(), 1);\n  if (process.env.DEV === \"true\") {\n    try {\n      Promise.resolve().then(() => _______________________________initializeDevToolsConnection());\n    } catch (_error) {\n      if (_error.code === \"ERR_MODULE_NOT_FOUND\") {\n        console.warn(`${`\nThe environment variable DEV is set to true, so Ink tried to import \\`react-devtools-core\\`,\nbut this failed as it was not installed. Debugging with React Devtools requires it.\n\nTo install use this command:\n\n$ npm install --save-dev react-devtools-core\n\t\t\t\t`.trim()}\n`);\n      } else {\n        throw _error;\n      }\n    }\n  }\n  renderComponent = rendererInstance.default({\n    getRootHostContext: () => ({\n      isInsideText: false\n    }),\n    prepareForCommit: () => null,\n    preparePortalMount: () => null,\n    clearContainer: () => false,\n    resetAfterCommit(renderCoordinator) {\n      if (typeof renderCoordinator.onComputeLayout === \"function\") {\n        renderCoordinator.onComputeLayout();\n      }\n      if (renderCoordinator.isStaticDirty) {\n        renderCoordinator.isStaticDirty = false;\n        if (typeof renderCoordinator.onImmediateRender === \"function\") {\n          renderCoordinator.onImmediateRender();\n        }\n        return;\n      }\n      renderCoordinator.onRender?.();\n    },\n    getChildHostContext(getChildHostContext, childContextType) {\n      let isInsideTextMatchingCondition = getChildHostContext.isInsideText;\n      let isTextContext = childContextType === \"ink-text\" || childContextType === \"ink-virtual-text\";\n      if (isInsideTextMatchingCondition === isTextContext) {\n        return getChildHostContext;\n      }\n      return {\n        isInsideText: isTextContext\n      };\n    },\n    shouldSetTextContent: () => false,\n    createInstance(createComponentInstance, componentProps, createInstanceFromProps, parentComponent) {\n      if (parentComponent.isInsideText && createComponentInstance === \"ink-box\") {\n        throw Error(\"<Box> can’t be nested inside <Text> component\");\n      }\n      let determinedComponentType = createComponentInstance === \"ink-text\" && parentComponent.isInsideText ? \"ink-virtual-text\" : createComponentInstance;\n      let instance = QPA(determinedComponentType);\n      for (let [propertyKey, value] of Object.entries(componentProps)) {\n        if (propertyKey === \"children\") {\n          continue;\n        }\n        if (propertyKey === \"style\") {\n          cZ1(instance, value);\n          if (instance.yogaNode) {\n            pZ1(instance.yogaNode, value);\n          }\n          continue;\n        }\n        if (propertyKey === \"internal_transform\") {\n          instance.internal_transform = value;\n          continue;\n        }\n        if (propertyKey === \"internal_static\") {\n          instance.internal_static = true;\n          continue;\n        }\n        dZ1(instance, propertyKey, value);\n      }\n      return instance;\n    },\n    createTextInstance(createTextInstance, textInstance, isTextComponentValid) {\n      if (!isTextComponentValid.isInsideText) {\n        throw Error(`Text string \"${createTextInstance}\" must be rendered inside <Text> component`);\n      }\n      return nj0(createTextInstance);\n    },\n    resetTextContent() {},\n    hideTextInstance(hideTextContent) {\n      eYA(hideTextContent, \"\");\n    },\n    unhideTextInstance(unhideTextInstance, textUnhideInstance) {\n      eYA(unhideTextInstance, textUnhideInstance);\n    },\n    getPublicInstance: defaultFunction => defaultFunction,\n    hideInstance(hideYogaNode) {\n      hideYogaNode.yogaNode?.setDisplay(TM.None);\n    },\n    unhideInstance(setYogaNodeDisplay) {\n      setYogaNodeDisplay.yogaNode?.setDisplay(TM.Flex);\n    },\n    appendInitialChild: IPA,\n    appendChild: IPA,\n    insertBefore: mZ1,\n    finalizeInitialChildren(finalizeInitialChildren, updateStaticNodeIfNecessary, isInitialChildrenFinalized, initialChildrenUpdater) {\n      if (finalizeInitialChildren.internal_static) {\n        initialChildrenUpdater.isStaticDirty = true;\n        initialChildrenUpdater.staticNode = finalizeInitialChildren;\n      }\n      return false;\n    },\n    isPrimaryRenderer: true,\n    supportsMutation: true,\n    supportsPersistence: false,\n    supportsHydration: false,\n    scheduleTimeout: setTimeout,\n    cancelTimeout: clearTimeout,\n    noTimeout: -1,\n    getCurrentEventPriority: () => RZ1,\n    beforeActiveInstanceBlur() {},\n    afterActiveInstanceBlur() {},\n    detachDeletedInstance() {},\n    getInstanceFromNode: () => null,\n    prepareScopeUpdate() {},\n    getInstanceFromScope: () => null,\n    appendChildToContainer: IPA,\n    insertInContainerBefore: mZ1,\n    removeChildFromContainer(_removeChildFromContainer, childElement) {\n      tYA(_removeChildFromContainer, childElement);\n      cleanupYogaNode(childElement.yogaNode);\n    },\n    prepareUpdate(prepareUpdateBasedOnInternalState, calculateDifferenceBetweenStates, previousState, _previousState, internalStateUpdate) {\n      if (prepareUpdateBasedOnInternalState.internal_static) {\n        internalStateUpdate.isStaticDirty = true;\n      }\n      let differenceBetweenStates = getDifferenceBetweenTwoObjects(previousState, _previousState);\n      let styleDifference = getDifferenceBetweenTwoObjects(previousState.style, _previousState.style);\n      if (!differenceBetweenStates && !styleDifference) {\n        return null;\n      }\n      return {\n        props: differenceBetweenStates,\n        style: styleDifference\n      };\n    },\n    commitUpdate(commitUpdateComponent, _componentProps) {\n      let {\n        props: props,\n        style: styleObject\n      } = _componentProps;\n      if (props) {\n        for (let [_propertyKey, styleOrTransformOrStaticValue] of Object.entries(props)) {\n          if (_propertyKey === \"style\") {\n            cZ1(commitUpdateComponent, styleOrTransformOrStaticValue);\n            continue;\n          }\n          if (_propertyKey === \"internal_transform\") {\n            commitUpdateComponent.internal_transform = styleOrTransformOrStaticValue;\n            continue;\n          }\n          if (_propertyKey === \"internal_static\") {\n            commitUpdateComponent.internal_static = true;\n            continue;\n          }\n          dZ1(commitUpdateComponent, _propertyKey, styleOrTransformOrStaticValue);\n        }\n      }\n      if (styleObject && commitUpdateComponent.yogaNode) {\n        pZ1(commitUpdateComponent.yogaNode, styleObject);\n      }\n    },\n    commitTextUpdate(commitTextUpdateTextContentUserIdCallback, updateCommitText, _updateCommitText) {\n      eYA(commitTextUpdateTextContentUserIdCallback, _updateCommitText);\n    },\n    removeChild(removeChildFromYogaNode, removeChildFromNode) {\n      tYA(removeChildFromYogaNode, removeChildFromNode);\n      cleanupYogaNode(removeChildFromNode.yogaNode);\n    }\n  });\n});\nfunction indentStringLines(inputString, indentationLevel = 1, ____options = {}) {\n  let {\n    indent: indentCharacter = \" \",\n    includeEmptyLines = false\n  } = ____options;\n  if (typeof inputString !== \"string\") {\n    throw TypeError(`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof inputString}\\``);\n  }\n  if (typeof indentationLevel !== \"number\") {\n    throw TypeError(`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof indentationLevel}\\``);\n  }\n  if (indentationLevel < 0) {\n    throw RangeError(`Expected \\`count\\` to be at least 0, got \\`${indentationLevel}\\``);\n  }\n  if (typeof indentCharacter !== \"string\") {\n    throw TypeError(`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof indentCharacter}\\``);\n  }\n  if (indentationLevel === 0) {\n    return inputString;\n  }\n  let lineMatchingRegex = includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n  return inputString.replace(lineMatchingRegex, indentCharacter.repeat(indentationLevel));\n}\nvar getComputedWidthMinusPaddingAndBorders = calculateAvailableWidth => {\n  return calculateAvailableWidth.getComputedWidth() - calculateAvailableWidth.getComputedPadding(l8.Left) - calculateAvailableWidth.getComputedPadding(l8.Right) - calculateAvailableWidth.getComputedBorder(l8.Left) - calculateAvailableWidth.getComputedBorder(l8.Right);\n};\nvar calculateElementWidth;\nvar initializeCalculationForElementWidth = T(() => {\n  wi();\n  calculateElementWidth = getComputedWidthMinusPaddingAndBorders;\n});\nvar borderStyles = z((generateBoxStyles, renderStylishBorders) => {\n  renderStylishBorders.exports = {\n    single: {\n      topLeft: \"┌\",\n      top: \"─\",\n      topRight: \"┐\",\n      right: \"│\",\n      bottomRight: \"┘\",\n      bottom: \"─\",\n      bottomLeft: \"└\",\n      left: \"│\"\n    },\n    double: {\n      topLeft: \"╔\",\n      top: \"═\",\n      topRight: \"╗\",\n      right: \"║\",\n      bottomRight: \"╝\",\n      bottom: \"═\",\n      bottomLeft: \"╚\",\n      left: \"║\"\n    },\n    round: {\n      topLeft: \"╭\",\n      top: \"─\",\n      topRight: \"╮\",\n      right: \"│\",\n      bottomRight: \"╯\",\n      bottom: \"─\",\n      bottomLeft: \"╰\",\n      left: \"│\"\n    },\n    bold: {\n      topLeft: \"┏\",\n      top: \"━\",\n      topRight: \"┓\",\n      right: \"┃\",\n      bottomRight: \"┛\",\n      bottom: \"━\",\n      bottomLeft: \"┗\",\n      left: \"┃\"\n    },\n    singleDouble: {\n      topLeft: \"╓\",\n      top: \"─\",\n      topRight: \"╖\",\n      right: \"║\",\n      bottomRight: \"╜\",\n      bottom: \"─\",\n      bottomLeft: \"╙\",\n      left: \"║\"\n    },\n    doubleSingle: {\n      topLeft: \"╒\",\n      top: \"═\",\n      topRight: \"╕\",\n      right: \"│\",\n      bottomRight: \"╛\",\n      bottom: \"═\",\n      bottomLeft: \"╘\",\n      left: \"│\"\n    },\n    classic: {\n      topLeft: \"+\",\n      top: \"-\",\n      topRight: \"+\",\n      right: \"|\",\n      bottomRight: \"+\",\n      bottom: \"-\",\n      bottomLeft: \"+\",\n      left: \"|\"\n    },\n    arrow: {\n      topLeft: \"↘\",\n      top: \"↓\",\n      topRight: \"↙\",\n      right: \"←\",\n      bottomRight: \"↖\",\n      bottom: \"↑\",\n      bottomLeft: \"↗\",\n      left: \"→\"\n    }\n  };\n});\nvar ___initializeReactDevTools = z((getBorderStyles, borderStylesExport) => {\n  var borderStylesDefinition = borderStyles();\n  borderStylesExport.exports = borderStylesDefinition;\n  borderStylesExport.exports.default = borderStylesDefinition;\n});\nfunction getColorPaletteBasedOnScheme(colorScheme) {\n  switch (colorScheme) {\n    case \"light\":\n      return colorPalette;\n    case \"light-ansi\":\n      return lightAnsiColor;\n    case \"dark-ansi\":\n      return darkAnsiColors;\n    case \"light-daltonized\":\n      return lightDaltonizedColor;\n    case \"dark-daltonized\":\n      return areaDarkenedColorTheme;\n    default:\n      return getDefaultColorPalette;\n  }\n}\nvar colorPalette;\nvar lightAnsiColor;\nvar darkAnsiColors;\nvar lightDaltonizedColor;\nvar getDefaultColorPalette;\nvar areaDarkenedColorTheme;\nvar loadColorPalette = T(() => {\n  colorPalette = {\n    autoAccept: \"rgb(135,0,255)\",\n    bashBorder: \"rgb(255,0,135)\",\n    claude: \"rgb(215,119,87)\",\n    claudeShimmer: \"rgb(245,149,117)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(87,105,247)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(117,135,255)\",\n    permission: \"rgb(87,105,247)\",\n    permissionShimmer: \"rgb(137,155,255)\",\n    planMode: \"rgb(0,102,102)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(153,153,153)\",\n    promptBorderShimmer: \"rgb(183,183,183)\",\n    text: \"rgb(0,0,0)\",\n    inverseText: \"rgb(255,255,255)\",\n    inactive: \"rgb(102,102,102)\",\n    subtle: \"rgb(175,175,175)\",\n    suggestion: \"rgb(87,105,247)\",\n    remember: \"rgb(0,0,255)\",\n    background: \"rgb(0,153,153)\",\n    success: \"rgb(44,122,57)\",\n    error: \"rgb(171,43,63)\",\n    warning: \"rgb(150,108,30)\",\n    warningShimmer: \"rgb(200,158,80)\",\n    diffAdded: \"rgb(105,219,124)\",\n    diffRemoved: \"rgb(255,168,180)\",\n    diffAddedDimmed: \"rgb(199,225,203)\",\n    diffRemovedDimmed: \"rgb(253,210,216)\",\n    diffAddedWord: \"rgb(47,157,68)\",\n    diffRemovedWord: \"rgb(209,69,75)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(220,38,38)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(37,99,235)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(22,163,74)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(202,138,4)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(147,51,234)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(234,88,12)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(219,39,119)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(8,145,178)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(240, 240, 240)\",\n    bashMessageBackgroundColor: \"rgb(250, 245, 250)\",\n    memoryBackgroundColor: \"rgb(230, 245, 250)\",\n    rate_limit_fill: \"rgb(87,105,247)\",\n    rate_limit_empty: \"rgb(39,47,111)\"\n  };\n  lightAnsiColor = {\n    autoAccept: \"ansi:magenta\",\n    bashBorder: \"ansi:magenta\",\n    claude: \"ansi:redBright\",\n    claudeShimmer: \"ansi:yellowBright\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"ansi:blue\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"ansi:blueBright\",\n    permission: \"ansi:blue\",\n    permissionShimmer: \"ansi:blueBright\",\n    planMode: \"ansi:cyan\",\n    ide: \"ansi:blueBright\",\n    promptBorder: \"ansi:white\",\n    promptBorderShimmer: \"ansi:whiteBright\",\n    text: \"ansi:black\",\n    inverseText: \"ansi:white\",\n    inactive: \"ansi:blackBright\",\n    subtle: \"ansi:blackBright\",\n    suggestion: \"ansi:blue\",\n    remember: \"ansi:blue\",\n    background: \"ansi:cyan\",\n    success: \"ansi:green\",\n    error: \"ansi:red\",\n    warning: \"ansi:yellow\",\n    warningShimmer: \"ansi:yellowBright\",\n    diffAdded: \"ansi:green\",\n    diffRemoved: \"ansi:red\",\n    diffAddedDimmed: \"ansi:green\",\n    diffRemovedDimmed: \"ansi:red\",\n    diffAddedWord: \"ansi:greenBright\",\n    diffRemovedWord: \"ansi:redBright\",\n    red_FOR_SUBAGENTS_ONLY: \"ansi:red\",\n    blue_FOR_SUBAGENTS_ONLY: \"ansi:blue\",\n    green_FOR_SUBAGENTS_ONLY: \"ansi:green\",\n    yellow_FOR_SUBAGENTS_ONLY: \"ansi:yellow\",\n    purple_FOR_SUBAGENTS_ONLY: \"ansi:magenta\",\n    orange_FOR_SUBAGENTS_ONLY: \"ansi:redBright\",\n    pink_FOR_SUBAGENTS_ONLY: \"ansi:magentaBright\",\n    cyan_FOR_SUBAGENTS_ONLY: \"ansi:cyan\",\n    professionalBlue: \"ansi:blueBright\",\n    rainbow_red: \"ansi:red\",\n    rainbow_orange: \"ansi:redBright\",\n    rainbow_yellow: \"ansi:yellow\",\n    rainbow_green: \"ansi:green\",\n    rainbow_blue: \"ansi:cyan\",\n    rainbow_indigo: \"ansi:blue\",\n    rainbow_violet: \"ansi:magenta\",\n    rainbow_red_shimmer: \"ansi:redBright\",\n    rainbow_orange_shimmer: \"ansi:yellow\",\n    rainbow_yellow_shimmer: \"ansi:yellowBright\",\n    rainbow_green_shimmer: \"ansi:greenBright\",\n    rainbow_blue_shimmer: \"ansi:cyanBright\",\n    rainbow_indigo_shimmer: \"ansi:blueBright\",\n    rainbow_violet_shimmer: \"ansi:magentaBright\",\n    clawd_body: \"ansi:redBright\",\n    clawd_background: \"ansi:black\",\n    userMessageBackground: \"ansi:white\",\n    bashMessageBackgroundColor: \"ansi:whiteBright\",\n    memoryBackgroundColor: \"ansi:white\",\n    rate_limit_fill: \"ansi:yellow\",\n    rate_limit_empty: \"ansi:black\"\n  };\n  darkAnsiColors = {\n    autoAccept: \"ansi:magentaBright\",\n    bashBorder: \"ansi:magentaBright\",\n    claude: \"ansi:redBright\",\n    claudeShimmer: \"ansi:yellowBright\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"ansi:blueBright\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"ansi:blueBright\",\n    permission: \"ansi:blueBright\",\n    permissionShimmer: \"ansi:blueBright\",\n    planMode: \"ansi:cyanBright\",\n    ide: \"ansi:blue\",\n    promptBorder: \"ansi:white\",\n    promptBorderShimmer: \"ansi:whiteBright\",\n    text: \"ansi:whiteBright\",\n    inverseText: \"ansi:black\",\n    inactive: \"ansi:white\",\n    subtle: \"ansi:white\",\n    suggestion: \"ansi:blueBright\",\n    remember: \"ansi:blueBright\",\n    background: \"ansi:cyanBright\",\n    success: \"ansi:greenBright\",\n    error: \"ansi:redBright\",\n    warning: \"ansi:yellowBright\",\n    warningShimmer: \"ansi:yellowBright\",\n    diffAdded: \"ansi:green\",\n    diffRemoved: \"ansi:red\",\n    diffAddedDimmed: \"ansi:green\",\n    diffRemovedDimmed: \"ansi:red\",\n    diffAddedWord: \"ansi:greenBright\",\n    diffRemovedWord: \"ansi:redBright\",\n    red_FOR_SUBAGENTS_ONLY: \"ansi:redBright\",\n    blue_FOR_SUBAGENTS_ONLY: \"ansi:blueBright\",\n    green_FOR_SUBAGENTS_ONLY: \"ansi:greenBright\",\n    yellow_FOR_SUBAGENTS_ONLY: \"ansi:yellowBright\",\n    purple_FOR_SUBAGENTS_ONLY: \"ansi:magentaBright\",\n    orange_FOR_SUBAGENTS_ONLY: \"ansi:redBright\",\n    pink_FOR_SUBAGENTS_ONLY: \"ansi:magentaBright\",\n    cyan_FOR_SUBAGENTS_ONLY: \"ansi:cyanBright\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"ansi:red\",\n    rainbow_orange: \"ansi:redBright\",\n    rainbow_yellow: \"ansi:yellow\",\n    rainbow_green: \"ansi:green\",\n    rainbow_blue: \"ansi:cyan\",\n    rainbow_indigo: \"ansi:blue\",\n    rainbow_violet: \"ansi:magenta\",\n    rainbow_red_shimmer: \"ansi:redBright\",\n    rainbow_orange_shimmer: \"ansi:yellow\",\n    rainbow_yellow_shimmer: \"ansi:yellowBright\",\n    rainbow_green_shimmer: \"ansi:greenBright\",\n    rainbow_blue_shimmer: \"ansi:cyanBright\",\n    rainbow_indigo_shimmer: \"ansi:blueBright\",\n    rainbow_violet_shimmer: \"ansi:magentaBright\",\n    clawd_body: \"ansi:redBright\",\n    clawd_background: \"ansi:black\",\n    userMessageBackground: \"ansi:blackBright\",\n    bashMessageBackgroundColor: \"ansi:black\",\n    memoryBackgroundColor: \"ansi:blackBright\",\n    rate_limit_fill: \"ansi:yellow\",\n    rate_limit_empty: \"ansi:white\"\n  };\n  lightDaltonizedColor = {\n    autoAccept: \"rgb(135,0,255)\",\n    bashBorder: \"rgb(0,102,204)\",\n    claude: \"rgb(255,153,51)\",\n    claudeShimmer: \"rgb(255,183,101)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(51,102,255)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(101,152,255)\",\n    permission: \"rgb(51,102,255)\",\n    permissionShimmer: \"rgb(101,152,255)\",\n    planMode: \"rgb(51,102,102)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(153,153,153)\",\n    promptBorderShimmer: \"rgb(183,183,183)\",\n    text: \"rgb(0,0,0)\",\n    inverseText: \"rgb(255,255,255)\",\n    inactive: \"rgb(102,102,102)\",\n    subtle: \"rgb(175,175,175)\",\n    suggestion: \"rgb(51,102,255)\",\n    remember: \"rgb(51,102,255)\",\n    background: \"rgb(0,153,153)\",\n    success: \"rgb(0,102,153)\",\n    error: \"rgb(204,0,0)\",\n    warning: \"rgb(255,153,0)\",\n    warningShimmer: \"rgb(255,183,50)\",\n    diffAdded: \"rgb(153,204,255)\",\n    diffRemoved: \"rgb(255,204,204)\",\n    diffAddedDimmed: \"rgb(209,231,253)\",\n    diffRemovedDimmed: \"rgb(255,233,233)\",\n    diffAddedWord: \"rgb(51,102,204)\",\n    diffRemovedWord: \"rgb(153,51,51)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(204,0,0)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(0,102,204)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(0,204,0)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(255,204,0)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(128,0,128)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(255,128,0)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(255,102,178)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(0,178,178)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(220, 220, 220)\",\n    bashMessageBackgroundColor: \"rgb(250, 245, 250)\",\n    memoryBackgroundColor: \"rgb(230, 245, 250)\",\n    rate_limit_fill: \"rgb(51,102,255)\",\n    rate_limit_empty: \"rgb(23,46,114)\"\n  };\n  getDefaultColorPalette = {\n    autoAccept: \"rgb(175,135,255)\",\n    bashBorder: \"rgb(253,93,177)\",\n    claude: \"rgb(215,119,87)\",\n    claudeShimmer: \"rgb(235,159,127)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(147,165,255)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(177,195,255)\",\n    permission: \"rgb(177,185,249)\",\n    permissionShimmer: \"rgb(207,215,255)\",\n    planMode: \"rgb(72,150,140)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(136,136,136)\",\n    promptBorderShimmer: \"rgb(166,166,166)\",\n    text: \"rgb(255,255,255)\",\n    inverseText: \"rgb(0,0,0)\",\n    inactive: \"rgb(153,153,153)\",\n    subtle: \"rgb(80,80,80)\",\n    suggestion: \"rgb(177,185,249)\",\n    remember: \"rgb(177,185,249)\",\n    background: \"rgb(0,204,204)\",\n    success: \"rgb(78,186,101)\",\n    error: \"rgb(255,107,128)\",\n    warning: \"rgb(255,193,7)\",\n    warningShimmer: \"rgb(255,223,57)\",\n    diffAdded: \"rgb(34,92,43)\",\n    diffRemoved: \"rgb(122,41,54)\",\n    diffAddedDimmed: \"rgb(71,88,74)\",\n    diffRemovedDimmed: \"rgb(105,72,77)\",\n    diffAddedWord: \"rgb(56,166,96)\",\n    diffRemovedWord: \"rgb(179,89,107)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(220,38,38)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(37,99,235)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(22,163,74)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(202,138,4)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(147,51,234)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(234,88,12)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(219,39,119)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(8,145,178)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(55, 55, 55)\",\n    bashMessageBackgroundColor: \"rgb(65, 60, 65)\",\n    memoryBackgroundColor: \"rgb(55, 65, 70)\",\n    rate_limit_fill: \"rgb(177,185,249)\",\n    rate_limit_empty: \"rgb(80,83,112)\"\n  };\n  areaDarkenedColorTheme = {\n    autoAccept: \"rgb(175,135,255)\",\n    bashBorder: \"rgb(51,153,255)\",\n    claude: \"rgb(255,153,51)\",\n    claudeShimmer: \"rgb(255,183,101)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(153,204,255)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(183,224,255)\",\n    permission: \"rgb(153,204,255)\",\n    permissionShimmer: \"rgb(183,224,255)\",\n    planMode: \"rgb(102,153,153)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(136,136,136)\",\n    promptBorderShimmer: \"rgb(166,166,166)\",\n    text: \"rgb(255,255,255)\",\n    inverseText: \"rgb(0,0,0)\",\n    inactive: \"rgb(153,153,153)\",\n    subtle: \"rgb(80,80,80)\",\n    suggestion: \"rgb(153,204,255)\",\n    remember: \"rgb(153,204,255)\",\n    background: \"rgb(0,204,204)\",\n    success: \"rgb(51,153,255)\",\n    error: \"rgb(255,102,102)\",\n    warning: \"rgb(255,204,0)\",\n    warningShimmer: \"rgb(255,234,50)\",\n    diffAdded: \"rgb(0,68,102)\",\n    diffRemoved: \"rgb(102,0,0)\",\n    diffAddedDimmed: \"rgb(62,81,91)\",\n    diffRemovedDimmed: \"rgb(62,44,44)\",\n    diffAddedWord: \"rgb(0,119,179)\",\n    diffRemovedWord: \"rgb(179,0,0)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(255,102,102)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(102,178,255)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(102,255,102)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(255,255,102)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(178,102,255)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(255,178,102)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(255,153,204)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(102,204,204)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(55, 55, 55)\",\n    bashMessageBackgroundColor: \"rgb(65, 60, 65)\",\n    memoryBackgroundColor: \"rgb(55, 65, 70)\",\n    rate_limit_fill: \"rgb(153,204,255)\",\n    rate_limit_empty: \"rgb(69,92,115)\"\n  };\n});\nfunction formatColorBasedOnActivity(isActive, valueBasedOnA, colorFormatType = \"foreground\") {\n  return _colorFormatter => colorFormatter(_colorFormatter, isActive ? getColorPaletteBasedOnScheme(valueBasedOnA)[isActive] : undefined, colorFormatType);\n}\nvar colorRegexPattern;\nvar ansiColorRegex;\nvar colorFormatter = (applyColorBasedOnFormatting, colorSpecifier, colorContext) => {\n  if (!colorSpecifier) {\n    return applyColorBasedOnFormatting;\n  }\n  if (colorSpecifier.startsWith(\"ansi:\")) {\n    switch (colorSpecifier.substring(5)) {\n      case \"black\":\n        if (colorContext === \"foreground\") {\n          return iA.black(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgBlack(applyColorBasedOnFormatting);\n        }\n      case \"red\":\n        if (colorContext === \"foreground\") {\n          return iA.red(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgRed(applyColorBasedOnFormatting);\n        }\n      case \"green\":\n        if (colorContext === \"foreground\") {\n          return iA.green(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgGreen(applyColorBasedOnFormatting);\n        }\n      case \"yellow\":\n        if (colorContext === \"foreground\") {\n          return iA.yellow(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgYellow(applyColorBasedOnFormatting);\n        }\n      case \"blue\":\n        if (colorContext === \"foreground\") {\n          return iA.blue(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgBlue(applyColorBasedOnFormatting);\n        }\n      case \"magenta\":\n        if (colorContext === \"foreground\") {\n          return iA.magenta(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgMagenta(applyColorBasedOnFormatting);\n        }\n      case \"cyan\":\n        if (colorContext === \"foreground\") {\n          return iA.cyan(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgCyan(applyColorBasedOnFormatting);\n        }\n      case \"white\":\n        if (colorContext === \"foreground\") {\n          return iA.white(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgWhite(applyColorBasedOnFormatting);\n        }\n      case \"blackBright\":\n        if (colorContext === \"foreground\") {\n          return iA.blackBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgBlackBright(applyColorBasedOnFormatting);\n        }\n      case \"redBright\":\n        if (colorContext === \"foreground\") {\n          return iA.redBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgRedBright(applyColorBasedOnFormatting);\n        }\n      case \"greenBright\":\n        if (colorContext === \"foreground\") {\n          return iA.greenBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgGreenBright(applyColorBasedOnFormatting);\n        }\n      case \"yellowBright\":\n        if (colorContext === \"foreground\") {\n          return iA.yellowBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgYellowBright(applyColorBasedOnFormatting);\n        }\n      case \"blueBright\":\n        if (colorContext === \"foreground\") {\n          return iA.blueBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgBlueBright(applyColorBasedOnFormatting);\n        }\n      case \"magentaBright\":\n        if (colorContext === \"foreground\") {\n          return iA.magentaBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgMagentaBright(applyColorBasedOnFormatting);\n        }\n      case \"cyanBright\":\n        if (colorContext === \"foreground\") {\n          return iA.cyanBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgCyanBright(applyColorBasedOnFormatting);\n        }\n      case \"whiteBright\":\n        if (colorContext === \"foreground\") {\n          return iA.whiteBright(applyColorBasedOnFormatting);\n        } else {\n          return iA.bgWhiteBright(applyColorBasedOnFormatting);\n        }\n    }\n  }\n  if (colorSpecifier.startsWith(\"#\")) {\n    if (colorContext === \"foreground\") {\n      return iA.hex(colorSpecifier)(applyColorBasedOnFormatting);\n    } else {\n      return iA.bgHex(colorSpecifier)(applyColorBasedOnFormatting);\n    }\n  }\n  if (colorSpecifier.startsWith(\"ansi256\")) {\n    let _colorMatchResult = ansiColorRegex.exec(colorSpecifier);\n    if (!_colorMatchResult) {\n      return applyColorBasedOnFormatting;\n    }\n    let _______colorValue = Number(_colorMatchResult[1]);\n    if (colorContext === \"foreground\") {\n      return iA.ansi256(_______colorValue)(applyColorBasedOnFormatting);\n    } else {\n      return iA.bgAnsi256(_______colorValue)(applyColorBasedOnFormatting);\n    }\n  }\n  if (colorSpecifier.startsWith(\"rgb\")) {\n    let match = colorRegexPattern.exec(colorSpecifier);\n    if (!match) {\n      return applyColorBasedOnFormatting;\n    }\n    let ________colorValue = Number(match[1]);\n    let blueValue = Number(match[2]);\n    let ____blueChannel = Number(match[3]);\n    if (colorContext === \"foreground\") {\n      return iA.rgb(________colorValue, blueValue, ____blueChannel)(applyColorBasedOnFormatting);\n    } else {\n      return iA.bgRgb(________colorValue, blueValue, ____blueChannel)(applyColorBasedOnFormatting);\n    }\n  }\n  return applyColorBasedOnFormatting;\n};\nvar ________________________________initializeDevToolsConnection = T(() => {\n  f2();\n  loadColorPalette();\n  colorRegexPattern = /^rgb\\(\\s?(\\d+),\\s?(\\d+),\\s?(\\d+)\\s?\\)$/;\n  ansiColorRegex = /^ansi256\\(\\s?(\\d+)\\s?\\)$/;\n});\nfunction formatStringWithPadding(sourceString, __inputString, alignmentPosition, inputStringOffset = 0, paddingCharacter) {\n  let inputStringLength = k7(__inputString);\n  let _inputStringLength = sourceString.length;\n  if (inputStringLength >= _inputStringLength - 2) {\n    return __inputString.substring(0, _inputStringLength);\n  }\n  let alignmentIndex;\n  if (alignmentPosition === \"center\") {\n    alignmentIndex = Math.floor((_inputStringLength - inputStringLength) / 2);\n  } else if (alignmentPosition === \"start\") {\n    alignmentIndex = inputStringOffset + 1;\n  } else {\n    alignmentIndex = _inputStringLength - inputStringLength - inputStringOffset - 1;\n  }\n  alignmentIndex = Math.max(1, Math.min(alignmentIndex, _inputStringLength - inputStringLength - 1));\n  let paddingPrefix = paddingCharacter.repeat(alignmentIndex - 1);\n  let rightPadding = paddingCharacter.repeat(_inputStringLength - alignmentIndex - inputStringLength - 1);\n  return sourceString.substring(0, 1) + paddingPrefix + __inputString + rightPadding + sourceString.substring(sourceString.length - 1);\n}\nvar borderStyleMap;\nvar _borderStyleMap;\nvar renderWithBorders = (renderBorderWithText, borderBaseWriteFunction, borderElement, borderWriter, borderColorActivity) => {\n  if (borderElement.style.borderStyle) {\n    let computedWidth = Math.floor(borderElement.yogaNode.getComputedWidth());\n    let computedHeight = Math.floor(borderElement.yogaNode.getComputedHeight());\n    let borderStyleObject = typeof borderElement.style.borderStyle === \"string\" ? _borderStyleMap[borderElement.style.borderStyle] ?? borderStyleMap.default[borderElement.style.borderStyle] : borderElement.style.borderStyle;\n    let borderTopColor = borderElement.style.borderTopColor ?? borderElement.style.borderColor;\n    let borderBottomColor = borderElement.style.borderBottomColor ?? borderElement.style.borderColor;\n    let leftBorderColor = borderElement.style.borderLeftColor ?? borderElement.style.borderColor;\n    let borderRightColor = borderElement.style.borderRightColor ?? borderElement.style.borderColor;\n    let borderTopDimColor = borderElement.style.borderTopDimColor ?? borderElement.style.borderDimColor;\n    let borderBottomDimColor = borderElement.style.borderBottomDimColor ?? borderElement.style.borderDimColor;\n    let leftBorderDimColor = borderElement.style.borderLeftDimColor ?? borderElement.style.borderDimColor;\n    let borderRightDimColor = borderElement.style.borderRightDimColor ?? borderElement.style.borderDimColor;\n    let isTopBorderVisible = borderElement.style.borderTop !== false;\n    let hasBorderBottom = borderElement.style.borderBottom !== false;\n    let hasLeftBorder = borderElement.style.borderLeft !== false;\n    let isBorderRightEnabled = borderElement.style.borderRight !== false;\n    let borderOffset = computedWidth - (hasLeftBorder ? 1 : 0) - (isBorderRightEnabled ? 1 : 0);\n    let topBorder = isTopBorderVisible ? (hasLeftBorder ? borderStyleObject.topLeft : \"\") + borderStyleObject.top.repeat(borderOffset) + (isBorderRightEnabled ? borderStyleObject.topRight : \"\") : \"\";\n    if (isTopBorderVisible && borderElement.style.borderText?.position === \"top\") {\n      let borderTextDetails = borderElement.style.borderText;\n      topBorder = formatStringWithPadding(topBorder, borderTextDetails.content, borderTextDetails.align, borderTextDetails.offset, borderStyleObject.top);\n    }\n    let topBorderColoredOutput = isTopBorderVisible ? formatColorBasedOnActivity(borderTopColor, borderColorActivity)(topBorder) : undefined;\n    if (isTopBorderVisible && borderTopDimColor) {\n      topBorderColoredOutput = iA.dim(topBorderColoredOutput);\n    }\n    let heightAdjustment = computedHeight;\n    if (isTopBorderVisible) {\n      heightAdjustment -= 1;\n    }\n    if (hasBorderBottom) {\n      heightAdjustment -= 1;\n    }\n    let leftBorderContent = `${formatColorBasedOnActivity(leftBorderColor, borderColorActivity)(borderStyleObject.left)}\n`.repeat(heightAdjustment);\n    if (leftBorderDimColor) {\n      leftBorderContent = iA.dim(leftBorderContent);\n    }\n    let rightBorderString = `${formatColorBasedOnActivity(borderRightColor, borderColorActivity)(borderStyleObject.right)}\n`.repeat(heightAdjustment);\n    if (borderRightDimColor) {\n      rightBorderString = iA.dim(rightBorderString);\n    }\n    let bottomBorder = hasBorderBottom ? (hasLeftBorder ? borderStyleObject.bottomLeft : \"\") + borderStyleObject.bottom.repeat(borderOffset) + (isBorderRightEnabled ? borderStyleObject.bottomRight : \"\") : \"\";\n    if (hasBorderBottom && borderElement.style.borderText?.position === \"bottom\") {\n      let borderTextConfig = borderElement.style.borderText;\n      bottomBorder = formatStringWithPadding(bottomBorder, borderTextConfig.content, borderTextConfig.align, borderTextConfig.offset, borderStyleObject.bottom);\n    }\n    let bottomBorderColoredOutput = hasBorderBottom ? formatColorBasedOnActivity(borderBottomColor, borderColorActivity)(bottomBorder) : undefined;\n    if (hasBorderBottom && borderBottomDimColor) {\n      bottomBorderColoredOutput = iA.dim(bottomBorderColoredOutput);\n    }\n    let isTopBorderValue = isTopBorderVisible ? 1 : 0;\n    if (topBorderColoredOutput) {\n      borderWriter.write(renderBorderWithText, borderBaseWriteFunction, topBorderColoredOutput, {\n        transformers: []\n      });\n    }\n    if (hasLeftBorder) {\n      borderWriter.write(renderBorderWithText, borderBaseWriteFunction + isTopBorderValue, leftBorderContent, {\n        transformers: []\n      });\n    }\n    if (isBorderRightEnabled) {\n      borderWriter.write(renderBorderWithText + computedWidth - 1, borderBaseWriteFunction + isTopBorderValue, rightBorderString, {\n        transformers: []\n      });\n    }\n    if (bottomBorderColoredOutput) {\n      borderWriter.write(renderBorderWithText, borderBaseWriteFunction + computedHeight - 1, bottomBorderColoredOutput, {\n        transformers: []\n      });\n    }\n  }\n};\nvar Renderer;\nvar _________initializeReactDevToolsConnection = T(() => {\n  f2();\n  F0A();\n  ________________________________initializeDevToolsConnection();\n  borderStyleMap = IA(___initializeReactDevTools(), 1);\n  _borderStyleMap = {\n    dashed: {\n      top: \"╌\",\n      left: \"╎\",\n      right: \"╎\",\n      bottom: \"╌\",\n      topLeft: \" \",\n      topRight: \" \",\n      bottomLeft: \" \",\n      bottomRight: \" \"\n    }\n  };\n  Renderer = renderWithBorders;\n});\nvar formatTextWithIndentation = (formatNodePosition, applyIndentation) => {\n  let getYogaNodePosition = formatNodePosition.childNodes[0]?.yogaNode;\n  if (getYogaNodePosition) {\n    let computedLeft = getYogaNodePosition.getComputedLeft();\n    let computedTopValue = getYogaNodePosition.getComputedTop();\n    applyIndentation = `\n`.repeat(computedTopValue) + indentStringLines(applyIndentation, computedLeft);\n  }\n  return applyIndentation;\n};\nvar DS0 = (A, B, {\n  offsetX: horizontalOffset = 0,\n  offsetY: _offsetY = 0,\n  transformers: transformersArray = [],\n  skipStaticElements: skipStaticElements,\n  theme: themeStyle\n}) => {\n  if (skipStaticElements && A.internal_static) {\n    return;\n  }\n  let {\n    yogaNode: J\n  } = A;\n  if (J) {\n    if (J.getDisplay() === TM.None) {\n      return;\n    }\n    let X = horizontalOffset + J.getComputedLeft();\n    let W = _offsetY + J.getComputedTop();\n    let F = transformersArray;\n    if (typeof A.internal_transform === \"function\") {\n      F = [A.internal_transform, ...transformersArray];\n    }\n    if (A.nodeName === \"ink-text\") {\n      let processedTextNodes = BPA(A);\n      if (processedTextNodes.length > 0) {\n        let elementWidth = W0A(processedTextNodes);\n        let calculatedElementWidth = calculateElementWidth(J);\n        if (elementWidth > calculatedElementWidth) {\n          let textWrapStyle = A.style.textWrap ?? \"wrap\";\n          processedTextNodes = Th(processedTextNodes, calculatedElementWidth, textWrapStyle);\n        }\n        processedTextNodes = formatTextWithIndentation(A, processedTextNodes);\n        B.write(X, W, processedTextNodes, {\n          transformers: F\n        });\n      }\n      return;\n    }\n    let C = false;\n    if (A.nodeName === \"ink-box\") {\n      Renderer(X, W, A, B, themeStyle);\n      let childNode = A.style.overflowX === \"hidden\" || A.style.overflow === \"hidden\";\n      let formattedTextWidth = A.style.overflowY === \"hidden\" || A.style.overflow === \"hidden\";\n      if (childNode || formattedTextWidth) {\n        let _calculatedElementWidth = childNode ? X + J.getComputedBorder(l8.Left) : undefined;\n        let _textWrapStyle = childNode ? X + J.getComputedWidth() - J.getComputedBorder(l8.Right) : undefined;\n        let clipBoundaryConditions = formattedTextWidth ? W + J.getComputedBorder(l8.Top) : undefined;\n        let calculatedBottomY = formattedTextWidth ? W + J.getComputedHeight() - J.getComputedBorder(l8.Bottom) : undefined;\n        B.clip({\n          x1: _calculatedElementWidth,\n          x2: _textWrapStyle,\n          y1: clipBoundaryConditions,\n          y2: calculatedBottomY\n        });\n        C = true;\n      }\n    }\n    if (A.nodeName === \"ink-root\" || A.nodeName === \"ink-box\") {\n      for (let _childNode of A.childNodes) {\n        DS0(_childNode, B, {\n          offsetX: X,\n          offsetY: W,\n          transformers: F,\n          skipStaticElements: skipStaticElements,\n          theme: themeStyle\n        });\n      }\n      if (C) {\n        B.unclip();\n      }\n    }\n  }\n};\nvar processAndDisplayNodes;\nvar ES0 = T(() => {\n  sTA();\n  wi();\n  APA();\n  initializeCalculationForElementWidth();\n  gZ1();\n  _________initializeReactDevToolsConnection();\n  processAndDisplayNodes = DS0;\n});\nfunction isIntegerAndEven(numberIsTwoDivisors) {\n  if (!Number.isInteger(numberIsTwoDivisors)) {\n    return false;\n  }\n  return X0A(numberIsTwoDivisors) === 2;\n}\nvar initializeApplication = T(() => {\n  sYA();\n});\nfunction getColorRepresentation(inputColor) {\n  if (extractInputColorChannels.has(inputColor)) {\n    return inputColor;\n  }\n  if (colorMapping.has(inputColor)) {\n    return colorMapping.get(inputColor);\n  }\n  inputColor = inputColor.slice(2);\n  if (inputColor.includes(\";\")) {\n    inputColor = inputColor[0] + \"0\";\n  }\n  let ___colorCode = A3.codes.get(Number.parseInt(inputColor, 10));\n  if (___colorCode) {\n    return A3.color.ansi(___colorCode);\n  }\n  return A3.reset.open;\n}\nfunction findFirstValidCharacterIndex(findIndexOfValidCharacter) {\n  for (let validCharacterIndex = 0; validCharacterIndex < findIndexOfValidCharacter.length; validCharacterIndex++) {\n    let __characterCode = findIndexOfValidCharacter.codePointAt(validCharacterIndex);\n    if (__characterCode >= isInsideStatic && __characterCode <= maxDigit) {\n      return validCharacterIndex;\n    }\n  }\n  return -1;\n}\nfunction extractSubstringUntilValidCharacter(substringBasedOnIndex, _startIndex) {\n  substringBasedOnIndex = substringBasedOnIndex.slice(_startIndex, _startIndex + 19);\n  let firstValidCharacterIndex = findFirstValidCharacterIndex(substringBasedOnIndex);\n  if (firstValidCharacterIndex !== -1) {\n    let characterPosition = substringBasedOnIndex.indexOf(\"m\", firstValidCharacterIndex);\n    if (characterPosition === -1) {\n      characterPosition = substringBasedOnIndex.length;\n    }\n    return substringBasedOnIndex.slice(0, characterPosition + 1);\n  }\n}\nfunction parseStyledStringIntoComponents(_inputString, maxCharacterLimit = Number.POSITIVE_INFINITY) {\n  let styledStringComponents = [];\n  let ___________currentIndex = 0;\n  let totalCharacterWidth = 0;\n  while (___________currentIndex < _inputString.length) {\n    let characterCode = _inputString.codePointAt(___________currentIndex);\n    if (processDelayedReactComponent.has(characterCode)) {\n      let parseAnsiStyledString = extractSubstringUntilValidCharacter(_inputString, ___________currentIndex);\n      if (parseAnsiStyledString) {\n        styledStringComponents.push({\n          type: \"ansi\",\n          code: parseAnsiStyledString,\n          endCode: getColorRepresentation(parseAnsiStyledString)\n        });\n        ___________currentIndex += parseAnsiStyledString.length;\n        continue;\n      }\n    }\n    let isCharacterFullWidth = isIntegerAndEven(characterCode);\n    let _characterString = String.fromCodePoint(characterCode);\n    styledStringComponents.push({\n      type: \"character\",\n      value: _characterString,\n      isFullWidth: isCharacterFullWidth\n    });\n    ___________currentIndex += _characterString.length;\n    if (isCharacterFullWidth) {\n      totalCharacterWidth += 2;\n    } else {\n      totalCharacterWidth += _characterString.length;\n    }\n    if (totalCharacterWidth >= maxCharacterLimit) {\n      break;\n    }\n  }\n  return styledStringComponents;\n}\nfunction processColorChannelData(processColorChannels) {\n  let processedColorChannels = [];\n  for (let colorChannel of processColorChannels) {\n    if (colorChannel.code === A3.reset.open) {\n      processedColorChannels = [];\n    } else if (extractInputColorChannels.has(colorChannel.code)) {\n      processedColorChannels = processedColorChannels.filter(_isEndCodeDifferent => _isEndCodeDifferent.endCode !== colorChannel.code);\n    } else {\n      processedColorChannels = processedColorChannels.filter(isEndCodeDifferent => isEndCodeDifferent.endCode !== colorChannel.endCode);\n      processedColorChannels.push(colorChannel);\n    }\n  }\n  return processedColorChannels;\n}\nfunction getReversedEndCodeString(getReversedEndCodes) {\n  return processColorChannelData(getReversedEndCodes).map(({\n    endCode: endCode\n  }) => endCode).reverse().join(\"\");\n}\nfunction processFormattedString(generateFormattedString, minWidthThreshold, maxCharLimit) {\n  let _styledStringComponents = parseStyledStringIntoComponents(generateFormattedString, maxCharLimit);\n  let formattedStringComponents = [];\n  let processedCharacterCount = 0;\n  let formattedStringOutput = \"\";\n  let isFullWidthCharacterProcessed = false;\n  for (let character of _styledStringComponents) {\n    if (maxCharLimit !== undefined && processedCharacterCount >= maxCharLimit) {\n      break;\n    }\n    if (character.type === \"ansi\") {\n      formattedStringComponents.push(character);\n      if (isFullWidthCharacterProcessed) {\n        formattedStringOutput += character.code;\n      }\n    } else {\n      if (!isFullWidthCharacterProcessed && processedCharacterCount >= minWidthThreshold) {\n        isFullWidthCharacterProcessed = true;\n        formattedStringComponents = processColorChannelData(formattedStringComponents);\n        formattedStringOutput = formattedStringComponents.map(({\n          code: _____processInput\n        }) => _____processInput).join(\"\");\n      }\n      if (isFullWidthCharacterProcessed) {\n        formattedStringOutput += character.value;\n      }\n      if (character.isFullWidth) {\n        processedCharacterCount += 2;\n      } else {\n        processedCharacterCount += character.value.length;\n      }\n    }\n  }\n  formattedStringOutput += getReversedEndCodeString(formattedStringComponents);\n  return formattedStringOutput;\n}\nvar processDelayedReactComponent;\nvar isInsideStatic;\nvar maxDigit;\nvar extractInputColorChannels;\nvar colorMapping;\nvar ____________initializeDevelopmentTools = T(() => {\n  C0A();\n  initializeApplication();\n  processDelayedReactComponent = new Set([27, 155]);\n  isInsideStatic = \"0\".codePointAt(0);\n  maxDigit = \"9\".codePointAt(0);\n  extractInputColorChannels = new Set();\n  colorMapping = new Map();\n  for (let [colorCodePair, _colorChannelIndex] of A3.codes) {\n    extractInputColorChannels.add(A3.color.ansi(_colorChannelIndex));\n    colorMapping.set(A3.color.ansi(colorCodePair), A3.color.ansi(_colorChannelIndex));\n  }\n});\nfunction getColorCode(colorCode) {\n  if (colorManagementHelper.has(colorCode)) {\n    return colorCode;\n  }\n  if (colorManagementSystem.has(colorCode)) {\n    return colorManagementSystem.get(colorCode);\n  }\n  if (colorCode.startsWith(Foreground_Pen_Actions)) {\n    return formatText;\n  }\n  colorCode = colorCode.slice(2);\n  if (colorCode.startsWith(\"38\")) {\n    return A3.color.close;\n  } else if (colorCode.startsWith(\"48\")) {\n    return A3.bgColor.close;\n  }\n  let ansiColorCode = A3.codes.get(parseInt(colorCode, 10));\n  if (ansiColorCode) {\n    return A3.color.ansi(ansiColorCode);\n  } else {\n    return A3.reset.open;\n  }\n}\nfunction concatenateCodeFromArray(getConcatenatedCodes) {\n  return getConcatenatedCodes.map(exportedCode => exportedCode.code).join(\"\");\n}\nvar customTransformation;\nvar colorSettings;\nvar $S0;\nvar colorManagementHelper;\nvar colorManagementSystem;\nvar Foreground_Pen_Actions = \"\u001b]8;;\";\nvar processManagement;\nvar connectionSource = \"\u0007\";\nvar InputProcessor;\nvar formatText;\nvar initializeColorManagementSystem = T(() => {\n  C0A();\n  customTransformation = new Set([27, 155]);\n  colorSettings = \"[\".codePointAt(0);\n  $S0 = \"]\".codePointAt(0);\n  colorManagementHelper = new Set();\n  colorManagementSystem = new Map();\n  for (let [codePair, _colorCode] of A3.codes) {\n    colorManagementHelper.add(A3.color.ansi(_colorCode));\n    colorManagementSystem.set(A3.color.ansi(codePair), A3.color.ansi(_colorCode));\n  }\n  processManagement = Foreground_Pen_Actions.split(\"\").map(firstCharacterAsciiCode => firstCharacterAsciiCode.charCodeAt(0));\n  InputProcessor = connectionSource.charCodeAt(0);\n  formatText = `\\x1B]8;;${connectionSource}`;\n});\nfunction processCompoundPathAnalysisInput(______inputArray) {\n  return processCompoundPathAnalysis([], ______inputArray);\n}\nfunction processCompoundPathAnalysis(compoundPathAnalysis, styledElements) {\n  let processedPathAnalysis = [...compoundPathAnalysis];\n  for (let styledElement of styledElements) {\n    if (styledElement.code === A3.reset.open) {\n      processedPathAnalysis = [];\n    } else if (colorManagementHelper.has(styledElement.code)) {\n      processedPathAnalysis = processedPathAnalysis.filter(_isEndCodeMismatch => _isEndCodeMismatch.endCode !== styledElement.code);\n    } else if (styledElement.code === A3.bold.open || styledElement.code === A3.dim.open) {\n      if (!processedPathAnalysis.find(areCodesMatching => areCodesMatching.code === styledElement.code && areCodesMatching.endCode === styledElement.endCode)) {\n        processedPathAnalysis.push(styledElement);\n      }\n    } else {\n      processedPathAnalysis = processedPathAnalysis.filter(isEndCodeMismatch => isEndCodeMismatch.endCode !== styledElement.endCode);\n      processedPathAnalysis.push(styledElement);\n    }\n  }\n  return processedPathAnalysis;\n}\nvar initializeReactDevToolsConnection = T(() => {\n  C0A();\n  initializeColorManagementSystem();\n});\nfunction transformAndReverseCompoundPathAnalysisInput(___inputData) {\n  return processCompoundPathAnalysisInput(___inputData).reverse().map(updateEndCode => ({\n    ...updateEndCode,\n    code: updateEndCode.endCode\n  }));\n}\nvar initializeReactDevelopmentToolsConnection = T(() => {\n  initializeReactDevToolsConnection();\n});\nfunction combineAndFilterDataResults(filterAndCombineData, filterAndMergeResults) {\n  let endCodeSet = new Set(filterAndMergeResults.map(_endCode => _endCode.endCode));\n  let existingCodesSet = new Set(filterAndCombineData.map(generateCode => generateCode.code));\n  return [...transformAndReverseCompoundPathAnalysisInput(filterAndCombineData.filter(isEndCodeExists => !endCodeSet.has(isEndCodeExists.endCode))), ...filterAndMergeResults.filter(isCodeUnique => !existingCodesSet.has(isCodeUnique.code))];\n}\nvar __________initializeReactDevToolsConnection = T(() => {\n  initializeReactDevelopmentToolsConnection();\n});\nfunction _processAnsiAndCharItems(processAnsiAndCharItems) {\n  let ansiStyles = [];\n  let charItemsWithStyles = [];\n  for (let __item of processAnsiAndCharItems) {\n    if (__item.type === \"ansi\") {\n      ansiStyles = processCompoundPathAnalysis(ansiStyles, [__item]);\n    } else if (__item.type === \"char\") {\n      charItemsWithStyles.push({\n        ...__item,\n        styles: [...ansiStyles]\n      });\n    }\n  }\n  return charItemsWithStyles;\n}\nfunction processStyledStringArray(generateStyledString) {\n  let styledStringOutput = \"\";\n  for (let ________________________________index = 0; ________________________________index < generateStyledString.length; ________________________________index++) {\n    let styledStringItem = generateStyledString[________________________________index];\n    if (________________________________index === 0) {\n      styledStringOutput += concatenateCodeFromArray(styledStringItem.styles);\n    } else {\n      styledStringOutput += concatenateCodeFromArray(combineAndFilterDataResults(generateStyledString[________________________________index - 1].styles, styledStringItem.styles));\n    }\n    styledStringOutput += styledStringItem.value;\n    if (________________________________index === generateStyledString.length - 1) {\n      styledStringOutput += concatenateCodeFromArray(combineAndFilterDataResults(styledStringItem.styles, []));\n    }\n  }\n  return styledStringOutput;\n}\nvar _initializeReactDevelopmentToolsConnection = T(() => {\n  initializeColorManagementSystem();\n  __________initializeReactDevToolsConnection();\n  initializeReactDevToolsConnection();\n});\nfunction isIntegerValidForChecks(inputNumber) {\n  if (!Number.isInteger(inputNumber)) {\n    return false;\n  }\n  return nYA(inputNumber) || aYA(inputNumber);\n}\nvar initializeDevelopmentTools = T(() => {\n  sYA();\n});\nfunction extractSubstringAfterOffset(substringAfterOffset, substringStartIndex) {\n  substringAfterOffset = substringAfterOffset.slice(substringStartIndex);\n  for (let _________________________index = 1; _________________________index < processManagement.length; _________________________index++) {\n    if (substringAfterOffset.charCodeAt(_________________________index) !== processManagement[_________________________index]) {\n      return;\n    }\n  }\n  let terminationIndex = substringAfterOffset.indexOf(\"\u0007\", Foreground_Pen_Actions.length);\n  if (terminationIndex === -1) {\n    return;\n  }\n  return substringAfterOffset.slice(0, terminationIndex + 1);\n}\nfunction findCharacterPosition(findCharacterIndex) {\n  for (let characterIndex = 2; characterIndex < findCharacterIndex.length; characterIndex++) {\n    let _characterCode = findCharacterIndex.charCodeAt(characterIndex);\n    if (_characterCode === debuggingToolConnection) {\n      return characterIndex;\n    }\n    if (_characterCode === renderContainer) {\n      continue;\n    }\n    if (_characterCode >= getModuleDetails && _characterCode <= maxAllowedValue) {\n      continue;\n    }\n    break;\n  }\n  return -1;\n}\nfunction extractSubstringUntilCharacterPosition(___inputArray, startingIndex) {\n  ___inputArray = ___inputArray.slice(startingIndex);\n  let _characterPosition = findCharacterPosition(___inputArray);\n  if (_characterPosition === -1) {\n    return;\n  }\n  return ___inputArray.slice(0, _characterPosition + 1);\n}\nfunction parseColorCodes(processInputString) {\n  if (!processInputString.includes(\";\")) {\n    return [processInputString];\n  }\n  let colorCodeSegments = processInputString.slice(2, -1).split(\";\");\n  let colorCodes = [];\n  for (let _______currentIndex = 0; _______currentIndex < colorCodeSegments.length; _______currentIndex++) {\n    let _currentElement = colorCodeSegments[_______currentIndex];\n    if (_currentElement === \"38\" || _currentElement === \"48\") {\n      if (_______currentIndex + 2 < colorCodeSegments.length && colorCodeSegments[_______currentIndex + 1] === \"5\") {\n        colorCodes.push(colorCodeSegments.slice(_______currentIndex, _______currentIndex + 3).join(\";\"));\n        _______currentIndex += 2;\n        continue;\n      } else if (_______currentIndex + 4 < colorCodeSegments.length && colorCodeSegments[_______currentIndex + 1] === \"2\") {\n        colorCodes.push(colorCodeSegments.slice(_______currentIndex, _______currentIndex + 5).join(\";\"));\n        _______currentIndex += 4;\n        continue;\n      }\n    }\n    colorCodes.push(_currentElement);\n  }\n  return colorCodes.map(__colorCode => `\\x1B[${__colorCode}m`);\n}\nfunction transformStringWithLimitedWidth(processStringWithLimitedWidth, _maxWidth = Number.POSITIVE_INFINITY) {\n  let transformedSegments = [];\n  let __________currentIndex = 0;\n  let totalWidth = 0;\n  while (__________currentIndex < processStringWithLimitedWidth.length) {\n    let codePointValue = processStringWithLimitedWidth.codePointAt(__________currentIndex);\n    if (customTransformation.has(codePointValue)) {\n      let transformedCode;\n      let nextCodePoint = processStringWithLimitedWidth.codePointAt(__________currentIndex + 1);\n      if (nextCodePoint === $S0) {\n        transformedCode = extractSubstringAfterOffset(processStringWithLimitedWidth, __________currentIndex);\n        if (transformedCode) {\n          transformedSegments.push({\n            type: \"ansi\",\n            code: transformedCode,\n            endCode: getColorCode(transformedCode)\n          });\n        }\n      } else if (nextCodePoint === colorSettings) {\n        transformedCode = extractSubstringUntilCharacterPosition(processStringWithLimitedWidth, __________currentIndex);\n        if (transformedCode) {\n          let getAnsiCharArray = parseColorCodes(transformedCode);\n          for (let ansiCharacter of getAnsiCharArray) {\n            transformedSegments.push({\n              type: \"ansi\",\n              code: ansiCharacter,\n              endCode: getColorCode(ansiCharacter)\n            });\n          }\n        }\n      }\n      if (transformedCode) {\n        __________currentIndex += transformedCode.length;\n        continue;\n      }\n    }\n    let fullWidthCharCount = isIntegerValidForChecks(codePointValue);\n    let characterString = String.fromCodePoint(codePointValue);\n    transformedSegments.push({\n      type: \"char\",\n      value: characterString,\n      fullWidth: fullWidthCharCount\n    });\n    __________currentIndex += characterString.length;\n    if (fullWidthCharCount) {\n      totalWidth += 2;\n    } else {\n      totalWidth += characterString.length;\n    }\n    if (totalWidth >= _maxWidth) {\n      break;\n    }\n  }\n  return transformedSegments;\n}\nvar getModuleDetails = 48;\nvar maxAllowedValue = 57;\nvar renderContainer = 59;\nvar debuggingToolConnection = 109;\nvar _initializeReactDevToolsConnection = T(() => {\n  initializeDevelopmentTools();\n  initializeColorManagementSystem();\n});\nvar ________________________________________________________________________initializeDevToolsConnection = T(() => {\n  initializeColorManagementSystem();\n  __________initializeReactDevToolsConnection();\n  initializeReactDevToolsConnection();\n  initializeReactDevelopmentToolsConnection();\n  _initializeReactDevelopmentToolsConnection();\n  _initializeReactDevToolsConnection();\n});\nfunction isPointWithinBounds(isPointWithinArea, _isPointWithinBounds) {\n  return _isPointWithinBounds.x < isPointWithinArea.width && _isPointWithinBounds.y < isPointWithinArea.height;\n}\nfunction validateIntegerInput(___inputValue, _errorMessage) {\n  if (___inputValue === undefined) {\n    return;\n  }\n  if (Number.isInteger(___inputValue)) {\n    return;\n  }\n  g(`${_errorMessage} should be an integer, got ${___inputValue}`, {\n    level: \"warn\"\n  });\n}\nvar initializeAppState = T(() => {\n  C0();\n});\nfunction compareTextStyle(compareStyleObjects, compareStyles) {\n  if (compareStyleObjects.char !== compareStyles.char || compareStyleObjects.width !== compareStyles.width) {\n    return false;\n  }\n  if (compareStyleObjects.styles.length !== compareStyles.styles.length) {\n    return false;\n  }\n  for (let styleIndex = 0; styleIndex < compareStyleObjects.styles.length; styleIndex++) {\n    if (compareStyleObjects.styles[styleIndex].code !== compareStyles.styles[styleIndex].code) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction createScreen(createScreenDimensions, screenWidthAndHeight) {\n  validateIntegerInput(createScreenDimensions, \"createScreen width\");\n  validateIntegerInput(screenWidthAndHeight, \"createScreen height\");\n  if (!Number.isInteger(createScreenDimensions) || createScreenDimensions < 0) {\n    createScreenDimensions = Math.max(0, Math.floor(createScreenDimensions) || 0);\n  }\n  if (!Number.isInteger(screenWidthAndHeight) || screenWidthAndHeight < 0) {\n    screenWidthAndHeight = Math.max(0, Math.floor(screenWidthAndHeight) || 0);\n  }\n  let screenCells = Array(createScreenDimensions * screenWidthAndHeight).fill(defaultStyledChar);\n  return {\n    width: createScreenDimensions,\n    height: screenWidthAndHeight,\n    cells: screenCells\n  };\n}\nfunction getCellFromGridCoordinates(getCellFromCoordinates, coordinate) {\n  if (!isPointWithinBounds(getCellFromCoordinates, coordinate)) {\n    return;\n  }\n  let cellIndex = coordinate.y * getCellFromCoordinates.width + coordinate.x;\n  return getCellFromCoordinates.cells[cellIndex];\n}\nfunction calculatePositionBasedOnWidth(calculateArea, positionValue) {\n  let {\n    x: positionX,\n    y: _yCoordinate\n  } = positionValue;\n  let areaWidth = calculateArea.width;\n  return _yCoordinate * areaWidth + positionX;\n}\nfunction updateCellInBounds(processCell, targetCell, updateCellValue) {\n  if (!isPointWithinBounds(processCell, targetCell)) {\n    return;\n  }\n  let _targetCellIndex = calculatePositionBasedOnWidth(processCell, targetCell);\n  processCell.cells[_targetCellIndex] = updateCellValue;\n  if (updateCellValue.width === 1) {\n    let newCellCoordinates = {\n      x: targetCell.x + 1,\n      y: targetCell.y\n    };\n    if (isPointWithinBounds(processCell, newCellCoordinates)) {\n      let targetCellIndex = calculatePositionBasedOnWidth(processCell, newCellCoordinates);\n      processCell.cells[targetCellIndex] = emptySpace;\n    }\n  }\n}\nfunction compareGridStyling(createGridComparison, sizeB) {\n  let discrepancies = [];\n  let maxHeight = Math.max(createGridComparison.height, sizeB.height);\n  let maxWidth = Math.max(createGridComparison.width, sizeB.width);\n  for (let _currentRowIndex = 0; _currentRowIndex < maxHeight; _currentRowIndex += 1) {\n    for (let ____currentIndex = 0; ____currentIndex < maxWidth; ____currentIndex += 1) {\n      let coordinates = {\n        x: ____currentIndex,\n        y: _currentRowIndex\n      };\n      let gridComparisonResult = getCellFromGridCoordinates(createGridComparison, coordinates);\n      let sizeComparison = getCellFromGridCoordinates(sizeB, coordinates);\n      if (gridComparisonResult && sizeComparison && compareTextStyle(gridComparisonResult, sizeComparison)) {\n        continue;\n      }\n      discrepancies.push([coordinates, gridComparisonResult, sizeComparison]);\n    }\n  }\n  return discrepancies;\n}\nvar defaultStyledChar;\nvar emptySpace;\nvar ____________________initializeDevTools = T(() => {\n  initializeAppState();\n  defaultStyledChar = Object.freeze({\n    char: \" \",\n    styles: [],\n    width: 0\n  });\n  emptySpace = Object.freeze({\n    char: \"\",\n    styles: [],\n    width: 2\n  });\n});\nclass TextRenderer {\n  width;\n  height;\n  ink2;\n  operations = [];\n  charCache = {};\n  styledCharsToStringCache = {};\n  constructor(constructorConfig) {\n    let {\n      width: width,\n      height: height,\n      ink2: isInkEnabled = false\n    } = constructorConfig;\n    this.width = width;\n    this.height = height;\n    this.ink2 = isInkEnabled;\n  }\n  write(writeDataWithTransformers, textToWrite, _textToWrite, __________inputData) {\n    let {\n      transformers: _transformers\n    } = __________inputData;\n    if (!_textToWrite) {\n      return;\n    }\n    this.operations.push({\n      type: \"write\",\n      x: writeDataWithTransformers,\n      y: textToWrite,\n      text: _textToWrite,\n      transformers: _transformers\n    });\n  }\n  clip(clipArea) {\n    this.operations.push({\n      type: \"clip\",\n      clip: clipArea\n    });\n  }\n  unclip() {\n    this.operations.push({\n      type: \"unclip\"\n    });\n  }\n  get() {\n    let rowsArray = [];\n    for (let rowIndex = 0; rowIndex < this.height; rowIndex++) {\n      let rowArray = [];\n      for (let columnIndex = 0; columnIndex < this.width; columnIndex++) {\n        rowArray.push({\n          type: \"char\",\n          value: \" \",\n          fullWidth: false,\n          styles: []\n        });\n      }\n      rowsArray.push(rowArray);\n    }\n    let screenBuffer = createScreen(this.width, this.height);\n    let clipStack = [];\n    for (let operation of this.operations) {\n      if (operation.type === \"clip\") {\n        clipStack.push(operation.clip);\n      }\n      if (operation.type === \"unclip\") {\n        clipStack.pop();\n      }\n      if (operation.type === \"write\") {\n        let {\n          text: textContent,\n          transformers: transformers\n        } = operation;\n        let {\n          x: coordinateX,\n          y: _operation\n        } = operation;\n        let splitTextLines = textContent.split(`\n`);\n        let lastClipObject = clipStack.at(-1);\n        if (lastClipObject) {\n          let isClipBoundsValid = typeof lastClipObject?.x1 === \"number\" && typeof lastClipObject?.x2 === \"number\";\n          let isYCoordinateValid = typeof lastClipObject?.y1 === \"number\" && typeof lastClipObject?.y2 === \"number\";\n          if (isClipBoundsValid) {\n            let contentLength = W0A(textContent);\n            if (coordinateX + contentLength < lastClipObject.x1 || coordinateX > lastClipObject.x2) {\n              continue;\n            }\n          }\n          if (isYCoordinateValid) {\n            let characterData = splitTextLines.length;\n            if (_operation + characterData < lastClipObject.y1 || _operation > lastClipObject.y2) {\n              continue;\n            }\n          }\n          if (isClipBoundsValid) {\n            splitTextLines = splitTextLines.map(calculateClipOffsetAndWidth => {\n              let offsetFromLastClipX = coordinateX < lastClipObject.x1 ? lastClipObject.x1 - coordinateX : 0;\n              let calculateHeight = k7(calculateClipOffsetAndWidth);\n              let __calculatedWidth = coordinateX + calculateHeight > lastClipObject.x2 ? lastClipObject.x2 - coordinateX : calculateHeight;\n              return processFormattedString(calculateClipOffsetAndWidth, offsetFromLastClipX, __calculatedWidth);\n            });\n            if (coordinateX < lastClipObject.x1) {\n              coordinateX = lastClipObject.x1;\n            }\n          }\n          if (isYCoordinateValid) {\n            let writeOperationData = _operation < lastClipObject.y1 ? lastClipObject.y1 - _operation : 0;\n            let calculatedWidth = splitTextLines.length;\n            let baseIndex = _operation + calculatedWidth > lastClipObject.y2 ? lastClipObject.y2 - _operation : calculatedWidth;\n            splitTextLines = splitTextLines.slice(writeOperationData, baseIndex);\n            if (_operation < lastClipObject.y1) {\n              _operation = lastClipObject.y1;\n            }\n          }\n        }\n        let currentLineIndex = 0;\n        for (let [textLineIndex, lineContent] of splitTextLines.entries()) {\n          let currentLineData = rowsArray[_operation + currentLineIndex];\n          if (!currentLineData) {\n            continue;\n          }\n          for (let transformerFunction of transformers) {\n            lineContent = transformerFunction(lineContent, textLineIndex);\n          }\n          if (!Object.prototype.hasOwnProperty.call(this.charCache, lineContent)) {\n            this.charCache[lineContent] = this.ink2 ? processColorSegments(_processAnsiAndCharItems(transformStringWithLimitedWidth(lineContent))) : _processAnsiAndCharItems(transformStringWithLimitedWidth(lineContent));\n          }\n          let cachedCharacterData = this.charCache[lineContent];\n          let currentXCoordinate = coordinateX;\n          for (let _characterData of cachedCharacterData) {\n            currentLineData[currentXCoordinate] = _characterData;\n            let isFullWidth = _characterData.fullWidth || _characterData.value.length > 1;\n            if (this.ink2) {\n              updateCellInBounds(screenBuffer, {\n                x: currentXCoordinate,\n                y: _operation + currentLineIndex\n              }, {\n                char: _characterData.value,\n                styles: _characterData.styles,\n                width: isFullWidth ? 1 : 0\n              });\n            }\n            if (isFullWidth) {\n              currentLineData[currentXCoordinate + 1] = {\n                type: \"char\",\n                value: \"\",\n                fullWidth: false,\n                styles: _characterData.styles\n              };\n            }\n            if (isFullWidth) {\n              currentXCoordinate += 2;\n            } else {\n              currentXCoordinate += 1;\n            }\n          }\n          currentLineIndex++;\n        }\n      }\n    }\n    return {\n      output: this.ink2 ? \"\" : rowsArray.map(filterAndCacheStyledChars => {\n        let filteredArray = filterAndCacheStyledChars.filter(isDefined => isDefined !== undefined);\n        let filteredArrayString = JSON.stringify(filteredArray);\n        if (!Object.prototype.hasOwnProperty.call(this.styledCharsToStringCache, filteredArrayString)) {\n          let formattedString = processStyledStringArray(filteredArray).trimEnd();\n          this.styledCharsToStringCache[filteredArrayString] = formattedString;\n        }\n        return this.styledCharsToStringCache[filteredArrayString];\n      }).join(`\n`),\n      height: rowsArray.length,\n      screen: screenBuffer\n    };\n  }\n}\nfunction areArraysEqualByCode(compareCodeArrays, compareArrayObjects) {\n  if (compareCodeArrays.length !== compareArrayObjects.length) {\n    return false;\n  }\n  for (let _____________________index = 0; _____________________index < compareCodeArrays.length; _____________________index++) {\n    if (compareCodeArrays[_____________________index].code !== compareArrayObjects[_____________________index].code) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction processColorSegments(colorSegments) {\n  let colorSegmentsProcessed = [];\n  let currentColorSegment = \"\";\n  let currentStyles = [];\n  function _processColorSegments() {\n    if (currentColorSegment.length === 0) {\n      return;\n    }\n    for (let {\n      segment: _segment\n    } of SegmentColorer.segment(currentColorSegment)) {\n      colorSegmentsProcessed.push({\n        type: \"char\",\n        value: _segment,\n        fullWidth: sV(_segment) === 2,\n        styles: currentStyles\n      });\n    }\n    currentColorSegment = \"\";\n  }\n  for (let colorSegment of colorSegments) {\n    if (currentColorSegment.length > 0 && !areArraysEqualByCode(colorSegment.styles, currentStyles)) {\n      _processColorSegments();\n    }\n    currentColorSegment += colorSegment.value;\n    currentStyles = colorSegment.styles;\n  }\n  _processColorSegments();\n  return colorSegmentsProcessed;\n}\nvar SegmentColorer;\nvar __________________________________________________________________________________initializeDevToolsConnection = T(() => {\n  ____________initializeDevelopmentTools();\n  sTA();\n  ________________________________________________________________________initializeDevToolsConnection();\n  F0A();\n  ____________________initializeDevTools();\n  rYA();\n  SegmentColorer = new Intl.Segmenter();\n});\nfunction createTerminalRenderer(createTerminalOutput) {\n  return renderTerminalOutput => {\n    let {\n      theme: theme,\n      terminalWidth: terminalWidth,\n      terminalRows: terminalRows,\n      isTTY: isInteractiveTerminal,\n      ink2: inkColor\n    } = renderTerminalOutput;\n    if (!createTerminalOutput.yogaNode) {\n      return {\n        output: \"\",\n        outputHeight: 0,\n        staticOutput: \"\",\n        rows: terminalRows,\n        columns: terminalWidth,\n        cursorVisible: true,\n        screen: createScreen(terminalWidth, 0),\n        viewport: {\n          width: terminalWidth,\n          height: 0\n        },\n        cursor: {\n          x: 0,\n          y: 0,\n          visible: true\n        }\n      };\n    }\n    createTerminalOutput.yogaNode.setWidth(terminalWidth);\n    createTerminalOutput.yogaNode.calculateLayout(undefined, undefined, Hi.LTR);\n    let textRendererInstance = new TextRenderer({\n      width: Math.floor(createTerminalOutput.yogaNode.getComputedWidth()),\n      height: Math.floor(createTerminalOutput.yogaNode.getComputedHeight()),\n      ink2: inkColor\n    });\n    processAndDisplayNodes(createTerminalOutput, textRendererInstance, {\n      skipStaticElements: true,\n      theme: theme\n    });\n    let staticTextRenderer;\n    if (!inkColor && createTerminalOutput.staticNode?.yogaNode) {\n      staticTextRenderer = new TextRenderer({\n        width: Math.floor(createTerminalOutput.staticNode.yogaNode.getComputedWidth()),\n        height: Math.floor(createTerminalOutput.staticNode.yogaNode.getComputedHeight()),\n        ink2: false\n      });\n      processAndDisplayNodes(createTerminalOutput.staticNode, staticTextRenderer, {\n        skipStaticElements: false,\n        theme: theme\n      });\n    }\n    let {\n      output: terminalOutput,\n      height: outputHeight,\n      screen: terminalScreen\n    } = textRendererInstance.get();\n    return {\n      output: terminalOutput,\n      outputHeight: outputHeight,\n      staticOutput: staticTextRenderer ? `${staticTextRenderer.get().output}\n` : \"\",\n      rows: terminalRows,\n      columns: terminalWidth,\n      cursorVisible: !isInteractiveTerminal || terminalOutput === \"\",\n      screen: terminalScreen,\n      viewport: {\n        width: terminalWidth,\n        height: terminalRows\n      },\n      cursor: {\n        x: 0,\n        y: Math.max(0, terminalScreen.height - 1),\n        visible: true\n      }\n    };\n  };\n}\nvar yS0 = T(() => {\n  ES0();\n  __________________________________________________________________________________initializeDevToolsConnection();\n  wi();\n  ____________________initializeDevTools();\n});\nvar environmentVariableDetection;\nvar isNodeEnvironment;\nvar isBunEnvironment;\nvar runtimeEnvironmentDetected;\nvar isElectronEnvironment;\nvar isRunningInJsdomEnvironment;\nvar isWebWorkerContext;\nvar isDedicatedWorkerGlobalScope;\nvar platformGlobalContext;\nvar isServiceWorkerGlobalScope;\nvar getUserAgentPlatform;\nvar isMacOS;\nvar getOSInformation;\nvar isLinuxOS;\nvar isOperatingInMobileEnvironment;\nvar isAndroidPlatform;\nvar _____________initializeDevelopmentTools = T(() => {\n  environmentVariableDetection = globalThis.window?.document !== undefined;\n  isNodeEnvironment = globalThis.process?.versions?.node !== undefined;\n  isBunEnvironment = globalThis.process?.versions?.bun !== undefined;\n  runtimeEnvironmentDetected = globalThis.Deno?.version?.deno !== undefined;\n  isElectronEnvironment = globalThis.process?.versions?.electron !== undefined;\n  isRunningInJsdomEnvironment = globalThis.navigator?.userAgent?.includes(\"jsdom\") === true;\n  isWebWorkerContext = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\n  isDedicatedWorkerGlobalScope = typeof DedicatedWorkerGlobalScope !== \"undefined\" && globalThis instanceof DedicatedWorkerGlobalScope;\n  platformGlobalContext = typeof SharedWorkerGlobalScope !== \"undefined\" && globalThis instanceof SharedWorkerGlobalScope;\n  isServiceWorkerGlobalScope = typeof ServiceWorkerGlobalScope !== \"undefined\" && globalThis instanceof ServiceWorkerGlobalScope;\n  getUserAgentPlatform = globalThis.navigator?.userAgentData?.platform;\n  isMacOS = getUserAgentPlatform === \"macOS\" || globalThis.navigator?.platform === \"MacIntel\" || globalThis.navigator?.userAgent?.includes(\" Mac \") === true || globalThis.process?.platform === \"darwin\";\n  getOSInformation = getUserAgentPlatform === \"Windows\" || globalThis.navigator?.platform === \"Win32\" || globalThis.process?.platform === \"win32\";\n  isLinuxOS = getUserAgentPlatform === \"Linux\" || globalThis.navigator?.platform?.startsWith(\"Linux\") === true || globalThis.navigator?.userAgent?.includes(\" Linux \") === true || globalThis.process?.platform === \"linux\";\n  isOperatingInMobileEnvironment = getUserAgentPlatform === \"iOS\" || globalThis.navigator?.platform === \"MacIntel\" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);\n  isAndroidPlatform = getUserAgentPlatform === \"Android\" || globalThis.navigator?.platform === \"Android\" || globalThis.navigator?.userAgent?.includes(\" Android \") === true || globalThis.process?.platform === \"android\";\n});\nvar terminalCommands = {};\nM$(terminalCommands, {\n  scrollUp: () => handleChildHostContext,\n  scrollDown: () => connectToDevTools,\n  link: () => ______________________initializeDevTools,\n  image: () => __________________________________initializeDevToolsConnection,\n  iTerm: () => getAndSetReactDevTools,\n  exitAlternativeScreen: () => exitAlternativeScreenAction,\n  eraseUp: () => eraseCharacters,\n  eraseStartLine: () => eraseStartLine,\n  eraseScreen: () => clearScreen,\n  eraseLines: () => __________________________________________initializeDevToolsConnection,\n  eraseLine: () => clearTargetNode,\n  eraseEndLine: () => clearLine,\n  eraseDown: () => removeChildFromContainer,\n  enterAlternativeScreen: () => enterAlternativeScreenCommand,\n  cursorUp: () => _____________________initializeDevTools,\n  cursorTo: () => ______________initializeDevelopmentTools,\n  cursorShow: () => cursorShow,\n  cursorSavePosition: () => setCursorToPosition,\n  cursorRestorePosition: () => commitUpdate,\n  cursorPrevLine: () => cursorPreviousLine,\n  cursorNextLine: () => cursorMoveToNextLine,\n  cursorMove: () => _______________initializeDevelopmentTools,\n  cursorLeft: () => cursorLeftPosition,\n  cursorHide: () => hideCursor,\n  cursorGetPosition: () => getCursorPosition,\n  cursorForward: () => _________________________________initializeDevToolsConnection,\n  cursorDown: () => ________________initializeDevelopmentTools,\n  cursorBackward: () => processColorString,\n  clearTerminal: () => clearTerminalDisplay,\n  clearScreen: () => clearTerminal,\n  beep: () => processScrollEvents\n});\nimport processModule from \"node:process\";\nvar escapeSequence = \"\u001b[\";\nvar decodingString = \"\u001b]\";\nvar alert = \"\u0007\";\nvar handleDevToolsConnection = \";\";\nvar compositeColorTransformFunction;\nvar formatTextCursorPosition;\nvar updateVisualization;\nvar ______________initializeDevelopmentTools = (calculateEscapeSequence, devToolsConnectionHandling) => {\n  if (typeof calculateEscapeSequence !== \"number\") {\n    throw TypeError(\"The `x` argument is required\");\n  }\n  if (typeof devToolsConnectionHandling !== \"number\") {\n    return escapeSequence + (calculateEscapeSequence + 1) + \"G\";\n  }\n  return escapeSequence + (devToolsConnectionHandling + 1) + handleDevToolsConnection + (calculateEscapeSequence + 1) + \"H\";\n};\nvar _______________initializeDevelopmentTools = (generateEscapeSequence, offsetY) => {\n  if (typeof generateEscapeSequence !== \"number\") {\n    throw TypeError(\"The `x` argument is required\");\n  }\n  let movementInstructions = \"\";\n  if (generateEscapeSequence < 0) {\n    movementInstructions += escapeSequence + -generateEscapeSequence + \"D\";\n  } else if (generateEscapeSequence > 0) {\n    movementInstructions += escapeSequence + generateEscapeSequence + \"C\";\n  }\n  if (offsetY < 0) {\n    movementInstructions += escapeSequence + -offsetY + \"A\";\n  } else if (offsetY > 0) {\n    movementInstructions += escapeSequence + offsetY + \"B\";\n  }\n  return movementInstructions;\n};\nvar _____________________initializeDevTools = (escapeSequenceValue = 1) => escapeSequence + escapeSequenceValue + \"A\";\nvar ________________initializeDevelopmentTools = (escapeOffset = 1) => escapeSequence + escapeOffset + \"B\";\nvar _________________________________initializeDevToolsConnection = (escapeValue = 1) => escapeSequence + escapeValue + \"C\";\nvar processColorString = (escapeValueAndAppendD = 1) => escapeSequence + escapeValueAndAppendD + \"D\";\nvar cursorLeftPosition;\nvar setCursorToPosition;\nvar commitUpdate;\nvar getCursorPosition;\nvar cursorMoveToNextLine;\nvar cursorPreviousLine;\nvar hideCursor;\nvar cursorShow;\nvar __________________________________________initializeDevToolsConnection = generateClearInstructions => {\n  let resultString = \"\";\n  for (let ____________________________index = 0; ____________________________index < generateClearInstructions; ____________________________index++) {\n    resultString += clearTargetNode + (____________________________index < generateClearInstructions - 1 ? _____________________initializeDevTools() : \"\");\n  }\n  if (generateClearInstructions) {\n    resultString += cursorLeftPosition;\n  }\n  return resultString;\n};\nvar clearLine;\nvar eraseStartLine;\nvar clearTargetNode;\nvar removeChildFromContainer;\nvar eraseCharacters;\nvar clearScreen;\nvar handleChildHostContext;\nvar connectToDevTools;\nvar clearTerminal = \"\u001bc\";\nvar clearTerminalDisplay;\nvar enterAlternativeScreenCommand;\nvar exitAlternativeScreenAction;\nvar processScrollEvents;\nvar ______________________initializeDevTools = (buildStringFromComponents, handleAlert) => [decodingString, \"8\", handleDevToolsConnection, handleDevToolsConnection, handleAlert, alert, buildStringFromComponents, decodingString, \"8\", handleDevToolsConnection, handleDevToolsConnection, alert].join(\"\");\nvar __________________________________initializeDevToolsConnection = (generateEncodedStringWithOptions, dimensions = {}) => {\n  let generateDataString = `${decodingString}1337;File=inline=1`;\n  if (dimensions.width) {\n    generateDataString += `;width=${dimensions.width}`;\n  }\n  if (dimensions.height) {\n    generateDataString += `;height=${dimensions.height}`;\n  }\n  if (dimensions.preserveAspectRatio === false) {\n    generateDataString += \";preserveAspectRatio=0\";\n  }\n  return generateDataString + \":\" + Buffer.from(generateEncodedStringWithOptions).toString(\"base64\") + alert;\n};\nvar getAndSetReactDevTools;\nvar __initializeReactDevToolsConnection = T(() => {\n  _____________initializeDevelopmentTools();\n  compositeColorTransformFunction = !environmentVariableDetection && processModule.env.TERM_PROGRAM === \"Apple_Terminal\";\n  formatTextCursorPosition = !environmentVariableDetection && processModule.platform === \"win32\";\n  if (environmentVariableDetection) {\n    updateVisualization = () => {\n      throw Error(\"`process.cwd()` only works in Node.js, not the browser.\");\n    };\n  } else {\n    updateVisualization = processModule.cwd;\n  }\n  cursorLeftPosition = escapeSequence + \"G\";\n  if (compositeColorTransformFunction) {\n    setCursorToPosition = \"\u001b7\";\n  } else {\n    setCursorToPosition = escapeSequence + \"s\";\n  }\n  if (compositeColorTransformFunction) {\n    commitUpdate = \"\u001b8\";\n  } else {\n    commitUpdate = escapeSequence + \"u\";\n  }\n  getCursorPosition = escapeSequence + \"6n\";\n  cursorMoveToNextLine = escapeSequence + \"E\";\n  cursorPreviousLine = escapeSequence + \"F\";\n  hideCursor = escapeSequence + \"?25l\";\n  cursorShow = escapeSequence + \"?25h\";\n  clearLine = escapeSequence + \"K\";\n  eraseStartLine = escapeSequence + \"1K\";\n  clearTargetNode = escapeSequence + \"2K\";\n  removeChildFromContainer = escapeSequence + \"J\";\n  eraseCharacters = escapeSequence + \"1J\";\n  clearScreen = escapeSequence + \"2J\";\n  handleChildHostContext = escapeSequence + \"S\";\n  connectToDevTools = escapeSequence + \"T\";\n  if (formatTextCursorPosition) {\n    clearTerminalDisplay = `${clearScreen}${escapeSequence}0f`;\n  } else {\n    clearTerminalDisplay = `${clearScreen}${escapeSequence}3J${escapeSequence}H`;\n  }\n  enterAlternativeScreenCommand = escapeSequence + \"?1049h\";\n  exitAlternativeScreenAction = escapeSequence + \"?1049l\";\n  processScrollEvents = alert;\n  getAndSetReactDevTools = {\n    setCwd: (currentDirectory = updateVisualization()) => `${decodingString}50;CurrentDir=${currentDirectory}${alert}`,\n    annotation(addAnnotation, annotationParameters = {}) {\n      let annotationPayload = `${decodingString}1337;`;\n      let isXDefined = annotationParameters.x !== undefined;\n      let isYDefined = annotationParameters.y !== undefined;\n      if ((isXDefined || isYDefined) && (!isXDefined || !isYDefined || annotationParameters.length === undefined)) {\n        throw Error(\"`x`, `y` and `length` must be defined when `x` or `y` is defined\");\n      }\n      addAnnotation = addAnnotation.replaceAll(\"|\", \"\");\n      if (annotationParameters.isHidden) {\n        annotationPayload += \"AddHiddenAnnotation=\";\n      } else {\n        annotationPayload += \"AddAnnotation=\";\n      }\n      if (annotationParameters.length > 0) {\n        annotationPayload += (isXDefined ? [addAnnotation, annotationParameters.length, annotationParameters.x, annotationParameters.y] : [annotationParameters.length, addAnnotation]).join(\"|\");\n      } else {\n        annotationPayload += addAnnotation;\n      }\n      return annotationPayload + alert;\n    }\n  };\n});\nvar __________________________________________________initializeDevToolsConnection = T(() => {\n  __initializeReactDevToolsConnection();\n  __initializeReactDevToolsConnection();\n});\nfunction createTerminalDisplay(numRows, columnCount) {\n  return {\n    output: \"\",\n    outputHeight: 0,\n    staticOutput: \"\",\n    rows: numRows,\n    columns: columnCount,\n    cursorVisible: true,\n    screen: createScreen(0, 0),\n    viewport: {\n      width: 0,\n      height: 0\n    },\n    cursor: {\n      x: 0,\n      y: 0,\n      visible: true\n    }\n  };\n}\nfunction areDimensionsValid(isLayoutMismatch, inputMatrix) {\n  let isDimensionMismatch = inputMatrix.rows !== isLayoutMismatch.rows || inputMatrix.columns !== isLayoutMismatch.columns;\n  let isInputHeightSufficient = inputMatrix.outputHeight >= inputMatrix.rows;\n  let isLayoutHeightValid = isLayoutMismatch.outputHeight >= isLayoutMismatch.rows;\n  return isDimensionMismatch || isInputHeightSufficient || isLayoutHeightValid;\n}\nvar _______________initializeRenderer = T(() => {\n  ____________________initializeDevTools();\n});\nclass TerminalRenderer {\n  options;\n  state;\n  constructor(optionsConfig, previousFrame) {\n    this.options = optionsConfig;\n    this.state = {\n      fullStaticOutput: \"\",\n      previousOutput: \"\",\n      prevFrame: previousFrame\n    };\n  }\n  render(currentFrame) {\n    let renderedFrame = this.options.ink2 ? this.render_v2(this.state.prevFrame, currentFrame) : this.render_v1(this.state.prevFrame, currentFrame);\n    this.state.prevFrame = currentFrame;\n    return renderedFrame;\n  }\n  render_v1(renderInput, renderableOutput) {\n    if (this.options.debug) {\n      return this.getRenderOpsDebug_DEPRECATED(renderableOutput);\n    }\n    if (!this.options.isTTY) {\n      return [{\n        type: \"stdout\",\n        content: renderableOutput.staticOutput,\n        scrollback: true\n      }];\n    }\n    if (areDimensionsValid(renderInput, renderableOutput)) {\n      return this.getRenderOpsForAllOutput_CAUSES_FLICKER(renderableOutput);\n    }\n    if ((!renderableOutput.staticOutput || renderableOutput.staticOutput === `\n`) && renderableOutput.output === renderInput.output) {\n      return [];\n    }\n    return [...this.getRenderOpsForClearAndRenderStaticOutput(renderInput, renderableOutput), ...this.renderEfficiently(renderInput, renderableOutput)];\n  }\n  renderPreviousOutput_DEPRECATED() {\n    if (!this.options.isTTY) {\n      return [{\n        type: \"stdout\",\n        content: this.state.prevFrame.output,\n        scrollback: true\n      }, {\n        type: \"stdout\",\n        content: `\n`,\n        scrollback: true\n      }];\n    } else if (!this.options.debug) {\n      return this.getRenderOpsForDone(this.state.prevFrame);\n    }\n    return [];\n  }\n  reset() {\n    this.state.prevFrame = createTerminalDisplay(this.state.prevFrame.rows, this.state.prevFrame.columns);\n    this.state.previousOutput = \"\";\n  }\n  renderEfficiently(renderOutputBasedOnState, renderOutputForComponent) {\n    let formattedOutput = `${renderOutputForComponent.output}\n`;\n    if (formattedOutput === this.state.previousOutput) {\n      return [];\n    }\n    let previousOutputLength = this.state.previousOutput ? oYA(this.state.previousOutput, renderOutputBasedOnState.columns) : 0;\n    this.state.previousOutput = formattedOutput;\n    let renderCommands = [];\n    if (!renderOutputForComponent.cursorVisible && renderOutputBasedOnState.cursorVisible) {\n      renderCommands.push({\n        type: \"cursorHide\"\n      });\n    } else if (renderOutputForComponent.cursorVisible && !renderOutputBasedOnState.cursorVisible) {\n      renderCommands.push({\n        type: \"cursorShow\"\n      });\n    }\n    if (previousOutputLength > 0) {\n      renderCommands.push({\n        type: \"clear\",\n        count: previousOutputLength\n      });\n    }\n    renderCommands.push({\n      type: \"stdout\",\n      content: renderOutputForComponent.output,\n      scrollback: false\n    });\n    renderCommands.push({\n      type: \"stdout\",\n      content: `\n`,\n      scrollback: false\n    });\n    return renderCommands;\n  }\n  getRenderOpsDebug_DEPRECATED(renderOperationsDebug) {\n    if (renderOperationsDebug.staticOutput && renderOperationsDebug.staticOutput !== `\n`) {\n      this.state.fullStaticOutput += renderOperationsDebug.staticOutput;\n    }\n    return [{\n      type: \"stdout\",\n      content: this.state.fullStaticOutput,\n      scrollback: true\n    }, {\n      type: \"stdout\",\n      content: renderOperationsDebug.output,\n      scrollback: true\n    }];\n  }\n  getRenderOpsForAllOutput_CAUSES_FLICKER(getRenderOperationsForAllOutputs) {\n    if (getRenderOperationsForAllOutputs.staticOutput && getRenderOperationsForAllOutputs.staticOutput !== `\n`) {\n      this.state.fullStaticOutput += getRenderOperationsForAllOutputs.staticOutput;\n    }\n    this.state.previousOutput = `${getRenderOperationsForAllOutputs.output}\n`;\n    let renderOperations = [];\n    renderOperations.push({\n      type: \"clearTerminal\"\n    });\n    renderOperations.push({\n      type: \"stdout\",\n      content: this.state.fullStaticOutput,\n      scrollback: true\n    });\n    renderOperations.push({\n      type: \"stdout\",\n      content: getRenderOperationsForAllOutputs.output,\n      scrollback: true\n    });\n    renderOperations.push({\n      type: \"stdout\",\n      content: `\n`,\n      scrollback: true\n    });\n    return renderOperations;\n  }\n  getRenderOpsForClearAndRenderStaticOutput(getRenderOpsForClearAndRenderStaticOutput, staticOutputData) {\n    if (!staticOutputData.staticOutput || staticOutputData.staticOutput === `\n`) {\n      return [];\n    }\n    this.state.fullStaticOutput += staticOutputData.staticOutput;\n    let previousOutputCount = this.state.previousOutput ? oYA(this.state.previousOutput, getRenderOpsForClearAndRenderStaticOutput.columns) : 0;\n    this.state.previousOutput = \"\";\n    let _renderOperations = [];\n    if (previousOutputCount > 0) {\n      _renderOperations.push({\n        type: \"clear\",\n        count: previousOutputCount\n      });\n    }\n    _renderOperations.push({\n      type: \"stdout\",\n      content: staticOutputData.staticOutput,\n      scrollback: true\n    });\n    return _renderOperations;\n  }\n  getRenderOpsForDone(getRenderOperationsForCursorVisibility) {\n    this.state.previousOutput = \"\";\n    if (!getRenderOperationsForCursorVisibility.cursorVisible) {\n      return [{\n        type: \"cursorShow\"\n      }];\n    }\n    return [];\n  }\n  render_v2(renderViewportComparison, renderViewportData) {\n    if (renderViewportData.screen.height === 0 || renderViewportData.screen.width === 0) {\n      return [];\n    }\n    if (renderViewportData.viewport.height < renderViewportComparison.viewport.height || renderViewportComparison.viewport.width !== 0 && renderViewportData.viewport.width !== renderViewportComparison.viewport.width) {\n      return renderScreenOutput(renderViewportData);\n    }\n    let viewportCursorManager = new ViewportCursorManager(renderViewportComparison.cursor, renderViewportData.viewport.width);\n    let itemCount = Math.max(renderViewportData.screen.height, 1) - Math.max(renderViewportComparison.screen.height, 1);\n    if (itemCount < 0) {\n      viewportCursorManager.txn(motionInstructions => [{\n        type: \"clear\",\n        count: -itemCount\n      }, {\n        dx: -motionInstructions.x,\n        dy: itemCount + 1\n      }]);\n      viewportCursorManager.txn(() => [{\n        type: \"cursorMove\",\n        x: 0,\n        y: -1\n      }, {\n        dx: 0,\n        dy: -1\n      }]);\n    } else if (itemCount > 0) {\n      for (let _iterationIndex = 0; _iterationIndex < itemCount; _iterationIndex += 1) {\n        viewportCursorManager.txn(outputData => [{\n          type: \"stdout\",\n          content: `\n`,\n          scrollback: false\n        }, {\n          dx: -outputData.x,\n          dy: 1\n        }]);\n      }\n    }\n    let maxScrollAdjustment = Math.max(renderViewportComparison.screen.height, renderViewportData.screen.height) - renderViewportData.viewport.height;\n    let processedOutput = [];\n    for (let [screenData, screenSize, currentScreen] of compareGridStyling(renderViewportComparison.screen, renderViewportData.screen)) {\n      if (currentScreen && (currentScreen.width === 2 || currentScreen.width === 3)) {\n        continue;\n      }\n      if (screenSize && (screenSize.width === 2 || screenSize.width === 3) && !currentScreen) {\n        continue;\n      }\n      if (screenData.y < maxScrollAdjustment) {\n        return renderScreenOutput(renderViewportData);\n      }\n      updateCursorAndScreenPosition(viewportCursorManager, screenData);\n      if (currentScreen && screenSize) {\n        processedOutput = processOutputAndStyles(viewportCursorManager, currentScreen, processedOutput);\n      } else if (currentScreen) {\n        processedOutput = processOutputAndStyles(viewportCursorManager, currentScreen, processedOutput);\n      } else if (screenSize) {\n        viewportCursorManager.txn(() => [{\n          type: \"del\"\n        }, {\n          dx: 0,\n          dy: 0\n        }]);\n      }\n    }\n    updateCursorAndScreenPosition(viewportCursorManager, renderViewportData.cursor);\n    if (processedOutput.length > 0) {\n      let iterationIndex = combineAndFilterDataResults(processedOutput, []);\n      if (iterationIndex.length > 0) {\n        viewportCursorManager.diff.push({\n          type: \"stdout\",\n          content: concatenateCodeFromArray(iterationIndex),\n          scrollback: false\n        });\n      }\n    }\n    return viewportCursorManager.diff;\n  }\n}\nfunction renderScreenOutput(handleScreenRendering) {\n  let screenOutputInstructions = [{\n    type: \"clearTerminal\"\n  }];\n  let screenPixelStyles = [];\n  for (let verticalIndex = 0; verticalIndex < handleScreenRendering.screen.height; verticalIndex += 1) {\n    for (let screenXIndex = 0; screenXIndex < handleScreenRendering.screen.width; screenXIndex += 1) {\n      let screenPixelData = getCellFromGridCoordinates(handleScreenRendering.screen, {\n        x: screenXIndex,\n        y: verticalIndex\n      });\n      if (!screenPixelData) {\n        continue;\n      }\n      if (screenPixelData.width === 2 || screenPixelData.width === 3) {\n        continue;\n      }\n      let formattedStyles = combineAndFilterDataResults(screenPixelStyles, screenPixelData.styles);\n      let formattedContent = formattedStyles.length > 0 ? concatenateCodeFromArray(formattedStyles) : \"\";\n      screenPixelStyles = screenPixelData.styles;\n      screenOutputInstructions.push({\n        type: \"stdout\",\n        content: formattedContent + screenPixelData.char,\n        scrollback: false\n      });\n    }\n    screenOutputInstructions.push({\n      type: \"stdout\",\n      content: `\n`,\n      scrollback: false\n    });\n  }\n  screenOutputInstructions.push({\n    type: \"cursorMove\",\n    x: 0,\n    y: -1\n  });\n  return screenOutputInstructions;\n}\nfunction processOutputAndStyles(outputHandler, styleConfig, styles) {\n  let filteredAndCombinedStyles = combineAndFilterDataResults(styles, styleConfig.styles);\n  let concatenatedCodeOutput = filteredAndCombinedStyles.length > 0 ? concatenateCodeFromArray(filteredAndCombinedStyles) : \"\";\n  outputHandler.txn(calculateOutput => {\n    let viewportAdjustmentFactor = styleConfig.width === 1 ? 2 : 1;\n    let calculateWidthAdjustment = calculateOutput.x >= outputHandler.viewportWidth ? viewportAdjustmentFactor - calculateOutput.x : viewportAdjustmentFactor;\n    let calculateScrollDirection = calculateOutput.x >= outputHandler.viewportWidth ? 1 : 0;\n    return [{\n      type: \"stdout\",\n      content: concatenatedCodeOutput + styleConfig.char,\n      scrollback: false\n    }, {\n      dx: calculateWidthAdjustment,\n      dy: calculateScrollDirection\n    }];\n  });\n  return styleConfig.styles;\n}\nfunction updateCursorAndScreenPosition(updateScreenAndCursorPosition, targetCoordinates) {\n  updateScreenAndCursorPosition.txn(getCursorUpdate => {\n    if (getCursorUpdate.x < updateScreenAndCursorPosition.viewportWidth) {\n      return [{\n        type: \"stdout\",\n        content: \"\",\n        scrollback: false\n      }, {\n        dx: 0,\n        dy: 0\n      }];\n    }\n    return [{\n      type: \"stdout\",\n      content: \" \\b\",\n      scrollback: false\n    }, {\n      dx: -getCursorUpdate.x,\n      dy: 1\n    }];\n  });\n  updateScreenAndCursorPosition.txn(calculateCursorMovement => {\n    let deltaX = targetCoordinates.x - calculateCursorMovement.x;\n    let deltaY = targetCoordinates.y - calculateCursorMovement.y;\n    if (deltaY !== 0) {\n      return [{\n        type: \"stdout\",\n        content: \"\\r\" + terminalCommands.cursorMove(targetCoordinates.x, deltaY),\n        scrollback: false\n      }, {\n        dx: deltaX,\n        dy: deltaY\n      }];\n    }\n    return [{\n      type: \"cursorMove\",\n      x: deltaX,\n      y: deltaY\n    }, {\n      dx: deltaX,\n      dy: deltaY\n    }];\n  });\n}\nclass ViewportCursorManager {\n  viewportWidth;\n  cursor;\n  diff = [];\n  constructor(cursorSettings, viewportHeight) {\n    this.viewportWidth = viewportHeight;\n    this.cursor = {\n      ...cursorSettings\n    };\n  }\n  txn(processTransaction) {\n    let [transactionResult, deltaMovement] = processTransaction(this.cursor);\n    this.diff.push(transactionResult);\n    this.cursor = {\n      x: this.cursor.x + deltaMovement.dx,\n      y: this.cursor.y + deltaMovement.dy\n    };\n  }\n}\nvar processAndDisplayElements = T(() => {\n  __________________________________________________initializeDevToolsConnection();\n  kZ1();\n  _______________initializeRenderer();\n  ____________________initializeDevTools();\n  ________________________________________________________________________initializeDevToolsConnection();\n});\nvar updateDefaultRenderer;\nvar colorManagement;\nvar ____initializeReactDevTools = T(() => {\n  updateDefaultRenderer = new Map();\n  colorManagement = updateDefaultRenderer;\n});\nclass EventPropagationHandler {\n  _didStopImmediatePropagation = false;\n  didStopImmediatePropagation() {\n    return this._didStopImmediatePropagation;\n  }\n  stopImmediatePropagation() {\n    this._didStopImmediatePropagation = true;\n  }\n}\nimport { EventEmitter as handleComponentInitialization } from \"events\";\nvar initializeDevTools;\nvar _____initializeReactDevTools = T(() => {\n  initializeDevTools = class EventEmitter extends handleComponentInitialization {\n    emit(emitEvent, ...eventArgs) {\n      if (emitEvent === \"error\") {\n        return super.emit(emitEvent, ...eventArgs);\n      }\n      let listenersForEvent = this.rawListeners(emitEvent);\n      if (listenersForEvent.length === 0) {\n        return false;\n      }\n      let __eventHandler = eventArgs[0] instanceof EventPropagationHandler ? eventArgs[0] : null;\n      for (let ______callbackFunction of listenersForEvent) {\n        ______callbackFunction.apply(this, eventArgs);\n        if (__eventHandler?.didStopImmediatePropagation()) {\n          break;\n        }\n      }\n      return true;\n    }\n  };\n});\nvar processData;\nvar processState;\nvar _initializeDevelopmentTools;\nvar _______________________initializeDevTools = T(() => {\n  processData = IA(KA(), 1);\n  processState = processData.createContext({\n    exit() {}\n  });\n  processState.displayName = \"InternalAppContext\";\n  _initializeDevelopmentTools = processState;\n});\nvar __initializeDevelopmentTools;\nvar rendererSetup;\nvar initializeReactDevTools;\nvar ___________________________________________initializeDevToolsConnection = T(() => {\n  _____initializeReactDevTools();\n  __initializeDevelopmentTools = IA(KA(), 1);\n  rendererSetup = __initializeDevelopmentTools.createContext({\n    stdin: process.stdin,\n    internal_eventEmitter: new initializeDevTools(),\n    setRawMode() {},\n    isRawModeSupported: false,\n    internal_exitOnCtrlC: true\n  });\n  rendererSetup.displayName = \"InternalStdinContext\";\n  initializeReactDevTools = rendererSetup;\n});\nvar ___initializeDevelopmentTools;\nvar ____initializeDevelopmentTools;\nvar _processAndDisplayNodes;\nvar __createInstance = T(() => {\n  ___initializeDevelopmentTools = IA(KA(), 1);\n  ____initializeDevelopmentTools = ___initializeDevelopmentTools.createContext({\n    activeId: undefined,\n    add() {},\n    remove() {},\n    activate() {},\n    deactivate() {},\n    enableFocus() {},\n    disableFocus() {},\n    focusNext() {},\n    focusPrevious() {},\n    focus() {}\n  });\n  ____initializeDevelopmentTools.displayName = \"InternalFocusContext\";\n  _processAndDisplayNodes = ____initializeDevelopmentTools;\n});\nvar _initializeDevTools = z((escapeRegExp, escapeSpecialCharacters) => {\n  var specialCharacterRegex = /[|\\\\{}()[\\]^$+*?.-]/g;\n  escapeSpecialCharacters.exports = _escapeSpecialCharacters => {\n    if (typeof _escapeSpecialCharacters !== \"string\") {\n      throw TypeError(\"Expected a string\");\n    }\n    return _escapeSpecialCharacters.replace(specialCharacterRegex, \"\\\\$&\");\n  };\n});\nvar ________________________initializeDevTools = z((createErrorStackCleaner, createStackTraceCleaner) => {\n  var ______________________________initializeDevTools = _initializeDevTools();\n  var currentWorkingDirectory = typeof process === \"object\" && process && typeof process.cwd === \"function\" ? process.cwd() : \".\";\n  var nodeInternalPatterns = [].concat(EA(\"module\").builtinModules, \"bootstrap_node\", \"node\").map(filePathRegex => new RegExp(`(?:\\\\((?:node:)?${filePathRegex}(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?${filePathRegex}(?:\\\\.js)?:\\\\d+:\\\\d+$)`));\n  nodeInternalPatterns.push(/\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/, /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/);\n  class NY1 {\n    constructor(__________options) {\n      __________options = {\n        ignoredPackages: [],\n        ...__________options\n      };\n      if (\"internals\" in __________options === false) {\n        __________options.internals = NY1.nodeInternals();\n      }\n      if (\"cwd\" in __________options === false) {\n        __________options.cwd = currentWorkingDirectory;\n      }\n      this._cwd = __________options.cwd.replace(/\\\\/g, \"/\");\n      this._internals = [].concat(__________options.internals, createNodeModulesRegex(__________options.ignoredPackages));\n      this._wrapCallSite = __________options.wrapCallSite || false;\n    }\n    static nodeInternals() {\n      return [...nodeInternalPatterns];\n    }\n    clean(A, indentationSpaces = 0) {\n      indentationSpaces = \" \".repeat(indentationSpaces);\n      if (!Array.isArray(A)) {\n        A = A.split(`\n`);\n      }\n      if (!/^\\s*at /.test(A[0]) && /^\\s*at /.test(A[1])) {\n        A = A.slice(1);\n      }\n      let Q = false;\n      let I = null;\n      let G = [];\n      A.forEach(processStackTraceEntry => {\n        processStackTraceEntry = processStackTraceEntry.replace(/\\\\/g, \"/\");\n        if (this._internals.some(TestStackTraceEntry => TestStackTraceEntry.test(processStackTraceEntry))) {\n          return;\n        }\n        let isStackTraceLine = /^\\s*at /.test(processStackTraceEntry);\n        if (Q) {\n          processStackTraceEntry = processStackTraceEntry.trimEnd().replace(/^(\\s+)at /, \"$1\");\n        } else {\n          processStackTraceEntry = processStackTraceEntry.trim();\n          if (isStackTraceLine) {\n            processStackTraceEntry = processStackTraceEntry.slice(3);\n          }\n        }\n        processStackTraceEntry = processStackTraceEntry.replace(`${this._cwd}/`, \"\");\n        if (processStackTraceEntry) {\n          if (isStackTraceLine) {\n            if (I) {\n              G.push(I);\n              I = null;\n            }\n            G.push(processStackTraceEntry);\n          } else {\n            Q = true;\n            I = processStackTraceEntry;\n          }\n        }\n      });\n      return G.map(formattedStringWithIndentation => `${indentationSpaces}${formattedStringWithIndentation}\n`).join(\"\");\n    }\n    captureString(maxStackTraceDepth, captureFunction = this.captureString) {\n      if (typeof maxStackTraceDepth === \"function\") {\n        captureFunction = maxStackTraceDepth;\n        maxStackTraceDepth = Infinity;\n      }\n      let {\n        stackTraceLimit: originalStackTraceLimit\n      } = Error;\n      if (maxStackTraceDepth) {\n        Error.stackTraceLimit = maxStackTraceDepth;\n      }\n      let stackTraceObject = {};\n      Error.captureStackTrace(stackTraceObject, captureFunction);\n      let {\n        stack: stackTrace\n      } = stackTraceObject;\n      Error.stackTraceLimit = originalStackTraceLimit;\n      return this.clean(stackTrace);\n    }\n    capture(captureStackTrace, functionCapture = this.capture) {\n      if (typeof captureStackTrace === \"function\") {\n        functionCapture = captureStackTrace;\n        captureStackTrace = Infinity;\n      }\n      let {\n        prepareStackTrace: originalPrepareStackTrace,\n        stackTraceLimit: stackTraceLimit\n      } = Error;\n      Error.prepareStackTrace = (mapWrappedCallSite, callSiteMapper) => {\n        if (this._wrapCallSite) {\n          return callSiteMapper.map(this._wrapCallSite);\n        }\n        return callSiteMapper;\n      };\n      if (captureStackTrace) {\n        Error.stackTraceLimit = captureStackTrace;\n      }\n      let stackTraceInfo = {};\n      Error.captureStackTrace(stackTraceInfo, functionCapture);\n      let {\n        stack: _stackTrace\n      } = stackTraceInfo;\n      Object.assign(Error, {\n        prepareStackTrace: originalPrepareStackTrace,\n        stackTraceLimit: stackTraceLimit\n      });\n      return _stackTrace;\n    }\n    at(getStackTraceInfo = this.at) {\n      let [B] = this.capture(1, getStackTraceInfo);\n      if (!B) {\n        return {};\n      }\n      let Q = {\n        line: B.getLineNumber(),\n        column: B.getColumnNumber()\n      };\n      updateFilePath(Q, B.getFileName(), this._cwd);\n      if (B.isConstructor()) {\n        Object.defineProperty(Q, \"constructor\", {\n          value: true,\n          configurable: true\n        });\n      }\n      if (B.isEval()) {\n        Q.evalOrigin = B.getEvalOrigin();\n      }\n      if (B.isNative()) {\n        Q.native = true;\n      }\n      let I;\n      try {\n        I = B.getTypeName();\n      } catch (______error) {}\n      if (I && I !== \"Object\" && I !== \"[object Object]\") {\n        Q.type = I;\n      }\n      let G = B.getFunctionName();\n      if (G) {\n        Q.function = G;\n      }\n      let Z = B.getMethodName();\n      if (Z && G !== Z) {\n        Q.method = Z;\n      }\n      return Q;\n    }\n    parseLine(A) {\n      let B = A && A.match(stackTraceLinePattern);\n      if (!B) {\n        return null;\n      }\n      let Q = B[1] === \"new\";\n      let I = B[2];\n      let G = B[3];\n      let Z = B[4];\n      let Y = Number(B[5]);\n      let J = Number(B[6]);\n      let X = B[7];\n      let W = B[8];\n      let F = B[9];\n      let C = B[10] === \"native\";\n      let V = B[11] === \")\";\n      let K;\n      let D = {};\n      if (W) {\n        D.line = Number(W);\n      }\n      if (F) {\n        D.column = Number(F);\n      }\n      if (V && X) {\n        let nestedParenthesesCounter = 0;\n        for (let index = X.length - 1; index > 0; index--) {\n          if (X.charAt(index) === \")\") {\n            nestedParenthesesCounter++;\n          } else if (X.charAt(index) === \"(\" && X.charAt(index - 1) === \" \") {\n            nestedParenthesesCounter--;\n            if (nestedParenthesesCounter === -1 && X.charAt(index - 1) === \" \") {\n              let substringBeforeClosingParenthesis = X.slice(0, index - 1);\n              X = X.slice(index + 1);\n              I += ` (${substringBeforeClosingParenthesis}`;\n              break;\n            }\n          }\n        }\n      }\n      if (I) {\n        let lastParenthesisCount = I.match(functionNamePattern);\n        if (lastParenthesisCount) {\n          I = lastParenthesisCount[1];\n          K = lastParenthesisCount[2];\n        }\n      }\n      updateFilePath(D, X, this._cwd);\n      if (Q) {\n        Object.defineProperty(D, \"constructor\", {\n          value: true,\n          configurable: true\n        });\n      }\n      if (G) {\n        D.evalOrigin = G;\n        D.evalLine = Y;\n        D.evalColumn = J;\n        D.evalFile = Z && Z.replace(/\\\\/g, \"/\");\n      }\n      if (C) {\n        D.native = true;\n      }\n      if (I) {\n        D.function = I;\n      }\n      if (K && I !== K) {\n        D.method = K;\n      }\n      return D;\n    }\n  }\n  function updateFilePath(_updateFilePath, filePath, baseDirectory) {\n    if (filePath) {\n      filePath = filePath.replace(/\\\\/g, \"/\");\n      if (filePath.startsWith(`${baseDirectory}/`)) {\n        filePath = filePath.slice(baseDirectory.length + 1);\n      }\n      _updateFilePath.file = filePath;\n    }\n  }\n  function createNodeModulesRegex(modulePattern) {\n    if (modulePattern.length === 0) {\n      return [];\n    }\n    let initializeDevToolsForModule = modulePattern.map(_________________________________initializeDevTools => ______________________________initializeDevTools(_________________________________initializeDevTools));\n    return new RegExp(`[/\\\\\\\\]node_modules[/\\\\\\\\](?:${initializeDevToolsForModule.join(\"|\")})[/\\\\\\\\][^:]+:\\\\d+:\\\\d+`);\n  }\n  var stackTraceLinePattern = new RegExp(\"^(?:\\\\s*at )?(?:(new) )?(?:(.*?) \\\\()?(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?(?:(.+?):(\\\\d+):(\\\\d+)|(native))(\\\\)?)$\");\n  var functionNamePattern = /^(.*?) \\[as (.*?)\\]$/;\n  createStackTraceCleaner.exports = NY1;\n});\nvar initializeDevToolsConnection = (replaceTabsWithSpaces, tabSizeMultiplier = 2) => {\n  return replaceTabsWithSpaces.replace(/^\\t+/gm, repeatedSpaces => \" \".repeat(repeatedSpaces.length * tabSizeMultiplier));\n};\nvar __initializeDevTools;\nvar _getDifferenceBetweenTwoObjects = T(() => {\n  __initializeDevTools = initializeDevToolsConnection;\n});\nvar _initializeDevToolsConnection = (calculateRange, _calculateRange) => {\n  let rangeArray = [];\n  let difference = calculateRange - _calculateRange;\n  let sumAB = calculateRange + _calculateRange;\n  for (let ________currentIndex = difference; ________currentIndex <= sumAB; ________currentIndex++) {\n    rangeArray.push(________currentIndex);\n  }\n  return rangeArray;\n};\nvar ___________________________________initializeDevToolsConnection = (fetchCodeLinesByNumber, lineNumber, devToolsConnectionOptions = {}) => {\n  if (typeof fetchCodeLinesByNumber !== \"string\") {\n    throw TypeError(\"Source code is missing.\");\n  }\n  if (!lineNumber || lineNumber < 1) {\n    throw TypeError(\"Line number must start from `1`.\");\n  }\n  let sourceLines = __initializeDevTools(fetchCodeLinesByNumber).split(/\\r?\\n/);\n  if (lineNumber > sourceLines.length) {\n    return;\n  }\n  return _initializeDevToolsConnection(lineNumber, devToolsConnectionOptions.around ?? 3).filter(__currentLineIndex => sourceLines[__currentLineIndex - 1] !== undefined).map(__currentLine => ({\n    line: __currentLine,\n    value: sourceLines[__currentLine - 1]\n  }));\n};\nvar initializeDebugTools;\nvar ____________________________________________initializeDevToolsConnection = T(() => {\n  _getDifferenceBetweenTwoObjects();\n  initializeDebugTools = ___________________________________initializeDevToolsConnection;\n});\nvar ___initializeDevTools;\nvar __initializeDevToolsConnection;\nvar __processAndDisplayNodes;\nvar setupReactDevelopmentTools = T(() => {\n  initializeAppState();\n  ___initializeDevTools = IA(KA(), 1);\n  __initializeDevToolsConnection = ___initializeDevTools.forwardRef(({\n    children: childrenContent,\n    ...boxStyleProps\n  }, elementRef) => {\n    validateIntegerInput(boxStyleProps.margin, \"margin\");\n    validateIntegerInput(boxStyleProps.marginX, \"marginX\");\n    validateIntegerInput(boxStyleProps.marginY, \"marginY\");\n    validateIntegerInput(boxStyleProps.marginTop, \"marginTop\");\n    validateIntegerInput(boxStyleProps.marginBottom, \"marginBottom\");\n    validateIntegerInput(boxStyleProps.marginLeft, \"marginLeft\");\n    validateIntegerInput(boxStyleProps.marginRight, \"marginRight\");\n    validateIntegerInput(boxStyleProps.padding, \"padding\");\n    validateIntegerInput(boxStyleProps.paddingX, \"paddingX\");\n    validateIntegerInput(boxStyleProps.paddingY, \"paddingY\");\n    validateIntegerInput(boxStyleProps.paddingTop, \"paddingTop\");\n    validateIntegerInput(boxStyleProps.paddingBottom, \"paddingBottom\");\n    validateIntegerInput(boxStyleProps.paddingLeft, \"paddingLeft\");\n    validateIntegerInput(boxStyleProps.paddingRight, \"paddingRight\");\n    validateIntegerInput(boxStyleProps.gap, \"gap\");\n    validateIntegerInput(boxStyleProps.columnGap, \"columnGap\");\n    validateIntegerInput(boxStyleProps.rowGap, \"rowGap\");\n    return ___initializeDevTools.default.createElement(\"ink-box\", {\n      ref: elementRef,\n      style: {\n        ...boxStyleProps,\n        overflowX: boxStyleProps.overflowX ?? boxStyleProps.overflow ?? \"visible\",\n        overflowY: boxStyleProps.overflowY ?? boxStyleProps.overflow ?? \"visible\"\n      }\n    }, childrenContent);\n  });\n  __initializeDevToolsConnection.displayName = \"Box\";\n  __initializeDevToolsConnection.defaultProps = {\n    flexWrap: \"nowrap\",\n    flexDirection: \"row\",\n    flexGrow: 0,\n    flexShrink: 1\n  };\n  __processAndDisplayNodes = __initializeDevToolsConnection;\n});\nfunction ThemeProvider({\n  children: __children,\n  initialState: initialThemeState\n}) {\n  let [_currentTheme, setThemeState] = _initializeReactDevTools.useState(initialThemeState);\n  let [previewTheme, setPreviewThemeValue] = _initializeReactDevTools.useState(null);\n  let themeContext = ___initializeDevToolsConnection.useMemo(() => ({\n    theme: _currentTheme,\n    setTheme: themeConfig => {\n      n0({\n        ...L1(),\n        theme: themeConfig\n      });\n      setThemeState(themeConfig);\n      setThemeForColorManagement(themeConfig);\n      setPreviewThemeValue(null);\n    },\n    setPreviewTheme: _______inputValue => {\n      setPreviewThemeValue(_______inputValue);\n      setThemeForColorManagement(_______inputValue);\n    },\n    savePreview: () => {\n      if (previewTheme !== null) {\n        n0({\n          ...L1(),\n          theme: previewTheme\n        });\n        setThemeState(previewTheme);\n        setPreviewThemeValue(null);\n      }\n    },\n    currentTheme: previewTheme ?? _currentTheme\n  }), [_currentTheme, previewTheme]);\n  return ___initializeDevToolsConnection.default.createElement(____initializeDevToolsConnection.Provider, {\n    value: themeContext\n  }, __children);\n}\nfunction useThemeContext() {\n  let {\n    currentTheme: currentTheme,\n    setTheme: updateTheme\n  } = _initializeReactDevTools.useContext(____initializeDevToolsConnection);\n  return [currentTheme, updateTheme];\n}\nfunction _______________________________initializeDevTools() {\n  let {\n    setPreviewTheme: setPreviewTheme,\n    savePreview: savePreview\n  } = _initializeReactDevTools.useContext(____initializeDevToolsConnection);\n  return {\n    setPreviewTheme: setPreviewTheme,\n    savePreview: savePreview\n  };\n}\nvar ___initializeDevToolsConnection;\nvar _initializeReactDevTools;\nvar ____initializeDevToolsConnection;\nvar OPA = T(() => {\n  kB();\n  PY1();\n  ___initializeDevToolsConnection = IA(KA(), 1);\n  _initializeReactDevTools = IA(KA(), 1);\n  ____initializeDevToolsConnection = _initializeReactDevTools.createContext({\n    theme: null,\n    setTheme: _defaultValue => _defaultValue,\n    setPreviewTheme: unspecifiedVariable => unspecifiedVariable,\n    savePreview: () => {},\n    currentTheme: null\n  });\n});\nfunction StyledText({\n  color: textColor,\n  backgroundColor: __backgroundColor,\n  dimColor: isDimmedColor = false,\n  bold: isBold = false,\n  italic: isItalic = false,\n  underline: isUnderlined = false,\n  strikethrough: useStrikethrough = false,\n  inverse: isInverse = false,\n  wrap: textWrap = \"wrap\",\n  children: __textContent\n}) {\n  let [_themeContext] = useThemeContext();\n  if (__textContent === undefined || __textContent === null) {\n    return null;\n  }\n  return _____initializeDevToolsConnection.default.createElement(\"ink-text\", {\n    style: {\n      flexGrow: 0,\n      flexShrink: 1,\n      flexDirection: \"row\",\n      textWrap: textWrap\n    },\n    internal_transform: applyTextStyles => {\n      if (isDimmedColor) {\n        applyTextStyles = formatColorBasedOnActivity(\"inactive\", _themeContext)(applyTextStyles);\n      }\n      if (textColor) {\n        applyTextStyles = formatColorBasedOnActivity(textColor, _themeContext)(applyTextStyles);\n      }\n      if (__backgroundColor) {\n        applyTextStyles = formatColorBasedOnActivity(__backgroundColor, _themeContext, \"background\")(applyTextStyles);\n      }\n      if (isBold) {\n        applyTextStyles = iA.bold(applyTextStyles);\n      }\n      if (isItalic) {\n        applyTextStyles = iA.italic(applyTextStyles);\n      }\n      if (isUnderlined) {\n        applyTextStyles = iA.underline(applyTextStyles);\n      }\n      if (useStrikethrough) {\n        applyTextStyles = iA.strikethrough(applyTextStyles);\n      }\n      if (isInverse) {\n        applyTextStyles = iA.inverse(applyTextStyles);\n      }\n      return applyTextStyles;\n    }\n  }, __textContent);\n}\nvar _____initializeDevToolsConnection;\nvar jY1 = T(() => {\n  f2();\n  ________________________________initializeDevToolsConnection();\n  OPA();\n  _____initializeDevToolsConnection = IA(KA(), 1);\n});\nimport * as DevToolsManager from \"node:fs\";\nimport { cwd as ______initializeDevToolsConnection } from \"node:process\";\nfunction handleErrorDisplay({\n  error: _errorObject\n}) {\n  let stackLines = _errorObject.stack ? _errorObject.stack.split(`\n`).slice(1) : undefined;\n  let parsedErrorStack = stackLines ? ________initializeDevToolsConnection.parseLine(stackLines[0]) : undefined;\n  let devToolsFilePath = devToolsInitializer(parsedErrorStack?.file);\n  let debugToolLines;\n  let maxLineLength = 0;\n  if (devToolsFilePath && parsedErrorStack?.line && DevToolsManager.existsSync(devToolsFilePath)) {\n    let stackTraceLine = DevToolsManager.readFileSync(devToolsFilePath, \"utf8\");\n    debugToolLines = initializeDebugTools(stackTraceLine, parsedErrorStack.line);\n    if (debugToolLines) {\n      for (let {\n        line: lineLength\n      } of debugToolLines) {\n        maxLineLength = Math.max(maxLineLength, String(lineLength).length);\n      }\n    }\n  }\n  return getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    flexDirection: \"column\",\n    padding: 1\n  }, getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, null, getDifferencesBetweenObjects.default.createElement(StyledText, {\n    backgroundColor: \"error\",\n    color: \"text\"\n  }, \" \", \"ERROR\", \" \"), getDifferencesBetweenObjects.default.createElement(StyledText, null, \" \", _errorObject.message)), parsedErrorStack && devToolsFilePath && getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    marginTop: 1\n  }, getDifferencesBetweenObjects.default.createElement(StyledText, {\n    dimColor: true\n  }, devToolsFilePath, \":\", parsedErrorStack.line, \":\", parsedErrorStack.column)), parsedErrorStack && debugToolLines && getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    marginTop: 1,\n    flexDirection: \"column\"\n  }, debugToolLines.map(({\n    line: lineIdentifier,\n    value: valueText\n  }) => getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    key: lineIdentifier\n  }, getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    width: maxLineLength + 1\n  }, getDifferencesBetweenObjects.default.createElement(StyledText, {\n    dimColor: lineIdentifier !== parsedErrorStack.line,\n    backgroundColor: lineIdentifier === parsedErrorStack.line ? \"error\" : undefined,\n    color: lineIdentifier === parsedErrorStack.line ? \"text\" : undefined\n  }, String(lineIdentifier).padStart(maxLineLength, \" \"), \":\")), getDifferencesBetweenObjects.default.createElement(StyledText, {\n    key: lineIdentifier,\n    backgroundColor: lineIdentifier === parsedErrorStack.line ? \"error\" : undefined,\n    color: lineIdentifier === parsedErrorStack.line ? \"text\" : undefined\n  }, \" \" + valueText)))), _errorObject.stack && getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    marginTop: 1,\n    flexDirection: \"column\"\n  }, _errorObject.stack.split(`\n`).slice(1).map(processDevToolsLine => {\n    let parsedLineInfo = ________initializeDevToolsConnection.parseLine(processDevToolsLine);\n    if (!parsedLineInfo) {\n      return getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n        key: processDevToolsLine\n      }, getDifferencesBetweenObjects.default.createElement(StyledText, {\n        dimColor: true\n      }, \"- \"), getDifferencesBetweenObjects.default.createElement(StyledText, {\n        dimColor: true,\n        bold: true\n      }, processDevToolsLine));\n    }\n    return getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n      key: processDevToolsLine\n    }, getDifferencesBetweenObjects.default.createElement(StyledText, {\n      dimColor: true\n    }, \"- \"), getDifferencesBetweenObjects.default.createElement(StyledText, {\n      dimColor: true,\n      bold: true\n    }, parsedLineInfo.function), getDifferencesBetweenObjects.default.createElement(StyledText, {\n      dimColor: true\n    }, \" \", \"(\", devToolsInitializer(parsedLineInfo.file) ?? \"\", \":\", parsedLineInfo.line, \":\", parsedLineInfo.column, \")\"));\n  })));\n}\nvar getDifferencesBetweenObjects;\nvar _______initializeDevToolsConnection;\nvar devToolsInitializer = removeFilePathPrefix => {\n  return removeFilePathPrefix?.replace(`file://${______initializeDevToolsConnection()}/`, \"\");\n};\nvar ________initializeDevToolsConnection;\nvar Wy0 = T(() => {\n  ____________________________________________initializeDevToolsConnection();\n  setupReactDevelopmentTools();\n  jY1();\n  getDifferencesBetweenObjects = IA(KA(), 1);\n  _______initializeDevToolsConnection = IA(________________________initializeDevTools(), 1);\n  ________initializeDevToolsConnection = new _______initializeDevToolsConnection.default({\n    cwd: ______initializeDevToolsConnection(),\n    internals: _______initializeDevToolsConnection.default.nodeInternals()\n  });\n});\nimport { Buffer as _________initializeDevToolsConnection } from \"node:buffer\";\nfunction createKeyboardEventState(inputSequence) {\n  return {\n    name: \"\",\n    fn: false,\n    ctrl: false,\n    meta: false,\n    shift: false,\n    option: false,\n    sequence: inputSequence,\n    raw: inputSequence,\n    isPasted: true\n  };\n}\nfunction processInputToString(___processInput) {\n  if (_________initializeDevToolsConnection.isBuffer(___processInput)) {\n    if (___processInput[0] > 127 && ___processInput[1] === undefined) {\n      ___processInput[0] -= 128;\n      return \"\u001b\" + String(___processInput);\n    } else {\n      return String(___processInput);\n    }\n  } else if (___processInput !== undefined && typeof ___processInput !== \"string\") {\n    return String(___processInput);\n  } else if (!___processInput) {\n    return \"\";\n  } else {\n    return ___processInput;\n  }\n}\nfunction processInputAndInitializeDevTools(processInput, devToolsConnectionParameter = \"\") {\n  let isDevToolsConnectionInitialized = devToolsConnectionParameter === null;\n  let ______inputString = isDevToolsConnectionInitialized ? \"\" : processInputToString(devToolsConnectionParameter);\n  if (processInput.mode === \"IN_PASTE\") {\n    if ((processInput.incomplete.slice(-___________initializeDevToolsConnection.length + 1) + ______inputString).indexOf(___________initializeDevToolsConnection) === -1) {\n      return [[], {\n        ...processInput,\n        incomplete: processInput.incomplete + ______inputString\n      }];\n    }\n  }\n  let processedInputBuffer = processInput.incomplete + ______inputString;\n  let devToolsInitializationState = {\n    ...processInput,\n    incomplete: \"\"\n  };\n  let createdKeyboardEvents = [];\n  let inputProcessingHandler = {\n    NORMAL: () => {\n      let devToolsExecutionResult = ____initializeDevTools.exec(processedInputBuffer);\n      processedInputBuffer = processedInputBuffer.substring(devToolsExecutionResult[0].length);\n      let renderedOutput = devToolsExecutionResult[1];\n      if (!devToolsExecutionResult[2] && !isDevToolsConnectionInitialized) {\n        let renderInitialization = _initializeRenderer.exec(renderedOutput);\n        devToolsInitializationState.incomplete = renderInitialization[2];\n        renderedOutput = renderInitialization[1];\n      }\n      if (renderedOutput) {\n        createdKeyboardEvents.push(_________________initializeDevelopmentTools(renderedOutput));\n      }\n      if (devToolsExecutionResult[2] === _____initializeDevelopmentTools) {\n        devToolsInitializationState.mode = \"IN_PASTE\";\n      } else if (devToolsExecutionResult[2]) {\n        createdKeyboardEvents.push(_________________initializeDevelopmentTools(devToolsExecutionResult[2]));\n      }\n    },\n    IN_PASTE: () => {\n      let devToolsConnectionIndex = processedInputBuffer.indexOf(___________initializeDevToolsConnection);\n      if (devToolsConnectionIndex === -1) {\n        if (!isDevToolsConnectionInitialized) {\n          devToolsInitializationState.incomplete = processedInputBuffer;\n          processedInputBuffer = \"\";\n          return;\n        }\n        devToolsConnectionIndex = processedInputBuffer.length;\n      }\n      let devToolsConnectionData = processedInputBuffer.substring(0, devToolsConnectionIndex);\n      if (devToolsConnectionData) {\n        createdKeyboardEvents.push(createKeyboardEventState(devToolsConnectionData));\n      }\n      processedInputBuffer = processedInputBuffer.substring(devToolsConnectionIndex + ___________initializeDevToolsConnection.length);\n      devToolsInitializationState.mode = \"NORMAL\";\n    }\n  };\n  while (processedInputBuffer) {\n    inputProcessingHandler[devToolsInitializationState.mode]();\n  }\n  return [createdKeyboardEvents, devToolsInitializationState];\n}\nvar initializeRenderer;\nvar __________initializeDevToolsConnection;\nvar _____initializeDevelopmentTools = \"\u001b[200~\";\nvar ___________initializeDevToolsConnection = \"\u001b[201~\";\nvar ____initializeDevTools;\nvar _initializeRenderer;\nvar ____________initializeDevToolsConnection;\nvar _____initializeDevTools;\nvar ______initializeDevelopmentTools;\nvar ______initializeDevTools = isValueInArray => {\n  return [\"[a\", \"[b\", \"[c\", \"[d\", \"[e\", \"[2$\", \"[3$\", \"[5$\", \"[6$\", \"[7$\", \"[8$\", \"[Z\"].includes(isValueInArray);\n};\nvar _____________initializeDevToolsConnection = isValueInAllowedList => {\n  return [\"Oa\", \"Ob\", \"Oc\", \"Od\", \"Oe\", \"[2^\", \"[3^\", \"[5^\", \"[6^\", \"[7^\", \"[8^\"].includes(isValueInAllowedList);\n};\nvar _________________initializeDevelopmentTools = (handleKeyInput = \"\") => {\n  let keySequenceMatch;\n  let keyEventDetails = {\n    name: \"\",\n    fn: false,\n    ctrl: false,\n    meta: false,\n    shift: false,\n    option: false,\n    sequence: handleKeyInput,\n    raw: handleKeyInput,\n    isPasted: false\n  };\n  keyEventDetails.sequence = keyEventDetails.sequence || handleKeyInput || keyEventDetails.name;\n  if (handleKeyInput === \"\\r\") {\n    keyEventDetails.raw = undefined;\n    keyEventDetails.name = \"return\";\n  } else if (handleKeyInput === `\n`) {\n    keyEventDetails.name = \"enter\";\n  } else if (handleKeyInput === \"\\t\") {\n    keyEventDetails.name = \"tab\";\n  } else if (handleKeyInput === \"\\b\" || handleKeyInput === \"\u001b\\b\") {\n    keyEventDetails.name = \"backspace\";\n    keyEventDetails.meta = handleKeyInput.charAt(0) === \"\u001b\";\n  } else if (handleKeyInput === \"\" || handleKeyInput === \"\u001b\") {\n    keyEventDetails.name = \"backspace\";\n    keyEventDetails.meta = handleKeyInput.charAt(0) === \"\u001b\";\n  } else if (handleKeyInput === \"\u001b\" || handleKeyInput === \"\u001b\u001b\") {\n    keyEventDetails.name = \"escape\";\n    keyEventDetails.meta = handleKeyInput.length === 2;\n  } else if (handleKeyInput === \" \" || handleKeyInput === \"\u001b \") {\n    keyEventDetails.name = \"space\";\n    keyEventDetails.meta = handleKeyInput.length === 2;\n  } else if (handleKeyInput === \"\u001f\") {\n    keyEventDetails.name = \"_\";\n    keyEventDetails.ctrl = true;\n  } else if (handleKeyInput <= \"\u001a\" && handleKeyInput.length === 1) {\n    keyEventDetails.name = String.fromCharCode(handleKeyInput.charCodeAt(0) + 97 - 1);\n    keyEventDetails.ctrl = true;\n  } else if (handleKeyInput.length === 1 && handleKeyInput >= \"0\" && handleKeyInput <= \"9\") {\n    keyEventDetails.name = \"number\";\n  } else if (handleKeyInput.length === 1 && handleKeyInput >= \"a\" && handleKeyInput <= \"z\") {\n    keyEventDetails.name = handleKeyInput;\n  } else if (handleKeyInput.length === 1 && handleKeyInput >= \"A\" && handleKeyInput <= \"Z\") {\n    keyEventDetails.name = handleKeyInput.toLowerCase();\n    keyEventDetails.shift = true;\n  } else if (keySequenceMatch = initializeRenderer.exec(handleKeyInput)) {\n    keyEventDetails.meta = true;\n    keyEventDetails.shift = /^[A-Z]$/.test(keySequenceMatch[1]);\n  } else if (keySequenceMatch = __________initializeDevToolsConnection.exec(handleKeyInput)) {\n    let _inputSequence = [...handleKeyInput];\n    if (_inputSequence[0] === \"\u001b\" && _inputSequence[1] === \"\u001b\") {\n      keyEventDetails.option = true;\n    }\n    let inputSequenceProcessed = [keySequenceMatch[1], keySequenceMatch[2], keySequenceMatch[4], keySequenceMatch[6]].filter(Boolean).join(\"\");\n    let keyPressInfo = (keySequenceMatch[3] || keySequenceMatch[5] || 1) - 1;\n    keyEventDetails.ctrl = !!(keyPressInfo & 4);\n    keyEventDetails.meta = !!(keyPressInfo & 10);\n    keyEventDetails.shift = !!(keyPressInfo & 1);\n    keyEventDetails.code = inputSequenceProcessed;\n    keyEventDetails.name = _____initializeDevTools[inputSequenceProcessed];\n    keyEventDetails.shift = ______initializeDevTools(inputSequenceProcessed) || keyEventDetails.shift;\n    keyEventDetails.ctrl = _____________initializeDevToolsConnection(inputSequenceProcessed) || keyEventDetails.ctrl;\n  }\n  if (keyEventDetails.raw === \"\u001bb\") {\n    keyEventDetails.meta = true;\n    keyEventDetails.name = \"left\";\n  } else if (keyEventDetails.raw === \"\u001bf\") {\n    keyEventDetails.meta = true;\n    keyEventDetails.name = \"right\";\n  }\n  switch (handleKeyInput) {\n    case \"\u001b[1~\":\n      return {\n        name: \"home\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n    case \"\u001b[4~\":\n      return {\n        name: \"end\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n    case \"\u001b[5~\":\n      return {\n        name: \"pageup\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n    case \"\u001b[6~\":\n      return {\n        name: \"pagedown\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n    case \"\u001b[1;5D\":\n      return {\n        name: \"left\",\n        ctrl: true,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n    case \"\u001b[1;5C\":\n      return {\n        name: \"right\",\n        ctrl: true,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n    case \"\u001b[1~\":\n      return {\n        name: \"left\",\n        ctrl: true,\n        fn: true,\n        meta: false,\n        shift: false,\n        option: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n    case \"\u001b[4~\":\n      return {\n        name: \"right\",\n        ctrl: true,\n        fn: true,\n        meta: false,\n        shift: false,\n        option: false,\n        sequence: handleKeyInput,\n        raw: handleKeyInput,\n        isPasted: false\n      };\n  }\n  return keyEventDetails;\n};\nvar _____initializeReactDevToolsConnection = T(() => {\n  initializeRenderer = /^(?:\\x1b)([a-zA-Z0-9])$/;\n  __________initializeDevToolsConnection = /^(?:\\x1b+)(O|N|\\[|\\[\\[)(?:(\\d+)(?:;(\\d+))?([~^$])|(?:1;)?(\\d+)?([a-zA-Z]))/;\n  ____initializeDevTools = new RegExp(\"^(.*?)(\" + [\"\\\\x1b\\\\][0-9]*(?:;[^\\\\x07\\\\x1b]*)*(?:\\\\x07|\\\\x1b\\\\\\\\)\", \"\\\\x1bP[^\\\\x1b]*\\\\x1b\\\\\\\\\", \"\\\\x1b\\\\[[0-9]*(?:;[0-9]*)*[A-Za-z~]\", \"\\\\x1bO[A-Za-z]\", \"\\\\x1b[\\\\x00-\\\\x7F]\", \"\\\\x1b\\\\x1b\", \"$\"].map(pattern => `(?:${pattern})`).join(\"|\") + \")\", \"s\");\n  _initializeRenderer = new RegExp(\"(.*?)(\" + [\"\\\\x1b\\\\][0-9]*(?:;[^\\\\x07\\\\x1b]*)*$\", \"\\\\x1bP[^\\\\x1b]*$\", \"\\\\x1b\\\\[[0-9]*(?:;[0-9]*)*$\", \"\\\\x1bO$\", \"\\\\x1b$\", \"$\"].map(_regexPattern => `(?:${_regexPattern})`).join(\"|\") + \")\", \"s\");\n  ____________initializeDevToolsConnection = {\n    mode: \"NORMAL\",\n    incomplete: \"\"\n  };\n  _____initializeDevTools = {\n    OP: \"f1\",\n    OQ: \"f2\",\n    OR: \"f3\",\n    OS: \"f4\",\n    \"[11~\": \"f1\",\n    \"[12~\": \"f2\",\n    \"[13~\": \"f3\",\n    \"[14~\": \"f4\",\n    \"[[A\": \"f1\",\n    \"[[B\": \"f2\",\n    \"[[C\": \"f3\",\n    \"[[D\": \"f4\",\n    \"[[E\": \"f5\",\n    \"[15~\": \"f5\",\n    \"[17~\": \"f6\",\n    \"[18~\": \"f7\",\n    \"[19~\": \"f8\",\n    \"[20~\": \"f9\",\n    \"[21~\": \"f10\",\n    \"[23~\": \"f11\",\n    \"[24~\": \"f12\",\n    \"[A\": \"up\",\n    \"[B\": \"down\",\n    \"[C\": \"right\",\n    \"[D\": \"left\",\n    \"[E\": \"clear\",\n    \"[F\": \"end\",\n    \"[H\": \"home\",\n    OA: \"up\",\n    OB: \"down\",\n    OC: \"right\",\n    OD: \"left\",\n    OE: \"clear\",\n    OF: \"end\",\n    OH: \"home\",\n    \"[1~\": \"home\",\n    \"[2~\": \"insert\",\n    \"[3~\": \"delete\",\n    \"[4~\": \"end\",\n    \"[5~\": \"pageup\",\n    \"[6~\": \"pagedown\",\n    \"[[5~\": \"pageup\",\n    \"[[6~\": \"pagedown\",\n    \"[7~\": \"home\",\n    \"[8~\": \"end\",\n    \"[a\": \"up\",\n    \"[b\": \"down\",\n    \"[c\": \"right\",\n    \"[d\": \"left\",\n    \"[e\": \"clear\",\n    \"[2$\": \"insert\",\n    \"[3$\": \"delete\",\n    \"[5$\": \"pageup\",\n    \"[6$\": \"pagedown\",\n    \"[7$\": \"home\",\n    \"[8$\": \"end\",\n    Oa: \"up\",\n    Ob: \"down\",\n    Oc: \"right\",\n    Od: \"left\",\n    Oe: \"clear\",\n    \"[2^\": \"insert\",\n    \"[3^\": \"delete\",\n    \"[5^\": \"pageup\",\n    \"[6^\": \"pagedown\",\n    \"[7^\": \"home\",\n    \"[8^\": \"end\",\n    \"[Z\": \"tab\"\n  };\n  ______initializeDevelopmentTools = [...Object.values(_____initializeDevTools), \"backspace\"];\n});\nfunction processInputKey(inputKey) {\n  let keyState = {\n    upArrow: inputKey.name === \"up\",\n    downArrow: inputKey.name === \"down\",\n    leftArrow: inputKey.name === \"left\",\n    rightArrow: inputKey.name === \"right\",\n    pageDown: inputKey.name === \"pagedown\",\n    pageUp: inputKey.name === \"pageup\",\n    home: inputKey.name === \"home\",\n    end: inputKey.name === \"end\",\n    return: inputKey.name === \"return\",\n    escape: inputKey.name === \"escape\",\n    fn: inputKey.fn,\n    ctrl: inputKey.ctrl,\n    shift: inputKey.shift,\n    tab: inputKey.name === \"tab\",\n    backspace: inputKey.name === \"backspace\",\n    delete: inputKey.name === \"delete\",\n    meta: inputKey.meta || inputKey.name === \"escape\" || inputKey.option\n  };\n  let __inputSequence = inputKey.ctrl ? inputKey.name : inputKey.sequence;\n  if (__inputSequence === undefined) {\n    __inputSequence = \"\";\n  }\n  if (inputKey.name && ______initializeDevelopmentTools.includes(inputKey.name)) {\n    __inputSequence = \"\";\n  }\n  if (__inputSequence.startsWith(\"\u001b\")) {\n    __inputSequence = __inputSequence.slice(1);\n  }\n  if (__inputSequence.length === 1 && typeof __inputSequence[0] === \"string\" && __inputSequence[0].toUpperCase() === __inputSequence[0]) {\n    keyState.shift = true;\n  }\n  return [keyState, __inputSequence];\n}\nvar ProcessPublicAccess;\nvar _________________________________________________________initializeDevToolsConnection = T(() => {\n  _____initializeReactDevToolsConnection();\n  ProcessPublicAccess = class KeyPressHandler extends EventPropagationHandler {\n    keypress;\n    key;\n    input;\n    constructor(__inputKey) {\n      super();\n      let [extractedKey, parsedInput] = processInputKey(__inputKey);\n      this.keypress = __inputKey;\n      this.key = extractedKey;\n      this.input = parsedInput;\n    }\n  };\n});\nvar ______________initializeDevToolsConnection;\nvar initializeDebuggerConnection;\nvar ____________________________________initializeDevToolsConnection = T(() => {\n  ______________initializeDevToolsConnection = IA(KA(), 1);\n  initializeDebuggerConnection = ______________initializeDevToolsConnection.createContext(false);\n});\nvar _______initializeDevTools;\nvar SinglePageApplication;\nvar __________________initializeDevelopmentTools = T(() => {\n  _______initializeDevTools = IA(KA(), 1);\n  SinglePageApplication = _______initializeDevTools.createContext(null);\n});\nvar _cleanupYogaNode;\nvar __initializeRenderer = \"\\t\";\nvar ________initializeDevTools = \"\u001b[Z\";\nvar _________initializeDevTools = \"\u001b\";\nvar _______initializeDevelopmentTools;\nvar _colorPalette;\nvar zy0 = T(() => {\n  _____initializeReactDevTools();\n  _______________________initializeDevTools();\n  ___________________________________________initializeDevToolsConnection();\n  __createInstance();\n  Wy0();\n  _____initializeReactDevToolsConnection();\n  OPA();\n  __________________________________________________initializeDevToolsConnection();\n  _________________________________________________________initializeDevToolsConnection();\n  ____________________________________initializeDevToolsConnection();\n  __________________initializeDevelopmentTools();\n  _cleanupYogaNode = IA(KA(), 1);\n  _______initializeDevelopmentTools = process.platform !== \"win32\";\n  _colorPalette = class InternalAppComponent extends _cleanupYogaNode.PureComponent {\n    static displayName = \"InternalApp\";\n    static getDerivedStateFromError(_______________error) {\n      return {\n        error: _______________error\n      };\n    }\n    state = {\n      isFocusEnabled: true,\n      activeFocusId: undefined,\n      focusables: [],\n      error: undefined\n    };\n    rawModeEnabledCount = 0;\n    internal_eventEmitter = new initializeDevTools();\n    keyParseState = ____________initializeDevToolsConnection;\n    incompleteEscapeTimer = null;\n    NORMAL_TIMEOUT = 50;\n    PASTE_TIMEOUT = 500;\n    isRawModeSupported() {\n      return this.props.stdin.isTTY;\n    }\n    render() {\n      return _cleanupYogaNode.default.createElement(SinglePageApplication.Provider, {\n        value: {\n          columns: this.props.terminalColumns,\n          rows: this.props.terminalRows\n        }\n      }, _cleanupYogaNode.default.createElement(initializeDebuggerConnection.Provider, {\n        value: this.props.ink2\n      }, _cleanupYogaNode.default.createElement(_initializeDevelopmentTools.Provider, {\n        value: {\n          exit: this.handleExit\n        }\n      }, _cleanupYogaNode.default.createElement(ThemeProvider, {\n        initialState: this.props.initialTheme\n      }, _cleanupYogaNode.default.createElement(initializeReactDevTools.Provider, {\n        value: {\n          stdin: this.props.stdin,\n          setRawMode: this.handleSetRawMode,\n          isRawModeSupported: this.isRawModeSupported(),\n          internal_exitOnCtrlC: this.props.exitOnCtrlC,\n          internal_eventEmitter: this.internal_eventEmitter\n        }\n      }, _cleanupYogaNode.default.createElement(_processAndDisplayNodes.Provider, {\n        value: {\n          activeId: this.state.activeFocusId,\n          add: this.addFocusable,\n          remove: this.removeFocusable,\n          activate: this.activateFocusable,\n          deactivate: this.deactivateFocusable,\n          enableFocus: this.enableFocus,\n          disableFocus: this.disableFocus,\n          focusNext: this.focusNext,\n          focusPrevious: this.focusPrevious,\n          focus: this.focus\n        }\n      }, this.state.error ? _cleanupYogaNode.default.createElement(handleErrorDisplay, {\n        error: this.state.error\n      }) : this.props.children))))));\n    }\n    componentDidMount() {\n      if (this.props.stdout.isTTY) {\n        this.props.stdout.write(terminalCommands.cursorHide);\n      }\n    }\n    componentWillUnmount() {\n      if (this.props.stdout.isTTY) {\n        this.props.stdout.write(terminalCommands.cursorShow);\n      }\n      if (this.incompleteEscapeTimer) {\n        clearTimeout(this.incompleteEscapeTimer);\n        this.incompleteEscapeTimer = null;\n      }\n      if (this.isRawModeSupported()) {\n        this.handleSetRawMode(false);\n      }\n    }\n    componentDidCatch(________________error) {\n      this.handleExit(________________error);\n    }\n    handleSetRawMode = toggleRawMode => {\n      let {\n        stdin: _inputStream\n      } = this.props;\n      if (!this.isRawModeSupported()) {\n        if (_inputStream === process.stdin) {\n          throw Error(`Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);\n        } else {\n          throw Error(`Raw mode is not supported on the stdin provided to Ink.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);\n        }\n      }\n      _inputStream.setEncoding(\"utf8\");\n      if (toggleRawMode) {\n        if (this.rawModeEnabledCount === 0) {\n          _inputStream.ref();\n          _inputStream.setRawMode(true);\n          _inputStream.addListener(\"readable\", this.handleReadable);\n          this.props.stdout.write(\"\u001b[?2004h\");\n        }\n        this.rawModeEnabledCount++;\n        return;\n      }\n      if (--this.rawModeEnabledCount === 0) {\n        this.props.stdout.write(\"\u001b[?2004l\");\n        _inputStream.setRawMode(false);\n        _inputStream.removeListener(\"readable\", this.handleReadable);\n        _inputStream.unref();\n      }\n    };\n    flushIncomplete = () => {\n      this.incompleteEscapeTimer = null;\n      if (!this.keyParseState.incomplete) {\n        return;\n      }\n      this.processInput(null);\n    };\n    processInput = processInputAndEmitEvents => {\n      let [inputItems, parsedKeyState] = processInputAndInitializeDevTools(this.keyParseState, processInputAndEmitEvents);\n      this.keyParseState = parsedKeyState;\n      for (let inputItem of inputItems) {\n        this.handleInput(inputItem.sequence);\n        let processPublicAccessInstance = new ProcessPublicAccess(inputItem);\n        this.internal_eventEmitter.emit(\"input\", processPublicAccessInstance);\n      }\n      if (this.keyParseState.incomplete) {\n        if (this.incompleteEscapeTimer) {\n          clearTimeout(this.incompleteEscapeTimer);\n        }\n        this.incompleteEscapeTimer = setTimeout(this.flushIncomplete, this.keyParseState.mode === \"IN_PASTE\" ? this.PASTE_TIMEOUT : this.NORMAL_TIMEOUT);\n      }\n    };\n    handleReadable = () => {\n      let _________inputData;\n      while ((_________inputData = this.props.stdin.read()) !== null) {\n        this.processInput(_________inputData);\n      }\n    };\n    handleInput = inputEvent => {\n      if (inputEvent === \"\u0003\" && this.props.exitOnCtrlC) {\n        this.handleExit();\n      }\n      if (inputEvent === \"\u001a\" && _______initializeDevelopmentTools) {\n        this.handleSuspend();\n      }\n      if (inputEvent === _________initializeDevTools && this.state.activeFocusId) {\n        this.setState({\n          activeFocusId: undefined\n        });\n      }\n      if (this.state.isFocusEnabled && this.state.focusables.length > 0) {\n        if (inputEvent === __initializeRenderer) {\n          this.focusNext();\n        }\n        if (inputEvent === ________initializeDevTools) {\n          this.focusPrevious();\n        }\n      }\n    };\n    handleExit = exitHandler => {\n      if (this.isRawModeSupported()) {\n        this.handleSetRawMode(false);\n      }\n      this.props.onExit(exitHandler);\n    };\n    handleSuspend = () => {\n      if (!this.isRawModeSupported()) {\n        return;\n      }\n      let rawModeEnabledCount = this.rawModeEnabledCount;\n      while (this.rawModeEnabledCount > 0) {\n        this.handleSetRawMode(false);\n      }\n      if (this.props.stdout.isTTY) {\n        this.props.stdout.write(terminalCommands.cursorShow);\n        this.props.stdout.write(\"\u001b[?1004l\");\n      }\n      this.internal_eventEmitter.emit(\"suspend\");\n      let handleResumeRawMode = () => {\n        for (let rawModeIterationCounter = 0; rawModeIterationCounter < rawModeEnabledCount; rawModeIterationCounter++) {\n          if (this.isRawModeSupported()) {\n            this.handleSetRawMode(true);\n          }\n        }\n        if (this.props.stdout.isTTY) {\n          this.props.stdout.write(terminalCommands.cursorHide);\n          this.props.stdout.write(\"\u001b[?1004h\");\n        }\n        this.internal_eventEmitter.emit(\"resume\");\n        process.removeListener(\"SIGCONT\", handleResumeRawMode);\n      };\n      process.on(\"SIGCONT\", handleResumeRawMode);\n      process.kill(process.pid, \"SIGSTOP\");\n    };\n    enableFocus = () => {\n      this.setState({\n        isFocusEnabled: true\n      });\n    };\n    disableFocus = () => {\n      this.setState({\n        isFocusEnabled: false\n      });\n    };\n    focus = updateActiveFocusId => {\n      this.setState(updateActiveFocus => {\n        if (!updateActiveFocus.focusables.some(itemId => itemId?.id === updateActiveFocusId)) {\n          return updateActiveFocus;\n        }\n        return {\n          activeFocusId: updateActiveFocusId\n        };\n      });\n    };\n    focusNext = () => {\n      this.setState(_getActiveFocusId => {\n        let _activeFocusableId = _getActiveFocusId.focusables.find(_isActive => _isActive.isActive)?.id;\n        return {\n          activeFocusId: this.findNextFocusable(_getActiveFocusId) ?? _activeFocusableId\n        };\n      });\n    };\n    focusPrevious = () => {\n      this.setState(getActiveFocusId => {\n        let activeFocusableId = getActiveFocusId.focusables.findLast(__isActive => __isActive.isActive)?.id;\n        return {\n          activeFocusId: this.findPreviousFocusable(getActiveFocusId) ?? activeFocusableId\n        };\n      });\n    };\n    addFocusable = (focusableElementId, {\n      autoFocus: shouldAutoFocus\n    }) => {\n      this.setState(getUpdatedFocusState => {\n        let activeFocusId = getUpdatedFocusState.activeFocusId;\n        if (!activeFocusId && shouldAutoFocus) {\n          activeFocusId = focusableElementId;\n        }\n        return {\n          activeFocusId: activeFocusId,\n          focusables: [...getUpdatedFocusState.focusables, {\n            id: focusableElementId,\n            isActive: true\n          }]\n        };\n      });\n    };\n    removeFocusable = handleActiveFocusChange => {\n      this.setState(updateActiveFocusAndFilterFocusables => ({\n        activeFocusId: updateActiveFocusAndFilterFocusables.activeFocusId === handleActiveFocusChange ? undefined : updateActiveFocusAndFilterFocusables.activeFocusId,\n        focusables: updateActiveFocusAndFilterFocusables.focusables.filter(isIdNotEqualToA => {\n          return isIdNotEqualToA.id !== handleActiveFocusChange;\n        })\n      }));\n    };\n    activateFocusable = activateFocusableById => {\n      this.setState(updateFocusableItems => ({\n        focusables: updateFocusableItems.focusables.map(updateOrActivateEntity => {\n          if (updateOrActivateEntity.id !== activateFocusableById) {\n            return updateOrActivateEntity;\n          }\n          return {\n            id: activateFocusableById,\n            isActive: true\n          };\n        })\n      }));\n    };\n    deactivateFocusable = toggleFocusOnUserById => {\n      this.setState(updateFocusState => ({\n        activeFocusId: updateFocusState.activeFocusId === toggleFocusOnUserById ? undefined : updateFocusState.activeFocusId,\n        focusables: updateFocusState.focusables.map(getUserByIdOrDefault => {\n          if (getUserByIdOrDefault.id !== toggleFocusOnUserById) {\n            return getUserByIdOrDefault;\n          }\n          return {\n            id: toggleFocusOnUserById,\n            isActive: false\n          };\n        })\n      }));\n    };\n    findNextFocusable = getNextFocusableByActiveId => {\n      let activeFocusIndex = getNextFocusableByActiveId.focusables.findIndex(isActiveFocusIdMatch => {\n        return isActiveFocusIdMatch.id === getNextFocusableByActiveId.activeFocusId;\n      });\n      for (let nextFocusableIndex = activeFocusIndex + 1; nextFocusableIndex < getNextFocusableByActiveId.focusables.length; nextFocusableIndex++) {\n        let focusableElement = getNextFocusableByActiveId.focusables[nextFocusableIndex];\n        if (focusableElement?.isActive) {\n          return focusableElement.id;\n        }\n      }\n      return;\n    };\n    findPreviousFocusable = getPreviousActiveFocusableId => {\n      let _activeFocusIndex = getPreviousActiveFocusableId.focusables.findIndex(_isActiveFocusIdMatch => {\n        return _isActiveFocusIdMatch.id === getPreviousActiveFocusableId.activeFocusId;\n      });\n      for (let focusableIndex = _activeFocusIndex - 1; focusableIndex >= 0; focusableIndex--) {\n        let _focusableElement = getPreviousActiveFocusableId.focusables[focusableIndex];\n        if (_focusableElement?.isActive) {\n          return _focusableElement.id;\n        }\n      }\n      return;\n    };\n  };\n});\nfunction initializeApp() {}\nvar initializeDebuggingTools;\nvar _________________________initializeDevTools = T(() => {\n  initializeDebuggingTools = initializeApp;\n});\nvar _______________initializeDevToolsConnection = \"\u001b[?2026h\";\nvar __________initializeDevTools = \"\u001b[?2026l\";\nfunction isWindowsTerminalSession() {\n  return process.platform === \"win32\" && !!process.env.WT_SESSION;\n}\nfunction isRunningInWindowsTerminal() {\n  if (isWindowsTerminalSession()) {\n    return true;\n  }\n  if (process.platform === \"win32\" && process.env.TERM_PROGRAM === \"vscode\" && process.env.TERM_PROGRAM_VERSION) {\n    return true;\n  }\n  return false;\n}\nfunction clearConsoleOutput() {\n  if (process.platform === \"win32\") {\n    if (isRunningInWindowsTerminal()) {\n      return \"\u001b[2J\u001b[3J\u001b[H\";\n    } else {\n      return \"\u001b[2J\u001b[0f\";\n    }\n  } else {\n    return \"\u001b[2J\u001b[3J\u001b[H\";\n  }\n}\nvar ________________initializeDevToolsConnection;\nvar ___________________________________________________initializeDevToolsConnection = T(() => {\n  ________________initializeDevToolsConnection = clearConsoleOutput();\n});\nfunction processDataCommands(devToolsWriter, dataCommands) {\n  if (dataCommands.length === 0) {\n    return;\n  }\n  let formattedDevToolsOutput = _______________initializeDevToolsConnection;\n  for (let _command of dataCommands) {\n    switch (_command.type) {\n      case \"stdout\":\n        formattedDevToolsOutput += _command.content;\n        break;\n      case \"clear\":\n        if (_command.count > 0) {\n          formattedDevToolsOutput += terminalCommands.eraseLines(_command.count);\n        }\n        break;\n      case \"clearTerminal\":\n        formattedDevToolsOutput += clearConsoleOutput();\n        break;\n      case \"cursorHide\":\n        formattedDevToolsOutput += terminalCommands.cursorHide;\n        break;\n      case \"cursorShow\":\n        formattedDevToolsOutput += terminalCommands.cursorShow;\n        break;\n      case \"cursorMove\":\n        formattedDevToolsOutput += terminalCommands.cursorMove(_command.x, _command.y);\n        break;\n      case \"del\":\n        formattedDevToolsOutput += \"\u001b[P\";\n        break;\n    }\n  }\n  formattedDevToolsOutput += __________initializeDevTools;\n  devToolsWriter.stdout.write(formattedDevToolsOutput);\n}\nvar __________________________________________________________initializeDevToolsConnection = T(() => {\n  __________________________________________________initializeDevToolsConnection();\n  ___________________________________________________initializeDevToolsConnection();\n});\nclass TerminalController {\n  options;\n  log;\n  terminal;\n  scheduleRender;\n  isUnmounted = false;\n  isPaused = false;\n  container;\n  rootNode;\n  renderer;\n  exitPromise;\n  restoreConsole;\n  unsubscribeTTYHandlers;\n  terminalColumns;\n  terminalRows;\n  currentNode = null;\n  constructor(_________options) {\n    this.options = _________options;\n    KZ1(this);\n    if (this.options.patchConsole) {\n      this.restoreConsole = this.patchConsole();\n    }\n    this.terminal = {\n      stdout: _________options.stdout,\n      stderr: _________options.stderr\n    };\n    this.terminalColumns = _________options.stdout.columns || 80;\n    this.terminalRows = _________options.stdout.rows || 24;\n    this.log = new TerminalRenderer({\n      debug: _________options.debug,\n      isTTY: _________options.stdout.isTTY || false,\n      onFlicker: _________options.onFlicker,\n      ink2: _________options.ink2\n    }, createTerminalDisplay(this.terminalRows, this.terminalColumns));\n    this.scheduleRender = _________options.debug ? this.onRender : VZ1(this.onRender, 32, {\n      leading: true,\n      trailing: true\n    });\n    this.isUnmounted = false;\n    this.unsubscribeExit = jTA(this.unmount, {\n      alwaysLast: false\n    });\n    if (_________options.stdout.isTTY) {\n      _________options.stdout.on(\"resize\", this.handleResize);\n      process.on(\"SIGCONT\", this.handleResume);\n      this.unsubscribeTTYHandlers = () => {\n        _________options.stdout.off(\"resize\", this.handleResize);\n        process.off(\"SIGCONT\", this.handleResume);\n      };\n    }\n    this.rootNode = QPA(\"ink-root\");\n    this.renderer = createTerminalRenderer(this.rootNode);\n    this.rootNode.onRender = this.scheduleRender;\n    this.rootNode.onImmediateRender = this.onRender;\n    this.container = renderComponent.createContainer(this.rootNode, 0, null, false, null, \"id\", () => {}, null);\n    if (process.env.DEV === \"true\") {\n      renderComponent.injectIntoDevTools({\n        bundleType: 0,\n        version: \"16.13.1\",\n        rendererPackageName: \"ink\"\n      });\n    }\n  }\n  handleResume = () => {\n    if (!this.options.stdout.isTTY) {\n      return;\n    }\n    this.log.reset();\n  };\n  handleResize = () => {\n    this.terminalColumns = this.options.stdout.columns || 80;\n    this.terminalRows = this.options.stdout.rows || 24;\n    if (this.currentNode !== null) {\n      this.render(this.currentNode);\n    }\n    this.scheduleRender();\n  };\n  resolveExitPromise = () => {};\n  rejectExitPromise = () => {};\n  unsubscribeExit = () => {};\n  setTheme(setThemeTheme) {\n    this.options.theme = setThemeTheme;\n  }\n  onRender() {\n    if (this.isUnmounted || this.isPaused) {\n      return;\n    }\n    let defaultTerminalRows = this.options.stdout.rows || 24;\n    let terminalColumns = this.options.stdout.columns || 80;\n    let _renderedOutput = this.renderer({\n      theme: this.options.theme,\n      terminalWidth: terminalColumns,\n      terminalRows: defaultTerminalRows,\n      isTTY: this.options.stdout.isTTY,\n      ink2: this.options.ink2\n    });\n    let renderedLogCommands = this.log.render(_renderedOutput);\n    for (let command of renderedLogCommands) {\n      if (command.type === \"clearTerminal\") {\n        this.options.onFlicker?.(_renderedOutput.outputHeight, _renderedOutput.rows, this.options.ink2);\n      }\n    }\n    processDataCommands(this.terminal, renderedLogCommands);\n  }\n  pause() {\n    renderComponent.flushSync();\n    this.onRender();\n    this.isPaused = true;\n  }\n  resume() {\n    this.isPaused = false;\n    this.onRender();\n  }\n  stdinListeners = [];\n  wasRawMode = false;\n  suspendStdin() {\n    let stdinStream = this.options.stdin;\n    if (!stdinStream.isTTY) {\n      return;\n    }\n    stdinStream.listeners(\"readable\").forEach(readableEventListener => {\n      this.stdinListeners.push({\n        event: \"readable\",\n        listener: readableEventListener\n      });\n      stdinStream.removeListener(\"readable\", readableEventListener);\n    });\n    let _stdinStream = stdinStream;\n    if (_stdinStream.isRaw && _stdinStream.setRawMode) {\n      _stdinStream.setRawMode(false);\n      this.wasRawMode = true;\n    }\n  }\n  resumeStdin() {\n    let stdinOptions = this.options.stdin;\n    if (!stdinOptions.isTTY) {\n      return;\n    }\n    this.stdinListeners.forEach(({\n      event: _eventHandler,\n      listener: eventListener\n    }) => {\n      stdinOptions.addListener(_eventHandler, eventListener);\n    });\n    this.stdinListeners = [];\n    if (this.wasRawMode) {\n      let stdinEvent = stdinOptions;\n      if (stdinEvent.setRawMode) {\n        stdinEvent.setRawMode(true);\n      }\n      this.wasRawMode = false;\n    }\n  }\n  render(_currentNode) {\n    this.currentNode = _currentNode;\n    let colorPaletteElement = ________initializeDevelopmentTools.default.createElement(_colorPalette, {\n      initialTheme: this.options.theme,\n      stdin: this.options.stdin,\n      stdout: this.options.stdout,\n      stderr: this.options.stderr,\n      exitOnCtrlC: this.options.exitOnCtrlC,\n      onExit: this.unmount,\n      ink2: this.options.ink2,\n      terminalColumns: this.terminalColumns,\n      terminalRows: this.terminalRows\n    }, _currentNode);\n    renderComponent.updateContainer(colorPaletteElement, this.container, null, initializeDebuggingTools);\n  }\n  unmount(handleUnmounting) {\n    if (this.isUnmounted) {\n      return;\n    }\n    this.onRender();\n    this.unsubscribeExit();\n    if (typeof this.restoreConsole === \"function\") {\n      this.restoreConsole();\n    }\n    this.unsubscribeTTYHandlers?.();\n    let previousLogOutput = this.log.renderPreviousOutput_DEPRECATED();\n    processDataCommands(this.terminal, previousLogOutput);\n    this.isUnmounted = true;\n    renderComponent.updateContainer(null, this.container, null, initializeDebuggingTools);\n    colorManagement.delete(this.options.stdout);\n    if (handleUnmounting instanceof Error) {\n      this.rejectExitPromise(handleUnmounting);\n    } else {\n      this.resolveExitPromise();\n    }\n  }\n  async waitUntilExit() {\n    this.exitPromise ||= new Promise((exitPromiseHandlers, rejectExitPromise) => {\n      this.resolveExitPromise = exitPromiseHandlers;\n      this.rejectExitPromise = rejectExitPromise;\n    });\n    return this.exitPromise;\n  }\n  resetLineCount() {\n    if (this.options.stdout.isTTY && !this.options.debug) {\n      this.log.reset();\n    }\n  }\n  patchConsole() {\n    if (this.options.debug) {\n      return;\n    }\n    return Gj0((outputStream, logMessage) => {\n      if (outputStream === \"stdout\") {\n        g(`console.log: ${logMessage}`);\n      }\n      if (outputStream === \"stderr\") {\n        BA(Error(`console.error: ${logMessage}`), lJ0);\n      }\n    });\n  }\n}\nfunction setThemeForColorManagement(themeToSet) {\n  colorManagement.forEach(themeSetter => {\n    themeSetter.setTheme(themeToSet);\n  });\n}\nvar ________initializeDevelopmentTools;\nvar PY1 = T(() => {\n  Bj0();\n  dG1();\n  Zj0();\n  initializeRendererInstance();\n  yS0();\n  ZPA();\n  processAndDisplayElements();\n  ____initializeReactDevTools();\n  zy0();\n  c1();\n  C0();\n  _________________________initializeDevTools();\n  __________________________________________________________initializeDevToolsConnection();\n  _______________initializeRenderer();\n  ________initializeDevelopmentTools = IA(KA(), 1);\n});\nfunction isUndefinedCheck() {\n  if (Nf(undefined)) {\n    return false;\n  }\n  return V0(undefined) || false;\n}\nvar _________________initializeDevToolsConnection = T(() => {\n  vB();\n  f4();\n});\nimport { Stream as ___________initializeDevTools } from \"node:stream\";\nvar ___________________________________________________________________________________initializeDevToolsConnection = (__________________________________initializeDevTools, _________________initializeReactDevToolsConnection) => {\n  let initializeReactDevToolsConfig = ______initializeReactDevTools(_________________initializeReactDevToolsConnection);\n  let devToolOptions = {\n    stdout: process.stdout,\n    stdin: process.stdin,\n    stderr: process.stderr,\n    debug: false,\n    exitOnCtrlC: true,\n    patchConsole: true,\n    ...initializeReactDevToolsConfig,\n    theme: initializeReactDevToolsConfig.theme ?? L1().theme,\n    ink2: initializeReactDevToolsConfig.ink2 ?? isUndefinedCheck()\n  };\n  let __devToolsConnection = _____________________________________initializeDevToolsConnection(devToolOptions.stdout, () => new TerminalController(devToolOptions));\n  __devToolsConnection.render(__________________________________initializeDevTools);\n  return {\n    rerender: __devToolsConnection.render,\n    unmount() {\n      __devToolsConnection.unmount();\n    },\n    waitUntilExit: __devToolsConnection.waitUntilExit,\n    cleanup: () => colorManagement.delete(devToolOptions.stdout)\n  };\n};\nvar ____________________________________________________________________________________initializeDevToolsConnection = async (_____________________________________________________________________________________initializeDevToolsConnection, ______________________________________________________________________________________initializeDevToolsConnection) => {\n  await ij0();\n  return ___________________________________________________________________________________initializeDevToolsConnection(_____________________________________________________________________________________initializeDevToolsConnection, ______________________________________________________________________________________initializeDevToolsConnection);\n};\nvar ___initializeRenderer;\nvar ______initializeReactDevTools = (devToolsInstance = {}) => {\n  if (devToolsInstance instanceof ___________initializeDevTools) {\n    return {\n      stdout: devToolsInstance,\n      stdin: process.stdin\n    };\n  }\n  return devToolsInstance;\n};\nvar _____________________________________initializeDevToolsConnection = (getColorOrGenerate, generateColor) => {\n  let getColor = colorManagement.get(getColorOrGenerate);\n  if (!getColor) {\n    getColor = generateColor();\n    colorManagement.set(getColorOrGenerate, getColor);\n  }\n  return getColor;\n};\nvar Oy0 = T(() => {\n  PY1();\n  ZPA();\n  ____initializeReactDevTools();\n  kB();\n  _________________initializeDevToolsConnection();\n  ___initializeRenderer = ____________________________________________________________________________________initializeDevToolsConnection;\n});\nfunction ColorSettingsProvider({\n  children: _children\n}) {\n  return retrieveColorSettings.default.createElement(__________________initializeDevToolsConnection.Provider, {\n    value: true\n  }, _children);\n}\nvar retrieveColorSettings;\nvar initDevToolsConnection;\nvar __________________initializeDevToolsConnection;\nvar __________________________initializeDevTools = T(() => {\n  retrieveColorSettings = IA(KA(), 1);\n  initDevToolsConnection = IA(KA(), 1);\n  __________________initializeDevToolsConnection = retrieveColorSettings.default.createContext(false);\n});\nfunction renderItemsWithDebuggerComponent(renderItemsWithDebugger) {\n  let {\n    items: itemsList,\n    children: renderChildItem\n  } = renderItemsWithDebugger;\n  let debuggerContext = devToolsHandler.useContext(initializeDebuggerConnection);\n  let [currentStartIndex, setCurrentIndex] = devToolsHandler.useState(0);\n  let slicedItems = devToolsHandler.useMemo(() => {\n    return itemsList.slice(currentStartIndex);\n  }, [itemsList, currentStartIndex]);\n  devToolsHandler.useLayoutEffect(() => {\n    setCurrentIndex(itemsList.length);\n  }, [itemsList.length]);\n  if (debuggerContext) {\n    let renderedItemElements = itemsList.map((calculateQuality, _calculateQuality) => renderChildItem(calculateQuality, _calculateQuality));\n    return devToolsHandler.default.createElement(\"ink-box\", {\n      style: {\n        flexDirection: \"column\"\n      }\n    }, renderedItemElements);\n  }\n  let renderedChildItems = slicedItems.map((childItem, offset) => {\n    return renderChildItem(childItem, currentStartIndex + offset);\n  });\n  return devToolsHandler.default.createElement(ColorSettingsProvider, null, devToolsHandler.default.createElement(\"ink-box\", {\n    internal_static: true,\n    style: {\n      position: \"absolute\",\n      flexDirection: \"column\"\n    }\n  }, renderedChildItems));\n}\nvar devToolsHandler;\nvar _____________________________________________initializeDevToolsConnection = T(() => {\n  __________________________initializeDevTools();\n  ____________________________________initializeDevToolsConnection();\n  devToolsHandler = IA(KA(), 1);\n});\nfunction renderWithTransform({\n  children: children,\n  transform: transformFunction\n}) {\n  if (children === undefined || children === null) {\n    return null;\n  }\n  return ___________________initializeDevToolsConnection.default.createElement(\"ink-text\", {\n    style: {\n      flexGrow: 0,\n      flexShrink: 1,\n      flexDirection: \"row\"\n    },\n    internal_transform: transformFunction\n  }, children);\n}\nvar ___________________initializeDevToolsConnection;\nvar ____________________initializeDevToolsConnection = T(() => {\n  ___________________initializeDevToolsConnection = IA(KA(), 1);\n});\nfunction createInkTextWithRepeatedNewLines({\n  count: newLineCount = 1\n}) {\n  return _____________________initializeDevToolsConnection.default.createElement(\"ink-text\", null, `\n`.repeat(newLineCount));\n}\nvar _____________________initializeDevToolsConnection;\nvar ______________________initializeDevToolsConnection = T(() => {\n  _____________________initializeDevToolsConnection = IA(KA(), 1);\n});\nvar _________initializeDevelopmentTools;\nvar ______________________________________________initializeDevToolsConnection = T(() => {\n  setupReactDevelopmentTools();\n  _________initializeDevelopmentTools = IA(KA(), 1);\n});\nvar devToolsInitializationHandler;\nvar initializeConnectionToDevTools = () => devToolsInitializationHandler.useContext(initializeReactDevTools);\nvar __________initializeDevelopmentTools;\nvar ____________________________________________________initializeDevToolsConnection = T(() => {\n  ___________________________________________initializeDevToolsConnection();\n  devToolsInitializationHandler = IA(KA(), 1);\n  __________initializeDevelopmentTools = initializeConnectionToDevTools;\n});\nvar ___________initializeDevelopmentTools;\nvar ______________________________________initializeDevToolsConnection = (handleUserInput, _____options = {}) => {\n  let {\n    stdin: inputStream,\n    setRawMode: setRawInputMode,\n    internal_exitOnCtrlC: isUpdateRequired,\n    internal_eventEmitter: inputEventEmitter\n  } = __________initializeDevelopmentTools();\n  ___________initializeDevelopmentTools.useEffect(() => {\n    if (_____options.isActive === false) {\n      return;\n    }\n    setRawInputMode(true);\n    return () => {\n      setRawInputMode(false);\n    };\n  }, [_____options.isActive, setRawInputMode]);\n  ___________initializeDevelopmentTools.useEffect(() => {\n    if (_____options.isActive === false) {\n      return;\n    }\n    let handleInputChange = processInputAndUpdate => {\n      let {\n        input: userInput,\n        key: keyHandler\n      } = processInputAndUpdate;\n      if (userInput !== \"c\" || !keyHandler.ctrl || !isUpdateRequired) {\n        renderComponent.batchedUpdates(() => {\n          handleUserInput(userInput, keyHandler, processInputAndUpdate);\n        });\n      }\n    };\n    inputEventEmitter?.on(\"input\", handleInputChange);\n    return () => {\n      inputEventEmitter?.removeListener(\"input\", handleInputChange);\n    };\n  }, [_____options.isActive, inputStream, isUpdateRequired, handleUserInput]);\n};\nvar renderAndSetupComponent;\nvar ___________________________________________________________initializeDevToolsConnection = T(() => {\n  initializeRendererInstance();\n  ____________________________________________________initializeDevToolsConnection();\n  ___________initializeDevelopmentTools = IA(KA(), 1);\n  renderAndSetupComponent = ______________________________________initializeDevToolsConnection;\n});\nvar ____________initializeDevTools;\nvar ___initializeReactDevToolsConnection = T(() => {\n  _______________________initializeDevTools();\n  ____________initializeDevTools = IA(KA(), 1);\n});\nvar renderingFunction1;\nvar ___________initializeReactDevToolsConnection = T(() => {\n  __createInstance();\n  ____________________________________________________initializeDevToolsConnection();\n  renderingFunction1 = IA(KA(), 1);\n});\nvar _______________________initializeDevToolsConnection;\nvar initializeDevelopmentToolsConnection = T(() => {\n  __createInstance();\n  _______________________initializeDevToolsConnection = IA(KA(), 1);\n});\nvar ____initializeRenderer = getYogaNodeDimensions => ({\n  width: getYogaNodeDimensions.yogaNode?.getComputedWidth() ?? 0,\n  height: getYogaNodeDimensions.yogaNode?.getComputedHeight() ?? 0\n});\nvar rendererInitialization;\nvar ___________________initializeDevelopmentTools = T(() => {\n  rendererInitialization = ____initializeRenderer;\n});\nvar nA = T(() => {\n  Oy0();\n  setupReactDevelopmentTools();\n  jY1();\n  _____________________________________________initializeDevToolsConnection();\n  ____________________initializeDevToolsConnection();\n  ______________________initializeDevToolsConnection();\n  ______________________________________________initializeDevToolsConnection();\n  ___________________________________________________________initializeDevToolsConnection();\n  ___initializeReactDevToolsConnection();\n  ____________________________________________________initializeDevToolsConnection();\n  ___________initializeReactDevToolsConnection();\n  initializeDevelopmentToolsConnection();\n  ___________________initializeDevelopmentTools();\n  __________________________initializeDevTools();\n  OPA();\n  ________________________________initializeDevToolsConnection();\n  APA();\n  _________________________________________________________initializeDevToolsConnection();\n  _____initializeReactDevTools();\n});\nfunction handleTimeoutLogic(evaluateCondition, onTimeoutElapsed, __callbackFunction) {\n  let lastExecutionTime = _____________initializeDevTools.useRef(0);\n  let timeoutHandleRef = _____________initializeDevTools.useRef();\n  let clearTimeoutIfExists = _____________initializeDevTools.useCallback(() => {\n    if (timeoutHandleRef.current) {\n      clearTimeout(timeoutHandleRef.current);\n      timeoutHandleRef.current = undefined;\n    }\n  }, []);\n  _____________initializeDevTools.useEffect(() => {\n    return () => {\n      clearTimeoutIfExists();\n    };\n  }, [clearTimeoutIfExists]);\n  return _____________initializeDevTools.useCallback(() => {\n    let currentExecutionTime = Date.now();\n    if (currentExecutionTime - lastExecutionTime.current <= ______________initializeDevTools && timeoutHandleRef.current !== undefined) {\n      clearTimeoutIfExists();\n      evaluateCondition(false);\n      onTimeoutElapsed();\n    } else {\n      __callbackFunction?.();\n      evaluateCondition(true);\n      clearTimeoutIfExists();\n      timeoutHandleRef.current = setTimeout(() => {\n        evaluateCondition(false);\n        timeoutHandleRef.current = undefined;\n      }, ______________initializeDevTools);\n    }\n    lastExecutionTime.current = currentExecutionTime;\n  }, [evaluateCondition, onTimeoutElapsed, __callbackFunction, clearTimeoutIfExists]);\n}\nvar _____________initializeDevTools;\nvar ______________initializeDevTools = 800;\nvar initializeColorPalette = T(() => {\n  _____________initializeDevTools = IA(KA(), 1);\n});\nfunction truncateStringWithEllipsis(truncateTextToMaxLength, maxLength, isTextTruncationEnabled = false) {\n  let textToTruncate = truncateTextToMaxLength;\n  if (isTextTruncationEnabled) {\n    let newlineIndex = truncateTextToMaxLength.indexOf(`\n`);\n    if (newlineIndex !== -1) {\n      textToTruncate = truncateTextToMaxLength.substring(0, newlineIndex);\n      if (textToTruncate.length + 1 > maxLength) {\n        return `${textToTruncate.substring(0, maxLength - 1)}…`;\n      }\n      return `${textToTruncate}…`;\n    }\n  }\n  if (textToTruncate.length <= maxLength) {\n    return textToTruncate;\n  }\n  return `${textToTruncate.substring(0, maxLength - 1)}…`;\n}\nfunction formatDuration(durationInMilliseconds) {\n  if (durationInMilliseconds < 60000) {\n    if (durationInMilliseconds === 0) {\n      return \"0s\";\n    }\n    if (durationInMilliseconds < 1) {\n      return `${(durationInMilliseconds / 1000).toFixed(1)}s`;\n    }\n    return `${Math.round(durationInMilliseconds / 1000).toString()}s`;\n  }\n  let hoursCount = Math.floor(durationInMilliseconds / 3600000);\n  let minutesPart = Math.floor(durationInMilliseconds % 3600000 / 60000);\n  let seconds = Math.round(durationInMilliseconds % 60000 / 1000);\n  if (hoursCount > 0) {\n    return `${hoursCount}h ${minutesPart}m ${seconds}s`;\n  }\n  if (minutesPart > 0) {\n    return `${minutesPart}m ${seconds}s`;\n  }\n  return `${seconds}s`;\n}\nfunction formatNumberWithCompactNotation(amountFormatter) {\n  let isCompactNotationRequired = amountFormatter >= 1000;\n  return new Intl.NumberFormat(\"en\", {\n    notation: \"compact\",\n    minimumFractionDigits: isCompactNotationRequired ? 1 : 0,\n    maximumFractionDigits: 1\n  }).format(amountFormatter).toLowerCase();\n}\nfunction formatRelativeTime(calculateRelativeTime, ___options = {}) {\n  let {\n    style: timeFormatStyle = \"narrow\",\n    numeric: numericDisplayOption = \"always\",\n    now: currentDate = new Date()\n  } = ___options;\n  let timeDifferenceInMilliseconds = calculateRelativeTime.getTime() - currentDate.getTime();\n  let elapsedTimeInSeconds = Math.trunc(timeDifferenceInMilliseconds / 1000);\n  let timeUnits = [{\n    unit: \"year\",\n    seconds: 31536000,\n    shortUnit: \"y\"\n  }, {\n    unit: \"month\",\n    seconds: 2592000,\n    shortUnit: \"mo\"\n  }, {\n    unit: \"week\",\n    seconds: 604800,\n    shortUnit: \"w\"\n  }, {\n    unit: \"day\",\n    seconds: 86400,\n    shortUnit: \"d\"\n  }, {\n    unit: \"hour\",\n    seconds: 3600,\n    shortUnit: \"h\"\n  }, {\n    unit: \"minute\",\n    seconds: 60,\n    shortUnit: \"m\"\n  }, {\n    unit: \"second\",\n    seconds: 1,\n    shortUnit: \"s\"\n  }];\n  for (let {\n    unit: timeUnit,\n    seconds: secondsThreshold,\n    shortUnit: shortUnitDisplay\n  } of timeUnits) {\n    if (Math.abs(elapsedTimeInSeconds) >= secondsThreshold) {\n      let timeInterval = Math.trunc(elapsedTimeInSeconds / secondsThreshold);\n      if (timeFormatStyle === \"narrow\") {\n        if (elapsedTimeInSeconds < 0) {\n          return `${Math.abs(timeInterval)}${shortUnitDisplay} ago`;\n        } else {\n          return `in ${timeInterval}${shortUnitDisplay}`;\n        }\n      }\n      return new Intl.RelativeTimeFormat(\"en\", {\n        style: \"long\",\n        numeric: numericDisplayOption\n      }).format(timeInterval, timeUnit);\n    }\n  }\n  if (timeFormatStyle === \"narrow\") {\n    if (elapsedTimeInSeconds <= 0) {\n      return \"0s ago\";\n    } else {\n      return \"in 0s\";\n    }\n  }\n  return new Intl.RelativeTimeFormat(\"en\", {\n    style: timeFormatStyle,\n    numeric: numericDisplayOption\n  }).format(0, \"second\");\n}\nfunction formatTimestampRelative(timestamp, ______options = {}) {\n  let {\n    now: __currentDate = new Date(),\n    ..._______options\n  } = ______options;\n  if (timestamp > __currentDate) {\n    return formatRelativeTime(timestamp, {\n      ..._______options,\n      now: __currentDate\n    });\n  }\n  return formatRelativeTime(timestamp, {\n    ..._______options,\n    numeric: \"always\",\n    now: __currentDate\n  });\n}\nfunction formatTimestamp(_formatTimestamp, includeTimeZone = false) {\n  if (!_formatTimestamp) {\n    return;\n  }\n  let formattedDate = new Date(_formatTimestamp * 1000);\n  let _currentDate = new Date();\n  let minutes = formattedDate.getMinutes();\n  if ((formattedDate.getTime() - _currentDate.getTime()) / 3600000 > 24) {\n    let dateFormatOptions = {\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"numeric\",\n      minute: minutes === 0 ? undefined : \"2-digit\",\n      hour12: true\n    };\n    if (formattedDate.getFullYear() !== _currentDate.getFullYear()) {\n      dateFormatOptions.year = \"numeric\";\n    }\n    return formattedDate.toLocaleString(\"en-US\", dateFormatOptions).replace(/ ([AP]M)/i, (convertToLowerCase, ____inputString) => ____inputString.toLowerCase()) + (includeTimeZone ? ` (${Intl.DateTimeFormat().resolvedOptions().timeZone})` : \"\");\n  }\n  let formattedTime = formattedDate.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: minutes === 0 ? undefined : \"2-digit\",\n    hour12: true\n  });\n  let timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n  return formattedTime.replace(/ ([AP]M)/i, (_convertToLowerCase, stringInput) => stringInput.toLowerCase()) + (includeTimeZone ? ` (${timezone})` : \"\");\n}\nvar _______________initializeDevTools = z((manageProcessTermination, handleProcessTermination) => {\n  var _childProcessModule = EA(\"child_process\");\n  var _spawnChildProcess = _childProcessModule.spawn;\n  var execChildProcessCommand = _childProcessModule.exec;\n  handleProcessTermination.exports = function (handleProcessId, callbackFunction, _callback) {\n    if (typeof callbackFunction === \"function\" && _callback === undefined) {\n      _callback = callbackFunction;\n      callbackFunction = undefined;\n    }\n    handleProcessId = parseInt(handleProcessId);\n    if (Number.isNaN(handleProcessId)) {\n      if (_callback) {\n        return _callback(Error(\"pid must be a number\"));\n      } else {\n        throw Error(\"pid must be a number\");\n      }\n    }\n    var processIds = {};\n    var processTrackers = {};\n    processIds[handleProcessId] = [];\n    processTrackers[handleProcessId] = 1;\n    switch (process.platform) {\n      case \"win32\":\n        execChildProcessCommand(\"taskkill /pid \" + handleProcessId + \" /T /F\", _callback);\n        break;\n      case \"darwin\":\n        processAsyncData(handleProcessId, processIds, processTrackers, function (_parentProcessId) {\n          return _spawnChildProcess(\"pgrep\", [\"-P\", _parentProcessId]);\n        }, function () {\n          processAndTerminate(processIds, callbackFunction, _callback);\n        });\n        break;\n      default:\n        processAsyncData(handleProcessId, processIds, processTrackers, function (parentProcessId) {\n          return _spawnChildProcess(\"ps\", [\"-o\", \"pid\", \"--no-headers\", \"--ppid\", parentProcessId]);\n        }, function () {\n          processAndTerminate(processIds, callbackFunction, _callback);\n        });\n        break;\n    }\n  };\n  function processAndTerminate(processElements, ____callbackFunction, errorHandler) {\n    var processedProcessIds = {};\n    try {\n      Object.keys(processElements).forEach(function (elementKey) {\n        processElements[elementKey].forEach(function (_processId) {\n          if (!processedProcessIds[_processId]) {\n            killProcessById(_processId, ____callbackFunction);\n            processedProcessIds[_processId] = 1;\n          }\n        });\n        if (!processedProcessIds[elementKey]) {\n          killProcessById(elementKey, ____callbackFunction);\n          processedProcessIds[elementKey] = 1;\n        }\n      });\n    } catch (_________error) {\n      if (errorHandler) {\n        return errorHandler(_________error);\n      } else {\n        throw _________error;\n      }\n    }\n    if (errorHandler) {\n      return errorHandler();\n    }\n  }\n  function killProcessById(processId, signal) {\n    try {\n      process.kill(parseInt(processId, 10), signal);\n    } catch (________error) {\n      if (________error.code !== \"ESRCH\") {\n        throw ________error;\n      }\n    }\n  }\n  function processAsyncData(_processData, __processData, pendingQueue, _processInput, callbackOnCompletion) {\n    var processStream = _processInput(_processData);\n    var outputDataBuffer = \"\";\n    processStream.stdout.on(\"data\", function (asciiString) {\n      var asciiString = asciiString.toString(\"ascii\");\n      outputDataBuffer += asciiString;\n    });\n    function _processInputData(____processInput) {\n      delete pendingQueue[_processData];\n      if (____processInput != 0) {\n        if (Object.keys(pendingQueue).length == 0) {\n          callbackOnCompletion();\n        }\n        return;\n      }\n      outputDataBuffer.match(/\\d+/g).forEach(function (dataIndex) {\n        dataIndex = parseInt(dataIndex, 10);\n        __processData[_processData].push(dataIndex);\n        __processData[dataIndex] = [];\n        pendingQueue[dataIndex] = 1;\n        processAsyncData(dataIndex, __processData, pendingQueue, _processInput, callbackOnCompletion);\n      });\n    }\n    processStream.on(\"close\", _processInputData);\n  }\n});\nclass CircularBuffer {\n  capacity;\n  buffer;\n  head = 0;\n  size = 0;\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.buffer = Array(capacity);\n  }\n  add(_element) {\n    this.buffer[this.head] = _element;\n    this.head = (this.head + 1) % this.capacity;\n    if (this.size < this.capacity) {\n      this.size++;\n    }\n  }\n  addAll(itemsToAdd) {\n    for (let _item of itemsToAdd) {\n      this.add(_item);\n    }\n  }\n  getRecent(getRecentItems) {\n    let recentItems = [];\n    let headIndex = this.size < this.capacity ? 0 : this.head;\n    let itemsToRetrieve = Math.min(getRecentItems, this.size);\n    for (let indexForBuffer = 0; indexForBuffer < itemsToRetrieve; indexForBuffer++) {\n      let bufferIndex = (headIndex + this.size - itemsToRetrieve + indexForBuffer) % this.capacity;\n      recentItems.push(this.buffer[bufferIndex]);\n    }\n    return recentItems;\n  }\n  toArray() {\n    if (this.size === 0) {\n      return [];\n    }\n    let bufferArray = [];\n    let bufferStartIndex = this.size < this.capacity ? 0 : this.head;\n    for (let ______________index = 0; ______________index < this.size; ______________index++) {\n      let _bufferIndex = (bufferStartIndex + ______________index) % this.capacity;\n      bufferArray.push(this.buffer[_bufferIndex]);\n    }\n    return bufferArray;\n  }\n  clear() {\n    this.head = 0;\n    this.size = 0;\n  }\n  length() {\n    return this.size;\n  }\n}\nfunction concatenateWithTruncation(concatAndTruncateString, separator = \",\", __maxLength = 67108736) {\n  let concatenatedResult = \"\";\n  for (let currentString of concatAndTruncateString) {\n    let conditionalPrefixString = concatenatedResult ? separator : \"\";\n    let concatenatedString = conditionalPrefixString + currentString;\n    if (concatenatedResult.length + concatenatedString.length <= __maxLength) {\n      concatenatedResult += concatenatedString;\n    } else {\n      let remainingCharsBeforeTruncate = __maxLength - concatenatedResult.length - conditionalPrefixString.length - 14;\n      if (remainingCharsBeforeTruncate > 0) {\n        concatenatedResult += conditionalPrefixString + currentString.slice(0, remainingCharsBeforeTruncate) + \"...[truncated]\";\n      } else {\n        concatenatedResult += \"...[truncated]\";\n      }\n      return concatenatedResult;\n    }\n  }\n  return concatenatedResult;\n}\nclass TextBuffer {\n  maxSize;\n  content = \"\";\n  isTruncated = false;\n  totalBytesReceived = 0;\n  constructor(defaultMaxSize = 67108736) {\n    this.maxSize = defaultMaxSize;\n  }\n  append(appendContent) {\n    let convertedInput = typeof appendContent === \"string\" ? appendContent : appendContent.toString();\n    this.totalBytesReceived += convertedInput.length;\n    if (this.isTruncated && this.content.length >= this.maxSize) {\n      return;\n    }\n    if (this.content.length + convertedInput.length > this.maxSize) {\n      let bytesToAppend = this.maxSize - this.content.length;\n      if (bytesToAppend > 0) {\n        this.content += convertedInput.slice(0, bytesToAppend);\n      }\n      this.isTruncated = true;\n    } else {\n      this.content += convertedInput;\n    }\n  }\n  toString() {\n    if (!this.isTruncated) {\n      return this.content;\n    }\n    let bytesExcess = this.totalBytesReceived - this.maxSize;\n    let bytesRemoved = Math.round(bytesExcess / 1024);\n    return `${this.content}\n... [output truncated - ${bytesRemoved}KB removed]`;\n  }\n  clear() {\n    this.content = \"\";\n    this.isTruncated = false;\n    this.totalBytesReceived = 0;\n  }\n  get length() {\n    return this.content.length;\n  }\n  get truncated() {\n    return this.isTruncated;\n  }\n  get totalBytes() {\n    return this.totalBytesReceived;\n  }\n}\nfunction truncateArrayToSize(truncateStringToLength, _maxLength) {\n  if (truncateStringToLength.length <= _maxLength) {\n    return truncateStringToLength;\n  }\n  let lengthDifference = truncateStringToLength.length - _maxLength;\n  let truncatedNotification = `\n\n... [tool result truncated - ${Math.round(lengthDifference / 1024)}KB removed]`;\n  return truncateStringToLength.slice(0, _maxLength) + truncatedNotification;\n}\nimport { PassThrough as _____initializeRenderer } from \"stream\";\nfunction createStreamHandler(eventHandler) {\n  let streamWriter = null;\n  let textBuffer = new TextBuffer();\n  eventHandler.on(\"data\", dataToWrite => {\n    if (streamWriter) {\n      streamWriter.write(dataToWrite);\n    } else {\n      textBuffer.append(dataToWrite);\n    }\n  });\n  let getBufferedData = () => textBuffer.toString();\n  return {\n    get: getBufferedData,\n    asStream() {\n      streamWriter = new _____initializeRenderer({\n        highWaterMark: 10485760\n      });\n      streamWriter.write(getBufferedData());\n      textBuffer.clear();\n      return streamWriter;\n    }\n  };\n}\nfunction executeProcessWithTimeoutHandler(executeProcessWithTimeout, abortEventTarget, timeoutDuration, callback, enableTimeoutCallback = false) {\n  let processStatus = \"running\";\n  let _backgroundTaskId;\n  let createStdoutStreamHandler = createStreamHandler(executeProcessWithTimeout.stdout);\n  let stderrStreamHandler = createStreamHandler(executeProcessWithTimeout.stderr);\n  if (callback) {\n    let circularBuffer = new CircularBuffer(1000);\n    let processedLineCount = 0;\n    let dataHandler = processNewLines => {\n      let splitAndFilteredLines = processNewLines.toString().split(`\n`).filter(_____inputString => _____inputString.trim());\n      circularBuffer.addAll(splitAndFilteredLines);\n      processedLineCount += splitAndFilteredLines.length;\n      let recentLines = circularBuffer.getRecent(5);\n      if (recentLines.length > 0) {\n        callback(concatenateWithTruncation(recentLines, `\n`), concatenateWithTruncation(circularBuffer.getRecent(100), `\n`), processedLineCount);\n      }\n    };\n    executeProcessWithTimeout.stdout.on(\"data\", dataHandler);\n    executeProcessWithTimeout.stderr.on(\"data\", dataHandler);\n  }\n  let killProcess = terminateProcess => {\n    processStatus = \"killed\";\n    if (executeProcessWithTimeout.pid) {\n      ________________initializeDevTools.default(executeProcessWithTimeout.pid, \"SIGKILL\");\n    }\n  };\n  let handleProcessTimeout = null;\n  let cleanupOnAbort;\n  let timeoutCallback;\n  let backgroundProcessHandler = handleBackgroundTask => {\n    if (processStatus === \"running\") {\n      _backgroundTaskId = handleBackgroundTask;\n      processStatus = \"backgrounded\";\n      cleanupOnAbort();\n      return {\n        stdoutStream: createStdoutStreamHandler.asStream(),\n        stderrStream: stderrStreamHandler.asStream()\n      };\n    }\n    return null;\n  };\n  let taskCompletionPromise = new Promise(handleDevToolsInitialization => {\n    let abortEventHandler = () => killProcess();\n    cleanupOnAbort = () => {\n      if (handleProcessTimeout) {\n        clearTimeout(handleProcessTimeout);\n        handleProcessTimeout = null;\n      }\n      abortEventTarget.removeEventListener(\"abort\", abortEventHandler);\n    };\n    abortEventTarget.addEventListener(\"abort\", abortEventHandler, {\n      once: true\n    });\n    new Promise(initializeDevToolsConnectionHandler => {\n      let initialFunctionCall = killProcess;\n      killProcess = connectionHandler => {\n        initialFunctionCall();\n        initializeDevToolsConnectionHandler(connectionHandler || ________________________initializeDevToolsConnection);\n      };\n      handleProcessTimeout = setTimeout(() => {\n        if (enableTimeoutCallback && timeoutCallback) {\n          timeoutCallback(backgroundProcessHandler);\n        } else {\n          killProcess(_________________________initializeDevToolsConnection);\n        }\n      }, timeoutDuration);\n      executeProcessWithTimeout.on(\"close\", (initializeSignalHandler, signalType) => {\n        initializeDevToolsConnectionHandler(initializeSignalHandler ?? (signalType === \"SIGTERM\" ? 144 : 1));\n      });\n      executeProcessWithTimeout.on(\"error\", () => initializeDevToolsConnectionHandler(1));\n    }).then(checkTaskStatusAndUpdate => {\n      cleanupOnAbort();\n      if (processStatus === \"running\" || processStatus === \"backgrounded\") {\n        processStatus = \"completed\";\n      }\n      let taskResult = {\n        code: checkTaskStatusAndUpdate,\n        stdout: createStdoutStreamHandler.get(),\n        stderr: stderrStreamHandler.get(),\n        interrupted: checkTaskStatusAndUpdate === ________________________initializeDevToolsConnection,\n        backgroundTaskId: _backgroundTaskId\n      };\n      if (checkTaskStatusAndUpdate === _________________________initializeDevToolsConnection) {\n        taskResult.stderr = [`Command timed out after ${formatDuration(timeoutDuration)}`, taskResult.stderr].filter(Boolean).join(\" \");\n      }\n      handleDevToolsInitialization(taskResult);\n    });\n  });\n  let processHandler = {\n    get status() {\n      return processStatus;\n    },\n    background: backgroundProcessHandler,\n    kill: () => killProcess(),\n    result: taskCompletionPromise\n  };\n  if (enableTimeoutCallback) {\n    processHandler.onTimeout = initializeVariable => {\n      timeoutCallback = initializeVariable;\n    };\n  }\n  return processHandler;\n}\nfunction createTaskResult(backgroundTaskId) {\n  return {\n    get status() {\n      return \"killed\";\n    },\n    background: () => null,\n    kill: () => {},\n    result: Promise.resolve({\n      code: 145,\n      stdout: \"\",\n      stderr: \"Command aborted before execution\",\n      interrupted: true,\n      backgroundTaskId: backgroundTaskId\n    })\n  };\n}\nvar ________________initializeDevTools;\nvar ________________________initializeDevToolsConnection = 137;\nvar _________________________initializeDevToolsConnection = 143;\nvar processStyledInputArray = T(() => {\n  ________________initializeDevTools = IA(_______________initializeDevTools(), 1);\n});\nfunction formatAndAppend(___inputString, additionalText) {\n  let lastIndexOfDash = ___inputString.lastIndexOf(\" -\");\n  if (lastIndexOfDash > 0) {\n    let baseString = ___inputString.substring(0, lastIndexOfDash);\n    let suffixString = ___inputString.substring(lastIndexOfDash + 1);\n    return `${q8([baseString])} ${suffixString} ${q8([additionalText])}`;\n  } else {\n    return `${q8([___inputString])} ${q8([additionalText])}`;\n  }\n}\nvar _devToolsInitializationHandler = T(() => {\n  $D();\n});\nimport { readFileSync as __________________________initializeDevToolsConnection, existsSync as initializeRendererComponent, mkdirSync as ___________________________initializeDevToolsConnection, readdirSync as _________________initializeDevTools } from \"node:fs\";\nimport { join as ______initializeRenderer } from \"node:path\";\nfunction initializeRendererAndDevToolsConnection() {\n  let _rendererInstance = ______initializeRenderer(mB(), \"session-env\", L0());\n  ___________________________initializeDevToolsConnection(_rendererInstance, {\n    recursive: true\n  });\n  return _rendererInstance;\n}\nfunction initializeHookRenderer(hookIdentifier) {\n  return ______initializeRenderer(initializeRendererAndDevToolsConnection(), `hook-${hookIdentifier}.sh`);\n}\nfunction invalidateSessionCache() {\n  g(\"Invalidating session environment cache\");\n  insertIndex = undefined;\n}\nfunction loadSessionEnvironment() {\n  if (EB() === \"windows\") {\n    g(\"Session environment not yet supported on Windows\");\n    return null;\n  }\n  if (insertIndex !== undefined) {\n    return insertIndex;\n  }\n  let rendererAndDevToolsConnection = initializeRendererAndDevToolsConnection();\n  if (!initializeRendererComponent(rendererAndDevToolsConnection)) {\n    g(\"No session environment directory found\");\n    insertIndex = null;\n    return insertIndex;\n  }\n  try {\n    let hookFilesList = _________________initializeDevTools(rendererAndDevToolsConnection).filter(isHookScriptFile => isHookScriptFile.startsWith(\"hook-\") && isHookScriptFile.endsWith(\".sh\")).sort((extractHookNumber, getHookNumberDifference) => {\n      let hookIndex = parseInt(extractHookNumber.match(/hook-(\\d+)\\.sh/)?.[1] || \"0\", 10);\n      let getHookNumber = parseInt(getHookNumberDifference.match(/hook-(\\d+)\\.sh/)?.[1] || \"0\", 10);\n      return hookIndex - getHookNumber;\n    });\n    if (hookFilesList.length === 0) {\n      g(\"No hook environment files found\");\n      insertIndex = null;\n      return insertIndex;\n    }\n    insertIndex = hookFilesList.map(initializeAndConnectRenderer => {\n      let renderer = ______initializeRenderer(rendererAndDevToolsConnection, initializeAndConnectRenderer);\n      return __________________________initializeDevToolsConnection(renderer, \"utf8\").trim();\n    }).join(`\n`);\n    g(`Session environment loaded from ${hookFilesList.length} hook file(s) (${insertIndex.length} chars)`);\n    return insertIndex;\n  } catch (__________error) {\n    g(`Failed to load session environment: ${__________error instanceof Error ? __________error.message : String(__________error)}`);\n    insertIndex = null;\n    return insertIndex;\n  }\n}\nvar insertIndex = undefined;\nvar setupDevToolsConnection = T(() => {\n  C0();\n  E5();\n  vB();\n  i0();\n});\nfunction renderTooltipComponent({\n  isFocused: isTooltipFocused,\n  isSelected: isSelected,\n  children: tooltipContent,\n  description: tooltipDescription,\n  shouldShowDownArrow: shouldShowTooltipDownArrow,\n  shouldShowUpArrow: shouldShowTooltipUpArrow\n}) {\n  return getLeftPadding.default.createElement(__processAndDisplayNodes, {\n    flexDirection: \"column\"\n  }, getLeftPadding.default.createElement(__processAndDisplayNodes, {\n    flexDirection: \"row\",\n    gap: 1\n  }, isTooltipFocused ? getLeftPadding.default.createElement(StyledText, {\n    color: \"suggestion\"\n  }, E1.pointer) : shouldShowTooltipDownArrow ? getLeftPadding.default.createElement(StyledText, {\n    dimColor: true\n  }, E1.arrowDown) : shouldShowTooltipUpArrow ? getLeftPadding.default.createElement(StyledText, {\n    dimColor: true\n  }, E1.arrowUp) : getLeftPadding.default.createElement(StyledText, null, \" \"), tooltipContent, isSelected && getLeftPadding.default.createElement(StyledText, {\n    color: \"success\"\n  }, E1.tick)), tooltipDescription && getLeftPadding.default.createElement(__processAndDisplayNodes, {\n    paddingLeft: 5\n  }, getLeftPadding.default.createElement(StyledText, {\n    color: \"inactive\"\n  }, tooltipDescription)));\n}\nvar getLeftPadding;\nvar gPA = T(() => {\n  s2();\n  nA();\n  getLeftPadding = IA(KA(), 1);\n});\nvar updateParentAttributes;\nvar calculateObjectDifference = T(() => {\n  updateParentAttributes = class OrderedMap extends Map {\n    first;\n    last;\n    constructor(elementsArray) {\n      let itemNodeList = [];\n      let firstNode;\n      let lastItemNode;\n      let previousNode;\n      let __currentIndex = 0;\n      for (let element of elementsArray) {\n        let itemNode = {\n          label: element.label,\n          value: element.value,\n          description: element.description,\n          previous: previousNode,\n          next: undefined,\n          index: __currentIndex\n        };\n        if (previousNode) {\n          previousNode.next = itemNode;\n        }\n        firstNode ||= itemNode;\n        lastItemNode = itemNode;\n        itemNodeList.push([element.value, itemNode]);\n        __currentIndex++;\n        previousNode = itemNode;\n      }\n      super(itemNodeList);\n      this.first = firstNode;\n      this.last = lastItemNode;\n    }\n  };\n});\nimport { isDeepStrictEqual as __________________initializeDevTools } from \"node:util\";\nfunction useFocusManager({\n  visibleOptionCount: defaultVisibleOptionCount = 5,\n  options: __optionsList,\n  initialFocusValue: _initialFocusValue,\n  onFocus: onFocusChange,\n  focusValue: currentFocusValue\n}) {\n  let [focusState, dispatchFocusAction] = initializeRendering.useReducer(initializeDevToolsFromConnection, {\n    visibleOptionCount: defaultVisibleOptionCount,\n    options: __optionsList,\n    initialFocusValue: currentFocusValue || _initialFocusValue\n  }, _______________________________________initializeDevToolsConnection);\n  let [currentOptions, _useFocusManager] = initializeRendering.useState(__optionsList);\n  if (__optionsList !== currentOptions && !__________________initializeDevTools(__optionsList, currentOptions)) {\n    dispatchFocusAction({\n      type: \"reset\",\n      state: _______________________________________initializeDevToolsConnection({\n        visibleOptionCount: defaultVisibleOptionCount,\n        options: __optionsList,\n        initialFocusValue: currentFocusValue ?? focusState.focusedValue ?? _initialFocusValue,\n        currentViewport: {\n          visibleFromIndex: focusState.visibleFromIndex,\n          visibleToIndex: focusState.visibleToIndex\n        }\n      })\n    });\n    _useFocusManager(__optionsList);\n  }\n  let focusNextOption = initializeRendering.useCallback(() => {\n    dispatchFocusAction({\n      type: \"focus-next-option\"\n    });\n  }, []);\n  let focusPreviousOption = initializeRendering.useCallback(() => {\n    dispatchFocusAction({\n      type: \"focus-previous-option\"\n    });\n  }, []);\n  let focusNextPage = initializeRendering.useCallback(() => {\n    dispatchFocusAction({\n      type: \"focus-next-page\"\n    });\n  }, []);\n  let focusPreviousPage = initializeRendering.useCallback(() => {\n    dispatchFocusAction({\n      type: \"focus-previous-page\"\n    });\n  }, []);\n  let setFocus = initializeRendering.useCallback(focusValue => {\n    if (focusValue !== undefined) {\n      dispatchFocusAction({\n        type: \"set-focus\",\n        value: focusValue\n      });\n    }\n  }, []);\n  let visibleOptions = initializeRendering.useMemo(() => {\n    return __optionsList.map((mergeWithIndex, _indexValue) => ({\n      ...mergeWithIndex,\n      index: _indexValue\n    })).slice(focusState.visibleFromIndex, focusState.visibleToIndex);\n  }, [__optionsList, focusState.visibleFromIndex, focusState.visibleToIndex]);\n  initializeRendering.useEffect(() => {\n    if (focusState.focusedValue !== undefined) {\n      onFocusChange?.(focusState.focusedValue);\n    }\n  }, [focusState.focusedValue, onFocusChange]);\n  initializeRendering.useEffect(() => {\n    if (currentFocusValue !== undefined) {\n      dispatchFocusAction({\n        type: \"set-focus\",\n        value: currentFocusValue\n      });\n    }\n  }, [currentFocusValue]);\n  let isFocusedValueInput = initializeRendering.useMemo(() => {\n    return __optionsList.find(isFocusedValueEqual => isFocusedValueEqual.value === focusState.focusedValue)?.type === \"input\";\n  }, [focusState.focusedValue, __optionsList]);\n  return {\n    focusedValue: focusState.focusedValue,\n    visibleFromIndex: focusState.visibleFromIndex,\n    visibleToIndex: focusState.visibleToIndex,\n    visibleOptions: visibleOptions,\n    isInInput: isFocusedValueInput ?? false,\n    focusNextOption: focusNextOption,\n    focusPreviousOption: focusPreviousOption,\n    focusNextPage: focusNextPage,\n    focusPreviousPage: focusPreviousPage,\n    focusOption: setFocus,\n    options: __optionsList\n  };\n}\nvar initializeRendering;\nvar initializeDevToolsFromConnection = (focusHandler, handleFocusAction) => {\n  switch (handleFocusAction.type) {\n    case \"focus-next-option\":\n      {\n        if (focusHandler.focusedValue === undefined) {\n          return focusHandler;\n        }\n        let focusedOption = focusHandler.optionMap.get(focusHandler.focusedValue);\n        if (!focusedOption) {\n          return focusHandler;\n        }\n        let nextOption = focusedOption.next || focusHandler.optionMap.first;\n        if (!nextOption) {\n          return focusHandler;\n        }\n        if (!focusedOption.next && nextOption === focusHandler.optionMap.first) {\n          return {\n            ...focusHandler,\n            focusedValue: nextOption.value,\n            visibleFromIndex: 0,\n            visibleToIndex: focusHandler.visibleOptionCount\n          };\n        }\n        if (!(nextOption.index >= focusHandler.visibleToIndex)) {\n          return {\n            ...focusHandler,\n            focusedValue: nextOption.value\n          };\n        }\n        let nextVisibleOptionCount = Math.min(focusHandler.optionMap.size, focusHandler.visibleToIndex + 1);\n        let visibleToIndexLimit = nextVisibleOptionCount - focusHandler.visibleOptionCount;\n        return {\n          ...focusHandler,\n          focusedValue: nextOption.value,\n          visibleFromIndex: visibleToIndexLimit,\n          visibleToIndex: nextVisibleOptionCount\n        };\n      }\n    case \"focus-previous-option\":\n      {\n        if (focusHandler.focusedValue === undefined) {\n          return focusHandler;\n        }\n        let ___focusedOption = focusHandler.optionMap.get(focusHandler.focusedValue);\n        if (!___focusedOption) {\n          return focusHandler;\n        }\n        let nextFocusedOption = ___focusedOption.previous || focusHandler.optionMap.last;\n        if (!nextFocusedOption) {\n          return focusHandler;\n        }\n        if (!___focusedOption.previous && nextFocusedOption === focusHandler.optionMap.last) {\n          let totalOptionsCount = focusHandler.optionMap.size;\n          let focusOptionHandler = Math.max(0, totalOptionsCount - focusHandler.visibleOptionCount);\n          return {\n            ...focusHandler,\n            focusedValue: nextFocusedOption.value,\n            visibleFromIndex: focusOptionHandler,\n            visibleToIndex: totalOptionsCount\n          };\n        }\n        if (!(nextFocusedOption.index <= focusHandler.visibleFromIndex)) {\n          return {\n            ...focusHandler,\n            focusedValue: nextFocusedOption.value\n          };\n        }\n        let _visibleToIndexLimit = Math.max(0, focusHandler.visibleFromIndex - 1);\n        let visibleOptionStart = _visibleToIndexLimit + focusHandler.visibleOptionCount;\n        return {\n          ...focusHandler,\n          focusedValue: nextFocusedOption.value,\n          visibleFromIndex: _visibleToIndexLimit,\n          visibleToIndex: visibleOptionStart\n        };\n      }\n    case \"focus-next-page\":\n      {\n        if (focusHandler.focusedValue === undefined) {\n          return focusHandler;\n        }\n        let ______focusedOption = focusHandler.optionMap.get(focusHandler.focusedValue);\n        if (!______focusedOption) {\n          return focusHandler;\n        }\n        let ________focusedOption = Math.min(focusHandler.optionMap.size - 1, ______focusedOption.index + focusHandler.visibleOptionCount);\n        let currentOption = focusHandler.optionMap.first;\n        while (currentOption && currentOption.index < ________focusedOption) {\n          if (currentOption.next) {\n            currentOption = currentOption.next;\n          } else {\n            break;\n          }\n        }\n        if (!currentOption) {\n          return focusHandler;\n        }\n        let __visibleToIndexLimit = Math.min(focusHandler.optionMap.size, currentOption.index + 1);\n        let visibleToIndexAdjustment = Math.max(0, __visibleToIndexLimit - focusHandler.visibleOptionCount);\n        return {\n          ...focusHandler,\n          focusedValue: currentOption.value,\n          visibleFromIndex: visibleToIndexAdjustment,\n          visibleToIndex: __visibleToIndexLimit\n        };\n      }\n    case \"focus-previous-page\":\n      {\n        if (focusHandler.focusedValue === undefined) {\n          return focusHandler;\n        }\n        let _________focusedOption = focusHandler.optionMap.get(focusHandler.focusedValue);\n        if (!_________focusedOption) {\n          return focusHandler;\n        }\n        let previousPageIndex = Math.max(0, _________focusedOption.index - focusHandler.visibleOptionCount);\n        let __currentOption = focusHandler.optionMap.first;\n        while (__currentOption && __currentOption.index < previousPageIndex) {\n          if (__currentOption.next) {\n            __currentOption = __currentOption.next;\n          } else {\n            break;\n          }\n        }\n        if (!__currentOption) {\n          return focusHandler;\n        }\n        let visibleToIndexEnd = Math.max(0, __currentOption.index);\n        let ___visibleToIndexLimit = Math.min(focusHandler.optionMap.size, visibleToIndexEnd + focusHandler.visibleOptionCount);\n        return {\n          ...focusHandler,\n          focusedValue: __currentOption.value,\n          visibleFromIndex: visibleToIndexEnd,\n          visibleToIndex: ___visibleToIndexLimit\n        };\n      }\n    case \"reset\":\n      return handleFocusAction.state;\n    case \"set-focus\":\n      {\n        let selectedOption = focusHandler.optionMap.get(handleFocusAction.value);\n        if (!selectedOption) {\n          return focusHandler;\n        }\n        if (selectedOption.index >= focusHandler.visibleFromIndex && selectedOption.index < focusHandler.visibleToIndex) {\n          return {\n            ...focusHandler,\n            focusedValue: handleFocusAction.value\n          };\n        }\n        let _previousPageIndex;\n        let currentOptionForPreviousPage;\n        if (selectedOption.index < focusHandler.visibleFromIndex) {\n          _previousPageIndex = selectedOption.index;\n          currentOptionForPreviousPage = Math.min(focusHandler.optionMap.size, _previousPageIndex + focusHandler.visibleOptionCount);\n        } else {\n          currentOptionForPreviousPage = Math.min(focusHandler.optionMap.size, selectedOption.index + 1);\n          _previousPageIndex = Math.max(0, currentOptionForPreviousPage - focusHandler.visibleOptionCount);\n        }\n        return {\n          ...focusHandler,\n          focusedValue: handleFocusAction.value,\n          visibleFromIndex: _previousPageIndex,\n          visibleToIndex: currentOptionForPreviousPage\n        };\n      }\n  }\n};\nvar _______________________________________initializeDevToolsConnection = ({\n  visibleOptionCount: calculateVisibleOptions,\n  options: _optionsList,\n  initialFocusValue: initialFocusValue,\n  currentViewport: currentViewport\n}) => {\n  let calculatedVisibleOptionCount = typeof calculateVisibleOptions === \"number\" ? Math.min(calculateVisibleOptions, _optionsList.length) : _optionsList.length;\n  let optionMap = new updateParentAttributes(_optionsList);\n  let ___________focusedOption = initialFocusValue !== undefined && optionMap.get(initialFocusValue);\n  let focusedOptionValue = ___________focusedOption ? initialFocusValue : optionMap.first?.value;\n  let startingVisibleIndex = 0;\n  let visibleOptionCountInViewport = calculatedVisibleOptionCount;\n  if (___________focusedOption && currentViewport) {\n    let focusedOptionIndex = ___________focusedOption.index;\n    if (focusedOptionIndex >= currentViewport.visibleFromIndex && focusedOptionIndex < currentViewport.visibleToIndex) {\n      startingVisibleIndex = currentViewport.visibleFromIndex;\n      visibleOptionCountInViewport = Math.min(optionMap.size, currentViewport.visibleToIndex);\n    } else if (focusedOptionIndex < currentViewport.visibleFromIndex) {\n      startingVisibleIndex = focusedOptionIndex;\n      visibleOptionCountInViewport = Math.min(optionMap.size, startingVisibleIndex + calculatedVisibleOptionCount);\n    } else {\n      visibleOptionCountInViewport = Math.min(optionMap.size, focusedOptionIndex + 1);\n      startingVisibleIndex = Math.max(0, visibleOptionCountInViewport - calculatedVisibleOptionCount);\n    }\n    startingVisibleIndex = Math.max(0, Math.min(startingVisibleIndex, optionMap.size - 1));\n    visibleOptionCountInViewport = Math.min(optionMap.size, Math.max(calculatedVisibleOptionCount, visibleOptionCountInViewport));\n  }\n  return {\n    optionMap: optionMap,\n    visibleOptionCount: calculatedVisibleOptionCount,\n    focusedValue: focusedOptionValue,\n    visibleFromIndex: startingVisibleIndex,\n    visibleToIndex: visibleOptionCountInViewport\n  };\n};\nvar __________initializeRenderer = T(() => {\n  calculateObjectDifference();\n  initializeRendering = IA(KA(), 1);\n});\nfunction useSelectableOptions({\n  visibleOptionCount: _visibleOptionCount = 5,\n  options: availableOptions,\n  defaultValue: defaultSelectedValue,\n  onChange: handleOptionChange,\n  onCancel: onCancelCallback,\n  onFocus: handleFocus,\n  focusValue: _focusedOptionValue\n}) {\n  let [selectedOptionValue, setSelectedValue] = addDevicePixelDensity.useState(defaultSelectedValue);\n  let focusManager = useFocusManager({\n    visibleOptionCount: _visibleOptionCount,\n    options: availableOptions,\n    initialFocusValue: undefined,\n    onFocus: handleFocus,\n    focusValue: _focusedOptionValue\n  });\n  let updateSelectedOption = addDevicePixelDensity.useCallback(() => {\n    setSelectedValue(focusManager.focusedValue);\n  }, [focusManager.focusedValue]);\n  return {\n    ...focusManager,\n    value: selectedOptionValue,\n    selectFocusedOption: updateSelectedOption,\n    onChange: handleOptionChange,\n    onCancel: onCancelCallback\n  };\n}\nvar addDevicePixelDensity;\nvar _______________________________________________initializeDevToolsConnection = T(() => {\n  __________initializeRenderer();\n  addDevicePixelDensity = IA(KA(), 1);\n});\nvar ________________________________________initializeDevToolsConnection = ({\n  isDisabled: isComponentDisabled = false,\n  disableSelection: allowSelection = false,\n  state: dropdownState,\n  options: optionsList,\n  isMultiSelect: isMultiSelectEnabled = false\n}) => {\n  renderAndSetupComponent((_inputKey, keyboardShortcuts) => {\n    if (optionsList.find(isValueFocused => isValueFocused.value === dropdownState.focusedValue)?.type === \"input\") {\n      if (!keyboardShortcuts.upArrow && !keyboardShortcuts.downArrow && !keyboardShortcuts.escape && (!keyboardShortcuts.ctrl || _inputKey !== \"n\" && _inputKey !== \"p\")) {\n        return;\n      }\n    }\n    if (keyboardShortcuts.downArrow || keyboardShortcuts.ctrl && _inputKey === \"n\" || !keyboardShortcuts.ctrl && !keyboardShortcuts.shift && _inputKey === \"j\") {\n      dropdownState.focusNextOption();\n    }\n    if (keyboardShortcuts.upArrow || keyboardShortcuts.ctrl && _inputKey === \"p\" || !keyboardShortcuts.ctrl && !keyboardShortcuts.shift && _inputKey === \"k\") {\n      dropdownState.focusPreviousOption();\n    }\n    if (keyboardShortcuts.pageDown) {\n      dropdownState.focusNextPage();\n    }\n    if (keyboardShortcuts.pageUp) {\n      dropdownState.focusPreviousPage();\n    }\n    if (allowSelection !== true) {\n      if ((isMultiSelectEnabled ? keyboardShortcuts.return || _inputKey === \" \" : keyboardShortcuts.return) && dropdownState.focusedValue !== undefined) {\n        dropdownState.selectFocusedOption?.();\n        dropdownState.onChange?.(dropdownState.focusedValue);\n      }\n      if (allowSelection !== \"numeric\" && /^[0-9]+$/.test(_inputKey)) {\n        let selectedOptionIndex = parseInt(_inputKey) - 1;\n        if (selectedOptionIndex >= 0 && selectedOptionIndex < dropdownState.options.length) {\n          let __________focusedOption = dropdownState.options[selectedOptionIndex];\n          if (__________focusedOption.type === \"input\") {\n            dropdownState.focusOption(__________focusedOption.value);\n            return;\n          }\n          dropdownState.onChange?.(__________focusedOption.value);\n          return;\n        }\n      }\n    }\n    if (keyboardShortcuts.escape) {\n      dropdownState.onCancel?.();\n    }\n  }, {\n    isActive: !isComponentDisabled\n  });\n};\nvar Jk0 = T(() => {\n  nA();\n});\nclass vI {\n  measuredText;\n  selection;\n  offset;\n  constructor(measuredText, offsetValue = 0, selectionIndex = 0) {\n    this.measuredText = measuredText;\n    this.selection = selectionIndex;\n    this.offset = Math.max(0, Math.min(this.text.length, offsetValue));\n  }\n  static fromText(createTextWrapper, createTextWrapperInstance, defaultValue = 0, ___initialValue = 0) {\n    return new vI(new TextWrapper(createTextWrapper, createTextWrapperInstance - 1), defaultValue, ___initialValue);\n  }\n  render(A, B, Q) {\n    let {\n      line: I,\n      column: G\n    } = this.getPosition();\n    return this.measuredText.getWrappedText().map((processText, currentSegmentIndex, maxLengthString) => {\n      let modifiedText = processText;\n      if (B && currentSegmentIndex === maxLengthString.length - 1) {\n        let maxLengthForRepeat = Math.max(0, processText.length - 6);\n        modifiedText = B.repeat(maxLengthForRepeat) + processText.slice(maxLengthForRepeat);\n      }\n      if (I !== currentSegmentIndex) {\n        return modifiedText.trimEnd();\n      }\n      let displayWidthIndex = this.measuredText.displayWidthToStringIndex(modifiedText, G);\n      let renderedSegments = Array.from(initializeRenderTree.segment(modifiedText)).map(({\n        segment: segment,\n        index: indexValue\n      }) => ({\n        segment: segment,\n        index: indexValue\n      }));\n      let accumulatedSegments = \"\";\n      let currentSegment = A;\n      let overflowSegment = \"\";\n      for (let {\n        segment: segmentContent,\n        index: segmentIndex\n      } of renderedSegments) {\n        let _calculatedWidth = segmentIndex + segmentContent.length;\n        if (_calculatedWidth <= displayWidthIndex) {\n          accumulatedSegments += segmentContent;\n        } else if (segmentIndex < displayWidthIndex && _calculatedWidth > displayWidthIndex) {\n          currentSegment = segmentContent;\n        } else if (segmentIndex === displayWidthIndex) {\n          currentSegment = segmentContent;\n        } else {\n          overflowSegment += segmentContent;\n        }\n      }\n      let processedSegment = A ? Q(currentSegment) : currentSegment;\n      return accumulatedSegments + processedSegment + overflowSegment.trimEnd();\n    }).join(`\n`);\n  }\n  left() {\n    if (this.offset === 0) {\n      return this;\n    }\n    let previousOffset = this.measuredText.prevOffset(this.offset);\n    return new vI(this.measuredText, previousOffset);\n  }\n  right() {\n    if (this.offset >= this.text.length) {\n      return this;\n    }\n    let nextTextOffset = this.measuredText.nextOffset(this.offset);\n    return new vI(this.measuredText, Math.min(nextTextOffset, this.text.length));\n  }\n  up() {\n    let {\n      line: ____currentLine,\n      column: currentColumn\n    } = this.getPosition();\n    if (____currentLine === 0) {\n      return this;\n    }\n    let previousLineText = this.measuredText.getWrappedText()[____currentLine - 1];\n    if (!previousLineText) {\n      return this;\n    }\n    let lastWrappedLineLength = k7(previousLineText);\n    if (currentColumn > lastWrappedLineLength) {\n      let offsetForPreviousLine = this.getOffset({\n        line: ____currentLine - 1,\n        column: lastWrappedLineLength\n      });\n      return new vI(this.measuredText, offsetForPreviousLine, 0);\n    }\n    let previousLineOffset = this.getOffset({\n      line: ____currentLine - 1,\n      column: currentColumn\n    });\n    return new vI(this.measuredText, previousLineOffset, 0);\n  }\n  down() {\n    let {\n      line: _____currentLine,\n      column: _currentColumn\n    } = this.getPosition();\n    if (_____currentLine >= this.measuredText.lineCount - 1) {\n      return this;\n    }\n    let nextLineText = this.measuredText.getWrappedText()[_____currentLine + 1];\n    if (!nextLineText) {\n      return this;\n    }\n    let wrappedLineWidth = k7(nextLineText);\n    if (_currentColumn > wrappedLineWidth) {\n      let calculatedOffsetForNewLine = this.getOffset({\n        line: _____currentLine + 1,\n        column: wrappedLineWidth\n      });\n      return new vI(this.measuredText, calculatedOffsetForNewLine, 0);\n    }\n    let offsetForNextLine = this.getOffset({\n      line: _____currentLine + 1,\n      column: _currentColumn\n    });\n    return new vI(this.measuredText, offsetForNextLine, 0);\n  }\n  startOfLine() {\n    let {\n      line: startOfLine\n    } = this.getPosition();\n    return new vI(this.measuredText, this.getOffset({\n      line: startOfLine,\n      column: 0\n    }), 0);\n  }\n  firstNonBlankInLine() {\n    let {\n      line: ___currentLineIndex\n    } = this.getPosition();\n    let _firstNonBlankCharacterMatch = (this.measuredText.getWrappedText()[___currentLineIndex] || \"\").match(/^\\s*\\S/);\n    let lastNonBlankCharIndex = _firstNonBlankCharacterMatch?.index ? _firstNonBlankCharacterMatch.index + _firstNonBlankCharacterMatch[0].length - 1 : 0;\n    let lastNonBlankCharacterOffset = this.getOffset({\n      line: ___currentLineIndex,\n      column: lastNonBlankCharIndex\n    });\n    return new vI(this.measuredText, lastNonBlankCharacterOffset, 0);\n  }\n  endOfLine() {\n    let {\n      line: ___currentLine\n    } = this.getPosition();\n    let _lineLength = this.measuredText.getLineLength(___currentLine);\n    let offsetAtEndOfLine = this.getOffset({\n      line: ___currentLine,\n      column: _lineLength\n    });\n    return new vI(this.measuredText, offsetAtEndOfLine, 0);\n  }\n  findLogicalLineStart(findLogicalLineStartOffsetThisOffset = this.offset) {\n    let lastNewLineIndex = this.text.lastIndexOf(`\n`, findLogicalLineStartOffsetThisOffset - 1);\n    if (lastNewLineIndex === -1) {\n      return 0;\n    } else {\n      return lastNewLineIndex + 1;\n    }\n  }\n  findLogicalLineEnd(findLogicalLineEndStartingFromOffset = this.offset) {\n    let _newlineIndex = this.text.indexOf(`\n`, findLogicalLineEndStartingFromOffset);\n    if (_newlineIndex === -1) {\n      return this.text.length;\n    } else {\n      return _newlineIndex;\n    }\n  }\n  getLogicalLineBounds() {\n    return {\n      start: this.findLogicalLineStart(),\n      end: this.findLogicalLineEnd()\n    };\n  }\n  createCursorWithColumn(createCursorWithOffset, _calculateCursorPosition, maxCursorOffset) {\n    let cursorPosition = _calculateCursorPosition - createCursorWithOffset;\n    let limitedCursorPosition = Math.min(maxCursorOffset, cursorPosition);\n    return new vI(this.measuredText, createCursorWithOffset + limitedCursorPosition, 0);\n  }\n  endOfLogicalLine() {\n    return new vI(this.measuredText, this.findLogicalLineEnd(), 0);\n  }\n  startOfLogicalLine() {\n    return new vI(this.measuredText, this.findLogicalLineStart(), 0);\n  }\n  firstNonBlankInLogicalLine() {\n    let {\n      start: __startIndex,\n      end: endIndex\n    } = this.getLogicalLineBounds();\n    let firstNonBlankCharacterMatch = this.text.slice(__startIndex, endIndex).match(/\\S/);\n    let firstNonBlankCharacterIndex = __startIndex + (firstNonBlankCharacterMatch?.index ?? 0);\n    return new vI(this.measuredText, firstNonBlankCharacterIndex, 0);\n  }\n  upLogicalLine() {\n    let {\n      start: logicalLineStart\n    } = this.getLogicalLineBounds();\n    if (logicalLineStart === 0) {\n      return new vI(this.measuredText, 0, 0);\n    }\n    let _offsetFromStart = this.offset - logicalLineStart;\n    let lastIndexOfLogicalLine = logicalLineStart - 1;\n    let logicalLineStartIndex = this.findLogicalLineStart(lastIndexOfLogicalLine);\n    return this.createCursorWithColumn(logicalLineStartIndex, lastIndexOfLogicalLine, _offsetFromStart);\n  }\n  downLogicalLine() {\n    let {\n      start: _logicalLineStart,\n      end: lineEndIndex\n    } = this.getLogicalLineBounds();\n    if (lineEndIndex >= this.text.length) {\n      return new vI(this.measuredText, this.text.length, 0);\n    }\n    let offsetFromLogicalLineStart = this.offset - _logicalLineStart;\n    let logicalLineEndIndex = lineEndIndex + 1;\n    let logicalLineEnd = this.findLogicalLineEnd(logicalLineEndIndex);\n    return this.createCursorWithColumn(logicalLineEndIndex, logicalLineEnd, offsetFromLogicalLineStart);\n  }\n  nextWord() {\n    let currentCharacterPointer = this;\n    while (currentCharacterPointer.isOverWordChar() && !currentCharacterPointer.isAtEnd()) {\n      currentCharacterPointer = currentCharacterPointer.right();\n    }\n    while (!currentCharacterPointer.isOverWordChar() && !currentCharacterPointer.isAtEnd()) {\n      currentCharacterPointer = currentCharacterPointer.right();\n    }\n    return currentCharacterPointer;\n  }\n  endOfWord() {\n    let currentWordPointer = this;\n    if (currentWordPointer.isOverWordChar() && (!currentWordPointer.right().isOverWordChar() || currentWordPointer.right().isAtEnd())) {\n      currentWordPointer = currentWordPointer.right();\n      return currentWordPointer.endOfWord();\n    }\n    if (!currentWordPointer.isOverWordChar()) {\n      currentWordPointer = currentWordPointer.nextWord();\n    }\n    while (currentWordPointer.right().isOverWordChar() && !currentWordPointer.isAtEnd()) {\n      currentWordPointer = currentWordPointer.right();\n    }\n    return currentWordPointer;\n  }\n  prevWord() {\n    let currentCursor = this;\n    if (!currentCursor.left().isOverWordChar()) {\n      currentCursor = currentCursor.left();\n    }\n    while (!currentCursor.isOverWordChar() && !currentCursor.isAtStart()) {\n      currentCursor = currentCursor.left();\n    }\n    if (currentCursor.isOverWordChar()) {\n      while (currentCursor.left().isOverWordChar() && !currentCursor.isAtStart()) {\n        currentCursor = currentCursor.left();\n      }\n    }\n    return currentCursor;\n  }\n  nextWORD() {\n    let currentPosition = this;\n    while (!currentPosition.isOverWhitespace() && !currentPosition.isAtEnd()) {\n      currentPosition = currentPosition.right();\n    }\n    while (currentPosition.isOverWhitespace() && !currentPosition.isAtEnd()) {\n      currentPosition = currentPosition.right();\n    }\n    return currentPosition;\n  }\n  endOfWORD() {\n    let currentPointer = this;\n    if (!currentPointer.isOverWhitespace() && (currentPointer.right().isOverWhitespace() || currentPointer.right().isAtEnd())) {\n      currentPointer = currentPointer.right();\n      return currentPointer.endOfWORD();\n    }\n    if (currentPointer.isOverWhitespace()) {\n      currentPointer = currentPointer.nextWORD();\n    }\n    while (!currentPointer.right().isOverWhitespace() && !currentPointer.isAtEnd()) {\n      currentPointer = currentPointer.right();\n    }\n    return currentPointer;\n  }\n  prevWORD() {\n    let _currentCursor = this;\n    if (_currentCursor.left().isOverWhitespace()) {\n      _currentCursor = _currentCursor.left();\n    }\n    while (_currentCursor.isOverWhitespace() && !_currentCursor.isAtStart()) {\n      _currentCursor = _currentCursor.left();\n    }\n    if (!_currentCursor.isOverWhitespace()) {\n      while (!_currentCursor.left().isOverWhitespace() && !_currentCursor.isAtStart()) {\n        _currentCursor = _currentCursor.left();\n      }\n    }\n    return _currentCursor;\n  }\n  modifyText(modifyTextWithModifiedContent, _modifiedText = \"\") {\n    let _offsetValue = this.offset;\n    let modifiedTextOffset = modifyTextWithModifiedContent.offset;\n    let updatedText = this.text.slice(0, _offsetValue) + _modifiedText + this.text.slice(modifiedTextOffset);\n    return vI.fromText(updatedText, this.columns, _offsetValue + _modifiedText.normalize(\"NFC\").length);\n  }\n  insert(textModificationParameter) {\n    return this.modifyText(this, textModificationParameter);\n  }\n  del() {\n    if (this.isAtEnd()) {\n      return this;\n    }\n    return this.modifyText(this.right());\n  }\n  backspace() {\n    if (this.isAtStart()) {\n      return this;\n    }\n    return this.left().modifyText(this);\n  }\n  deleteToLineStart() {\n    return this.startOfLine().modifyText(this);\n  }\n  deleteToLineEnd() {\n    if (this.text[this.offset] === `\n`) {\n      return this.modifyText(this.right());\n    }\n    return this.modifyText(this.endOfLine());\n  }\n  deleteToLogicalLineEnd() {\n    if (this.text[this.offset] === `\n`) {\n      return this.modifyText(this.right());\n    }\n    return this.modifyText(this.endOfLogicalLine());\n  }\n  deleteWordBefore() {\n    if (this.isAtStart()) {\n      return this;\n    }\n    return this.prevWord().modifyText(this);\n  }\n  deleteWordAfter() {\n    if (this.isAtEnd()) {\n      return this;\n    }\n    return this.modifyText(this.nextWord());\n  }\n  isOverWordChar() {\n    let currentCharacter = this.text[this.offset] ?? \"\";\n    return /\\w/.test(currentCharacter);\n  }\n  isOverWhitespace() {\n    let _currentCharacter = this.text[this.offset] ?? \"\";\n    return /\\s/.test(_currentCharacter);\n  }\n  equals(_isEqualTo) {\n    return this.offset === _isEqualTo.offset && this.measuredText === _isEqualTo.measuredText;\n  }\n  isAtStart() {\n    return this.offset === 0;\n  }\n  isAtEnd() {\n    return this.offset >= this.text.length;\n  }\n  startOfFirstLine() {\n    return new vI(this.measuredText, 0, 0);\n  }\n  startOfLastLine() {\n    let lastLineStartIndex = this.text.lastIndexOf(`\n`);\n    if (lastLineStartIndex === -1) {\n      return this.startOfLine();\n    }\n    return new vI(this.measuredText, lastLineStartIndex + 1, 0);\n  }\n  get text() {\n    return this.measuredText.text;\n  }\n  get columns() {\n    return this.measuredText.columns + 1;\n  }\n  getPosition() {\n    return this.measuredText.getPositionFromOffset(this.offset);\n  }\n  getOffset(position) {\n    return this.measuredText.getOffsetFromPosition(position);\n  }\n}\nclass TextSegment {\n  text;\n  startOffset;\n  isPrecededByNewline;\n  endsWithNewline;\n  constructor(_textContent, startOffset, isPrecededByNewline, endsWithNewline = false) {\n    this.text = _textContent;\n    this.startOffset = startOffset;\n    this.isPrecededByNewline = isPrecededByNewline;\n    this.endsWithNewline = endsWithNewline;\n  }\n  equals(isEqualTo) {\n    return this.text === isEqualTo.text && this.startOffset === isEqualTo.startOffset;\n  }\n  get length() {\n    return this.text.length + (this.endsWithNewline ? 1 : 0);\n  }\n}\nclass TextWrapper {\n  columns;\n  _wrappedLines;\n  text;\n  navigationCache;\n  graphemeBoundaries;\n  constructor(inputText, _columnCount) {\n    this.columns = _columnCount;\n    this.text = inputText.normalize(\"NFC\");\n    this.navigationCache = new Map();\n  }\n  get wrappedLines() {\n    if (!this._wrappedLines) {\n      this._wrappedLines = this.measureWrappedText();\n    }\n    return this._wrappedLines;\n  }\n  getGraphemeBoundaries() {\n    if (!this.graphemeBoundaries) {\n      this.graphemeBoundaries = [];\n      for (let {\n        index: charIndex\n      } of initializeRenderTree.segment(this.text)) {\n        this.graphemeBoundaries.push(charIndex);\n      }\n      this.graphemeBoundaries.push(this.text.length);\n    }\n    return this.graphemeBoundaries;\n  }\n  binarySearchBoundary(binarySearchBoundaryToFindThreshold, boundaryValue, isFindingUpperBoundary) {\n    let lowerBoundIndex = 0;\n    let rightBoundaryIndex = binarySearchBoundaryToFindThreshold.length - 1;\n    let lastFoundElement = isFindingUpperBoundary ? this.text.length : 0;\n    while (lowerBoundIndex <= rightBoundaryIndex) {\n      let midpointIndex = Math.floor((lowerBoundIndex + rightBoundaryIndex) / 2);\n      let currentElement = binarySearchBoundaryToFindThreshold[midpointIndex];\n      if (currentElement === undefined) {\n        break;\n      }\n      if (isFindingUpperBoundary) {\n        if (currentElement > boundaryValue) {\n          lastFoundElement = currentElement;\n          rightBoundaryIndex = midpointIndex - 1;\n        } else {\n          lowerBoundIndex = midpointIndex + 1;\n        }\n      } else if (currentElement < boundaryValue) {\n        lastFoundElement = currentElement;\n        lowerBoundIndex = midpointIndex + 1;\n      } else {\n        rightBoundaryIndex = midpointIndex - 1;\n      }\n    }\n    return lastFoundElement;\n  }\n  stringIndexToDisplayWidth(getDisplayWidthByStringIndex, stringIndexToDisplayWidth) {\n    if (stringIndexToDisplayWidth <= 0) {\n      return 0;\n    }\n    if (stringIndexToDisplayWidth >= getDisplayWidthByStringIndex.length) {\n      return k7(getDisplayWidthByStringIndex);\n    }\n    return k7(getDisplayWidthByStringIndex.substring(0, stringIndexToDisplayWidth));\n  }\n  displayWidthToStringIndex(getStringIndexByDisplayWidth, _displayWidth) {\n    if (_displayWidth <= 0) {\n      return 0;\n    }\n    if (!getStringIndexByDisplayWidth) {\n      return 0;\n    }\n    if (getStringIndexByDisplayWidth === this.text) {\n      return this.offsetAtDisplayWidth(_displayWidth);\n    }\n    let cumulativeRenderedWidth = 0;\n    let lastRenderedIndex = 0;\n    for (let {\n      segment: segmentData,\n      index: _segmentIndex\n    } of initializeRenderTree.segment(getStringIndexByDisplayWidth)) {\n      let renderedSegmentLength = k7(segmentData);\n      if (cumulativeRenderedWidth + renderedSegmentLength > _displayWidth) {\n        break;\n      }\n      cumulativeRenderedWidth += renderedSegmentLength;\n      lastRenderedIndex = _segmentIndex + segmentData.length;\n    }\n    return lastRenderedIndex;\n  }\n  offsetAtDisplayWidth(getOffsetAtDisplayWidth) {\n    if (getOffsetAtDisplayWidth <= 0) {\n      return 0;\n    }\n    let accumulatedScore = 0;\n    let __graphemeBoundaries = this.getGraphemeBoundaries();\n    for (let ___currentIndex = 0; ___currentIndex < __graphemeBoundaries.length - 1; ___currentIndex++) {\n      let startIndex = __graphemeBoundaries[___currentIndex];\n      let nextIndex = __graphemeBoundaries[___currentIndex + 1];\n      if (startIndex === undefined || nextIndex === undefined) {\n        continue;\n      }\n      let substringBetweenIndices = this.text.substring(startIndex, nextIndex);\n      let calculateSubstringScore = k7(substringBetweenIndices);\n      if (accumulatedScore + calculateSubstringScore > getOffsetAtDisplayWidth) {\n        return startIndex;\n      }\n      accumulatedScore += calculateSubstringScore;\n    }\n    return this.text.length;\n  }\n  measureWrappedText() {\n    let wrappedTextMeasurements = V0A(this.text, this.columns, {\n      hard: true,\n      trim: false\n    });\n    let wrappedTextSegments = [];\n    let lastIndexProcessed = 0;\n    let lastNewlineIndex = -1;\n    let splitTextIntoLines = wrappedTextMeasurements.split(`\n`);\n    for (let currentIndex = 0; currentIndex < splitTextIntoLines.length; currentIndex++) {\n      let currentLine = splitTextIntoLines[currentIndex];\n      let isLineStart = previousCharIsNewline => currentIndex === 0 || previousCharIsNewline > 0 && this.text[previousCharIsNewline - 1] === `\n`;\n      if (currentLine.length === 0) {\n        lastNewlineIndex = this.text.indexOf(`\n`, lastNewlineIndex + 1);\n        if (lastNewlineIndex !== -1) {\n          let _currentIndex = lastNewlineIndex;\n          let isLineWrapped = true;\n          wrappedTextSegments.push(new TextSegment(currentLine, _currentIndex, isLineStart(_currentIndex), true));\n        } else {\n          let findWrappedLineIndex = this.text.length;\n          wrappedTextSegments.push(new TextSegment(currentLine, findWrappedLineIndex, isLineStart(findWrappedLineIndex), false));\n        }\n      } else {\n        let _lineIndex = this.text.indexOf(currentLine, lastIndexProcessed);\n        if (_lineIndex === -1) {\n          throw Error(\"Failed to find wrapped line in text\");\n        }\n        lastIndexProcessed = _lineIndex + currentLine.length;\n        let isLineBreakFollowing = _lineIndex + currentLine.length;\n        let isNextCharacterNewline = isLineBreakFollowing < this.text.length && this.text[isLineBreakFollowing] === `\n`;\n        if (isNextCharacterNewline) {\n          lastNewlineIndex = isLineBreakFollowing;\n        }\n        wrappedTextSegments.push(new TextSegment(currentLine, _lineIndex, isLineStart(_lineIndex), isNextCharacterNewline));\n      }\n    }\n    return wrappedTextSegments;\n  }\n  getWrappedText() {\n    return this.wrappedLines.map(textWithLeadingNewline => textWithLeadingNewline.isPrecededByNewline ? textWithLeadingNewline.text : textWithLeadingNewline.text.trimStart());\n  }\n  getWrappedLines() {\n    return this.wrappedLines;\n  }\n  getLine(getLine) {\n    let _wrappedLines = this.wrappedLines;\n    return _wrappedLines[Math.max(0, Math.min(getLine, _wrappedLines.length - 1))];\n  }\n  getOffsetFromPosition(getOffsetFromPosition) {\n    let lineData = this.getLine(getOffsetFromPosition.line);\n    if (lineData.text.length === 0 && lineData.endsWithNewline) {\n      return lineData.startOffset;\n    }\n    let leadingWhitespaceOffset = lineData.isPrecededByNewline ? 0 : lineData.text.length - lineData.text.trimStart().length;\n    let calculatedOffset = getOffsetFromPosition.column + leadingWhitespaceOffset;\n    let stringIndexFromDisplayWidth = this.displayWidthToStringIndex(lineData.text, calculatedOffset);\n    let _calculatedOffset = lineData.startOffset + stringIndexFromDisplayWidth;\n    let endOffsetOfLine = lineData.startOffset + lineData.text.length;\n    let endOffset = endOffsetOfLine;\n    let calculateOffsetFromPosition = k7(lineData.text);\n    if (lineData.endsWithNewline && getOffsetFromPosition.column > calculateOffsetFromPosition) {\n      endOffset = endOffsetOfLine + 1;\n    }\n    return Math.min(_calculatedOffset, endOffset);\n  }\n  getLineLength(getLineLength) {\n    let getLineObject = this.getLine(getLineLength);\n    return k7(getLineObject.text);\n  }\n  getPositionFromOffset(getPositionFromOffset) {\n    let wrappedLines = this.wrappedLines;\n    for (let _currentLineIndex = 0; _currentLineIndex < wrappedLines.length; _currentLineIndex++) {\n      let _currentLine = wrappedLines[_currentLineIndex];\n      let nextLine = wrappedLines[_currentLineIndex + 1];\n      if (getPositionFromOffset >= _currentLine.startOffset && (!nextLine || getPositionFromOffset < nextLine.startOffset)) {\n        let offsetFromStart = getPositionFromOffset - _currentLine.startOffset;\n        let displayWidth;\n        if (_currentLine.isPrecededByNewline) {\n          displayWidth = this.stringIndexToDisplayWidth(_currentLine.text, offsetFromStart);\n        } else {\n          let leadingWhitespaceLength = _currentLine.text.length - _currentLine.text.trimStart().length;\n          if (offsetFromStart < leadingWhitespaceLength) {\n            displayWidth = 0;\n          } else {\n            let trimmedText = _currentLine.text.trimStart();\n            let charIndexAfterWhitespace = offsetFromStart - leadingWhitespaceLength;\n            displayWidth = this.stringIndexToDisplayWidth(trimmedText, charIndexAfterWhitespace);\n          }\n        }\n        return {\n          line: _currentLineIndex,\n          column: Math.max(0, displayWidth)\n        };\n      }\n    }\n    let lastLineIndex = wrappedLines.length - 1;\n    let lastLine = this.wrappedLines[lastLineIndex];\n    return {\n      line: lastLineIndex,\n      column: k7(lastLine.text)\n    };\n  }\n  get lineCount() {\n    return this.wrappedLines.length;\n  }\n  withCache(withCacheAndGetValue, fetchNavigationData) {\n    let cachedNavigationResult = this.navigationCache.get(withCacheAndGetValue);\n    if (cachedNavigationResult !== undefined) {\n      return cachedNavigationResult;\n    }\n    let cachedResult = fetchNavigationData();\n    this.navigationCache.set(withCacheAndGetValue, cachedResult);\n    return cachedResult;\n  }\n  nextOffset(nextOffsetIndex) {\n    return this.withCache(`next:${nextOffsetIndex}`, () => {\n      let _graphemeBoundaries = this.getGraphemeBoundaries();\n      return this.binarySearchBoundary(_graphemeBoundaries, nextOffsetIndex, true);\n    });\n  }\n  prevOffset(getPreviousOffset) {\n    if (getPreviousOffset <= 0) {\n      return 0;\n    }\n    return this.withCache(`prev:${getPreviousOffset}`, () => {\n      let graphemeBoundaries = this.getGraphemeBoundaries();\n      return this.binarySearchBoundary(graphemeBoundaries, getPreviousOffset, false);\n    });\n  }\n}\nvar initializeRenderTree;\nvar initializeRenderingProcess = T(() => {\n  bZ1();\n  F0A();\n  initializeRenderTree = new Intl.Segmenter(undefined, {\n    granularity: \"grapheme\"\n  });\n});\nvar _______initializeRenderer = z((validateDataTypes, validateInputExports) => {\n  function isDefinedAndNotNull(_isDefinedAndNotNull) {\n    return typeof _isDefinedAndNotNull !== \"undefined\" && _isDefinedAndNotNull !== null;\n  }\n  function _isObject(__isObject) {\n    return typeof __isObject === \"object\";\n  }\n  function isObjectType(isObject) {\n    return Object.prototype.toString.call(isObject) === \"[object Object]\";\n  }\n  function isFunction(_isFunction) {\n    return typeof _isFunction === \"function\";\n  }\n  function isBoolean(_isBoolean) {\n    return typeof _isBoolean === \"boolean\";\n  }\n  function isBufferInstance(_isBufferInstance) {\n    return _isBufferInstance instanceof Buffer;\n  }\n  function isTypedArray(isArrayBufferType) {\n    if (isDefinedAndNotNull(isArrayBufferType)) {\n      switch (isArrayBufferType.constructor) {\n        case Uint8Array:\n        case Uint8ClampedArray:\n        case Int8Array:\n        case Uint16Array:\n        case Int16Array:\n        case Uint32Array:\n        case Int32Array:\n        case Float32Array:\n        case Float64Array:\n          return true;\n      }\n    }\n    return false;\n  }\n  function isArrayBuffer(_isArrayBuffer) {\n    return _isArrayBuffer instanceof ArrayBuffer;\n  }\n  function isNonEmptyString(_isNonEmptyString) {\n    return typeof _isNonEmptyString === \"string\" && _isNonEmptyString.length > 0;\n  }\n  function isValidNumber(_isValidNumber) {\n    return typeof _isValidNumber === \"number\" && !Number.isNaN(_isValidNumber);\n  }\n  function isInteger(numberIsInteger) {\n    return Number.isInteger(numberIsInteger);\n  }\n  function isWithinRange(_isWithinRange, upperBoundCheck, upperLimit) {\n    return _isWithinRange >= upperBoundCheck && _isWithinRange <= upperLimit;\n  }\n  function isElementInArray(elementExistsInArray, elementToCheck) {\n    return elementToCheck.includes(elementExistsInArray);\n  }\n  function generateTypeErrorMessage(createErrorMessage, expectedValue, actualValue) {\n    return Error(`Expected ${expectedValue} for ${createErrorMessage} but received ${actualValue} of type ${typeof actualValue}`);\n  }\n  function copyMessage(_copyMessage, updateMessage) {\n    updateMessage.message = _copyMessage.message;\n    return updateMessage;\n  }\n  validateInputExports.exports = {\n    defined: isDefinedAndNotNull,\n    object: _isObject,\n    plainObject: isObjectType,\n    fn: isFunction,\n    bool: isBoolean,\n    buffer: isBufferInstance,\n    typedArray: isTypedArray,\n    arrayBuffer: isArrayBuffer,\n    string: isNonEmptyString,\n    number: isValidNumber,\n    integer: isInteger,\n    inRange: isWithinRange,\n    inArray: isElementInArray,\n    invalidParameterError: generateTypeErrorMessage,\n    nativeError: copyMessage\n  };\n});\nvar ___________________initializeDevTools = z((initializePlatformReport, _moduleExports) => {\n  var isLinuxPlatform = () => process.platform === \"linux\";\n  var cachedProcessReport = null;\n  var _getCachedProcessReport = () => {\n    if (!cachedProcessReport) {\n      if (isLinuxPlatform() && process.report) {\n        let originalNetworkExclusionValue = process.report.excludeNetwork;\n        process.report.excludeNetwork = true;\n        cachedProcessReport = process.report.getReport();\n        process.report.excludeNetwork = originalNetworkExclusionValue;\n      } else {\n        cachedProcessReport = {};\n      }\n    }\n    return cachedProcessReport;\n  };\n  _moduleExports.exports = {\n    isLinux: isLinuxPlatform,\n    getReport: _getCachedProcessReport\n  };\n});\nvar ____________________________initializeDevToolsConnection = z((moduleSetup, initializeFileSystemModule) => {\n  var fileSystemModule = EA(\"fs\");\n  var _readFileSync = _filePath => fileSystemModule.readFileSync(_filePath, \"utf-8\");\n  var readFileAsync = readFileContentPromise => new Promise((handleFileReadError, processFileContent) => {\n    fileSystemModule.readFile(readFileContentPromise, \"utf-8\", (______inputValue, guardCondition) => {\n      if (______inputValue) {\n        processFileContent(______inputValue);\n      } else {\n        handleFileReadError(guardCondition);\n      }\n    });\n  });\n  initializeFileSystemModule.exports = {\n    LDD_PATH: \"/usr/bin/ldd\",\n    readFileSync: _readFileSync,\n    readFile: readFileAsync\n  };\n});\nvar appendChildToYogaNode = z((detectLinuxLibc, initializeLinuxLibraryInfo) => {\n  var childProcessModule = EA(\"child_process\");\n  var {\n    isLinux: isLinuxOperatingSystem,\n    getReport: getLinuxLibraryInfo\n  } = ___________________initializeDevTools();\n  var {\n    LDD_PATH: lddPath,\n    readFile: readFileFromFilePath,\n    readFileSync: readFileSync\n  } = ____________________________initializeDevToolsConnection();\n  var libcDetectionCache;\n  var glibcVersion;\n  var glibcVersionInfo = \"\";\n  var _fetchGlibcVersionInfo = () => {\n    if (!glibcVersionInfo) {\n      return new Promise(fetchGlibcVersion => {\n        childProcessModule.exec(\"getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true\", (isGlibcVersionAvailable, _glibcVersion) => {\n          if (isGlibcVersionAvailable) {\n            glibcVersionInfo = \" \";\n          } else {\n            glibcVersionInfo = _glibcVersion;\n          }\n          fetchGlibcVersion(glibcVersionInfo);\n        });\n      });\n    }\n    return glibcVersionInfo;\n  };\n  var _getGlibcVersionSync = () => {\n    if (!glibcVersionInfo) {\n      try {\n        glibcVersionInfo = childProcessModule.execSync(\"getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true\", {\n          encoding: \"utf8\"\n        });\n      } catch (____error) {\n        glibcVersionInfo = \" \";\n      }\n    }\n    return glibcVersionInfo;\n  };\n  var GLIBC_IDENTIFIER = \"glibc\";\n  var glibcVersionRegex = /LIBC[a-z0-9 \\-).]*?(\\d+\\.\\d+)/i;\n  var MUSL_LIBC = \"musl\";\n  var isMuslLibc = isUsingMuslLibrary => isUsingMuslLibrary.includes(\"libc.musl-\") || isUsingMuslLibrary.includes(\"ld-musl-\");\n  var detectLibraryImplementation = () => {\n    let linuxLibraryInfo = getLinuxLibraryInfo();\n    if (linuxLibraryInfo.header && linuxLibraryInfo.header.glibcVersionRuntime) {\n      return GLIBC_IDENTIFIER;\n    }\n    if (Array.isArray(linuxLibraryInfo.sharedObjects)) {\n      if (linuxLibraryInfo.sharedObjects.some(isMuslLibc)) {\n        return MUSL_LIBC;\n      }\n    }\n    return null;\n  };\n  var detectLibcImplementation = _detectLibcType => {\n    let [headerLine, secondLineContent] = _detectLibcType.split(/[\\r\\n]+/);\n    if (headerLine && headerLine.includes(GLIBC_IDENTIFIER)) {\n      return GLIBC_IDENTIFIER;\n    }\n    if (secondLineContent && secondLineContent.includes(MUSL_LIBC)) {\n      return MUSL_LIBC;\n    }\n    return null;\n  };\n  var detectLibcType = getLibcIdentifier => {\n    if (getLibcIdentifier.includes(\"musl\")) {\n      return MUSL_LIBC;\n    }\n    if (getLibcIdentifier.includes(\"GNU C Library\")) {\n      return GLIBC_IDENTIFIER;\n    }\n    return null;\n  };\n  var detectLibcImplementationAsync = async () => {\n    if (libcDetectionCache !== undefined) {\n      return libcDetectionCache;\n    }\n    libcDetectionCache = null;\n    try {\n      let fileData = await readFileFromFilePath(lddPath);\n      libcDetectionCache = detectLibcType(fileData);\n    } catch (___________error) {}\n    return libcDetectionCache;\n  };\n  var detectLibcVersionSync = () => {\n    if (libcDetectionCache !== undefined) {\n      return libcDetectionCache;\n    }\n    libcDetectionCache = null;\n    try {\n      let fileContents = readFileSync(lddPath);\n      libcDetectionCache = detectLibcType(fileContents);\n    } catch (____________error) {}\n    return libcDetectionCache;\n  };\n  var detectLibcFamilyAsync = async () => {\n    let _libcImplementation = null;\n    if (isLinuxOperatingSystem()) {\n      _libcImplementation = await detectLibcImplementationAsync();\n      if (!_libcImplementation) {\n        _libcImplementation = detectLibraryImplementation();\n      }\n      if (!_libcImplementation) {\n        let fetchedData = await _fetchGlibcVersionInfo();\n        _libcImplementation = detectLibcImplementation(fetchedData);\n      }\n    }\n    return _libcImplementation;\n  };\n  var getLibraryImplementationSync = () => {\n    let libraryImplementation = null;\n    if (isLinuxOperatingSystem()) {\n      libraryImplementation = detectLibcVersionSync();\n      if (!libraryImplementation) {\n        libraryImplementation = detectLibraryImplementation();\n      }\n      if (!libraryImplementation) {\n        let ___processData = _getGlibcVersionSync();\n        libraryImplementation = detectLibcImplementation(___processData);\n      }\n    }\n    return libraryImplementation;\n  };\n  var isNonGlibcLinuxAsync = async () => isLinuxOperatingSystem() && (await detectLibcFamilyAsync()) !== GLIBC_IDENTIFIER;\n  var isNonGlibcLinuxSync = () => isLinuxOperatingSystem() && getLibraryImplementationSync() !== GLIBC_IDENTIFIER;\n  var _fetchGlibcVersion = async () => {\n    if (glibcVersion !== undefined) {\n      return glibcVersion;\n    }\n    glibcVersion = null;\n    try {\n      let glibcVersionMatch = (await readFileFromFilePath(lddPath)).match(glibcVersionRegex);\n      if (glibcVersionMatch) {\n        glibcVersion = glibcVersionMatch[1];\n      }\n    } catch (_____________error) {}\n    return glibcVersion;\n  };\n  var getGlibcVersionSync = () => {\n    if (glibcVersion !== undefined) {\n      return glibcVersion;\n    }\n    glibcVersion = null;\n    try {\n      let matchedGlibcVersion = readFileSync(lddPath).match(glibcVersionRegex);\n      if (matchedGlibcVersion) {\n        glibcVersion = matchedGlibcVersion[1];\n      }\n    } catch (______________error) {}\n    return glibcVersion;\n  };\n  var getGlibcVersionRuntime = () => {\n    let _linuxLibraryInfo = getLinuxLibraryInfo();\n    if (_linuxLibraryInfo.header && _linuxLibraryInfo.header.glibcVersionRuntime) {\n      return _linuxLibraryInfo.header.glibcVersionRuntime;\n    }\n    return null;\n  };\n  var extractGlibcVersion = getSecondWordFromTrimmedString => getSecondWordFromTrimmedString.trim().split(/\\s+/)[1];\n  var extractGlibcVersionFromOutput = parseLibraryInfo => {\n    let [libcVersionLine, libraryIdentifier, inputReferenceLine] = parseLibraryInfo.split(/[\\r\\n]+/);\n    if (libcVersionLine && libcVersionLine.includes(GLIBC_IDENTIFIER)) {\n      return extractGlibcVersion(libcVersionLine);\n    }\n    if (libraryIdentifier && inputReferenceLine && libraryIdentifier.includes(MUSL_LIBC)) {\n      return extractGlibcVersion(inputReferenceLine);\n    }\n    return null;\n  };\n  var ___fetchGlibcVersion = async () => {\n    let ___glibcVersion = null;\n    if (isLinuxOperatingSystem()) {\n      ___glibcVersion = await _fetchGlibcVersion();\n      if (!___glibcVersion) {\n        ___glibcVersion = getGlibcVersionRuntime();\n      }\n      if (!___glibcVersion) {\n        let _fetchedData = await _fetchGlibcVersionInfo();\n        ___glibcVersion = extractGlibcVersionFromOutput(_fetchedData);\n      }\n    }\n    return ___glibcVersion;\n  };\n  var __getGlibcVersionSync = () => {\n    let __glibcVersion = null;\n    if (isLinuxOperatingSystem()) {\n      __glibcVersion = getGlibcVersionSync();\n      if (!__glibcVersion) {\n        __glibcVersion = getGlibcVersionRuntime();\n      }\n      if (!__glibcVersion) {\n        let _inputData = _getGlibcVersionSync();\n        __glibcVersion = extractGlibcVersionFromOutput(_inputData);\n      }\n    }\n    return __glibcVersion;\n  };\n  initializeLinuxLibraryInfo.exports = {\n    GLIBC: GLIBC_IDENTIFIER,\n    MUSL: MUSL_LIBC,\n    family: detectLibcFamilyAsync,\n    familySync: getLibraryImplementationSync,\n    isNonGlibcLinux: isNonGlibcLinuxAsync,\n    isNonGlibcLinuxSync: isNonGlibcLinuxSync,\n    version: ___fetchGlibcVersion,\n    versionSync: __getGlibcVersionSync\n  };\n});\nvar _handleDevToolsConnection = z((logSemverDebug, exportDebugLogger) => {\n  var _logSemverDebug = typeof process === \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...logSemanticVersioningErrors) => console.error(\"SEMVER\", ...logSemanticVersioningErrors) : () => {};\n  exportDebugLogger.exports = _logSemverDebug;\n});\nvar _____________________________initializeDevToolsConnection = z((initializeSemanticVersioning, semverConstants) => {\n  var MAX_SAFE_INTEGER_DEFINED = Number.MAX_SAFE_INTEGER || 9007199254740991;\n  var RELEASE_TYPES_ARRAY = [\"major\", \"premajor\", \"minor\", \"preminor\", \"patch\", \"prepatch\", \"prerelease\"];\n  semverConstants.exports = {\n    MAX_LENGTH: 256,\n    MAX_SAFE_COMPONENT_LENGTH: 16,\n    MAX_SAFE_BUILD_LENGTH: 250,\n    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER_DEFINED,\n    RELEASE_TYPES: RELEASE_TYPES_ARRAY,\n    SEMVER_SPEC_VERSION: \"2.0.0\",\n    FLAG_INCLUDE_PRERELEASE: 1,\n    FLAG_LOOSE: 2\n  };\n});\nvar ___________________________initializeDevTools = z((versionParser, initializeVersioningExports) => {\n  var {\n    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH,\n    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH,\n    MAX_LENGTH: MAX_SAFE_LENGTH\n  } = _____________________________initializeDevToolsConnection();\n  var __handleDevToolsConnection = _handleDevToolsConnection();\n  versionParser = initializeVersioningExports.exports = {};\n  var regexpArray = versionParser.re = [];\n  var safeRegExpCache = versionParser.safeRe = [];\n  var versionPatterns = versionParser.src = [];\n  var safeSourcePatterns = versionParser.safeSrc = [];\n  var _versionPatterns = versionParser.t = {};\n  var regexCounter = 0;\n  var ALPHANUMERIC_IDENTIFIER_PATTERN = \"[a-zA-Z0-9-]\";\n  var VERSION_IDENTIFIER_INCLUDE = [[\"\\\\s\", 1], [\"\\\\d\", MAX_SAFE_LENGTH], [ALPHANUMERIC_IDENTIFIER_PATTERN, MAX_SAFE_BUILD_LENGTH]];\n  var replacePatternWithMaxLength = generateRegexFromVersionIdentifiers => {\n    for (let [versionDelimiter, versionIdentifier] of VERSION_IDENTIFIER_INCLUDE) {\n      generateRegexFromVersionIdentifiers = generateRegexFromVersionIdentifiers.split(`${versionDelimiter}*`).join(`${versionDelimiter}{0,${versionIdentifier}}`).split(`${versionDelimiter}+`).join(`${versionDelimiter}{1,${versionIdentifier}}`);\n    }\n    return generateRegexFromVersionIdentifiers;\n  };\n  var defineVersionPattern = (handlePatternAndConnection, _pattern, isGlobalFlag) => {\n    let maxLengthPattern = replacePatternWithMaxLength(_pattern);\n    let _regexCounter = regexCounter++;\n    __handleDevToolsConnection(handlePatternAndConnection, _regexCounter, _pattern);\n    _versionPatterns[handlePatternAndConnection] = _regexCounter;\n    versionPatterns[_regexCounter] = _pattern;\n    safeSourcePatterns[_regexCounter] = maxLengthPattern;\n    regexpArray[_regexCounter] = new RegExp(_pattern, isGlobalFlag ? \"g\" : undefined);\n    safeRegExpCache[_regexCounter] = new RegExp(maxLengthPattern, isGlobalFlag ? \"g\" : undefined);\n  };\n  defineVersionPattern(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\");\n  defineVersionPattern(\"NUMERICIDENTIFIERLOOSE\", \"\\\\d+\");\n  defineVersionPattern(\"NONNUMERICIDENTIFIER\", `\\\\d*[a-zA-Z-]${ALPHANUMERIC_IDENTIFIER_PATTERN}*`);\n  defineVersionPattern(\"MAINVERSION\", `(${versionPatterns[_versionPatterns.NUMERICIDENTIFIER]})\\\\.(${versionPatterns[_versionPatterns.NUMERICIDENTIFIER]})\\\\.(${versionPatterns[_versionPatterns.NUMERICIDENTIFIER]})`);\n  defineVersionPattern(\"MAINVERSIONLOOSE\", `(${versionPatterns[_versionPatterns.NUMERICIDENTIFIERLOOSE]})\\\\.(${versionPatterns[_versionPatterns.NUMERICIDENTIFIERLOOSE]})\\\\.(${versionPatterns[_versionPatterns.NUMERICIDENTIFIERLOOSE]})`);\n  defineVersionPattern(\"PRERELEASEIDENTIFIER\", `(?:${versionPatterns[_versionPatterns.NUMERICIDENTIFIER]}|${versionPatterns[_versionPatterns.NONNUMERICIDENTIFIER]})`);\n  defineVersionPattern(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${versionPatterns[_versionPatterns.NUMERICIDENTIFIERLOOSE]}|${versionPatterns[_versionPatterns.NONNUMERICIDENTIFIER]})`);\n  defineVersionPattern(\"PRERELEASE\", `(?:-(${versionPatterns[_versionPatterns.PRERELEASEIDENTIFIER]}(?:\\\\.${versionPatterns[_versionPatterns.PRERELEASEIDENTIFIER]})*))`);\n  defineVersionPattern(\"PRERELEASELOOSE\", `(?:-?(${versionPatterns[_versionPatterns.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${versionPatterns[_versionPatterns.PRERELEASEIDENTIFIERLOOSE]})*))`);\n  defineVersionPattern(\"BUILDIDENTIFIER\", `${ALPHANUMERIC_IDENTIFIER_PATTERN}+`);\n  defineVersionPattern(\"BUILD\", `(?:\\\\+(${versionPatterns[_versionPatterns.BUILDIDENTIFIER]}(?:\\\\.${versionPatterns[_versionPatterns.BUILDIDENTIFIER]})*))`);\n  defineVersionPattern(\"FULLPLAIN\", `v?${versionPatterns[_versionPatterns.MAINVERSION]}${versionPatterns[_versionPatterns.PRERELEASE]}?${versionPatterns[_versionPatterns.BUILD]}?`);\n  defineVersionPattern(\"FULL\", `^${versionPatterns[_versionPatterns.FULLPLAIN]}$`);\n  defineVersionPattern(\"LOOSEPLAIN\", `[v=\\\\s]*${versionPatterns[_versionPatterns.MAINVERSIONLOOSE]}${versionPatterns[_versionPatterns.PRERELEASELOOSE]}?${versionPatterns[_versionPatterns.BUILD]}?`);\n  defineVersionPattern(\"LOOSE\", `^${versionPatterns[_versionPatterns.LOOSEPLAIN]}$`);\n  defineVersionPattern(\"GTLT\", \"((?:<|>)?=?)\");\n  defineVersionPattern(\"XRANGEIDENTIFIERLOOSE\", `${versionPatterns[_versionPatterns.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n  defineVersionPattern(\"XRANGEIDENTIFIER\", `${versionPatterns[_versionPatterns.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n  defineVersionPattern(\"XRANGEPLAIN\", `[v=\\\\s]*(${versionPatterns[_versionPatterns.XRANGEIDENTIFIER]})(?:\\\\.(${versionPatterns[_versionPatterns.XRANGEIDENTIFIER]})(?:\\\\.(${versionPatterns[_versionPatterns.XRANGEIDENTIFIER]})(?:${versionPatterns[_versionPatterns.PRERELEASE]})?${versionPatterns[_versionPatterns.BUILD]}?)?)?`);\n  defineVersionPattern(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${versionPatterns[_versionPatterns.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${versionPatterns[_versionPatterns.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${versionPatterns[_versionPatterns.XRANGEIDENTIFIERLOOSE]})(?:${versionPatterns[_versionPatterns.PRERELEASELOOSE]})?${versionPatterns[_versionPatterns.BUILD]}?)?)?`);\n  defineVersionPattern(\"XRANGE\", `^${versionPatterns[_versionPatterns.GTLT]}\\\\s*${versionPatterns[_versionPatterns.XRANGEPLAIN]}$`);\n  defineVersionPattern(\"XRANGELOOSE\", `^${versionPatterns[_versionPatterns.GTLT]}\\\\s*${versionPatterns[_versionPatterns.XRANGEPLAINLOOSE]}$`);\n  defineVersionPattern(\"COERCEPLAIN\", `(^|[^\\\\d])(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);\n  defineVersionPattern(\"COERCE\", `${versionPatterns[_versionPatterns.COERCEPLAIN]}(?:$|[^\\\\d])`);\n  defineVersionPattern(\"COERCEFULL\", `${versionPatterns[_versionPatterns.COERCEPLAIN]}(?:${versionPatterns[_versionPatterns.PRERELEASE]})?(?:${versionPatterns[_versionPatterns.BUILD]})?(?:$|[^\\\\d])`);\n  defineVersionPattern(\"COERCERTL\", versionPatterns[_versionPatterns.COERCE], true);\n  defineVersionPattern(\"COERCERTLFULL\", versionPatterns[_versionPatterns.COERCEFULL], true);\n  defineVersionPattern(\"LONETILDE\", \"(?:~>?)\");\n  defineVersionPattern(\"TILDETRIM\", `(\\\\s*)${versionPatterns[_versionPatterns.LONETILDE]}\\\\s+`, true);\n  versionParser.tildeTrimReplace = \"$1~\";\n  defineVersionPattern(\"TILDE\", `^${versionPatterns[_versionPatterns.LONETILDE]}${versionPatterns[_versionPatterns.XRANGEPLAIN]}$`);\n  defineVersionPattern(\"TILDELOOSE\", `^${versionPatterns[_versionPatterns.LONETILDE]}${versionPatterns[_versionPatterns.XRANGEPLAINLOOSE]}$`);\n  defineVersionPattern(\"LONECARET\", \"(?:\\\\^)\");\n  defineVersionPattern(\"CARETTRIM\", `(\\\\s*)${versionPatterns[_versionPatterns.LONECARET]}\\\\s+`, true);\n  versionParser.caretTrimReplace = \"$1^\";\n  defineVersionPattern(\"CARET\", `^${versionPatterns[_versionPatterns.LONECARET]}${versionPatterns[_versionPatterns.XRANGEPLAIN]}$`);\n  defineVersionPattern(\"CARETLOOSE\", `^${versionPatterns[_versionPatterns.LONECARET]}${versionPatterns[_versionPatterns.XRANGEPLAINLOOSE]}$`);\n  defineVersionPattern(\"COMPARATORLOOSE\", `^${versionPatterns[_versionPatterns.GTLT]}\\\\s*(${versionPatterns[_versionPatterns.LOOSEPLAIN]})$|^$`);\n  defineVersionPattern(\"COMPARATOR\", `^${versionPatterns[_versionPatterns.GTLT]}\\\\s*(${versionPatterns[_versionPatterns.FULLPLAIN]})$|^$`);\n  defineVersionPattern(\"COMPARATORTRIM\", `(\\\\s*)${versionPatterns[_versionPatterns.GTLT]}\\\\s*(${versionPatterns[_versionPatterns.LOOSEPLAIN]}|${versionPatterns[_versionPatterns.XRANGEPLAIN]})`, true);\n  versionParser.comparatorTrimReplace = \"$1$2$3\";\n  defineVersionPattern(\"HYPHENRANGE\", `^\\\\s*(${versionPatterns[_versionPatterns.XRANGEPLAIN]})\\\\s+-\\\\s+(${versionPatterns[_versionPatterns.XRANGEPLAIN]})\\\\s*$`);\n  defineVersionPattern(\"HYPHENRANGELOOSE\", `^\\\\s*(${versionPatterns[_versionPatterns.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${versionPatterns[_versionPatterns.XRANGEPLAINLOOSE]})\\\\s*$`);\n  defineVersionPattern(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\");\n  defineVersionPattern(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\");\n  defineVersionPattern(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n});\nvar ________initializeRenderer = z((handleInputValidation, exportConfiguredFunction) => {\n  var defaultBehaviorConfig = Object.freeze({\n    loose: true\n  });\n  var defaultEmptyObject = Object.freeze({});\n  var validateInputOrReturnDefault = getOrDefaultConfig => {\n    if (!getOrDefaultConfig) {\n      return defaultEmptyObject;\n    }\n    if (typeof getOrDefaultConfig !== \"object\") {\n      return defaultBehaviorConfig;\n    }\n    return getOrDefaultConfig;\n  };\n  exportConfiguredFunction.exports = validateInputOrReturnDefault;\n});\nvar __initializeReactDevTools = z((compareNumericOrStringIdentifiers, compareNumericIdentifiers) => {\n  var numericRegex = /^[0-9]+$/;\n  var compareIdentifiers = (compareNumericStrings, compareNumericValues) => {\n    let isStringNumeric = numericRegex.test(compareNumericStrings);\n    let isNumericValue = numericRegex.test(compareNumericValues);\n    if (isStringNumeric && isNumericValue) {\n      compareNumericStrings = +compareNumericStrings;\n      compareNumericValues = +compareNumericValues;\n    }\n    if (compareNumericStrings === compareNumericValues) {\n      return 0;\n    } else if (isStringNumeric && !isNumericValue) {\n      return -1;\n    } else if (isNumericValue && !isStringNumeric) {\n      return 1;\n    } else if (compareNumericStrings < compareNumericValues) {\n      return -1;\n    } else {\n      return 1;\n    }\n  };\n  var reverseCompareIdentifiers = (compareIdentifiersDescending, compareIdentifiersByName) => compareIdentifiers(compareIdentifiersByName, compareIdentifiersDescending);\n  compareNumericIdentifiers.exports = {\n    compareIdentifiers: compareIdentifiers,\n    rcompareIdentifiers: reverseCompareIdentifiers\n  };\n});\nvar ____initializeReactDevToolsConnection = z((createSemanticVersion, SemVer) => {\n  var _____________________________initializeDevTools = _handleDevToolsConnection();\n  var {\n    MAX_LENGTH: MAX_VERSION_LENGTH,\n    MAX_SAFE_INTEGER: maxSafeInteger\n  } = _____________________________initializeDevToolsConnection();\n  var {\n    safeRe: safeRegex,\n    safeSrc: safeRegExPatterns,\n    t: _versionParser\n  } = ___________________________initializeDevTools();\n  var initializeSemanticVersion = ________initializeRenderer();\n  var {\n    compareIdentifiers: compareVersions\n  } = __initializeReactDevTools();\n  class SM {\n    constructor(versionOrInstance, B) {\n      B = initializeSemanticVersion(B);\n      if (versionOrInstance instanceof SM) {\n        if (versionOrInstance.loose === !!B.loose && versionOrInstance.includePrerelease === !!B.includePrerelease) {\n          return versionOrInstance;\n        } else {\n          versionOrInstance = versionOrInstance.version;\n        }\n      } else if (typeof versionOrInstance !== \"string\") {\n        throw TypeError(`Invalid version. Must be a string. Got type \"${typeof versionOrInstance}\".`);\n      }\n      if (versionOrInstance.length > MAX_VERSION_LENGTH) {\n        throw TypeError(`version is longer than ${MAX_VERSION_LENGTH} characters`);\n      }\n      _____________________________initializeDevTools(\"SemVer\", versionOrInstance, B);\n      this.options = B;\n      this.loose = !!B.loose;\n      this.includePrerelease = !!B.includePrerelease;\n      let Q = versionOrInstance.trim().match(B.loose ? safeRegex[_versionParser.LOOSE] : safeRegex[_versionParser.FULL]);\n      if (!Q) {\n        throw TypeError(`Invalid Version: ${versionOrInstance}`);\n      }\n      this.raw = versionOrInstance;\n      this.major = +Q[1];\n      this.minor = +Q[2];\n      this.patch = +Q[3];\n      if (this.major > maxSafeInteger || this.major < 0) {\n        throw TypeError(\"Invalid major version\");\n      }\n      if (this.minor > maxSafeInteger || this.minor < 0) {\n        throw TypeError(\"Invalid minor version\");\n      }\n      if (this.patch > maxSafeInteger || this.patch < 0) {\n        throw TypeError(\"Invalid patch version\");\n      }\n      if (!Q[4]) {\n        this.prerelease = [];\n      } else {\n        this.prerelease = Q[4].split(\".\").map(_inputValue => {\n          if (/^[0-9]+$/.test(_inputValue)) {\n            let parsedInteger = +_inputValue;\n            if (parsedInteger >= 0 && parsedInteger < maxSafeInteger) {\n              return parsedInteger;\n            }\n          }\n          return _inputValue;\n        });\n      }\n      this.build = Q[5] ? Q[5].split(\".\") : [];\n      this.format();\n    }\n    format() {\n      this.version = `${this.major}.${this.minor}.${this.patch}`;\n      if (this.prerelease.length) {\n        this.version += `-${this.prerelease.join(\".\")}`;\n      }\n      return this.version;\n    }\n    toString() {\n      return this.version;\n    }\n    compare(versionToCompare) {\n      _____________________________initializeDevTools(\"SemVer.compare\", this.version, this.options, versionToCompare);\n      if (!(versionToCompare instanceof SM)) {\n        if (typeof versionToCompare === \"string\" && versionToCompare === this.version) {\n          return 0;\n        }\n        versionToCompare = new SM(versionToCompare, this.options);\n      }\n      if (versionToCompare.version === this.version) {\n        return 0;\n      }\n      return this.compareMain(versionToCompare) || this.comparePre(versionToCompare);\n    }\n    compareMain(compareSemanticVersion) {\n      if (!(compareSemanticVersion instanceof SM)) {\n        compareSemanticVersion = new SM(compareSemanticVersion, this.options);\n      }\n      return compareVersions(this.major, compareSemanticVersion.major) || compareVersions(this.minor, compareSemanticVersion.minor) || compareVersions(this.patch, compareSemanticVersion.patch);\n    }\n    comparePre(A) {\n      if (!(A instanceof SM)) {\n        A = new SM(A, this.options);\n      }\n      if (this.prerelease.length && !A.prerelease.length) {\n        return -1;\n      } else if (!this.prerelease.length && A.prerelease.length) {\n        return 1;\n      } else if (!this.prerelease.length && !A.prerelease.length) {\n        return 0;\n      }\n      let prereleaseComparisonIndex = 0;\n      do {\n        let prereleaseElement = this.prerelease[prereleaseComparisonIndex];\n        let prereleaseItem = A.prerelease[prereleaseComparisonIndex];\n        _____________________________initializeDevTools(\"prerelease compare\", prereleaseComparisonIndex, prereleaseElement, prereleaseItem);\n        if (prereleaseElement === undefined && prereleaseItem === undefined) {\n          return 0;\n        } else if (prereleaseItem === undefined) {\n          return 1;\n        } else if (prereleaseElement === undefined) {\n          return -1;\n        } else if (prereleaseElement === prereleaseItem) {\n          continue;\n        } else {\n          return compareVersions(prereleaseElement, prereleaseItem);\n        }\n      } while (++prereleaseComparisonIndex);\n    }\n    compareBuild(compareBuildComponents) {\n      if (!(compareBuildComponents instanceof SM)) {\n        compareBuildComponents = new SM(compareBuildComponents, this.options);\n      }\n      let buildIndex = 0;\n      do {\n        let currentBuildComponent = this.build[buildIndex];\n        let currentBuild = compareBuildComponents.build[buildIndex];\n        _____________________________initializeDevTools(\"build compare\", buildIndex, currentBuildComponent, currentBuild);\n        if (currentBuildComponent === undefined && currentBuild === undefined) {\n          return 0;\n        } else if (currentBuild === undefined) {\n          return 1;\n        } else if (currentBuildComponent === undefined) {\n          return -1;\n        } else if (currentBuildComponent === currentBuild) {\n          continue;\n        } else {\n          return compareVersions(currentBuildComponent, currentBuild);\n        }\n      } while (++buildIndex);\n    }\n    inc(A, identifier, Q) {\n      if (A.startsWith(\"pre\")) {\n        if (!identifier && Q === false) {\n          throw Error(\"invalid increment argument: identifier is empty\");\n        }\n        if (identifier) {\n          let preReleaseRegex = new RegExp(`^${this.options.loose ? safeRegExPatterns[_versionParser.PRERELEASELOOSE] : safeRegExPatterns[_versionParser.PRERELEASE]}$`);\n          let matchedIdentifier = `-${identifier}`.match(preReleaseRegex);\n          if (!matchedIdentifier || matchedIdentifier[1] !== identifier) {\n            throw Error(`invalid identifier: ${identifier}`);\n          }\n        }\n      }\n      switch (A) {\n        case \"premajor\":\n          this.prerelease.length = 0;\n          this.patch = 0;\n          this.minor = 0;\n          this.major++;\n          this.inc(\"pre\", identifier, Q);\n          break;\n        case \"preminor\":\n          this.prerelease.length = 0;\n          this.patch = 0;\n          this.minor++;\n          this.inc(\"pre\", identifier, Q);\n          break;\n        case \"prepatch\":\n          this.prerelease.length = 0;\n          this.inc(\"patch\", identifier, Q);\n          this.inc(\"pre\", identifier, Q);\n          break;\n        case \"prerelease\":\n          if (this.prerelease.length === 0) {\n            this.inc(\"patch\", identifier, Q);\n          }\n          this.inc(\"pre\", identifier, Q);\n          break;\n        case \"release\":\n          if (this.prerelease.length === 0) {\n            throw Error(`version ${this.raw} is not a prerelease`);\n          }\n          this.prerelease.length = 0;\n          break;\n        case \"major\":\n          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n            this.major++;\n          }\n          this.minor = 0;\n          this.patch = 0;\n          this.prerelease = [];\n          break;\n        case \"minor\":\n          if (this.patch !== 0 || this.prerelease.length === 0) {\n            this.minor++;\n          }\n          this.patch = 0;\n          this.prerelease = [];\n          break;\n        case \"patch\":\n          if (this.prerelease.length === 0) {\n            this.patch++;\n          }\n          this.prerelease = [];\n          break;\n        case \"pre\":\n          {\n            let regexPattern = Number(Q) ? 1 : 0;\n            if (this.prerelease.length === 0) {\n              this.prerelease = [regexPattern];\n            } else {\n              let __matchedIdentifier = this.prerelease.length;\n              while (--__matchedIdentifier >= 0) {\n                if (typeof this.prerelease[__matchedIdentifier] === \"number\") {\n                  this.prerelease[__matchedIdentifier]++;\n                  __matchedIdentifier = -2;\n                }\n              }\n              if (__matchedIdentifier === -1) {\n                if (identifier === this.prerelease.join(\".\") && Q === false) {\n                  throw Error(\"invalid increment argument: identifier already exists\");\n                }\n                this.prerelease.push(regexPattern);\n              }\n            }\n            if (identifier) {\n              let ____matchedIdentifier = [identifier, regexPattern];\n              if (Q === false) {\n                ____matchedIdentifier = [identifier];\n              }\n              if (compareVersions(this.prerelease[0], identifier) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = ____matchedIdentifier;\n                }\n              } else {\n                this.prerelease = ____matchedIdentifier;\n              }\n            }\n            break;\n          }\n        default:\n          throw Error(`invalid increment argument: ${A}`);\n      }\n      this.raw = this.format();\n      if (this.build.length) {\n        this.raw += `+${this.build.join(\".\")}`;\n      }\n      return this;\n    }\n  }\n  SemVer.exports = SM;\n});\nvar ______initializeReactDevToolsConnection = z((createInstance, _createInstance) => {\n  var ReactDevToolsConnection = ____initializeReactDevToolsConnection();\n  var createReactDevToolsInstance = (createReactDevToolsConnection, connectionOptions, shouldThrowError = false) => {\n    if (createReactDevToolsConnection instanceof ReactDevToolsConnection) {\n      return createReactDevToolsConnection;\n    }\n    try {\n      return new ReactDevToolsConnection(createReactDevToolsConnection, connectionOptions);\n    } catch (errorCaught) {\n      if (!shouldThrowError) {\n        return null;\n      }\n      throw errorCaught;\n    }\n  };\n  _createInstance.exports = createReactDevToolsInstance;\n});\nvar _initializeDevelopmentToolsConnection = z((parseVersion, parseVersionString) => {\n  var _______initializeReactDevToolsConnection = ____initializeReactDevToolsConnection();\n  var _______________________________________________________________initializeDevToolsConnection = ______initializeReactDevToolsConnection();\n  var {\n    safeRe: versionPatternRegex,\n    t: versionParseMethod\n  } = ___________________________initializeDevTools();\n  var _parseVersion = (parseVersionAndInitializeConnection, ________options) => {\n    if (parseVersionAndInitializeConnection instanceof _______initializeReactDevToolsConnection) {\n      return parseVersionAndInitializeConnection;\n    }\n    if (typeof parseVersionAndInitializeConnection === \"number\") {\n      parseVersionAndInitializeConnection = String(parseVersionAndInitializeConnection);\n    }\n    if (typeof parseVersionAndInitializeConnection !== \"string\") {\n      return null;\n    }\n    ________options = ________options || {};\n    let matchedPattern = null;\n    if (!________options.rtl) {\n      matchedPattern = parseVersionAndInitializeConnection.match(________options.includePrerelease ? versionPatternRegex[versionParseMethod.COERCEFULL] : versionPatternRegex[versionParseMethod.COERCE]);\n    } else {\n      let __regexPattern = ________options.includePrerelease ? versionPatternRegex[versionParseMethod.COERCERTLFULL] : versionPatternRegex[versionParseMethod.COERCERTL];\n      let regexMatch;\n      while ((regexMatch = __regexPattern.exec(parseVersionAndInitializeConnection)) && (!matchedPattern || matchedPattern.index + matchedPattern[0].length !== parseVersionAndInitializeConnection.length)) {\n        if (!matchedPattern || regexMatch.index + regexMatch[0].length !== matchedPattern.index + matchedPattern[0].length) {\n          matchedPattern = regexMatch;\n        }\n        __regexPattern.lastIndex = regexMatch.index + regexMatch[1].length + regexMatch[2].length;\n      }\n      __regexPattern.lastIndex = -1;\n    }\n    if (matchedPattern === null) {\n      return null;\n    }\n    let _____patchVersion = matchedPattern[2];\n    let ______patchVersion = matchedPattern[3] || \"0\";\n    let _______patchVersion = matchedPattern[4] || \"0\";\n    let _prereleaseSuffix = ________options.includePrerelease && matchedPattern[5] ? `-${matchedPattern[5]}` : \"\";\n    let metadataSuffix = ________options.includePrerelease && matchedPattern[6] ? `+${matchedPattern[6]}` : \"\";\n    return _______________________________________________________________initializeDevToolsConnection(`${_____patchVersion}.${______patchVersion}.${_______patchVersion}${_prereleaseSuffix}${metadataSuffix}`, ________options);\n  };\n  parseVersionString.exports = _parseVersion;\n});\nvar _____________________________________________________initializeDevToolsConnection = z((compareValuesBasedOnCriteria, compareNumbers) => {\n  var ________initializeReactDevToolsConnection = ____initializeReactDevToolsConnection();\n  var _compareValues = (reactDevToolsConnectionInitializer, reactDevToolsConnection, _ReactDevToolsConnection) => new ________initializeReactDevToolsConnection(reactDevToolsConnectionInitializer, _ReactDevToolsConnection).compare(new ________initializeReactDevToolsConnection(reactDevToolsConnection, _ReactDevToolsConnection));\n  compareNumbers.exports = _compareValues;\n});\nvar ____________initializeReactDevToolsConnection = z((isConditionMet, isValueNonNegative) => {\n  var __________________________________________________________________initializeDevToolsConnection = _____________________________________________________initializeDevToolsConnection();\n  var isDevToolsConnectionSuccessful = (_____________________________________________________________________________initializeDevToolsConnection, ______________________________________________________________________________initializeDevToolsConnection, initializeDevToolsConnectionAndCheck) => __________________________________________________________________initializeDevToolsConnection(_____________________________________________________________________________initializeDevToolsConnection, ______________________________________________________________________________initializeDevToolsConnection, initializeDevToolsConnectionAndCheck) >= 0;\n  isValueNonNegative.exports = isDevToolsConnectionSuccessful;\n});\nvar _initializeDebugTools = z((createLRUCache, CacheManager) => {\n  class _CacheManager {\n    constructor() {\n      this.max = 1000;\n      this.map = new Map();\n    }\n    get(getItemFromMap) {\n      let cachedValue = this.map.get(getItemFromMap);\n      if (cachedValue === undefined) {\n        return;\n      } else {\n        this.map.delete(getItemFromMap);\n        this.map.set(getItemFromMap, cachedValue);\n        return cachedValue;\n      }\n    }\n    delete(deleteItem) {\n      return this.map.delete(deleteItem);\n    }\n    set(setKeyValuePair, _value) {\n      if (!this.delete(setKeyValuePair) && _value !== undefined) {\n        if (this.map.size >= this.max) {\n          let oldestKey = this.map.keys().next().value;\n          this.delete(oldestKey);\n        }\n        this.map.set(setKeyValuePair, _value);\n      }\n      return this;\n    }\n  }\n  CacheManager.exports = _CacheManager;\n});\nvar ____________________________________________________________initializeDevToolsConnection = z((isEqualToZero, compareValues) => {\n  var ________________________________________________________________initializeDevToolsConnection = _____________________________________________________initializeDevToolsConnection();\n  var _isEqualToZero = (_________________________________________________________________________initializeDevToolsConnection, __________________________________________________________________________initializeDevToolsConnection, initializeDevToolsConnectionStatus) => ________________________________________________________________initializeDevToolsConnection(_________________________________________________________________________initializeDevToolsConnection, __________________________________________________________________________initializeDevToolsConnection, initializeDevToolsConnectionStatus) === 0;\n  compareValues.exports = _isEqualToZero;\n});\nvar _____________________________________________________________initializeDevToolsConnection = z((isNotEqualToZero, checkNonZero) => {\n  var _________________________________________________________________initializeDevToolsConnection = _____________________________________________________initializeDevToolsConnection();\n  var _isNotEqualToZero = (___________________________________________________________________________initializeDevToolsConnection, ____________________________________________________________________________initializeDevToolsConnection, _initializeDevToolsConnectionStatus) => _________________________________________________________________initializeDevToolsConnection(___________________________________________________________________________initializeDevToolsConnection, ____________________________________________________________________________initializeDevToolsConnection, _initializeDevToolsConnectionStatus) !== 0;\n  checkNonZero.exports = _isNotEqualToZero;\n});\nvar initializeAndConnectDevTools = z((isGreaterThanZero, checkConditionAndExport) => {\n  var initializeAndCheckGreaterThanZero = _____________________________________________________initializeDevToolsConnection();\n  var isValueGreaterThanZero = (isInitializedAndGreaterThanZero, initializeAndCheckGreaterThanZeroForB, _isInitializedAndGreaterThanZero) => initializeAndCheckGreaterThanZero(isInitializedAndGreaterThanZero, initializeAndCheckGreaterThanZeroForB, _isInitializedAndGreaterThanZero) > 0;\n  checkConditionAndExport.exports = isValueGreaterThanZero;\n});\nvar _____________initializeReactDevToolsConnection = z((isLessThan, isLessThanZero) => {\n  var ____________________________________________________________________initializeDevToolsConnection = _____________________________________________________initializeDevToolsConnection();\n  var isValueLessThanZero = (_________________________________________________________________________________initializeDevToolsConnection, _isDevToolsConnectionInitialized, _devToolsConnection) => ____________________________________________________________________initializeDevToolsConnection(_________________________________________________________________________________initializeDevToolsConnection, _isDevToolsConnectionInitialized, _devToolsConnection) < 0;\n  isLessThanZero.exports = isValueLessThanZero;\n});\nvar ______________________________________________________________initializeDevToolsConnection = z((isLessThanOrEqualToZero, isQueryResultNonPositive) => {\n  var ___________________________________________________________________initializeDevToolsConnection = _____________________________________________________initializeDevToolsConnection();\n  var isQueryResultLessThanOrEqualToZero = (checkDevToolsInitialization, _______________________________________________________________________________initializeDevToolsConnection, ________________________________________________________________________________initializeDevToolsConnection) => ___________________________________________________________________initializeDevToolsConnection(checkDevToolsInitialization, _______________________________________________________________________________initializeDevToolsConnection, ________________________________________________________________________________initializeDevToolsConnection) <= 0;\n  isQueryResultNonPositive.exports = isQueryResultLessThanOrEqualToZero;\n});\nvar _____________________________________________________________________initializeDevToolsConnection = z((compareValuesBasedOnOperator, exportComparisonFunction) => {\n  var _______________________________________________________________________initializeDevToolsConnection = ____________________________________________________________initializeDevToolsConnection();\n  var compareValuesUsingOperator = _____________________________________________________________initializeDevToolsConnection();\n  var compareValuesWithGreaterThan = initializeAndConnectDevTools();\n  var initializeReactDevToolsComparisonConnection = ____________initializeReactDevToolsConnection();\n  var compareValuesUsingLessThan = _____________initializeReactDevToolsConnection();\n  var initializeConnectionForLessThanOrEqual = ______________________________________________________________initializeDevToolsConnection();\n  var _compareValuesBasedOnOperator = (__compareValuesBasedOnOperator, _comparisonOperator, compareValueOrInitializeConnection, comparisonContext) => {\n    switch (_comparisonOperator) {\n      case \"===\":\n        if (typeof __compareValuesBasedOnOperator === \"object\") {\n          __compareValuesBasedOnOperator = __compareValuesBasedOnOperator.version;\n        }\n        if (typeof compareValueOrInitializeConnection === \"object\") {\n          compareValueOrInitializeConnection = compareValueOrInitializeConnection.version;\n        }\n        return __compareValuesBasedOnOperator === compareValueOrInitializeConnection;\n      case \"!==\":\n        if (typeof __compareValuesBasedOnOperator === \"object\") {\n          __compareValuesBasedOnOperator = __compareValuesBasedOnOperator.version;\n        }\n        if (typeof compareValueOrInitializeConnection === \"object\") {\n          compareValueOrInitializeConnection = compareValueOrInitializeConnection.version;\n        }\n        return __compareValuesBasedOnOperator !== compareValueOrInitializeConnection;\n      case \"\":\n      case \"=\":\n      case \"==\":\n        return _______________________________________________________________________initializeDevToolsConnection(__compareValuesBasedOnOperator, compareValueOrInitializeConnection, comparisonContext);\n      case \"!=\":\n        return compareValuesUsingOperator(__compareValuesBasedOnOperator, compareValueOrInitializeConnection, comparisonContext);\n      case \">\":\n        return compareValuesWithGreaterThan(__compareValuesBasedOnOperator, compareValueOrInitializeConnection, comparisonContext);\n      case \">=\":\n        return initializeReactDevToolsComparisonConnection(__compareValuesBasedOnOperator, compareValueOrInitializeConnection, comparisonContext);\n      case \"<\":\n        return compareValuesUsingLessThan(__compareValuesBasedOnOperator, compareValueOrInitializeConnection, comparisonContext);\n      case \"<=\":\n        return initializeConnectionForLessThanOrEqual(__compareValuesBasedOnOperator, compareValueOrInitializeConnection, comparisonContext);\n      default:\n        throw TypeError(`Invalid operator: ${_comparisonOperator}`);\n    }\n  };\n  exportComparisonFunction.exports = _compareValuesBasedOnOperator;\n});\nvar DJA = z((createComparator, Comparator) => {\n  var SEMVER_ANY_SYMBOL = Symbol(\"SemVer ANY\");\n  class BjA {\n    static get ANY() {\n      return SEMVER_ANY_SYMBOL;\n    }\n    constructor(versionOrComparator, rendererOptions) {\n      rendererOptions = ______________initializeRenderer(rendererOptions);\n      if (versionOrComparator instanceof BjA) {\n        if (versionOrComparator.loose === !!rendererOptions.loose) {\n          return versionOrComparator;\n        } else {\n          versionOrComparator = versionOrComparator.value;\n        }\n      }\n      versionOrComparator = versionOrComparator.trim().split(/\\s+/).join(\" \");\n      logDevToolConnection(\"comparator\", versionOrComparator, rendererOptions);\n      this.options = rendererOptions;\n      this.loose = !!rendererOptions.loose;\n      this.parse(versionOrComparator);\n      if (this.semver === SEMVER_ANY_SYMBOL) {\n        this.value = \"\";\n      } else {\n        this.value = this.operator + this.semver.version;\n      }\n      logDevToolConnection(\"comp\", this);\n    }\n    parse(parseComparator) {\n      let comparatorPattern = this.options.loose ? comparatorPatterns[DevToolsInitialization.COMPARATORLOOSE] : comparatorPatterns[DevToolsInitialization.COMPARATOR];\n      let matchedComparator = parseComparator.match(comparatorPattern);\n      if (!matchedComparator) {\n        throw TypeError(`Invalid comparator: ${parseComparator}`);\n      }\n      this.operator = matchedComparator[1] !== undefined ? matchedComparator[1] : \"\";\n      if (this.operator === \"=\") {\n        this.operator = \"\";\n      }\n      if (!matchedComparator[2]) {\n        this.semver = SEMVER_ANY_SYMBOL;\n      } else {\n        this.semver = new _SemVer(matchedComparator[2], this.options.loose);\n      }\n    }\n    toString() {\n      return this.value;\n    }\n    test(_versionToCompare) {\n      logDevToolConnection(\"Comparator.test\", _versionToCompare, this.options.loose);\n      if (this.semver === SEMVER_ANY_SYMBOL || _versionToCompare === SEMVER_ANY_SYMBOL) {\n        return true;\n      }\n      if (typeof _versionToCompare === \"string\") {\n        try {\n          _versionToCompare = new _SemVer(_versionToCompare, this.options);\n        } catch (__error) {\n          return false;\n        }\n      }\n      return compareSemver(_versionToCompare, this.operator, this.semver, this.options);\n    }\n    intersects(A, B) {\n      if (!(A instanceof BjA)) {\n        throw TypeError(\"a Comparator is required\");\n      }\n      if (this.operator === \"\") {\n        if (this.value === \"\") {\n          return true;\n        }\n        return new W_0(A.value, B).test(this.value);\n      } else if (A.operator === \"\") {\n        if (A.value === \"\") {\n          return true;\n        }\n        return new W_0(this.value, B).test(A.semver);\n      }\n      B = ______________initializeRenderer(B);\n      if (B.includePrerelease && (this.value === \"<0.0.0-0\" || A.value === \"<0.0.0-0\")) {\n        return false;\n      }\n      if (!B.includePrerelease && (this.value.startsWith(\"<0.0.0\") || A.value.startsWith(\"<0.0.0\"))) {\n        return false;\n      }\n      if (this.operator.startsWith(\">\") && A.operator.startsWith(\">\")) {\n        return true;\n      }\n      if (this.operator.startsWith(\"<\") && A.operator.startsWith(\"<\")) {\n        return true;\n      }\n      if (this.semver.version === A.semver.version && this.operator.includes(\"=\") && A.operator.includes(\"=\")) {\n        return true;\n      }\n      if (compareSemver(this.semver, \"<\", A.semver, B) && this.operator.startsWith(\">\") && A.operator.startsWith(\"<\")) {\n        return true;\n      }\n      if (compareSemver(this.semver, \">\", A.semver, B) && this.operator.startsWith(\"<\") && A.operator.startsWith(\">\")) {\n        return true;\n      }\n      return false;\n    }\n  }\n  Comparator.exports = BjA;\n  var ______________initializeRenderer = ________initializeRenderer();\n  var {\n    safeRe: comparatorPatterns,\n    t: DevToolsInitialization\n  } = ___________________________initializeDevTools();\n  var compareSemver = _____________________________________________________________________initializeDevToolsConnection();\n  var logDevToolConnection = _handleDevToolsConnection();\n  var _SemVer = ____initializeReactDevToolsConnection();\n  var W_0 = c$();\n});\nvar c$ = z((parseSemverRange, EjaExport) => {\n  var whitespacePattern = /\\s+/g;\n  class EJA {\n    constructor(A, B) {\n      B = ____________initializeRenderer(B);\n      if (A instanceof EJA) {\n        if (A.loose === !!B.loose && A.includePrerelease === !!B.includePrerelease) {\n          return A;\n        } else {\n          return new EJA(A.raw, B);\n        }\n      }\n      if (A instanceof JJ1) {\n        this.raw = A.value;\n        this.set = [[A]];\n        this.formatted = undefined;\n        return this;\n      }\n      this.options = B;\n      this.loose = !!B.loose;\n      this.includePrerelease = !!B.includePrerelease;\n      this.raw = A.trim().replace(whitespacePattern, \" \");\n      this.set = this.raw.split(\"||\").map(rangeString => this.parseRange(rangeString.trim())).filter(_arrayLength => _arrayLength.length);\n      if (!this.set.length) {\n        throw TypeError(`Invalid SemVer Range: ${this.raw}`);\n      }\n      if (this.set.length > 1) {\n        let rangeSegment = this.set[0];\n        this.set = this.set.filter(isReleaseVersion => !isPrereleaseVersion(isReleaseVersion[0]));\n        if (this.set.length === 0) {\n          this.set = [rangeSegment];\n        } else if (this.set.length > 1) {\n          for (let item of this.set) {\n            if (item.length === 1 && isEmptyVersion(item[0])) {\n              this.set = [item];\n              break;\n            }\n          }\n        }\n      }\n      this.formatted = undefined;\n    }\n    get range() {\n      if (this.formatted === undefined) {\n        this.formatted = \"\";\n        for (let ____index = 0; ____index < this.set.length; ____index++) {\n          if (____index > 0) {\n            this.formatted += \"||\";\n          }\n          let currentSetElement = this.set[____index];\n          for (let currentElementIndex = 0; currentElementIndex < currentSetElement.length; currentElementIndex++) {\n            if (currentElementIndex > 0) {\n              this.formatted += \" \";\n            }\n            this.formatted += currentSetElement[currentElementIndex].toString().trim();\n          }\n        }\n      }\n      return this.formatted;\n    }\n    format() {\n      return this.range;\n    }\n    toString() {\n      return this.range;\n    }\n    parseRange(A) {\n      let Q = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE_MODE)) + \":\" + A;\n      let I = debugToolsInstance.get(Q);\n      if (I) {\n        return I;\n      }\n      let G = this.options.loose;\n      let Z = G ? semverRegexPatterns[devToolFlags.HYPHENRANGELOOSE] : semverRegexPatterns[devToolFlags.HYPHENRANGE];\n      A = A.replace(Z, generateRangeString(this.options.includePrerelease));\n      logDebugInfo(\"hyphen replace\", A);\n      A = A.replace(semverRegexPatterns[devToolFlags.COMPARATORTRIM], comparatorTrimReplacement);\n      logDebugInfo(\"comparator trim\", A);\n      A = A.replace(semverRegexPatterns[devToolFlags.TILDETRIM], tildeTrimReplacePattern);\n      logDebugInfo(\"tilde trim\", A);\n      A = A.replace(semverRegexPatterns[devToolFlags.CARETTRIM], caretTrimReplace);\n      logDebugInfo(\"caret trim\", A);\n      let Y = A.split(\" \").map(queryParams9 => parseAndMapSemver(queryParams9, this.options)).join(\" \").split(/\\s+/).map(jsonParser => replaceGTE0(jsonParser, this.options));\n      if (G) {\n        Y = Y.filter(filterValidator => {\n          logDebugInfo(\"loose invalid filter\", filterValidator, this.options);\n          return !!filterValidator.match(semverRegexPatterns[devToolFlags.COMPARATORLOOSE]);\n        });\n      }\n      logDebugInfo(\"range list\", Y);\n      let J = new Map();\n      let X = Y.map(initializeJJ1 => new JJ1(initializeJJ1, this.options));\n      for (let _prereleaseItem of X) {\n        if (isPrereleaseVersion(_prereleaseItem)) {\n          return [_prereleaseItem];\n        }\n        J.set(_prereleaseItem.value, _prereleaseItem);\n      }\n      if (J.size > 1 && J.has(\"\")) {\n        J.delete(\"\");\n      }\n      let W = [...J.values()];\n      debugToolsInstance.set(Q, W);\n      return W;\n    }\n    intersects(rangeToCheck, boundingShape) {\n      if (!(rangeToCheck instanceof EJA)) {\n        throw TypeError(\"a Range is required\");\n      }\n      return this.set.some(isIntersectionValid => {\n        return checkIntersection(isIntersectionValid, boundingShape) && rangeToCheck.set.some(intersectionChecker => {\n          return checkIntersection(intersectionChecker, boundingShape) && isIntersectionValid.every(checkIntersections => {\n            return intersectionChecker.every(shapeToCheck => {\n              return checkIntersections.intersects(shapeToCheck, boundingShape);\n            });\n          });\n        });\n      });\n    }\n    test(validateSemver) {\n      if (!validateSemver) {\n        return false;\n      }\n      if (typeof validateSemver === \"string\") {\n        try {\n          validateSemver = new initializeSemver(validateSemver, this.options);\n        } catch (___error) {\n          return false;\n        }\n      }\n      for (let ____________index = 0; ____________index < this.set.length; ____________index++) {\n        if (yp9(this.set[____________index], validateSemver, this.options)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  EjaExport.exports = EJA;\n  var debugToolsInitializer = _initializeDebugTools();\n  var debugToolsInstance = new debugToolsInitializer();\n  var ____________initializeRenderer = ________initializeRenderer();\n  var JJ1 = DJA();\n  var logDebugInfo = _handleDevToolsConnection();\n  var initializeSemver = ____initializeReactDevToolsConnection();\n  var {\n    safeRe: semverRegexPatterns,\n    t: devToolFlags,\n    comparatorTrimReplace: comparatorTrimReplacement,\n    tildeTrimReplace: tildeTrimReplacePattern,\n    caretTrimReplace: caretTrimReplace\n  } = ___________________________initializeDevTools();\n  var {\n    FLAG_INCLUDE_PRERELEASE: FLAG_INCLUDE_PRERELEASE,\n    FLAG_LOOSE: FLAG_LOOSE_MODE\n  } = _____________________________initializeDevToolsConnection();\n  var isPrereleaseVersion = isVersionLessThanZero => isVersionLessThanZero.value === \"<0.0.0-0\";\n  var isEmptyVersion = isInputValueEmpty => isInputValueEmpty.value === \"\";\n  var checkIntersection = (isAllShapesIntersecting, checkAllShapesIntersecting) => {\n    let _isIntersectionValid = true;\n    let remainingShapes = isAllShapesIntersecting.slice();\n    let lastShape = remainingShapes.pop();\n    while (_isIntersectionValid && remainingShapes.length) {\n      _isIntersectionValid = remainingShapes.every(isShapeIntersecting => {\n        return lastShape.intersects(isShapeIntersecting, checkAllShapesIntersecting);\n      });\n      lastShape = remainingShapes.pop();\n    }\n    return _isIntersectionValid;\n  };\n  var parseAndMapSemver = (versionTransformer, __currentVersion) => {\n    logDebugInfo(\"comp\", versionTransformer, __currentVersion);\n    versionTransformer = mapSemverToCaretRange(versionTransformer, __currentVersion);\n    logDebugInfo(\"caret\", versionTransformer);\n    versionTransformer = parseTildeVersions(versionTransformer, __currentVersion);\n    logDebugInfo(\"tildes\", versionTransformer);\n    versionTransformer = replaceXRangesInVersion(versionTransformer, __currentVersion);\n    logDebugInfo(\"xrange\", versionTransformer);\n    versionTransformer = replaceWildcardVersions(versionTransformer, __currentVersion);\n    logDebugInfo(\"stars\", versionTransformer);\n    return versionTransformer;\n  };\n  var isWildcard = isValidInput => !isValidInput || isValidInput.toLowerCase() === \"x\" || isValidInput === \"*\";\n  var parseTildeVersions = (processVersionStrings, versioningStrategy) => {\n    return processVersionStrings.trim().split(/\\s+/).map(_parseTildeVersion => parseTildeVersion(_parseTildeVersion, versioningStrategy)).join(\" \");\n  };\n  var parseTildeVersion = (replaceTildeVersion, replaceTildeWithRange) => {\n    let tildeVersionRegex = replaceTildeWithRange.loose ? semverRegexPatterns[devToolFlags.TILDELOOSE] : semverRegexPatterns[devToolFlags.TILDE];\n    return replaceTildeVersion.replace(tildeVersionRegex, (_currentVersion, version, __patchVersion, patchVersionModifier, _preReleaseIdentifier) => {\n      logDebugInfo(\"tilde\", replaceTildeVersion, _currentVersion, version, __patchVersion, patchVersionModifier, _preReleaseIdentifier);\n      let ___versionRange;\n      if (isWildcard(version)) {\n        ___versionRange = \"\";\n      } else if (isWildcard(__patchVersion)) {\n        ___versionRange = `>=${version}.0.0 <${+version + 1}.0.0-0`;\n      } else if (isWildcard(patchVersionModifier)) {\n        ___versionRange = `>=${version}.${__patchVersion}.0 <${version}.${+__patchVersion + 1}.0-0`;\n      } else if (_preReleaseIdentifier) {\n        logDebugInfo(\"replaceTilde pr\", _preReleaseIdentifier);\n        ___versionRange = `>=${version}.${__patchVersion}.${patchVersionModifier}-${_preReleaseIdentifier} <${version}.${+__patchVersion + 1}.0-0`;\n      } else {\n        ___versionRange = `>=${version}.${__patchVersion}.${patchVersionModifier} <${version}.${+__patchVersion + 1}.0-0`;\n      }\n      logDebugInfo(\"tilde return\", ___versionRange);\n      return ___versionRange;\n    });\n  };\n  var mapSemverToCaretRange = (getCaretAdjustedWords, rangeModifier) => {\n    return getCaretAdjustedWords.trim().split(/\\s+/).map(_applyCaretRange => applyCaretRange(_applyCaretRange, rangeModifier)).join(\" \");\n  };\n  var applyCaretRange = (replaceCaretInVersionString, _replaceCaretInVersionString) => {\n    logDebugInfo(\"caret\", replaceCaretInVersionString, _replaceCaretInVersionString);\n    let caretVersionRegex = _replaceCaretInVersionString.loose ? semverRegexPatterns[devToolFlags.CARETLOOSE] : semverRegexPatterns[devToolFlags.CARET];\n    let prereleaseSuffix = _replaceCaretInVersionString.includePrerelease ? \"-0\" : \"\";\n    return replaceCaretInVersionString.replace(caretVersionRegex, (generateCaretRange, versionMinor, _minorVersion, patchVersion, preReleaseIdentifier) => {\n      logDebugInfo(\"caret\", replaceCaretInVersionString, generateCaretRange, versionMinor, _minorVersion, patchVersion, preReleaseIdentifier);\n      let __versionRange;\n      if (isWildcard(versionMinor)) {\n        __versionRange = \"\";\n      } else if (isWildcard(_minorVersion)) {\n        __versionRange = `>=${versionMinor}.0.0${prereleaseSuffix} <${+versionMinor + 1}.0.0-0`;\n      } else if (isWildcard(patchVersion)) {\n        if (versionMinor === \"0\") {\n          __versionRange = `>=${versionMinor}.${_minorVersion}.0${prereleaseSuffix} <${versionMinor}.${+_minorVersion + 1}.0-0`;\n        } else {\n          __versionRange = `>=${versionMinor}.${_minorVersion}.0${prereleaseSuffix} <${+versionMinor + 1}.0.0-0`;\n        }\n      } else if (preReleaseIdentifier) {\n        logDebugInfo(\"replaceCaret pr\", preReleaseIdentifier);\n        if (versionMinor === \"0\") {\n          if (_minorVersion === \"0\") {\n            __versionRange = `>=${versionMinor}.${_minorVersion}.${patchVersion}-${preReleaseIdentifier} <${versionMinor}.${_minorVersion}.${+patchVersion + 1}-0`;\n          } else {\n            __versionRange = `>=${versionMinor}.${_minorVersion}.${patchVersion}-${preReleaseIdentifier} <${versionMinor}.${+_minorVersion + 1}.0-0`;\n          }\n        } else {\n          __versionRange = `>=${versionMinor}.${_minorVersion}.${patchVersion}-${preReleaseIdentifier} <${+versionMinor + 1}.0.0-0`;\n        }\n      } else {\n        logDebugInfo(\"no pr\");\n        if (versionMinor === \"0\") {\n          if (_minorVersion === \"0\") {\n            __versionRange = `>=${versionMinor}.${_minorVersion}.${patchVersion}${prereleaseSuffix} <${versionMinor}.${_minorVersion}.${+patchVersion + 1}-0`;\n          } else {\n            __versionRange = `>=${versionMinor}.${_minorVersion}.${patchVersion}${prereleaseSuffix} <${versionMinor}.${+_minorVersion + 1}.0-0`;\n          }\n        } else {\n          __versionRange = `>=${versionMinor}.${_minorVersion}.${patchVersion} <${+versionMinor + 1}.0.0-0`;\n        }\n      }\n      logDebugInfo(\"caret return\", __versionRange);\n      return __versionRange;\n    });\n  };\n  var replaceXRangesInVersion = (inputSemverString, ____versionRange) => {\n    logDebugInfo(\"replaceXRanges\", inputSemverString, ____versionRange);\n    return inputSemverString.split(/\\s+/).map(_replaceXRangesInSemver => replaceXRangesInSemver(_replaceXRangesInSemver, ____versionRange)).join(\" \");\n  };\n  var replaceXRangesInSemver = (processVersionRange, processVersionRanges) => {\n    processVersionRange = processVersionRange.trim();\n    let getVersionRangeRegex = processVersionRanges.loose ? semverRegexPatterns[devToolFlags.XRANGELOOSE] : semverRegexPatterns[devToolFlags.XRANGE];\n    return processVersionRange.replace(getVersionRangeRegex, (resolvedVersion, comparisonOperator, versionRange, minorVersion, ____patchVersion, optionalSuffix) => {\n      logDebugInfo(\"xRange\", processVersionRange, resolvedVersion, comparisonOperator, versionRange, minorVersion, ____patchVersion, optionalSuffix);\n      let isVersionRangeWildcard = isWildcard(versionRange);\n      let isVersionWildcard = isVersionRangeWildcard || isWildcard(minorVersion);\n      let isMinorVersionWildCard = isVersionWildcard || isWildcard(____patchVersion);\n      let isVersionSatisfiable = isMinorVersionWildCard;\n      if (comparisonOperator === \"=\" && isVersionSatisfiable) {\n        comparisonOperator = \"\";\n      }\n      if (processVersionRanges.includePrerelease) {\n        optionalSuffix = \"-0\";\n      } else {\n        optionalSuffix = \"\";\n      }\n      if (isVersionRangeWildcard) {\n        if (comparisonOperator === \">\" || comparisonOperator === \"<\") {\n          resolvedVersion = \"<0.0.0-0\";\n        } else {\n          resolvedVersion = \"*\";\n        }\n      } else if (comparisonOperator && isVersionSatisfiable) {\n        if (isVersionWildcard) {\n          minorVersion = 0;\n        }\n        ____patchVersion = 0;\n        if (comparisonOperator === \">\") {\n          comparisonOperator = \">=\";\n          if (isVersionWildcard) {\n            versionRange = +versionRange + 1;\n            minorVersion = 0;\n            ____patchVersion = 0;\n          } else {\n            minorVersion = +minorVersion + 1;\n            ____patchVersion = 0;\n          }\n        } else if (comparisonOperator === \"<=\") {\n          comparisonOperator = \"<\";\n          if (isVersionWildcard) {\n            versionRange = +versionRange + 1;\n          } else {\n            minorVersion = +minorVersion + 1;\n          }\n        }\n        if (comparisonOperator === \"<\") {\n          optionalSuffix = \"-0\";\n        }\n        resolvedVersion = `${comparisonOperator + versionRange}.${minorVersion}.${____patchVersion}${optionalSuffix}`;\n      } else if (isVersionWildcard) {\n        resolvedVersion = `>=${versionRange}.0.0${optionalSuffix} <${+versionRange + 1}.0.0-0`;\n      } else if (isMinorVersionWildCard) {\n        resolvedVersion = `>=${versionRange}.${minorVersion}.0${optionalSuffix} <${versionRange}.${+minorVersion + 1}.0-0`;\n      }\n      logDebugInfo(\"xRange return\", resolvedVersion);\n      return resolvedVersion;\n    });\n  };\n  var replaceWildcardVersions = (________inputString, _________inputString) => {\n    logDebugInfo(\"replaceStars\", ________inputString, _________inputString);\n    return ________inputString.trim().replace(semverRegexPatterns[devToolFlags.STAR], \"\");\n  };\n  var replaceGTE0 = (_______inputString, versionInput) => {\n    logDebugInfo(\"replaceGTE0\", _______inputString, versionInput);\n    return _______inputString.trim().replace(semverRegexPatterns[versionInput.includePrerelease ? devToolFlags.GTE0PRE : devToolFlags.GTE0], \"\");\n  };\n  var generateRangeString = generateVersionRange => (_generateVersionRange, _versionRange, versionConstraint, versionRangeLowerBound, lowerVersionBoundary, isLowerBoundedVersion, __generateVersionRange, _upperBound, upperVersionBoundary, upperBoundVersion, _patchVersion, prereleaseIdentifier) => {\n    if (isWildcard(versionConstraint)) {\n      _versionRange = \"\";\n    } else if (isWildcard(versionRangeLowerBound)) {\n      _versionRange = `>=${versionConstraint}.0.0${generateVersionRange ? \"-0\" : \"\"}`;\n    } else if (isWildcard(lowerVersionBoundary)) {\n      _versionRange = `>=${versionConstraint}.${versionRangeLowerBound}.0${generateVersionRange ? \"-0\" : \"\"}`;\n    } else if (isLowerBoundedVersion) {\n      _versionRange = `>=${_versionRange}`;\n    } else {\n      _versionRange = `>=${_versionRange}${generateVersionRange ? \"-0\" : \"\"}`;\n    }\n    if (isWildcard(upperVersionBoundary)) {\n      _upperBound = \"\";\n    } else if (isWildcard(upperBoundVersion)) {\n      _upperBound = `<${+upperVersionBoundary + 1}.0.0-0`;\n    } else if (isWildcard(_patchVersion)) {\n      _upperBound = `<${upperVersionBoundary}.${+upperBoundVersion + 1}.0-0`;\n    } else if (prereleaseIdentifier) {\n      _upperBound = `<=${upperVersionBoundary}.${upperBoundVersion}.${_patchVersion}-${prereleaseIdentifier}`;\n    } else if (generateVersionRange) {\n      _upperBound = `<${upperVersionBoundary}.${upperBoundVersion}.${+_patchVersion + 1}-0`;\n    } else {\n      _upperBound = `<=${_upperBound}`;\n    }\n    return `${_versionRange} ${_upperBound}`.trim();\n  };\n  var yp9 = (checkVersionCompatibility, _versionConstraint, isVersionCompatible) => {\n    for (let __________________________________index = 0; __________________________________index < checkVersionCompatibility.length; __________________________________index++) {\n      if (!checkVersionCompatibility[__________________________________index].test(_versionConstraint)) {\n        return false;\n      }\n    }\n    if (_versionConstraint.prerelease.length && !isVersionCompatible.includePrerelease) {\n      for (let __index = 0; __index < checkVersionCompatibility.length; __index++) {\n        logDebugInfo(checkVersionCompatibility[__index].semver);\n        if (checkVersionCompatibility[__index].semver === JJ1.ANY) {\n          continue;\n        }\n        if (checkVersionCompatibility[__index].semver.prerelease.length > 0) {\n          let currentSemver = checkVersionCompatibility[__index].semver;\n          if (currentSemver.major === _versionConstraint.major && currentSemver.minor === _versionConstraint.minor && currentSemver.patch === _versionConstraint.patch) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    return true;\n  };\n});\nvar q0A = z((regexTest, exportFunctionForTesting) => {\n  var Kp9TestInstance = c$();\n  var _testInputAgainstKP9 = (________inputValue, kp9Instance, testInputAgainstKP9) => {\n    try {\n      kp9Instance = new Kp9TestInstance(kp9Instance, testInputAgainstKP9);\n    } catch (_________________error) {\n      return false;\n    }\n    return kp9Instance.test(________inputValue);\n  };\n  exportFunctionForTesting.exports = _testInputAgainstKP9;\n});\nvar _________initializeRenderer = z((createSharpModule, _createSharpModule) => {\n  _createSharpModule.exports = {\n    name: \"sharp\",\n    description: \"High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images\",\n    version: \"0.33.5\",\n    author: \"Lovell Fuller <npm@lovell.info>\",\n    homepage: \"https://sharp.pixelplumbing.com\",\n    contributors: [\"Pierre Inglebert <pierre.inglebert@gmail.com>\", \"Jonathan Ong <jonathanrichardong@gmail.com>\", \"Chanon Sajjamanochai <chanon.s@gmail.com>\", \"Juliano Julio <julianojulio@gmail.com>\", \"Daniel Gasienica <daniel@gasienica.ch>\", \"Julian Walker <julian@fiftythree.com>\", \"Amit Pitaru <pitaru.amit@gmail.com>\", \"Brandon Aaron <hello.brandon@aaron.sh>\", \"Andreas Lind <andreas@one.com>\", \"Maurus Cuelenaere <mcuelenaere@gmail.com>\", \"Linus Unnebäck <linus@folkdatorn.se>\", \"Victor Mateevitsi <mvictoras@gmail.com>\", \"Alaric Holloway <alaric.holloway@gmail.com>\", \"Bernhard K. Weisshuhn <bkw@codingforce.com>\", \"Chris Riley <criley@primedia.com>\", \"David Carley <dacarley@gmail.com>\", \"John Tobin <john@limelightmobileinc.com>\", \"Kenton Gray <kentongray@gmail.com>\", \"Felix Bünemann <Felix.Buenemann@gmail.com>\", \"Samy Al Zahrani <samyalzahrany@gmail.com>\", \"Chintan Thakkar <lemnisk8@gmail.com>\", \"F. Orlando Galashan <frulo@gmx.de>\", \"Kleis Auke Wolthuizen <info@kleisauke.nl>\", \"Matt Hirsch <mhirsch@media.mit.edu>\", \"Matthias Thoemmes <thoemmes@gmail.com>\", \"Patrick Paskaris <patrick@paskaris.gr>\", \"Jérémy Lal <kapouer@melix.org>\", \"Rahul Nanwani <r.nanwani@gmail.com>\", \"Alice Monday <alice0meta@gmail.com>\", \"Kristo Jorgenson <kristo.jorgenson@gmail.com>\", \"YvesBos <yves_bos@outlook.com>\", \"Guy Maliar <guy@tailorbrands.com>\", \"Nicolas Coden <nicolas@ncoden.fr>\", \"Matt Parrish <matt.r.parrish@gmail.com>\", \"Marcel Bretschneider <marcel.bretschneider@gmail.com>\", \"Matthew McEachen <matthew+github@mceachen.org>\", \"Jarda Kotěšovec <jarda.kotesovec@gmail.com>\", \"Kenric D'Souza <kenric.dsouza@gmail.com>\", \"Oleh Aleinyk <oleg.aleynik@gmail.com>\", \"Marcel Bretschneider <marcel.bretschneider@gmail.com>\", \"Andrea Bianco <andrea.bianco@unibas.ch>\", \"Rik Heywood <rik@rik.org>\", \"Thomas Parisot <hi@oncletom.io>\", \"Nathan Graves <nathanrgraves+github@gmail.com>\", \"Tom Lokhorst <tom@lokhorst.eu>\", \"Espen Hovlandsdal <espen@hovlandsdal.com>\", \"Sylvain Dumont <sylvain.dumont35@gmail.com>\", \"Alun Davies <alun.owain.davies@googlemail.com>\", \"Aidan Hoolachan <ajhoolachan21@gmail.com>\", \"Axel Eirola <axel.eirola@iki.fi>\", \"Freezy <freezy@xbmc.org>\", \"Daiz <taneli.vatanen@gmail.com>\", \"Julian Aubourg <j@ubourg.net>\", \"Keith Belovay <keith@picthrive.com>\", \"Michael B. Klein <mbklein@gmail.com>\", \"Jordan Prudhomme <jordan@raboland.fr>\", \"Ilya Ovdin <iovdin@gmail.com>\", \"Andargor <andargor@yahoo.com>\", \"Paul Neave <paul.neave@gmail.com>\", \"Brendan Kennedy <brenwken@gmail.com>\", \"Brychan Bennett-Odlum <git@brychan.io>\", \"Edward Silverton <e.silverton@gmail.com>\", \"Roman Malieiev <aromaleev@gmail.com>\", \"Tomas Szabo <tomas.szabo@deftomat.com>\", \"Robert O'Rourke <robert@o-rourke.org>\", \"Guillermo Alfonso Varela Chouciño <guillevch@gmail.com>\", \"Christian Flintrup <chr@gigahost.dk>\", \"Manan Jadhav <manan@motionden.com>\", \"Leon Radley <leon@radley.se>\", \"alza54 <alza54@thiocod.in>\", \"Jacob Smith <jacob@frende.me>\", \"Michael Nutt <michael@nutt.im>\", \"Brad Parham <baparham@gmail.com>\", \"Taneli Vatanen <taneli.vatanen@gmail.com>\", \"Joris Dugué <zaruike10@gmail.com>\", \"Chris Banks <christopher.bradley.banks@gmail.com>\", \"Ompal Singh <ompal.hitm09@gmail.com>\", \"Brodan <christopher.hranj@gmail.com>\", \"Ankur Parihar <ankur.github@gmail.com>\", \"Brahim Ait elhaj <brahima@gmail.com>\", \"Mart Jansink <m.jansink@gmail.com>\", \"Lachlan Newman <lachnewman007@gmail.com>\", \"Dennis Beatty <dennis@dcbeatty.com>\", \"Ingvar Stepanyan <me@rreverser.com>\", \"Don Denton <don@happycollision.com>\"],\n    scripts: {\n      install: \"node install/check\",\n      clean: \"rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*\",\n      test: \"npm run test-lint && npm run test-unit && npm run test-licensing && npm run test-types\",\n      \"test-lint\": \"semistandard && cpplint\",\n      \"test-unit\": \"nyc --reporter=lcov --reporter=text --check-coverage --branches=100 mocha\",\n      \"test-licensing\": \"license-checker --production --summary --onlyAllow=\\\"Apache-2.0;BSD;ISC;LGPL-3.0-or-later;MIT\\\"\",\n      \"test-leak\": \"./test/leak/leak.sh\",\n      \"test-types\": \"tsd\",\n      \"package-from-local-build\": \"node npm/from-local-build\",\n      \"package-from-github-release\": \"node npm/from-github-release\",\n      \"docs-build\": \"node docs/build && node docs/search-index/build\",\n      \"docs-serve\": \"cd docs && npx serve\",\n      \"docs-publish\": \"cd docs && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp\"\n    },\n    type: \"commonjs\",\n    main: \"lib/index.js\",\n    types: \"lib/index.d.ts\",\n    files: [\"install\", \"lib\", \"src/*.{cc,h,gyp}\"],\n    repository: {\n      type: \"git\",\n      url: \"git://github.com/lovell/sharp.git\"\n    },\n    keywords: [\"jpeg\", \"png\", \"webp\", \"avif\", \"tiff\", \"gif\", \"svg\", \"jp2\", \"dzi\", \"image\", \"resize\", \"thumbnail\", \"crop\", \"embed\", \"libvips\", \"vips\"],\n    dependencies: {\n      color: \"^4.2.3\",\n      \"detect-libc\": \"^2.0.3\",\n      semver: \"^7.6.3\"\n    },\n    optionalDependencies: {\n      \"@img/sharp-darwin-arm64\": \"0.33.5\",\n      \"@img/sharp-darwin-x64\": \"0.33.5\",\n      \"@img/sharp-libvips-darwin-arm64\": \"1.0.4\",\n      \"@img/sharp-libvips-darwin-x64\": \"1.0.4\",\n      \"@img/sharp-libvips-linux-arm\": \"1.0.5\",\n      \"@img/sharp-libvips-linux-arm64\": \"1.0.4\",\n      \"@img/sharp-libvips-linux-s390x\": \"1.0.4\",\n      \"@img/sharp-libvips-linux-x64\": \"1.0.4\",\n      \"@img/sharp-libvips-linuxmusl-arm64\": \"1.0.4\",\n      \"@img/sharp-libvips-linuxmusl-x64\": \"1.0.4\",\n      \"@img/sharp-linux-arm\": \"0.33.5\",\n      \"@img/sharp-linux-arm64\": \"0.33.5\",\n      \"@img/sharp-linux-s390x\": \"0.33.5\",\n      \"@img/sharp-linux-x64\": \"0.33.5\",\n      \"@img/sharp-linuxmusl-arm64\": \"0.33.5\",\n      \"@img/sharp-linuxmusl-x64\": \"0.33.5\",\n      \"@img/sharp-wasm32\": \"0.33.5\",\n      \"@img/sharp-win32-ia32\": \"0.33.5\",\n      \"@img/sharp-win32-x64\": \"0.33.5\"\n    },\n    devDependencies: {\n      \"@emnapi/runtime\": \"^1.2.0\",\n      \"@img/sharp-libvips-dev\": \"1.0.4\",\n      \"@img/sharp-libvips-dev-wasm32\": \"1.0.5\",\n      \"@img/sharp-libvips-win32-ia32\": \"1.0.4\",\n      \"@img/sharp-libvips-win32-x64\": \"1.0.4\",\n      \"@types/node\": \"*\",\n      async: \"^3.2.5\",\n      cc: \"^3.0.1\",\n      emnapi: \"^1.2.0\",\n      \"exif-reader\": \"^2.0.1\",\n      \"extract-zip\": \"^2.0.1\",\n      icc: \"^3.0.0\",\n      \"jsdoc-to-markdown\": \"^8.0.3\",\n      \"license-checker\": \"^25.0.1\",\n      mocha: \"^10.7.3\",\n      \"node-addon-api\": \"^8.1.0\",\n      nyc: \"^17.0.0\",\n      prebuild: \"^13.0.1\",\n      semistandard: \"^17.0.0\",\n      \"tar-fs\": \"^3.0.6\",\n      tsd: \"^0.31.1\"\n    },\n    license: \"Apache-2.0\",\n    engines: {\n      node: \"^18.17.0 || ^20.3.0 || >=21.0.0\"\n    },\n    config: {\n      libvips: \">=8.15.3\"\n    },\n    funding: {\n      url: \"https://opencollective.com/libvips\"\n    },\n    binary: {\n      napi_versions: [9]\n    },\n    semistandard: {\n      env: [\"mocha\"]\n    },\n    cc: {\n      linelength: \"120\",\n      filter: [\"build/include\"]\n    },\n    nyc: {\n      include: [\"lib\"]\n    },\n    tsd: {\n      directory: \"test/types/\"\n    }\n  };\n});\nvar FJ1 = z((processLibvipsSetup, moduleExports) => {\n  var {\n    spawnSync: spawnChildProcess\n  } = EA(\"node:child_process\");\n  var {\n    createHash: createHash\n  } = EA(\"node:crypto\");\n  var ___initializeDevelopmentToolsConnection = _initializeDevelopmentToolsConnection();\n  var ________________initializeReactDevToolsConnection = ____________initializeReactDevToolsConnection();\n  var fp9 = q0A();\n  var yogaNodeAppender = appendChildToYogaNode();\n  var {\n    config: libvipsConfig,\n    engines: libvipsEngines,\n    optionalDependencies: optionalDependencies\n  } = _________initializeRenderer();\n  var libvipsVersion = process.env.npm_package_config_libvips || libvipsConfig.libvips;\n  var minLibvipsVersion = ___initializeDevelopmentToolsConnection(libvipsVersion).version;\n  var supportedPlatforms = [\"darwin-arm64\", \"darwin-x64\", \"linux-arm\", \"linux-arm64\", \"linux-s390x\", \"linux-x64\", \"linuxmusl-arm64\", \"linuxmusl-x64\", \"win32-ia32\", \"win32-x64\"];\n  var spawnOptions = {\n    encoding: \"utf8\",\n    shell: true\n  };\n  var logInstallationError = handleErrorOrLog => {\n    if (handleErrorOrLog instanceof Error) {\n      console.error(`sharp: Installation error: ${handleErrorOrLog.message}`);\n    } else {\n      console.log(`sharp: ${handleErrorOrLog}`);\n    }\n  };\n  var getLibvipsABI = () => yogaNodeAppender.isNonGlibcLinuxSync() ? yogaNodeAppender.familySync() : \"\";\n  var getRuntimePlatformArchitecture = () => `${process.platform}${getLibvipsABI()}-${process.arch}`;\n  var getBuildPlatformArch = () => {\n    if (isUsingEmscripten()) {\n      return \"wasm32\";\n    }\n    let {\n      npm_config_arch: npmConfigArch,\n      npm_config_platform: npmConfigPlatform,\n      npm_config_libc: libcType\n    } = process.env;\n    let libcImplementation = typeof libcType === \"string\" ? libcType : getLibvipsABI();\n    return `${npmConfigPlatform || process.platform}${libcImplementation}-${npmConfigArch || process.arch}`;\n  };\n  var getSharpLibvipsIncludeDir = () => {\n    try {\n      return EA(`@img/sharp-libvips-dev-${getBuildPlatformArch()}/include`);\n    } catch {\n      try {\n        return (() => {\n          throw new Error(\"Cannot require module @img/sharp-libvips-dev/include\");\n        })();\n      } catch {}\n    }\n    return \"\";\n  };\n  var getSharpLibvipsCPlusPlusDir = () => {\n    try {\n      return (() => {\n        throw new Error(\"Cannot require module @img/sharp-libvips-dev/cplusplus\");\n      })();\n    } catch {}\n    return \"\";\n  };\n  var getSharpLibvipsLibDir = () => {\n    try {\n      return EA(`@img/sharp-libvips-dev-${getBuildPlatformArch()}/lib`);\n    } catch {\n      try {\n        return EA(`@img/sharp-libvips-${getBuildPlatformArch()}/lib`);\n      } catch {}\n    }\n    return \"\";\n  };\n  var np9 = () => {\n    if (process.release?.name === \"node\" && process.versions) {\n      if (!fp9(process.versions.node, libvipsEngines.node)) {\n        return {\n          found: process.versions.node,\n          expected: libvipsEngines.node\n        };\n      }\n    }\n  };\n  var isUsingEmscripten = () => {\n    let {\n      CC: isEmccPathConfigured\n    } = process.env;\n    return Boolean(isEmccPathConfigured && isEmccPathConfigured.endsWith(\"/emcc\"));\n  };\n  var isRunningUnderRosetta = () => {\n    if (process.platform === \"darwin\" && process.arch === \"x64\") {\n      return (spawnChildProcess(\"sysctl sysctl.proc_translated\", spawnOptions).stdout || \"\").trim() === \"sysctl.proc_translated: 1\";\n    }\n    return false;\n  };\n  var generateSHA512Hash = inputDataForHashing => createHash(\"sha512\").update(inputDataForHashing).digest(\"hex\");\n  var calculateLibvipsIdentifier = () => {\n    try {\n      let generatedHashKey = generateSHA512Hash(`imgsharp-libvips-${getBuildPlatformArch()}`);\n      let developmentToolsConnectionVersion = ___initializeDevelopmentToolsConnection(optionalDependencies[`@img/sharp-libvips-${getBuildPlatformArch()}`]).version;\n      return generateSHA512Hash(`${generatedHashKey}npm:${developmentToolsConnectionVersion}`).slice(0, 10);\n    } catch {}\n    return \"\";\n  };\n  var spawnNodeGypRebuild = () => spawnChildProcess(`node-gyp rebuild --directory=src ${isUsingEmscripten() ? \"--nodedir=emscripten\" : \"\"}`, {\n    ...spawnOptions,\n    stdio: \"inherit\"\n  }).status;\n  var getGlobalLibvipsVersion = () => {\n    if (process.platform !== \"win32\") {\n      return (spawnChildProcess(\"pkg-config --modversion vips-cpp\", {\n        ...spawnOptions,\n        env: {\n          ...process.env,\n          PKG_CONFIG_PATH: getPkgConfigPath()\n        }\n      }).stdout || \"\").trim();\n    } else {\n      return \"\";\n    }\n  };\n  var getPkgConfigPath = () => {\n    if (process.platform !== \"win32\") {\n      return [(spawnChildProcess(\"which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d\\\" \\\" -f2\", spawnOptions).stdout || \"\").trim(), process.env.PKG_CONFIG_PATH, \"/usr/local/lib/pkgconfig\", \"/usr/lib/pkgconfig\", \"/usr/local/libdata/pkgconfig\", \"/usr/libdata/pkgconfig\"].filter(Boolean).join(\":\");\n    } else {\n      return \"\";\n    }\n  };\n  var handleGlobalLibvipsUsage = (detectedAndSkippedMessage, detectedLibraryName, logDetectedLibvips) => {\n    if (logDetectedLibvips) {\n      logDetectedLibvips(`Detected ${detectedLibraryName}, skipping search for globally-installed libvips`);\n    }\n    return detectedAndSkippedMessage;\n  };\n  var checkGlobalLibvipsAvailability = checkGlobalLibvipsUsage => {\n    if (Boolean(process.env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {\n      return handleGlobalLibvipsUsage(false, \"SHARP_IGNORE_GLOBAL_LIBVIPS\", checkGlobalLibvipsUsage);\n    }\n    if (Boolean(process.env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {\n      return handleGlobalLibvipsUsage(true, \"SHARP_FORCE_GLOBAL_LIBVIPS\", checkGlobalLibvipsUsage);\n    }\n    if (isRunningUnderRosetta()) {\n      return handleGlobalLibvipsUsage(false, \"Rosetta\", checkGlobalLibvipsUsage);\n    }\n    let globalLibvipsVersion = getGlobalLibvipsVersion();\n    return !!globalLibvipsVersion && ________________initializeReactDevToolsConnection(globalLibvipsVersion, minLibvipsVersion);\n  };\n  moduleExports.exports = {\n    minimumLibvipsVersion: minLibvipsVersion,\n    prebuiltPlatforms: supportedPlatforms,\n    buildPlatformArch: getBuildPlatformArch,\n    buildSharpLibvipsIncludeDir: getSharpLibvipsIncludeDir,\n    buildSharpLibvipsCPlusPlusDir: getSharpLibvipsCPlusPlusDir,\n    buildSharpLibvipsLibDir: getSharpLibvipsLibDir,\n    isUnsupportedNodeRuntime: np9,\n    runtimePlatformArch: getRuntimePlatformArchitecture,\n    log: logInstallationError,\n    yarnLocator: calculateLibvipsIdentifier,\n    spawnRebuild: spawnNodeGypRebuild,\n    globalLibvipsVersion: getGlobalLibvipsVersion,\n    pkgConfigPath: getPkgConfigPath,\n    useGlobalLibvips: checkGlobalLibvipsAvailability\n  };\n});\nvar HJA = z((loadSharpModule, moduleExporter) => {\n  var {\n    familySync: getLibvipsVersion,\n    versionSync: getSharpLibraryVersion\n  } = appendChildToYogaNode();\n  var {\n    runtimePlatformArch: Al9,\n    isUnsupportedNodeRuntime: R_0,\n    prebuiltPlatforms: Bl9,\n    minimumLibvipsVersion: Ql9\n  } = FJ1();\n  var Ni = Al9();\n  var Il9 = [`../src/build/Release/sharp-${Ni}.node`, \"../src/build/Release/sharp-wasm32.node\", `@img/sharp-${Ni}/sharp.node`, \"@img/sharp-wasm32/sharp.node\"];\n  var loadedSharpModule;\n  var errorList = [];\n  for (let moduleItem of Il9) {\n    try {\n      loadedSharpModule = EA(moduleItem);\n      break;\n    } catch (_____error) {\n      errorList.push(_____error);\n    }\n  }\n  if (loadedSharpModule) {\n    moduleExporter.exports = loadedSharpModule;\n  } else {\n    let [platformSpecificBuildAttempt, error, isWin32Platform] = [\"linux\", \"darwin\", \"win32\"].map(prefixString => Ni.startsWith(prefixString));\n    let errorMessage = [`Could not load the \"sharp\" module using the ${Ni} runtime`];\n    errorList.forEach(_errorHandler => {\n      if (_errorHandler.code !== \"MODULE_NOT_FOUND\") {\n        errorMessage.push(`${_errorHandler.code}: ${_errorHandler.message}`);\n      }\n    });\n    let errorMessageConcat = errorList.map(messageHandler => messageHandler.message).join(\" \");\n    errorMessage.push(\"Possible solutions:\");\n    if (R_0()) {\n      let {\n        found: platformPrefixCheck,\n        expected: requiredNodeVersion\n      } = R_0();\n      errorMessage.push(\"- Please upgrade Node.js:\", `    Found ${platformPrefixCheck}`, `    Requires ${requiredNodeVersion}`);\n    } else if (Bl9.includes(Ni)) {\n      let [runtimePlatformCheck, expectedNodeVersion] = Ni.split(\"-\");\n      let platformSpecificDependencyHint = runtimePlatformCheck.endsWith(\"musl\") ? \" --libc=musl\" : \"\";\n      errorMessage.push(\"- Ensure optional dependencies can be installed:\", \"    npm install --include=optional sharp\", \"- Ensure your package manager supports multi-platform installation:\", \"    See https://sharp.pixelplumbing.com/install#cross-platform\", \"- Add platform-specific dependencies:\", `    npm install --os=${runtimePlatformCheck.replace(\"musl\", \"\")}${platformSpecificDependencyHint} --cpu=${expectedNodeVersion} sharp`);\n    } else {\n      errorMessage.push(`- Manually install libvips >= ${Ql9}`, \"- Add experimental WebAssembly-based dependencies:\", \"    npm install --cpu=wasm32 sharp\", \"    npm install @img/sharp-wasm32\");\n    }\n    if (platformSpecificBuildAttempt && /(symbol not found|CXXABI_)/i.test(errorMessageConcat)) {\n      try {\n        let {\n          config: platformDetection\n        } = EA(`@img/sharp-libvips-${Ni}/package`);\n        let _expectedNodeVersion = `${getLibvipsVersion()} ${getSharpLibraryVersion()}`;\n        let platformDependency = `${platformDetection.musl ? \"musl\" : \"glibc\"} ${platformDetection.musl || platformDetection.glibc}`;\n        errorMessage.push(\"- Update your OS:\", `    Found ${_expectedNodeVersion}`, `    Requires ${platformDependency}`);\n      } catch (_______error) {}\n    }\n    if (platformSpecificBuildAttempt && /\\/snap\\/core[0-9]{2}/.test(errorMessageConcat)) {\n      errorMessage.push(\"- Remove the Node.js Snap, which does not support native modules\", \"    snap remove node\");\n    }\n    if (error && /Incompatible library version/.test(errorMessageConcat)) {\n      errorMessage.push(\"- Update Homebrew:\", \"    brew update && brew upgrade vips\");\n    }\n    if (errorList.some(__errorResponse => __errorResponse.code === \"ERR_DLOPEN_DISABLED\")) {\n      errorMessage.push(\"- Run Node.js without using the --no-addons flag\");\n    }\n    if (isWin32Platform && /The specified procedure could not be found/.test(errorMessageConcat)) {\n      errorMessage.push(\"- Using the canvas package on Windows?\", \"    See https://sharp.pixelplumbing.com/install#canvas-and-windows\", \"- Check for outdated versions of sharp in the dependency tree:\", \"    npm ls sharp\");\n    }\n    errorMessage.push(\"- Consult the installation documentation:\", \"    See https://sharp.pixelplumbing.com/install\");\n    throw Error(errorMessage.join(`\n`));\n  }\n});\nvar j_0 = z((createImageProcessor, ImageProcessor) => {\n  var loadUtilModule = EA(\"node:util\");\n  var StreamProcessingModule = EA(\"node:stream\");\n  var initializeImageRenderer = _______initializeRenderer();\n  HJA();\n  var debugLogSharp = loadUtilModule.debuglog(\"sharp\");\n  function Li(_ImageProcessor, inputDescriptor) {\n    if (arguments.length === 1 && !initializeImageRenderer.defined(_ImageProcessor)) {\n      throw Error(\"Invalid input\");\n    }\n    if (!(this instanceof Li)) {\n      return new Li(_ImageProcessor, inputDescriptor);\n    }\n    StreamProcessingModule.Duplex.call(this);\n    this.options = {\n      topOffsetPre: -1,\n      leftOffsetPre: -1,\n      widthPre: -1,\n      heightPre: -1,\n      topOffsetPost: -1,\n      leftOffsetPost: -1,\n      widthPost: -1,\n      heightPost: -1,\n      width: -1,\n      height: -1,\n      canvas: \"crop\",\n      position: 0,\n      resizeBackground: [0, 0, 0, 255],\n      useExifOrientation: false,\n      angle: 0,\n      rotationAngle: 0,\n      rotationBackground: [0, 0, 0, 255],\n      rotateBeforePreExtract: false,\n      flip: false,\n      flop: false,\n      extendTop: 0,\n      extendBottom: 0,\n      extendLeft: 0,\n      extendRight: 0,\n      extendBackground: [0, 0, 0, 255],\n      extendWith: \"background\",\n      withoutEnlargement: false,\n      withoutReduction: false,\n      affineMatrix: [],\n      affineBackground: [0, 0, 0, 255],\n      affineIdx: 0,\n      affineIdy: 0,\n      affineOdx: 0,\n      affineOdy: 0,\n      affineInterpolator: this.constructor.interpolators.bilinear,\n      kernel: \"lanczos3\",\n      fastShrinkOnLoad: true,\n      tint: [-1, 0, 0, 0],\n      flatten: false,\n      flattenBackground: [0, 0, 0],\n      unflatten: false,\n      negate: false,\n      negateAlpha: true,\n      medianSize: 0,\n      blurSigma: 0,\n      precision: \"integer\",\n      minAmpl: 0.2,\n      sharpenSigma: 0,\n      sharpenM1: 1,\n      sharpenM2: 2,\n      sharpenX1: 2,\n      sharpenY2: 10,\n      sharpenY3: 20,\n      threshold: 0,\n      thresholdGrayscale: true,\n      trimBackground: [],\n      trimThreshold: -1,\n      trimLineArt: false,\n      gamma: 0,\n      gammaOut: 0,\n      greyscale: false,\n      normalise: false,\n      normaliseLower: 1,\n      normaliseUpper: 99,\n      claheWidth: 0,\n      claheHeight: 0,\n      claheMaxSlope: 3,\n      brightness: 1,\n      saturation: 1,\n      hue: 0,\n      lightness: 0,\n      booleanBufferIn: null,\n      booleanFileIn: \"\",\n      joinChannelIn: [],\n      extractChannel: -1,\n      removeAlpha: false,\n      ensureAlpha: -1,\n      colourspace: \"srgb\",\n      colourspacePipeline: \"last\",\n      composite: [],\n      fileOut: \"\",\n      formatOut: \"input\",\n      streamOut: false,\n      keepMetadata: 0,\n      withMetadataOrientation: -1,\n      withMetadataDensity: 0,\n      withIccProfile: \"\",\n      withExif: {},\n      withExifMerge: true,\n      resolveWithObject: false,\n      jpegQuality: 80,\n      jpegProgressive: false,\n      jpegChromaSubsampling: \"4:2:0\",\n      jpegTrellisQuantisation: false,\n      jpegOvershootDeringing: false,\n      jpegOptimiseScans: false,\n      jpegOptimiseCoding: true,\n      jpegQuantisationTable: 0,\n      pngProgressive: false,\n      pngCompressionLevel: 6,\n      pngAdaptiveFiltering: false,\n      pngPalette: false,\n      pngQuality: 100,\n      pngEffort: 7,\n      pngBitdepth: 8,\n      pngDither: 1,\n      jp2Quality: 80,\n      jp2TileHeight: 512,\n      jp2TileWidth: 512,\n      jp2Lossless: false,\n      jp2ChromaSubsampling: \"4:4:4\",\n      webpQuality: 80,\n      webpAlphaQuality: 100,\n      webpLossless: false,\n      webpNearLossless: false,\n      webpSmartSubsample: false,\n      webpPreset: \"default\",\n      webpEffort: 4,\n      webpMinSize: false,\n      webpMixed: false,\n      gifBitdepth: 8,\n      gifEffort: 7,\n      gifDither: 1,\n      gifInterFrameMaxError: 0,\n      gifInterPaletteMaxError: 3,\n      gifReuse: true,\n      gifProgressive: false,\n      tiffQuality: 80,\n      tiffCompression: \"jpeg\",\n      tiffPredictor: \"horizontal\",\n      tiffPyramid: false,\n      tiffMiniswhite: false,\n      tiffBitdepth: 8,\n      tiffTile: false,\n      tiffTileHeight: 256,\n      tiffTileWidth: 256,\n      tiffXres: 1,\n      tiffYres: 1,\n      tiffResolutionUnit: \"inch\",\n      heifQuality: 50,\n      heifLossless: false,\n      heifCompression: \"av1\",\n      heifEffort: 4,\n      heifChromaSubsampling: \"4:4:4\",\n      heifBitdepth: 8,\n      jxlDistance: 1,\n      jxlDecodingTier: 0,\n      jxlEffort: 7,\n      jxlLossless: false,\n      rawDepth: \"uchar\",\n      tileSize: 256,\n      tileOverlap: 0,\n      tileContainer: \"fs\",\n      tileLayout: \"dz\",\n      tileFormat: \"last\",\n      tileDepth: \"last\",\n      tileAngle: 0,\n      tileSkipBlanks: -1,\n      tileBackground: [255, 255, 255, 255],\n      tileCentre: false,\n      tileId: \"https://example.com/iiif\",\n      tileBasename: \"\",\n      timeoutSeconds: 0,\n      linearA: [],\n      linearB: [],\n      debuglog: warningMessage => {\n        this.emit(\"warning\", warningMessage);\n        debugLogSharp(warningMessage);\n      },\n      queueListener: function (changeEventData) {\n        Li.queue.emit(\"change\", changeEventData);\n      }\n    };\n    this.options.input = this._createInputDescriptor(_ImageProcessor, inputDescriptor, {\n      allowStream: true\n    });\n    return this;\n  }\n  Object.setPrototypeOf(Li.prototype, StreamProcessingModule.Duplex.prototype);\n  Object.setPrototypeOf(Li, StreamProcessingModule.Duplex);\n  function createInstanceWithOptions() {\n    let newInstance = this.constructor.call();\n    let {\n      debuglog: debugLogger,\n      queueListener: queueListener,\n      ...additionalOptions\n    } = this.options;\n    newInstance.options = structuredClone(additionalOptions);\n    newInstance.options.debuglog = debugLogger;\n    newInstance.options.queueListener = queueListener;\n    if (this._isStreamInput()) {\n      this.on(\"finish\", () => {\n        this._flattenBufferIn();\n        newInstance.options.input.buffer = this.options.input.buffer;\n        newInstance.emit(\"finish\");\n      });\n    }\n    return newInstance;\n  }\n  Object.assign(Li.prototype, {\n    clone: createInstanceWithOptions\n  });\n  ImageProcessor.exports = Li;\n});\nvar ______________________________initializeDevToolsConnection = z((exportColorPalette, colorPaletteModule) => {\n  colorPaletteModule.exports = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    rebeccapurple: [102, 51, 153],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  };\n});\nvar calculateDifferencesBetweenObjects = z((validateArrayInput, isArrayOrArrayLike) => {\n  isArrayOrArrayLike.exports = function (inputArray) {\n    if (!inputArray || typeof inputArray === \"string\") {\n      return false;\n    }\n    return inputArray instanceof Array || Array.isArray(inputArray) || inputArray.length >= 0 && (inputArray.splice instanceof Function || Object.getOwnPropertyDescriptor(inputArray, inputArray.length - 1) && inputArray.constructor.name !== \"String\");\n  };\n});\nvar ____________________________initializeDevTools = z((processItems, processInputArray) => {\n  var calculateIfObjectHasDifferences = calculateDifferencesBetweenObjects();\n  var concatenateArrays = Array.prototype.concat;\n  var extractArrayElements = Array.prototype.slice;\n  var processAndFilterInputArray = processInputArray.exports = function (__inputArray) {\n    var resultArray = [];\n    var _______index = 0;\n    for (var inputArrayLength = __inputArray.length; _______index < inputArrayLength; _______index++) {\n      var inputElement = __inputArray[_______index];\n      if (calculateIfObjectHasDifferences(inputElement)) {\n        resultArray = concatenateArrays.call(resultArray, extractArrayElements.call(inputElement));\n      } else {\n        resultArray.push(inputElement);\n      }\n    }\n    return resultArray;\n  };\n  processAndFilterInputArray.wrap = function (_______callbackFunction) {\n    return function () {\n      return _______callbackFunction(processAndFilterInputArray(arguments));\n    };\n  };\n});\nvar ________________________________________________initializeDevToolsConnection = z((_colorConverter, colorModule) => {\n  var colorDatabase = ______________________________initializeDevToolsConnection();\n  var createColorComponents = ____________________________initializeDevTools();\n  var objectHasOwnProperty = Object.hasOwnProperty;\n  var colorMap = Object.create(null);\n  for (colorKey in colorDatabase) {\n    if (objectHasOwnProperty.call(colorDatabase, colorKey)) {\n      colorMap[colorDatabase[colorKey]] = colorKey;\n    }\n  }\n  var colorKey;\n  var _colorConversionMethods = colorModule.exports = {\n    to: {},\n    get: {}\n  };\n  _colorConversionMethods.get = function (colorFormatParser) {\n    var colorModelAbbreviation = colorFormatParser.substring(0, 3).toLowerCase();\n    var _colorValue;\n    var _colorModel;\n    switch (colorModelAbbreviation) {\n      case \"hsl\":\n        _colorValue = _colorConversionMethods.get.hsl(colorFormatParser);\n        _colorModel = \"hsl\";\n        break;\n      case \"hwb\":\n        _colorValue = _colorConversionMethods.get.hwb(colorFormatParser);\n        _colorModel = \"hwb\";\n        break;\n      default:\n        _colorValue = _colorConversionMethods.get.rgb(colorFormatParser);\n        _colorModel = \"rgb\";\n        break;\n    }\n    if (!_colorValue) {\n      return null;\n    }\n    return {\n      model: _colorModel,\n      value: _colorValue\n    };\n  };\n  _colorConversionMethods.get.rgb = function (parseColorString) {\n    if (!parseColorString) {\n      return null;\n    }\n    var hexColorShortRegex = /^#([a-f0-9]{3,4})$/i;\n    var hexColorWithAlphaRegex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;\n    var rgbaPatternRegex = /^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n    var rgbaPercentPattern = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n    var colorKeywordRegex = /^(\\w+)$/;\n    var rgbaColor = [0, 0, 0, 1];\n    var matchValue;\n    var colorChannelIndex;\n    var alphaChannelHex;\n    if (matchValue = parseColorString.match(hexColorWithAlphaRegex)) {\n      alphaChannelHex = matchValue[2];\n      matchValue = matchValue[1];\n      for (colorChannelIndex = 0; colorChannelIndex < 3; colorChannelIndex++) {\n        var colorChannelOffset = colorChannelIndex * 2;\n        rgbaColor[colorChannelIndex] = parseInt(matchValue.slice(colorChannelOffset, colorChannelOffset + 2), 16);\n      }\n      if (alphaChannelHex) {\n        rgbaColor[3] = parseInt(alphaChannelHex, 16) / 255;\n      }\n    } else if (matchValue = parseColorString.match(hexColorShortRegex)) {\n      matchValue = matchValue[1];\n      alphaChannelHex = matchValue[3];\n      for (colorChannelIndex = 0; colorChannelIndex < 3; colorChannelIndex++) {\n        rgbaColor[colorChannelIndex] = parseInt(matchValue[colorChannelIndex] + matchValue[colorChannelIndex], 16);\n      }\n      if (alphaChannelHex) {\n        rgbaColor[3] = parseInt(alphaChannelHex + alphaChannelHex, 16) / 255;\n      }\n    } else if (matchValue = parseColorString.match(rgbaPatternRegex)) {\n      for (colorChannelIndex = 0; colorChannelIndex < 3; colorChannelIndex++) {\n        rgbaColor[colorChannelIndex] = parseInt(matchValue[colorChannelIndex + 1], 0);\n      }\n      if (matchValue[4]) {\n        if (matchValue[5]) {\n          rgbaColor[3] = parseFloat(matchValue[4]) * 0.01;\n        } else {\n          rgbaColor[3] = parseFloat(matchValue[4]);\n        }\n      }\n    } else if (matchValue = parseColorString.match(rgbaPercentPattern)) {\n      for (colorChannelIndex = 0; colorChannelIndex < 3; colorChannelIndex++) {\n        rgbaColor[colorChannelIndex] = Math.round(parseFloat(matchValue[colorChannelIndex + 1]) * 2.55);\n      }\n      if (matchValue[4]) {\n        if (matchValue[5]) {\n          rgbaColor[3] = parseFloat(matchValue[4]) * 0.01;\n        } else {\n          rgbaColor[3] = parseFloat(matchValue[4]);\n        }\n      }\n    } else if (matchValue = parseColorString.match(colorKeywordRegex)) {\n      if (matchValue[1] === \"transparent\") {\n        return [0, 0, 0, 0];\n      }\n      if (!objectHasOwnProperty.call(colorDatabase, matchValue[1])) {\n        return null;\n      }\n      rgbaColor = colorDatabase[matchValue[1]];\n      rgbaColor[3] = 1;\n      return rgbaColor;\n    } else {\n      return null;\n    }\n    for (colorChannelIndex = 0; colorChannelIndex < 3; colorChannelIndex++) {\n      rgbaColor[colorChannelIndex] = _clampValue(rgbaColor[colorChannelIndex], 0, 255);\n    }\n    rgbaColor[3] = _clampValue(rgbaColor[3], 0, 1);\n    return rgbaColor;\n  };\n  _colorConversionMethods.get.hsl = function (parseHSLACSSColor) {\n    if (!parseHSLACSSColor) {\n      return null;\n    }\n    var hslColorRegex = /^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*(?:[,|\\/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n    var matchedColorValues = parseHSLACSSColor.match(hslColorRegex);\n    if (matchedColorValues) {\n      var alphaValue = parseFloat(matchedColorValues[4]);\n      var hueAngle = (parseFloat(matchedColorValues[1]) % 360 + 360) % 360;\n      var saturationValue = _clampValue(parseFloat(matchedColorValues[2]), 0, 100);\n      var _saturationValue = _clampValue(parseFloat(matchedColorValues[3]), 0, 100);\n      var alphaChannelValue = _clampValue(isNaN(alphaValue) ? 1 : alphaValue, 0, 1);\n      return [hueAngle, saturationValue, _saturationValue, alphaChannelValue];\n    }\n    return null;\n  };\n  _colorConversionMethods.get.hwb = function (parseHwbColor) {\n    if (!parseHwbColor) {\n      return null;\n    }\n    var hwbColorRegex = /^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n    var colorMatchResult = parseHwbColor.match(hwbColorRegex);\n    if (colorMatchResult) {\n      var alpha = parseFloat(colorMatchResult[4]);\n      var _hueValue = (parseFloat(colorMatchResult[1]) % 360 + 360) % 360;\n      var hwbHue = _clampValue(parseFloat(colorMatchResult[2]), 0, 100);\n      var _lightnessValue = _clampValue(parseFloat(colorMatchResult[3]), 0, 100);\n      var _alphaValue = _clampValue(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [_hueValue, hwbHue, _lightnessValue, _alphaValue];\n    }\n    return null;\n  };\n  _colorConversionMethods.to.hex = function () {\n    var createColorHashFromArguments = createColorComponents(arguments);\n    return \"#\" + _convertToHex(createColorHashFromArguments[0]) + _convertToHex(createColorHashFromArguments[1]) + _convertToHex(createColorHashFromArguments[2]) + (createColorHashFromArguments[3] < 1 ? _convertToHex(Math.round(createColorHashFromArguments[3] * 255)) : \"\");\n  };\n  _colorConversionMethods.to.rgb = function () {\n    var colorComponents = createColorComponents(arguments);\n    if (colorComponents.length < 4 || colorComponents[3] === 1) {\n      return \"rgb(\" + Math.round(colorComponents[0]) + \", \" + Math.round(colorComponents[1]) + \", \" + Math.round(colorComponents[2]) + \")\";\n    } else {\n      return \"rgba(\" + Math.round(colorComponents[0]) + \", \" + Math.round(colorComponents[1]) + \", \" + Math.round(colorComponents[2]) + \", \" + colorComponents[3] + \")\";\n    }\n  };\n  _colorConversionMethods.to.rgb.percent = function () {\n    var colorValues = createColorComponents(arguments);\n    var redPercentage = Math.round(colorValues[0] / 255 * 100);\n    var greenPercentage = Math.round(colorValues[1] / 255 * 100);\n    var bluePercentage = Math.round(colorValues[2] / 255 * 100);\n    if (colorValues.length < 4 || colorValues[3] === 1) {\n      return \"rgb(\" + redPercentage + \"%, \" + greenPercentage + \"%, \" + bluePercentage + \"%)\";\n    } else {\n      return \"rgba(\" + redPercentage + \"%, \" + greenPercentage + \"%, \" + bluePercentage + \"%, \" + colorValues[3] + \")\";\n    }\n  };\n  _colorConversionMethods.to.hsl = function () {\n    var __colorComponents = createColorComponents(arguments);\n    if (__colorComponents.length < 4 || __colorComponents[3] === 1) {\n      return \"hsl(\" + __colorComponents[0] + \", \" + __colorComponents[1] + \"%, \" + __colorComponents[2] + \"%)\";\n    } else {\n      return \"hsla(\" + __colorComponents[0] + \", \" + __colorComponents[1] + \"%, \" + __colorComponents[2] + \"%, \" + __colorComponents[3] + \")\";\n    }\n  };\n  _colorConversionMethods.to.hwb = function () {\n    var parsedArguments = createColorComponents(arguments);\n    var additionalAlphaValue = \"\";\n    if (parsedArguments.length >= 4 && parsedArguments[3] !== 1) {\n      additionalAlphaValue = \", \" + parsedArguments[3];\n    }\n    return \"hwb(\" + parsedArguments[0] + \", \" + parsedArguments[1] + \"%, \" + parsedArguments[2] + \"%\" + additionalAlphaValue + \")\";\n  };\n  _colorConversionMethods.to.keyword = function (getColorByCode) {\n    return colorMap[getColorByCode.slice(0, 3)];\n  };\n  function _clampValue(clampValueBetweenBounds, clampedValue, upperBound) {\n    return Math.min(Math.max(clampedValue, clampValueBetweenBounds), upperBound);\n  }\n  function _convertToHex(convertNumberToHexString) {\n    var hexString = Math.round(convertNumberToHexString).toString(16).toUpperCase();\n    if (hexString.length < 2) {\n      return \"0\" + hexString;\n    } else {\n      return hexString;\n    }\n  }\n});\nvar ____________________initializeDevelopmentTools = z((colorFormatMappingFunction, colorConverter) => {\n  var initializeColorMapping = ______________________________initializeDevToolsConnection();\n  var colorKeywordMapping = {};\n  for (let keyword of Object.keys(initializeColorMapping)) {\n    colorKeywordMapping[initializeColorMapping[keyword]] = keyword;\n  }\n  var colorConversionMethods = {\n    rgb: {\n      channels: 3,\n      labels: \"rgb\"\n    },\n    hsl: {\n      channels: 3,\n      labels: \"hsl\"\n    },\n    hsv: {\n      channels: 3,\n      labels: \"hsv\"\n    },\n    hwb: {\n      channels: 3,\n      labels: \"hwb\"\n    },\n    cmyk: {\n      channels: 4,\n      labels: \"cmyk\"\n    },\n    xyz: {\n      channels: 3,\n      labels: \"xyz\"\n    },\n    lab: {\n      channels: 3,\n      labels: \"lab\"\n    },\n    lch: {\n      channels: 3,\n      labels: \"lch\"\n    },\n    hex: {\n      channels: 1,\n      labels: [\"hex\"]\n    },\n    keyword: {\n      channels: 1,\n      labels: [\"keyword\"]\n    },\n    ansi16: {\n      channels: 1,\n      labels: [\"ansi16\"]\n    },\n    ansi256: {\n      channels: 1,\n      labels: [\"ansi256\"]\n    },\n    hcg: {\n      channels: 3,\n      labels: [\"h\", \"c\", \"g\"]\n    },\n    apple: {\n      channels: 3,\n      labels: [\"r16\", \"g16\", \"b16\"]\n    },\n    gray: {\n      channels: 1,\n      labels: [\"gray\"]\n    }\n  };\n  colorConverter.exports = colorConversionMethods;\n  for (let colorMethodKey of Object.keys(colorConversionMethods)) {\n    if (!(\"channels\" in colorConversionMethods[colorMethodKey])) {\n      throw Error(\"missing channels property: \" + colorMethodKey);\n    }\n    if (!(\"labels\" in colorConversionMethods[colorMethodKey])) {\n      throw Error(\"missing channel labels property: \" + colorMethodKey);\n    }\n    if (colorConversionMethods[colorMethodKey].labels.length !== colorConversionMethods[colorMethodKey].channels) {\n      throw Error(\"channel and label counts mismatch: \" + colorMethodKey);\n    }\n    let {\n      channels: channelCount,\n      labels: channelLabels\n    } = colorConversionMethods[colorMethodKey];\n    delete colorConversionMethods[colorMethodKey].channels;\n    delete colorConversionMethods[colorMethodKey].labels;\n    Object.defineProperty(colorConversionMethods[colorMethodKey], \"channels\", {\n      value: channelCount\n    });\n    Object.defineProperty(colorConversionMethods[colorMethodKey], \"labels\", {\n      value: channelLabels\n    });\n  }\n  colorConversionMethods.rgb.hsl = function (_convertRgbToHsl) {\n    let normalizeRedValue = _convertRgbToHsl[0] / 255;\n    let saturation = _convertRgbToHsl[1] / 255;\n    let _blueChannel = _convertRgbToHsl[2] / 255;\n    let minColorValue = Math.min(normalizeRedValue, saturation, _blueChannel);\n    let _maxColorValue = Math.max(normalizeRedValue, saturation, _blueChannel);\n    let chromaDifference = _maxColorValue - minColorValue;\n    let _hue;\n    let _brightnessFactor;\n    if (_maxColorValue === minColorValue) {\n      _hue = 0;\n    } else if (normalizeRedValue === _maxColorValue) {\n      _hue = (saturation - _blueChannel) / chromaDifference;\n    } else if (saturation === _maxColorValue) {\n      _hue = 2 + (_blueChannel - normalizeRedValue) / chromaDifference;\n    } else if (_blueChannel === _maxColorValue) {\n      _hue = 4 + (normalizeRedValue - saturation) / chromaDifference;\n    }\n    _hue = Math.min(_hue * 60, 360);\n    if (_hue < 0) {\n      _hue += 360;\n    }\n    let lightness = (minColorValue + _maxColorValue) / 2;\n    if (_maxColorValue === minColorValue) {\n      _brightnessFactor = 0;\n    } else if (lightness <= 0.5) {\n      _brightnessFactor = chromaDifference / (_maxColorValue + minColorValue);\n    } else {\n      _brightnessFactor = chromaDifference / (2 - _maxColorValue - minColorValue);\n    }\n    return [_hue, _brightnessFactor * 100, lightness * 100];\n  };\n  colorConversionMethods.rgb.hsv = function (convertRgbToHsl) {\n    let hueCalculation;\n    let chromaValue;\n    let hue;\n    let hueValue;\n    let lightnessRatio;\n    let normalizedRed = convertRgbToHsl[0] / 255;\n    let greenChannelNormalized = convertRgbToHsl[1] / 255;\n    let convertRGBToHSV = convertRgbToHsl[2] / 255;\n    let maxColorValue = Math.max(normalizedRed, greenChannelNormalized, convertRGBToHSV);\n    let calculateColorDifference = maxColorValue - Math.min(normalizedRed, greenChannelNormalized, convertRGBToHSV);\n    let calculateHueAdjustment = function (colorAdjustmentFactor) {\n      return (maxColorValue - colorAdjustmentFactor) / 6 / calculateColorDifference + 0.5;\n    };\n    if (calculateColorDifference === 0) {\n      hueValue = 0;\n      lightnessRatio = 0;\n    } else {\n      lightnessRatio = calculateColorDifference / maxColorValue;\n      hueCalculation = calculateHueAdjustment(normalizedRed);\n      chromaValue = calculateHueAdjustment(greenChannelNormalized);\n      hue = calculateHueAdjustment(convertRGBToHSV);\n      if (normalizedRed === maxColorValue) {\n        hueValue = hue - chromaValue;\n      } else if (greenChannelNormalized === maxColorValue) {\n        hueValue = 0.3333333333333333 + hueCalculation - hue;\n      } else if (convertRGBToHSV === maxColorValue) {\n        hueValue = 0.6666666666666666 + chromaValue - hueCalculation;\n      }\n      if (hueValue < 0) {\n        hueValue += 1;\n      } else if (hueValue > 1) {\n        hueValue -= 1;\n      }\n    }\n    return [hueValue * 360, lightnessRatio * 100, maxColorValue * 100];\n  };\n  colorConversionMethods.rgb.hwb = function (convertRgbToHslAndCalculateBrightness) {\n    let firstColorValue = convertRgbToHslAndCalculateBrightness[0];\n    let _greenValue = convertRgbToHslAndCalculateBrightness[1];\n    let lightnessAdjustment = convertRgbToHslAndCalculateBrightness[2];\n    let ____hueValue = colorConversionMethods.rgb.hsl(convertRgbToHslAndCalculateBrightness)[0];\n    let minimumColorIntensity = Math.min(firstColorValue, Math.min(_greenValue, lightnessAdjustment)) * 0.00392156862745098;\n    lightnessAdjustment = 1 - Math.max(firstColorValue, Math.max(_greenValue, lightnessAdjustment)) * 0.00392156862745098;\n    return [____hueValue, minimumColorIntensity * 100, lightnessAdjustment * 100];\n  };\n  colorConversionMethods.rgb.cmyk = function (convertRgbToCmyk) {\n    let normalizedRedComponent = convertRgbToCmyk[0] / 255;\n    let ______greenComponent = convertRgbToCmyk[1] / 255;\n    let _blueComponent = convertRgbToCmyk[2] / 255;\n    let minimumComponentValue = Math.min(1 - normalizedRedComponent, 1 - ______greenComponent, 1 - _blueComponent);\n    let cyanValue = (1 - normalizedRedComponent - minimumComponentValue) / (1 - minimumComponentValue) || 0;\n    let yellowComponent = (1 - ______greenComponent - minimumComponentValue) / (1 - minimumComponentValue) || 0;\n    let cyanComponent = (1 - _blueComponent - minimumComponentValue) / (1 - minimumComponentValue) || 0;\n    return [cyanValue * 100, yellowComponent * 100, cyanComponent * 100, minimumComponentValue * 100];\n  };\n  function calculateSquaredDistance(_calculateSquaredDistance, pointB) {\n    return (_calculateSquaredDistance[0] - pointB[0]) ** 2 + (_calculateSquaredDistance[1] - pointB[1]) ** 2 + (_calculateSquaredDistance[2] - pointB[2]) ** 2;\n  }\n  colorConversionMethods.rgb.keyword = function (getClosestColor) {\n    let matchedColor = colorKeywordMapping[getClosestColor];\n    if (matchedColor) {\n      return matchedColor;\n    }\n    let closestMatchIndex = Infinity;\n    let closestColorKey;\n    for (let _colorKey of Object.keys(initializeColorMapping)) {\n      let ____colorValue = initializeColorMapping[_colorKey];\n      let closestColorDifference = calculateSquaredDistance(getClosestColor, ____colorValue);\n      if (closestColorDifference < closestMatchIndex) {\n        closestMatchIndex = closestColorDifference;\n        closestColorKey = _colorKey;\n      }\n    }\n    return closestColorKey;\n  };\n  colorConversionMethods.keyword.rgb = function (getElementById) {\n    return initializeColorMapping[getElementById];\n  };\n  colorConversionMethods.rgb.xyz = function (_convertRGBToXYZ) {\n    let redChannelNormalized = _convertRGBToXYZ[0] / 255;\n    let __greenComponent = _convertRGBToXYZ[1] / 255;\n    let __blueChannel = _convertRGBToXYZ[2] / 255;\n    if (redChannelNormalized > 0.04045) {\n      redChannelNormalized = ((redChannelNormalized + 0.055) / 1.055) ** 2.4;\n    } else {\n      redChannelNormalized = redChannelNormalized / 12.92;\n    }\n    if (__greenComponent > 0.04045) {\n      __greenComponent = ((__greenComponent + 0.055) / 1.055) ** 2.4;\n    } else {\n      __greenComponent = __greenComponent / 12.92;\n    }\n    if (__blueChannel > 0.04045) {\n      __blueChannel = ((__blueChannel + 0.055) / 1.055) ** 2.4;\n    } else {\n      __blueChannel = __blueChannel / 12.92;\n    }\n    let calculatedX = redChannelNormalized * 0.4124 + __greenComponent * 0.3576 + __blueChannel * 0.1805;\n    let luminanceComponent = redChannelNormalized * 0.2126 + __greenComponent * 0.7152 + __blueChannel * 0.0722;\n    let luminanceY = redChannelNormalized * 0.0193 + __greenComponent * 0.1192 + __blueChannel * 0.9505;\n    return [calculatedX * 100, luminanceComponent * 100, luminanceY * 100];\n  };\n  colorConversionMethods.rgb.lab = function (convertRgbToLab) {\n    let colorConversionResult = colorConversionMethods.rgb.xyz(convertRgbToLab);\n    let _normalizedRed = colorConversionResult[0];\n    let modifiedGreenChannel = colorConversionResult[1];\n    let blueComponent = colorConversionResult[2];\n    _normalizedRed /= 95.047;\n    modifiedGreenChannel /= 100;\n    blueComponent /= 108.883;\n    if (_normalizedRed > 0.008856) {\n      _normalizedRed = _normalizedRed ** 0.3333333333333333;\n    } else {\n      _normalizedRed = _normalizedRed * 7.787 + 0.13793103448275862;\n    }\n    if (modifiedGreenChannel > 0.008856) {\n      modifiedGreenChannel = modifiedGreenChannel ** 0.3333333333333333;\n    } else {\n      modifiedGreenChannel = modifiedGreenChannel * 7.787 + 0.13793103448275862;\n    }\n    if (blueComponent > 0.008856) {\n      blueComponent = blueComponent ** 0.3333333333333333;\n    } else {\n      blueComponent = blueComponent * 7.787 + 0.13793103448275862;\n    }\n    let lightnessValue = modifiedGreenChannel * 116 - 16;\n    let luminanceDifference = (_normalizedRed - modifiedGreenChannel) * 500;\n    let _chromaDifference = (modifiedGreenChannel - blueComponent) * 200;\n    return [lightnessValue, luminanceDifference, _chromaDifference];\n  };\n  colorConversionMethods.hsl.rgb = function (convertHSLtoRGB) {\n    let hueToRgbFraction = convertHSLtoRGB[0] / 360;\n    let brightnessFactor = convertHSLtoRGB[1] / 100;\n    let lightnessFactor = convertHSLtoRGB[2] / 100;\n    let greenValue;\n    let _hueAdjustment;\n    let colorValue;\n    if (brightnessFactor === 0) {\n      colorValue = lightnessFactor * 255;\n      return [colorValue, colorValue, colorValue];\n    }\n    if (lightnessFactor < 0.5) {\n      greenValue = lightnessFactor * (1 + brightnessFactor);\n    } else {\n      greenValue = lightnessFactor + brightnessFactor - lightnessFactor * brightnessFactor;\n    }\n    let valueAtHue = lightnessFactor * 2 - greenValue;\n    let __convertHSLToRGB = [0, 0, 0];\n    for (let hueIndex = 0; hueIndex < 3; hueIndex++) {\n      _hueAdjustment = hueToRgbFraction + -(hueIndex - 1) * 0.3333333333333333;\n      if (_hueAdjustment < 0) {\n        _hueAdjustment++;\n      }\n      if (_hueAdjustment > 1) {\n        _hueAdjustment--;\n      }\n      if (_hueAdjustment * 6 < 1) {\n        colorValue = valueAtHue + (greenValue - valueAtHue) * 6 * _hueAdjustment;\n      } else if (_hueAdjustment * 2 < 1) {\n        colorValue = greenValue;\n      } else if (_hueAdjustment * 3 < 2) {\n        colorValue = valueAtHue + (greenValue - valueAtHue) * (0.6666666666666666 - _hueAdjustment) * 6;\n      } else {\n        colorValue = valueAtHue;\n      }\n      __convertHSLToRGB[hueIndex] = colorValue * 255;\n    }\n    return __convertHSLToRGB;\n  };\n  colorConversionMethods.hsl.hsv = function (calculateAdjustedValues) {\n    let initialValue = calculateAdjustedValues[0];\n    let adjustedQuantity = calculateAdjustedValues[1] / 100;\n    let interestRateFactor = calculateAdjustedValues[2] / 100;\n    let adjustedQualityFactor = adjustedQuantity;\n    let effectiveInterestRate = Math.max(interestRateFactor, 0.01);\n    interestRateFactor *= 2;\n    if (interestRateFactor <= 1) {\n      adjustedQuantity *= interestRateFactor;\n    } else {\n      adjustedQuantity *= 2 - interestRateFactor;\n    }\n    if (effectiveInterestRate <= 1) {\n      adjustedQualityFactor *= effectiveInterestRate;\n    } else {\n      adjustedQualityFactor *= 2 - effectiveInterestRate;\n    }\n    let averageImpact = (interestRateFactor + adjustedQuantity) / 2;\n    let calculateAdjustmentFactor = interestRateFactor === 0 ? adjustedQualityFactor * 2 / (effectiveInterestRate + adjustedQualityFactor) : adjustedQuantity * 2 / (interestRateFactor + adjustedQuantity);\n    return [initialValue, calculateAdjustmentFactor * 100, averageImpact * 100];\n  };\n  colorConversionMethods.hsv.rgb = function (___convertHSLToRGB) {\n    let calculateColorComponents = ___convertHSLToRGB[0] / 60;\n    let saturationFactor = ___convertHSLToRGB[1] / 100;\n    let __intensity = ___convertHSLToRGB[2] / 100;\n    let hueSection = Math.floor(calculateColorComponents) % 6;\n    let fractionalPart = calculateColorComponents - Math.floor(calculateColorComponents);\n    let colorComponent = __intensity * 255 * (1 - saturationFactor);\n    let _intermediateColorValue = __intensity * 255 * (1 - saturationFactor * fractionalPart);\n    let colorComponentB = __intensity * 255 * (1 - saturationFactor * (1 - fractionalPart));\n    __intensity *= 255;\n    switch (hueSection) {\n      case 0:\n        return [__intensity, colorComponentB, colorComponent];\n      case 1:\n        return [_intermediateColorValue, __intensity, colorComponent];\n      case 2:\n        return [colorComponent, __intensity, colorComponentB];\n      case 3:\n        return [colorComponent, _intermediateColorValue, __intensity];\n      case 4:\n        return [colorComponentB, colorComponent, __intensity];\n      case 5:\n        return [__intensity, colorComponent, _intermediateColorValue];\n    }\n  };\n  colorConversionMethods.hsv.hsl = function (calculateFinancialMetrics) {\n    let _initialValue = calculateFinancialMetrics[0];\n    let discountRate = calculateFinancialMetrics[1] / 100;\n    let interestRate = calculateFinancialMetrics[2] / 100;\n    let minimumInterestRate = Math.max(interestRate, 0.01);\n    let adjustedEfficiency;\n    let calculatedYield;\n    calculatedYield = (2 - discountRate) * interestRate;\n    let adjustedValue = (2 - discountRate) * minimumInterestRate;\n    adjustedEfficiency = discountRate * minimumInterestRate;\n    if (adjustedValue <= 1) {\n      adjustedEfficiency /= adjustedValue;\n    } else {\n      adjustedEfficiency /= 2 - adjustedValue;\n    }\n    adjustedEfficiency = adjustedEfficiency || 0;\n    calculatedYield /= 2;\n    return [_initialValue, adjustedEfficiency * 100, calculatedYield * 100];\n  };\n  colorConversionMethods.hwb.rgb = function (convertHSLToRGB) {\n    let hueToRgbConversion = convertHSLToRGB[0] / 360;\n    let chromaticAdjustmentFactor = convertHSLToRGB[1] / 100;\n    let intensity = convertHSLToRGB[2] / 100;\n    let colorSum = chromaticAdjustmentFactor + intensity;\n    let hueAdjustment;\n    if (colorSum > 1) {\n      chromaticAdjustmentFactor /= colorSum;\n      intensity /= colorSum;\n    }\n    let hueSegment = Math.floor(hueToRgbConversion * 6);\n    let valueJ = 1 - intensity;\n    hueAdjustment = hueToRgbConversion * 6 - hueSegment;\n    if ((hueSegment & 1) !== 0) {\n      hueAdjustment = 1 - hueAdjustment;\n    }\n    let intermediateColorValue = chromaticAdjustmentFactor + hueAdjustment * (valueJ - chromaticAdjustmentFactor);\n    let valueAdjustment;\n    let hueAdjustmentValue;\n    let adjustedChromaticValue;\n    switch (hueSegment) {\n      default:\n      case 6:\n      case 0:\n        valueAdjustment = valueJ;\n        hueAdjustmentValue = intermediateColorValue;\n        adjustedChromaticValue = chromaticAdjustmentFactor;\n        break;\n      case 1:\n        valueAdjustment = intermediateColorValue;\n        hueAdjustmentValue = valueJ;\n        adjustedChromaticValue = chromaticAdjustmentFactor;\n        break;\n      case 2:\n        valueAdjustment = chromaticAdjustmentFactor;\n        hueAdjustmentValue = valueJ;\n        adjustedChromaticValue = intermediateColorValue;\n        break;\n      case 3:\n        valueAdjustment = chromaticAdjustmentFactor;\n        hueAdjustmentValue = intermediateColorValue;\n        adjustedChromaticValue = valueJ;\n        break;\n      case 4:\n        valueAdjustment = intermediateColorValue;\n        hueAdjustmentValue = chromaticAdjustmentFactor;\n        adjustedChromaticValue = valueJ;\n        break;\n      case 5:\n        valueAdjustment = valueJ;\n        hueAdjustmentValue = chromaticAdjustmentFactor;\n        adjustedChromaticValue = intermediateColorValue;\n        break;\n    }\n    return [valueAdjustment * 255, hueAdjustmentValue * 255, adjustedChromaticValue * 255];\n  };\n  colorConversionMethods.cmyk.rgb = function (convertToRgbScale) {\n    let baseColorMultiplier = convertToRgbScale[0] / 100;\n    let colorGreenComponent = convertToRgbScale[1] / 100;\n    let _____intensity = convertToRgbScale[2] / 100;\n    let transparencyFactor = convertToRgbScale[3] / 100;\n    let calculatedZValue = 1 - Math.min(1, baseColorMultiplier * (1 - transparencyFactor) + transparencyFactor);\n    let calculateAdjustedBrightness = 1 - Math.min(1, colorGreenComponent * (1 - transparencyFactor) + transparencyFactor);\n    let adjustedIntensity = 1 - Math.min(1, _____intensity * (1 - transparencyFactor) + transparencyFactor);\n    return [calculatedZValue * 255, calculateAdjustedBrightness * 255, adjustedIntensity * 255];\n  };\n  colorConversionMethods.xyz.rgb = function (convertRGBToXYZ) {\n    let convertColorComponent = convertRGBToXYZ[0] / 100;\n    let greenComponent = convertRGBToXYZ[1] / 100;\n    let _intensity = convertRGBToXYZ[2] / 100;\n    let linearizedRedValue;\n    let blueChannel;\n    let Luminance;\n    linearizedRedValue = convertColorComponent * 3.2406 + greenComponent * -1.5372 + _intensity * -0.4986;\n    blueChannel = convertColorComponent * -0.9689 + greenComponent * 1.8758 + _intensity * 0.0415;\n    Luminance = convertColorComponent * 0.0557 + greenComponent * -0.204 + _intensity * 1.057;\n    if (linearizedRedValue > 0.0031308) {\n      linearizedRedValue = linearizedRedValue ** 0.4166666666666667 * 1.055 - 0.055;\n    } else {\n      linearizedRedValue = linearizedRedValue * 12.92;\n    }\n    if (blueChannel > 0.0031308) {\n      blueChannel = blueChannel ** 0.4166666666666667 * 1.055 - 0.055;\n    } else {\n      blueChannel = blueChannel * 12.92;\n    }\n    if (Luminance > 0.0031308) {\n      Luminance = Luminance ** 0.4166666666666667 * 1.055 - 0.055;\n    } else {\n      Luminance = Luminance * 12.92;\n    }\n    linearizedRedValue = Math.min(Math.max(0, linearizedRedValue), 1);\n    blueChannel = Math.min(Math.max(0, blueChannel), 1);\n    Luminance = Math.min(Math.max(0, Luminance), 1);\n    return [linearizedRedValue * 255, blueChannel * 255, Luminance * 255];\n  };\n  colorConversionMethods.xyz.lab = function (convertRgbToCieLab) {\n    let referenceWhitePoint = convertRgbToCieLab[0];\n    let ___greenComponent = convertRgbToCieLab[1];\n    let IntensityValue = convertRgbToCieLab[2];\n    referenceWhitePoint /= 95.047;\n    ___greenComponent /= 100;\n    IntensityValue /= 108.883;\n    if (referenceWhitePoint > 0.008856) {\n      referenceWhitePoint = referenceWhitePoint ** 0.3333333333333333;\n    } else {\n      referenceWhitePoint = referenceWhitePoint * 7.787 + 0.13793103448275862;\n    }\n    if (___greenComponent > 0.008856) {\n      ___greenComponent = ___greenComponent ** 0.3333333333333333;\n    } else {\n      ___greenComponent = ___greenComponent * 7.787 + 0.13793103448275862;\n    }\n    if (IntensityValue > 0.008856) {\n      IntensityValue = IntensityValue ** 0.3333333333333333;\n    } else {\n      IntensityValue = IntensityValue * 7.787 + 0.13793103448275862;\n    }\n    let computedLuminance = ___greenComponent * 116 - 16;\n    let __chromaDifference = (referenceWhitePoint - ___greenComponent) * 500;\n    let differenceOfQandI = (___greenComponent - IntensityValue) * 200;\n    return [computedLuminance, __chromaDifference, differenceOfQandI];\n  };\n  colorConversionMethods.lab.xyz = function (convertColorToXYZ) {\n    let luminanceValue = convertColorToXYZ[0];\n    let _greenComponent = convertColorToXYZ[1];\n    let _lightnessComponent = convertColorToXYZ[2];\n    let calculatedGreenValue;\n    let normalizedValue;\n    let _lightness;\n    normalizedValue = (luminanceValue + 16) / 116;\n    calculatedGreenValue = _greenComponent / 500 + normalizedValue;\n    _lightness = normalizedValue - _lightnessComponent / 200;\n    let ZCubed = normalizedValue ** 3;\n    let calculateGammaValue = calculatedGreenValue ** 3;\n    let Y_Cube = _lightness ** 3;\n    if (ZCubed > 0.008856) {\n      normalizedValue = ZCubed;\n    } else {\n      normalizedValue = (normalizedValue - 0.13793103448275862) / 7.787;\n    }\n    if (calculateGammaValue > 0.008856) {\n      calculatedGreenValue = calculateGammaValue;\n    } else {\n      calculatedGreenValue = (calculatedGreenValue - 0.13793103448275862) / 7.787;\n    }\n    if (Y_Cube > 0.008856) {\n      _lightness = Y_Cube;\n    } else {\n      _lightness = (_lightness - 0.13793103448275862) / 7.787;\n    }\n    calculatedGreenValue *= 95.047;\n    normalizedValue *= 100;\n    _lightness *= 108.883;\n    return [calculatedGreenValue, normalizedValue, _lightness];\n  };\n  colorConversionMethods.lab.lch = function (calculatePolarCoordinates) {\n    let firstElement = calculatePolarCoordinates[0];\n    let horizontalDistance = calculatePolarCoordinates[1];\n    let inputYCoordinate = calculatePolarCoordinates[2];\n    let angleInDegrees;\n    angleInDegrees = Math.atan2(inputYCoordinate, horizontalDistance) * 360 / 2 / Math.PI;\n    if (angleInDegrees < 0) {\n      angleInDegrees += 360;\n    }\n    let magnitude = Math.sqrt(horizontalDistance * horizontalDistance + inputYCoordinate * inputYCoordinate);\n    return [firstElement, magnitude, angleInDegrees];\n  };\n  colorConversionMethods.lch.lab = function (processCoordinates) {\n    let __initialValue = processCoordinates[0];\n    let radius = processCoordinates[1];\n    let angleInRadians = processCoordinates[2] / 360 * 2 * Math.PI;\n    let horizontalComponent = radius * Math.cos(angleInRadians);\n    let yCoordinate = radius * Math.sin(angleInRadians);\n    return [__initialValue, horizontalComponent, yCoordinate];\n  };\n  colorConversionMethods.rgb.ansi16 = function (colorTransformFunction, optionalBrightnessValue = null) {\n    let [redChannelValue, ____greenComponent, _____greenComponent] = colorTransformFunction;\n    let ___hueValue = optionalBrightnessValue === null ? colorConversionMethods.rgb.hsv(colorTransformFunction)[2] : optionalBrightnessValue;\n    ___hueValue = Math.round(___hueValue / 50);\n    if (___hueValue === 0) {\n      return 30;\n    }\n    let calculatedColorValue = 30 + (Math.round(_____greenComponent / 255) << 2 | Math.round(____greenComponent / 255) << 1 | Math.round(redChannelValue / 255));\n    if (___hueValue === 2) {\n      calculatedColorValue += 60;\n    }\n    return calculatedColorValue;\n  };\n  colorConversionMethods.hsv.ansi16 = function (hsvToAnsi16Conversion) {\n    return colorConversionMethods.rgb.ansi16(colorConversionMethods.hsv.rgb(hsvToAnsi16Conversion), hsvToAnsi16Conversion[2]);\n  };\n  colorConversionMethods.rgb.ansi256 = function (processColorValues) {\n    let firstValue = processColorValues[0];\n    let secondValue = processColorValues[1];\n    let valueC = processColorValues[2];\n    if (firstValue === secondValue && secondValue === valueC) {\n      if (firstValue < 8) {\n        return 16;\n      }\n      if (firstValue > 248) {\n        return 231;\n      }\n      return Math.round((firstValue - 8) / 247 * 24) + 232;\n    }\n    return 16 + Math.round(firstValue / 255 * 5) * 36 + Math.round(secondValue / 255 * 5) * 6 + Math.round(valueC / 255 * 5);\n  };\n  colorConversionMethods.ansi16.rgb = function (_calculateColorComponents) {\n    let lastDigit = _calculateColorComponents % 10;\n    if (lastDigit === 0 || lastDigit === 7) {\n      if (_calculateColorComponents > 50) {\n        lastDigit += 3.5;\n      }\n      lastDigit = lastDigit / 10.5 * 255;\n      return [lastDigit, lastDigit, lastDigit];\n    }\n    let __brightnessFactor = (~~(_calculateColorComponents > 50) + 1) * 0.5;\n    let ____intensity = (lastDigit & 1) * __brightnessFactor * 255;\n    let greenIntensity = (lastDigit >> 1 & 1) * __brightnessFactor * 255;\n    let blueChannelValue = (lastDigit >> 2 & 1) * __brightnessFactor * 255;\n    return [____intensity, greenIntensity, blueChannelValue];\n  };\n  colorConversionMethods.ansi256.rgb = function (calculateColorValues) {\n    if (calculateColorValues >= 232) {\n      let calculatedValue = (calculateColorValues - 232) * 10 + 8;\n      return [calculatedValue, calculatedValue, calculatedValue];\n    }\n    calculateColorValues -= 16;\n    let remainderAfterDividingBy36;\n    let calculatedColorComponent = Math.floor(calculateColorValues / 36) / 5 * 255;\n    let ______intensity = Math.floor((remainderAfterDividingBy36 = calculateColorValues % 36) / 6) / 5 * 255;\n    let calculateGreenChannelValue = remainderAfterDividingBy36 % 6 / 5 * 255;\n    return [calculatedColorComponent, ______intensity, calculateGreenChannelValue];\n  };\n  colorConversionMethods.rgb.hex = function (convertRgbToHex) {\n    let hexColorCode = (((Math.round(convertRgbToHex[0]) & 255) << 16) + ((Math.round(convertRgbToHex[1]) & 255) << 8) + (Math.round(convertRgbToHex[2]) & 255)).toString(16).toUpperCase();\n    return \"000000\".substring(hexColorCode.length) + hexColorCode;\n  };\n  colorConversionMethods.hex.rgb = function (convertHexToRgb) {\n    let colorMatch = convertHexToRgb.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n    if (!colorMatch) {\n      return [0, 0, 0];\n    }\n    let hexColor = colorMatch[0];\n    if (colorMatch[0].length === 3) {\n      hexColor = hexColor.split(\"\").map(sumOfJ => {\n        return sumOfJ + sumOfJ;\n      }).join(\"\");\n    }\n    let hexToRgbInt = parseInt(hexColor, 16);\n    let redValue = hexToRgbInt >> 16 & 255;\n    let _greenChannel = hexToRgbInt >> 8 & 255;\n    let ___blueChannel = hexToRgbInt & 255;\n    return [redValue, _greenChannel, ___blueChannel];\n  };\n  colorConversionMethods.rgb.hcg = function (convertRGBtoHSL) {\n    let __normalizedRed = convertRGBtoHSL[0] / 255;\n    let greenChannel = convertRGBtoHSL[1] / 255;\n    let ___intensity = convertRGBtoHSL[2] / 255;\n    let calculateHueSaturationLightness = Math.max(Math.max(__normalizedRed, greenChannel), ___intensity);\n    let minimumColorValue = Math.min(Math.min(__normalizedRed, greenChannel), ___intensity);\n    let ___chromaDifference = calculateHueSaturationLightness - minimumColorValue;\n    let __valueAdjustment;\n    let __hueValue;\n    if (___chromaDifference < 1) {\n      __valueAdjustment = minimumColorValue / (1 - ___chromaDifference);\n    } else {\n      __valueAdjustment = 0;\n    }\n    if (___chromaDifference <= 0) {\n      __hueValue = 0;\n    } else if (calculateHueSaturationLightness === __normalizedRed) {\n      __hueValue = (greenChannel - ___intensity) / ___chromaDifference % 6;\n    } else if (calculateHueSaturationLightness === greenChannel) {\n      __hueValue = 2 + (___intensity - __normalizedRed) / ___chromaDifference;\n    } else {\n      __hueValue = 4 + (__normalizedRed - greenChannel) / ___chromaDifference;\n    }\n    __hueValue /= 6;\n    __hueValue %= 1;\n    return [__hueValue * 360, ___chromaDifference * 100, __valueAdjustment * 100];\n  };\n  colorConversionMethods.hsl.hcg = function (calculateInterestAndGrowth) {\n    let baseValue = calculateInterestAndGrowth[1] / 100;\n    let ratio = calculateInterestAndGrowth[2] / 100;\n    let influenceFactor = ratio < 0.5 ? baseValue * 2 * ratio : baseValue * 2 * (1 - ratio);\n    let _calculateAdjustmentFactor = 0;\n    if (influenceFactor < 1) {\n      _calculateAdjustmentFactor = (ratio - influenceFactor * 0.5) / (1 - influenceFactor);\n    }\n    return [calculateInterestAndGrowth[0], influenceFactor * 100, _calculateAdjustmentFactor * 100];\n  };\n  colorConversionMethods.hsv.hcg = function (calculateInvestmentGrowth) {\n    let calculateAdjustedValue = calculateInvestmentGrowth[1] / 100;\n    let __interestRate = calculateInvestmentGrowth[2] / 100;\n    let investmentAmount = calculateAdjustedValue * __interestRate;\n    let calculateGrowthFactor = 0;\n    if (investmentAmount < 1) {\n      calculateGrowthFactor = (__interestRate - investmentAmount) / (1 - investmentAmount);\n    }\n    return [calculateInvestmentGrowth[0], investmentAmount * 100, calculateGrowthFactor * 100];\n  };\n  colorConversionMethods.hcg.rgb = function (_convertHSLToRGB) {\n    let _hueToRgbConversion = _convertHSLToRGB[0] / 360;\n    let saturationRatio = _convertHSLToRGB[1] / 100;\n    let lightnessComponent = _convertHSLToRGB[2] / 100;\n    if (saturationRatio === 0) {\n      return [lightnessComponent * 255, lightnessComponent * 255, lightnessComponent * 255];\n    }\n    let hueToRGBConversion = [0, 0, 0];\n    let _hueSegment = _hueToRgbConversion % 1 * 6;\n    let fractionalComponent = _hueSegment % 1;\n    let _valueAdjustment = 1 - fractionalComponent;\n    let computeColorFromHSL = 0;\n    switch (Math.floor(_hueSegment)) {\n      case 0:\n        hueToRGBConversion[0] = 1;\n        hueToRGBConversion[1] = fractionalComponent;\n        hueToRGBConversion[2] = 0;\n        break;\n      case 1:\n        hueToRGBConversion[0] = _valueAdjustment;\n        hueToRGBConversion[1] = 1;\n        hueToRGBConversion[2] = 0;\n        break;\n      case 2:\n        hueToRGBConversion[0] = 0;\n        hueToRGBConversion[1] = 1;\n        hueToRGBConversion[2] = fractionalComponent;\n        break;\n      case 3:\n        hueToRGBConversion[0] = 0;\n        hueToRGBConversion[1] = _valueAdjustment;\n        hueToRGBConversion[2] = 1;\n        break;\n      case 4:\n        hueToRGBConversion[0] = fractionalComponent;\n        hueToRGBConversion[1] = 0;\n        hueToRGBConversion[2] = 1;\n        break;\n      default:\n        hueToRGBConversion[0] = 1;\n        hueToRGBConversion[1] = 0;\n        hueToRGBConversion[2] = _valueAdjustment;\n    }\n    computeColorFromHSL = (1 - saturationRatio) * lightnessComponent;\n    return [(saturationRatio * hueToRGBConversion[0] + computeColorFromHSL) * 255, (saturationRatio * hueToRGBConversion[1] + computeColorFromHSL) * 255, (saturationRatio * hueToRGBConversion[2] + computeColorFromHSL) * 255];\n  };\n  colorConversionMethods.hcg.hsv = function (calculateFundingRatios) {\n    let calculateProbability = calculateFundingRatios[1] / 100;\n    let calculateConversionRate = calculateFundingRatios[2] / 100;\n    let investmentIndex = calculateProbability + calculateConversionRate * (1 - calculateProbability);\n    let calculateProfitShare = 0;\n    if (investmentIndex > 0) {\n      calculateProfitShare = calculateProbability / investmentIndex;\n    }\n    return [calculateFundingRatios[0], calculateProfitShare * 100, investmentIndex * 100];\n  };\n  colorConversionMethods.hcg.hsl = function (calculateGrowthIndex) {\n    let _discountRate = calculateGrowthIndex[1] / 100;\n    let _interestRate = calculateGrowthIndex[2] / 100 * (1 - _discountRate) + _discountRate * 0.5;\n    let gainRatio = 0;\n    if (_interestRate > 0 && _interestRate < 0.5) {\n      gainRatio = _discountRate / (_interestRate * 2);\n    } else if (_interestRate >= 0.5 && _interestRate < 1) {\n      gainRatio = _discountRate / ((1 - _interestRate) * 2);\n    }\n    return [calculateGrowthIndex[0], gainRatio * 100, _interestRate * 100];\n  };\n  colorConversionMethods.hcg.hwb = function (calculateInvestmentReturns) {\n    let calculateAdjustedRate = calculateInvestmentReturns[1] / 100;\n    let investmentRate = calculateInvestmentReturns[2] / 100;\n    let influencedPercentage = calculateAdjustedRate + investmentRate * (1 - calculateAdjustedRate);\n    return [calculateInvestmentReturns[0], (influencedPercentage - calculateAdjustedRate) * 100, (1 - influencedPercentage) * 100];\n  };\n  colorConversionMethods.hwb.hcg = function (calculateValues) {\n    let decimalsFromPercent = calculateValues[1] / 100;\n    let investmentAdjustment = 1 - calculateValues[2] / 100;\n    let calculateNetEffect = investmentAdjustment - decimalsFromPercent;\n    let _calculatedValue = 0;\n    if (calculateNetEffect < 1) {\n      _calculatedValue = (investmentAdjustment - calculateNetEffect) / (1 - calculateNetEffect);\n    }\n    return [calculateValues[0], calculateNetEffect * 100, _calculatedValue * 100];\n  };\n  colorConversionMethods.apple.rgb = function (convertRGBTo255Scale) {\n    return [convertRGBTo255Scale[0] / 65535 * 255, convertRGBTo255Scale[1] / 65535 * 255, convertRGBTo255Scale[2] / 65535 * 255];\n  };\n  colorConversionMethods.rgb.apple = function (convertRGBToMaxColorValue) {\n    return [convertRGBToMaxColorValue[0] / 255 * 65535, convertRGBToMaxColorValue[1] / 255 * 65535, convertRGBToMaxColorValue[2] / 255 * 65535];\n  };\n  colorConversionMethods.gray.rgb = function (convertToRGB) {\n    return [convertToRGB[0] / 100 * 255, convertToRGB[0] / 100 * 255, convertToRGB[0] / 100 * 255];\n  };\n  colorConversionMethods.gray.hsl = function (getCoordinateX) {\n    return [0, 0, getCoordinateX[0]];\n  };\n  colorConversionMethods.gray.hsv = colorConversionMethods.gray.hsl;\n  colorConversionMethods.gray.hwb = function (_____inputArray) {\n    return [0, 100, _____inputArray[0]];\n  };\n  colorConversionMethods.gray.cmyk = function (____inputArray) {\n    return [0, 0, 0, ____inputArray[0]];\n  };\n  colorConversionMethods.gray.lab = function (firstElementArray) {\n    return [firstElementArray[0], 0, 0];\n  };\n  colorConversionMethods.gray.hex = function (convertToHexColor) {\n    let calculateColorValue = Math.round(convertToHexColor[0] / 100 * 255) & 255;\n    let _hexColor = ((calculateColorValue << 16) + (calculateColorValue << 8) + calculateColorValue).toString(16).toUpperCase();\n    return \"000000\".substring(_hexColor.length) + _hexColor;\n  };\n  colorConversionMethods.rgb.gray = function (calculateAverageBrightness) {\n    return [(calculateAverageBrightness[0] + calculateAverageBrightness[1] + calculateAverageBrightness[2]) / 3 / 255 * 100];\n  };\n});\nvar _________________________________________________initializeDevToolsConnection = z((analyzeGraphTraversal, exportShortestPaths) => {\n  var graphAdjacencyList = ____________________initializeDevelopmentTools();\n  function initializeGraphNodes() {\n    let initializeNodeDistances = {};\n    let nodeKeys = Object.keys(graphAdjacencyList);\n    for (let numberOfVertices = nodeKeys.length, ______________________________index = 0; ______________________________index < numberOfVertices; ______________________________index++) {\n      initializeNodeDistances[nodeKeys[______________________________index]] = {\n        distance: -1,\n        parent: null\n      };\n    }\n    return initializeNodeDistances;\n  }\n  function traverseGraphFromNode(startNode) {\n    let graphNodes = initializeGraphNodes();\n    let queue = [startNode];\n    graphNodes[startNode].distance = 0;\n    while (queue.length) {\n      let currentNode = queue.pop();\n      let adjacentNodeKeys = Object.keys(graphAdjacencyList[currentNode]);\n      for (let totalAdjacentNodes = adjacentNodeKeys.length, ________index = 0; ________index < totalAdjacentNodes; ________index++) {\n        let currentAdjacentNodeKey = adjacentNodeKeys[________index];\n        let adjacentNode = graphNodes[currentAdjacentNodeKey];\n        if (adjacentNode.distance === -1) {\n          adjacentNode.distance = graphNodes[currentNode].distance + 1;\n          adjacentNode.parent = currentNode;\n          queue.unshift(currentAdjacentNodeKey);\n        }\n      }\n    }\n    return graphNodes;\n  }\n  function composeAndApply(processAndTransform, transformAndApply) {\n    return function (_____inputData) {\n      return transformAndApply(processAndTransform(_____inputData));\n    };\n  }\n  function generateConversionPath(getConversionPath, nodeInfo) {\n    let conversionPath = [nodeInfo[getConversionPath].parent, getConversionPath];\n    let conversionPathData = graphAdjacencyList[nodeInfo[getConversionPath].parent][getConversionPath];\n    let currentNodeParent = nodeInfo[getConversionPath].parent;\n    while (nodeInfo[currentNodeParent].parent) {\n      conversionPath.unshift(nodeInfo[currentNodeParent].parent);\n      conversionPathData = composeAndApply(graphAdjacencyList[nodeInfo[currentNodeParent].parent][currentNodeParent], conversionPathData);\n      currentNodeParent = nodeInfo[currentNodeParent].parent;\n    }\n    conversionPathData.conversion = conversionPath;\n    return conversionPathData;\n  }\n  exportShortestPaths.exports = function (filterParentKeys) {\n    let transformData = traverseGraphFromNode(filterParentKeys);\n    let parentChildRelations = {};\n    let keysArray = Object.keys(transformData);\n    for (let lengthOfKeys = keysArray.length, ______currentIndex = 0; ______currentIndex < lengthOfKeys; ______currentIndex++) {\n      let currentKey = keysArray[______currentIndex];\n      if (transformData[currentKey].parent === null) {\n        continue;\n      }\n      parentChildRelations[currentKey] = generateConversionPath(currentKey, transformData);\n    }\n    return parentChildRelations;\n  };\n});\nvar ______________________________________________________initializeDevToolsConnection = z((initializeSignalValues, exportedData) => {\n  var developmentTools = ____________________initializeDevelopmentTools();\n  var ________________________________________________________initializeDevToolsConnection = _________________________________________________initializeDevToolsConnection();\n  var dataProcessor = {};\n  var developmentToolKeys = Object.keys(developmentTools);\n  function createFunctionWrapper(_____callbackFunction) {\n    let callbackWrapper = function (..._______inputArray) {\n      let ________inputArray = _______inputArray[0];\n      if (________inputArray === undefined || ________inputArray === null) {\n        return ________inputArray;\n      }\n      if (________inputArray.length > 1) {\n        _______inputArray = ________inputArray;\n      }\n      return _____callbackFunction(_______inputArray);\n    };\n    if (\"conversion\" in _____callbackFunction) {\n      callbackWrapper.conversion = _____callbackFunction.conversion;\n    }\n    return callbackWrapper;\n  }\n  function createRounder(__processInput) {\n    let processAndRoundInputs = function (...inputValues) {\n      let ______inputData = inputValues[0];\n      if (______inputData === undefined || ______inputData === null) {\n        return ______inputData;\n      }\n      if (______inputData.length > 1) {\n        inputValues = ______inputData;\n      }\n      let processedInput = __processInput(inputValues);\n      if (typeof processedInput === \"object\") {\n        for (let arrayLength = processedInput.length, ________________index = 0; ________________index < arrayLength; ________________index++) {\n          processedInput[________________index] = Math.round(processedInput[________________index]);\n        }\n      }\n      return processedInput;\n    };\n    if (\"conversion\" in __processInput) {\n      processAndRoundInputs.conversion = __processInput.conversion;\n    }\n    return processAndRoundInputs;\n  }\n  developmentToolKeys.forEach(processDataForChannel => {\n    dataProcessor[processDataForChannel] = {};\n    Object.defineProperty(dataProcessor[processDataForChannel], \"channels\", {\n      value: developmentTools[processDataForChannel].channels\n    });\n    Object.defineProperty(dataProcessor[processDataForChannel], \"labels\", {\n      value: developmentTools[processDataForChannel].labels\n    });\n    let processedData = ________________________________________________________initializeDevToolsConnection(processDataForChannel);\n    Object.keys(processedData).forEach(_channelIndex => {\n      let processedDataForIndex = processedData[_channelIndex];\n      dataProcessor[processDataForChannel][_channelIndex] = createRounder(processedDataForIndex);\n      dataProcessor[processDataForChannel][_channelIndex].raw = createFunctionWrapper(processedDataForIndex);\n    });\n  });\n  exportedData.exports = dataProcessor;\n});\nvar ______________initializeReactDevToolsConnection = z((colorModelConstructor, ColorConverter) => {\n  var _______________________________________________________initializeDevToolsConnection = ________________________________________________initializeDevToolsConnection();\n  var colorModelInfo = ______________________________________________________initializeDevToolsConnection();\n  var colorModelNames = [\"keyword\", \"gray\", \"hex\"];\n  var colorLabelMap = {};\n  for (let countryCode of Object.keys(colorModelInfo)) {\n    colorLabelMap[[...colorModelInfo[countryCode].labels].sort().join(\"\")] = countryCode;\n  }\n  var colorModelTransformations = {};\n  function BF(_ColorConverter, colorModel) {\n    if (!(this instanceof BF)) {\n      return new BF(_ColorConverter, colorModel);\n    }\n    if (colorModel && colorModel in colorModelNames) {\n      colorModel = null;\n    }\n    if (colorModel && !(colorModel in colorModelInfo)) {\n      throw Error(\"Unknown model: \" + colorModel);\n    }\n    let ___________index;\n    let I;\n    if (_ColorConverter == null) {\n      this.model = \"rgb\";\n      this.color = [0, 0, 0];\n      this.valpha = 1;\n    } else if (_ColorConverter instanceof BF) {\n      this.model = _ColorConverter.model;\n      this.color = [..._ColorConverter.color];\n      this.valpha = _ColorConverter.valpha;\n    } else if (typeof _ColorConverter === \"string\") {\n      let colorInfo = _______________________________________________________initializeDevToolsConnection.get(_ColorConverter);\n      if (colorInfo === null) {\n        throw Error(\"Unable to parse color from string: \" + _ColorConverter);\n      }\n      this.model = colorInfo.model;\n      I = colorModelInfo[this.model].channels;\n      this.color = colorInfo.value.slice(0, I);\n      this.valpha = typeof colorInfo.value[I] === \"number\" ? colorInfo.value[I] : 1;\n    } else if (_ColorConverter.length > 0) {\n      this.model = colorModel || \"rgb\";\n      I = colorModelInfo[this.model].channels;\n      let parsedColor = Array.prototype.slice.call(_ColorConverter, 0, I);\n      this.color = replaceNonNumericWithZero(parsedColor, I);\n      this.valpha = typeof _ColorConverter[I] === \"number\" ? _ColorConverter[I] : 1;\n    } else if (typeof _ColorConverter === \"number\") {\n      this.model = \"rgb\";\n      this.color = [_ColorConverter >> 16 & 255, _ColorConverter >> 8 & 255, _ColorConverter & 255];\n      this.valpha = 1;\n    } else {\n      this.valpha = 1;\n      let colorComponentKeys = Object.keys(_ColorConverter);\n      if (\"alpha\" in _ColorConverter) {\n        colorComponentKeys.splice(colorComponentKeys.indexOf(\"alpha\"), 1);\n        this.valpha = typeof _ColorConverter.alpha === \"number\" ? _ColorConverter.alpha : 0;\n      }\n      let colorComponentKeyString = colorComponentKeys.sort().join(\"\");\n      if (!(colorComponentKeyString in colorLabelMap)) {\n        throw Error(\"Unable to parse color from object: \" + JSON.stringify(_ColorConverter));\n      }\n      this.model = colorLabelMap[colorComponentKeyString];\n      let {\n        labels: colorComponentLabels\n      } = colorModelInfo[this.model];\n      let ___colorComponents = [];\n      for (___________index = 0; ___________index < colorComponentLabels.length; ___________index++) {\n        ___colorComponents.push(_ColorConverter[colorComponentLabels[___________index]]);\n      }\n      this.color = replaceNonNumericWithZero(___colorComponents);\n    }\n    if (colorModelTransformations[this.model]) {\n      I = colorModelInfo[this.model].channels;\n      for (___________index = 0; ___________index < I; ___________index++) {\n        let colorTransformationFunction = colorModelTransformations[this.model][___________index];\n        if (colorTransformationFunction) {\n          this.color[___________index] = colorTransformationFunction(this.color[___________index]);\n        }\n      }\n    }\n    this.valpha = Math.max(0, Math.min(1, this.valpha));\n    if (Object.freeze) {\n      Object.freeze(this);\n    }\n  }\n  BF.prototype = {\n    toString() {\n      return this.string();\n    },\n    toJSON() {\n      return this[this.model]();\n    },\n    string(convertColor) {\n      let getRoundedColor = this.model in _______________________________________________________initializeDevToolsConnection.to ? this : this.rgb();\n      getRoundedColor = getRoundedColor.round(typeof convertColor === \"number\" ? convertColor : 1);\n      let computedColorWithAlpha = getRoundedColor.valpha === 1 ? getRoundedColor.color : [...getRoundedColor.color, this.valpha];\n      return _______________________________________________________initializeDevToolsConnection.to[getRoundedColor.model](computedColorWithAlpha);\n    },\n    percentString(percentString) {\n      let roundedRgbValue = this.rgb().round(typeof percentString === \"number\" ? percentString : 1);\n      let colorWithAlpha = roundedRgbValue.valpha === 1 ? roundedRgbValue.color : [...roundedRgbValue.color, this.valpha];\n      return _______________________________________________________initializeDevToolsConnection.to.rgb.percent(colorWithAlpha);\n    },\n    array() {\n      if (this.valpha === 1) {\n        return [...this.color];\n      } else {\n        return [...this.color, this.valpha];\n      }\n    },\n    object() {\n      let _colorMapping = {};\n      let {\n        channels: _channelCount\n      } = colorModelInfo[this.model];\n      let {\n        labels: labels\n      } = colorModelInfo[this.model];\n      for (let __channelIndex = 0; __channelIndex < _channelCount; __channelIndex++) {\n        _colorMapping[labels[__channelIndex]] = this.color[__channelIndex];\n      }\n      if (this.valpha !== 1) {\n        _colorMapping.alpha = this.valpha;\n      }\n      return _colorMapping;\n    },\n    unitArray() {\n      let normalizedColorArray = this.rgb().color;\n      normalizedColorArray[0] /= 255;\n      normalizedColorArray[1] /= 255;\n      normalizedColorArray[2] /= 255;\n      if (this.valpha !== 1) {\n        normalizedColorArray.push(this.valpha);\n      }\n      return normalizedColorArray;\n    },\n    unitObject() {\n      let normalizedColorObject = this.rgb().object();\n      normalizedColorObject.r /= 255;\n      normalizedColorObject.g /= 255;\n      normalizedColorObject.b /= 255;\n      if (this.valpha !== 1) {\n        normalizedColorObject.alpha = this.valpha;\n      }\n      return normalizedColorObject;\n    },\n    round(roundValue) {\n      roundValue = Math.max(roundValue || 0, 0);\n      return new BF([...this.color.map(createDecimalFormatter(roundValue)), this.valpha], this.model);\n    },\n    alpha(___alphaValue) {\n      if (___alphaValue !== undefined) {\n        return new BF([...this.color, Math.max(0, Math.min(1, ___alphaValue))], this.model);\n      }\n      return this.valpha;\n    },\n    red: createColorTransformationFunction(\"rgb\", 0, clampValueWithinRange(255)),\n    green: createColorTransformationFunction(\"rgb\", 1, clampValueWithinRange(255)),\n    blue: createColorTransformationFunction(\"rgb\", 2, clampValueWithinRange(255)),\n    hue: createColorTransformationFunction([\"hsl\", \"hsv\", \"hsl\", \"hwb\", \"hcg\"], 0, normalizeAngle => (normalizeAngle % 360 + 360) % 360),\n    saturationl: createColorTransformationFunction(\"hsl\", 1, clampValueWithinRange(100)),\n    lightness: createColorTransformationFunction(\"hsl\", 2, clampValueWithinRange(100)),\n    saturationv: createColorTransformationFunction(\"hsv\", 1, clampValueWithinRange(100)),\n    value: createColorTransformationFunction(\"hsv\", 2, clampValueWithinRange(100)),\n    chroma: createColorTransformationFunction(\"hcg\", 1, clampValueWithinRange(100)),\n    gray: createColorTransformationFunction(\"hcg\", 2, clampValueWithinRange(100)),\n    white: createColorTransformationFunction(\"hwb\", 1, clampValueWithinRange(100)),\n    wblack: createColorTransformationFunction(\"hwb\", 2, clampValueWithinRange(100)),\n    cyan: createColorTransformationFunction(\"cmyk\", 0, clampValueWithinRange(100)),\n    magenta: createColorTransformationFunction(\"cmyk\", 1, clampValueWithinRange(100)),\n    yellow: createColorTransformationFunction(\"cmyk\", 2, clampValueWithinRange(100)),\n    black: createColorTransformationFunction(\"cmyk\", 3, clampValueWithinRange(100)),\n    x: createColorTransformationFunction(\"xyz\", 0, clampValueWithinRange(95.047)),\n    y: createColorTransformationFunction(\"xyz\", 1, clampValueWithinRange(100)),\n    z: createColorTransformationFunction(\"xyz\", 2, clampValueWithinRange(108.833)),\n    l: createColorTransformationFunction(\"lab\", 0, clampValueWithinRange(100)),\n    a: createColorTransformationFunction(\"lab\", 1),\n    b: createColorTransformationFunction(\"lab\", 2),\n    keyword(inputKeyword) {\n      if (inputKeyword !== undefined) {\n        return new BF(inputKeyword);\n      }\n      return colorModelInfo[this.model].keyword(this.color);\n    },\n    hex(__convertToHex) {\n      if (__convertToHex !== undefined) {\n        return new BF(__convertToHex);\n      }\n      return _______________________________________________________initializeDevToolsConnection.to.hex(this.rgb().round().color);\n    },\n    hexa(convertToHex) {\n      if (convertToHex !== undefined) {\n        return new BF(convertToHex);\n      }\n      let roundedColor = this.rgb().round().color;\n      let alphaHexValue = Math.round(this.valpha * 255).toString(16).toUpperCase();\n      if (alphaHexValue.length === 1) {\n        alphaHexValue = \"0\" + alphaHexValue;\n      }\n      return _______________________________________________________initializeDevToolsConnection.to.hex(roundedColor) + alphaHexValue;\n    },\n    rgbNumber() {\n      let _rgbColorArray = this.rgb().color;\n      return (_rgbColorArray[0] & 255) << 16 | (_rgbColorArray[1] & 255) << 8 | _rgbColorArray[2] & 255;\n    },\n    luminosity() {\n      let rgbColorArray = this.rgb().color;\n      let linearColorValues = [];\n      for (let [colorIndex, _____colorValue] of rgbColorArray.entries()) {\n        let normalizedGreenValue = _____colorValue / 255;\n        linearColorValues[colorIndex] = normalizedGreenValue <= 0.04045 ? normalizedGreenValue / 12.92 : ((normalizedGreenValue + 0.055) / 1.055) ** 2.4;\n      }\n      return linearColorValues[0] * 0.2126 + linearColorValues[1] * 0.7152 + linearColorValues[2] * 0.0722;\n    },\n    contrast(contrastColor) {\n      let currentLuminosity = this.luminosity();\n      let inputLuminosity = contrastColor.luminosity();\n      if (currentLuminosity > inputLuminosity) {\n        return (currentLuminosity + 0.05) / (inputLuminosity + 0.05);\n      }\n      return (inputLuminosity + 0.05) / (currentLuminosity + 0.05);\n    },\n    level(calculateContrastLevel) {\n      let contrastValue = this.contrast(calculateContrastLevel);\n      if (contrastValue >= 7) {\n        return \"AAA\";\n      }\n      if (contrastValue >= 4.5) {\n        return \"AA\";\n      } else {\n        return \"\";\n      }\n    },\n    isDark() {\n      let _colorValues = this.rgb().color;\n      return (_colorValues[0] * 2126 + _colorValues[1] * 7152 + _colorValues[2] * 722) / 10000 < 128;\n    },\n    isLight() {\n      return !this.isDark();\n    },\n    negate() {\n      let negatedColor = this.rgb();\n      for (let __colorChannelIndex = 0; __colorChannelIndex < 3; __colorChannelIndex++) {\n        negatedColor.color[__colorChannelIndex] = 255 - negatedColor.color[__colorChannelIndex];\n      }\n      return negatedColor;\n    },\n    lighten(lightenPercentage) {\n      let adjustedHSL = this.hsl();\n      adjustedHSL.color[2] += adjustedHSL.color[2] * lightenPercentage;\n      return adjustedHSL;\n    },\n    darken(darkenFactor) {\n      let darkenColor = this.hsl();\n      darkenColor.color[2] -= darkenColor.color[2] * darkenFactor;\n      return darkenColor;\n    },\n    saturate(saturationLevel) {\n      let adjustedColor = this.hsl();\n      adjustedColor.color[1] += adjustedColor.color[1] * saturationLevel;\n      return adjustedColor;\n    },\n    desaturate(desaturationFactor) {\n      let desaturatedColor = this.hsl();\n      desaturatedColor.color[1] -= desaturatedColor.color[1] * desaturationFactor;\n      return desaturatedColor;\n    },\n    whiten(whitenColor) {\n      let calculateWhitenedColor = this.hwb();\n      calculateWhitenedColor.color[1] += calculateWhitenedColor.color[1] * whitenColor;\n      return calculateWhitenedColor;\n    },\n    blacken(adjustBlackness) {\n      let adjustHwbColorBrightness = this.hwb();\n      adjustHwbColorBrightness.color[2] += adjustHwbColorBrightness.color[2] * adjustBlackness;\n      return adjustHwbColorBrightness;\n    },\n    grayscale() {\n      let calculateGrayscaleValue = this.rgb().color;\n      let _calculateGrayscaleValue = calculateGrayscaleValue[0] * 0.3 + calculateGrayscaleValue[1] * 0.59 + calculateGrayscaleValue[2] * 0.11;\n      return BF.rgb(_calculateGrayscaleValue, _calculateGrayscaleValue, _calculateGrayscaleValue);\n    },\n    fade(fadeFactor) {\n      return this.alpha(this.valpha - this.valpha * fadeFactor);\n    },\n    opaquer(calculateOpacitiy) {\n      return this.alpha(this.valpha + this.valpha * calculateOpacitiy);\n    },\n    rotate(rotateHue) {\n      let hslColor = this.hsl();\n      let __hue = hslColor.color[0];\n      __hue = (__hue + rotateHue) % 360;\n      if (__hue < 0) {\n        __hue = 360 + __hue;\n      } else {\n        __hue = __hue;\n      }\n      hslColor.color[0] = __hue;\n      return hslColor;\n    },\n    mix(mixColors, mixRatio) {\n      if (!mixColors || !mixColors.rgb) {\n        throw Error(\"Argument to \\\"mix\\\" was not a Color instance, but rather an instance of \" + typeof mixColors);\n      }\n      let sourceColorRgb = mixColors.rgb();\n      let color = this.rgb();\n      let mixFactor = mixRatio === undefined ? 0.5 : mixRatio;\n      let _mixRatio = mixFactor * 2 - 1;\n      let alphaDifference = sourceColorRgb.alpha() - color.alpha();\n      let _mixFactor = ((_mixRatio * alphaDifference === -1 ? _mixRatio : (_mixRatio + alphaDifference) / (1 + _mixRatio * alphaDifference)) + 1) / 2;\n      let __mixFactor = 1 - _mixFactor;\n      return BF.rgb(_mixFactor * sourceColorRgb.red() + __mixFactor * color.red(), _mixFactor * sourceColorRgb.green() + __mixFactor * color.green(), _mixFactor * sourceColorRgb.blue() + __mixFactor * color.blue(), sourceColorRgb.alpha() * mixFactor + color.alpha() * (1 - mixFactor));\n    }\n  };\n  for (let colorModelKey of Object.keys(colorModelInfo)) {\n    if (colorModelNames.includes(colorModelKey)) {\n      continue;\n    }\n    let {\n      channels: channelData\n    } = colorModelInfo[colorModelKey];\n    BF.prototype[colorModelKey] = function (...params) {\n      if (this.model === colorModelKey) {\n        return new BF(this);\n      }\n      if (params.length > 0) {\n        return new BF(params, colorModelKey);\n      }\n      return new BF([...ensureArray(colorModelInfo[this.model][colorModelKey].raw(this.color)), this.valpha], colorModelKey);\n    };\n    BF[colorModelKey] = function (...__inputData) {\n      let ____inputValue = __inputData[0];\n      if (typeof ____inputValue === \"number\") {\n        ____inputValue = replaceNonNumericWithZero(__inputData, channelData);\n      }\n      return new BF(____inputValue, colorModelKey);\n    };\n  }\n  function formatNumberToDecimalPlaces(roundNumberToDecimalPlaces, decimalPlaces) {\n    return Number(roundNumberToDecimalPlaces.toFixed(decimalPlaces));\n  }\n  function createDecimalFormatter(createFunctionWithArgument) {\n    return function (argumentHandler) {\n      return formatNumberToDecimalPlaces(argumentHandler, createFunctionWithArgument);\n    };\n  }\n  function createColorTransformationFunction(applyColorModelTransformation, colorProperty, valueTransformationFunction) {\n    if (Array.isArray(applyColorModelTransformation)) {\n      applyColorModelTransformation = applyColorModelTransformation;\n    } else {\n      applyColorModelTransformation = [applyColorModelTransformation];\n    }\n    for (let ___________________________index of applyColorModelTransformation) {\n      (colorModelTransformations[___________________________index] ||= [])[colorProperty] = valueTransformationFunction;\n    }\n    applyColorModelTransformation = applyColorModelTransformation[0];\n    return function (___colorValue) {\n      let colorModelTransformationResult;\n      if (___colorValue !== undefined) {\n        if (valueTransformationFunction) {\n          ___colorValue = valueTransformationFunction(___colorValue);\n        }\n        colorModelTransformationResult = this[applyColorModelTransformation]();\n        colorModelTransformationResult.color[colorProperty] = ___colorValue;\n        return colorModelTransformationResult;\n      }\n      colorModelTransformationResult = this[applyColorModelTransformation]().color[colorProperty];\n      if (valueTransformationFunction) {\n        colorModelTransformationResult = valueTransformationFunction(colorModelTransformationResult);\n      }\n      return colorModelTransformationResult;\n    };\n  }\n  function clampValueWithinRange(clampValue) {\n    return function (_clampedValue) {\n      return Math.max(0, Math.min(clampValue, _clampedValue));\n    };\n  }\n  function ensureArray(normalizeInput) {\n    if (Array.isArray(normalizeInput)) {\n      return normalizeInput;\n    } else {\n      return [normalizeInput];\n    }\n  }\n  function replaceNonNumericWithZero(initializeArrayWithZeros, maxIndex) {\n    for (let _______________________index = 0; _______________________index < maxIndex; _______________________index++) {\n      if (typeof initializeArrayWithZeros[_______________________index] !== \"number\") {\n        initializeArrayWithZeros[_______________________index] = 0;\n      }\n    }\n    return initializeArrayWithZeros;\n  }\n  ColorConverter.exports = BF;\n});\nvar s_0 = z((createInputOptions, exportInputUtilities) => {\n  var _______________initializeReactDevToolsConnection = ______________initializeReactDevToolsConnection();\n  var inputValidationUtil = _______initializeRenderer();\n  var uh = HJA();\n  var textAlignmentMap = {\n    left: \"low\",\n    center: \"centre\",\n    centre: \"centre\",\n    right: \"high\"\n  };\n  function extractValidImageProperties(extractImageProperties) {\n    let {\n      raw: rawImageData,\n      density: imageDensity,\n      limitInputPixels: limitInputPixels,\n      ignoreIcc: ignoreIccProfile,\n      unlimited: isUnlimited,\n      sequentialRead: sequentialReadProcessing,\n      failOn: errorHandlingStrategy,\n      failOnError: failOnErrorFlag,\n      animated: isAnimated,\n      page: pageIndex,\n      pages: pageNumbers,\n      subifd: subIFD\n    } = extractImageProperties;\n    if ([rawImageData, imageDensity, limitInputPixels, ignoreIccProfile, isUnlimited, sequentialReadProcessing, errorHandlingStrategy, failOnErrorFlag, isAnimated, pageIndex, pageNumbers, subIFD].some(inputValidationUtil.defined)) {\n      return {\n        raw: rawImageData,\n        density: imageDensity,\n        limitInputPixels: limitInputPixels,\n        ignoreIcc: ignoreIccProfile,\n        unlimited: isUnlimited,\n        sequentialRead: sequentialReadProcessing,\n        failOn: errorHandlingStrategy,\n        failOnError: failOnErrorFlag,\n        animated: isAnimated,\n        page: pageIndex,\n        pages: pageNumbers,\n        subifd: subIFD\n      };\n    } else {\n      return undefined;\n    }\n  }\n  function createInputImage(inputHandler, inputOptions, inputConfiguration) {\n    let inputImageOptions = {\n      failOn: \"warning\",\n      limitInputPixels: Math.pow(16383, 2),\n      ignoreIcc: false,\n      unlimited: false,\n      sequentialRead: true\n    };\n    if (inputValidationUtil.string(inputHandler)) {\n      inputImageOptions.file = inputHandler;\n    } else if (inputValidationUtil.buffer(inputHandler)) {\n      if (inputHandler.length === 0) {\n        throw Error(\"Input Buffer is empty\");\n      }\n      inputImageOptions.buffer = inputHandler;\n    } else if (inputValidationUtil.arrayBuffer(inputHandler)) {\n      if (inputHandler.byteLength === 0) {\n        throw Error(\"Input bit Array is empty\");\n      }\n      inputImageOptions.buffer = Buffer.from(inputHandler, 0, inputHandler.byteLength);\n    } else if (inputValidationUtil.typedArray(inputHandler)) {\n      if (inputHandler.length === 0) {\n        throw Error(\"Input Bit Array is empty\");\n      }\n      inputImageOptions.buffer = Buffer.from(inputHandler.buffer, inputHandler.byteOffset, inputHandler.byteLength);\n    } else if (inputValidationUtil.plainObject(inputHandler) && !inputValidationUtil.defined(inputOptions)) {\n      inputOptions = inputHandler;\n      if (extractValidImageProperties(inputOptions)) {\n        inputImageOptions.buffer = [];\n      }\n    } else if (!inputValidationUtil.defined(inputHandler) && !inputValidationUtil.defined(inputOptions) && inputValidationUtil.object(inputConfiguration) && inputConfiguration.allowStream) {\n      inputImageOptions.buffer = [];\n    } else {\n      throw Error(`Unsupported input '${inputHandler}' of type ${typeof inputHandler}${inputValidationUtil.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : \"\"}`);\n    }\n    if (inputValidationUtil.object(inputOptions)) {\n      if (inputValidationUtil.defined(inputOptions.failOnError)) {\n        if (inputValidationUtil.bool(inputOptions.failOnError)) {\n          inputImageOptions.failOn = inputOptions.failOnError ? \"warning\" : \"none\";\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"failOnError\", \"boolean\", inputOptions.failOnError);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.failOn)) {\n        if (inputValidationUtil.string(inputOptions.failOn) && inputValidationUtil.inArray(inputOptions.failOn, [\"none\", \"truncated\", \"error\", \"warning\"])) {\n          inputImageOptions.failOn = inputOptions.failOn;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"failOn\", \"one of: none, truncated, error, warning\", inputOptions.failOn);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.density)) {\n        if (inputValidationUtil.inRange(inputOptions.density, 1, 100000)) {\n          inputImageOptions.density = inputOptions.density;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"density\", \"number between 1 and 100000\", inputOptions.density);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.ignoreIcc)) {\n        if (inputValidationUtil.bool(inputOptions.ignoreIcc)) {\n          inputImageOptions.ignoreIcc = inputOptions.ignoreIcc;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"ignoreIcc\", \"boolean\", inputOptions.ignoreIcc);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.limitInputPixels)) {\n        if (inputValidationUtil.bool(inputOptions.limitInputPixels)) {\n          inputImageOptions.limitInputPixels = inputOptions.limitInputPixels ? Math.pow(16383, 2) : 0;\n        } else if (inputValidationUtil.integer(inputOptions.limitInputPixels) && inputValidationUtil.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {\n          inputImageOptions.limitInputPixels = inputOptions.limitInputPixels;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"limitInputPixels\", \"positive integer\", inputOptions.limitInputPixels);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.unlimited)) {\n        if (inputValidationUtil.bool(inputOptions.unlimited)) {\n          inputImageOptions.unlimited = inputOptions.unlimited;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"unlimited\", \"boolean\", inputOptions.unlimited);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.sequentialRead)) {\n        if (inputValidationUtil.bool(inputOptions.sequentialRead)) {\n          inputImageOptions.sequentialRead = inputOptions.sequentialRead;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"sequentialRead\", \"boolean\", inputOptions.sequentialRead);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.raw)) {\n        if (inputValidationUtil.object(inputOptions.raw) && inputValidationUtil.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && inputValidationUtil.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && inputValidationUtil.integer(inputOptions.raw.channels) && inputValidationUtil.inRange(inputOptions.raw.channels, 1, 4)) {\n          inputImageOptions.rawWidth = inputOptions.raw.width;\n          inputImageOptions.rawHeight = inputOptions.raw.height;\n          inputImageOptions.rawChannels = inputOptions.raw.channels;\n          inputImageOptions.rawPremultiplied = !!inputOptions.raw.premultiplied;\n          switch (inputHandler.constructor) {\n            case Uint8Array:\n            case Uint8ClampedArray:\n              inputImageOptions.rawDepth = \"uchar\";\n              break;\n            case Int8Array:\n              inputImageOptions.rawDepth = \"char\";\n              break;\n            case Uint16Array:\n              inputImageOptions.rawDepth = \"ushort\";\n              break;\n            case Int16Array:\n              inputImageOptions.rawDepth = \"short\";\n              break;\n            case Uint32Array:\n              inputImageOptions.rawDepth = \"uint\";\n              break;\n            case Int32Array:\n              inputImageOptions.rawDepth = \"int\";\n              break;\n            case Float32Array:\n              inputImageOptions.rawDepth = \"float\";\n              break;\n            case Float64Array:\n              inputImageOptions.rawDepth = \"double\";\n              break;\n            default:\n              inputImageOptions.rawDepth = \"uchar\";\n              break;\n          }\n        } else {\n          throw Error(\"Expected width, height and channels for raw pixel input\");\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.animated)) {\n        if (inputValidationUtil.bool(inputOptions.animated)) {\n          inputImageOptions.pages = inputOptions.animated ? -1 : 1;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"animated\", \"boolean\", inputOptions.animated);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.pages)) {\n        if (inputValidationUtil.integer(inputOptions.pages) && inputValidationUtil.inRange(inputOptions.pages, -1, 100000)) {\n          inputImageOptions.pages = inputOptions.pages;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"pages\", \"integer between -1 and 100000\", inputOptions.pages);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.page)) {\n        if (inputValidationUtil.integer(inputOptions.page) && inputValidationUtil.inRange(inputOptions.page, 0, 100000)) {\n          inputImageOptions.page = inputOptions.page;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"page\", \"integer between 0 and 100000\", inputOptions.page);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.level)) {\n        if (inputValidationUtil.integer(inputOptions.level) && inputValidationUtil.inRange(inputOptions.level, 0, 256)) {\n          inputImageOptions.level = inputOptions.level;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"level\", \"integer between 0 and 256\", inputOptions.level);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.subifd)) {\n        if (inputValidationUtil.integer(inputOptions.subifd) && inputValidationUtil.inRange(inputOptions.subifd, -1, 100000)) {\n          inputImageOptions.subifd = inputOptions.subifd;\n        } else {\n          throw inputValidationUtil.invalidParameterError(\"subifd\", \"integer between -1 and 100000\", inputOptions.subifd);\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.create)) {\n        if (inputValidationUtil.object(inputOptions.create) && inputValidationUtil.integer(inputOptions.create.width) && inputOptions.create.width > 0 && inputValidationUtil.integer(inputOptions.create.height) && inputOptions.create.height > 0 && inputValidationUtil.integer(inputOptions.create.channels)) {\n          inputImageOptions.createWidth = inputOptions.create.width;\n          inputImageOptions.createHeight = inputOptions.create.height;\n          inputImageOptions.createChannels = inputOptions.create.channels;\n          if (inputValidationUtil.defined(inputOptions.create.noise)) {\n            if (!inputValidationUtil.object(inputOptions.create.noise)) {\n              throw Error(\"Expected noise to be an object\");\n            }\n            if (!inputValidationUtil.inArray(inputOptions.create.noise.type, [\"gaussian\"])) {\n              throw Error(\"Only gaussian noise is supported at the moment\");\n            }\n            if (!inputValidationUtil.inRange(inputOptions.create.channels, 1, 4)) {\n              throw inputValidationUtil.invalidParameterError(\"create.channels\", \"number between 1 and 4\", inputOptions.create.channels);\n            }\n            inputImageOptions.createNoiseType = inputOptions.create.noise.type;\n            if (inputValidationUtil.number(inputOptions.create.noise.mean) && inputValidationUtil.inRange(inputOptions.create.noise.mean, 0, 10000)) {\n              inputImageOptions.createNoiseMean = inputOptions.create.noise.mean;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"create.noise.mean\", \"number between 0 and 10000\", inputOptions.create.noise.mean);\n            }\n            if (inputValidationUtil.number(inputOptions.create.noise.sigma) && inputValidationUtil.inRange(inputOptions.create.noise.sigma, 0, 10000)) {\n              inputImageOptions.createNoiseSigma = inputOptions.create.noise.sigma;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"create.noise.sigma\", \"number between 0 and 10000\", inputOptions.create.noise.sigma);\n            }\n          } else if (inputValidationUtil.defined(inputOptions.create.background)) {\n            if (!inputValidationUtil.inRange(inputOptions.create.channels, 3, 4)) {\n              throw inputValidationUtil.invalidParameterError(\"create.channels\", \"number between 3 and 4\", inputOptions.create.channels);\n            }\n            let backgroundColor = _______________initializeReactDevToolsConnection(inputOptions.create.background);\n            inputImageOptions.createBackground = [backgroundColor.red(), backgroundColor.green(), backgroundColor.blue(), Math.round(backgroundColor.alpha() * 255)];\n          } else {\n            throw Error(\"Expected valid noise or background to create a new input image\");\n          }\n          delete inputImageOptions.buffer;\n        } else {\n          throw Error(\"Expected valid width, height and channels to create a new input image\");\n        }\n      }\n      if (inputValidationUtil.defined(inputOptions.text)) {\n        if (inputValidationUtil.object(inputOptions.text) && inputValidationUtil.string(inputOptions.text.text)) {\n          inputImageOptions.textValue = inputOptions.text.text;\n          if (inputValidationUtil.defined(inputOptions.text.height) && inputValidationUtil.defined(inputOptions.text.dpi)) {\n            throw Error(\"Expected only one of dpi or height\");\n          }\n          if (inputValidationUtil.defined(inputOptions.text.font)) {\n            if (inputValidationUtil.string(inputOptions.text.font)) {\n              inputImageOptions.textFont = inputOptions.text.font;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.font\", \"string\", inputOptions.text.font);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.fontfile)) {\n            if (inputValidationUtil.string(inputOptions.text.fontfile)) {\n              inputImageOptions.textFontfile = inputOptions.text.fontfile;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.fontfile\", \"string\", inputOptions.text.fontfile);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.width)) {\n            if (inputValidationUtil.integer(inputOptions.text.width) && inputOptions.text.width > 0) {\n              inputImageOptions.textWidth = inputOptions.text.width;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.width\", \"positive integer\", inputOptions.text.width);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.height)) {\n            if (inputValidationUtil.integer(inputOptions.text.height) && inputOptions.text.height > 0) {\n              inputImageOptions.textHeight = inputOptions.text.height;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.height\", \"positive integer\", inputOptions.text.height);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.align)) {\n            if (inputValidationUtil.string(inputOptions.text.align) && inputValidationUtil.string(this.constructor.align[inputOptions.text.align])) {\n              inputImageOptions.textAlign = this.constructor.align[inputOptions.text.align];\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.align\", \"valid alignment\", inputOptions.text.align);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.justify)) {\n            if (inputValidationUtil.bool(inputOptions.text.justify)) {\n              inputImageOptions.textJustify = inputOptions.text.justify;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.justify\", \"boolean\", inputOptions.text.justify);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.dpi)) {\n            if (inputValidationUtil.integer(inputOptions.text.dpi) && inputValidationUtil.inRange(inputOptions.text.dpi, 1, 1000000)) {\n              inputImageOptions.textDpi = inputOptions.text.dpi;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.dpi\", \"integer between 1 and 1000000\", inputOptions.text.dpi);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.rgba)) {\n            if (inputValidationUtil.bool(inputOptions.text.rgba)) {\n              inputImageOptions.textRgba = inputOptions.text.rgba;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.rgba\", \"bool\", inputOptions.text.rgba);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.spacing)) {\n            if (inputValidationUtil.integer(inputOptions.text.spacing) && inputValidationUtil.inRange(inputOptions.text.spacing, -1000000, 1000000)) {\n              inputImageOptions.textSpacing = inputOptions.text.spacing;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.spacing\", \"integer between -1000000 and 1000000\", inputOptions.text.spacing);\n            }\n          }\n          if (inputValidationUtil.defined(inputOptions.text.wrap)) {\n            if (inputValidationUtil.string(inputOptions.text.wrap) && inputValidationUtil.inArray(inputOptions.text.wrap, [\"word\", \"char\", \"word-char\", \"none\"])) {\n              inputImageOptions.textWrap = inputOptions.text.wrap;\n            } else {\n              throw inputValidationUtil.invalidParameterError(\"text.wrap\", \"one of: word, char, word-char, none\", inputOptions.text.wrap);\n            }\n          }\n          delete inputImageOptions.buffer;\n        } else {\n          throw Error(\"Expected a valid string to create an image with text.\");\n        }\n      }\n    } else if (inputValidationUtil.defined(inputOptions)) {\n      throw Error(\"Invalid input options \" + inputOptions);\n    }\n    return inputImageOptions;\n  }\n  function processInputData(inputData, dataChunk, ___callbackFunction) {\n    if (Array.isArray(this.options.input.buffer)) {\n      if (inputValidationUtil.buffer(inputData)) {\n        if (this.options.input.buffer.length === 0) {\n          this.on(\"finish\", () => {\n            this.streamInFinished = true;\n          });\n        }\n        this.options.input.buffer.push(inputData);\n        ___callbackFunction();\n      } else {\n        ___callbackFunction(Error(\"Non-Buffer data on Writable Stream\"));\n      }\n    } else {\n      ___callbackFunction(Error(\"Unexpected data on Writable Stream\"));\n    }\n  }\n  function concatInputBuffer() {\n    if (this._isStreamInput()) {\n      this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n    }\n  }\n  function isInputBufferArray() {\n    return Array.isArray(this.options.input.buffer);\n  }\n  function jl9(handleMetadataCallback) {\n    let B = Error();\n    if (inputValidationUtil.fn(handleMetadataCallback)) {\n      if (this._isStreamInput()) {\n        this.on(\"finish\", () => {\n          this._flattenBufferIn();\n          uh.metadata(this.options, (isError, errorObject) => {\n            if (isError) {\n              handleMetadataCallback(inputValidationUtil.nativeError(isError, B));\n            } else {\n              handleMetadataCallback(null, errorObject);\n            }\n          });\n        });\n      } else {\n        uh.metadata(this.options, (___isError, errorResponse) => {\n          if (___isError) {\n            handleMetadataCallback(inputValidationUtil.nativeError(___isError, B));\n          } else {\n            handleMetadataCallback(null, errorResponse);\n          }\n        });\n      }\n      return this;\n    } else if (this._isStreamInput()) {\n      return new Promise((processMetadata, errorCallback) => {\n        let processBufferAndEmit = () => {\n          this._flattenBufferIn();\n          uh.metadata(this.options, (inputError, metadata) => {\n            if (inputError) {\n              errorCallback(inputValidationUtil.nativeError(inputError, B));\n            } else {\n              processMetadata(metadata);\n            }\n          });\n        };\n        if (this.writableFinished) {\n          processBufferAndEmit();\n        } else {\n          this.once(\"finish\", processBufferAndEmit);\n        }\n      });\n    } else {\n      return new Promise((handleMetadataResponse, handleError) => {\n        uh.metadata(this.options, (handleErrorOrMetadataResponse, metadataResponse) => {\n          if (handleErrorOrMetadataResponse) {\n            handleError(inputValidationUtil.nativeError(handleErrorOrMetadataResponse, B));\n          } else {\n            handleMetadataResponse(metadataResponse);\n          }\n        });\n      });\n    }\n  }\n  function Sl9(handleStatsCallback) {\n    let B = Error();\n    if (inputValidationUtil.fn(handleStatsCallback)) {\n      if (this._isStreamInput()) {\n        this.on(\"finish\", () => {\n          this._flattenBufferIn();\n          uh.stats(this.options, (_isError, errorInfo) => {\n            if (_isError) {\n              handleStatsCallback(inputValidationUtil.nativeError(_isError, B));\n            } else {\n              handleStatsCallback(null, errorInfo);\n            }\n          });\n        });\n      } else {\n        uh.stats(this.options, (__errorCallback, _errorResponse) => {\n          if (__errorCallback) {\n            handleStatsCallback(inputValidationUtil.nativeError(__errorCallback, B));\n          } else {\n            handleStatsCallback(null, _errorResponse);\n          }\n        });\n      }\n      return this;\n    } else if (this._isStreamInput()) {\n      return new Promise((handleStatsResponse, _errorCallback) => {\n        this.on(\"finish\", function () {\n          this._flattenBufferIn();\n          uh.stats(this.options, (__isError, statsResponse) => {\n            if (__isError) {\n              _errorCallback(inputValidationUtil.nativeError(__isError, B));\n            } else {\n              handleStatsResponse(statsResponse);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((processStatsResponse, _handleError) => {\n        uh.stats(this.options, (handleNativeError, _statsResponse) => {\n          if (handleNativeError) {\n            _handleError(inputValidationUtil.nativeError(handleNativeError, B));\n          } else {\n            processStatsResponse(_statsResponse);\n          }\n        });\n      });\n    }\n  }\n  exportInputUtilities.exports = function (_InputProcessor) {\n    Object.assign(_InputProcessor.prototype, {\n      _inputOptionsFromObject: extractValidImageProperties,\n      _createInputDescriptor: createInputImage,\n      _write: processInputData,\n      _flattenBufferIn: concatInputBuffer,\n      _isStreamInput: isInputBufferArray,\n      metadata: jl9,\n      stats: Sl9\n    });\n    _InputProcessor.align = textAlignmentMap;\n  };\n});\nvar _________________________________________initializeDevToolsConnection = z((setupImageManipulationOptions, exportImageResizingMethods) => {\n  var imageRenderer = _______initializeRenderer();\n  var directions = {\n    center: 0,\n    centre: 0,\n    north: 1,\n    east: 2,\n    south: 3,\n    west: 4,\n    northeast: 5,\n    southeast: 6,\n    southwest: 7,\n    northwest: 8\n  };\n  var PositionMapping = {\n    top: 1,\n    right: 2,\n    bottom: 3,\n    left: 4,\n    \"right top\": 5,\n    \"right bottom\": 6,\n    \"left bottom\": 7,\n    \"left top\": 8\n  };\n  var imageProcessingOptions = {\n    background: \"background\",\n    copy: \"copy\",\n    repeat: \"repeat\",\n    mirror: \"mirror\"\n  };\n  var resizePositionStrategy = {\n    entropy: 16,\n    attention: 17\n  };\n  var resamplingMethods = {\n    nearest: \"nearest\",\n    linear: \"linear\",\n    cubic: \"cubic\",\n    mitchell: \"mitchell\",\n    lanczos2: \"lanczos2\",\n    lanczos3: \"lanczos3\"\n  };\n  var resizeFitOptions = {\n    contain: \"contain\",\n    cover: \"cover\",\n    fill: \"fill\",\n    inside: \"inside\",\n    outside: \"outside\"\n  };\n  var imageFitOptions = {\n    contain: \"embed\",\n    cover: \"crop\",\n    fill: \"ignore_aspect\",\n    inside: \"max\",\n    outside: \"min\"\n  };\n  function isImageTransformRequired(shouldRedrawImage) {\n    return shouldRedrawImage.angle % 360 !== 0 || shouldRedrawImage.useExifOrientation === true || shouldRedrawImage.rotationAngle !== 0;\n  }\n  function isDimensionsValid(_isDimensionsValid) {\n    return _isDimensionsValid.width !== -1 || _isDimensionsValid.height !== -1;\n  }\n  function setImageResizeParameters(setImageResizeOptions, heightValue, resizeOptions) {\n    if (isDimensionsValid(this.options)) {\n      this.options.debuglog(\"ignoring previous resize options\");\n    }\n    if (this.options.widthPost !== -1) {\n      this.options.debuglog(\"operation order will be: extract, resize, extract\");\n    }\n    if (imageRenderer.defined(setImageResizeOptions)) {\n      if (imageRenderer.object(setImageResizeOptions) && !imageRenderer.defined(resizeOptions)) {\n        resizeOptions = setImageResizeOptions;\n      } else if (imageRenderer.integer(setImageResizeOptions) && setImageResizeOptions > 0) {\n        this.options.width = setImageResizeOptions;\n      } else {\n        throw imageRenderer.invalidParameterError(\"width\", \"positive integer\", setImageResizeOptions);\n      }\n    } else {\n      this.options.width = -1;\n    }\n    if (imageRenderer.defined(heightValue)) {\n      if (imageRenderer.integer(heightValue) && heightValue > 0) {\n        this.options.height = heightValue;\n      } else {\n        throw imageRenderer.invalidParameterError(\"height\", \"positive integer\", heightValue);\n      }\n    } else {\n      this.options.height = -1;\n    }\n    if (imageRenderer.object(resizeOptions)) {\n      if (imageRenderer.defined(resizeOptions.width)) {\n        if (imageRenderer.integer(resizeOptions.width) && resizeOptions.width > 0) {\n          this.options.width = resizeOptions.width;\n        } else {\n          throw imageRenderer.invalidParameterError(\"width\", \"positive integer\", resizeOptions.width);\n        }\n      }\n      if (imageRenderer.defined(resizeOptions.height)) {\n        if (imageRenderer.integer(resizeOptions.height) && resizeOptions.height > 0) {\n          this.options.height = resizeOptions.height;\n        } else {\n          throw imageRenderer.invalidParameterError(\"height\", \"positive integer\", resizeOptions.height);\n        }\n      }\n      if (imageRenderer.defined(resizeOptions.fit)) {\n        let fitOption = imageFitOptions[resizeOptions.fit];\n        if (imageRenderer.string(fitOption)) {\n          this.options.canvas = fitOption;\n        } else {\n          throw imageRenderer.invalidParameterError(\"fit\", \"valid fit\", resizeOptions.fit);\n        }\n      }\n      if (imageRenderer.defined(resizeOptions.position)) {\n        let _fitOption = imageRenderer.integer(resizeOptions.position) ? resizeOptions.position : resizePositionStrategy[resizeOptions.position] || PositionMapping[resizeOptions.position] || directions[resizeOptions.position];\n        if (imageRenderer.integer(_fitOption) && (imageRenderer.inRange(_fitOption, 0, 8) || imageRenderer.inRange(_fitOption, 16, 17))) {\n          this.options.position = _fitOption;\n        } else {\n          throw imageRenderer.invalidParameterError(\"position\", \"valid position/gravity/strategy\", resizeOptions.position);\n        }\n      }\n      this._setBackgroundColourOption(\"resizeBackground\", resizeOptions.background);\n      if (imageRenderer.defined(resizeOptions.kernel)) {\n        if (imageRenderer.string(resamplingMethods[resizeOptions.kernel])) {\n          this.options.kernel = resamplingMethods[resizeOptions.kernel];\n        } else {\n          throw imageRenderer.invalidParameterError(\"kernel\", \"valid kernel name\", resizeOptions.kernel);\n        }\n      }\n      if (imageRenderer.defined(resizeOptions.withoutEnlargement)) {\n        this._setBooleanOption(\"withoutEnlargement\", resizeOptions.withoutEnlargement);\n      }\n      if (imageRenderer.defined(resizeOptions.withoutReduction)) {\n        this._setBooleanOption(\"withoutReduction\", resizeOptions.withoutReduction);\n      }\n      if (imageRenderer.defined(resizeOptions.fastShrinkOnLoad)) {\n        this._setBooleanOption(\"fastShrinkOnLoad\", resizeOptions.fastShrinkOnLoad);\n      }\n    }\n    if (isImageTransformRequired(this.options) && isDimensionsValid(this.options)) {\n      this.options.rotateBeforePreExtract = true;\n    }\n    return this;\n  }\n  function setExtensionOptions(extensionOptions) {\n    if (imageRenderer.integer(extensionOptions) && extensionOptions > 0) {\n      this.options.extendTop = extensionOptions;\n      this.options.extendBottom = extensionOptions;\n      this.options.extendLeft = extensionOptions;\n      this.options.extendRight = extensionOptions;\n    } else if (imageRenderer.object(extensionOptions)) {\n      if (imageRenderer.defined(extensionOptions.top)) {\n        if (imageRenderer.integer(extensionOptions.top) && extensionOptions.top >= 0) {\n          this.options.extendTop = extensionOptions.top;\n        } else {\n          throw imageRenderer.invalidParameterError(\"top\", \"positive integer\", extensionOptions.top);\n        }\n      }\n      if (imageRenderer.defined(extensionOptions.bottom)) {\n        if (imageRenderer.integer(extensionOptions.bottom) && extensionOptions.bottom >= 0) {\n          this.options.extendBottom = extensionOptions.bottom;\n        } else {\n          throw imageRenderer.invalidParameterError(\"bottom\", \"positive integer\", extensionOptions.bottom);\n        }\n      }\n      if (imageRenderer.defined(extensionOptions.left)) {\n        if (imageRenderer.integer(extensionOptions.left) && extensionOptions.left >= 0) {\n          this.options.extendLeft = extensionOptions.left;\n        } else {\n          throw imageRenderer.invalidParameterError(\"left\", \"positive integer\", extensionOptions.left);\n        }\n      }\n      if (imageRenderer.defined(extensionOptions.right)) {\n        if (imageRenderer.integer(extensionOptions.right) && extensionOptions.right >= 0) {\n          this.options.extendRight = extensionOptions.right;\n        } else {\n          throw imageRenderer.invalidParameterError(\"right\", \"positive integer\", extensionOptions.right);\n        }\n      }\n      this._setBackgroundColourOption(\"extendBackground\", extensionOptions.background);\n      if (imageRenderer.defined(extensionOptions.extendWith)) {\n        if (imageRenderer.string(imageProcessingOptions[extensionOptions.extendWith])) {\n          this.options.extendWith = imageProcessingOptions[extensionOptions.extendWith];\n        } else {\n          throw imageRenderer.invalidParameterError(\"extendWith\", \"one of: background, copy, repeat, mirror\", extensionOptions.extendWith);\n        }\n      }\n    } else {\n      throw imageRenderer.invalidParameterError(\"extend\", \"integer or object\", extensionOptions);\n    }\n    return this;\n  }\n  function setPositionAndSize(setPositionAndSizeOptions) {\n    let widthCondition = isDimensionsValid(this.options) || this.options.widthPre !== -1 ? \"Post\" : \"Pre\";\n    if (this.options[`width${widthCondition}`] !== -1) {\n      this.options.debuglog(\"ignoring previous extract options\");\n    }\n    [\"left\", \"top\", \"width\", \"height\"].forEach(function (positionOrSize) {\n      let positionOrSizeValue = setPositionAndSizeOptions[positionOrSize];\n      if (imageRenderer.integer(positionOrSizeValue) && positionOrSizeValue >= 0) {\n        this.options[positionOrSize + (positionOrSize === \"left\" || positionOrSize === \"top\" ? \"Offset\" : \"\") + widthCondition] = positionOrSizeValue;\n      } else {\n        throw imageRenderer.invalidParameterError(positionOrSize, \"integer\", positionOrSizeValue);\n      }\n    }, this);\n    if (isImageTransformRequired(this.options) && !isDimensionsValid(this.options)) {\n      if (this.options.widthPre === -1 || this.options.widthPost === -1) {\n        this.options.rotateBeforePreExtract = true;\n      }\n    }\n    return this;\n  }\n  function setTrimOptions(trimOptions) {\n    this.options.trimThreshold = 10;\n    if (imageRenderer.defined(trimOptions)) {\n      if (imageRenderer.object(trimOptions)) {\n        if (imageRenderer.defined(trimOptions.background)) {\n          this._setBackgroundColourOption(\"trimBackground\", trimOptions.background);\n        }\n        if (imageRenderer.defined(trimOptions.threshold)) {\n          if (imageRenderer.number(trimOptions.threshold) && trimOptions.threshold >= 0) {\n            this.options.trimThreshold = trimOptions.threshold;\n          } else {\n            throw imageRenderer.invalidParameterError(\"threshold\", \"positive number\", trimOptions.threshold);\n          }\n        }\n        if (imageRenderer.defined(trimOptions.lineArt)) {\n          this._setBooleanOption(\"trimLineArt\", trimOptions.lineArt);\n        }\n      } else {\n        throw imageRenderer.invalidParameterError(\"trim\", \"object\", trimOptions);\n      }\n    }\n    if (isImageTransformRequired(this.options)) {\n      this.options.rotateBeforePreExtract = true;\n    }\n    return this;\n  }\n  exportImageResizingMethods.exports = function (___ImageProcessor) {\n    Object.assign(___ImageProcessor.prototype, {\n      resize: setImageResizeParameters,\n      extend: setExtensionOptions,\n      extract: setPositionAndSize,\n      trim: setTrimOptions\n    });\n    ___ImageProcessor.gravity = directions;\n    ___ImageProcessor.strategy = resizePositionStrategy;\n    ___ImageProcessor.kernel = resamplingMethods;\n    ___ImageProcessor.fit = resizeFitOptions;\n    ___ImageProcessor.position = PositionMapping;\n  };\n});\nvar _____________________initializeDevelopmentTools = z((compositeImageOptions, registerCompositeMethods) => {\n  var _____________initializeRenderer = _______initializeRenderer();\n  var blendModes = {\n    clear: \"clear\",\n    source: \"source\",\n    over: \"over\",\n    in: \"in\",\n    out: \"out\",\n    atop: \"atop\",\n    dest: \"dest\",\n    \"dest-over\": \"dest-over\",\n    \"dest-in\": \"dest-in\",\n    \"dest-out\": \"dest-out\",\n    \"dest-atop\": \"dest-atop\",\n    xor: \"xor\",\n    add: \"add\",\n    saturate: \"saturate\",\n    multiply: \"multiply\",\n    screen: \"screen\",\n    overlay: \"overlay\",\n    darken: \"darken\",\n    lighten: \"lighten\",\n    \"colour-dodge\": \"colour-dodge\",\n    \"color-dodge\": \"colour-dodge\",\n    \"colour-burn\": \"colour-burn\",\n    \"color-burn\": \"colour-burn\",\n    \"hard-light\": \"hard-light\",\n    \"soft-light\": \"soft-light\",\n    difference: \"difference\",\n    exclusion: \"exclusion\"\n  };\n  function validateAndComposeImages(composeImages) {\n    if (!Array.isArray(composeImages)) {\n      throw _____________initializeRenderer.invalidParameterError(\"images to composite\", \"array\", composeImages);\n    }\n    this.options.composite = composeImages.map(_compositeImageOptions => {\n      if (!_____________initializeRenderer.object(_compositeImageOptions)) {\n        throw _____________initializeRenderer.invalidParameterError(\"image to composite\", \"object\", _compositeImageOptions);\n      }\n      let _inputOptions = this._inputOptionsFromObject(_compositeImageOptions);\n      let _inputConfiguration = {\n        input: this._createInputDescriptor(_compositeImageOptions.input, _inputOptions, {\n          allowStream: false\n        }),\n        blend: \"over\",\n        tile: false,\n        left: 0,\n        top: 0,\n        hasOffset: false,\n        gravity: 0,\n        premultiplied: false\n      };\n      if (_____________initializeRenderer.defined(_compositeImageOptions.blend)) {\n        if (_____________initializeRenderer.string(blendModes[_compositeImageOptions.blend])) {\n          _inputConfiguration.blend = blendModes[_compositeImageOptions.blend];\n        } else {\n          throw _____________initializeRenderer.invalidParameterError(\"blend\", \"valid blend name\", _compositeImageOptions.blend);\n        }\n      }\n      if (_____________initializeRenderer.defined(_compositeImageOptions.tile)) {\n        if (_____________initializeRenderer.bool(_compositeImageOptions.tile)) {\n          _inputConfiguration.tile = _compositeImageOptions.tile;\n        } else {\n          throw _____________initializeRenderer.invalidParameterError(\"tile\", \"boolean\", _compositeImageOptions.tile);\n        }\n      }\n      if (_____________initializeRenderer.defined(_compositeImageOptions.left)) {\n        if (_____________initializeRenderer.integer(_compositeImageOptions.left)) {\n          _inputConfiguration.left = _compositeImageOptions.left;\n        } else {\n          throw _____________initializeRenderer.invalidParameterError(\"left\", \"integer\", _compositeImageOptions.left);\n        }\n      }\n      if (_____________initializeRenderer.defined(_compositeImageOptions.top)) {\n        if (_____________initializeRenderer.integer(_compositeImageOptions.top)) {\n          _inputConfiguration.top = _compositeImageOptions.top;\n        } else {\n          throw _____________initializeRenderer.invalidParameterError(\"top\", \"integer\", _compositeImageOptions.top);\n        }\n      }\n      if (_____________initializeRenderer.defined(_compositeImageOptions.top) !== _____________initializeRenderer.defined(_compositeImageOptions.left)) {\n        throw Error(\"Expected both left and top to be set\");\n      } else {\n        _inputConfiguration.hasOffset = _____________initializeRenderer.integer(_compositeImageOptions.top) && _____________initializeRenderer.integer(_compositeImageOptions.left);\n      }\n      if (_____________initializeRenderer.defined(_compositeImageOptions.gravity)) {\n        if (_____________initializeRenderer.integer(_compositeImageOptions.gravity) && _____________initializeRenderer.inRange(_compositeImageOptions.gravity, 0, 8)) {\n          _inputConfiguration.gravity = _compositeImageOptions.gravity;\n        } else if (_____________initializeRenderer.string(_compositeImageOptions.gravity) && _____________initializeRenderer.integer(this.constructor.gravity[_compositeImageOptions.gravity])) {\n          _inputConfiguration.gravity = this.constructor.gravity[_compositeImageOptions.gravity];\n        } else {\n          throw _____________initializeRenderer.invalidParameterError(\"gravity\", \"valid gravity\", _compositeImageOptions.gravity);\n        }\n      }\n      if (_____________initializeRenderer.defined(_compositeImageOptions.premultiplied)) {\n        if (_____________initializeRenderer.bool(_compositeImageOptions.premultiplied)) {\n          _inputConfiguration.premultiplied = _compositeImageOptions.premultiplied;\n        } else {\n          throw _____________initializeRenderer.invalidParameterError(\"premultiplied\", \"boolean\", _compositeImageOptions.premultiplied);\n        }\n      }\n      return _inputConfiguration;\n    });\n    return this;\n  }\n  registerCompositeMethods.exports = function (BlendableObject) {\n    BlendableObject.prototype.composite = validateAndComposeImages;\n    BlendableObject.blend = blendModes;\n  };\n});\nvar __initializeDevelopmentToolsConnection = z((processImageTransformations, exportImageProcessingMethods) => {\n  var initializeColorTools = ______________initializeReactDevToolsConnection();\n  var ___________initializeRenderer = _______initializeRenderer();\n  var PrecisionTypes = {\n    integer: \"integer\",\n    float: \"float\",\n    approximate: \"approximate\"\n  };\n  function setRotationOptions(rotateAngle, backgroundOptions) {\n    if (this.options.useExifOrientation || this.options.angle || this.options.rotationAngle) {\n      this.options.debuglog(\"ignoring previous rotate options\");\n    }\n    if (!___________initializeRenderer.defined(rotateAngle)) {\n      this.options.useExifOrientation = true;\n    } else if (___________initializeRenderer.integer(rotateAngle) && !(rotateAngle % 90)) {\n      this.options.angle = rotateAngle;\n    } else if (___________initializeRenderer.number(rotateAngle)) {\n      this.options.rotationAngle = rotateAngle;\n      if (___________initializeRenderer.object(backgroundOptions) && backgroundOptions.background) {\n        let _backgroundColor = initializeColorTools(backgroundOptions.background);\n        this.options.rotationBackground = [_backgroundColor.red(), _backgroundColor.green(), _backgroundColor.blue(), Math.round(_backgroundColor.alpha() * 255)];\n      }\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"angle\", \"numeric\", rotateAngle);\n    }\n    return this;\n  }\n  function setFlipOptionOrDefault(setFlipOption) {\n    this.options.flip = ___________initializeRenderer.bool(setFlipOption) ? setFlipOption : true;\n    return this;\n  }\n  function initializeFlopOption(setFlopOption) {\n    this.options.flop = ___________initializeRenderer.bool(setFlopOption) ? setFlopOption : true;\n    return this;\n  }\n  function setAffineTransformation(setAffineTransformationOptions, options) {\n    let transformationMatrix = [].concat(...setAffineTransformationOptions);\n    if (transformationMatrix.length === 4 && transformationMatrix.every(___________initializeRenderer.number)) {\n      this.options.affineMatrix = transformationMatrix;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"matrix\", \"1x4 or 2x2 array\", setAffineTransformationOptions);\n    }\n    if (___________initializeRenderer.defined(options)) {\n      if (___________initializeRenderer.object(options)) {\n        this._setBackgroundColourOption(\"affineBackground\", options.background);\n        if (___________initializeRenderer.defined(options.idx)) {\n          if (___________initializeRenderer.number(options.idx)) {\n            this.options.affineIdx = options.idx;\n          } else {\n            throw ___________initializeRenderer.invalidParameterError(\"options.idx\", \"number\", options.idx);\n          }\n        }\n        if (___________initializeRenderer.defined(options.idy)) {\n          if (___________initializeRenderer.number(options.idy)) {\n            this.options.affineIdy = options.idy;\n          } else {\n            throw ___________initializeRenderer.invalidParameterError(\"options.idy\", \"number\", options.idy);\n          }\n        }\n        if (___________initializeRenderer.defined(options.odx)) {\n          if (___________initializeRenderer.number(options.odx)) {\n            this.options.affineOdx = options.odx;\n          } else {\n            throw ___________initializeRenderer.invalidParameterError(\"options.odx\", \"number\", options.odx);\n          }\n        }\n        if (___________initializeRenderer.defined(options.ody)) {\n          if (___________initializeRenderer.number(options.ody)) {\n            this.options.affineOdy = options.ody;\n          } else {\n            throw ___________initializeRenderer.invalidParameterError(\"options.ody\", \"number\", options.ody);\n          }\n        }\n        if (___________initializeRenderer.defined(options.interpolator)) {\n          if (___________initializeRenderer.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {\n            this.options.affineInterpolator = options.interpolator;\n          } else {\n            throw ___________initializeRenderer.invalidParameterError(\"options.interpolator\", \"valid interpolator name\", options.interpolator);\n          }\n        }\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"options\", \"object\", options);\n      }\n    }\n    return this;\n  }\n  function configureSharpeningOptions(sharpeningOptions, sharpenM1, sharpeningStrength) {\n    if (!___________initializeRenderer.defined(sharpeningOptions)) {\n      this.options.sharpenSigma = -1;\n    } else if (___________initializeRenderer.bool(sharpeningOptions)) {\n      this.options.sharpenSigma = sharpeningOptions ? -1 : 0;\n    } else if (___________initializeRenderer.number(sharpeningOptions) && ___________initializeRenderer.inRange(sharpeningOptions, 0.01, 10000)) {\n      this.options.sharpenSigma = sharpeningOptions;\n      if (___________initializeRenderer.defined(sharpenM1)) {\n        if (___________initializeRenderer.number(sharpenM1) && ___________initializeRenderer.inRange(sharpenM1, 0, 10000)) {\n          this.options.sharpenM1 = sharpenM1;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"flat\", \"number between 0 and 10000\", sharpenM1);\n        }\n      }\n      if (___________initializeRenderer.defined(sharpeningStrength)) {\n        if (___________initializeRenderer.number(sharpeningStrength) && ___________initializeRenderer.inRange(sharpeningStrength, 0, 10000)) {\n          this.options.sharpenM2 = sharpeningStrength;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"jagged\", \"number between 0 and 10000\", sharpeningStrength);\n        }\n      }\n    } else if (___________initializeRenderer.plainObject(sharpeningOptions)) {\n      if (___________initializeRenderer.number(sharpeningOptions.sigma) && ___________initializeRenderer.inRange(sharpeningOptions.sigma, 0.000001, 10)) {\n        this.options.sharpenSigma = sharpeningOptions.sigma;\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"options.sigma\", \"number between 0.000001 and 10\", sharpeningOptions.sigma);\n      }\n      if (___________initializeRenderer.defined(sharpeningOptions.m1)) {\n        if (___________initializeRenderer.number(sharpeningOptions.m1) && ___________initializeRenderer.inRange(sharpeningOptions.m1, 0, 1000000)) {\n          this.options.sharpenM1 = sharpeningOptions.m1;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"options.m1\", \"number between 0 and 1000000\", sharpeningOptions.m1);\n        }\n      }\n      if (___________initializeRenderer.defined(sharpeningOptions.m2)) {\n        if (___________initializeRenderer.number(sharpeningOptions.m2) && ___________initializeRenderer.inRange(sharpeningOptions.m2, 0, 1000000)) {\n          this.options.sharpenM2 = sharpeningOptions.m2;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"options.m2\", \"number between 0 and 1000000\", sharpeningOptions.m2);\n        }\n      }\n      if (___________initializeRenderer.defined(sharpeningOptions.x1)) {\n        if (___________initializeRenderer.number(sharpeningOptions.x1) && ___________initializeRenderer.inRange(sharpeningOptions.x1, 0, 1000000)) {\n          this.options.sharpenX1 = sharpeningOptions.x1;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"options.x1\", \"number between 0 and 1000000\", sharpeningOptions.x1);\n        }\n      }\n      if (___________initializeRenderer.defined(sharpeningOptions.y2)) {\n        if (___________initializeRenderer.number(sharpeningOptions.y2) && ___________initializeRenderer.inRange(sharpeningOptions.y2, 0, 1000000)) {\n          this.options.sharpenY2 = sharpeningOptions.y2;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"options.y2\", \"number between 0 and 1000000\", sharpeningOptions.y2);\n        }\n      }\n      if (___________initializeRenderer.defined(sharpeningOptions.y3)) {\n        if (___________initializeRenderer.number(sharpeningOptions.y3) && ___________initializeRenderer.inRange(sharpeningOptions.y3, 0, 1000000)) {\n          this.options.sharpenY3 = sharpeningOptions.y3;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"options.y3\", \"number between 0 and 1000000\", sharpeningOptions.y3);\n        }\n      }\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"sigma\", \"number between 0.01 and 10000\", sharpeningOptions);\n    }\n    return this;\n  }\n  function setMedianSize(medianSizeParameter) {\n    if (!___________initializeRenderer.defined(medianSizeParameter)) {\n      this.options.medianSize = 3;\n    } else if (___________initializeRenderer.integer(medianSizeParameter) && ___________initializeRenderer.inRange(medianSizeParameter, 1, 1000)) {\n      this.options.medianSize = medianSizeParameter;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"size\", \"integer between 1 and 1000\", medianSizeParameter);\n    }\n    return this;\n  }\n  function setBlurringParameters(setBlurringOptions) {\n    let blurringValue;\n    if (___________initializeRenderer.number(setBlurringOptions)) {\n      blurringValue = setBlurringOptions;\n    } else if (___________initializeRenderer.plainObject(setBlurringOptions)) {\n      if (!___________initializeRenderer.number(setBlurringOptions.sigma)) {\n        throw ___________initializeRenderer.invalidParameterError(\"options.sigma\", \"number between 0.3 and 1000\", blurringValue);\n      }\n      blurringValue = setBlurringOptions.sigma;\n      if (\"precision\" in setBlurringOptions) {\n        if (___________initializeRenderer.string(PrecisionTypes[setBlurringOptions.precision])) {\n          this.options.precision = PrecisionTypes[setBlurringOptions.precision];\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"precision\", \"one of: integer, float, approximate\", setBlurringOptions.precision);\n        }\n      }\n      if (\"minAmplitude\" in setBlurringOptions) {\n        if (___________initializeRenderer.number(setBlurringOptions.minAmplitude) && ___________initializeRenderer.inRange(setBlurringOptions.minAmplitude, 0.001, 1)) {\n          this.options.minAmpl = setBlurringOptions.minAmplitude;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"minAmplitude\", \"number between 0.001 and 1\", setBlurringOptions.minAmplitude);\n        }\n      }\n    }\n    if (!___________initializeRenderer.defined(setBlurringOptions)) {\n      this.options.blurSigma = -1;\n    } else if (___________initializeRenderer.bool(setBlurringOptions)) {\n      this.options.blurSigma = setBlurringOptions ? -1 : 0;\n    } else if (___________initializeRenderer.number(blurringValue) && ___________initializeRenderer.inRange(blurringValue, 0.3, 1000)) {\n      this.options.blurSigma = blurringValue;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"sigma\", \"number between 0.3 and 1000\", blurringValue);\n    }\n    return this;\n  }\n  function setFlattenOption(flattenOption) {\n    this.options.flatten = ___________initializeRenderer.bool(flattenOption) ? flattenOption : true;\n    if (___________initializeRenderer.object(flattenOption)) {\n      this._setBackgroundColourOption(\"flattenBackground\", flattenOption.background);\n    }\n    return this;\n  }\n  function setOptionsToUnflatten() {\n    this.options.unflatten = true;\n    return this;\n  }\n  function setGammaValues(setGammaAndGammaOut, gammaOutput) {\n    if (!___________initializeRenderer.defined(setGammaAndGammaOut)) {\n      this.options.gamma = 2.2;\n    } else if (___________initializeRenderer.number(setGammaAndGammaOut) && ___________initializeRenderer.inRange(setGammaAndGammaOut, 1, 3)) {\n      this.options.gamma = setGammaAndGammaOut;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"gamma\", \"number between 1.0 and 3.0\", setGammaAndGammaOut);\n    }\n    if (!___________initializeRenderer.defined(gammaOutput)) {\n      this.options.gammaOut = this.options.gamma;\n    } else if (___________initializeRenderer.number(gammaOutput) && ___________initializeRenderer.inRange(gammaOutput, 1, 3)) {\n      this.options.gammaOut = gammaOutput;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"gammaOut\", \"number between 1.0 and 3.0\", gammaOutput);\n    }\n    return this;\n  }\n  function initializeRendererWithOptions(inputParameter) {\n    this.options.negate = ___________initializeRenderer.bool(inputParameter) ? inputParameter : true;\n    if (___________initializeRenderer.plainObject(inputParameter) && \"alpha\" in inputParameter) {\n      if (!___________initializeRenderer.bool(inputParameter.alpha)) {\n        throw ___________initializeRenderer.invalidParameterError(\"alpha\", \"should be boolean value\", inputParameter.alpha);\n      } else {\n        this.options.negateAlpha = inputParameter.alpha;\n      }\n    }\n    return this;\n  }\n  function validateAndNormalizeRange(validateAndNormaliseRange) {\n    if (___________initializeRenderer.plainObject(validateAndNormaliseRange)) {\n      if (___________initializeRenderer.defined(validateAndNormaliseRange.lower)) {\n        if (___________initializeRenderer.number(validateAndNormaliseRange.lower) && ___________initializeRenderer.inRange(validateAndNormaliseRange.lower, 0, 99)) {\n          this.options.normaliseLower = validateAndNormaliseRange.lower;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"lower\", \"number between 0 and 99\", validateAndNormaliseRange.lower);\n        }\n      }\n      if (___________initializeRenderer.defined(validateAndNormaliseRange.upper)) {\n        if (___________initializeRenderer.number(validateAndNormaliseRange.upper) && ___________initializeRenderer.inRange(validateAndNormaliseRange.upper, 1, 100)) {\n          this.options.normaliseUpper = validateAndNormaliseRange.upper;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"upper\", \"number between 1 and 100\", validateAndNormaliseRange.upper);\n        }\n      }\n    }\n    if (this.options.normaliseLower >= this.options.normaliseUpper) {\n      throw ___________initializeRenderer.invalidParameterError(\"range\", \"lower to be less than upper\", `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);\n    }\n    this.options.normalise = true;\n    return this;\n  }\n  function normalizeData(____inputData) {\n    return this.normalise(____inputData);\n  }\n  function initializeClaheOptions(_options) {\n    if (___________initializeRenderer.plainObject(_options)) {\n      if (___________initializeRenderer.integer(_options.width) && _options.width > 0) {\n        this.options.claheWidth = _options.width;\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"width\", \"integer greater than zero\", _options.width);\n      }\n      if (___________initializeRenderer.integer(_options.height) && _options.height > 0) {\n        this.options.claheHeight = _options.height;\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"height\", \"integer greater than zero\", _options.height);\n      }\n      if (___________initializeRenderer.defined(_options.maxSlope)) {\n        if (___________initializeRenderer.integer(_options.maxSlope) && ___________initializeRenderer.inRange(_options.maxSlope, 0, 100)) {\n          this.options.claheMaxSlope = _options.maxSlope;\n        } else {\n          throw ___________initializeRenderer.invalidParameterError(\"maxSlope\", \"integer between 0 and 100\", _options.maxSlope);\n        }\n      }\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"options\", \"plain object\", _options);\n    }\n    return this;\n  }\n  function validateConvolutionKernelOptions(convolutionKernelOptions) {\n    if (!___________initializeRenderer.object(convolutionKernelOptions) || !Array.isArray(convolutionKernelOptions.kernel) || !___________initializeRenderer.integer(convolutionKernelOptions.width) || !___________initializeRenderer.integer(convolutionKernelOptions.height) || !___________initializeRenderer.inRange(convolutionKernelOptions.width, 3, 1001) || !___________initializeRenderer.inRange(convolutionKernelOptions.height, 3, 1001) || convolutionKernelOptions.height * convolutionKernelOptions.width !== convolutionKernelOptions.kernel.length) {\n      throw Error(\"Invalid convolution kernel\");\n    }\n    if (!___________initializeRenderer.integer(convolutionKernelOptions.scale)) {\n      convolutionKernelOptions.scale = convolutionKernelOptions.kernel.reduce(function (sum, addend) {\n        return sum + addend;\n      }, 0);\n    }\n    if (convolutionKernelOptions.scale < 1) {\n      convolutionKernelOptions.scale = 1;\n    }\n    if (!___________initializeRenderer.integer(convolutionKernelOptions.offset)) {\n      convolutionKernelOptions.offset = 0;\n    }\n    this.options.convKernel = convolutionKernelOptions;\n    return this;\n  }\n  function setImageThreshold(setThresholdOptions, __options) {\n    if (!___________initializeRenderer.defined(setThresholdOptions)) {\n      this.options.threshold = 128;\n    } else if (___________initializeRenderer.bool(setThresholdOptions)) {\n      this.options.threshold = setThresholdOptions ? 128 : 0;\n    } else if (___________initializeRenderer.integer(setThresholdOptions) && ___________initializeRenderer.inRange(setThresholdOptions, 0, 255)) {\n      this.options.threshold = setThresholdOptions;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"threshold\", \"integer between 0 and 255\", setThresholdOptions);\n    }\n    if (!___________initializeRenderer.object(__options) || __options.greyscale === true || __options.grayscale === true) {\n      this.options.thresholdGrayscale = true;\n    } else {\n      this.options.thresholdGrayscale = false;\n    }\n    return this;\n  }\n  function BooleanExpressionConstructor(inputValue, booleanOperator, _inputDescriptor) {\n    this.options.boolean = this._createInputDescriptor(inputValue, _inputDescriptor);\n    if (___________initializeRenderer.string(booleanOperator) && ___________initializeRenderer.inArray(booleanOperator, [\"and\", \"or\", \"eor\"])) {\n      this.options.booleanOp = booleanOperator;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"operator\", \"one of: and, or, eor\", booleanOperator);\n    }\n    return this;\n  }\n  function setLinearOptionsAndInitialize(setLinearOptions, inputB) {\n    if (!___________initializeRenderer.defined(setLinearOptions) && ___________initializeRenderer.number(inputB)) {\n      setLinearOptions = 1;\n    } else if (___________initializeRenderer.number(setLinearOptions) && !___________initializeRenderer.defined(inputB)) {\n      inputB = 0;\n    }\n    if (!___________initializeRenderer.defined(setLinearOptions)) {\n      this.options.linearA = [];\n    } else if (___________initializeRenderer.number(setLinearOptions)) {\n      this.options.linearA = [setLinearOptions];\n    } else if (Array.isArray(setLinearOptions) && setLinearOptions.length && setLinearOptions.every(___________initializeRenderer.number)) {\n      this.options.linearA = setLinearOptions;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"a\", \"number or array of numbers\", setLinearOptions);\n    }\n    if (!___________initializeRenderer.defined(inputB)) {\n      this.options.linearB = [];\n    } else if (___________initializeRenderer.number(inputB)) {\n      this.options.linearB = [inputB];\n    } else if (Array.isArray(inputB) && inputB.length && inputB.every(___________initializeRenderer.number)) {\n      this.options.linearB = inputB;\n    } else {\n      throw ___________initializeRenderer.invalidParameterError(\"b\", \"number or array of numbers\", inputB);\n    }\n    if (this.options.linearA.length !== this.options.linearB.length) {\n      throw Error(\"Expected a and b to be arrays of the same length\");\n    }\n    return this;\n  }\n  function setRecombinationMatrix(validateAndSetRecombinationMatrix) {\n    if (!Array.isArray(validateAndSetRecombinationMatrix)) {\n      throw ___________initializeRenderer.invalidParameterError(\"inputMatrix\", \"array\", validateAndSetRecombinationMatrix);\n    }\n    if (validateAndSetRecombinationMatrix.length !== 3 && validateAndSetRecombinationMatrix.length !== 4) {\n      throw ___________initializeRenderer.invalidParameterError(\"inputMatrix\", \"3x3 or 4x4 array\", validateAndSetRecombinationMatrix.length);\n    }\n    let flattenedRecombinationMatrix = validateAndSetRecombinationMatrix.flat().map(Number);\n    if (flattenedRecombinationMatrix.length !== 9 && flattenedRecombinationMatrix.length !== 16) {\n      throw ___________initializeRenderer.invalidParameterError(\"inputMatrix\", \"cardinality of 9 or 16\", flattenedRecombinationMatrix.length);\n    }\n    this.options.recombMatrix = flattenedRecombinationMatrix;\n    return this;\n  }\n  function initializeColorOptions(colorOptions) {\n    if (!___________initializeRenderer.plainObject(colorOptions)) {\n      throw ___________initializeRenderer.invalidParameterError(\"options\", \"plain object\", colorOptions);\n    }\n    if (\"brightness\" in colorOptions) {\n      if (___________initializeRenderer.number(colorOptions.brightness) && colorOptions.brightness >= 0) {\n        this.options.brightness = colorOptions.brightness;\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"brightness\", \"number above zero\", colorOptions.brightness);\n      }\n    }\n    if (\"saturation\" in colorOptions) {\n      if (___________initializeRenderer.number(colorOptions.saturation) && colorOptions.saturation >= 0) {\n        this.options.saturation = colorOptions.saturation;\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"saturation\", \"number above zero\", colorOptions.saturation);\n      }\n    }\n    if (\"hue\" in colorOptions) {\n      if (___________initializeRenderer.integer(colorOptions.hue)) {\n        this.options.hue = colorOptions.hue % 360;\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"hue\", \"number\", colorOptions.hue);\n      }\n    }\n    if (\"lightness\" in colorOptions) {\n      if (___________initializeRenderer.number(colorOptions.lightness)) {\n        this.options.lightness = colorOptions.lightness;\n      } else {\n        throw ___________initializeRenderer.invalidParameterError(\"lightness\", \"number\", colorOptions.lightness);\n      }\n    }\n    return this;\n  }\n  exportImageProcessingMethods.exports = function (__ImageProcessor) {\n    Object.assign(__ImageProcessor.prototype, {\n      rotate: setRotationOptions,\n      flip: setFlipOptionOrDefault,\n      flop: initializeFlopOption,\n      affine: setAffineTransformation,\n      sharpen: configureSharpeningOptions,\n      median: setMedianSize,\n      blur: setBlurringParameters,\n      flatten: setFlattenOption,\n      unflatten: setOptionsToUnflatten,\n      gamma: setGammaValues,\n      negate: initializeRendererWithOptions,\n      normalise: validateAndNormalizeRange,\n      normalize: normalizeData,\n      clahe: initializeClaheOptions,\n      convolve: validateConvolutionKernelOptions,\n      threshold: setImageThreshold,\n      boolean: BooleanExpressionConstructor,\n      linear: setLinearOptionsAndInitialize,\n      recomb: setRecombinationMatrix,\n      modulate: initializeColorOptions\n    });\n  };\n});\nvar ______________________________________________________________________initializeDevToolsConnection = z((initializeColorSpaceExtensions, initializeColourOptions) => {\n  var initializeColorComponents = ______________initializeReactDevToolsConnection();\n  var rendererInitializer = _______initializeRenderer();\n  var colorSpaceOptions = {\n    multiband: \"multiband\",\n    \"b-w\": \"b-w\",\n    bw: \"b-w\",\n    cmyk: \"cmyk\",\n    srgb: \"srgb\"\n  };\n  function setBackgroundTint(backgroundColourTint) {\n    this._setBackgroundColourOption(\"tint\", backgroundColourTint);\n    return this;\n  }\n  function setGreyscale(setGreyscaleOption) {\n    this.options.greyscale = rendererInitializer.bool(setGreyscaleOption) ? setGreyscaleOption : true;\n    return this;\n  }\n  function convertToGreyscale(getGreyscaleValue) {\n    return this.greyscale(getGreyscaleValue);\n  }\n  function _setColourspace(colourspace) {\n    if (!rendererInitializer.string(colourspace)) {\n      throw rendererInitializer.invalidParameterError(\"colourspace\", \"string\", colourspace);\n    }\n    this.options.colourspacePipeline = colourspace;\n    return this;\n  }\n  function convertToPipelineColourspace(inputColour) {\n    return this.pipelineColourspace(inputColour);\n  }\n  function __setColourspace(setColourspace) {\n    if (!rendererInitializer.string(setColourspace)) {\n      throw rendererInitializer.invalidParameterError(\"colourspace\", \"string\", setColourspace);\n    }\n    this.options.colourspace = setColourspace;\n    return this;\n  }\n  function convertToColourspace(colourSpaceValue) {\n    return this.toColourspace(colourSpaceValue);\n  }\n  function setBackgroundColor(backgroundProperty, background) {\n    if (rendererInitializer.defined(background)) {\n      if (rendererInitializer.object(background) || rendererInitializer.string(background)) {\n        let _colorComponents = initializeColorComponents(background);\n        this.options[backgroundProperty] = [_colorComponents.red(), _colorComponents.green(), _colorComponents.blue(), Math.round(_colorComponents.alpha() * 255)];\n      } else {\n        throw rendererInitializer.invalidParameterError(\"background\", \"object or string\", background);\n      }\n    }\n  }\n  initializeColourOptions.exports = function (ColorSpaceHandler) {\n    Object.assign(ColorSpaceHandler.prototype, {\n      tint: setBackgroundTint,\n      greyscale: setGreyscale,\n      grayscale: convertToGreyscale,\n      pipelineColourspace: _setColourspace,\n      pipelineColorspace: convertToPipelineColourspace,\n      toColourspace: __setColourspace,\n      toColorspace: convertToColourspace,\n      _setBackgroundColourOption: setBackgroundColor\n    });\n    ColorSpaceHandler.colourspace = colorSpaceOptions;\n    ColorSpaceHandler.colorspace = colorSpaceOptions;\n  };\n});\nvar ______________________initializeDevelopmentTools = z((initializeColorTransform, exportColorOptions) => {\n  var _renderer = _______initializeRenderer();\n  var BooleanOperations = {\n    and: \"and\",\n    or: \"or\",\n    eor: \"eor\"\n  };\n  function setOptionsToRemoveAlpha() {\n    this.options.removeAlpha = true;\n    return this;\n  }\n  function setAlphaValue(__alphaValue) {\n    if (_renderer.defined(__alphaValue)) {\n      if (_renderer.number(__alphaValue) && _renderer.inRange(__alphaValue, 0, 1)) {\n        this.options.ensureAlpha = __alphaValue;\n      } else {\n        throw _renderer.invalidParameterError(\"alpha\", \"number between 0 and 1\", __alphaValue);\n      }\n    } else {\n      this.options.ensureAlpha = 1;\n    }\n    return this;\n  }\n  function setExtractChannel(channelInput) {\n    let colorChannelMap = {\n      red: 0,\n      green: 1,\n      blue: 2,\n      alpha: 3\n    };\n    if (Object.keys(colorChannelMap).includes(channelInput)) {\n      channelInput = colorChannelMap[channelInput];\n    }\n    if (_renderer.integer(channelInput) && _renderer.inRange(channelInput, 0, 4)) {\n      this.options.extractChannel = channelInput;\n    } else {\n      throw _renderer.invalidParameterError(\"channel\", \"integer or one of: red, green, blue, alpha\", channelInput);\n    }\n    return this;\n  }\n  function addInputDescriptorsToJoinChannel(__inputDescriptor, ___inputDescriptor) {\n    if (Array.isArray(__inputDescriptor)) {\n      __inputDescriptor.forEach(function (____inputDescriptor) {\n        this.options.joinChannelIn.push(this._createInputDescriptor(____inputDescriptor, ___inputDescriptor));\n      }, this);\n    } else {\n      this.options.joinChannelIn.push(this._createInputDescriptor(__inputDescriptor, ___inputDescriptor));\n    }\n    return this;\n  }\n  function _setBooleanOperator(setBooleanOperator) {\n    if (_renderer.string(setBooleanOperator) && _renderer.inArray(setBooleanOperator, [\"and\", \"or\", \"eor\"])) {\n      this.options.bandBoolOp = setBooleanOperator;\n    } else {\n      throw _renderer.invalidParameterError(\"boolOp\", \"one of: and, or, eor\", setBooleanOperator);\n    }\n    return this;\n  }\n  exportColorOptions.exports = function (AlphaOperations) {\n    Object.assign(AlphaOperations.prototype, {\n      removeAlpha: setOptionsToRemoveAlpha,\n      ensureAlpha: setAlphaValue,\n      extractChannel: setExtractChannel,\n      joinChannel: addInputDescriptorsToJoinChannel,\n      bandbool: _setBooleanOperator\n    });\n    AlphaOperations.bool = BooleanOperations;\n  };\n});",
  "originalFile": "test-samples/claude.js",
  "originalProvider": "openai",
  "originalModel": "gpt-4o-mini",
  "originalArgs": {
    "provider": "openai",
    "outputDir": "output/claude-2025-11-16T19:49:17",
    "baseURL": "https://api.openai.com/v1",
    "contextSize": "100000",
    "maxConcurrent": "25",
    "minBatchSize": "3",
    "maxBatchSize": "100",
    "dependencyMode": "balanced",
    "perf": true,
    "maxMemory": "4096",
    "validate": true,
    "chunkSize": "300000",
    "chunking": true,
    "debugChunks": false,
    "turbo": true,
    "refine": true
  }
}