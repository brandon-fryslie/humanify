{
  "version": "2.0.0",
  "timestamp": 1763351437249,
  "inputHash": "4f356e1f309d2125",
  "completedBatches": 49,
  "totalBatches": 131,
  "renames": {
    "zx0": "processImageTransformation",
    "qx0": "ImageProcessingEngine",
    "MJ1": "MAX_IMAGE_SIZE",
    "VjA": "maxImageDimension",
    "KjA": "MAX_IMAGE_DIMENSION",
    "DjA": "initializeDjA",
    "EjA": "execSyncChildProcess",
    "Qn9": "extractFileExtension",
    "In9": "getExtensionFromFile",
    "Gn9": "isPathAbsolute",
    "HbI": "getErrorDescriptionForOutputFile",
    "HjA": "HIGHLIGHTED_MAX_WIDTH",
    "Ox0": "outputFileHandler",
    "dh": "displayHandler",
    "Xn9": "imageProcessingFunction",
    "KH": "ReactContext",
    "yx0": "imageProcessingPipeline",
    "Wn9": "imageProcessingOperation",
    "qJA": "componentKey",
    "Cn9": "resolveFilePath",
    "Fn9": "updateImageFormatBasedOnOptions",
    "_x0": "sharpImageProcessor",
    "vx0": "fileFormatMap",
    "Vn9": "defaultImageProcessor",
    "Kn9": "getPathFromHomeDirectory",
    "PJ1": "initializeShapelessPipeline",
    "Hn9": "ImageProcessingModule",
    "zn9": "errorMessages",
    "jJ1": "initializeCustomSettings",
    "yJ1": "generateRandomBytes",
    "B3": "LineSeparator",
    "NjA": "getFolderPath",
    "LjA": "processImageTransformations",
    "$n9": "imageProcessor",
    "hk": "outputImageFormatHandler",
    "qn9": "validateOutputFilePath",
    "ch": "character",
    "nx0": "processImageInput",
    "ax0": "processImage",
    "Rn9": "_imageProcessingPipeline",
    "Tn9": "_processImage",
    "Mi": "setExifData",
    "_J1": "transformImageFormats",
    "ph": "imageProcessingHandler",
    "Av0": "_imageProcessor",
    "Qv0": "ImageProcessingPipeline",
    "Zv0": "processorFunction",
    "Xv0": "__imageProcessingPipeline",
    "Fv0": "__processImage",
    "Vv0": "___imageProcessingPipeline",
    "Dv0": "updateImageOutputOptions",
    "Hv0": "handleImageFormatConversion",
    "Uv0": "imageConversionPipeline",
    "$v0": "____imageProcessingPipeline",
    "RjA": "updateImageFormatSettings",
    "Pv0": "_____imageProcessingPipeline",
    "Sv0": "_imageProcessingHandler",
    "kv0": "enhancedImageProcessingPipeline",
    "vv0": "convertImageFormat",
    "fv0": "processImagePipeline",
    "TjA": "initializeSharpImageProcessing",
    "av0": "______imageProcessingPipeline",
    "rv0": "outputFilePath",
    "Qb0": "outputImageProcessingFunction",
    "uJ1": "processImageAndGenerateOutput",
    "Vs9": "initializeImageProcessingSettings",
    "DH": "ImageHandler",
    "Oi": "setExifMergeOptions",
    "kM": "handleImageProcessing",
    "Ks9": "imageProcessingModule",
    "Xb0": "_______imageProcessingPipeline",
    "Ds9": "imageProcessingOptions",
    "Es9": "_ImageProcessingPipeline",
    "Hs9": "__imageProcessor",
    "Wb0": "__imageProcessingHandler",
    "zs9": "initializeImageProcessingModule",
    "Us9": "processImageOps",
    "ws9": "processImageInWorkflow",
    "HU": "handleImageOutput",
    "mJ1": "maxImageSize",
    "Kb0": "________imageProcessingPipeline",
    "$s9": "jpegOutputFileExtensionRegex",
    "Fb0": "initializeAndLoadImageProcessing",
    "qs9": "processImageConversion",
    "Ns9": "NodePipeline",
    "Ms9": "_________imageProcessingPipeline",
    "Cb0": "__ImageProcessingPipeline",
    "Db0": "_ImageProcessor",
    "Os9": "__________imageProcessingPipeline",
    "zb0": "processAudioFile",
    "Rs9": "ImageProcessor",
    "Ts9": "_processImageInput",
    "wb0": "imageProcessingService",
    "Ps9": "___processImage",
    "dJ1": "updateOutputFilePath",
    "mG": "imageFormatHandler",
    "js9": "___imageProcessor",
    "Ss9": "____imageProcessor",
    "lJ1": "sharpImageProcessing",
    "$b0": "_imageProcessingOptions",
    "yjA": "imagePipeline",
    "kjA": "ImageTransformProcessor",
    "iJ1": "_validateOutputFilePath",
    "ys9": "_processImageTransformation",
    "ks9": "__processImageTransformation",
    "_s9": "updateImageOutputFormat",
    "qb0": "___processImageTransformation",
    "KG": "___________imageProcessingPipeline",
    "_M": "____________imageProcessingPipeline",
    "xs9": "imageTransformationProcessor",
    "vs9": "validateImageOutputOptions",
    "Ti": "_imageTransformationProcessor",
    "PjA": "____processImageTransformation",
    "_0A": "_____imageProcessor",
    "bs9": "_____processImageTransformation",
    "fs9": "__validateOutputFilePath",
    "pJ1": "initializeImageProcessing",
    "RJA": "______processImageTransformation",
    "gs9": "_______processImageTransformation",
    "TJA": "imageTransformationPipeline",
    "Nb0": "________processImageTransformation",
    "jjA": "_processImageTransformations",
    "cJ1": "_imageTransformationPipeline",
    "ds9": "_____________imageProcessingPipeline",
    "cs9": "_________processImageTransformation",
    "ps9": "processImageTransformationHandler",
    "ls9": "__________processImageTransformation",
    "V6": "_updateImageFormatBasedOnOptions",
    "aJ1": "___________processImageTransformation",
    "is9": "isJPEG2000Format",
    "jb0": "____________processImageTransformation",
    "ns9": "__imageTransformationProcessor",
    "as9": "_____________processImageTransformation",
    "ss9": "validateImageOutputSettings",
    "Mb0": "__imageTransformationPipeline",
    "rs9": "______________imageProcessingPipeline",
    "os9": "imageFileProcessor",
    "sJ1": "______________processImageTransformation",
    "Qr9": "_______________processImageTransformation",
    "Ir9": "________________processImageTransformation",
    "Gr9": "_________________processImageTransformation",
    "rJ1": "__ImageTransformationProcessor",
    "_b0": "___________________processImageTransformation",
    "bb0": "__processImageTransformations",
    "Yr9": "____________________processImageTransformation",
    "Jr9": "___imageTransformationProcessor",
    "Xr9": "_____________________processImageTransformation",
    "x0A": "ImageTransformationProcessor",
    "vb0": "____imageTransformationProcessor",
    "fb0": "_handleImageProcessing",
    "xjA": "______________________processImageTransformation",
    "PJA": "_ImageTransformationProcessor",
    "v0A": "OpenImageProcessingEngine",
    "bjA": "_____imageTransformationProcessor",
    "EH": "_______________________processImageTransformation",
    "jJA": "________________________processImageTransformation",
    "SJA": "_________________________processImageTransformation",
    "yJA": "transformImagePipeline",
    "kJA": "__________________________processImageTransformation",
    "Pi": "setKeepMetadataOptions",
    "oJ1": "_______________imageProcessingPipeline",
    "_JA": "___________________________processImageTransformation",
    "xJA": "_processImageTransformationHandler",
    "vJA": "______imageTransformationProcessor",
    "tJ1": "____________________________processImageTransformation",
    "fJA": "processImageTransformationFunction",
    "BX1": "_____________________________processImageTransformation",
    "kf0": "______________________________processImageTransformation",
    "if0": "_validateImageOutputOptions",
    "Kh0": "________________imageProcessingPipeline",
    "sh": "processImageTransformatio",
    "fh0": "___validateOutputFilePath",
    "XX1": "__updateImageFormatBasedOnOptions",
    "Ig0": "______imageProcessor",
    "Zg0": "_______________________________processImageTransformation",
    "wg0": "________________________________processImageTransformation",
    "jg0": "_processImageTransformationFunction",
    "Iu0": "_________________________________processImageTransformation",
    "Ku0": "__________________________________processImageTransformation",
    "th": "imageTransformationHandler",
    "cu0": "___________________________________processImageTransformation",
    "Ad0": "_______imageTransformationProcessor",
    "IbI": "processImageOutput",
    "Hx0": "registerImageProcessingMethods",
    "NJ1": "pathModule",
    "Y1": "inputValidator",
    "O0A": "_______imageProcessor",
    "Vx0": "supportedImageFormats",
    "$i9": "jp2FileExtensionRegex",
    "Kx0": "generateJP2Error",
    "Dx0": "calculateBitDepth",
    "cgI": "initializeImportsAndSetup",
    "ym0": "moduleExports",
    "dX1": "defineProperty",
    "yB4": "getOwnPropertyDescriptor",
    "kB4": "getOwnPropertyNames",
    "_B4": "objectHasOwnProperty",
    "Om0": "_moduleExports",
    "VgI": "handleHttpRequest",
    "ng0": "nodeHttpHandler",
    "OA4": "createObject",
    "gJA": "definePropertyWithDescriptor",
    "RA4": "getOwnPropertyDescriptorFromObject",
    "TA4": "_getOwnPropertyNames",
    "PA4": "getPrototypeOfObject",
    "jA4": "_hasOwnProperty",
    "gg0": "nodeHttpHandlerExports",
    "CX1": "httpAgent",
    "VX1": "HttpsAgentInstance",
    "_A4": "commonNetworkErrors",
    "zH": "timeoutHandler",
    "xg0": "DEFAULT_REQUEST_TIMEOUT",
    "vA4": "DEFAULT_SOCKET_TIMEOUT",
    "vg0": "defaultRequestTimeout",
    "cg0": "createStreamModule",
    "bg0": "_defaultRequestTimeout",
    "lg0": "__defaultRequestTimeout",
    "fg0": "Http2Protocol",
    "hgI": "initializeModule",
    "Cm0": "__moduleExports",
    "yX1": "_defineProperty",
    "S04": "_getOwnPropertyDescriptor",
    "y04": "getObjectOwnPropertyNames",
    "k04": "__hasOwnProperty",
    "Gm0": "___moduleExports",
    "f04": "parseBooleanString",
    "g04": "MAX_32_BIT_FLOAT",
    "pJA": "validateIntegerValue",
    "m04": "convertToTypedInteger",
    "d04": "expectNonNullValue",
    "Zm0": "expectObject",
    "i04": "numericRegexPattern",
    "Jm0": "parseSpecialFloatValue",
    "MSA": "generateStackTrace",
    "lJA": "consoleLogger",
    "t04": "weekDaysShort",
    "vX1": "monthsArray",
    "AB4": "RFC3339DateTimePattern",
    "QB4": "rfc3339DateTimeRegex",
    "GB4": "RFC7231DateTimeRegex",
    "ZB4": "rfcWeekdayDateTimeFormat",
    "YB4": "rfc7231DateTimeRegex",
    "FB4": "MAX_DATE_DIFF_MILLIS",
    "VB4": "daysInMonth",
    "DB4": "isLeapYear",
    "HB4": "parseTimezoneOffset",
    "d0A": "removeLeadingZeros",
    "wB4": "splitCSV",
    "Fm0": "NumericValue",
    "SgI": "createSchemaExports",
    "Im0": "importSchema",
    "LX1": "__defineProperty",
    "C04": "__getOwnPropertyDescriptor",
    "V04": "__getOwnPropertyNames",
    "K04": "___hasOwnProperty",
    "tu0": "schemaExports",
    "uJA": "invokeOrReturnValue",
    "NX1": "extractRequestIdFromHeaders",
    "eu0": "deserializerMiddlewareOption",
    "Am0": "serializerMiddlewareOptions",
    "u0A": "SchemaDefinition",
    "rY": "SchemaTypeRegistry",
    "tgI": "createHttpRequestSigningMiddleware",
    "pm0": "identityProviderExports",
    "SSA": "definePropertyWithConfig",
    "sB4": "___getOwnPropertyDescriptor",
    "rB4": "___getOwnPropertyNames",
    "oB4": "_objectHasOwnProperty",
    "km0": "_identityProviderExports",
    "vm0": "httpAuthSchemeEndpointRuleSetMiddlewareOptions",
    "hm0": "httpSigningMiddlewareOptions",
    "dm0": "DEFAULT_IDENTITY_EXPIRATION_MS",
    "LgI": "httpRequestHandler",
    "Mu0": "ModuleExports",
    "wSA": "definePropertyWithSetter",
    "S14": "____getOwnPropertyDescriptor",
    "y14": "____getOwnPropertyNames",
    "k14": "____hasOwnProperty",
    "wu0": "httpHandlerExports",
    "USA": "httpKeepAliveSupport",
    "NhI": "createHttpHandlerExtensionConfiguration",
    "Af0": "httpHandlerConfigurationModule",
    "ujA": "___defineProperty",
    "Rr9": "_____getOwnPropertyDescriptor",
    "Tr9": "_____getOwnPropertyNames",
    "Pr9": "_____hasOwnProperty",
    "rb0": "____moduleExports",
    "_hI": "initializeHttpHandlerModule",
    "of0": "_____moduleExports",
    "ejA": "definePropertyWithName",
    "ro9": "______getOwnPropertyDescriptor",
    "oo9": "______getOwnPropertyNames",
    "to9": "______hasOwnProperty",
    "nf0": "______moduleExports",
    "hhI": "configureHttpHandler",
    "Fh0": "httpHandlerExtensionConfig",
    "QSA": "____defineProperty",
    "Et9": "_______getOwnPropertyDescriptor",
    "Ht9": "_______getOwnPropertyNames",
    "zt9": "_______hasOwnProperty",
    "Yh0": "httpHandlerExtensions",
    "YgI": "setupHttpHandlerExtensionConfiguration",
    "Mg0": "_______moduleExports",
    "FSA": "_definePropertyWithConfig",
    "te9": "________getOwnPropertyDescriptor",
    "ee9": "________getOwnPropertyNames",
    "AA4": "________hasOwnProperty",
    "$g0": "_httpHandlerExports",
    "zgI": "httpHandlerExtensionConfigFactory",
    "Xu0": "________moduleExports",
    "ESA": "definePropertyWithMetadata",
    "I14": "getPropertyDescriptor",
    "G14": "getObjectPropertyNames",
    "Z14": "_________hasOwnProperty",
    "Gu0": "httpHandlerConfiguration",
    "mfI": "compareVersionSets",
    "Bb0": "exportVersionComparisonFunction",
    "ov0": "VersionSetComparator",
    "fJ1": "createVersionValidator",
    "OJA": "compareVersionConstraints",
    "hJ1": "compareSemver",
    "Q": "streamedDataCollector",
    "fhI": "createDeserializerMiddleware",
    "Zh0": "_________moduleExports",
    "ASA": "_definePropertyWithName",
    "Xt9": "_________getOwnPropertyDescriptor",
    "Wt9": "_________getOwnPropertyNames",
    "Ft9": "__________hasOwnProperty",
    "ef0": "serializerAndDeserializerSetup",
    "Qh0": "deserializerMiddlewareOptions",
    "Ih0": "_serializerMiddlewareOptions",
    "A": "______imageData",
    "Z": "transformImageWithEncoding",
    "Y": "_imageBuffer",
    "J": "____imageData",
    "X": "parsedSeconds",
    "W": "____fractionalMilliseconds",
    "F": "dataTransform",
    "b": "requestPayload",
    "C": "enqueueData",
    "V": "verifiedChecksum",
    "K": "dayOfMonth",
    "D": "dateObject",
    "E": "currentPendingWrite",
    "H": "processMemberSchema",
    "x": "errorCode",
    "w": "__memberSchema",
    "L": "isNotType",
    "N": "requestFailureHandler",
    "$": "__abortError",
    "O": "headerEntry",
    "I": "isStreamTransformed",
    "G": "_initializeStreamTransformation",
    "qhI": "initializeExports",
    "sb0": "exportedModule",
    "hjA": "__definePropertyWithName",
    "Er9": "__________getOwnPropertyDescriptor",
    "Hr9": "getOwnPropertyNamesImplemented",
    "zr9": "___________hasOwnProperty",
    "mb0": "_exportedModule",
    "Or9": "SMITHY_CONTEXT_KEY",
    "jhI": "initializeChecksumConfiguration",
    "Nf0": "__________moduleExports",
    "ijA": "___definePropertyWithName",
    "Wo9": "___________getOwnPropertyDescriptor",
    "Fo9": "__________getOwnPropertyNames",
    "Co9": "____________hasOwnProperty",
    "Df0": "___________moduleExports",
    "wo9": "_SMITHY_CONTEXT_KEY",
    "ShI": "validateAndDefineExportedProperties",
    "yf0": "____________moduleExports",
    "ajA": "_____defineProperty",
    "$o9": "____________getOwnPropertyDescriptor",
    "qo9": "___________getOwnPropertyNames",
    "No9": "_____________hasOwnProperty",
    "Lf0": "_____________moduleExports",
    "So9": "__SMITHY_CONTEXT_KEY",
    "khI": "defineExportedModules",
    "lf0": "______________moduleExports",
    "ojA": "______defineProperty",
    "go9": "_____________getOwnPropertyDescriptor",
    "uo9": "____________getOwnPropertyNames",
    "mo9": "hasOwnPropertyFallback",
    "ff0": "exportedModules",
    "so9": "___SMITHY_CONTEXT_KEY",
    "ZgI": "initializeApiConfigurations",
    "Ug0": "_______________moduleExports",
    "XSA": "____definePropertyWithName",
    "me9": "______________getOwnPropertyDescriptor",
    "de9": "_____________getOwnPropertyNames",
    "ce9": "hasOwnPropertyCheck",
    "Fg0": "__exportedModule",
    "oe9": "SMITHY_CONTEXT_IDENTIFIER",
    "HgI": "initializeModuleExports",
    "Qu0": "________________moduleExports",
    "KSA": "_______defineProperty",
    "iA4": "_______________getOwnPropertyDescriptor",
    "nA4": "______________getOwnPropertyNames",
    "aA4": "______________hasOwnProperty",
    "ag0": "_________________moduleExports",
    "Q14": "____SMITHY_CONTEXT_KEY",
    "IuI": "defineAndExportClientConfiguration",
    "em0": "__________________moduleExports",
    "ySA": "_definePropertyWithDescriptor",
    "wQ4": "________________getOwnPropertyDescriptor",
    "$Q4": "_______________getOwnPropertyNames",
    "qQ4": "_______________hasOwnProperty",
    "lm0": "clientConfigurationExports",
    "jQ4": "_____SMITHY_CONTEXT_KEY",
    "GbI": "initializeSharpModule",
    "$x0": "_initializeSharpModule",
    "ni9": "EventEmitter",
    "FjA": "imageProcessingLibrary",
    "p$": "parameterValidator",
    "ai9": "getRuntimePlatformArch",
    "LD": "libVipsInstance",
    "si9": "interpolationMethods",
    "sh0": "ReadableBufferedStream",
    "B": "streamCollector",
    "ThI": "loggerMiddlewareFunction",
    "Wf0": "loggerMiddlewareModule",
    "cjA": "_____definePropertyWithName",
    "ir9": "_________________getOwnPropertyDescriptor",
    "nr9": "________________getOwnPropertyNames",
    "ar9": "________________hasOwnProperty",
    "Yf0": "loggerModule",
    "Xf0": "loggerMiddlewareConfig",
    "jgI": "_initializeModuleExports",
    "eT": "___________________moduleExports",
    "qSA": "________defineProperty",
    "Y04": "__________________getOwnPropertyDescriptor",
    "J04": "getOwnPropertyNamesEnhanced",
    "X04": "_________________hasOwnProperty",
    "tT": "____________________moduleExports",
    "vu0": "streamTransformationMixin",
    "_u0": "streamTransformationErrorMessage",
    "xu0": "isBlobInstance",
    "PhI": "defineRecursionDetectionMiddleware",
    "Kf0": "_____________________moduleExports",
    "ljA": "______definePropertyWithName",
    "er9": "___________________getOwnPropertyDescriptor",
    "Ao9": "_________________getOwnPropertyNames",
    "Bo9": "_hasOwnPropertyCheck",
    "Ff0": "recursionDetectionPlugin",
    "AX1": "AWS_TRACER_HEADER",
    "Yo9": "awsLambdaFunctionName",
    "Jo9": "X_AMZN_TRACE_ID_ENV_VAR",
    "Vf0": "recursionDetectionMiddlewareOptions",
    "RhI": "createHostHeaderMiddleware",
    "Zf0": "initializeHostHeaderMiddleware",
    "djA": "_________defineProperty",
    "hr9": "____________________getOwnPropertyDescriptor",
    "gr9": "__________________getOwnPropertyNames",
    "ur9": "__________________hasOwnProperty",
    "Bf0": "hostHeaderManagement",
    "Gf0": "hostHeaderMiddlewareOptions",
    "lhI": "utf8ConversionFunctions",
    "Lh0": "utf8Utilities",
    "ZSA": "_______definePropertyWithName",
    "nt9": "_____________________getOwnPropertyDescriptor",
    "at9": "_getObjectOwnPropertyNames",
    "st9": "___________________hasOwnProperty",
    "$h0": "utf8Conversions",
    "dfI": "_imageProcessingModule",
    "Zb0": "imageProcessingExports",
    "gJ1": "___imageProcessingHandler",
    "Ib0": "semverConstants",
    "Pa9": "SemanticVersion",
    "Gb0": "imageIdentifierUtils",
    "ja9": "parseSemver",
    "ha9": "compareVersions",
    "pa9": "getGreaterThan",
    "la9": "lessThanVersion",
    "ia9": "compareSemanticVersions",
    "na9": "isVersionEqual",
    "aa9": "isGreaterThanOrEqualTo",
    "sa9": "lessThanOrEqualTo",
    "ra9": "_compareVersions",
    "oa9": "coerceVersion",
    "ta9": "ComparatorFunction",
    "ea9": "RangeHandler",
    "As9": "satisfiesVersion",
    "MgI": "hexadecimalConverter",
    "yu0": "______________________moduleExports",
    "$SA": "________definePropertyWithName",
    "u14": "getObjectPropertyDescriptor",
    "m14": "___________________getOwnPropertyNames",
    "d14": "__hasOwnPropertyCheck",
    "Tu0": "hexConversionModule",
    "Pu0": "hexValueMap",
    "zX1": "hexCharacterToDecimalMap",
    "gu0": "_streamTransformationMixin",
    "UX1": "StreamMixin",
    "hu0": "errorMessageStreamTransformed",
    "Mx0": "getClipboardImageHandler",
    "eh0": "streamUtils",
    "je9": "streamModule",
    "chI": "_________________imageProcessingPipeline",
    "Hh0": "initializeBufferConversion",
    "GSA": "_________definePropertyWithName",
    "vt9": "______________________getOwnPropertyDescriptor",
    "bt9": "____________________getOwnPropertyNames",
    "ft9": "____________________hasOwnProperty",
    "Eh0": "bufferConversionHandlers",
    "IX1": "bufferLibrary",
    "bfI": "validateVersionConstraints",
    "mv0": "validateSemverRange",
    "Ca9": "__compareVersions",
    "uv0": "createVersionComparisonFunction",
    "Ka9": "VersionRangeValidator",
    "Da9": "evaluateSemverConstraints",
    "hv0": "comparisonOperatorHandler",
    "gv0": "evaluateVersionConstraints",
    "Ea9": "_validateVersionConstraints",
    "Ha9": "validateVersionRange",
    "CgI": "buildQueryStringModule",
    "kg0": "_buildQueryStringModule",
    "VSA": "__________definePropertyWithName",
    "UA4": "_______________________getOwnPropertyDescriptor",
    "wA4": "_____________________getOwnPropertyNames",
    "$A4": "_____________________hasOwnProperty",
    "Sg0": "queryStringBuilder",
    "NgI": "transformImageAndBuildQueryString",
    "Hu0": "processAndExportModule",
    "zSA": "definePropertyDescriptor",
    "L14": "________________________getOwnPropertyDescriptor",
    "M14": "______________________getOwnPropertyNames",
    "O14": "___hasOwnPropertyCheck",
    "Du0": "_______________________moduleExports",
    "Sh0": "ChecksumStreamModule",
    "We9": "createChecksumStream",
    "hh0": "_createChecksumStream",
    "Jg0": "imageStreamHandler",
    "fe9": "StreamWritable",
    "yhI": "_imageTransformationHandler",
    "bf0": "________________________moduleExports",
    "rjA": "___________definePropertyWithName",
    "yo9": "_________________________getOwnPropertyDescriptor",
    "ko9": "_______________________getOwnPropertyNames",
    "_o9": "______________________hasOwnProperty",
    "vf0": "contextProvider",
    "FgI": "exportModule",
    "Pg0": "_________________________moduleExports",
    "CSA": "____________definePropertyWithName",
    "FA4": "getOwnPropertyDescriptorInsteadFA4",
    "CA4": "________________________getOwnPropertyNames",
    "VA4": "_______________________hasOwnProperty",
    "Rg0": "exportedUriUtils",
    "qgI": "defineEscapeUriFunctions",
    "Vu0": "_initializeExports",
    "HSA": "_____________definePropertyWithName",
    "E14": "__________________________getOwnPropertyDescriptor",
    "H14": "_________________________getOwnPropertyNames",
    "z14": "____hasOwnPropertyCheck",
    "Fu0": "uriEncoderModule",
    "xfI": "validateVersion",
    "xv0": "validateSemver",
    "vJ1": "SemverValidator",
    "Ja9": "_validateSemverRange",
    "_v0": "___compareVersions",
    "dhI": "validateArrayBuffer",
    "Vh0": "defineArrayBufferChecker",
    "ISA": "______________definePropertyWithName",
    "Tt9": "___________________________getOwnPropertyDescriptor",
    "Pt9": "__________________________getOwnPropertyNames",
    "jt9": "________________________hasOwnProperty",
    "Ch0": "arrayBufferUtils",
    "ufI": "createConditionalRanges",
    "sv0": "createExportedSortingFunction",
    "La9": "isConditionMet",
    "Ma9": "generateRangePairs",
    "Bg0": "awsChunkedEncodingStream",
    "_e9": "createAwsChunkedEncodingStream",
    "ph0": "ByteArrayModule",
    "ub0": "getFormattedTitleForClaude",
    "qfI": "compareVersionPragmatics",
    "Jv0": "versionComparisonFunction",
    "Yv0": "_createVersionComparisonFunction",
    "nhI": "defineAndExportModule",
    "YSA": "moduleExporter",
    "Th0": "__________defineProperty",
    "Ge9": "____________________________getOwnPropertyDescriptor",
    "Ze9": "___________________________getOwnPropertyNames",
    "Ye9": "_________________________hasOwnProperty",
    "YX1": "__________________________moduleExports",
    "dgI": "defineObjectProperties",
    "OSA": "exportsModule",
    "Um0": "___________defineProperty",
    "TB4": "_____________________________getOwnPropertyDescriptor",
    "PB4": "getOwnPropertyNamesWithOwnerCheck",
    "jB4": "__________________________hasOwnProperty",
    "fX1": "_exportModule",
    "Gg0": "streamReaderModule",
    "ch0": "ByteArrayCollector",
    "Rx0": "detectImageType",
    "ve9": "readDataChunks",
    "Mh0": "Base64Encoder",
    "Em0": "_Base64Encoder",
    "UB4": "splitIntoChunksByDelimiter",
    "zh0": "base64Decoder",
    "lt9": "base64ValidationRegex",
    "Vm0": "Base64Converter",
    "NB4": "_base64ValidationRegex",
    "Lu0": "readFileAsDataURL",
    "kh0": "streamAndBlobUtils",
    "Fe9": "isReadableStream",
    "Ce9": "isBlob",
    "iu0": "_streamUtils",
    "pu0": "__streamUtils",
    "kfI": "findBestMatch",
    "jv0": "exportHighestPriorityMatch",
    "Ba9": "findMatchingElement",
    "Qa9": "createTestInstance",
    "_fI": "_findBestMatch",
    "yv0": "findBestMatchingValue",
    "Ga9": "createComparisonObject",
    "Za9": "createTestObject",
    "ig0": "readStreamToUint8Array",
    "Nu0": "_readStreamToUint8Array",
    "Zn9": "getClipboardScreenshotMessage",
    "Request": "HttpRequest",
    "mh0": "___________________________moduleExports",
    "$fI": "incrementVersion",
    "Gv0": "exportVersionIncrementer",
    "Iv0": "VersionManager",
    "Blob": "_BinaryLargeObject",
    "Vr9": "getValidFiles",
    "JSA": "flushStreamByIndex",
    "$u0": "createTimeoutPromise",
    "vh0": "ChecksumStream",
    "Ke9": "StreamReader",
    "ReadableStream": "InputDataStream",
    "um0": "setSmithyFeature",
    "ah0": "getBufferType",
    "yi": "createStringWithJSONMethods",
    "ox0": "extractReferencesFromText",
    "du0": "___streamUtils",
    "wfI": "getVersionFromInput",
    "Bv0": "getVersion",
    "kn9": "_getVersion",
    "OfI": "getPrereleaseParts",
    "Ev0": "getPrereleaseVersions",
    "dn9": "_getPrereleaseVersions",
    "g3": "getServiceType",
    "Yb0": "formatStringBasedOnType",
    "Px0": "normalizeFilePath",
    "PfI": "compareInstances",
    "Nv0": "_compareInstances",
    "qv0": "ObjectComparator",
    "UfI": "getVersionFromData",
    "ex0": "getVersionFromQuery",
    "Sn9": "_getVersionFromData",
    "vfI": "createRangeWithFallback",
    "bv0": "createRangeFunction",
    "Wa9": "createRangeInstance",
    "tb0": "cloneObject",
    "sf0": "cloneObjectWithArrayValues",
    "Xh0": "_cloneObjectWithArrayValues",
    "Ng0": "cloneObjectWithArrays",
    "Yu0": "cloneObjectProperties",
    "gfI": "checkIntersects",
    "nv0": "checkIntersection",
    "iv0": "IntersectionChecker",
    "uk": "getCommandType",
    "aJA": "encodeUriComponentWithSpecialChars",
    "YbI": "processAndExportImage",
    "Nx0": "exportImageProcessingFunction",
    "fk": "_imageProcessingResult",
    "li9": "startStream",
    "En9": "getAppleTerminalStatus",
    "yfI": "createAndMapValues",
    "Tv0": "createAndExportArrayMapper",
    "en9": "_createAndMapValues",
    "Tx0": "removeQuotesFromString",
    "wn9": "getITerm2SetupStatus",
    "ix0": "handleReturnKey",
    "ArrayBuffer": "isArrayBuffer",
    "zB4": "wrapStringInQuotesIfNeeded",
    "bx0": "incrementProjectOnboardingSeenCount",
    "sx0": "formatPastedText",
    "Dn9": "initializeAppleTerminalSetup",
    "B04": "streamTeeProcessor",
    "xm0": "createSchemeMap",
    "jfI": "sortImageSettingsByFormat",
    "Lv0": "sortImagesByFormat",
    "SfI": "_sortImagesByFormat",
    "Ov0": "__sortImagesByFormat",
    "n": "frameId",
    "Un9": "setupIterm2WithBackupPath",
    "ffI": "sharpImageProcessingFilter",
    "dv0": "exportSharpImageProcessing",
    "hfI": "sharpImageProcessingHandler",
    "pv0": "_sharpImageProcessing",
    "Oi9": "initializeWithExif",
    "NfI": "createMajorInstance",
    "Wv0": "createMajorFromInputs",
    "bn9": "_createMajorInstance",
    "LfI": "createMinorMatrix",
    "Cv0": "createMinorFunction",
    "hn9": "createMinorInstance",
    "MfI": "createPatchFunction",
    "Kv0": "_createPatchFunction",
    "un9": "createPatchInstance",
    "RfI": "requestFunction",
    "zv0": "exportFunction",
    "pn9": "createCustomFunction",
    "TfI": "createIn9Function",
    "wv0": "exportedFunction",
    "in9": "createAndExportFunctionWithParams",
    "_jA": "ensureArray",
    "fi9": "applyAv1Compression",
    "LJA": "_initializeAppleTerminalSetup",
    "S0A": "setupInProgressAndNotify",
    "k0A": "filterOutHookProgress",
    "eb0": "isValidIdentifier",
    "rf0": "_isValidIdentifier",
    "Wh0": "_isValidUsername",
    "Lg0": "__isValidIdentifier",
    "Ju0": "__isValidUsername",
    "Li9": "setKeepMetadataFlag",
    "Ri9": "updateMetadataOptions",
    "Pi9": "setKeepMetadataOption",
    "cx0": "isShiftEnterKeyBindingInstalled",
    "px0": "isMetaKeyOptionInstalled",
    "MjA": "countNewlines",
    "lx0": "checkIfBackslashReturnUsed",
    "g0A": "getArrayByteLength",
    "Jb0": "isSpecialCharacter",
    "gb0": "findItemByValue",
    "HX1": "createRequest",
    "rx0": "generateImageTag",
    "Pn9": "parseJsonString",
    "Qf0": "identityFunction",
    "CjA": "___imageTransformationPipeline",
    "UjA": "________imageTransformationProcessor",
    "Sx0": "_________imageTransformationProcessor",
    "Mv0": "___processImageTransformations",
    "Rv0": "______________________________________processImageTransformation",
    "cv0": "imageTransformProcessor",
    "lv0": "__________imageTransformationProcessor",
    "Ls9": "____imageTransformationPipeline",
    "Vb0": "___________imageTransformationProcessor",
    "hs9": "processImageOutputHandler",
    "SjA": "imageProcessingWorkflow",
    "ms9": "__processImageTransformationHandler",
    "Lb0": "_______________________________________processImageTransformation",
    "Tb0": "____________imageTransformationProcessor",
    "Br9": "_____________imageTransformationProcessor",
    "HH": "imageProcessingMethods",
    "bI": "______________imageTransformationProcessor",
    "tf0": "_processImageTransform",
    "ji": "updateMetadata",
    "dG": "________________________________________processImageTransformation",
    "oh0": "_________________________________________processImageTransformation",
    "Wg0": "_______________imageTransformationProcessor",
    "Og0": "__________________________________________processImageTransformation",
    "_g0": "imageProcessingTransformation",
    "Wu0": "________________imageTransformationProcessor",
    "zu0": "__processImageTransformationFunction",
    "nu0": "_________________imageTransformationProcessor",
    "xB4": "defineProperties",
    "vB4": "copyPropertiesFromSourceToTarget",
    "Tm0": "replaceHttpLabelInPath",
    "W7": "setFunctionName",
    "SA4": "_defineProperties",
    "hg0": "copyPropertiesFromSource",
    "_04": "__defineProperties",
    "x04": "assignPropertiesIfNew",
    "h04": "convertToBooleanValue",
    "cJA": "convertToNumber",
    "u04": "validateIntegerInput",
    "kX1": "validateTypedInteger",
    "c04": "expectStringValue",
    "p04": "expectUnionValue",
    "c0A": "parseNumericString",
    "CB4": "adjustDateForHistoricalLimit",
    "TX1": "convertMonthToIndex",
    "KB4": "validateDayInMonth",
    "D04": "___defineProperties",
    "E04": "definePropertiesForObject",
    "MX1": "ListSchemaDefinition",
    "OX1": "MapSchemaDefinition",
    "Bm0": "OperationSchema",
    "NSA": "StructureSchema",
    "RX1": "ReactiveSchema",
    "cG": "defineFunctionName",
    "tB4": "____defineProperties",
    "eB4": "copyPropertiesNonEnumerably",
    "jSA": "___________________________________________processImageTransformation",
    "oT": "_setFunctionName",
    "_14": "_____defineProperties",
    "x14": "assignPropertiesFromSource",
    "ih": "_______________definePropertyWithName",
    "jr9": "definePropertyForObject",
    "Sr9": "______defineProperties",
    "ob0": "createHttpHandlerMethod",
    "nh": "_defineFunctionName",
    "eo9": "definePropertiesWithGetters",
    "At9": "defineNonEnumerableProperties",
    "af0": "__validateImageOutputOptions",
    "ah": "________________definePropertyWithName",
    "Ut9": "assignProperties",
    "wt9": "definePropertiesFromObject",
    "Jh0": "__________________imageTransformationProcessor",
    "rh": "__definePropertyWithConfig",
    "BA4": "_______defineProperties",
    "QA4": "copyOwnProperties",
    "qg0": "createHttpRequestInstance",
    "oh": "_________________definePropertyWithName",
    "Y14": "_definePropertiesWithGetters",
    "J14": "_defineNonEnumerableProperties",
    "Zu0": "____________________________________________processImageTransformation",
    "bJ1": "ANY_VERSION",
    "Ra9": "prereleaseValidator",
    "tv0": "defaultVersionConstraints",
    "ev0": "____compareVersions",
    "Ab0": "compareSemverConstraints",
    "BSA": "defineFunctionWithName",
    "Ct9": "________defineProperties",
    "Vt9": "definePropertiesFromSource",
    "mi9": "validateAndSetTileOptions",
    "bi9": "setTiffOptions",
    "gjA": "__________________definePropertyWithName",
    "Ur9": "defineEnumerableProperties",
    "wr9": "definePropertiesWithGettersAndEnumerability",
    "njA": "___________________definePropertyWithName",
    "Vo9": "_________defineProperties",
    "Ko9": "_definePropertiesFromSource",
    "sjA": "____________________definePropertyWithName",
    "Lo9": "defineGetters",
    "Mo9": "defineExportedProperties",
    "tjA": "___definePropertyWithConfig",
    "do9": "_defineExportedProperties",
    "co9": "_defineObjectProperties",
    "WSA": "_____________________definePropertyWithName",
    "pe9": "definePropertiesFrom",
    "le9": "copyProperties",
    "DSA": "_defineFunctionWithName",
    "sA4": "definePropertyGetters",
    "rA4": "__definePropertiesFromSource",
    "kSA": "______________________definePropertyWithName",
    "NQ4": "__________defineProperties",
    "LQ4": "_copyPropertiesFromSource",
    "Ux0": "getPlatformArchitecture",
    "LJ1": "libVipsVersion",
    "mh": "imageFormatManager",
    "oi9": "eventEmitterInstance",
    "yi9": "configureJpegCompressionOptions",
    "Le9": "updateImageFormat",
    "ii9": "_processImagePipeline",
    "eJ1": "__setFunctionName",
    "sr9": "___________defineProperties",
    "rr9": "__defineNonEnumerableProperties",
    "Nn9": "installWezTermShiftEnterKeyBinding",
    "ki9": "configurePngOptions",
    "qX1": "___setFunctionName",
    "W04": "____________defineProperties",
    "wX1": "addPropertiesFromObject",
    "a14": "__imageTransformationHandler",
    "ku0": "_____________________________________________processImageTransformation",
    "hi9": "setHeifOptions",
    "pjA": "__defineFunctionWithName",
    "Qo9": "extendObjectWithProperties",
    "Io9": "_assignPropertiesFromSource",
    "mjA": "__defineFunctionName",
    "mr9": "addHostHeaderProperties",
    "dr9": "addObjectProperties",
    "Ln9": "installGhosttyShiftEnterKeyBindingHandler",
    "GX1": "definePropertyWithNameForExport",
    "rt9": "_____________defineProperties",
    "ot9": "___definePropertiesFromSource",
    "Sa9": "validateImageProcessing",
    "ya9": "cleanProcessedImage",
    "ka9": "_incrementVersion",
    "_a9": "diffImageProcessing",
    "xa9": "getMajorVersion",
    "va9": "calculateImageMinorVersion",
    "ba9": "updateImagePatchOptions",
    "fa9": "handleImagePreprocessing",
    "ga9": "imageConversionComparisonPipeline",
    "ua9": "compareLooseSemanticVersions",
    "ma9": "compareImageFormatSettings",
    "Bs9": "toComparatorsPipeline",
    "Qs9": "getMaxSatisfyingVersion",
    "Is9": "minSatisfyingVersion",
    "Gs9": "minVersionHandler",
    "Zs9": "validRange",
    "Ys9": "processOutsideImagePipeline",
    "Ws9": "intersectImageProcessingPipelines",
    "Fs9": "simplifyImageProcessingRange",
    "Cs9": "outputImagePipelineSettings",
    "Ru0": "___defineFunctionName",
    "c14": "______________defineProperties",
    "p14": "definePropertiesIfNotExists",
    "SJ1": "installTerminalShiftEnterKeyBinding",
    "vi9": "updateJP2Options",
    "gi9": "configureJxlOptions",
    "th0": "___updateImageFormatBasedOnOptions",
    "Se9": "______________________________________________processImageTransformation",
    "Dh0": "___defineFunctionWithName",
    "ht9": "_______________defineProperties",
    "gt9": "definePropertiesIfNotExist",
    "mt9": "initializeImageProcessingPipeline",
    "Va9": "ANY_VERSION_COMPARISON",
    "qA4": "____defineFunctionName",
    "NA4": "associateProperties",
    "LA4": "___defineNonEnumerableProperties",
    "FX1": "___processImageTransformationFunction",
    "R14": "_____defineFunctionName",
    "T14": "_assignProperties",
    "P14": "copyObjectProperties",
    "EX1": "_______________________________________________processImageTransformation",
    "Ee9": "__createChecksumStream",
    "He9": "____validateOutputFilePath",
    "he9": "_imageTransformProcessor",
    "ge9": "________________________________________________processImageTransformation",
    "xf0": "_______________________definePropertyWithName",
    "xo9": "_defineGetters",
    "vo9": "assignPropertiesIfNotPresent",
    "_f0": "processImageTransformationResult",
    "WX1": "definePropertyWithNameAndValue",
    "KA4": "________________defineProperties",
    "DA4": "____defineNonEnumerableProperties",
    "DX1": "definePropertyWithNameAndDescription",
    "U14": "defineGetterProperties",
    "w14": "_definePropertyForObject",
    "Xa9": "findHighestValidSemver",
    "St9": "____setFunctionName",
    "yt9": "assignGetterProperties",
    "kt9": "copyPropertiesIfNotDefined",
    "yb0": "ImageTransformationWatcher",
    "xe9": "createChunkedEncodingStream",
    "ji9": "processMetadataOptions",
    "vn9": "_____compareVersions",
    "TJ1": "generateOnboardingTips",
    "kb0": "ImageWatcher",
    "ZX1": "copyPropertiesToTarget",
    "bX1": "_definePropertiesFromObject",
    "Ex0": "configureLoopAndDelay",
    "$jA": "restoreAppleTerminalSettings",
    "Mi9": "processExifDataAndStore",
    "qi9": "validateAndProcessOutputFile",
    "Yg0": "BufferedStreamWriter",
    "ts9": "createMatcherFunction",
    "Eb0": "initializeFileReading",
    "ui9": "validateInputDepthAndSet",
    "pg0": "pipeToDestinationStream",
    "Ti9": "setIccProfileAndMetadataOptions",
    "e04": "convertDateToUtcString",
    "ju0": "convertHexStringToUint8Array",
    "I04": "_________________________________________________processImageTransformation",
    "lu0": "imageTransformationUtils",
    "Ia9": "findBestMatchingElement",
    "Ya9": "findBestMatchForInputs",
    "Ue9": "imageTransformationProcess",
    "di9": "setTimeoutOptions",
    "Bn9": "processImageOperations",
    "An9": "validateAndProcessImage",
    "Ni9": "setResolveOption",
    "es9": "normalizeImagePath",
    "xn9": "__incrementVersion",
    "OjA": "streamExifData",
    "wx0": "configureCacheSettings",
    "wjA": "RenderImageWithChildren",
    "MJA": "isEnvironmentSupportedForImageTransformations",
    "Buffer": "DataBuffer",
    "Infinity": "MAX_SAFE_TIMESTAMP",
    "Si9": "processImageByFormat",
    "Kr9": "processImageKeyTransformation",
    "_n9": "extractVersion",
    "cn9": "extractPrereleaseTags",
    "an9": "compareObjectInstances",
    "nh0": "updateValueInArray",
    "Yn9": "getClipboardImagePath",
    "yn9": "fetchVersionFromData",
    "Fa9": "_createRangeWithFallback",
    "Na9": "_checkIntersection",
    "Aa9": "mapValuesToArray",
    "b0A": "subscribeToImageProcessing",
    "pi9": "setBooleanOption",
    "ci9": "setOutputFormat",
    "Dr9": "processImageDeletion",
    "Su0": "convertByteArrayToHexString",
    "Jn9": "processAndValidateFilePath",
    "hb0": "resetImageTransformation",
    "sn9": "compareImageFormats",
    "on9": "updateAndSortImagesByFormat",
    "Ua9": "sharpImageProcessingFilterHandler",
    "$a9": "initializeSharpImageProcessor",
    "fn9": "createMajorFromArgs",
    "gn9": "_createMinorMatrix",
    "mn9": "createPatch",
    "qjA": "getImageProcessingErrorMessages",
    "ln9": "createAndExportCustomFunction",
    "nn9": "createAndExportFunctionWithParamsAndFlag",
    "j0A": "getTerminalPreferencesPath",
    "Ri": "processCommand",
    "OJ1": "processFilePath",
    "Cr9": "processAndCacheImageTransformation",
    "ri9": "setConcurrencyLevel",
    "Fr9": "__________________________________________________processImageTransformation",
    "Zr9": "applyImageTransformation",
    "$B4": "convertToBigDecimal",
    "ei9": "validateAndProcessBoolean",
    "ti9": "getVipsCounters",
    "xM": "getServiceTypeValue",
    "xh0": "FileStreamReader",
    "yM": "_imageProcessingFunction",
    "Hb0": "_________imageProcessor",
    "Sb0": "__________________imageProcessingPipeline",
    "bJA": "initializeImageProcessor",
    "hJA": "createImageProcessor",
    "X7": "___________________imageTransformationProcessor",
    "wh0": "__processImageTransform",
    "J2": "___________________imageProcessingPipeline",
    "Ag0": "____________________imageTransformationProcessor",
    "F7": "processAndExportImageTransformation",
    "D4": "__processImagePipeline",
    "Dm0": "_____imageTransformationPipeline",
    "bB4": "copyAndDefineProperties",
    "fB4": "initializeAndExportMetadata",
    "qm0": "httpMetadataManager",
    "uB4": "updateMetadataUtil",
    "dB4": "updateMetadataHook",
    "yA4": "_initializeModule",
    "kA4": "transformExportedNodeHttpHandler",
    "ug0": "initializeHttpResponseProcessor",
    "mg0": "_imageProcessingTransformation",
    "dg0": "transformHeadersToString",
    "xA4": "setConnectionTimeoutHandler",
    "bA4": "_setSocketKeepAlive",
    "fA4": "_handleSocketTimeout",
    "uA4": "NodeHttp2ConnectionPool",
    "cA4": "CollectorWritableStream",
    "lA4": "_isReadableStream",
    "v04": "assignPropertiesToModule",
    "LSA": "validateFloat32",
    "PX1": "expectInt32Value",
    "jX1": "expectShortInteger",
    "SX1": "validateTypedInteger8Bit",
    "_X1": "strictParseDouble",
    "xX1": "__parseSpecialFloatValue",
    "Xm0": "strictParseLongInteger",
    "H04": "_createSchemaExports",
    "z04": "metadataUpdate",
    "U04": "_____________________imageTransformationProcessor",
    "$04": "______________________imageTransformationProcessor",
    "Qm0": "ExtendedStructureSchema",
    "AQ4": "createIdentityProviderExports",
    "BQ4": "getSmithyContextFromRequest",
    "_m0": "_______________________imageTransformationProcessor",
    "QQ4": "filterAuthOptionsBySchemeIds",
    "lX1": "httpRequestUtil",
    "YQ4": "defaultErrorHandler",
    "JQ4": "defaultSuccessHandler",
    "WQ4": "normalizeIdentityProvider",
    "FQ4": "makePagedClientRequest",
    "CQ4": "fetchNextTokenFromPaginationResult",
    "KQ4": "DefaultIdentityProviderConfig",
    "HQ4": "NoAuthSignatory",
    "cm0": "checkIfIdentityNeedsRefresh",
    "UQ4": "memoizeRequestDataProvider",
    "v14": "createModuleExports",
    "Uu0": "________________________imageTransformationProcessor",
    "b14": "____processImageTransformationFunction",
    "yr9": "defineExportedModule",
    "kr9": "getHttpHandlerExtensionConfiguration",
    "_r9": "resolveHttpHandlerRuntimeConfiguration",
    "xr9": "HttpRequestField",
    "vr9": "HttpFieldContainer",
    "fr9": "HttpResponseHandler",
    "Bt9": "defineModuleExports",
    "Qt9": "_createHttpHandlerExtensionConfiguration",
    "It9": "resolveHttpHandlerRuntimeConfig",
    "Gt9": "HttpField",
    "Zt9": "FieldCollection",
    "Jt9": "HttpResponse",
    "$t9": "defineExportProperties",
    "qt9": "_getHttpHandlerExtensionConfiguration",
    "Nt9": "resolveHttpHandlerConfig",
    "Lt9": "FieldDefinition",
    "Mt9": "HttpFieldsManager",
    "Rt9": "_HttpResponse",
    "IA4": "createHttpHandlerModule",
    "GA4": "__createHttpHandlerExtensionConfiguration",
    "ZA4": "_resolveHttpHandlerConfig",
    "YA4": "_HttpField",
    "JA4": "HttpFieldCollection",
    "WA4": "HttpResponseClass",
    "X14": "defineHttpHandlerExtensionConfiguration",
    "W14": "__getHttpHandlerExtensionConfiguration",
    "F14": "__resolveHttpHandlerConfig",
    "C14": "HttpHeader",
    "V14": "HttpHeadersCollection",
    "D14": "_HttpResponseHandler",
    "Ta9": "compareVersionItems",
    "Kt9": "createModuleWithProperties",
    "Dt9": "___________________________________________________processImageTransformation",
    "QX1": "findHeaderInResponseHeaders",
    "Bh0": "serializerMiddlewareFunction",
    "$r9": "createModuleExportsObject",
    "qr9": "defineChecksumAlgorithmManager",
    "Nr9": "generateChecksumAlgorithmMap",
    "Do9": "initializeModuleExportsWithChecksum",
    "Eo9": "_____createChecksumAlgorithmManager",
    "Ho9": "generateChecksumConstructorsMap",
    "Oo9": "createExportedModule",
    "Ro9": "_createChecksumAlgorithmProvider",
    "To9": "generateChecksumAlgorithmsMapping",
    "po9": "defineExportedModuleProperties",
    "lo9": "_defineChecksumAlgorithmManager",
    "io9": "generateChecksumMapFromAlgorithms",
    "ie9": "initializeExportedModule",
    "ne9": "createChecksumAlgorithmHandlerWithProperties",
    "ae9": "generateChecksumConstructorMap",
    "oA4": "_createModuleExports",
    "tA4": "______createChecksumAlgorithmManager",
    "eA4": "_generateChecksumConstructorMap",
    "MQ4": "createClientConfigurationExport",
    "OQ4": "_______createChecksumAlgorithmManager",
    "RQ4": "resolveChecksumConstructorsByAlgorithmId",
    "R0A": "sharpLibraryVersions",
    "or9": "createLoggerMiddlewareModule",
    "Jf0": "_loggerMiddlewareFunction",
    "eh": "addPropertiesAndExport",
    "F04": "createModuleWithExports",
    "Go9": "createRecursionDetectionMiddleware",
    "Zo9": "_imageProcessingMethods",
    "cr9": "createHostHeaderModule",
    "pr9": "imageProcessingMethodsInstance",
    "xi9": "setGifOptions",
    "_i9": "configureWebpOptions",
    "tt9": "createUtf8ConversionsModule",
    "qh0": "_____processImageTransformationFunction",
    "da9": "sortImageProcessing",
    "ca9": "sortDescendingByVersion",
    "Js9": "_________________________imageTransformationProcessor",
    "Xs9": "imageTransformProcessorLoose",
    "l14": "__createModuleExports",
    "t14": "processImageTransformationUtil",
    "mk": "_createImageProcessor",
    "ut9": "createBufferConversionModule",
    "dt9": "_createBufferFromArrayBuffer",
    "ct9": "convertStringToBuffer",
    "za9": "validateVersionComparison",
    "MA4": "createQueryStringBuilder",
    "j14": "createModuleExportsWithEscapedProperties",
    "ih0": "processStream",
    "T0A": "processAndTransformImage",
    "ue9": "streamToBufferWithLimit",
    "bo9": "createModuleExportsWithContext",
    "fo9": "getSmithyContext",
    "ho9": "normalizeToPromiseProvider",
    "EA4": "createNonEnumerableProperties",
    "HA4": "convertCharacterToHexadecimal",
    "$14": "createModuleWithExport",
    "q14": "convertCharacterToHexString",
    "_t9": "createArrayBufferModule",
    "xt9": "isArrayBufferChecker",
    "Ph0": "copyDefaultProperties",
    "Je9": "createModuleExport",
    "wm0": "defineAndExportProperties",
    "SB4": "_defineModuleExports",
    "kx0": "RenderImageWithMarkers",
    "KX1": "handleContinueExpectations",
    "Be9": "processImageToBase64",
    "MB4": "imageToBase64Encoder",
    "Wr9": "startImageTransformationWatcher",
    "pt9": "processImageBase64Transformation",
    "qB4": "processBase64String",
    "ux0": "restoreITerm2Settings",
    "mx0": "setOptionAsMetaKey",
    "yg0": "serializeQueryParamsToString",
    "Eu0": "_convertObjectToQueryString",
    "hx0": "exportTerminalPreferences",
    "dx0": "disableTerminalAudioBell",
    "gx0": "exportIterm2Settings",
    "Ub0": "processImageWithCallbacks",
    "G04": "processInputStreamForImageTransformation",
    "xJ1": "filterProjectExifDataStream",
    "Ob0": "checkImageWithPredicates",
    "xx0": "areOnboardingTipsComplete",
    "rn9": "sortImagesByFormatUsingSettings",
    "tn9": "___sortImagesByFormat",
    "wa9": "applySharpImageProcessingFilter",
    "qa9": "processImageWithThreshold",
    "RJ1": "___________imageProcessor",
    "lh": "imageTransformer",
    "us9": "____________________imageProcessingPipeline",
    "Rb0": "__________________________imageTransformationProcessor",
    "Pb0": "____________imageProcessor",
    "Rh0": "_____________________imageProcessingPipeline",
    "K6": "____________________________________________________processImageTransformation",
    "zm0": "______imageTransformationPipeline",
    "iJA": "_initializeImageProcessingPipeline",
    "RSA": "______________________imageProcessingPipeline",
    "uX1": "_______________________imageProcessingPipeline",
    "Pm0": "RequestBuilder",
    "TSA": "________________________imageProcessingPipeline",
    "pB4": "_________________________imageProcessingPipeline",
    "nJA": "____processImagePipeline",
    "lB4": "__________________________imageProcessingPipeline",
    "Lm0": "___________________________imageProcessingPipeline",
    "nB4": "____________________________imageProcessingPipeline",
    "PSA": "_____________________________imageProcessingPipeline",
    "gA4": "http2ModuleInitializer",
    "pA4": "streamDataCollector",
    "b04": "______________________________imageProcessingPipeline",
    "l04": "strictParseFloatValue",
    "Ym0": "validateFloat32Input",
    "n04": "handleSpecialFloatValue",
    "a04": "parseSpecialFloatString",
    "s04": "validateFloat32WithSpecialCases",
    "r04": "strictParsePositiveInteger",
    "o04": "expectInt32ValueFromInput",
    "m0A": "validateShortIntegerInput",
    "Wm0": "_validateTypedInteger8Bit",
    "XB4": "parseEpochTimestampToDate",
    "w04": "handleOperationResponseWithDeserialization",
    "q04": "createOperationRequest",
    "pX1": "httpAuthSchemeMiddlewareFunction",
    "GQ4": "___________________________imageTransformationProcessor",
    "fm0": "signHttpRequestMiddleware",
    "DQ4": "HttpApiKeyAuthSigner",
    "EQ4": "HttpBearerAuthSigner",
    "mm0": "createIsIdentityExpiredFunction",
    "Oa9": "_compareVersionSets",
    "Ah0": "deserializerMiddleware",
    "Lr9": "getDefaultClientConfiguration",
    "Mr9": "resolveChecksumConfiguration",
    "zo9": "_getDefaultClientConfiguration",
    "Uo9": "_resolveChecksumConfiguration",
    "Po9": "__getDefaultClientConfiguration",
    "jo9": "__resolveChecksumConfiguration",
    "no9": "___getDefaultClientConfiguration",
    "ao9": "generateChecksumMapFromInput",
    "se9": "____getDefaultClientConfiguration",
    "re9": "mapChecksumConstructorByAlgorithm",
    "A14": "getDefaultClientChecksumConfiguration",
    "B14": "resolveChecksumConstructorMap",
    "TQ4": "getDefaultChecksumAlgorithmConfiguration",
    "PQ4": "resolveDefaultChecksumConstructors",
    "tr9": "getLoggerPlugin",
    "su0": "_______________________________imageProcessingPipeline",
    "s14": "________________________________imageProcessingPipeline",
    "Cf0": "recursionDetectionMiddlewareFunction",
    "If0": "hostHeaderMiddleware",
    "On9": "configureAppleTerminalSettings",
    "Nh0": "convertFromUtf8",
    "Ae9": "convertToUtf8String",
    "Mn9": "installIterm2ShiftEnterKeyBinding",
    "o14": "initializeStreamTransformation",
    "ye9": "processImageStream",
    "Tg0": "escapeUriFn",
    "Cu0": "escapeUriFunction",
    "gm0": "paginateOperation",
    "Qe9": "_________________________________imageProcessingPipeline",
    "OB4": "__________________________________imageProcessingPipeline",
    "jx0": "processImageFileAsync",
    "it9": "decodeBase64ToUint8Array",
    "LB4": "_decodeBase64ToUint8Array",
    "zjA": "processClipboardImage",
    "Lx0": "processBase64ImageAndTransform",
    "Ar9": "createMatcherChain",
    "P0A": "completeProjectOnboardingIfRequired",
    "NJA": "imagePipelineProcessor",
    "h0A": "_____________imageProcessor",
    "hX1": "___imageTransformationHandler",
    "$m0": "_____________________________imageTransformationProcessor",
    "p0A": "_____________________________________________________processImageTransformation",
    "mX1": "______________________________________________________processImageTransformation",
    "mA4": "NodeHttp2ConnectionManager",
    "WB4": "normalizeYearForTwoDigitFormat",
    "AP": "validateIntegerInRange",
    "EB4": "convertFractionalMillisecondsToFloat32",
    "IQ4": "getHttpAuthSchemeEndpointRuleSetPlugin",
    "bm0": "httpAuthSchemeMiddlewareOptions",
    "XQ4": "getHttpSigningMiddleware",
    "zQ4": "isIdentityExpired",
    "nJ1": "ImageFileWatcher",
    "Xo9": "createRecursionDetectionPlugin",
    "lr9": "getHostHeaderPlugin",
    "et9": "__convertToUint8Array",
    "zA4": "escapeUriPathFn",
    "N14": "escapeUriPathFunction",
    "kJ1": "configureTerminalShiftEnterKeyBinding",
    "cX1": "validateTimestampSchema",
    "Ie9": "encodeToBase64",
    "RB4": "_encodeToBase64",
    "N04": "_createRequestHandler",
    "Gh0": "createMiddlewareStack",
    "cB4": "createRequestBuilder",
    "y0A": "___________________________________imageProcessingPipeline",
    "JX1": "____________________________________imageProcessingPipeline",
    "uh0": "_____processImagePipeline",
    "Ou0": "______________imageProcessor",
    "Nm0": "_____imageTransformationHandler",
    "Mm0": "______imageTransformationHandler",
    "dJA": "createDateFromComponents",
    "ZQ4": "getHttpAuthSchemePlugin",
    "h14": "_______________imageProcessor",
    "au0": "imageProcessorInstance",
    "n14": "________________imageProcessor",
    "Xe9": "_________________imageProcessor",
    "De9": "initializeChecksumProcessor",
    "xb0": "________imageProcessingHandler",
    "dh0": "__________________imageProcessor",
    "fu0": "_________________________________________________________processImageTransformation",
    "jm0": "FromStringShapeDeserializer",
    "Sm0": "StringShapeSerializer",
    "BB4": "parseRfc3339DateTime",
    "IB4": "parseRFC3339DateTimeWithOffset",
    "JB4": "parseRfc7231DateTimeString",
    "i14": "imageStreamTransformer",
    "ze9": "___createChecksumStream",
    "jh0": "_ChecksumStream",
    "we9": "__ChecksumStream",
    "$e9": "______processImagePipeline",
    "ru0": "processInputData",
    "qu0": "processImageFromFile",
    "vjA": "_initializeImageProcessing",
    "mu0": "___________________imageProcessor",
    "iB4": "HttpInterceptingShapeDeserializer",
    "aB4": "HttpInterceptingShapeSerializer",
    "g14": "_convertBlobToUint8Array",
    "r14": "createStreamTransformationMixin",
    "e14": "__streamTransformationMixin",
    "TransformStream": "ChecksumTransformStream",
    "qe9": "processInputStream",
    "fjA": "__initializeImageProcessing",
    "Ag": "____________________imageProcessor",
    "A04": "applyStreamTransformation",
    "TextDecoder": "CustomTextDecoder",
    "b6": "createImageProcessingPipeline",
    "gX1": "___initializeImageProcessing",
    "hB4": "getImageProcessor",
    "yQ": "_createHttpRequestSigningMiddleware",
    "l0A": "collectBodyFromHttpResponse",
    "VQ4": "_____________________________________imageProcessingPipeline",
    "Rm0": "HttpRequestHandler"
  },
  "partialCode": "var processImageTransformation = z((processImageOutput, registerImageProcessingMethods) => {\n  var pathModule = EA(\"node:path\");\n  var inputValidator = iT();\n  var _______imageProcessor = HJA();\n  var supportedImageFormats = new Map([[\"heic\", \"heif\"], [\"heif\", \"heif\"], [\"avif\", \"avif\"], [\"jpeg\", \"jpeg\"], [\"jpg\", \"jpeg\"], [\"jpe\", \"jpeg\"], [\"tile\", \"tile\"], [\"dz\", \"tile\"], [\"png\", \"png\"], [\"raw\", \"raw\"], [\"tiff\", \"tiff\"], [\"tif\", \"tiff\"], [\"webp\", \"webp\"], [\"gif\", \"gif\"], [\"jp2\", \"jp2\"], [\"jpx\", \"jp2\"], [\"j2k\", \"jp2\"], [\"j2c\", \"jp2\"], [\"jxl\", \"jxl\"]]);\n  var jp2FileExtensionRegex = /\\.(jp[2x]|j2[kc])$/i;\n  var generateJP2Error = () => Error(\"JP2 output requires libvips with support for OpenJPEG\");\n  var calculateBitDepth = calculateBitShiftForLog2 => 1 << 31 - Math.clz32(Math.ceil(Math.log2(calculateBitShiftForLog2)));\n  function validateAndProcessOutputFile(___outputFilePath, ___callbackFunction) {\n    let ______________________error;\n    if (!inputValidator.string(___outputFilePath)) {\n      ______________________error = Error(\"Missing output file path\");\n    } else if (inputValidator.string(this.options.input.file) && pathModule.resolve(this.options.input.file) === pathModule.resolve(___outputFilePath)) {\n      ______________________error = Error(\"Cannot use same file for input and output\");\n    } else if (jp2FileExtensionRegex.test(pathModule.extname(___outputFilePath)) && !this.constructor.format.jp2k.output.file) {\n      ______________________error = generateJP2Error();\n    }\n    if (______________________error) {\n      if (inputValidator.fn(___callbackFunction)) {\n        ___callbackFunction(______________________error);\n      } else {\n        return Promise.reject(______________________error);\n      }\n    } else {\n      this.options.fileOut = ___outputFilePath;\n      let errorInstance = Error();\n      return this._pipeline(___callbackFunction, errorInstance);\n    }\n    return this;\n  }\n  function setResolveOption(resolveOption, fallbackValue) {\n    if (inputValidator.object(resolveOption)) {\n      this._setBooleanOption(\"resolveWithObject\", resolveOption.resolveWithObject);\n    } else if (this.options.resolveWithObject) {\n      this.options.resolveWithObject = false;\n    }\n    this.options.fileOut = \"\";\n    let _errorInstance = Error();\n    return this._pipeline(inputValidator.fn(resolveOption) ? resolveOption : fallbackValue, _errorInstance);\n  }\n  function setKeepMetadataFlag() {\n    this.options.keepMetadata |= 1;\n    return this;\n  }\n  function processExifDataAndStore(processExifData) {\n    if (inputValidator.object(processExifData)) {\n      for (let [exifProperty, exifEntry] of Object.entries(processExifData)) {\n        if (inputValidator.object(exifEntry)) {\n          for (let [exifKey, exifValue] of Object.entries(exifEntry)) {\n            if (inputValidator.string(exifValue)) {\n              this.options.withExif[`exif-${exifProperty.toLowerCase()}-${exifKey}`] = exifValue;\n            } else {\n              throw inputValidator.invalidParameterError(`${exifProperty}.${exifKey}`, \"string\", exifValue);\n            }\n          }\n        } else {\n          throw inputValidator.invalidParameterError(exifProperty, \"object\", exifEntry);\n        }\n      }\n    } else {\n      throw inputValidator.invalidParameterError(\"exif\", \"object\", processExifData);\n    }\n    this.options.withExifMerge = false;\n    return this.keepExif();\n  }\n  function initializeWithExif(__imageData) {\n    this.withExif(__imageData);\n    this.options.withExifMerge = true;\n    return this;\n  }\n  function updateMetadataOptions() {\n    this.options.keepMetadata |= 8;\n    return this;\n  }\n  function setIccProfileAndMetadataOptions(iccProfile, _metadataOptions) {\n    if (inputValidator.string(iccProfile)) {\n      this.options.withIccProfile = iccProfile;\n    } else {\n      throw inputValidator.invalidParameterError(\"icc\", \"string\", iccProfile);\n    }\n    this.keepIccProfile();\n    if (inputValidator.object(_metadataOptions)) {\n      if (inputValidator.defined(_metadataOptions.attach)) {\n        if (inputValidator.bool(_metadataOptions.attach)) {\n          if (!_metadataOptions.attach) {\n            this.options.keepMetadata &= -9;\n          }\n        } else {\n          throw inputValidator.invalidParameterError(\"attach\", \"boolean\", _metadataOptions.attach);\n        }\n      }\n    }\n    return this;\n  }\n  function setKeepMetadataOption() {\n    this.options.keepMetadata = 31;\n    return this;\n  }\n  function processMetadataOptions(metadataOptions) {\n    this.keepMetadata();\n    this.withIccProfile(\"srgb\");\n    if (inputValidator.object(metadataOptions)) {\n      if (inputValidator.defined(metadataOptions.orientation)) {\n        if (inputValidator.integer(metadataOptions.orientation) && inputValidator.inRange(metadataOptions.orientation, 1, 8)) {\n          this.options.withMetadataOrientation = metadataOptions.orientation;\n        } else {\n          throw inputValidator.invalidParameterError(\"orientation\", \"integer between 1 and 8\", metadataOptions.orientation);\n        }\n      }\n      if (inputValidator.defined(metadataOptions.density)) {\n        if (inputValidator.number(metadataOptions.density) && metadataOptions.density > 0) {\n          this.options.withMetadataDensity = metadataOptions.density;\n        } else {\n          throw inputValidator.invalidParameterError(\"density\", \"positive number\", metadataOptions.density);\n        }\n      }\n      if (inputValidator.defined(metadataOptions.icc)) {\n        this.withIccProfile(metadataOptions.icc);\n      }\n      if (inputValidator.defined(metadataOptions.exif)) {\n        this.withExifMerge(metadataOptions.exif);\n      }\n    }\n    return this;\n  }\n  function processImageByFormat(_imageFormatHandler, _imageData) {\n    let __imageFormatHandler = supportedImageFormats.get((inputValidator.object(_imageFormatHandler) && inputValidator.string(_imageFormatHandler.id) ? _imageFormatHandler.id : _imageFormatHandler).toLowerCase());\n    if (!__imageFormatHandler) {\n      throw inputValidator.invalidParameterError(\"format\", `one of: ${[...supportedImageFormats.keys()].join(\", \")}`, _imageFormatHandler);\n    }\n    return this[__imageFormatHandler](_imageData);\n  }\n  function configureJpegCompressionOptions(jpegOptions) {\n    if (inputValidator.object(jpegOptions)) {\n      if (inputValidator.defined(jpegOptions.quality)) {\n        if (inputValidator.integer(jpegOptions.quality) && inputValidator.inRange(jpegOptions.quality, 1, 100)) {\n          this.options.jpegQuality = jpegOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", jpegOptions.quality);\n        }\n      }\n      if (inputValidator.defined(jpegOptions.progressive)) {\n        this._setBooleanOption(\"jpegProgressive\", jpegOptions.progressive);\n      }\n      if (inputValidator.defined(jpegOptions.chromaSubsampling)) {\n        if (inputValidator.string(jpegOptions.chromaSubsampling) && inputValidator.inArray(jpegOptions.chromaSubsampling, [\"4:2:0\", \"4:4:4\"])) {\n          this.options.jpegChromaSubsampling = jpegOptions.chromaSubsampling;\n        } else {\n          throw inputValidator.invalidParameterError(\"chromaSubsampling\", \"one of: 4:2:0, 4:4:4\", jpegOptions.chromaSubsampling);\n        }\n      }\n      let isOptimizeCodingDefined = inputValidator.bool(jpegOptions.optimizeCoding) ? jpegOptions.optimizeCoding : jpegOptions.optimiseCoding;\n      if (inputValidator.defined(isOptimizeCodingDefined)) {\n        this._setBooleanOption(\"jpegOptimiseCoding\", isOptimizeCodingDefined);\n      }\n      if (inputValidator.defined(jpegOptions.mozjpeg)) {\n        if (inputValidator.bool(jpegOptions.mozjpeg)) {\n          if (jpegOptions.mozjpeg) {\n            this.options.jpegTrellisQuantisation = true;\n            this.options.jpegOvershootDeringing = true;\n            this.options.jpegOptimiseScans = true;\n            this.options.jpegProgressive = true;\n            this.options.jpegQuantisationTable = 3;\n          }\n        } else {\n          throw inputValidator.invalidParameterError(\"mozjpeg\", \"boolean\", jpegOptions.mozjpeg);\n        }\n      }\n      let isTrellisQuantizationEnabled = inputValidator.bool(jpegOptions.trellisQuantization) ? jpegOptions.trellisQuantization : jpegOptions.trellisQuantisation;\n      if (inputValidator.defined(isTrellisQuantizationEnabled)) {\n        this._setBooleanOption(\"jpegTrellisQuantisation\", isTrellisQuantizationEnabled);\n      }\n      if (inputValidator.defined(jpegOptions.overshootDeringing)) {\n        this._setBooleanOption(\"jpegOvershootDeringing\", jpegOptions.overshootDeringing);\n      }\n      let optimizeScansFlag = inputValidator.bool(jpegOptions.optimizeScans) ? jpegOptions.optimizeScans : jpegOptions.optimiseScans;\n      if (inputValidator.defined(optimizeScansFlag)) {\n        this._setBooleanOption(\"jpegOptimiseScans\", optimizeScansFlag);\n        if (optimizeScansFlag) {\n          this.options.jpegProgressive = true;\n        }\n      }\n      let quantizationTableValue = inputValidator.number(jpegOptions.quantizationTable) ? jpegOptions.quantizationTable : jpegOptions.quantisationTable;\n      if (inputValidator.defined(quantizationTableValue)) {\n        if (inputValidator.integer(quantizationTableValue) && inputValidator.inRange(quantizationTableValue, 0, 8)) {\n          this.options.jpegQuantisationTable = quantizationTableValue;\n        } else {\n          throw inputValidator.invalidParameterError(\"quantisationTable\", \"integer between 0 and 8\", quantizationTableValue);\n        }\n      }\n    }\n    return this._updateFormatOut(\"jpeg\", jpegOptions);\n  }\n  function configurePngOptions(optionsConfig) {\n    if (inputValidator.object(optionsConfig)) {\n      if (inputValidator.defined(optionsConfig.progressive)) {\n        this._setBooleanOption(\"pngProgressive\", optionsConfig.progressive);\n      }\n      if (inputValidator.defined(optionsConfig.compressionLevel)) {\n        if (inputValidator.integer(optionsConfig.compressionLevel) && inputValidator.inRange(optionsConfig.compressionLevel, 0, 9)) {\n          this.options.pngCompressionLevel = optionsConfig.compressionLevel;\n        } else {\n          throw inputValidator.invalidParameterError(\"compressionLevel\", \"integer between 0 and 9\", optionsConfig.compressionLevel);\n        }\n      }\n      if (inputValidator.defined(optionsConfig.adaptiveFiltering)) {\n        this._setBooleanOption(\"pngAdaptiveFiltering\", optionsConfig.adaptiveFiltering);\n      }\n      let colorCount = optionsConfig.colours || optionsConfig.colors;\n      if (inputValidator.defined(colorCount)) {\n        if (inputValidator.integer(colorCount) && inputValidator.inRange(colorCount, 2, 256)) {\n          this.options.pngBitdepth = calculateBitDepth(colorCount);\n        } else {\n          throw inputValidator.invalidParameterError(\"colours\", \"integer between 2 and 256\", colorCount);\n        }\n      }\n      if (inputValidator.defined(optionsConfig.palette)) {\n        this._setBooleanOption(\"pngPalette\", optionsConfig.palette);\n      } else if ([optionsConfig.quality, optionsConfig.effort, optionsConfig.colours, optionsConfig.colors, optionsConfig.dither].some(inputValidator.defined)) {\n        this._setBooleanOption(\"pngPalette\", true);\n      }\n      if (this.options.pngPalette) {\n        if (inputValidator.defined(optionsConfig.quality)) {\n          if (inputValidator.integer(optionsConfig.quality) && inputValidator.inRange(optionsConfig.quality, 0, 100)) {\n            this.options.pngQuality = optionsConfig.quality;\n          } else {\n            throw inputValidator.invalidParameterError(\"quality\", \"integer between 0 and 100\", optionsConfig.quality);\n          }\n        }\n        if (inputValidator.defined(optionsConfig.effort)) {\n          if (inputValidator.integer(optionsConfig.effort) && inputValidator.inRange(optionsConfig.effort, 1, 10)) {\n            this.options.pngEffort = optionsConfig.effort;\n          } else {\n            throw inputValidator.invalidParameterError(\"effort\", \"integer between 1 and 10\", optionsConfig.effort);\n          }\n        }\n        if (inputValidator.defined(optionsConfig.dither)) {\n          if (inputValidator.number(optionsConfig.dither) && inputValidator.inRange(optionsConfig.dither, 0, 1)) {\n            this.options.pngDither = optionsConfig.dither;\n          } else {\n            throw inputValidator.invalidParameterError(\"dither\", \"number between 0.0 and 1.0\", optionsConfig.dither);\n          }\n        }\n      }\n    }\n    return this._updateFormatOut(\"png\", optionsConfig);\n  }\n  function configureWebpOptions(webpOptions) {\n    if (inputValidator.object(webpOptions)) {\n      if (inputValidator.defined(webpOptions.quality)) {\n        if (inputValidator.integer(webpOptions.quality) && inputValidator.inRange(webpOptions.quality, 1, 100)) {\n          this.options.webpQuality = webpOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", webpOptions.quality);\n        }\n      }\n      if (inputValidator.defined(webpOptions.alphaQuality)) {\n        if (inputValidator.integer(webpOptions.alphaQuality) && inputValidator.inRange(webpOptions.alphaQuality, 0, 100)) {\n          this.options.webpAlphaQuality = webpOptions.alphaQuality;\n        } else {\n          throw inputValidator.invalidParameterError(\"alphaQuality\", \"integer between 0 and 100\", webpOptions.alphaQuality);\n        }\n      }\n      if (inputValidator.defined(webpOptions.lossless)) {\n        this._setBooleanOption(\"webpLossless\", webpOptions.lossless);\n      }\n      if (inputValidator.defined(webpOptions.nearLossless)) {\n        this._setBooleanOption(\"webpNearLossless\", webpOptions.nearLossless);\n      }\n      if (inputValidator.defined(webpOptions.smartSubsample)) {\n        this._setBooleanOption(\"webpSmartSubsample\", webpOptions.smartSubsample);\n      }\n      if (inputValidator.defined(webpOptions.preset)) {\n        if (inputValidator.string(webpOptions.preset) && inputValidator.inArray(webpOptions.preset, [\"default\", \"photo\", \"picture\", \"drawing\", \"icon\", \"text\"])) {\n          this.options.webpPreset = webpOptions.preset;\n        } else {\n          throw inputValidator.invalidParameterError(\"preset\", \"one of: default, photo, picture, drawing, icon, text\", webpOptions.preset);\n        }\n      }\n      if (inputValidator.defined(webpOptions.effort)) {\n        if (inputValidator.integer(webpOptions.effort) && inputValidator.inRange(webpOptions.effort, 0, 6)) {\n          this.options.webpEffort = webpOptions.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 0 and 6\", webpOptions.effort);\n        }\n      }\n      if (inputValidator.defined(webpOptions.minSize)) {\n        this._setBooleanOption(\"webpMinSize\", webpOptions.minSize);\n      }\n      if (inputValidator.defined(webpOptions.mixed)) {\n        this._setBooleanOption(\"webpMixed\", webpOptions.mixed);\n      }\n    }\n    configureLoopAndDelay(webpOptions, this.options);\n    return this._updateFormatOut(\"webp\", webpOptions);\n  }\n  function setGifOptions(gifOptions) {\n    if (inputValidator.object(gifOptions)) {\n      if (inputValidator.defined(gifOptions.reuse)) {\n        this._setBooleanOption(\"gifReuse\", gifOptions.reuse);\n      }\n      if (inputValidator.defined(gifOptions.progressive)) {\n        this._setBooleanOption(\"gifProgressive\", gifOptions.progressive);\n      }\n      let _colorCount = gifOptions.colours || gifOptions.colors;\n      if (inputValidator.defined(_colorCount)) {\n        if (inputValidator.integer(_colorCount) && inputValidator.inRange(_colorCount, 2, 256)) {\n          this.options.gifBitdepth = calculateBitDepth(_colorCount);\n        } else {\n          throw inputValidator.invalidParameterError(\"colours\", \"integer between 2 and 256\", _colorCount);\n        }\n      }\n      if (inputValidator.defined(gifOptions.effort)) {\n        if (inputValidator.number(gifOptions.effort) && inputValidator.inRange(gifOptions.effort, 1, 10)) {\n          this.options.gifEffort = gifOptions.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 1 and 10\", gifOptions.effort);\n        }\n      }\n      if (inputValidator.defined(gifOptions.dither)) {\n        if (inputValidator.number(gifOptions.dither) && inputValidator.inRange(gifOptions.dither, 0, 1)) {\n          this.options.gifDither = gifOptions.dither;\n        } else {\n          throw inputValidator.invalidParameterError(\"dither\", \"number between 0.0 and 1.0\", gifOptions.dither);\n        }\n      }\n      if (inputValidator.defined(gifOptions.interFrameMaxError)) {\n        if (inputValidator.number(gifOptions.interFrameMaxError) && inputValidator.inRange(gifOptions.interFrameMaxError, 0, 32)) {\n          this.options.gifInterFrameMaxError = gifOptions.interFrameMaxError;\n        } else {\n          throw inputValidator.invalidParameterError(\"interFrameMaxError\", \"number between 0.0 and 32.0\", gifOptions.interFrameMaxError);\n        }\n      }\n      if (inputValidator.defined(gifOptions.interPaletteMaxError)) {\n        if (inputValidator.number(gifOptions.interPaletteMaxError) && inputValidator.inRange(gifOptions.interPaletteMaxError, 0, 256)) {\n          this.options.gifInterPaletteMaxError = gifOptions.interPaletteMaxError;\n        } else {\n          throw inputValidator.invalidParameterError(\"interPaletteMaxError\", \"number between 0.0 and 256.0\", gifOptions.interPaletteMaxError);\n        }\n      }\n    }\n    configureLoopAndDelay(gifOptions, this.options);\n    return this._updateFormatOut(\"gif\", gifOptions);\n  }\n  function updateJP2Options(jp2Options) {\n    if (!this.constructor.format.jp2k.output.buffer) {\n      throw generateJP2Error();\n    }\n    if (inputValidator.object(jp2Options)) {\n      if (inputValidator.defined(jp2Options.quality)) {\n        if (inputValidator.integer(jp2Options.quality) && inputValidator.inRange(jp2Options.quality, 1, 100)) {\n          this.options.jp2Quality = jp2Options.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", jp2Options.quality);\n        }\n      }\n      if (inputValidator.defined(jp2Options.lossless)) {\n        if (inputValidator.bool(jp2Options.lossless)) {\n          this.options.jp2Lossless = jp2Options.lossless;\n        } else {\n          throw inputValidator.invalidParameterError(\"lossless\", \"boolean\", jp2Options.lossless);\n        }\n      }\n      if (inputValidator.defined(jp2Options.tileWidth)) {\n        if (inputValidator.integer(jp2Options.tileWidth) && inputValidator.inRange(jp2Options.tileWidth, 1, 32768)) {\n          this.options.jp2TileWidth = jp2Options.tileWidth;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileWidth\", \"integer between 1 and 32768\", jp2Options.tileWidth);\n        }\n      }\n      if (inputValidator.defined(jp2Options.tileHeight)) {\n        if (inputValidator.integer(jp2Options.tileHeight) && inputValidator.inRange(jp2Options.tileHeight, 1, 32768)) {\n          this.options.jp2TileHeight = jp2Options.tileHeight;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileHeight\", \"integer between 1 and 32768\", jp2Options.tileHeight);\n        }\n      }\n      if (inputValidator.defined(jp2Options.chromaSubsampling)) {\n        if (inputValidator.string(jp2Options.chromaSubsampling) && inputValidator.inArray(jp2Options.chromaSubsampling, [\"4:2:0\", \"4:4:4\"])) {\n          this.options.jp2ChromaSubsampling = jp2Options.chromaSubsampling;\n        } else {\n          throw inputValidator.invalidParameterError(\"chromaSubsampling\", \"one of: 4:2:0, 4:4:4\", jp2Options.chromaSubsampling);\n        }\n      }\n    }\n    return this._updateFormatOut(\"jp2\", jp2Options);\n  }\n  function configureLoopAndDelay(config, destinationObject) {\n    if (inputValidator.object(config) && inputValidator.defined(config.loop)) {\n      if (inputValidator.integer(config.loop) && inputValidator.inRange(config.loop, 0, 65535)) {\n        destinationObject.loop = config.loop;\n      } else {\n        throw inputValidator.invalidParameterError(\"loop\", \"integer between 0 and 65535\", config.loop);\n      }\n    }\n    if (inputValidator.object(config) && inputValidator.defined(config.delay)) {\n      if (inputValidator.integer(config.delay) && inputValidator.inRange(config.delay, 0, 65535)) {\n        destinationObject.delay = [config.delay];\n      } else if (Array.isArray(config.delay) && config.delay.every(inputValidator.integer) && config.delay.every(_inputValue => inputValidator.inRange(_inputValue, 0, 65535))) {\n        destinationObject.delay = config.delay;\n      } else {\n        throw inputValidator.invalidParameterError(\"delay\", \"integer or an array of integers between 0 and 65535\", config.delay);\n      }\n    }\n  }\n  function setTiffOptions(tiffOptions) {\n    if (inputValidator.object(tiffOptions)) {\n      if (inputValidator.defined(tiffOptions.quality)) {\n        if (inputValidator.integer(tiffOptions.quality) && inputValidator.inRange(tiffOptions.quality, 1, 100)) {\n          this.options.tiffQuality = tiffOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", tiffOptions.quality);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.bitdepth)) {\n        if (inputValidator.integer(tiffOptions.bitdepth) && inputValidator.inArray(tiffOptions.bitdepth, [1, 2, 4, 8])) {\n          this.options.tiffBitdepth = tiffOptions.bitdepth;\n        } else {\n          throw inputValidator.invalidParameterError(\"bitdepth\", \"1, 2, 4 or 8\", tiffOptions.bitdepth);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.tile)) {\n        this._setBooleanOption(\"tiffTile\", tiffOptions.tile);\n      }\n      if (inputValidator.defined(tiffOptions.tileWidth)) {\n        if (inputValidator.integer(tiffOptions.tileWidth) && tiffOptions.tileWidth > 0) {\n          this.options.tiffTileWidth = tiffOptions.tileWidth;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileWidth\", \"integer greater than zero\", tiffOptions.tileWidth);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.tileHeight)) {\n        if (inputValidator.integer(tiffOptions.tileHeight) && tiffOptions.tileHeight > 0) {\n          this.options.tiffTileHeight = tiffOptions.tileHeight;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileHeight\", \"integer greater than zero\", tiffOptions.tileHeight);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.miniswhite)) {\n        this._setBooleanOption(\"tiffMiniswhite\", tiffOptions.miniswhite);\n      }\n      if (inputValidator.defined(tiffOptions.pyramid)) {\n        this._setBooleanOption(\"tiffPyramid\", tiffOptions.pyramid);\n      }\n      if (inputValidator.defined(tiffOptions.xres)) {\n        if (inputValidator.number(tiffOptions.xres) && tiffOptions.xres > 0) {\n          this.options.tiffXres = tiffOptions.xres;\n        } else {\n          throw inputValidator.invalidParameterError(\"xres\", \"number greater than zero\", tiffOptions.xres);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.yres)) {\n        if (inputValidator.number(tiffOptions.yres) && tiffOptions.yres > 0) {\n          this.options.tiffYres = tiffOptions.yres;\n        } else {\n          throw inputValidator.invalidParameterError(\"yres\", \"number greater than zero\", tiffOptions.yres);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.compression)) {\n        if (inputValidator.string(tiffOptions.compression) && inputValidator.inArray(tiffOptions.compression, [\"none\", \"jpeg\", \"deflate\", \"packbits\", \"ccittfax4\", \"lzw\", \"webp\", \"zstd\", \"jp2k\"])) {\n          this.options.tiffCompression = tiffOptions.compression;\n        } else {\n          throw inputValidator.invalidParameterError(\"compression\", \"one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\", tiffOptions.compression);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.predictor)) {\n        if (inputValidator.string(tiffOptions.predictor) && inputValidator.inArray(tiffOptions.predictor, [\"none\", \"horizontal\", \"float\"])) {\n          this.options.tiffPredictor = tiffOptions.predictor;\n        } else {\n          throw inputValidator.invalidParameterError(\"predictor\", \"one of: none, horizontal, float\", tiffOptions.predictor);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.resolutionUnit)) {\n        if (inputValidator.string(tiffOptions.resolutionUnit) && inputValidator.inArray(tiffOptions.resolutionUnit, [\"inch\", \"cm\"])) {\n          this.options.tiffResolutionUnit = tiffOptions.resolutionUnit;\n        } else {\n          throw inputValidator.invalidParameterError(\"resolutionUnit\", \"one of: inch, cm\", tiffOptions.resolutionUnit);\n        }\n      }\n    }\n    return this._updateFormatOut(\"tiff\", tiffOptions);\n  }\n  function applyAv1Compression(videoOptions) {\n    return this.heif({\n      ...videoOptions,\n      compression: \"av1\"\n    });\n  }\n  function setHeifOptions(heifOptions) {\n    if (inputValidator.object(heifOptions)) {\n      if (inputValidator.string(heifOptions.compression) && inputValidator.inArray(heifOptions.compression, [\"av1\", \"hevc\"])) {\n        this.options.heifCompression = heifOptions.compression;\n      } else {\n        throw inputValidator.invalidParameterError(\"compression\", \"one of: av1, hevc\", heifOptions.compression);\n      }\n      if (inputValidator.defined(heifOptions.quality)) {\n        if (inputValidator.integer(heifOptions.quality) && inputValidator.inRange(heifOptions.quality, 1, 100)) {\n          this.options.heifQuality = heifOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", heifOptions.quality);\n        }\n      }\n      if (inputValidator.defined(heifOptions.lossless)) {\n        if (inputValidator.bool(heifOptions.lossless)) {\n          this.options.heifLossless = heifOptions.lossless;\n        } else {\n          throw inputValidator.invalidParameterError(\"lossless\", \"boolean\", heifOptions.lossless);\n        }\n      }\n      if (inputValidator.defined(heifOptions.effort)) {\n        if (inputValidator.integer(heifOptions.effort) && inputValidator.inRange(heifOptions.effort, 0, 9)) {\n          this.options.heifEffort = heifOptions.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 0 and 9\", heifOptions.effort);\n        }\n      }\n      if (inputValidator.defined(heifOptions.chromaSubsampling)) {\n        if (inputValidator.string(heifOptions.chromaSubsampling) && inputValidator.inArray(heifOptions.chromaSubsampling, [\"4:2:0\", \"4:4:4\"])) {\n          this.options.heifChromaSubsampling = heifOptions.chromaSubsampling;\n        } else {\n          throw inputValidator.invalidParameterError(\"chromaSubsampling\", \"one of: 4:2:0, 4:4:4\", heifOptions.chromaSubsampling);\n        }\n      }\n      if (inputValidator.defined(heifOptions.bitdepth)) {\n        if (inputValidator.integer(heifOptions.bitdepth) && inputValidator.inArray(heifOptions.bitdepth, [8, 10, 12])) {\n          if (heifOptions.bitdepth !== 8 && this.constructor.versions.heif) {\n            throw inputValidator.invalidParameterError(\"bitdepth when using prebuilt binaries\", 8, heifOptions.bitdepth);\n          }\n          this.options.heifBitdepth = heifOptions.bitdepth;\n        } else {\n          throw inputValidator.invalidParameterError(\"bitdepth\", \"8, 10 or 12\", heifOptions.bitdepth);\n        }\n      }\n    } else {\n      throw inputValidator.invalidParameterError(\"options\", \"Object\", heifOptions);\n    }\n    return this._updateFormatOut(\"heif\", heifOptions);\n  }\n  function configureJxlOptions(_optionsConfig) {\n    if (inputValidator.object(_optionsConfig)) {\n      if (inputValidator.defined(_optionsConfig.quality)) {\n        if (inputValidator.integer(_optionsConfig.quality) && inputValidator.inRange(_optionsConfig.quality, 1, 100)) {\n          this.options.jxlDistance = _optionsConfig.quality >= 30 ? 0.1 + (100 - _optionsConfig.quality) * 0.09 : _optionsConfig.quality * 0.017666666666666667 * _optionsConfig.quality - _optionsConfig.quality * 1.15 + 25;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", _optionsConfig.quality);\n        }\n      } else if (inputValidator.defined(_optionsConfig.distance)) {\n        if (inputValidator.number(_optionsConfig.distance) && inputValidator.inRange(_optionsConfig.distance, 0, 15)) {\n          this.options.jxlDistance = _optionsConfig.distance;\n        } else {\n          throw inputValidator.invalidParameterError(\"distance\", \"number between 0.0 and 15.0\", _optionsConfig.distance);\n        }\n      }\n      if (inputValidator.defined(_optionsConfig.decodingTier)) {\n        if (inputValidator.integer(_optionsConfig.decodingTier) && inputValidator.inRange(_optionsConfig.decodingTier, 0, 4)) {\n          this.options.jxlDecodingTier = _optionsConfig.decodingTier;\n        } else {\n          throw inputValidator.invalidParameterError(\"decodingTier\", \"integer between 0 and 4\", _optionsConfig.decodingTier);\n        }\n      }\n      if (inputValidator.defined(_optionsConfig.lossless)) {\n        if (inputValidator.bool(_optionsConfig.lossless)) {\n          this.options.jxlLossless = _optionsConfig.lossless;\n        } else {\n          throw inputValidator.invalidParameterError(\"lossless\", \"boolean\", _optionsConfig.lossless);\n        }\n      }\n      if (inputValidator.defined(_optionsConfig.effort)) {\n        if (inputValidator.integer(_optionsConfig.effort) && inputValidator.inRange(_optionsConfig.effort, 3, 9)) {\n          this.options.jxlEffort = _optionsConfig.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 3 and 9\", _optionsConfig.effort);\n        }\n      }\n    }\n    return this._updateFormatOut(\"jxl\", _optionsConfig);\n  }\n  function validateInputDepthAndSet(inputOptions) {\n    if (inputValidator.object(inputOptions)) {\n      if (inputValidator.defined(inputOptions.depth)) {\n        if (inputValidator.string(inputOptions.depth) && inputValidator.inArray(inputOptions.depth, [\"char\", \"uchar\", \"short\", \"ushort\", \"int\", \"uint\", \"float\", \"complex\", \"double\", \"dpcomplex\"])) {\n          this.options.rawDepth = inputOptions.depth;\n        } else {\n          throw inputValidator.invalidParameterError(\"depth\", \"one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex\", inputOptions.depth);\n        }\n      }\n    }\n    return this._updateFormatOut(\"raw\");\n  }\n  function validateAndSetTileOptions(tileOptions) {\n    if (inputValidator.object(tileOptions)) {\n      if (inputValidator.defined(tileOptions.size)) {\n        if (inputValidator.integer(tileOptions.size) && inputValidator.inRange(tileOptions.size, 1, 8192)) {\n          this.options.tileSize = tileOptions.size;\n        } else {\n          throw inputValidator.invalidParameterError(\"size\", \"integer between 1 and 8192\", tileOptions.size);\n        }\n      }\n      if (inputValidator.defined(tileOptions.overlap)) {\n        if (inputValidator.integer(tileOptions.overlap) && inputValidator.inRange(tileOptions.overlap, 0, 8192)) {\n          if (tileOptions.overlap > this.options.tileSize) {\n            throw inputValidator.invalidParameterError(\"overlap\", `<= size (${this.options.tileSize})`, tileOptions.overlap);\n          }\n          this.options.tileOverlap = tileOptions.overlap;\n        } else {\n          throw inputValidator.invalidParameterError(\"overlap\", \"integer between 0 and 8192\", tileOptions.overlap);\n        }\n      }\n      if (inputValidator.defined(tileOptions.container)) {\n        if (inputValidator.string(tileOptions.container) && inputValidator.inArray(tileOptions.container, [\"fs\", \"zip\"])) {\n          this.options.tileContainer = tileOptions.container;\n        } else {\n          throw inputValidator.invalidParameterError(\"container\", \"one of: fs, zip\", tileOptions.container);\n        }\n      }\n      if (inputValidator.defined(tileOptions.layout)) {\n        if (inputValidator.string(tileOptions.layout) && inputValidator.inArray(tileOptions.layout, [\"dz\", \"google\", \"iiif\", \"iiif3\", \"zoomify\"])) {\n          this.options.tileLayout = tileOptions.layout;\n        } else {\n          throw inputValidator.invalidParameterError(\"layout\", \"one of: dz, google, iiif, iiif3, zoomify\", tileOptions.layout);\n        }\n      }\n      if (inputValidator.defined(tileOptions.angle)) {\n        if (inputValidator.integer(tileOptions.angle) && !(tileOptions.angle % 90)) {\n          this.options.tileAngle = tileOptions.angle;\n        } else {\n          throw inputValidator.invalidParameterError(\"angle\", \"positive/negative multiple of 90\", tileOptions.angle);\n        }\n      }\n      this._setBackgroundColourOption(\"tileBackground\", tileOptions.background);\n      if (inputValidator.defined(tileOptions.depth)) {\n        if (inputValidator.string(tileOptions.depth) && inputValidator.inArray(tileOptions.depth, [\"onepixel\", \"onetile\", \"one\"])) {\n          this.options.tileDepth = tileOptions.depth;\n        } else {\n          throw inputValidator.invalidParameterError(\"depth\", \"one of: onepixel, onetile, one\", tileOptions.depth);\n        }\n      }\n      if (inputValidator.defined(tileOptions.skipBlanks)) {\n        if (inputValidator.integer(tileOptions.skipBlanks) && inputValidator.inRange(tileOptions.skipBlanks, -1, 65535)) {\n          this.options.tileSkipBlanks = tileOptions.skipBlanks;\n        } else {\n          throw inputValidator.invalidParameterError(\"skipBlanks\", \"integer between -1 and 255/65535\", tileOptions.skipBlanks);\n        }\n      } else if (inputValidator.defined(tileOptions.layout) && tileOptions.layout === \"google\") {\n        this.options.tileSkipBlanks = 5;\n      }\n      let tileCenterOption = inputValidator.bool(tileOptions.center) ? tileOptions.center : tileOptions.centre;\n      if (inputValidator.defined(tileCenterOption)) {\n        this._setBooleanOption(\"tileCentre\", tileCenterOption);\n      }\n      if (inputValidator.defined(tileOptions.id)) {\n        if (inputValidator.string(tileOptions.id)) {\n          this.options.tileId = tileOptions.id;\n        } else {\n          throw inputValidator.invalidParameterError(\"id\", \"string\", tileOptions.id);\n        }\n      }\n      if (inputValidator.defined(tileOptions.basename)) {\n        if (inputValidator.string(tileOptions.basename)) {\n          this.options.tileBasename = tileOptions.basename;\n        } else {\n          throw inputValidator.invalidParameterError(\"basename\", \"string\", tileOptions.basename);\n        }\n      }\n    }\n    if (inputValidator.inArray(this.options.formatOut, [\"jpeg\", \"png\", \"webp\"])) {\n      this.options.tileFormat = this.options.formatOut;\n    } else if (this.options.formatOut !== \"input\") {\n      throw inputValidator.invalidParameterError(\"format\", \"one of: jpeg, png, webp\", this.options.formatOut);\n    }\n    return this._updateFormatOut(\"dz\");\n  }\n  function setTimeoutOptions(__optionsConfig) {\n    if (!inputValidator.plainObject(__optionsConfig)) {\n      throw inputValidator.invalidParameterError(\"options\", \"object\", __optionsConfig);\n    }\n    if (inputValidator.integer(__optionsConfig.seconds) && inputValidator.inRange(__optionsConfig.seconds, 0, 3600)) {\n      this.options.timeoutSeconds = __optionsConfig.seconds;\n    } else {\n      throw inputValidator.invalidParameterError(\"seconds\", \"integer between 0 and 3600\", __optionsConfig.seconds);\n    }\n    return this;\n  }\n  function setOutputFormat(outputFormat, outputFormatter) {\n    if (!inputValidator.object(outputFormatter) || outputFormatter.force !== false) {\n      this.options.formatOut = outputFormat;\n    }\n    return this;\n  }\n  function setBooleanOption(optionKey, booleanValue) {\n    if (inputValidator.bool(booleanValue)) {\n      this.options[optionKey] = booleanValue;\n    } else {\n      throw inputValidator.invalidParameterError(optionKey, \"boolean\", booleanValue);\n    }\n  }\n  function startStream() {\n    if (!this.options.streamOut) {\n      this.options.streamOut = true;\n      let streamError = Error();\n      this._pipeline(undefined, streamError);\n    }\n  }\n  function _processImagePipeline(_callbackFunction, errorHandler) {\n    if (typeof _callbackFunction === \"function\") {\n      if (this._isStreamInput()) {\n        this.on(\"finish\", () => {\n          this._flattenBufferIn();\n          _______imageProcessor.pipeline(this.options, (_errorResponse, _____errorHandler, errorHandlerAndResponse) => {\n            if (_errorResponse) {\n              _callbackFunction(inputValidator.nativeError(_errorResponse, errorHandler));\n            } else {\n              _callbackFunction(null, _____errorHandler, errorHandlerAndResponse);\n            }\n          });\n        });\n      } else {\n        _______imageProcessor.pipeline(this.options, (inputValidationError, _input, errorHandlerOrCallback) => {\n          if (inputValidationError) {\n            _callbackFunction(inputValidator.nativeError(inputValidationError, errorHandler));\n          } else {\n            _callbackFunction(null, _input, errorHandlerOrCallback);\n          }\n        });\n      }\n      return this;\n    } else if (this.options.streamOut) {\n      if (this._isStreamInput()) {\n        this.once(\"finish\", () => {\n          this._flattenBufferIn();\n          _______imageProcessor.pipeline(this.options, (isValidInput, __inputData, logInfo) => {\n            if (isValidInput) {\n              this.emit(\"error\", inputValidator.nativeError(isValidInput, errorHandler));\n            } else {\n              this.emit(\"info\", logInfo);\n              this.push(__inputData);\n            }\n            this.push(null);\n            this.on(\"end\", () => this.emit(\"close\"));\n          });\n        });\n        if (this.streamInFinished) {\n          this.emit(\"finish\");\n        }\n      } else {\n        _______imageProcessor.pipeline(this.options, (errorOccurred, ___inputData, infoMessage) => {\n          if (errorOccurred) {\n            this.emit(\"error\", inputValidator.nativeError(errorOccurred, errorHandler));\n          } else {\n            this.emit(\"info\", infoMessage);\n            this.push(___inputData);\n          }\n          this.push(null);\n          this.on(\"end\", () => this.emit(\"close\"));\n        });\n      }\n      return this;\n    } else if (this._isStreamInput()) {\n      return new Promise((______processImage, _errorCallback) => {\n        this.once(\"finish\", () => {\n          this._flattenBufferIn();\n          _______imageProcessor.pipeline(this.options, (imageProcessingCondition, imageData, imageInfo) => {\n            if (imageProcessingCondition) {\n              _errorCallback(inputValidator.nativeError(imageProcessingCondition, errorHandler));\n            } else if (this.options.resolveWithObject) {\n              ______processImage({\n                data: imageData,\n                info: imageInfo\n              });\n            } else {\n              ______processImage(imageData);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((____callbackFunction, handleError) => {\n        _______imageProcessor.pipeline(this.options, (inputValidationResult, responseData, infoData) => {\n          if (inputValidationResult) {\n            handleError(inputValidator.nativeError(inputValidationResult, errorHandler));\n          } else if (this.options.resolveWithObject) {\n            ____callbackFunction({\n              data: responseData,\n              info: infoData\n            });\n          } else {\n            ____callbackFunction(responseData);\n          }\n        });\n      });\n    }\n  }\n  registerImageProcessingMethods.exports = function (ImageTransformer) {\n    Object.assign(ImageTransformer.prototype, {\n      toFile: validateAndProcessOutputFile,\n      toBuffer: setResolveOption,\n      keepExif: setKeepMetadataFlag,\n      withExif: processExifDataAndStore,\n      withExifMerge: initializeWithExif,\n      keepIccProfile: updateMetadataOptions,\n      withIccProfile: setIccProfileAndMetadataOptions,\n      keepMetadata: setKeepMetadataOption,\n      withMetadata: processMetadataOptions,\n      toFormat: processImageByFormat,\n      jpeg: configureJpegCompressionOptions,\n      jp2: updateJP2Options,\n      png: configurePngOptions,\n      webp: configureWebpOptions,\n      tiff: setTiffOptions,\n      avif: applyAv1Compression,\n      heif: setHeifOptions,\n      jxl: configureJxlOptions,\n      gif: setGifOptions,\n      raw: validateInputDepthAndSet,\n      tile: validateAndSetTileOptions,\n      timeout: setTimeoutOptions,\n      _updateFormatOut: setOutputFormat,\n      _setBooleanOption: setBooleanOption,\n      _read: startStream,\n      _pipeline: _processImagePipeline\n    });\n  };\n});\nvar ImageProcessingEngine = z((initializeSharpModule, _initializeSharpModule) => {\n  var EventEmitter = EA(\"node:events\");\n  var imageProcessingLibrary = iPA();\n  var parameterValidator = iT();\n  var {\n    runtimePlatformArch: getRuntimePlatformArch\n  } = FJ1();\n  var libVipsInstance = HJA();\n  var getPlatformArchitecture = getRuntimePlatformArch();\n  var libVipsVersion = libVipsInstance.libvipsVersion();\n  var imageFormatManager = libVipsInstance.format();\n  imageFormatManager.heif.output.alias = [\"avif\", \"heic\"];\n  imageFormatManager.jpeg.output.alias = [\"jpe\", \"jpg\"];\n  imageFormatManager.tiff.output.alias = [\"tif\"];\n  imageFormatManager.jp2k.output.alias = [\"j2c\", \"j2k\", \"jp2\", \"jpx\"];\n  var interpolationMethods = {\n    nearest: \"nearest\",\n    bilinear: \"bilinear\",\n    bicubic: \"bicubic\",\n    locallyBoundedBicubic: \"lbb\",\n    nohalo: \"nohalo\",\n    vertexSplitQuadraticBasisSpline: \"vsqbs\"\n  };\n  var sharpLibraryVersions = {\n    vips: libVipsVersion.semver\n  };\n  if (!libVipsVersion.isGlobal) {\n    if (!libVipsVersion.isWasm) {\n      try {\n        sharpLibraryVersions = EA(`@img/sharp-${getPlatformArchitecture}/versions`);\n      } catch (errorWhileFetchingVersion) {\n        try {\n          sharpLibraryVersions = EA(`@img/sharp-libvips-${getPlatformArchitecture}/versions`);\n        } catch (_________________error) {}\n      }\n    } else {\n      try {\n        sharpLibraryVersions = (() => {\n          throw new Error(\"Cannot require module @img/sharp-wasm32/versions\");\n        })();\n      } catch (errorCatch) {}\n    }\n  }\n  sharpLibraryVersions.sharp = XJ1().version;\n  if (sharpLibraryVersions.heif && imageFormatManager.heif) {\n    imageFormatManager.heif.input.fileSuffix = [\".avif\"];\n    imageFormatManager.heif.output.alias = [\"avif\"];\n  }\n  function configureCacheSettings(cacheParameters) {\n    if (parameterValidator.bool(cacheParameters)) {\n      if (cacheParameters) {\n        return libVipsInstance.cache(50, 20, 100);\n      } else {\n        return libVipsInstance.cache(0, 0, 0);\n      }\n    } else if (parameterValidator.object(cacheParameters)) {\n      return libVipsInstance.cache(cacheParameters.memory, cacheParameters.files, cacheParameters.items);\n    } else {\n      return libVipsInstance.cache();\n    }\n  }\n  configureCacheSettings(true);\n  function setConcurrencyLevel(concurrencyInput) {\n    return libVipsInstance.concurrency(parameterValidator.integer(concurrencyInput) ? concurrencyInput : null);\n  }\n  if (imageProcessingLibrary.familySync() === imageProcessingLibrary.GLIBC && !libVipsInstance._isUsingJemalloc()) {\n    libVipsInstance.concurrency(1);\n  } else if (imageProcessingLibrary.familySync() === imageProcessingLibrary.MUSL && libVipsInstance.concurrency() === 1024) {\n    libVipsInstance.concurrency(EA(\"node:os\").availableParallelism());\n  }\n  var eventEmitterInstance = new EventEmitter.EventEmitter();\n  function getVipsCounters() {\n    return libVipsInstance.counters();\n  }\n  function validateAndProcessBoolean(isValidBoolean) {\n    return libVipsInstance.simd(parameterValidator.bool(isValidBoolean) ? isValidBoolean : null);\n  }\n  function validateAndProcessImage(validateAndProcessImageOptions) {\n    if (parameterValidator.object(validateAndProcessImageOptions)) {\n      if (Array.isArray(validateAndProcessImageOptions.operation) && validateAndProcessImageOptions.operation.every(parameterValidator.string)) {\n        libVipsInstance.block(validateAndProcessImageOptions.operation, true);\n      } else {\n        throw parameterValidator.invalidParameterError(\"operation\", \"Array<string>\", validateAndProcessImageOptions.operation);\n      }\n    } else {\n      throw parameterValidator.invalidParameterError(\"options\", \"object\", validateAndProcessImageOptions);\n    }\n  }\n  function processImageOperations(__options) {\n    if (parameterValidator.object(__options)) {\n      if (Array.isArray(__options.operation) && __options.operation.every(parameterValidator.string)) {\n        libVipsInstance.block(__options.operation, false);\n      } else {\n        throw parameterValidator.invalidParameterError(\"operation\", \"Array<string>\", __options.operation);\n      }\n    } else {\n      throw parameterValidator.invalidParameterError(\"options\", \"object\", __options);\n    }\n  }\n  _initializeSharpModule.exports = function (configuration) {\n    configuration.cache = configureCacheSettings;\n    configuration.concurrency = setConcurrencyLevel;\n    configuration.counters = getVipsCounters;\n    configuration.simd = validateAndProcessBoolean;\n    configuration.format = imageFormatManager;\n    configuration.interpolators = interpolationMethods;\n    configuration.versions = sharpLibraryVersions;\n    configuration.queue = eventEmitterInstance;\n    configuration.block = validateAndProcessImage;\n    configuration.unblock = processImageOperations;\n  };\n});\nvar ___imageTransformationPipeline = z((processAndExportImage, exportImageProcessingFunction) => {\n  var _imageProcessingResult = j_0();\n  s_0()(_imageProcessingResult);\n  Bx0()(_imageProcessingResult);\n  Ix0()(_imageProcessingResult);\n  Yx0()(_imageProcessingResult);\n  Wx0()(_imageProcessingResult);\n  Cx0()(_imageProcessingResult);\n  processImageTransformation()(_imageProcessingResult);\n  ImageProcessingEngine()(_imageProcessingResult);\n  exportImageProcessingFunction.exports = _imageProcessingResult;\n});\nasync function processAndTransformImage(processImageTransform, _maxImageSize, defaultImageFormat) {\n  try {\n    let __imageProcessingResult = await Promise.resolve().then(() => IA(___imageTransformationPipeline(), 1));\n    let _imageTransformer = (__imageProcessingResult.default || __imageProcessingResult)(processImageTransform);\n    let _imageMetadata = await _imageTransformer.metadata();\n    if (!_imageMetadata.width || !_imageMetadata.height) {\n      if (_maxImageSize > MAX_IMAGE_SIZE) {\n        return {\n          buffer: await _imageTransformer.jpeg({\n            quality: 80\n          }).toBuffer(),\n          mediaType: \"jpeg\"\n        };\n      }\n    }\n    let imageWidth = _imageMetadata.width || 0;\n    let imageHeight = _imageMetadata.height || 0;\n    let imageFormat = _imageMetadata.format ?? defaultImageFormat;\n    let imageMediaType = imageFormat === \"jpg\" ? \"jpeg\" : imageFormat;\n    if (_maxImageSize <= MAX_IMAGE_SIZE && imageWidth <= maxImageDimension && imageHeight <= MAX_IMAGE_DIMENSION) {\n      return {\n        buffer: processImageTransform,\n        mediaType: imageMediaType\n      };\n    }\n    if (imageWidth > maxImageDimension) {\n      imageHeight = Math.round(imageHeight * maxImageDimension / imageWidth);\n      imageWidth = maxImageDimension;\n    }\n    if (imageHeight > MAX_IMAGE_DIMENSION) {\n      imageWidth = Math.round(imageWidth * MAX_IMAGE_DIMENSION / imageHeight);\n      imageHeight = MAX_IMAGE_DIMENSION;\n    }\n    let resizedImageBuffer = await _imageTransformer.resize(imageWidth, imageHeight, {\n      fit: \"inside\",\n      withoutEnlargement: true\n    }).toBuffer();\n    if (resizedImageBuffer.length > MAX_IMAGE_SIZE) {\n      return {\n        buffer: await _imageTransformer.jpeg({\n          quality: 80\n        }).toBuffer(),\n        mediaType: \"jpeg\"\n      };\n    }\n    return {\n      buffer: resizedImageBuffer,\n      mediaType: imageMediaType\n    };\n  } catch (_errorHandling) {\n    BA(_errorHandling, BY0);\n    return {\n      buffer: processImageTransform,\n      mediaType: defaultImageFormat === \"jpg\" ? \"jpeg\" : defaultImageFormat\n    };\n  }\n}\nasync function processBase64ImageAndTransform(processBase64Image) {\n  if (processBase64Image.source.type !== \"base64\") {\n    return processBase64Image;\n  }\n  let decodedImageBuffer = Buffer.from(processBase64Image.source.data, \"base64\");\n  let imageBufferLength = decodedImageBuffer.length;\n  let _imageFormat = processBase64Image.source.media_type?.split(\"/\")[1] || \"png\";\n  let _processedImage = await processAndTransformImage(decodedImageBuffer, imageBufferLength, _imageFormat);\n  return {\n    type: \"image\",\n    source: {\n      type: \"base64\",\n      media_type: `image/${_processedImage.mediaType}`,\n      data: _processedImage.buffer.toString(\"base64\")\n    }\n  };\n}\nvar MAX_IMAGE_SIZE = 3932160;\nvar maxImageDimension = 2000;\nvar MAX_IMAGE_DIMENSION = 2000;\nvar initializeDjA = T(() => {\n  c1();\n});\nimport { execSync as execSyncChildProcess } from \"child_process\";\nimport { basename as extractFileExtension, extname as getExtensionFromFile, isAbsolute as isPathAbsolute } from \"path\";\nfunction getClipboardScreenshotMessage() {\n  let currentPlatform = process.platform;\n  let clipboardScreenshotMessages = {\n    darwin: \"No image found in clipboard. Use Cmd + Ctrl + Shift + 4 to copy a screenshot to clipboard.\",\n    win32: \"No image found in clipboard. Use Print Screen to copy a screenshot to clipboard.\",\n    linux: \"No image found in clipboard. Use appropriate screenshot tool to copy a screenshot to clipboard.\"\n  };\n  return clipboardScreenshotMessages[currentPlatform] || clipboardScreenshotMessages.linux;\n}\nfunction getClipboardImageHandler() {\n  let _getClipboardImageHandler = process.platform;\n  let platformSpecificClipboardImagePaths = {\n    darwin: \"/tmp/claude_cli_latest_screenshot.png\",\n    linux: \"/tmp/claude_cli_latest_screenshot.png\",\n    win32: process.env.TEMP ? `${process.env.TEMP}\\\\claude_cli_latest_screenshot.png` : \"C:\\\\Temp\\\\claude_cli_latest_screenshot.png\"\n  };\n  let screenshotPath = platformSpecificClipboardImagePaths[_getClipboardImageHandler] || platformSpecificClipboardImagePaths.linux;\n  let clipboardImageCommands = {\n    darwin: {\n      checkImage: \"osascript -e 'the clipboard as class PNGf'\",\n      saveImage: `osascript -e 'set png_data to (the clipboard as class PNGf)' -e 'set fp to open for access POSIX file \"${screenshotPath}\" with write permission' -e 'write png_data to fp' -e 'close access fp'`,\n      getPath: \"osascript -e 'get POSIX path of (the clipboard as class furl)'\",\n      deleteFile: `rm -f \"${screenshotPath}\"`\n    },\n    linux: {\n      checkImage: \"xclip -selection clipboard -t TARGETS -o | grep -E \\\"image/(png|jpeg|jpg|gif|webp)\\\"\",\n      saveImage: `xclip -selection clipboard -t image/png -o > \"${screenshotPath}\" || wl-paste --type image/png > \"${screenshotPath}\"`,\n      getPath: \"xclip -selection clipboard -t text/plain -o\",\n      deleteFile: `rm -f \"${screenshotPath}\"`\n    },\n    win32: {\n      checkImage: \"powershell -NoProfile -Command \\\"(Get-Clipboard -Format Image) -ne $null\\\"\",\n      saveImage: `powershell -NoProfile -Command \"$img = Get-Clipboard -Format Image; if ($img) { $img.Save('${screenshotPath.replace(/\\\\/g, \"\\\\\\\\\")}', [System.Drawing.Imaging.ImageFormat]::Png) }\"`,\n      getPath: \"powershell -NoProfile -Command \\\"Get-Clipboard\\\"\",\n      deleteFile: `del /f \"${screenshotPath}\"`\n    }\n  };\n  return {\n    commands: clipboardImageCommands[_getClipboardImageHandler] || clipboardImageCommands.linux,\n    screenshotPath: screenshotPath\n  };\n}\nasync function processClipboardImage() {\n  let {\n    commands: imageCommands,\n    screenshotPath: _screenshotPath\n  } = getClipboardImageHandler();\n  try {\n    execSyncChildProcess(imageCommands.checkImage, {\n      stdio: \"ignore\"\n    });\n    execSyncChildProcess(imageCommands.saveImage, {\n      stdio: \"ignore\"\n    });\n    let __imageBytes = NA().readFileBytesSync(_screenshotPath);\n    let {\n      buffer: processedImageBuffer\n    } = await processAndTransformImage(__imageBytes, __imageBytes.length, \"png\");\n    let _base64EncodedImage = processedImageBuffer.toString(\"base64\");\n    let _imageType = detectImageType(_base64EncodedImage);\n    execSyncChildProcess(imageCommands.deleteFile, {\n      stdio: \"ignore\"\n    });\n    return {\n      base64: _base64EncodedImage,\n      mediaType: _imageType\n    };\n  } catch {\n    return null;\n  }\n}\nfunction getClipboardImagePath() {\n  let {\n    commands: _clipboardImageCommands\n  } = getClipboardImageHandler();\n  try {\n    return execSyncChildProcess(_clipboardImageCommands.getPath, {\n      encoding: \"utf-8\"\n    }).trim();\n  } catch (_______errorHandler) {\n    BA(_______errorHandler, _MA);\n    return null;\n  }\n}\nfunction detectImageType(getImageMimeTypeFromBase64) {\n  try {\n    let imageBuffer = Buffer.from(getImageMimeTypeFromBase64, \"base64\");\n    if (imageBuffer.length < 4) {\n      return \"image/png\";\n    }\n    if (imageBuffer[0] === 137 && imageBuffer[1] === 80 && imageBuffer[2] === 78 && imageBuffer[3] === 71) {\n      return \"image/png\";\n    }\n    if (imageBuffer[0] === 255 && imageBuffer[1] === 216 && imageBuffer[2] === 255) {\n      return \"image/jpeg\";\n    }\n    if (imageBuffer[0] === 71 && imageBuffer[1] === 73 && imageBuffer[2] === 70) {\n      return \"image/gif\";\n    }\n    if (imageBuffer[0] === 82 && imageBuffer[1] === 73 && imageBuffer[2] === 70 && imageBuffer[3] === 70) {\n      if (imageBuffer.length >= 12 && imageBuffer[8] === 87 && imageBuffer[9] === 69 && imageBuffer[10] === 66 && imageBuffer[11] === 80) {\n        return \"image/webp\";\n      }\n    }\n    return \"image/png\";\n  } catch {\n    return \"image/png\";\n  }\n}\nfunction removeQuotesFromString(trimQuotes) {\n  if (trimQuotes.startsWith(\"\\\"\") && trimQuotes.endsWith(\"\\\"\") || trimQuotes.startsWith(\"'\") && trimQuotes.endsWith(\"'\")) {\n    return trimQuotes.slice(1, -1);\n  }\n  return trimQuotes;\n}\nfunction normalizeFilePath(normalizePathSeparator) {\n  if (process.platform === \"win32\") {\n    return normalizePathSeparator;\n  }\n  let doubleBackslashPlaceholder = \"__DOUBLE_BACKSLASH__\";\n  return normalizePathSeparator.replace(/\\\\\\\\/g, doubleBackslashPlaceholder).replace(/\\\\(.)/g, \"$1\").replace(new RegExp(doubleBackslashPlaceholder, \"g\"), \"\\\\\");\n}\nfunction processFilePath(____inputString) {\n  let processedFilePath = removeQuotesFromString(____inputString.trim());\n  let _normalizedFilePath = normalizeFilePath(processedFilePath);\n  return outputFileHandler.test(_normalizedFilePath);\n}\nfunction processAndValidateFilePath(_inputFilePath) {\n  let cleanedAndNormalizedFilePath = removeQuotesFromString(_inputFilePath.trim());\n  let normalizedFilePath = normalizeFilePath(cleanedAndNormalizedFilePath);\n  if (outputFileHandler.test(normalizedFilePath)) {\n    return normalizedFilePath;\n  }\n  return null;\n}\nasync function processImageFileAsync(inputFilePath) {\n  let validatedFilePath = processAndValidateFilePath(inputFilePath);\n  if (!validatedFilePath) {\n    return null;\n  }\n  let __validatedFilePath = validatedFilePath;\n  let imageBytes;\n  try {\n    if (isPathAbsolute(__validatedFilePath)) {\n      imageBytes = NA().readFileBytesSync(__validatedFilePath);\n    } else {\n      let temporaryFilePath = getClipboardImagePath();\n      if (temporaryFilePath && __validatedFilePath === extractFileExtension(temporaryFilePath)) {\n        imageBytes = NA().readFileBytesSync(temporaryFilePath);\n      }\n    }\n  } catch (_______________________________error) {\n    BA(_______________________________error, AY0);\n    return null;\n  }\n  if (!imageBytes) {\n    return null;\n  }\n  let imageFileExtension = getExtensionFromFile(__validatedFilePath).slice(1).toLowerCase() || \"png\";\n  let {\n    buffer: transformedImageBuffer\n  } = await processAndTransformImage(imageBytes, imageBytes.length, imageFileExtension);\n  let base64EncodedImage = transformedImageBuffer.toString(\"base64\");\n  let detectedImageType = detectImageType(base64EncodedImage);\n  return {\n    path: __validatedFilePath,\n    base64: base64EncodedImage,\n    mediaType: detectedImageType\n  };\n}\nvar getErrorDescriptionForOutputFile;\nvar HIGHLIGHTED_MAX_WIDTH = 800;\nvar outputFileHandler;\nvar ________imageTransformationProcessor = T(() => {\n  m0();\n  c1();\n  initializeDjA();\n  getErrorDescriptionForOutputFile = getClipboardScreenshotMessage();\n  outputFileHandler = /\\.(png|jpe?g|gif|webp)$/i;\n});\nfunction RenderImageWithChildren({\n  children: children\n}) {\n  let {\n    marker: imageMarker\n  } = displayHandler.useContext(imageProcessingFunction);\n  return displayHandler.default.createElement(S, {\n    gap: 1\n  }, displayHandler.default.createElement(U, {\n    dimColor: true\n  }, imageMarker), displayHandler.default.createElement(S, {\n    flexDirection: \"column\"\n  }, children));\n}\nvar displayHandler;\nvar imageProcessingFunction;\nvar _________imageTransformationProcessor = T(() => {\n  nA();\n  displayHandler = IA(KA(), 1);\n  imageProcessingFunction = displayHandler.createContext({\n    marker: \"\"\n  });\n});\nfunction RenderImageWithMarkers({\n  children: _children\n}) {\n  let {\n    marker: currentMarker\n  } = ReactContext.useContext(imageProcessingPipeline);\n  let validComponentCount = 0;\n  for (let childElement of ReactContext.default.Children.toArray(_children)) {\n    if (!ReactContext.isValidElement(childElement) || childElement.type !== RenderImageWithChildren) {\n      continue;\n    }\n    validComponentCount++;\n  }\n  let validComponentCountLength = String(validComponentCount).length;\n  return ReactContext.default.createElement(S, {\n    flexDirection: \"column\"\n  }, ReactContext.default.Children.map(_children, (renderImageWithChildrenIfValid, _markerIndex) => {\n    if (!ReactContext.isValidElement(renderImageWithChildrenIfValid) || renderImageWithChildrenIfValid.type !== RenderImageWithChildren) {\n      return renderImageWithChildrenIfValid;\n    }\n    let formattedMarkerPrefix = `${String(_markerIndex + 1).padStart(validComponentCountLength)}.`;\n    let _imageMarker = `${currentMarker}${formattedMarkerPrefix}`;\n    return ReactContext.default.createElement(imageProcessingPipeline.Provider, {\n      value: {\n        marker: _imageMarker\n      }\n    }, ReactContext.default.createElement(imageProcessingOperation.Provider, {\n      value: {\n        marker: _imageMarker\n      }\n    }, renderImageWithChildrenIfValid));\n  }));\n}\nvar ReactContext;\nvar imageProcessingPipeline;\nvar imageProcessingOperation;\nvar componentKey;\nvar ___________imageProcessor = T(() => {\n  nA();\n  _________imageTransformationProcessor();\n  ReactContext = IA(KA(), 1);\n  imageProcessingPipeline = ReactContext.createContext({\n    marker: \"\"\n  });\n  imageProcessingOperation = ReactContext.createContext({\n    marker: \"\"\n  });\n  RenderImageWithMarkers.Item = RenderImageWithChildren;\n  componentKey = RenderImageWithMarkers;\n});\nimport { join as resolveFilePath } from \"path\";\nfunction areOnboardingTipsComplete() {\n  return generateOnboardingTips().filter(({\n    isCompletable: isCompletable,\n    isEnabled: isFeatureEnabled\n  }) => isCompletable && isFeatureEnabled).every(({\n    isComplete: isComplete\n  }) => isComplete);\n}\nfunction completeProjectOnboardingIfRequired() {\n  let userOnboardingStatus = v6();\n  if (areOnboardingTipsComplete() && !userOnboardingStatus.hasCompletedProjectOnboarding) {\n    uG({\n      ...userOnboardingStatus,\n      hasCompletedProjectOnboarding: true\n    });\n  }\n}\nfunction generateOnboardingTips() {\n  let fileExistsForClaudeMD = NA().existsSync(resolveFilePath(G0(), \"CLAUDE.md\"));\n  let isFx0Active = fx0(G0());\n  let isWorkspaceTipHidden = _7(\"cc_onboarding_hide_workspace\", \"hide_workspace_tip\", false);\n  let isGithubIntegrationStepVisible = _7(\"cc_onboarding_github\", \"show_github_integration_step\", false);\n  return [{\n    key: \"workspace\",\n    text: \"Ask Claude to create a new app or clone a repository\",\n    isComplete: false,\n    isCompletable: true,\n    isEnabled: isFx0Active && !isWorkspaceTipHidden\n  }, {\n    key: \"claudemd\",\n    text: \"Run /init to create a CLAUDE.md file with instructions for Claude\",\n    isComplete: fileExistsForClaudeMD,\n    isCompletable: true,\n    isEnabled: !isFx0Active\n  }, {\n    key: \"github\",\n    text: \"Run /install-github-app to tag @claude right from your Github issues and PRs\",\n    isComplete: Boolean(L1().githubActionSetupCount),\n    isCompletable: true,\n    isEnabled: isGithubIntegrationStepVisible\n  }];\n}\nfunction incrementProjectOnboardingSeenCount() {\n  let projectOnboardingData = v6();\n  uG({\n    ...projectOnboardingData,\n    projectOnboardingSeenCount: projectOnboardingData.projectOnboardingSeenCount + 1\n  });\n}\nvar updateImageFormatBasedOnOptions;\nvar sharpImageProcessor;\nvar fileFormatMap;\nvar imagePipelineProcessor = T(() => {\n  ___________imageProcessor();\n  nA();\n  kB();\n  Z4();\n  V2();\n  m0();\n  a2();\n  f4();\n  updateImageFormatBasedOnOptions = IA(KA(), 1);\n  sharpImageProcessor = IA(KA(), 1);\n  fileFormatMap = I0(() => {\n    if (areOnboardingTipsComplete() || v6().projectOnboardingSeenCount >= 4 || process.env.IS_DEMO) {\n      return false;\n    }\n    return true;\n  });\n});\nimport { homedir as defaultImageProcessor } from \"os\";\nimport { join as getPathFromHomeDirectory } from \"path\";\nfunction initializeAppleTerminalSetup(appleTerminalBackupPath) {\n  let appleTerminalSetupConfig = L1();\n  appleTerminalSetupConfig.appleTerminalSetupInProgress = true;\n  appleTerminalSetupConfig.appleTerminalBackupPath = appleTerminalBackupPath;\n  n0(appleTerminalSetupConfig);\n}\nfunction _initializeAppleTerminalSetup() {\n  let appleTerminalSetup = L1();\n  appleTerminalSetup.appleTerminalSetupInProgress = false;\n  n0(appleTerminalSetup);\n}\nfunction getAppleTerminalStatus() {\n  let appleTerminalStatus = L1();\n  return {\n    inProgress: appleTerminalStatus.appleTerminalSetupInProgress ?? false,\n    backupPath: appleTerminalStatus.appleTerminalBackupPath || null\n  };\n}\nfunction getTerminalPreferencesPath() {\n  return getPathFromHomeDirectory(defaultImageProcessor(), \"Library\", \"Preferences\", \"com.apple.Terminal.plist\");\n}\nasync function exportTerminalPreferences() {\n  let terminalPreferencesPath = getTerminalPreferencesPath();\n  let backupTerminalPreferencesPath = `${terminalPreferencesPath}.bak`;\n  try {\n    let {\n      code: _exitCode\n    } = await r0(\"defaults\", [\"export\", \"com.apple.Terminal\", terminalPreferencesPath]);\n    if (_exitCode !== 0) {\n      return null;\n    }\n    if (NA().existsSync(terminalPreferencesPath)) {\n      await r0(\"defaults\", [\"export\", \"com.apple.Terminal\", backupTerminalPreferencesPath]);\n      initializeAppleTerminalSetup(backupTerminalPreferencesPath);\n      return backupTerminalPreferencesPath;\n    }\n    return null;\n  } catch (________errorHandler) {\n    BA(________errorHandler instanceof Error ? ________errorHandler : Error(String(________errorHandler)), pG0);\n    return null;\n  }\n}\nasync function restoreAppleTerminalSettings() {\n  let {\n    inProgress: isBackupInProgress,\n    backupPath: __backupFilePath\n  } = getAppleTerminalStatus();\n  if (!isBackupInProgress) {\n    return {\n      status: \"no_backup\"\n    };\n  }\n  if (!__backupFilePath || !NA().existsSync(__backupFilePath)) {\n    _initializeAppleTerminalSetup();\n    return {\n      status: \"no_backup\"\n    };\n  }\n  try {\n    let {\n      code: exitCode\n    } = await r0(\"defaults\", [\"import\", \"com.apple.Terminal\", __backupFilePath]);\n    if (exitCode !== 0) {\n      return {\n        status: \"failed\",\n        backupPath: __backupFilePath\n      };\n    }\n    await r0(\"killall\", [\"cfprefsd\"]);\n    _initializeAppleTerminalSetup();\n    return {\n      status: \"restored\"\n    };\n  } catch (_______________________error) {\n    BA(Error(`Failed to restore Terminal.app settings with: ${_______________________error}`), lG0);\n    _initializeAppleTerminalSetup();\n    return {\n      status: \"failed\",\n      backupPath: __backupFilePath\n    };\n  }\n}\nvar initializeShapelessPipeline = T(() => {\n  Q5();\n  c1();\n  kB();\n  m0();\n});\nimport { homedir as ImageProcessingModule } from \"os\";\nimport { join as errorMessages } from \"path\";\nfunction setupIterm2WithBackupPath(backupPath) {\n  let iterm2Session = L1();\n  iterm2Session.iterm2SetupInProgress = true;\n  iterm2Session.iterm2BackupPath = backupPath;\n  n0(iterm2Session);\n}\nfunction setupInProgressAndNotify() {\n  let setupNotificationForIterm2 = L1();\n  setupNotificationForIterm2.iterm2SetupInProgress = false;\n  n0(setupNotificationForIterm2);\n}\nfunction getITerm2SetupStatus() {\n  let iterm2SetupStatus = L1();\n  return {\n    inProgress: iterm2SetupStatus.iterm2SetupInProgress ?? false,\n    backupPath: iterm2SetupStatus.iterm2BackupPath || null\n  };\n}\nfunction getImageProcessingErrorMessages() {\n  return errorMessages(ImageProcessingModule(), \"Library\", \"Preferences\", \"com.googlecode.iterm2.plist\");\n}\nasync function exportIterm2Settings() {\n  let imageProcessingErrorMessages = getImageProcessingErrorMessages();\n  let _____backupFilePath = `${imageProcessingErrorMessages}.bak`;\n  try {\n    await r0(\"defaults\", [\"export\", \"com.googlecode.iterm2\", imageProcessingErrorMessages]);\n    if (NA().existsSync(imageProcessingErrorMessages)) {\n      NA().copyFileSync(imageProcessingErrorMessages, _____backupFilePath);\n      setupIterm2WithBackupPath(_____backupFilePath);\n      return _____backupFilePath;\n    }\n    return null;\n  } catch (_________errorHandler) {\n    BA(_________errorHandler instanceof Error ? _________errorHandler : Error(String(_________errorHandler)), QY0);\n    return null;\n  }\n}\nfunction restoreITerm2Settings() {\n  let {\n    inProgress: isRestoreInProgress,\n    backupPath: ____backupFilePath\n  } = getITerm2SetupStatus();\n  if (!isRestoreInProgress) {\n    return {\n      status: \"no_backup\"\n    };\n  }\n  if (!____backupFilePath || !NA().existsSync(____backupFilePath)) {\n    setupInProgressAndNotify();\n    return {\n      status: \"no_backup\"\n    };\n  }\n  try {\n    NA().copyFileSync(____backupFilePath, getImageProcessingErrorMessages());\n    setupInProgressAndNotify();\n    return {\n      status: \"restored\"\n    };\n  } catch (_____________________________error) {\n    BA(Error(`Failed to restore iTerm2 settings with: ${_____________________________error}`), IY0);\n    setupInProgressAndNotify();\n    return {\n      status: \"failed\",\n      backupPath: ____backupFilePath\n    };\n  }\n}\nvar initializeCustomSettings = T(() => {\n  Q5();\n  c1();\n  kB();\n  m0();\n});\nimport { randomBytes as generateRandomBytes } from \"crypto\";\nimport { EOL as LineSeparator, homedir as getFolderPath, platform as processImageTransformations } from \"os\";\nimport { dirname as imageProcessor, join as outputImageFormatHandler } from \"path\";\nfunction isEnvironmentSupportedForImageTransformations() {\n  return processImageTransformations() === \"darwin\" && (O0.terminal === \"iTerm.app\" || O0.terminal === \"Apple_Terminal\") || O0.terminal === \"vscode\" || O0.terminal === \"cursor\" || O0.terminal === \"windsurf\" || O0.terminal === \"ghostty\" || O0.terminal === \"WezTerm\";\n}\nasync function configureTerminalShiftEnterKeyBinding(getTerminalOutput) {\n  let shiftEnterKeyBinding = \"\";\n  switch (O0.terminal) {\n    case \"iTerm.app\":\n      shiftEnterKeyBinding = await installIterm2ShiftEnterKeyBinding(getTerminalOutput);\n      break;\n    case \"Apple_Terminal\":\n      shiftEnterKeyBinding = await configureAppleTerminalSettings(getTerminalOutput);\n      break;\n    case \"vscode\":\n      shiftEnterKeyBinding = installTerminalShiftEnterKeyBinding(\"VSCode\", getTerminalOutput);\n      break;\n    case \"cursor\":\n      shiftEnterKeyBinding = installTerminalShiftEnterKeyBinding(\"Cursor\", getTerminalOutput);\n      break;\n    case \"windsurf\":\n      shiftEnterKeyBinding = installTerminalShiftEnterKeyBinding(\"Windsurf\", getTerminalOutput);\n      break;\n    case \"ghostty\":\n      shiftEnterKeyBinding = await installGhosttyShiftEnterKeyBindingHandler(getTerminalOutput);\n      break;\n    case \"WezTerm\":\n      shiftEnterKeyBinding = await installWezTermShiftEnterKeyBinding(getTerminalOutput);\n      break;\n    case null:\n      break;\n  }\n  let terminalConfiguration = L1();\n  if ([\"iTerm.app\", \"vscode\", \"cursor\", \"windsurf\", \"ghostty\", \"WezTerm\"].includes(O0.terminal ?? \"\")) {\n    terminalConfiguration.shiftEnterKeyBindingInstalled = true;\n  } else if (O0.terminal === \"Apple_Terminal\") {\n    terminalConfiguration.optionAsMetaKeyInstalled = true;\n  }\n  n0(terminalConfiguration);\n  completeProjectOnboardingIfRequired();\n  return shiftEnterKeyBinding;\n}\nfunction isShiftEnterKeyBindingInstalled() {\n  return L1().shiftEnterKeyBindingInstalled === true;\n}\nfunction isMetaKeyOptionInstalled() {\n  return L1().optionAsMetaKeyInstalled === true;\n}\nfunction checkIfBackslashReturnUsed() {\n  return L1().hasUsedBackslashReturn === true;\n}\nfunction handleReturnKey() {\n  let _responseData = L1();\n  if (!_responseData.hasUsedBackslashReturn) {\n    n0({\n      ..._responseData,\n      hasUsedBackslashReturn: true\n    });\n  }\n}\nasync function installWezTermShiftEnterKeyBinding(installWezTermShiftEnterBinding) {\n  let wezTermConfigFilePath = outputImageFormatHandler(getFolderPath(), \".wezterm.lua\");\n  try {\n    let existingConfigContent = \"\";\n    let isExistingKeyBinding = false;\n    if (NA().existsSync(wezTermConfigFilePath)) {\n      isExistingKeyBinding = true;\n      existingConfigContent = NA().readFileSync(wezTermConfigFilePath, {\n        encoding: \"utf-8\"\n      });\n      if (existingConfigContent.includes(\"mods=\\\"SHIFT\\\"\") && existingConfigContent.includes(\"key=\\\"Enter\\\"\")) {\n        return `${OB(\"warning\", installWezTermShiftEnterBinding)(\"Found existing WezTerm Shift+Enter key binding. Remove it to continue.\")}${LineSeparator}${iA.dim(`See ${wezTermConfigFilePath}`)}${LineSeparator}`;\n      }\n      let backupFileName = generateRandomBytes(4).toString(\"hex\");\n      let _backupFileName = `${wezTermConfigFilePath}.${backupFileName}.bak`;\n      try {\n        NA().copyFileSync(wezTermConfigFilePath, _backupFileName);\n      } catch (___error) {\n        BA(___error instanceof Error ? ___error : Error(String(___error)), $G0);\n        return `${OB(\"warning\", installWezTermShiftEnterBinding)(\"Error backing up existing WezTerm config. Bailing out.\")}${LineSeparator}${iA.dim(`See ${wezTermConfigFilePath}`)}${LineSeparator}${iA.dim(`Backup path: ${_backupFileName}`)}${LineSeparator}`;\n      }\n    }\n    if (!isExistingKeyBinding) {\n      existingConfigContent = `local wezterm = require 'wezterm'\nlocal config = wezterm.config_builder()\n\nconfig.keys = {\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n}\n\nreturn config\n`;\n    } else {\n      let temporaryBackupIdentifier = existingConfigContent.match(/config\\.keys\\s*=\\s*\\{([^}]*)\\}/s);\n      if (temporaryBackupIdentifier) {\n        let backupFilePath = temporaryBackupIdentifier[1] ?? \"\";\n        let keyBindingUpdateString = backupFilePath.trim() ? `${backupFilePath.trim()},\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},` : `\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n`;\n        existingConfigContent = existingConfigContent.replace(/config\\.keys\\s*=\\s*\\{[^}]*\\}/s, `config.keys = {${keyBindingUpdateString}}`);\n      } else if (existingConfigContent.match(/return\\s+config/s)) {\n        existingConfigContent = existingConfigContent.replace(/return\\s+config/s, `config.keys = {\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n}\n\nreturn config`);\n      } else {\n        existingConfigContent += `\nconfig.keys = {\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n}\n`;\n      }\n    }\n    NA().writeFileSync(wezTermConfigFilePath, existingConfigContent, {\n      encoding: \"utf-8\",\n      flush: false\n    });\n    return `${OB(\"success\", installWezTermShiftEnterBinding)(\"Installed WezTerm Shift+Enter key binding\")}${LineSeparator}${OB(\"success\", installWezTermShiftEnterBinding)(\"You may need to restart WezTerm for changes to take effect\")}${LineSeparator}${iA.dim(`See ${wezTermConfigFilePath}`)}${LineSeparator}`;\n  } catch (__errorInstance) {\n    BA(__errorInstance instanceof Error ? __errorInstance : Error(String(__errorInstance)), qG0);\n    throw Error(\"Failed to install WezTerm Shift+Enter key binding\");\n  }\n}\nasync function installGhosttyShiftEnterKeyBindingHandler(installGhosttyShiftEnterKeyBinding) {\n  let configPaths = [];\n  let xdgConfigHome = process.env.XDG_CONFIG_HOME;\n  if (xdgConfigHome) {\n    configPaths.push(outputImageFormatHandler(xdgConfigHome, \"ghostty\", \"config\"));\n  } else {\n    configPaths.push(outputImageFormatHandler(getFolderPath(), \".config\", \"ghostty\", \"config\"));\n  }\n  if (processImageTransformations() === \"darwin\") {\n    configPaths.push(outputImageFormatHandler(getFolderPath(), \"Library\", \"Application Support\", \"com.mitchellh.ghostty\", \"config\"));\n  }\n  let configPath = null;\n  let isConfigFileFound = false;\n  for (let configPathCandidate of configPaths) {\n    if (NA().existsSync(configPathCandidate)) {\n      configPath = configPathCandidate;\n      isConfigFileFound = true;\n      break;\n    }\n  }\n  if (!configPath) {\n    configPath = configPaths[0] ?? null;\n    isConfigFileFound = false;\n  }\n  if (!configPath) {\n    throw Error(\"No valid config path found for Ghostty\");\n  }\n  try {\n    let _configFilePath = \"\";\n    if (isConfigFileFound) {\n      _configFilePath = NA().readFileSync(configPath, {\n        encoding: \"utf-8\"\n      });\n      if (_configFilePath.includes(\"shift+enter\")) {\n        return `${OB(\"warning\", installGhosttyShiftEnterKeyBinding)(\"Found existing Ghostty Shift+Enter key binding. Remove it to continue.\")}${LineSeparator}${iA.dim(`See ${configPath}`)}${LineSeparator}`;\n      }\n      let installGhosttyShiftEnterBinding = generateRandomBytes(4).toString(\"hex\");\n      let backupConfigFilePath = `${configPath}.${installGhosttyShiftEnterBinding}.bak`;\n      try {\n        NA().copyFileSync(configPath, backupConfigFilePath);\n      } catch {\n        return `${OB(\"warning\", installGhosttyShiftEnterKeyBinding)(\"Error backing up existing Ghostty config. Bailing out.\")}${LineSeparator}${iA.dim(`See ${configPath}`)}${LineSeparator}${iA.dim(`Backup path: ${backupConfigFilePath}`)}${LineSeparator}`;\n      }\n    } else {\n      let setupGhosttyConfiguration = imageProcessor(configPath);\n      if (!NA().existsSync(setupGhosttyConfiguration)) {\n        NA().mkdirSync(setupGhosttyConfiguration);\n      }\n    }\n    let configContent = _configFilePath;\n    if (_configFilePath && !_configFilePath.endsWith(`\n`)) {\n      configContent += `\n`;\n    }\n    configContent += `keybind = shift+enter=text:\\\\x1b\\\\r\n`;\n    NA().writeFileSync(configPath, configContent, {\n      encoding: \"utf-8\",\n      flush: false\n    });\n    return `${OB(\"success\", installGhosttyShiftEnterKeyBinding)(\"Installed Ghostty Shift+Enter key binding\")}${LineSeparator}${OB(\"success\", installGhosttyShiftEnterKeyBinding)(\"You may need to restart Ghostty for changes to take effect\")}${LineSeparator}${iA.dim(`See ${configPath}`)}${LineSeparator}`;\n  } catch (______errorHandler) {\n    BA(______errorHandler instanceof Error ? ______errorHandler : Error(String(______errorHandler)), NG0);\n    throw Error(\"Failed to install Ghostty Shift+Enter key binding\");\n  }\n}\nasync function installIterm2ShiftEnterKeyBinding(installITerm2ShiftEnterKeyBinding) {\n  let _imageProcessingErrorMessages = getImageProcessingErrorMessages();\n  try {\n    if (!(await exportIterm2Settings())) {\n      throw Error(\"Failed to create backup of iTerm2 preferences, bailing out\");\n    }\n    let {\n      code: installationResultCode\n    } = await r0(\"defaults\", [\"write\", \"com.googlecode.iterm2\", \"GlobalKeyMap\", \"-dict-add\", \"0xd-0x20000-0x24\", `<dict>\n        <key>Text</key>\n        <string>\\\\n</string>\n        <key>Action</key>\n        <integer>12</integer>\n        <key>Version</key>\n        <integer>1</integer>\n        <key>Keycode</key>\n        <integer>13</integer>\n        <key>Modifiers</key>\n        <integer>131072</integer>\n      </dict>`]);\n    if (installationResultCode !== 0) {\n      throw Error(\"Failed to install iTerm2 Shift+Enter key binding\");\n    }\n    await r0(\"defaults\", [\"export\", \"com.googlecode.iterm2\", _imageProcessingErrorMessages]);\n    setupInProgressAndNotify();\n    return `${OB(\"success\", installITerm2ShiftEnterKeyBinding)(\"Installed iTerm2 Shift+Enter key binding\")}${LineSeparator}${iA.dim(\"See iTerm2  Preferences  Keys\")}${LineSeparator}`;\n  } catch (errorCaught) {\n    BA(errorCaught instanceof Error ? errorCaught : Error(String(errorCaught)), LG0);\n    let iterm2BackupPath = L1().iterm2BackupPath;\n    let isBackupRestored = false;\n    if (iterm2BackupPath && NA().existsSync(iterm2BackupPath)) {\n      try {\n        await r0(\"defaults\", [\"import\", \"com.googlecode.iterm2\", iterm2BackupPath]);\n        isBackupRestored = true;\n        setupInProgressAndNotify();\n      } catch (________error) {\n        BA(Error(`Failed to restore from backup: ${String(________error)}`), MG0);\n      }\n    }\n    throw Error(`Failed to install iTerm2 Shift+Enter key binding. ${isBackupRestored ? \"Your settings have been restored from backup.\" : iterm2BackupPath && NA().existsSync(iterm2BackupPath) ? `Restoring from backup failed, try manually with: defaults import com.googlecode.iterm2 ${iterm2BackupPath}` : \"No backup was available to restore from.\"}`);\n  }\n}\nfunction installTerminalShiftEnterKeyBinding(_installTerminalShiftEnterKeyBinding = \"VSCode\", userCallback) {\n  let applicationName = _installTerminalShiftEnterKeyBinding === \"VSCode\" ? \"Code\" : _installTerminalShiftEnterKeyBinding;\n  let outputPath = outputImageFormatHandler(getFolderPath(), processImageTransformations() === \"win32\" ? outputImageFormatHandler(\"AppData\", \"Roaming\", applicationName, \"User\") : processImageTransformations() === \"darwin\" ? outputImageFormatHandler(\"Library\", \"Application Support\", applicationName, \"User\") : outputImageFormatHandler(\".config\", applicationName, \"User\"));\n  let keybindingsJsonPath = outputImageFormatHandler(outputPath, \"keybindings.json\");\n  try {\n    let jsonContent = \"[]\";\n    let existingKeyBindings = [];\n    if (!NA().existsSync(outputPath)) {\n      NA().mkdirSync(outputPath);\n    }\n    if (NA().existsSync(keybindingsJsonPath)) {\n      jsonContent = NA().readFileSync(keybindingsJsonPath, {\n        encoding: \"utf-8\"\n      });\n      existingKeyBindings = XR0(jsonContent) ?? [];\n      let existingBindingCheck = generateRandomBytes(4).toString(\"hex\");\n      let _backupFilePath = `${keybindingsJsonPath}.${existingBindingCheck}.bak`;\n      try {\n        NA().copyFileSync(keybindingsJsonPath, _backupFilePath);\n      } catch {\n        return `${OB(\"warning\", userCallback)(`Error backing up existing ${_installTerminalShiftEnterKeyBinding} terminal keybindings. Bailing out.`)}${LineSeparator}${iA.dim(`See ${keybindingsJsonPath}`)}${LineSeparator}${iA.dim(`Backup path: ${_backupFilePath}`)}${LineSeparator}`;\n      }\n    }\n    if (existingKeyBindings.find(isShiftEnterCommandInTerminalFocus => isShiftEnterCommandInTerminalFocus.key === \"shift+enter\" && isShiftEnterCommandInTerminalFocus.command === \"workbench.action.terminal.sendSequence\" && isShiftEnterCommandInTerminalFocus.when === \"terminalFocus\")) {\n      return `${OB(\"warning\", userCallback)(`Found existing ${_installTerminalShiftEnterKeyBinding} terminal Shift+Enter key binding. Remove it to continue.`)}${LineSeparator}${iA.dim(`See ${keybindingsJsonPath}`)}${LineSeparator}`;\n    }\n    let newKeyBindingConfig = WR0(jsonContent, {\n      key: \"shift+enter\",\n      command: \"workbench.action.terminal.sendSequence\",\n      args: {\n        text: \"\u001b\\r\"\n      },\n      when: \"terminalFocus\"\n    });\n    NA().writeFileSync(keybindingsJsonPath, newKeyBindingConfig, {\n      encoding: \"utf-8\",\n      flush: false\n    });\n    return `${OB(\"success\", userCallback)(`Installed ${_installTerminalShiftEnterKeyBinding} terminal Shift+Enter key binding`)}${LineSeparator}${iA.dim(`See ${keybindingsJsonPath}`)}${LineSeparator}`;\n  } catch (________________________error) {\n    BA(________________________error instanceof Error ? ________________________error : Error(String(________________________error)), OG0);\n    throw Error(`Failed to install ${_installTerminalShiftEnterKeyBinding} terminal Shift+Enter key binding`);\n  }\n}\nasync function setOptionAsMetaKey(terminalProfileName) {\n  let {\n    code: commandExecutionResultCode\n  } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Add :'Window Settings':'${terminalProfileName}':useOptionAsMetaKey bool true`, getTerminalPreferencesPath()]);\n  if (commandExecutionResultCode !== 0) {\n    let {\n      code: setOptionAsMetaKeyResult\n    } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Set :'Window Settings':'${terminalProfileName}':useOptionAsMetaKey true`, getTerminalPreferencesPath()]);\n    if (setOptionAsMetaKeyResult !== 0) {\n      BA(Error(`Failed to enable Option as Meta key for Terminal.app profile: ${terminalProfileName}`), RG0);\n      return false;\n    }\n  }\n  return true;\n}\nasync function disableTerminalAudioBell(profileName) {\n  let {\n    code: bellSettingChangeCode\n  } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Add :'Window Settings':'${profileName}':Bell bool false`, getTerminalPreferencesPath()]);\n  if (bellSettingChangeCode !== 0) {\n    let {\n      code: setAudioBellDisabledStatus\n    } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Set :'Window Settings':'${profileName}':Bell false`, getTerminalPreferencesPath()]);\n    if (setAudioBellDisabledStatus !== 0) {\n      BA(Error(`Failed to disable audio bell for Terminal.app profile: ${profileName}`), TG0);\n      return false;\n    }\n  }\n  return true;\n}\nasync function configureAppleTerminalSettings(configureTerminalAppSettings) {\n  try {\n    if (!(await exportTerminalPreferences())) {\n      throw Error(\"Failed to create backup of Terminal.app preferences, bailing out\");\n    }\n    let {\n      stdout: defaultTerminalProfileName,\n      code: __exitCode\n    } = await r0(\"defaults\", [\"read\", \"com.apple.Terminal\", \"Default Window Settings\"]);\n    if (__exitCode !== 0 || !defaultTerminalProfileName.trim()) {\n      throw Error(\"Failed to read default Terminal.app profile\");\n    }\n    let {\n      stdout: startupProfileSettings,\n      code: startupWindowSettingsExitCode\n    } = await r0(\"defaults\", [\"read\", \"com.apple.Terminal\", \"Startup Window Settings\"]);\n    if (startupWindowSettingsExitCode !== 0 || !startupProfileSettings.trim()) {\n      throw Error(\"Failed to read startup Terminal.app profile\");\n    }\n    let isTerminalSettingsUpdated = false;\n    let defaultProfileName = defaultTerminalProfileName.trim();\n    let isOptionAsMetaKeyEnabled = await setOptionAsMetaKey(defaultProfileName);\n    let isTerminalAudioBellDisabled = await disableTerminalAudioBell(defaultProfileName);\n    if (isOptionAsMetaKeyEnabled || isTerminalAudioBellDisabled) {\n      isTerminalSettingsUpdated = true;\n    }\n    let defaultProfileSettings = startupProfileSettings.trim();\n    if (defaultProfileSettings !== defaultProfileName) {\n      let isProfileConfigured = await setOptionAsMetaKey(defaultProfileSettings);\n      let isOptionAsMetaEnabled = await disableTerminalAudioBell(defaultProfileSettings);\n      if (isProfileConfigured || isOptionAsMetaEnabled) {\n        isTerminalSettingsUpdated = true;\n      }\n    }\n    if (!isTerminalSettingsUpdated) {\n      throw Error(\"Failed to enable Option as Meta key or disable audio bell for any Terminal.app profile\");\n    }\n    await r0(\"killall\", [\"cfprefsd\"]);\n    _initializeAppleTerminalSetup();\n    return `${OB(\"success\", configureTerminalAppSettings)(\"Configured Terminal.app settings:\")}${LineSeparator}${OB(\"success\", configureTerminalAppSettings)(\"- Enabled \\\"Use Option as Meta key\\\"\")}${LineSeparator}${OB(\"success\", configureTerminalAppSettings)(\"- Switched to visual bell\")}${LineSeparator}${iA.dim(\"Option+Enter will now enter a newline.\")}${LineSeparator}${iA.dim(\"You must restart Terminal.app for changes to take effect.\", configureTerminalAppSettings)}${LineSeparator}`;\n  } catch (___________errorHandler) {\n    BA(___________errorHandler instanceof Error ? ___________errorHandler : Error(String(___________errorHandler)), PG0);\n    let appleTerminalSettingsRestoreResult = await restoreAppleTerminalSettings();\n    let errorMessage = \"Failed to enable Option as Meta key for Terminal.app.\";\n    if (appleTerminalSettingsRestoreResult.status === \"restored\") {\n      throw Error(`${errorMessage} Your settings have been restored from backup.`);\n    } else if (appleTerminalSettingsRestoreResult.status === \"failed\") {\n      throw Error(`${errorMessage} Restoring from backup failed, try manually with: defaults import com.apple.Terminal ${appleTerminalSettingsRestoreResult.backupPath}`);\n    } else {\n      throw Error(`${errorMessage} No backup was available to restore from.`);\n    }\n  }\n}\nvar validateOutputFilePath;\nvar character;\nvar ___________________________________imageProcessingPipeline = T(() => {\n  f2();\n  imagePipelineProcessor();\n  initializeShapelessPipeline();\n  kB();\n  C6();\n  Q5();\n  m0();\n  initializeCustomSettings();\n  wC();\n  c1();\n  nA();\n  E5();\n  validateOutputFilePath = {\n    type: \"local-jsx\",\n    name: \"terminal-setup\",\n    userFacingName() {\n      return \"terminal-setup\";\n    },\n    description: O0.terminal === \"Apple_Terminal\" ? \"Enable Option+Enter key binding for newlines and visual bell\" : \"Install Shift+Enter key binding for newlines\",\n    isEnabled: () => true,\n    isHidden: false,\n    async call(handleTerminalSetup, __callbackFunction) {\n      if (!isEnvironmentSupportedForImageTransformations()) {\n        let currentTerminal = O0.terminal || \"your current terminal\";\n        let getOperatingSystem = EB();\n        let supportedTerminalsInfo = \"\";\n        if (getOperatingSystem === \"macos\") {\n          supportedTerminalsInfo = `    macOS: iTerm2, Apple Terminal\n`;\n        } else if (getOperatingSystem === \"windows\") {\n          supportedTerminalsInfo = `    Windows: Windows Terminal\n`;\n        }\n        let terminalSetupErrorMessage = `Terminal setup cannot be run from ${currentTerminal}.\n\nThis command configures a convenient Shift+Enter shortcut for multi-line prompts.\n${iA.dim(\"Note: You can already use backslash (\\\\) + return to add newlines.\")}\n\nTo set up the shortcut (optional):\n1. Exit tmux/screen temporarily\n2. Run /terminal-setup directly in one of these terminals:\n${supportedTerminalsInfo}    IDE: VSCode, Cursor, Windsurf\n    Other: Ghostty, WezTerm\n3. Return to tmux/screen - settings will persist`;\n        handleTerminalSetup(terminalSetupErrorMessage);\n        return null;\n      }\n      let fetchTheme = await configureTerminalShiftEnterKeyBinding(__callbackFunction.options.theme);\n      handleTerminalSetup(fetchTheme);\n      return null;\n    }\n  };\n  character = validateOutputFilePath;\n});\nimport { join as processImageInput } from \"path\";\nfunction countNewlines(countLineBreaks) {\n  return (countLineBreaks.match(/\\r\\n|\\r|\\n/g) || []).length;\n}\nfunction formatPastedText(pastedTextFormatter, linesOffset) {\n  if (linesOffset === 0) {\n    return `[Pasted text #${pastedTextFormatter}]`;\n  }\n  return `[Pasted text #${pastedTextFormatter} +${linesOffset} lines]`;\n}\nfunction generateImageTag(imageIndex) {\n  return `[Image #${imageIndex}]`;\n}\nfunction extractReferencesFromText(extractTextMatches) {\n  let referencePattern = /\\[(Pasted text|Image|\\.\\.\\.Truncated text) #(\\d+)(?: \\+\\d+ lines)?(\\.)*\\]/g;\n  return [...extractTextMatches.matchAll(referencePattern)].map(_inputArray => ({\n    id: parseInt(_inputArray[2] || \"0\"),\n    match: _inputArray[0]\n  })).filter(isValidId => isValidId.id > 0);\n}\nfunction parseJsonString(jsonString) {\n  return JSON.parse(jsonString);\n}\nasync function* streamExifData() {\n  for (let ________________index = setExifData.length - 1; ________________index >= 0; ________________index--) {\n    yield setExifData[________________index];\n  }\n  let imageHistoryFilePath = processImageInput(mB(), \"history.jsonl\");\n  if (!NA().existsSync(imageHistoryFilePath)) {\n    return;\n  }\n  for await (let historyLine of C90(imageHistoryFilePath)) {\n    try {\n      yield parseJsonString(historyLine);\n    } catch (___________error) {\n      g(`Failed to parse history line: ${___________error}`);\n    }\n  }\n}\nasync function* filterProjectExifDataStream() {\n  let currentProjectId = GQ();\n  let imageCount = 0;\n  for await (let exifData of streamExifData()) {\n    if (exifData.project === currentProjectId) {\n      yield exifData;\n      imageCount++;\n      if (imageCount >= _imageProcessingPipeline) {\n        break;\n      }\n    }\n  }\n}\nasync function tx0(processImageTransaction) {\n  if (transformImageFormats || setExifData.length === 0) {\n    return;\n  }\n  if (processImageTransaction > 5) {\n    return;\n  }\n  transformImageFormats = true;\n  let B;\n  try {\n    let Q = processImageInput(mB(), \"history.jsonl\");\n    let I = NA();\n    if (!I.existsSync(Q)) {\n      I.writeFileSync(Q, \"\", {\n        encoding: \"utf8\",\n        flush: true,\n        mode: 384\n      });\n    }\n    B = await processImage.lock(Q, {\n      stale: 10000,\n      retries: {\n        retries: 3,\n        minTimeout: 50\n      }\n    });\n    let G = setExifData.map(jsonStringRepresentation => `${JSON.stringify(jsonStringRepresentation)}\n`);\n    setExifData = [];\n    I.appendFileSync(Q, G.join(\"\"), {\n      mode: 384\n    });\n  } catch (Q) {\n    g(`Failed to write prompt history: ${Q}`);\n  } finally {\n    transformImageFormats = false;\n    if (B) {\n      await B();\n    }\n    await new Promise(retryTimeout => setTimeout(retryTimeout, 1000));\n    if (setExifData.length > 0) {\n      tx0(processImageTransaction + 1);\n    }\n  }\n}\nasync function jn9(processInput) {\n  let B = typeof processInput === \"string\" ? {\n    display: processInput,\n    pastedContents: {}\n  } : processInput;\n  let Q = {};\n  if (B.pastedContents) {\n    for (let [contentIndex, pastedContent] of Object.entries(B.pastedContents)) {\n      if (pastedContent.type !== \"image\" && pastedContent.content.length <= _processImage) {\n        Q[Number(contentIndex)] = pastedContent;\n      }\n    }\n  }\n  let I = {\n    ...B,\n    pastedContents: Q,\n    timestamp: Date.now(),\n    project: GQ(),\n    sessionId: L0()\n  };\n  setExifData.push(I);\n  tx0(0);\n}\nfunction gk(_______inputData) {\n  jn9(_______inputData);\n}\nvar processImage;\nvar _imageProcessingPipeline = 100;\nvar _processImage = 1024;\nvar setExifData;\nvar transformImageFormats = false;\nvar imageProcessingHandler = T(() => {\n  vB();\n  m0();\n  i0();\n  C0();\n  processImage = IA(xYA(), 1);\n  setExifData = [];\n});\nvar _imageProcessor = z((getVersionFromData, getVersionFromQuery) => {\n  var _getVersionFromData = qi();\n  var fetchVersionFromData = (__getVersionFromData, dataObject) => {\n    let _versionInfo = _getVersionFromData(__getVersionFromData, dataObject);\n    if (_versionInfo) {\n      return _versionInfo.version;\n    } else {\n      return null;\n    }\n  };\n  getVersionFromQuery.exports = fetchVersionFromData;\n});\nvar ImageProcessingPipeline = z((getVersionFromInput, getVersion) => {\n  var _getVersion = qi();\n  var extractVersion = (getVersionWithoutPrefix, versionString) => {\n    let _getVersionFromInput = _getVersion(getVersionWithoutPrefix.trim().replace(/^[=v]+/, \"\"), versionString);\n    if (_getVersionFromInput) {\n      return _getVersionFromInput.version;\n    } else {\n      return null;\n    }\n  };\n  getVersion.exports = extractVersion;\n});\nvar processorFunction = z((incrementVersion, exportVersionIncrementer) => {\n  var VersionManager = oV();\n  var __incrementVersion = (updateVersion, ___incrementVersion, incrementVersionString, inputVersion, previousIncrementValue) => {\n    if (typeof incrementVersionString === \"string\") {\n      previousIncrementValue = inputVersion;\n      inputVersion = incrementVersionString;\n      incrementVersionString = undefined;\n    }\n    try {\n      return new VersionManager(updateVersion instanceof VersionManager ? updateVersion.version : updateVersion, incrementVersionString).inc(___incrementVersion, inputVersion, previousIncrementValue).version;\n    } catch (_________________________error) {\n      return null;\n    }\n  };\n  exportVersionIncrementer.exports = __incrementVersion;\n});\nvar __imageProcessingPipeline = z((compareVersionPragmatics, versionComparisonFunction) => {\n  var _createVersionComparisonFunction = qi();\n  var _____compareVersions = (compareVersionDifferences, ______compareVersions) => {\n    let createVersionComparisonFunctionA = _createVersionComparisonFunction(compareVersionDifferences, null, true);\n    let versionComparisonFunctionB = _createVersionComparisonFunction(______compareVersions, null, true);\n    let comparisonResult = createVersionComparisonFunctionA.compare(versionComparisonFunctionB);\n    if (comparisonResult === 0) {\n      return null;\n    }\n    let isFirstVersionGreater = comparisonResult > 0;\n    let selectedVersionComparisonFunction = isFirstVersionGreater ? createVersionComparisonFunctionA : versionComparisonFunctionB;\n    let previousVersionComparator = isFirstVersionGreater ? versionComparisonFunctionB : createVersionComparisonFunctionA;\n    let isPrereleaseVersion = !!selectedVersionComparisonFunction.prerelease.length;\n    if (!!previousVersionComparator.prerelease.length && !isPrereleaseVersion) {\n      if (!previousVersionComparator.patch && !previousVersionComparator.minor) {\n        return \"major\";\n      }\n      if (previousVersionComparator.compareMain(selectedVersionComparisonFunction) === 0) {\n        if (previousVersionComparator.minor && !previousVersionComparator.patch) {\n          return \"minor\";\n        }\n        return \"patch\";\n      }\n    }\n    let prereleasePrefix = isPrereleaseVersion ? \"pre\" : \"\";\n    if (createVersionComparisonFunctionA.major !== versionComparisonFunctionB.major) {\n      return prereleasePrefix + \"major\";\n    }\n    if (createVersionComparisonFunctionA.minor !== versionComparisonFunctionB.minor) {\n      return prereleasePrefix + \"minor\";\n    }\n    if (createVersionComparisonFunctionA.patch !== versionComparisonFunctionB.patch) {\n      return prereleasePrefix + \"patch\";\n    }\n    return \"prerelease\";\n  };\n  versionComparisonFunction.exports = _____compareVersions;\n});\nvar __processImage = z((createMajorInstance, createMajorFromInputs) => {\n  var _createMajorInstance = oV();\n  var createMajorFromArgs = (__createMajorInstance, createMajorInstanceFromInputs) => new _createMajorInstance(__createMajorInstance, createMajorInstanceFromInputs).major;\n  createMajorFromInputs.exports = createMajorFromArgs;\n});\nvar ___imageProcessingPipeline = z((createMinorMatrix, createMinorFunction) => {\n  var createMinorInstance = oV();\n  var _createMinorMatrix = (createAndReturnMinorInstance, createMinorInstanceFromInputs) => new createMinorInstance(createAndReturnMinorInstance, createMinorInstanceFromInputs).minor;\n  createMinorFunction.exports = _createMinorMatrix;\n});\nvar updateImageOutputOptions = z((createPatchFunction, _createPatchFunction) => {\n  var createPatchInstance = oV();\n  var createPatch = (createAndPatchInstance, _createAndPatchInstance) => new createPatchInstance(createAndPatchInstance, _createAndPatchInstance).patch;\n  _createPatchFunction.exports = createPatch;\n});\nvar handleImageFormatConversion = z((getPrereleaseParts, getPrereleaseVersions) => {\n  var _getPrereleaseVersions = qi();\n  var extractPrereleaseTags = (__getPrereleaseVersions, ___getPrereleaseVersions) => {\n    let ____getPrereleaseVersions = _getPrereleaseVersions(__getPrereleaseVersions, ___getPrereleaseVersions);\n    if (____getPrereleaseVersions && ____getPrereleaseVersions.prerelease.length) {\n      return ____getPrereleaseVersions.prerelease;\n    } else {\n      return null;\n    }\n  };\n  getPrereleaseVersions.exports = extractPrereleaseTags;\n});\nvar imageConversionPipeline = z((requestFunction, exportFunction) => {\n  var createCustomFunction = d$();\n  var createAndExportCustomFunction = (__dataProcessor, customFunctionParameter, customFunctionCreator) => createCustomFunction(customFunctionParameter, __dataProcessor, customFunctionCreator);\n  exportFunction.exports = createAndExportCustomFunction;\n});\nvar ____imageProcessingPipeline = z((createIn9Function, exportedFunction) => {\n  var createAndExportFunctionWithParams = d$();\n  var createAndExportFunctionWithParamsAndFlag = (_createAndExportFunctionWithParams, ______________callbackFunction) => createAndExportFunctionWithParams(_createAndExportFunctionWithParams, ______________callbackFunction, true);\n  exportedFunction.exports = createAndExportFunctionWithParamsAndFlag;\n});\nvar updateImageFormatSettings = z((compareInstances, _compareInstances) => {\n  var ObjectComparator = oV();\n  var compareObjectInstances = (compareObjects, objectComparatorForA, _objectComparatorForA) => {\n    let objectComparatorA = new ObjectComparator(compareObjects, _objectComparatorForA);\n    let ___comparisonResult = new ObjectComparator(objectComparatorForA, _objectComparatorForA);\n    return objectComparatorA.compare(___comparisonResult) || objectComparatorA.compareBuild(___comparisonResult);\n  };\n  _compareInstances.exports = compareObjectInstances;\n});\nvar ___processImageTransformations = z((sortImageSettingsByFormat, sortImagesByFormat) => {\n  var compareImageFormats = updateImageFormatSettings();\n  var sortImagesByFormatUsingSettings = (____sortImagesByFormat, imageFormatComparisonFunction) => ____sortImagesByFormat.sort((compareFormatParameters, imageFormatComparer) => compareImageFormats(compareFormatParameters, imageFormatComparer, imageFormatComparisonFunction));\n  sortImagesByFormat.exports = sortImagesByFormatUsingSettings;\n});\nvar ______________________________________processImageTransformation = z((_sortImagesByFormat, __sortImagesByFormat) => {\n  var updateAndSortImagesByFormat = updateImageFormatSettings();\n  var ___sortImagesByFormat = (sortImagesByFormatAndUpdate, sortOrderFunction) => sortImagesByFormatAndUpdate.sort((imageUpdateHandler, imagesToUpdate) => updateAndSortImagesByFormat(imagesToUpdate, imageUpdateHandler, sortOrderFunction));\n  __sortImagesByFormat.exports = ___sortImagesByFormat;\n});\nvar _____imageProcessingPipeline = z((createAndMapValues, createAndExportArrayMapper) => {\n  var _createAndMapValues = c$();\n  var mapValuesToArray = (__createAndMapValues, inputValues) => new _createAndMapValues(__createAndMapValues, inputValues).set.map(inputValuesToArray => inputValuesToArray.map(____inputValue => ____inputValue.value).join(\" \").trim().split(\" \"));\n  createAndExportArrayMapper.exports = mapValuesToArray;\n});\nvar _imageProcessingHandler = z((findBestMatch, exportHighestPriorityMatch) => {\n  var findMatchingElement = oV();\n  var createTestInstance = c$();\n  var findBestMatchingElement = (_findBestMatchingElement, testInstanceConstructor, testCriteria) => {\n    let currentBestMatch = null;\n    let elementMatcher = null;\n    let testInstance = null;\n    try {\n      testInstance = new createTestInstance(testInstanceConstructor, testCriteria);\n    } catch (__________________________error) {\n      return null;\n    }\n    _findBestMatchingElement.forEach(potentialMatch => {\n      if (testInstance.test(potentialMatch)) {\n        if (!currentBestMatch || elementMatcher.compare(potentialMatch) === -1) {\n          currentBestMatch = potentialMatch;\n          elementMatcher = new findMatchingElement(currentBestMatch, testCriteria);\n        }\n      }\n    });\n    return currentBestMatch;\n  };\n  exportHighestPriorityMatch.exports = findBestMatchingElement;\n});\nvar enhancedImageProcessingPipeline = z((_findBestMatch, findBestMatchingValue) => {\n  var createComparisonObject = oV();\n  var createTestObject = c$();\n  var findBestMatchForInputs = (__findBestMatch, testParameters, _testCriteria) => {\n    let _currentBestMatch = null;\n    let comparisonObject = null;\n    let testObject = null;\n    try {\n      testObject = new createTestObject(testParameters, _testCriteria);\n    } catch (___________________________error) {\n      return null;\n    }\n    __findBestMatch.forEach(candidateValue => {\n      if (testObject.test(candidateValue)) {\n        if (!_currentBestMatch || comparisonObject.compare(candidateValue) === 1) {\n          _currentBestMatch = candidateValue;\n          comparisonObject = new createComparisonObject(_currentBestMatch, _testCriteria);\n        }\n      }\n    });\n    return _currentBestMatch;\n  };\n  findBestMatchingValue.exports = findBestMatchForInputs;\n});\nvar convertImageFormat = z((validateVersion, validateSemver) => {\n  var SemverValidator = oV();\n  var _validateSemverRange = c$();\n  var ___compareVersions = VJA();\n  var findHighestValidSemver = (validateAndFindHighestValidVersion, semverRangeValidator) => {\n    validateAndFindHighestValidVersion = new _validateSemverRange(validateAndFindHighestValidVersion, semverRangeValidator);\n    let highestValidVersion = new SemverValidator(\"0.0.0\");\n    if (validateAndFindHighestValidVersion.test(highestValidVersion)) {\n      return highestValidVersion;\n    }\n    highestValidVersion = new SemverValidator(\"0.0.0-0\");\n    if (validateAndFindHighestValidVersion.test(highestValidVersion)) {\n      return highestValidVersion;\n    }\n    highestValidVersion = null;\n    for (let currentSetIndex = 0; currentSetIndex < validateAndFindHighestValidVersion.set.length; ++currentSetIndex) {\n      let currentVersionSet = validateAndFindHighestValidVersion.set[currentSetIndex];\n      let highestSemverValidator = null;\n      currentVersionSet.forEach(semverValidationOperation => {\n        let semverValidator = new SemverValidator(semverValidationOperation.semver.version);\n        switch (semverValidationOperation.operator) {\n          case \">\":\n            if (semverValidator.prerelease.length === 0) {\n              semverValidator.patch++;\n            } else {\n              semverValidator.prerelease.push(0);\n            }\n            semverValidator.raw = semverValidator.format();\n          case \"\":\n          case \">=\":\n            if (!highestSemverValidator || ___compareVersions(semverValidator, highestSemverValidator)) {\n              highestSemverValidator = semverValidator;\n            }\n            break;\n          case \"<\":\n          case \"<=\":\n            break;\n          default:\n            throw Error(`Unexpected operation: ${semverValidationOperation.operator}`);\n        }\n      });\n      if (highestSemverValidator && (!highestValidVersion || ___compareVersions(highestValidVersion, highestSemverValidator))) {\n        highestValidVersion = highestSemverValidator;\n      }\n    }\n    if (highestValidVersion && validateAndFindHighestValidVersion.test(highestValidVersion)) {\n      return highestValidVersion;\n    }\n    return null;\n  };\n  validateSemver.exports = findHighestValidSemver;\n});\nvar processImagePipeline = z((createRangeWithFallback, createRangeFunction) => {\n  var createRangeInstance = c$();\n  var _createRangeWithFallback = (createRangeWithBounds, createRange) => {\n    try {\n      return new createRangeInstance(createRangeWithBounds, createRange).range || \"*\";\n    } catch (____________________________error) {\n      return null;\n    }\n  };\n  createRangeFunction.exports = _createRangeWithFallback;\n});\nvar initializeSharpImageProcessing = z((validateVersionConstraints, validateSemverRange) => {\n  var __compareVersions = oV();\n  var createVersionComparisonFunction = DJA();\n  var {\n    ANY: ANY_VERSION_COMPARISON\n  } = createVersionComparisonFunction;\n  var VersionRangeValidator = c$();\n  var evaluateSemverConstraints = q0A();\n  var comparisonOperatorHandler = VJA();\n  var evaluateVersionConstraints = ePA();\n  var _validateVersionConstraints = AjA();\n  var validateVersionRange = CJA();\n  var validateVersionComparison = (validateVersionCompatibility, versionRange, _comparisonOperator, _currentVersionCandidate) => {\n    validateVersionCompatibility = new __compareVersions(validateVersionCompatibility, _currentVersionCandidate);\n    versionRange = new VersionRangeValidator(versionRange, _currentVersionCandidate);\n    let comparisonOperationHandler;\n    let __validateVersionConstraints;\n    let ___compareVersionConstraints;\n    let __comparisonOperator;\n    let versionRangeUpperBoundOperator;\n    switch (_comparisonOperator) {\n      case \">\":\n        comparisonOperationHandler = comparisonOperatorHandler;\n        __validateVersionConstraints = _validateVersionConstraints;\n        ___compareVersionConstraints = evaluateVersionConstraints;\n        __comparisonOperator = \">\";\n        versionRangeUpperBoundOperator = \">=\";\n        break;\n      case \"<\":\n        comparisonOperationHandler = evaluateVersionConstraints;\n        __validateVersionConstraints = validateVersionRange;\n        ___compareVersionConstraints = comparisonOperatorHandler;\n        __comparisonOperator = \"<\";\n        versionRangeUpperBoundOperator = \"<=\";\n        break;\n      default:\n        throw TypeError(\"Must provide a hilo val of \\\"<\\\" or \\\">\\\"\");\n    }\n    if (evaluateSemverConstraints(validateVersionCompatibility, versionRange, _currentVersionCandidate)) {\n      return false;\n    }\n    for (let _currentSetIndex = 0; _currentSetIndex < versionRange.set.length; ++_currentSetIndex) {\n      let currentVersion = versionRange.set[_currentSetIndex];\n      let currentVersionCandidate = null;\n      let latestVersion = null;\n      currentVersion.forEach(versionInfo => {\n        if (versionInfo.semver === ANY_VERSION_COMPARISON) {\n          versionInfo = new createVersionComparisonFunction(\">=0.0.0\");\n        }\n        currentVersionCandidate = currentVersionCandidate || versionInfo;\n        latestVersion = latestVersion || versionInfo;\n        if (comparisonOperationHandler(versionInfo.semver, currentVersionCandidate.semver, _currentVersionCandidate)) {\n          currentVersionCandidate = versionInfo;\n        } else if (___compareVersionConstraints(versionInfo.semver, latestVersion.semver, _currentVersionCandidate)) {\n          latestVersion = versionInfo;\n        }\n      });\n      if (currentVersionCandidate.operator === __comparisonOperator || currentVersionCandidate.operator === versionRangeUpperBoundOperator) {\n        return false;\n      }\n      if ((!latestVersion.operator || latestVersion.operator === __comparisonOperator) && __validateVersionConstraints(validateVersionCompatibility, latestVersion.semver)) {\n        return false;\n      } else if (latestVersion.operator === versionRangeUpperBoundOperator && ___compareVersionConstraints(validateVersionCompatibility, latestVersion.semver)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  validateSemverRange.exports = validateVersionComparison;\n});\nvar imageTransformProcessor = z((sharpImageProcessingFilter, exportSharpImageProcessing) => {\n  var sharpImageProcessingFilterHandler = initializeSharpImageProcessing();\n  var applySharpImageProcessingFilter = (_sharpImageProcessingFilterHandler, _sharpImageProcessingFilter, ___comparisonOperator) => sharpImageProcessingFilterHandler(_sharpImageProcessingFilterHandler, _sharpImageProcessingFilter, \">\", ___comparisonOperator);\n  exportSharpImageProcessing.exports = applySharpImageProcessingFilter;\n});\nvar __________imageTransformationProcessor = z((sharpImageProcessingHandler, _sharpImageProcessing) => {\n  var initializeSharpImageProcessor = initializeSharpImageProcessing();\n  var processImageWithThreshold = (_initializeSharpImageProcessor, ____comparisonOperator, thresholdValue) => initializeSharpImageProcessor(_initializeSharpImageProcessor, ____comparisonOperator, \"<\", thresholdValue);\n  _sharpImageProcessing.exports = processImageWithThreshold;\n});\nvar ______imageProcessingPipeline = z((checkIntersects, checkIntersection) => {\n  var IntersectionChecker = c$();\n  var _checkIntersection = (intersectionChecker, secondIntersectionChecker, _intersectionChecker) => {\n    intersectionChecker = new IntersectionChecker(intersectionChecker, _intersectionChecker);\n    secondIntersectionChecker = new IntersectionChecker(secondIntersectionChecker, _intersectionChecker);\n    return intersectionChecker.intersects(secondIntersectionChecker, _intersectionChecker);\n  };\n  checkIntersection.exports = _checkIntersection;\n});\nvar outputFilePath = z((createConditionalRanges, createExportedSortingFunction) => {\n  var isConditionMet = q0A();\n  var generateRangePairs = d$();\n  createExportedSortingFunction.exports = (generateRangeString, generateFilterOutput, findRangesBasedOnCriteria) => {\n    let resultsArray = [];\n    let currentGroup = null;\n    let currentElement = null;\n    let sortedArray = generateRangeString.sort((findAndGenerateRangePairs, criteriaBasedRangeGenerator) => generateRangePairs(findAndGenerateRangePairs, criteriaBasedRangeGenerator, findRangesBasedOnCriteria));\n    for (let currentSortedElement of sortedArray) {\n      if (isConditionMet(currentSortedElement, generateFilterOutput, findRangesBasedOnCriteria)) {\n        currentElement = currentSortedElement;\n        if (!currentGroup) {\n          currentGroup = currentSortedElement;\n        }\n      } else {\n        if (currentElement) {\n          resultsArray.push([currentGroup, currentElement]);\n        }\n        currentElement = null;\n        currentGroup = null;\n      }\n    }\n    if (currentGroup) {\n      resultsArray.push([currentGroup, null]);\n    }\n    let formattedRanges = [];\n    for (let [rangeStart, endRange] of resultsArray) {\n      if (rangeStart === endRange) {\n        formattedRanges.push(rangeStart);\n      } else if (!endRange && rangeStart === sortedArray[0]) {\n        formattedRanges.push(\"*\");\n      } else if (!endRange) {\n        formattedRanges.push(`>=${rangeStart}`);\n      } else if (rangeStart === sortedArray[0]) {\n        formattedRanges.push(`<=${endRange}`);\n      } else {\n        formattedRanges.push(`${rangeStart} - ${endRange}`);\n      }\n    }\n    let generateConditionString = formattedRanges.join(\" || \");\n    let formattedOutput = typeof generateFilterOutput.raw === \"string\" ? generateFilterOutput.raw : String(generateFilterOutput);\n    if (generateConditionString.length < formattedOutput.length) {\n      return generateConditionString;\n    } else {\n      return generateFilterOutput;\n    }\n  };\n});\nvar outputImageProcessingFunction = z((compareVersionSets, exportVersionComparisonFunction) => {\n  var VersionSetComparator = c$();\n  var createVersionValidator = DJA();\n  var {\n    ANY: ANY_VERSION\n  } = createVersionValidator;\n  var compareVersionConstraints = q0A();\n  var compareSemver = d$();\n  var _compareVersionSets = (__compareVersionSets, secondVersionSet, versionSetComparatorOptions = {}) => {\n    if (__compareVersionSets === secondVersionSet) {\n      return true;\n    }\n    __compareVersionSets = new VersionSetComparator(__compareVersionSets, versionSetComparatorOptions);\n    secondVersionSet = new VersionSetComparator(secondVersionSet, versionSetComparatorOptions);\n    let isAnyVersionMatched = false;\n    A: for (let versionSetItem of __compareVersionSets.set) {\n      for (let _item of secondVersionSet.set) {\n        let resultFromTa9 = compareVersionItems(versionSetItem, _item, versionSetComparatorOptions);\n        isAnyVersionMatched = isAnyVersionMatched || resultFromTa9 !== null;\n        if (resultFromTa9) {\n          continue A;\n        }\n      }\n      if (isAnyVersionMatched) {\n        return false;\n      }\n    }\n    return true;\n  };\n  var prereleaseValidator = [new createVersionValidator(\">=0.0.0-0\")];\n  var defaultVersionConstraints = [new createVersionValidator(\">=0.0.0\")];\n  var compareVersionItems = (__compareVersionConstraints, versionConstraintsB, versionOptions) => {\n    if (__compareVersionConstraints === versionConstraintsB) {\n      return true;\n    }\n    if (__compareVersionConstraints.length === 1 && __compareVersionConstraints[0].semver === ANY_VERSION) {\n      if (versionConstraintsB.length === 1 && versionConstraintsB[0].semver === ANY_VERSION) {\n        return true;\n      } else if (versionOptions.includePrerelease) {\n        __compareVersionConstraints = prereleaseValidator;\n      } else {\n        __compareVersionConstraints = defaultVersionConstraints;\n      }\n    }\n    if (versionConstraintsB.length === 1 && versionConstraintsB[0].semver === ANY_VERSION) {\n      if (versionOptions.includePrerelease) {\n        return true;\n      } else {\n        versionConstraintsB = defaultVersionConstraints;\n      }\n    }\n    let versionsSet = new Set();\n    let previousVersionComparison;\n    let ____comparisonResult;\n    for (let __versionConstraint of __compareVersionConstraints) {\n      if (__versionConstraint.operator === \">\" || __versionConstraint.operator === \">=\") {\n        previousVersionComparison = ____compareVersions(previousVersionComparison, __versionConstraint, versionOptions);\n      } else if (__versionConstraint.operator === \"<\" || __versionConstraint.operator === \"<=\") {\n        ____comparisonResult = compareSemverConstraints(____comparisonResult, __versionConstraint, versionOptions);\n      } else {\n        versionsSet.add(__versionConstraint.semver);\n      }\n    }\n    if (versionsSet.size > 1) {\n      return null;\n    }\n    let semverComparisonResult;\n    if (previousVersionComparison && ____comparisonResult) {\n      semverComparisonResult = compareSemver(previousVersionComparison.semver, ____comparisonResult.semver, versionOptions);\n      if (semverComparisonResult > 0) {\n        return null;\n      } else if (semverComparisonResult === 0 && (previousVersionComparison.operator !== \">=\" || ____comparisonResult.operator !== \"<=\")) {\n        return null;\n      }\n    }\n    for (let version of versionsSet) {\n      if (previousVersionComparison && !compareVersionConstraints(version, String(previousVersionComparison), versionOptions)) {\n        return null;\n      }\n      if (____comparisonResult && !compareVersionConstraints(version, String(____comparisonResult), versionOptions)) {\n        return null;\n      }\n      for (let versionConstraint of versionConstraintsB) {\n        if (!compareVersionConstraints(version, String(versionConstraint), versionOptions)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    let latestVersionCheck;\n    let compareVersionConstraintsAgainstSemver;\n    let isVersionCompatible;\n    let checkVersionConstraints;\n    let latestStableVersion = ____comparisonResult && !versionOptions.includePrerelease && ____comparisonResult.semver.prerelease.length ? ____comparisonResult.semver : false;\n    let potentialVersionConstraint = previousVersionComparison && !versionOptions.includePrerelease && previousVersionComparison.semver.prerelease.length ? previousVersionComparison.semver : false;\n    if (latestStableVersion && latestStableVersion.prerelease.length === 1 && ____comparisonResult.operator === \"<\" && latestStableVersion.prerelease[0] === 0) {\n      latestStableVersion = false;\n    }\n    for (let _versionConstraint of versionConstraintsB) {\n      checkVersionConstraints = checkVersionConstraints || _versionConstraint.operator === \">\" || _versionConstraint.operator === \">=\";\n      isVersionCompatible = isVersionCompatible || _versionConstraint.operator === \"<\" || _versionConstraint.operator === \"<=\";\n      if (previousVersionComparison) {\n        if (potentialVersionConstraint) {\n          if (_versionConstraint.semver.prerelease && _versionConstraint.semver.prerelease.length && _versionConstraint.semver.major === potentialVersionConstraint.major && _versionConstraint.semver.minor === potentialVersionConstraint.minor && _versionConstraint.semver.patch === potentialVersionConstraint.patch) {\n            potentialVersionConstraint = false;\n          }\n        }\n        if (_versionConstraint.operator === \">\" || _versionConstraint.operator === \">=\") {\n          latestVersionCheck = ____compareVersions(previousVersionComparison, _versionConstraint, versionOptions);\n          if (latestVersionCheck === _versionConstraint && latestVersionCheck !== previousVersionComparison) {\n            return false;\n          }\n        } else if (previousVersionComparison.operator === \">=\" && !compareVersionConstraints(previousVersionComparison.semver, String(_versionConstraint), versionOptions)) {\n          return false;\n        }\n      }\n      if (____comparisonResult) {\n        if (latestStableVersion) {\n          if (_versionConstraint.semver.prerelease && _versionConstraint.semver.prerelease.length && _versionConstraint.semver.major === latestStableVersion.major && _versionConstraint.semver.minor === latestStableVersion.minor && _versionConstraint.semver.patch === latestStableVersion.patch) {\n            latestStableVersion = false;\n          }\n        }\n        if (_versionConstraint.operator === \"<\" || _versionConstraint.operator === \"<=\") {\n          compareVersionConstraintsAgainstSemver = compareSemverConstraints(____comparisonResult, _versionConstraint, versionOptions);\n          if (compareVersionConstraintsAgainstSemver === _versionConstraint && compareVersionConstraintsAgainstSemver !== ____comparisonResult) {\n            return false;\n          }\n        } else if (____comparisonResult.operator === \"<=\" && !compareVersionConstraints(____comparisonResult.semver, String(_versionConstraint), versionOptions)) {\n          return false;\n        }\n      }\n      if (!_versionConstraint.operator && (____comparisonResult || previousVersionComparison) && semverComparisonResult !== 0) {\n        return false;\n      }\n    }\n    if (previousVersionComparison && isVersionCompatible && !____comparisonResult && semverComparisonResult !== 0) {\n      return false;\n    }\n    if (____comparisonResult && checkVersionConstraints && !previousVersionComparison && semverComparisonResult !== 0) {\n      return false;\n    }\n    if (potentialVersionConstraint || latestStableVersion) {\n      return false;\n    }\n    return true;\n  };\n  var ____compareVersions = (compareVersionsBasedOnSemver, fallbackVersion, semverComparisonFunction) => {\n    if (!compareVersionsBasedOnSemver) {\n      return fallbackVersion;\n    }\n    let _comparisonResult = compareSemver(compareVersionsBasedOnSemver.semver, fallbackVersion.semver, semverComparisonFunction);\n    if (_comparisonResult > 0) {\n      return compareVersionsBasedOnSemver;\n    } else if (_comparisonResult < 0) {\n      return fallbackVersion;\n    } else if (fallbackVersion.operator === \">\" && compareVersionsBasedOnSemver.operator === \">=\") {\n      return fallbackVersion;\n    } else {\n      return compareVersionsBasedOnSemver;\n    }\n  };\n  var compareSemverConstraints = (_compareVersionConstraints, _fallbackVersion, comparisonOperator) => {\n    if (!_compareVersionConstraints) {\n      return _fallbackVersion;\n    }\n    let __comparisonResult = compareSemver(_compareVersionConstraints.semver, _fallbackVersion.semver, comparisonOperator);\n    if (__comparisonResult < 0) {\n      return _compareVersionConstraints;\n    } else if (__comparisonResult > 0) {\n      return _fallbackVersion;\n    } else if (_fallbackVersion.operator === \"<\" && _compareVersionConstraints.operator === \"<=\") {\n      return _fallbackVersion;\n    } else {\n      return _compareVersionConstraints;\n    }\n  };\n  exportVersionComparisonFunction.exports = _compareVersionSets;\n});\nvar _imageProcessingFunction = z((_imageProcessingModule, imageProcessingExports) => {\n  var ___imageProcessingHandler = w0A();\n  var semverConstants = FJA();\n  var SemanticVersion = oV();\n  var imageIdentifierUtils = AJ1();\n  var parseSemver = qi();\n  var validateImageProcessing = _imageProcessor();\n  var cleanProcessedImage = ImageProcessingPipeline();\n  var _incrementVersion = processorFunction();\n  var diffImageProcessing = __imageProcessingPipeline();\n  var getMajorVersion = __processImage();\n  var calculateImageMinorVersion = ___imageProcessingPipeline();\n  var updateImagePatchOptions = updateImageOutputOptions();\n  var handleImagePreprocessing = handleImageFormatConversion();\n  var compareVersions = d$();\n  var imageConversionComparisonPipeline = imageConversionPipeline();\n  var compareLooseSemanticVersions = ____imageProcessingPipeline();\n  var compareImageFormatSettings = updateImageFormatSettings();\n  var sortImageProcessing = ___processImageTransformations();\n  var sortDescendingByVersion = ______________________________________processImageTransformation();\n  var getGreaterThan = VJA();\n  var lessThanVersion = ePA();\n  var compareSemanticVersions = QJ1();\n  var isVersionEqual = IJ1();\n  var isGreaterThanOrEqualTo = CJA();\n  var lessThanOrEqualTo = AjA();\n  var _compareVersions = GJ1();\n  var coerceVersion = BJ1();\n  var ComparatorFunction = DJA();\n  var RangeHandler = c$();\n  var satisfiesVersion = q0A();\n  var toComparatorsPipeline = _____imageProcessingPipeline();\n  var getMaxSatisfyingVersion = _imageProcessingHandler();\n  var minSatisfyingVersion = enhancedImageProcessingPipeline();\n  var minVersionHandler = convertImageFormat();\n  var validRange = processImagePipeline();\n  var processOutsideImagePipeline = initializeSharpImageProcessing();\n  var _________________________imageTransformationProcessor = imageTransformProcessor();\n  var imageTransformProcessorLoose = __________imageTransformationProcessor();\n  var intersectImageProcessingPipelines = ______imageProcessingPipeline();\n  var simplifyImageProcessingRange = outputFilePath();\n  var outputImagePipelineSettings = outputImageProcessingFunction();\n  imageProcessingExports.exports = {\n    parse: parseSemver,\n    valid: validateImageProcessing,\n    clean: cleanProcessedImage,\n    inc: _incrementVersion,\n    diff: diffImageProcessing,\n    major: getMajorVersion,\n    minor: calculateImageMinorVersion,\n    patch: updateImagePatchOptions,\n    prerelease: handleImagePreprocessing,\n    compare: compareVersions,\n    rcompare: imageConversionComparisonPipeline,\n    compareLoose: compareLooseSemanticVersions,\n    compareBuild: compareImageFormatSettings,\n    sort: sortImageProcessing,\n    rsort: sortDescendingByVersion,\n    gt: getGreaterThan,\n    lt: lessThanVersion,\n    eq: compareSemanticVersions,\n    neq: isVersionEqual,\n    gte: isGreaterThanOrEqualTo,\n    lte: lessThanOrEqualTo,\n    cmp: _compareVersions,\n    coerce: coerceVersion,\n    Comparator: ComparatorFunction,\n    Range: RangeHandler,\n    satisfies: satisfiesVersion,\n    toComparators: toComparatorsPipeline,\n    maxSatisfying: getMaxSatisfyingVersion,\n    minSatisfying: minSatisfyingVersion,\n    minVersion: minVersionHandler,\n    validRange: validRange,\n    outside: processOutsideImagePipeline,\n    gtr: _________________________imageTransformationProcessor,\n    ltr: imageTransformProcessorLoose,\n    intersects: intersectImageProcessingPipelines,\n    simplifyRange: simplifyImageProcessingRange,\n    subset: outputImagePipelineSettings,\n    SemVer: SemanticVersion,\n    re: ___imageProcessingHandler.re,\n    src: ___imageProcessingHandler.src,\n    tokens: ___imageProcessingHandler.t,\n    SEMVER_SPEC_VERSION: semverConstants.SEMVER_SPEC_VERSION,\n    RELEASE_TYPES: semverConstants.RELEASE_TYPES,\n    compareIdentifiers: imageIdentifierUtils.compareIdentifiers,\n    rcompareIdentifiers: imageIdentifierUtils.rcompareIdentifiers\n  };\n});\nvar processImageAndGenerateOutput;\nvar processImageEnhancements;\nvar ImageHandler;\nvar setExifMergeOptions;\nvar imageTransformer = T(() => {\n  E5();\n  processImageAndGenerateOutput = IA(_imageProcessingFunction(), 1);\n  processImageEnhancements = EB() !== \"windows\" || (Ai() ? processImageAndGenerateOutput.default.satisfies(process.versions.bun, \">=1.2.23\") : processImageAndGenerateOutput.default.satisfies(process.versions.node, \">=22.17.0 <23.0.0 || >=24.2.0\"));\n  if (!processImageEnhancements) {\n    ImageHandler = {\n      displayText: \"alt+m\",\n      check: (isMetaKeyPressed, isMetaKeyPress) => isMetaKeyPress.meta && (isMetaKeyPressed === \"m\" || isMetaKeyPressed === \"M\")\n    };\n  } else {\n    ImageHandler = {\n      displayText: \"shift+tab\",\n      check: (isTabAndShiftActive, keyPressed) => keyPressed.tab && keyPressed.shift\n    };\n  }\n  if (EB() === \"windows\") {\n    setExifMergeOptions = {\n      displayText: \"alt+v\",\n      check: (isVersionCheck, isValidMetaForVersion) => isValidMetaForVersion.meta && (isVersionCheck === \"v\" || isVersionCheck === \"V\")\n    };\n  } else {\n    setExifMergeOptions = {\n      displayText: \"ctrl+v\",\n      check: (isPasteCommand, isControlVPressed) => isControlVPressed.ctrl && (isPasteCommand === \"v\" || isPasteCommand === \"V\")\n    };\n  }\n});\nfunction formatStringBasedOnType(commandModifier, commandType) {\n  switch (commandType) {\n    case \"bash\":\n      return `!${commandModifier}`;\n    case \"memorySelect\":\n      return `#${commandModifier}`;\n    case \"background\":\n      return `&${commandModifier}`;\n    default:\n      return commandModifier;\n  }\n}\nfunction getCommandType(commandPrefix) {\n  if (commandPrefix.startsWith(\"!\")) {\n    return \"bash\";\n  }\n  if (commandPrefix.startsWith(\"#\")) {\n    return \"memory\";\n  }\n  commandPrefix.startsWith(\"&\");\n  return \"prompt\";\n}\nfunction processCommand(command) {\n  if (getCommandType(command) === \"prompt\") {\n    return command;\n  }\n  return command.slice(1);\n}\nfunction isSpecialCharacter(_isSpecialCharacter) {\n  return _isSpecialCharacter === \"!\" || _isSpecialCharacter === \"#\" || false;\n}\nfunction filterOutHookProgress(_filterOutHookProgress) {\n  return _filterOutHookProgress.filter(isNotHookProgress => isNotHookProgress.data?.type !== \"hook_progress\");\n}\nvar handleImageProcessing = () => ({\n  mode: \"default\",\n  additionalWorkingDirectories: new Map(),\n  alwaysAllowRules: {},\n  alwaysDenyRules: {},\n  alwaysAskRules: {},\n  isBypassPermissionsModeAvailable: false\n});\nimport { stat as imageProcessingModule, lstat as _______imageProcessingPipeline, readdir as imageProcessingOptions, realpath as _ImageProcessingPipeline } from \"node:fs/promises\";\nimport { Readable as __imageProcessor } from \"node:stream\";\nimport { resolve as __imageProcessingHandler, relative as initializeImageProcessingModule, join as processImageOps, sep as processImageInWorkflow } from \"node:path\";\nfunction initializeFileReading(rootDirectory, fileReadOptions = {}) {\n  let _entryType = fileReadOptions.entryType || fileReadOptions.type;\n  if (_entryType === \"both\") {\n    _entryType = handleImageOutput.FILE_DIR_TYPE;\n  }\n  if (_entryType) {\n    fileReadOptions.type = _entryType;\n  }\n  if (!rootDirectory) {\n    throw Error(\"readdirp: root argument is required. Usage: readdirp(root, options)\");\n  } else if (typeof rootDirectory !== \"string\") {\n    throw TypeError(\"readdirp: root argument must be a string. Usage: readdirp(root, options)\");\n  } else if (_entryType && !initializeAndLoadImageProcessing.includes(_entryType)) {\n    throw Error(`readdirp: Invalid type passed. Use one of ${initializeAndLoadImageProcessing.join(\", \")}`);\n  }\n  fileReadOptions.root = rootDirectory;\n  return new databaseConnection(fileReadOptions);\n}\nvar handleImageOutput;\nvar maxImageSize;\nvar ________imageProcessingPipeline = \"READDIRP_RECURSIVE_ERROR\";\nvar jpegOutputFileExtensionRegex;\nvar initializeAndLoadImageProcessing;\nvar processImageConversion;\nvar NodePipeline;\nvar ____imageTransformationPipeline = jpegOutputFileExtensionRegexHasFileExtension => jpegOutputFileExtensionRegex.has(jpegOutputFileExtensionRegexHasFileExtension.code);\nvar _________imageProcessingPipeline;\nvar __ImageProcessingPipeline = __isActive => true;\nvar ___________imageTransformationProcessor = getImageProcessingFunction => {\n  if (getImageProcessingFunction === undefined) {\n    return __ImageProcessingPipeline;\n  }\n  if (typeof getImageProcessingFunction === \"function\") {\n    return getImageProcessingFunction;\n  }\n  if (typeof getImageProcessingFunction === \"string\") {\n    let trimmedBaseNames = getImageProcessingFunction.trim();\n    return basenameMatchesB => basenameMatchesB.basename === trimmedBaseNames;\n  }\n  if (Array.isArray(getImageProcessingFunction)) {\n    let _trimmedBaseNames = getImageProcessingFunction.map(stringWithWhitespaceTrimmed => stringWithWhitespaceTrimmed.trim());\n    return isBaseNameInCollection => _trimmedBaseNames.some(_isBaseNameInCollection => isBaseNameInCollection.basename === _isBaseNameInCollection);\n  }\n  return __ImageProcessingPipeline;\n};\nvar databaseConnection;\nvar _________imageProcessor = T(() => {\n  handleImageOutput = {\n    FILE_TYPE: \"files\",\n    DIR_TYPE: \"directories\",\n    FILE_DIR_TYPE: \"files_directories\",\n    EVERYTHING_TYPE: \"all\"\n  };\n  maxImageSize = {\n    root: \".\",\n    fileFilter: isActive => true,\n    directoryFilter: _isActive => true,\n    type: handleImageOutput.FILE_TYPE,\n    lstat: false,\n    depth: 2147483648,\n    alwaysStat: false,\n    highWaterMark: 4096\n  };\n  Object.freeze(maxImageSize);\n  jpegOutputFileExtensionRegex = new Set([\"ENOENT\", \"EPERM\", \"EACCES\", \"ELOOP\", ________imageProcessingPipeline]);\n  initializeAndLoadImageProcessing = [handleImageOutput.DIR_TYPE, handleImageOutput.EVERYTHING_TYPE, handleImageOutput.FILE_DIR_TYPE, handleImageOutput.FILE_TYPE];\n  processImageConversion = new Set([handleImageOutput.DIR_TYPE, handleImageOutput.EVERYTHING_TYPE, handleImageOutput.FILE_DIR_TYPE]);\n  NodePipeline = new Set([handleImageOutput.EVERYTHING_TYPE, handleImageOutput.FILE_DIR_TYPE, handleImageOutput.FILE_TYPE]);\n  _________imageProcessingPipeline = process.platform === \"win32\";\n  databaseConnection = class _ImageProcessor extends __imageProcessor {\n    constructor(_options = {}) {\n      super({\n        objectMode: true,\n        autoDestroy: true,\n        highWaterMark: _options.highWaterMark\n      });\n      let ____options = {\n        ...maxImageSize,\n        ..._options\n      };\n      let {\n        root: _rootDirectory,\n        type: imageType\n      } = ____options;\n      this._fileFilter = ___________imageTransformationProcessor(____options.fileFilter);\n      this._directoryFilter = ___________imageTransformationProcessor(____options.directoryFilter);\n      let _______imageProcessingHandler = ____options.lstat ? _______imageProcessingPipeline : imageProcessingModule;\n      if (_________imageProcessingPipeline) {\n        this._stat = generateBigInt => _______imageProcessingHandler(generateBigInt, {\n          bigint: true\n        });\n      } else {\n        this._stat = _______imageProcessingHandler;\n      }\n      this._maxDepth = ____options.depth ?? maxImageSize.depth;\n      this._wantsDir = imageType ? processImageConversion.has(imageType) : false;\n      this._wantsFile = imageType ? NodePipeline.has(imageType) : false;\n      this._wantsEverything = imageType === handleImageOutput.EVERYTHING_TYPE;\n      this._root = __imageProcessingHandler(_rootDirectory);\n      this._isDirent = !____options.alwaysStat;\n      this._statsProp = this._isDirent ? \"dirent\" : \"stats\";\n      this._rdOptions = {\n        encoding: \"utf8\",\n        withFileTypes: this._isDirent\n      };\n      this.parents = [this._exploreDir(_rootDirectory, 1)];\n      this.reading = false;\n      this.parent = undefined;\n    }\n    async _read(remainingItemsCount) {\n      if (this.reading) {\n        return;\n      }\n      this.reading = true;\n      try {\n        while (!this.destroyed && remainingItemsCount > 0) {\n          let parentDirectory = this.parent;\n          let fileList = parentDirectory && parentDirectory.files;\n          if (fileList && fileList.length > 0) {\n            let {\n              path: currentFilePath,\n              depth: directoryDepth\n            } = parentDirectory;\n            let formattedEntries = fileList.splice(0, remainingItemsCount).map(formatEntry => this._formatEntry(formatEntry, currentFilePath));\n            let _formattedEntries = await Promise.all(formattedEntries);\n            for (let formattedEntry of _formattedEntries) {\n              if (!formattedEntry) {\n                continue;\n              }\n              if (this.destroyed) {\n                return;\n              }\n              let entryType = await this._getEntryType(formattedEntry);\n              if (entryType === \"directory\" && this._directoryFilter(formattedEntry)) {\n                if (directoryDepth <= this._maxDepth) {\n                  this.parents.push(this._exploreDir(formattedEntry.fullPath, directoryDepth + 1));\n                }\n                if (this._wantsDir) {\n                  this.push(formattedEntry);\n                  remainingItemsCount--;\n                }\n              } else if ((entryType === \"file\" || this._includeAsFile(formattedEntry)) && this._fileFilter(formattedEntry)) {\n                if (this._wantsFile) {\n                  this.push(formattedEntry);\n                  remainingItemsCount--;\n                }\n              }\n            }\n          } else {\n            let filePath = this.parents.pop();\n            if (!filePath) {\n              this.push(null);\n              break;\n            }\n            this.parent = await filePath;\n            if (this.destroyed) {\n              return;\n            }\n          }\n        }\n      } catch (______________error) {\n        this.destroy(______________error);\n      } finally {\n        this.reading = false;\n      }\n    }\n    async _exploreDir(directoryPath, _directoryDepth) {\n      let ___imageProcessingResult;\n      try {\n        ___imageProcessingResult = await imageProcessingOptions(directoryPath, this._rdOptions);\n      } catch (_____________error) {\n        this._onError(_____________error);\n      }\n      return {\n        files: ___imageProcessingResult,\n        depth: _directoryDepth,\n        path: directoryPath\n      };\n    }\n    async _formatEntry(entry, imageProcessingOperations) {\n      let __formattedEntry;\n      let entryName = this._isDirent ? entry.name : entry;\n      try {\n        let processedImage = __imageProcessingHandler(processImageOps(imageProcessingOperations, entryName));\n        __formattedEntry = {\n          path: initializeImageProcessingModule(this._root, processedImage),\n          fullPath: processedImage,\n          basename: entryName\n        };\n        __formattedEntry[this._statsProp] = this._isDirent ? entry : await this._stat(processedImage);\n      } catch (____________error) {\n        this._onError(____________error);\n        return;\n      }\n      return __formattedEntry;\n    }\n    _onError(_errorObject) {\n      if (____imageTransformationPipeline(_errorObject) && !this.destroyed) {\n        this.emit(\"warn\", _errorObject);\n      } else {\n        this.destroy(_errorObject);\n      }\n    }\n    async _getEntryType(_getEntryTypeByStats) {\n      if (!_getEntryTypeByStats && this._statsProp in _getEntryTypeByStats) {\n        return \"\";\n      }\n      let entryPath = _getEntryTypeByStats[this._statsProp];\n      if (entryPath.isFile()) {\n        return \"file\";\n      }\n      if (entryPath.isDirectory()) {\n        return \"directory\";\n      }\n      if (entryPath && entryPath.isSymbolicLink()) {\n        let symbolicLinkPath = _getEntryTypeByStats.fullPath;\n        try {\n          let imageProcessingResult = await _ImageProcessingPipeline(symbolicLinkPath);\n          let processedImageEntry = await _______imageProcessingPipeline(imageProcessingResult);\n          if (processedImageEntry.isFile()) {\n            return \"file\";\n          }\n          if (processedImageEntry.isDirectory()) {\n            let lengthOfSymlinkTarget = imageProcessingResult.length;\n            if (symbolicLinkPath.startsWith(imageProcessingResult) && symbolicLinkPath.substr(lengthOfSymlinkTarget, 1) === processImageInWorkflow) {\n              let circularSymlinkError = Error(`Circular symlink detected: \"${symbolicLinkPath}\" points to \"${imageProcessingResult}\"`);\n              circularSymlinkError.code = ________imageProcessingPipeline;\n              return this._onError(circularSymlinkError);\n            }\n            return \"directory\";\n          }\n        } catch (__________error) {\n          this._onError(__________error);\n          return \"\";\n        }\n      }\n    }\n    _includeAsFile(includeFileCondition) {\n      let shouldIncludeAsFile = includeFileCondition && includeFileCondition[this._statsProp];\n      return shouldIncludeAsFile && this._wantsEverything && !shouldIncludeAsFile.isDirectory();\n    }\n  };\n});\nimport { watchFile as __________imageProcessingPipeline, unwatchFile as processAudioFile, watch as ImageProcessor } from \"fs\";\nimport { open as _processImageInput, stat as imageProcessingService, lstat as ___processImage, realpath as updateOutputFilePath } from \"fs/promises\";\nimport * as imageFormatHandler from \"path\";\nimport { type as ___imageProcessor } from \"os\";\nfunction processImageWithCallbacks(inputImagePath, imagePersistenceConfig, _____callbackFunction, __errorCallback, imageTransformationCallback) {\n  let imageCallbackHandler = (outputImagePath, _outputImagePath) => {\n    _____callbackFunction(inputImagePath);\n    imageTransformationCallback(outputImagePath, _outputImagePath, {\n      watchedPath: inputImagePath\n    });\n    if (_outputImagePath && inputImagePath !== _outputImagePath) {\n      imageProcessingWorkflow(imageFormatHandler.resolve(inputImagePath, _outputImagePath), _imageTransformationProcessor, imageFormatHandler.join(inputImagePath, _outputImagePath));\n    }\n  };\n  try {\n    return ImageProcessor(inputImagePath, {\n      persistent: imagePersistenceConfig.persistent\n    }, imageCallbackHandler);\n  } catch (______________________________error) {\n    __errorCallback(______________________________error);\n    return;\n  }\n}\nclass ImageFileWatcher {\n  constructor(fileSystemWatcher) {\n    this.fsw = fileSystemWatcher;\n    this._boundHandleError = errorHandlingFunction => fileSystemWatcher._handleError(errorHandlingFunction);\n  }\n  _watchWithNodeFs(watchWithNodeFileSystem, imageProcessingListener) {\n    let _____options = this.fsw.options;\n    let _imageDirectory = imageFormatHandler.dirname(watchWithNodeFileSystem);\n    let baseFilename = imageFormatHandler.basename(watchWithNodeFileSystem);\n    this.fsw._getWatchedDir(_imageDirectory).add(baseFilename);\n    let resolvedImagePath = imageFormatHandler.resolve(watchWithNodeFileSystem);\n    let watchOptions = {\n      persistent: _____options.persistent\n    };\n    if (!imageProcessingListener) {\n      imageProcessingListener = imagePipeline;\n    }\n    let transformationProcess;\n    if (_____options.usePolling) {\n      let isIntervalBinaryDifferent = _____options.interval !== _____options.binaryInterval;\n      watchOptions.interval = isIntervalBinaryDifferent && processImageOutputHandler(baseFilename) ? _____options.binaryInterval : _____options.interval;\n      transformationProcess = __processImageTransformationHandler(watchWithNodeFileSystem, resolvedImagePath, watchOptions, {\n        listener: imageProcessingListener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      transformationProcess = ____________________imageProcessingPipeline(watchWithNodeFileSystem, resolvedImagePath, watchOptions, {\n        listener: imageProcessingListener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n    return transformationProcess;\n  }\n  _handleFile(_handleFileChange, __imageMetadata, initialFileMetadata) {\n    if (this.fsw.closed) {\n      return;\n    }\n    let imageDirectory = imageFormatHandler.dirname(_handleFileChange);\n    let imageBaseName = imageFormatHandler.basename(_handleFileChange);\n    let watchedDirectory = this.fsw._getWatchedDir(imageDirectory);\n    let ___imageMetadata = __imageMetadata;\n    if (watchedDirectory.has(imageBaseName)) {\n      return;\n    }\n    let __handleImageProcessing = async (imageFileHandle, imageMetadata) => {\n      if (!this.fsw._throttle(imageTransformationProcessor, _handleFileChange, 5)) {\n        return;\n      }\n      if (!imageMetadata || imageMetadata.mtimeMs === 0) {\n        try {\n          let processedImageMetadata = await imageProcessingService(_handleFileChange);\n          if (this.fsw.closed) {\n            return;\n          }\n          let {\n            atimeMs: lastAccessTimeMs,\n            mtimeMs: mtimeMsUpdated\n          } = processedImageMetadata;\n          if (!lastAccessTimeMs || lastAccessTimeMs <= mtimeMsUpdated || mtimeMsUpdated !== ___imageMetadata.mtimeMs) {\n            this.fsw._emit(____________imageProcessingPipeline.CHANGE, _handleFileChange, processedImageMetadata);\n          }\n          if ((_processImageTransformation || __processImageTransformation || updateImageOutputFormat) && ___imageMetadata.ino !== processedImageMetadata.ino) {\n            this.fsw._closeFile(imageFileHandle);\n            ___imageMetadata = processedImageMetadata;\n            let imageWatcher = this._watchWithNodeFs(_handleFileChange, __handleImageProcessing);\n            if (imageWatcher) {\n              this.fsw._addPathCloser(imageFileHandle, imageWatcher);\n            }\n          } else {\n            ___imageMetadata = processedImageMetadata;\n          }\n        } catch (exceptionHandler) {\n          this.fsw._remove(imageDirectory, imageBaseName);\n        }\n      } else if (watchedDirectory.has(imageBaseName)) {\n        let {\n          atimeMs: __lastAccessTimeMs,\n          mtimeMs: modifiedTimeMs\n        } = imageMetadata;\n        if (!__lastAccessTimeMs || __lastAccessTimeMs <= modifiedTimeMs || modifiedTimeMs !== ___imageMetadata.mtimeMs) {\n          this.fsw._emit(____________imageProcessingPipeline.CHANGE, _handleFileChange, imageMetadata);\n        }\n        ___imageMetadata = imageMetadata;\n      }\n    };\n    let imageWatcherHandle = this._watchWithNodeFs(_handleFileChange, __handleImageProcessing);\n    if ((!initialFileMetadata || !this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(_handleFileChange)) {\n      if (!this.fsw._throttle(____________imageProcessingPipeline.ADD, _handleFileChange, 0)) {\n        return;\n      }\n      this.fsw._emit(____________imageProcessingPipeline.ADD, _handleFileChange, __imageMetadata);\n    }\n    return imageWatcherHandle;\n  }\n  async _handleSymlink(_handleSymlink, targetFilePath, symlinkFilePath, symlinkIdentifier) {\n    if (this.fsw.closed) {\n      return;\n    }\n    let symlinkFullPath = _handleSymlink.fullPath;\n    let __watchedDirectory = this.fsw._getWatchedDir(targetFilePath);\n    if (!this.fsw.options.followSymlinks) {\n      this.fsw._incrReadyCount();\n      let updatedFilePath;\n      try {\n        updatedFilePath = await updateOutputFilePath(symlinkFilePath);\n      } catch (_________error) {\n        this.fsw._emitReady();\n        return true;\n      }\n      if (this.fsw.closed) {\n        return;\n      }\n      if (__watchedDirectory.has(symlinkIdentifier)) {\n        if (this.fsw._symlinkPaths.get(symlinkFullPath) !== updatedFilePath) {\n          this.fsw._symlinkPaths.set(symlinkFullPath, updatedFilePath);\n          this.fsw._emit(____________imageProcessingPipeline.CHANGE, symlinkFilePath, _handleSymlink.stats);\n        }\n      } else {\n        __watchedDirectory.add(symlinkIdentifier);\n        this.fsw._symlinkPaths.set(symlinkFullPath, updatedFilePath);\n        this.fsw._emit(____________imageProcessingPipeline.ADD, symlinkFilePath, _handleSymlink.stats);\n      }\n      this.fsw._emitReady();\n      return true;\n    }\n    if (this.fsw._symlinkPaths.has(symlinkFullPath)) {\n      return true;\n    }\n    this.fsw._symlinkPaths.set(symlinkFullPath, true);\n  }\n  _handleRead(handleImageDirectoryRead, imageFileReadHandler, directoryWatcher, currentPath, sourceImagePath, currentFileCount, throttledReadDirectory) {\n    handleImageDirectoryRead = imageFormatHandler.join(handleImageDirectoryRead, \"\");\n    throttledReadDirectory = this.fsw._throttle(\"readdir\", handleImageDirectoryRead, 1000);\n    if (!throttledReadDirectory) {\n      return;\n    }\n    let _watchedDirectory = this.fsw._getWatchedDir(directoryWatcher.path);\n    let processedFileSet = new Set();\n    let ________imageProcessor = this.fsw._readdirp(handleImageDirectoryRead, {\n      fileFilter: filterPath => directoryWatcher.filterPath(filterPath),\n      directoryFilter: filterDirectory => directoryWatcher.filterDir(filterDirectory)\n    });\n    if (!________imageProcessor) {\n      return;\n    }\n    ________imageProcessor.on(____imageProcessor, async handleFileEvent => {\n      if (this.fsw.closed) {\n        ________imageProcessor = undefined;\n        return;\n      }\n      let __filePath = handleFileEvent.path;\n      let imageFilePath = imageFormatHandler.join(handleImageDirectoryRead, __filePath);\n      processedFileSet.add(__filePath);\n      if (handleFileEvent.stats.isSymbolicLink() && (await this._handleSymlink(handleFileEvent, handleImageDirectoryRead, imageFilePath, __filePath))) {\n        return;\n      }\n      if (this.fsw.closed) {\n        ________imageProcessor = undefined;\n        return;\n      }\n      if (__filePath === currentPath || !currentPath && !_watchedDirectory.has(__filePath)) {\n        this.fsw._incrReadyCount();\n        imageFilePath = imageFormatHandler.join(sourceImagePath, imageFormatHandler.relative(sourceImagePath, imageFilePath));\n        this._addToNodeFs(imageFilePath, imageFileReadHandler, directoryWatcher, currentFileCount + 1);\n      }\n    }).on(____________imageProcessingPipeline.ERROR, this._boundHandleError);\n    return new Promise((____processImage, _____processImage) => {\n      if (!________imageProcessor) {\n        return _____processImage();\n      }\n      ________imageProcessor.once(sharpImageProcessing, () => {\n        if (this.fsw.closed) {\n          ________imageProcessor = undefined;\n          return;\n        }\n        let isYClear = throttledReadDirectory ? throttledReadDirectory.clear() : false;\n        ____processImage(undefined);\n        _watchedDirectory.getChildren().filter(isValidKey => {\n          return isValidKey !== handleImageDirectoryRead && !processedFileSet.has(isValidKey);\n        }).forEach(_________callbackFunction => {\n          this.fsw._remove(handleImageDirectoryRead, _________callbackFunction);\n        });\n        ________imageProcessor = undefined;\n        if (isYClear) {\n          this._handleRead(handleImageDirectoryRead, false, directoryWatcher, currentPath, sourceImagePath, currentFileCount, throttledReadDirectory);\n        }\n      });\n    });\n  }\n  async _handleDir(_handleDirectoryProcessing, ____imagePath, previouslyProcessedDirectory, currentDepth, isDirectoryProcessed, imageProcessCallback, symlinkPath) {\n    let ___watchedDirectory = this.fsw._getWatchedDir(imageFormatHandler.dirname(_handleDirectoryProcessing));\n    let isFileAlreadyWatched = ___watchedDirectory.has(imageFormatHandler.basename(_handleDirectoryProcessing));\n    if ((!previouslyProcessedDirectory || !this.fsw.options.ignoreInitial) && !isDirectoryProcessed && !isFileAlreadyWatched) {\n      this.fsw._emit(____________imageProcessingPipeline.ADD_DIR, _handleDirectoryProcessing, ____imagePath);\n    }\n    ___watchedDirectory.add(imageFormatHandler.basename(_handleDirectoryProcessing));\n    this.fsw._getWatchedDir(_handleDirectoryProcessing);\n    let watchCallback;\n    let fileWatcherHandle;\n    let maxDirectoryDepth = this.fsw.options.depth;\n    if ((maxDirectoryDepth == null || currentDepth <= maxDirectoryDepth) && !this.fsw._symlinkPaths.has(symlinkPath)) {\n      if (!isDirectoryProcessed) {\n        await this._handleRead(_handleDirectoryProcessing, previouslyProcessedDirectory, imageProcessCallback, isDirectoryProcessed, _handleDirectoryProcessing, currentDepth, watchCallback);\n        if (this.fsw.closed) {\n          return;\n        }\n      }\n      fileWatcherHandle = this._watchWithNodeFs(_handleDirectoryProcessing, (___filePath, fileMetadata) => {\n        if (fileMetadata && fileMetadata.mtimeMs === 0) {\n          return;\n        }\n        this._handleRead(___filePath, false, imageProcessCallback, isDirectoryProcessed, _handleDirectoryProcessing, currentDepth, watchCallback);\n      });\n    }\n    return fileWatcherHandle;\n  }\n  async _addToNodeFs(_____filePath, __imageProcessingCallback, imageFilters, outputHandler, imageHandler) {\n    let emitReadySignal = this.fsw._emitReady;\n    if (this.fsw._isIgnored(_____filePath) || this.fsw.closed) {\n      emitReadySignal();\n      return false;\n    }\n    let watchHelpers = this.fsw._getWatchHelpers(_____filePath);\n    if (imageFilters) {\n      watchHelpers.filterPath = _filterPath => imageFilters.filterPath(_filterPath);\n      watchHelpers.filterDir = directoryFilter => imageFilters.filterDir(directoryFilter);\n    }\n    try {\n      let imageValidationResult = await validateImageOutputOptions[watchHelpers.statMethod](watchHelpers.watchPath);\n      if (this.fsw.closed) {\n        return;\n      }\n      if (this.fsw._isIgnored(watchHelpers.watchPath, imageValidationResult)) {\n        emitReadySignal();\n        return false;\n      }\n      let shouldFollowSymlinks = this.fsw.options.followSymlinks;\n      let outputResult;\n      if (imageValidationResult.isDirectory()) {\n        let resolvedImageFormat = imageFormatHandler.resolve(_____filePath);\n        let _outputFilePath = shouldFollowSymlinks ? await updateOutputFilePath(_____filePath) : _____filePath;\n        if (this.fsw.closed) {\n          return;\n        }\n        outputResult = await this._handleDir(watchHelpers.watchPath, imageValidationResult, __imageProcessingCallback, outputHandler, imageHandler, watchHelpers, _outputFilePath);\n        if (this.fsw.closed) {\n          return;\n        }\n        if (resolvedImageFormat !== _outputFilePath && _outputFilePath !== undefined) {\n          this.fsw._symlinkPaths.set(resolvedImageFormat, _outputFilePath);\n        }\n      } else if (imageValidationResult.isSymbolicLink()) {\n        let resolveImageFormat = shouldFollowSymlinks ? await updateOutputFilePath(_____filePath) : _____filePath;\n        if (this.fsw.closed) {\n          return;\n        }\n        let __outputFilePath = imageFormatHandler.dirname(watchHelpers.watchPath);\n        this.fsw._getWatchedDir(__outputFilePath).add(watchHelpers.watchPath);\n        this.fsw._emit(____________imageProcessingPipeline.ADD, watchHelpers.watchPath, imageValidationResult);\n        outputResult = await this._handleDir(__outputFilePath, imageValidationResult, __imageProcessingCallback, outputHandler, _____filePath, watchHelpers, resolveImageFormat);\n        if (this.fsw.closed) {\n          return;\n        }\n        if (resolveImageFormat !== undefined) {\n          this.fsw._symlinkPaths.set(imageFormatHandler.resolve(_____filePath), resolveImageFormat);\n        }\n      } else {\n        outputResult = this._handleFile(watchHelpers.watchPath, imageValidationResult, __imageProcessingCallback);\n      }\n      emitReadySignal();\n      if (outputResult) {\n        this.fsw._addPathCloser(_____filePath, outputResult);\n      }\n      return false;\n    } catch (_______error) {\n      if (this.fsw._handleError(_______error)) {\n        emitReadySignal();\n        return _____filePath;\n      }\n    }\n  }\n}\nvar ____imageProcessor = \"data\";\nvar sharpImageProcessing = \"end\";\nvar _imageProcessingOptions = \"close\";\nvar imagePipeline = () => {};\nvar ImageTransformProcessor;\nvar _validateOutputFilePath;\nvar _processImageTransformation;\nvar __processImageTransformation;\nvar updateImageOutputFormat;\nvar ___processImageTransformation;\nvar ___________imageProcessingPipeline;\nvar ____________imageProcessingPipeline;\nvar imageTransformationProcessor = \"watch\";\nvar validateImageOutputOptions;\nvar _imageTransformationProcessor = \"listeners\";\nvar ____processImageTransformation = \"errHandlers\";\nvar _____imageProcessor = \"rawEmitters\";\nvar _____processImageTransformation;\nvar __validateOutputFilePath;\nvar processImageOutputHandler = outputFilePathValidation => __validateOutputFilePath.has(imageFormatHandler.extname(outputFilePathValidation).slice(1).toLowerCase());\nvar initializeImageProcessing = (processSetOrValue, ____________callbackFunction) => {\n  if (processSetOrValue instanceof Set) {\n    processSetOrValue.forEach(____________callbackFunction);\n  } else {\n    ____________callbackFunction(processSetOrValue);\n  }\n};\nvar ______processImageTransformation = (updateSetWithValue, updateSetForKey, elementToAdd) => {\n  let itemSet = updateSetWithValue[updateSetForKey];\n  if (!(itemSet instanceof Set)) {\n    updateSetWithValue[updateSetForKey] = itemSet = new Set([itemSet]);\n  }\n  itemSet.add(elementToAdd);\n};\nvar _______processImageTransformation = clearOrDeleteProperty => clearOrDeletePropertyByKey => {\n  let propertyValue = clearOrDeleteProperty[clearOrDeletePropertyByKey];\n  if (propertyValue instanceof Set) {\n    propertyValue.clear();\n  } else {\n    delete clearOrDeleteProperty[clearOrDeletePropertyByKey];\n  }\n};\nvar imageTransformationPipeline = (removeItemFromSetOrDeleteKey, removeItemFromCollection, itemToDelete) => {\n  let itemOrSet = removeItemFromSetOrDeleteKey[removeItemFromCollection];\n  if (itemOrSet instanceof Set) {\n    itemOrSet.delete(itemToDelete);\n  } else if (itemOrSet === itemToDelete) {\n    delete removeItemFromSetOrDeleteKey[removeItemFromCollection];\n  }\n};\nvar ________processImageTransformation = isSetEmptyOrFalsy => isSetEmptyOrFalsy instanceof Set ? isSetEmptyOrFalsy.size === 0 : !isSetEmptyOrFalsy;\nvar _processImageTransformations;\nvar imageProcessingWorkflow = (__imageTransformation, imageTransformationKey, _imageProcessingCallback, __________imageProcessor, ___callback) => {\n  let transformedImage = _processImageTransformations.get(__imageTransformation);\n  if (!transformedImage) {\n    return;\n  }\n  initializeImageProcessing(transformedImage[imageTransformationKey], processImageUsingCallback => {\n    processImageUsingCallback(_imageProcessingCallback, __________imageProcessor, ___callback);\n  });\n};\nvar ____________________imageProcessingPipeline = (processImageAndHandleTransformations, _imageTransformationKey, __imageProcessingOptions, ____imageTransformationHandler) => {\n  let {\n    listener: imageListener,\n    errHandler: __________errorHandler,\n    rawEmitter: rawImageEmitter\n  } = ____imageTransformationHandler;\n  let imageTransformationHandlers = _processImageTransformations.get(_imageTransformationKey);\n  let imageProcessingWatcher;\n  if (!__imageProcessingOptions.persistent) {\n    imageProcessingWatcher = processImageWithCallbacks(processImageAndHandleTransformations, __imageProcessingOptions, imageListener, __________errorHandler, rawImageEmitter);\n    if (!imageProcessingWatcher) {\n      return;\n    }\n    return imageProcessingWatcher.close.bind(imageProcessingWatcher);\n  }\n  if (imageTransformationHandlers) {\n    ______processImageTransformation(imageTransformationHandlers, _imageTransformationProcessor, imageListener);\n    ______processImageTransformation(imageTransformationHandlers, ____processImageTransformation, __________errorHandler);\n    ______processImageTransformation(imageTransformationHandlers, _____imageProcessor, rawImageEmitter);\n  } else {\n    imageProcessingWatcher = processImageWithCallbacks(processImageAndHandleTransformations, __imageProcessingOptions, imageProcessingWorkflow.bind(null, _imageTransformationKey, _imageTransformationProcessor), __________errorHandler, imageProcessingWorkflow.bind(null, _imageTransformationKey, _____imageProcessor));\n    if (!imageProcessingWatcher) {\n      return;\n    }\n    imageProcessingWatcher.on(____________imageProcessingPipeline.ERROR, async ____________________________________processImageTransformation => {\n      let _____________________________________processImageTransformation = imageProcessingWorkflow.bind(null, _imageTransformationKey, ____processImageTransformation);\n      if (imageTransformationHandlers) {\n        imageTransformationHandlers.watcherUnusable = true;\n      }\n      if (_validateOutputFilePath && ____________________________________processImageTransformation.code === \"EPERM\") {\n        try {\n          await (await _processImageInput(processImageAndHandleTransformations, \"r\")).close();\n          _____________________________________processImageTransformation(____________________________________processImageTransformation);\n        } catch (__________________error) {}\n      } else {\n        _____________________________________processImageTransformation(____________________________________processImageTransformation);\n      }\n    });\n    imageTransformationHandlers = {\n      listeners: imageListener,\n      errHandlers: __________errorHandler,\n      rawEmitters: rawImageEmitter,\n      watcher: imageProcessingWatcher\n    };\n    _processImageTransformations.set(_imageTransformationKey, imageTransformationHandlers);\n  }\n  return () => {\n    imageTransformationPipeline(imageTransformationHandlers, _imageTransformationProcessor, imageListener);\n    imageTransformationPipeline(imageTransformationHandlers, ____processImageTransformation, __________errorHandler);\n    imageTransformationPipeline(imageTransformationHandlers, _____imageProcessor, rawImageEmitter);\n    if (________processImageTransformation(imageTransformationHandlers.listeners)) {\n      imageTransformationHandlers.watcher.close();\n      _processImageTransformations.delete(_imageTransformationKey);\n      _____processImageTransformation.forEach(_______processImageTransformation(imageTransformationHandlers));\n      imageTransformationHandlers.watcher = undefined;\n      Object.freeze(imageTransformationHandlers);\n    }\n  };\n};\nvar _imageTransformationPipeline;\nvar __processImageTransformationHandler = (_____imageProcessingHandler, _imageSource, imageTransformationOptions, imageTransformationData) => {\n  let {\n    listener: imageTransformationListeners,\n    rawEmitter: rawAudioEmitter\n  } = imageTransformationData;\n  let _imageTransformationData = _imageTransformationPipeline.get(_imageSource);\n  let ___options = _imageTransformationData && _imageTransformationData.options;\n  if (___options && (___options.persistent < imageTransformationOptions.persistent || ___options.interval > imageTransformationOptions.interval)) {\n    processAudioFile(_imageSource);\n    _imageTransformationData = undefined;\n  }\n  if (_imageTransformationData) {\n    ______processImageTransformation(_imageTransformationData, _imageTransformationProcessor, imageTransformationListeners);\n    ______processImageTransformation(_imageTransformationData, _____imageProcessor, rawAudioEmitter);\n  } else {\n    _imageTransformationData = {\n      listeners: imageTransformationListeners,\n      rawEmitters: rawAudioEmitter,\n      options: imageTransformationOptions,\n      watcher: __________imageProcessingPipeline(_imageSource, imageTransformationOptions, (currentImage, previousImage) => {\n        initializeImageProcessing(_imageTransformationData.rawEmitters, dispatchImageChangeEvent => {\n          dispatchImageChangeEvent(____________imageProcessingPipeline.CHANGE, _imageSource, {\n            curr: currentImage,\n            prev: previousImage\n          });\n        });\n        let currentImageModificationTime = currentImage.mtimeMs;\n        if (currentImage.size !== previousImage.size || currentImageModificationTime > previousImage.mtimeMs || currentImageModificationTime === 0) {\n          initializeImageProcessing(_imageTransformationData.listeners, _______processImage => _______processImage(_____imageProcessingHandler, currentImage));\n        }\n      })\n    };\n    _imageTransformationPipeline.set(_imageSource, _imageTransformationData);\n  }\n  return () => {\n    imageTransformationPipeline(_imageTransformationData, _imageTransformationProcessor, imageTransformationListeners);\n    imageTransformationPipeline(_imageTransformationData, _____imageProcessor, rawAudioEmitter);\n    if (________processImageTransformation(_imageTransformationData.listeners)) {\n      _imageTransformationPipeline.delete(_imageSource);\n      processAudioFile(_imageSource);\n      _imageTransformationData.options = _imageTransformationData.watcher = undefined;\n      Object.freeze(_imageTransformationData);\n    }\n  };\n};\nvar _______________________________________processImageTransformation = T(() => {\n  ImageTransformProcessor = process.platform;\n  _validateOutputFilePath = ImageTransformProcessor === \"win32\";\n  _processImageTransformation = ImageTransformProcessor === \"darwin\";\n  __processImageTransformation = ImageTransformProcessor === \"linux\";\n  updateImageOutputFormat = ImageTransformProcessor === \"freebsd\";\n  ___processImageTransformation = ___imageProcessor() === \"OS400\";\n  ___________imageProcessingPipeline = {\n    ALL: \"all\",\n    READY: \"ready\",\n    ADD: \"add\",\n    CHANGE: \"change\",\n    ADD_DIR: \"addDir\",\n    UNLINK: \"unlink\",\n    UNLINK_DIR: \"unlinkDir\",\n    RAW: \"raw\",\n    ERROR: \"error\"\n  };\n  ____________imageProcessingPipeline = ___________imageProcessingPipeline;\n  validateImageOutputOptions = {\n    lstat: ___processImage,\n    stat: imageProcessingService\n  };\n  _____processImageTransformation = [_imageTransformationProcessor, ____processImageTransformation, _____imageProcessor];\n  __validateOutputFilePath = new Set([\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"afdesign\", \"afphoto\", \"afpub\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"]);\n  _processImageTransformations = new Map();\n  _imageTransformationPipeline = new Map();\n});\nimport { stat as _____________imageProcessingPipeline } from \"fs\";\nimport { stat as _________processImageTransformation, readdir as processImageTransformationHandler } from \"fs/promises\";\nimport { EventEmitter as __________processImageTransformation } from \"events\";\nimport * as _updateImageFormatBasedOnOptions from \"path\";\nfunction ensureArray(wrapInArray) {\n  if (Array.isArray(wrapInArray)) {\n    return wrapInArray;\n  } else {\n    return [wrapInArray];\n  }\n}\nfunction createMatcherFunction(createMatcher) {\n  if (typeof createMatcher === \"function\") {\n    return createMatcher;\n  }\n  if (typeof createMatcher === \"string\") {\n    return _createMatcher => createMatcher === _createMatcher;\n  }\n  if (createMatcher instanceof RegExp) {\n    return ___inputValue => createMatcher.test(___inputValue);\n  }\n  if (typeof createMatcher === \"object\" && createMatcher !== null) {\n    return matchedPath => {\n      if (createMatcher.path === matchedPath) {\n        return true;\n      }\n      if (createMatcher.recursive) {\n        let resolvedPath = _updateImageFormatBasedOnOptions.relative(createMatcher.path, matchedPath);\n        if (!resolvedPath) {\n          return false;\n        }\n        return !resolvedPath.startsWith(\"..\") && !_updateImageFormatBasedOnOptions.isAbsolute(resolvedPath);\n      }\n      return false;\n    };\n  }\n  return () => false;\n}\nfunction normalizeImagePath(updateImagePath) {\n  if (typeof updateImagePath !== \"string\") {\n    throw Error(\"string expected\");\n  }\n  updateImagePath = _updateImageFormatBasedOnOptions.normalize(updateImagePath);\n  updateImagePath = updateImagePath.replace(/\\\\/g, \"/\");\n  let isPathStartWithDoubleSlash = false;\n  if (updateImagePath.startsWith(\"//\")) {\n    isPathStartWithDoubleSlash = true;\n  }\n  let doubleSlashRegex = /\\/\\//;\n  while (updateImagePath.match(doubleSlashRegex)) {\n    updateImagePath = updateImagePath.replace(doubleSlashRegex, \"/\");\n  }\n  if (isPathStartWithDoubleSlash) {\n    updateImagePath = \"/\" + updateImagePath;\n  }\n  return updateImagePath;\n}\nfunction checkImageWithPredicates(predicateFunction, ______callbackFunction, _______callbackFunction) {\n  let normalizedImagePath = normalizeImagePath(______callbackFunction);\n  for (let predicateIndex = 0; predicateIndex < predicateFunction.length; predicateIndex++) {\n    let currentPredicate = predicateFunction[predicateIndex];\n    if (currentPredicate(normalizedImagePath, _______callbackFunction)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction createMatcherChain(inputArray, matchFunction) {\n  if (inputArray == null) {\n    throw TypeError(\"anymatch: specify first argument\");\n  }\n  let matcherFunctions = ensureArray(inputArray).map(_createMatcherFunction => createMatcherFunction(_createMatcherFunction));\n  if (matchFunction == null) {\n    return (_processData, __________callbackFunction) => {\n      return checkImageWithPredicates(matcherFunctions, _processData, __________callbackFunction);\n    };\n  }\n  return checkImageWithPredicates(matcherFunctions, matchFunction);\n}\nclass ImageTransformationWatcher {\n  constructor(pathValue, removeWatcherCallback) {\n    this.path = pathValue;\n    this._removeWatcher = removeWatcherCallback;\n    this.items = new Set();\n  }\n  add(newImageTransformation) {\n    let {\n      items: itemsCollection\n    } = this;\n    if (!itemsCollection) {\n      return;\n    }\n    if (newImageTransformation !== ____________processImageTransformation && newImageTransformation !== __imageTransformationProcessor) {\n      itemsCollection.add(newImageTransformation);\n    }\n  }\n  async remove(imageToRemove) {\n    let {\n      items: imageCollection\n    } = this;\n    if (!imageCollection) {\n      return;\n    }\n    imageCollection.delete(imageToRemove);\n    if (imageCollection.size > 0) {\n      return;\n    }\n    let ___imagePath = this.path;\n    try {\n      await processImageTransformationHandler(___imagePath);\n    } catch (______error) {\n      if (this._removeWatcher) {\n        this._removeWatcher(_updateImageFormatBasedOnOptions.dirname(___imagePath), _updateImageFormatBasedOnOptions.basename(___imagePath));\n      }\n    }\n  }\n  has(itemExists) {\n    let {\n      items: __itemsCollection\n    } = this;\n    if (!__itemsCollection) {\n      return;\n    }\n    return __itemsCollection.has(itemExists);\n  }\n  getChildren() {\n    let {\n      items: _itemsCollection\n    } = this;\n    if (!_itemsCollection) {\n      return [];\n    }\n    return [..._itemsCollection.values()];\n  }\n  dispose() {\n    this.items.clear();\n    this.path = \"\";\n    this._removeWatcher = imagePipeline;\n    this.items = _______________processImageTransformation;\n    Object.freeze(this);\n  }\n}\nclass ImageWatcher {\n  constructor(__imagePath, _shouldFollowSymlinks, ______imageProcessingHandler) {\n    this.fsw = ______imageProcessingHandler;\n    let originalImagePath = __imagePath;\n    this.path = __imagePath = __imagePath.replace(imageFileProcessor, \"\");\n    this.watchPath = originalImagePath;\n    this.fullWatchPath = _updateImageFormatBasedOnOptions.resolve(originalImagePath);\n    this.dirParts = [];\n    this.dirParts.forEach(removeLastElementIfMoreThanOne => {\n      if (removeLastElementIfMoreThanOne.length > 1) {\n        removeLastElementIfMoreThanOne.pop();\n      }\n    });\n    this.followSymlinks = _shouldFollowSymlinks;\n    this.statMethod = _shouldFollowSymlinks ? ________________processImageTransformation : _________________processImageTransformation;\n  }\n  entryPath(entryFullPath) {\n    return _updateImageFormatBasedOnOptions.join(this.watchPath, _updateImageFormatBasedOnOptions.relative(this.watchPath, entryFullPath.fullPath));\n  }\n  filterPath(filterFilePath) {\n    let {\n      stats: _fileStats\n    } = filterFilePath;\n    if (_fileStats && _fileStats.isSymbolicLink()) {\n      return this.filterDir(filterFilePath);\n    }\n    let entryPathValue = this.entryPath(filterFilePath);\n    return this.fsw._isntIgnored(entryPathValue, _fileStats) && this.fsw._hasReadPermissions(_fileStats);\n  }\n  filterDir(filterIgnoredDirectory) {\n    return this.fsw._isntIgnored(this.entryPath(filterIgnoredDirectory), filterIgnoredDirectory.stats);\n  }\n}\nfunction applyImageTransformation(_imageTransformation, _imageTransformationOptions = {}) {\n  let imageTransformationQueue = new __________________processImageTransformation(_imageTransformationOptions);\n  imageTransformationQueue.add(_imageTransformation);\n  return imageTransformationQueue;\n}\nvar ___________processImageTransformation = \"/\";\nvar isJPEG2000Format = \"//\";\nvar ____________processImageTransformation = \".\";\nvar __imageTransformationProcessor = \"..\";\nvar _____________processImageTransformation = \"string\";\nvar validateImageOutputSettings;\nvar __imageTransformationPipeline;\nvar ______________imageProcessingPipeline;\nvar imageFileProcessor;\nvar ______________processImageTransformation = isValidObject => typeof isValidObject === \"object\" && isValidObject !== null && !(isValidObject instanceof RegExp);\nvar __________________________imageTransformationProcessor = transformImagePaths => {\n  let imageTransformationPaths = ensureArray(transformImagePaths).flat();\n  if (!imageTransformationPaths.every(_______________________________________________________processImageTransformation => typeof _______________________________________________________processImageTransformation === _____________processImageTransformation)) {\n    throw TypeError(`Non-string provided as watch path: ${imageTransformationPaths}`);\n  }\n  return imageTransformationPaths.map(__________________imageProcessingPipeline);\n};\nvar ____________imageTransformationProcessor = transformImageOutputSettings => {\n  let transformedImageSettings = transformImageOutputSettings.replace(validateImageOutputSettings, ___________processImageTransformation);\n  let isJPEG2000FormatDetected = false;\n  if (transformedImageSettings.startsWith(isJPEG2000Format)) {\n    isJPEG2000FormatDetected = true;\n  }\n  while (transformedImageSettings.match(__imageTransformationPipeline)) {\n    transformedImageSettings = transformedImageSettings.replace(__imageTransformationPipeline, ___________processImageTransformation);\n  }\n  if (isJPEG2000FormatDetected) {\n    transformedImageSettings = ___________processImageTransformation + transformedImageSettings;\n  }\n  return transformedImageSettings;\n};\nvar __________________imageProcessingPipeline = ____________________________imageTransformationProcessor => ____________imageTransformationProcessor(_updateImageFormatBasedOnOptions.normalize(____________imageTransformationProcessor(____________________________imageTransformationProcessor)));\nvar ____________imageProcessor = (imageUrlGenerator = \"\") => processImageIdentifier => {\n  if (typeof processImageIdentifier === \"string\") {\n    return __________________imageProcessingPipeline(_updateImageFormatBasedOnOptions.isAbsolute(processImageIdentifier) ? processImageIdentifier : _updateImageFormatBasedOnOptions.join(imageUrlGenerator, processImageIdentifier));\n  } else {\n    return processImageIdentifier;\n  }\n};\nvar _____________imageTransformationProcessor = (imagePathOrFormat, baseImagePath) => {\n  if (_updateImageFormatBasedOnOptions.isAbsolute(imagePathOrFormat)) {\n    return imagePathOrFormat;\n  }\n  return _updateImageFormatBasedOnOptions.join(baseImagePath, imagePathOrFormat);\n};\nvar _______________processImageTransformation;\nvar ________________processImageTransformation = \"stat\";\nvar _________________processImageTransformation = \"lstat\";\nvar __________________processImageTransformation;\nvar ___________________processImageTransformation;\nvar ________imageProcessingHandler = T(() => {\n  _________imageProcessor();\n  _______________________________________processImageTransformation();\n  validateImageOutputSettings = /\\\\/g;\n  __imageTransformationPipeline = /\\/\\//;\n  ______________imageProcessingPipeline = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  imageFileProcessor = /^\\.[/\\\\]/;\n  _______________processImageTransformation = Object.freeze(new Set());\n  __________________processImageTransformation = class __ImageTransformationProcessor extends __________processImageTransformation {\n    constructor(options = {}) {\n      super();\n      this.closed = false;\n      this._closers = new Map();\n      this._ignoredPaths = new Set();\n      this._throttled = new Map();\n      this._streams = new Set();\n      this._symlinkPaths = new Map();\n      this._watched = new Map();\n      this._pendingWrites = new Map();\n      this._pendingUnlinks = new Map();\n      this._readyCount = 0;\n      this._readyEmitted = false;\n      let awaitWriteFinishSetting = options.awaitWriteFinish;\n      let writeFinishOptions = {\n        stabilityThreshold: 2000,\n        pollInterval: 100\n      };\n      let ___optionsConfig = {\n        persistent: true,\n        ignoreInitial: false,\n        ignorePermissionErrors: false,\n        interval: 100,\n        binaryInterval: 300,\n        followSymlinks: true,\n        usePolling: false,\n        atomic: true,\n        ...options,\n        ignored: options.ignored ? ensureArray(options.ignored) : ensureArray([]),\n        awaitWriteFinish: awaitWriteFinishSetting === true ? writeFinishOptions : typeof awaitWriteFinishSetting === \"object\" ? {\n          ...writeFinishOptions,\n          ...awaitWriteFinishSetting\n        } : false\n      };\n      if (___processImageTransformation) {\n        ___optionsConfig.usePolling = true;\n      }\n      if (___optionsConfig.atomic === undefined) {\n        ___optionsConfig.atomic = !___optionsConfig.usePolling;\n      }\n      let _environmentPollingSetting = process.env.CHOKIDAR_USEPOLLING;\n      if (_environmentPollingSetting !== undefined) {\n        let environmentPollingSetting = _environmentPollingSetting.toLowerCase();\n        if (environmentPollingSetting === \"false\" || environmentPollingSetting === \"0\") {\n          ___optionsConfig.usePolling = false;\n        } else if (environmentPollingSetting === \"true\" || environmentPollingSetting === \"1\") {\n          ___optionsConfig.usePolling = true;\n        } else {\n          ___optionsConfig.usePolling = !!environmentPollingSetting;\n        }\n      }\n      let chokidarInterval = process.env.CHOKIDAR_INTERVAL;\n      if (chokidarInterval) {\n        ___optionsConfig.interval = Number.parseInt(chokidarInterval, 10);\n      }\n      let readyCounter = 0;\n      this._emitReady = () => {\n        readyCounter++;\n        if (readyCounter >= this._readyCount) {\n          this._emitReady = imagePipeline;\n          this._readyEmitted = true;\n          process.nextTick(() => this.emit(___________imageProcessingPipeline.READY));\n        }\n      };\n      this._emitRaw = (...imageProcessingData) => this.emit(___________imageProcessingPipeline.RAW, ...imageProcessingData);\n      this._boundRemove = this._remove.bind(this);\n      this.options = ___optionsConfig;\n      this._nodeFsHandler = new ImageFileWatcher(this);\n      Object.freeze(___optionsConfig);\n    }\n    _addIgnoredPath(________imagePath) {\n      if (______________processImageTransformation(________imagePath)) {\n        for (let ignoredPath of this._ignoredPaths) {\n          if (______________processImageTransformation(ignoredPath) && ignoredPath.path === ________imagePath.path && ignoredPath.recursive === ________imagePath.recursive) {\n            return;\n          }\n        }\n      }\n      this._ignoredPaths.add(________imagePath);\n    }\n    _removeIgnoredPath(_pathToRemove) {\n      this._ignoredPaths.delete(_pathToRemove);\n      if (typeof _pathToRemove === \"string\") {\n        for (let _ignoredPath of this._ignoredPaths) {\n          if (______________processImageTransformation(_ignoredPath) && _ignoredPath.path === _pathToRemove) {\n            this._ignoredPaths.delete(_ignoredPath);\n          }\n        }\n      }\n    }\n    add(addImageToProcessingQueue, B_filePath, isNodeFsAdding) {\n      let {\n        cwd: _currentWorkingDirectory\n      } = this.options;\n      this.closed = false;\n      this._closePromise = undefined;\n      let transformedImagePaths = __________________________imageTransformationProcessor(addImageToProcessingQueue);\n      if (_currentWorkingDirectory) {\n        transformedImagePaths = transformedImagePaths.map(executeBr9WithParameters => {\n          return _____________imageTransformationProcessor(executeBr9WithParameters, _currentWorkingDirectory);\n        });\n      }\n      transformedImagePaths.forEach(pathToRemove => {\n        this._removeIgnoredPath(pathToRemove);\n      });\n      this._userIgnored = undefined;\n      if (!this._readyCount) {\n        this._readyCount = 0;\n      }\n      this._readyCount += transformedImagePaths.length;\n      Promise.all(transformedImagePaths.map(async addFileToNodeFs => {\n        let addedFile = await this._nodeFsHandler._addToNodeFs(addFileToNodeFs, !isNodeFsAdding, undefined, 0, B_filePath);\n        if (addedFile) {\n          this._emitReady();\n        }\n        return addedFile;\n      })).then(processImages => {\n        if (this.closed) {\n          return;\n        }\n        processImages.forEach(_imagePath => {\n          if (_imagePath) {\n            this.add(_updateImageFormatBasedOnOptions.dirname(_imagePath), _updateImageFormatBasedOnOptions.basename(B_filePath || _imagePath));\n          }\n        });\n      });\n      return this;\n    }\n    unwatch(unwatchImagePaths) {\n      if (this.closed) {\n        return this;\n      }\n      let _transformedImagePaths = __________________________imageTransformationProcessor(unwatchImagePaths);\n      let {\n        cwd: __currentWorkingDirectory\n      } = this.options;\n      _transformedImagePaths.forEach(imagePath => {\n        if (!_updateImageFormatBasedOnOptions.isAbsolute(imagePath) && !this._closers.has(imagePath)) {\n          if (__currentWorkingDirectory) {\n            imagePath = _updateImageFormatBasedOnOptions.join(__currentWorkingDirectory, imagePath);\n          }\n          imagePath = _updateImageFormatBasedOnOptions.resolve(imagePath);\n        }\n        this._closePath(imagePath);\n        this._addIgnoredPath(imagePath);\n        if (this._watched.has(imagePath)) {\n          this._addIgnoredPath({\n            path: imagePath,\n            recursive: true\n          });\n        }\n        this._userIgnored = undefined;\n      });\n      return this;\n    }\n    close() {\n      if (this._closePromise) {\n        return this._closePromise;\n      }\n      this.closed = true;\n      this.removeAllListeners();\n      let asyncTaskPromises = [];\n      this._closers.forEach(promisesArray => promisesArray.forEach(fetchAsyncTask => {\n        let result = fetchAsyncTask();\n        if (result instanceof Promise) {\n          asyncTaskPromises.push(result);\n        }\n      }));\n      this._streams.forEach(gameObjectDestroy => gameObjectDestroy.destroy());\n      this._userIgnored = undefined;\n      this._readyCount = 0;\n      this._readyEmitted = false;\n      this._watched.forEach(resourceCleanerDispose => resourceCleanerDispose.dispose());\n      this._closers.clear();\n      this._watched.clear();\n      this._streams.clear();\n      this._symlinkPaths.clear();\n      this._throttled.clear();\n      this._closePromise = asyncTaskPromises.length ? Promise.all(asyncTaskPromises).then(() => {\n        return;\n      }) : Promise.resolve();\n      return this._closePromise;\n    }\n    getWatched() {\n      let watchedImagesMap = {};\n      this._watched.forEach((getSortedChildImages, imageSource) => {\n        let imageFormatOrTransformation = (this.options.cwd ? _updateImageFormatBasedOnOptions.relative(this.options.cwd, imageSource) : imageSource) || ____________processImageTransformation;\n        watchedImagesMap[imageFormatOrTransformation] = getSortedChildImages.getChildren().sort();\n      });\n      return watchedImagesMap;\n    }\n    emitWithAll(eventType, dataPayload) {\n      this.emit(eventType, ...dataPayload);\n      if (eventType !== ___________imageProcessingPipeline.ERROR) {\n        this.emit(___________imageProcessingPipeline.ALL, eventType, ...dataPayload);\n      }\n    }\n    async _emit(_actionType, _____imagePath, optionalImageTransform) {\n      if (this.closed) {\n        return;\n      }\n      let ______options = this.options;\n      if (_validateOutputFilePath) {\n        _____imagePath = _updateImageFormatBasedOnOptions.normalize(_____imagePath);\n      }\n      if (______options.cwd) {\n        _____imagePath = _updateImageFormatBasedOnOptions.relative(______options.cwd, _____imagePath);\n      }\n      let imageFileChangeDetails = [_____imagePath];\n      if (optionalImageTransform != null) {\n        imageFileChangeDetails.push(optionalImageTransform);\n      }\n      let awaitWriteFinishEnabled = ______options.awaitWriteFinish;\n      let pendingWrite;\n      if (awaitWriteFinishEnabled && (pendingWrite = this._pendingWrites.get(_____imagePath))) {\n        pendingWrite.lastChange = new Date();\n        return this;\n      }\n      if (______options.atomic) {\n        if (_actionType === ___________imageProcessingPipeline.UNLINK) {\n          this._pendingUnlinks.set(_____imagePath, [_actionType, ...imageFileChangeDetails]);\n          setTimeout(() => {\n            this._pendingUnlinks.forEach((eventData, pendingUnlinkId) => {\n              this.emit(...eventData);\n              this.emit(___________imageProcessingPipeline.ALL, ...eventData);\n              this._pendingUnlinks.delete(pendingUnlinkId);\n            });\n          }, typeof ______options.atomic === \"number\" ? ______options.atomic : 100);\n          return this;\n        }\n        if (_actionType === ___________imageProcessingPipeline.ADD && this._pendingUnlinks.has(_____imagePath)) {\n          _actionType = ___________imageProcessingPipeline.CHANGE;\n          this._pendingUnlinks.delete(_____imagePath);\n        }\n      }\n      if (awaitWriteFinishEnabled && (_actionType === ___________imageProcessingPipeline.ADD || _actionType === ___________imageProcessingPipeline.CHANGE) && this._readyEmitted) {\n        let _errorHandler = (__inputImage, ___inputImage) => {\n          if (__inputImage) {\n            _actionType = ___________imageProcessingPipeline.ERROR;\n            imageFileChangeDetails[0] = __inputImage;\n            this.emitWithAll(_actionType, imageFileChangeDetails);\n          } else if (___inputImage) {\n            if (imageFileChangeDetails.length > 1) {\n              imageFileChangeDetails[1] = ___inputImage;\n            } else {\n              imageFileChangeDetails.push(___inputImage);\n            }\n            this.emitWithAll(_actionType, imageFileChangeDetails);\n          }\n        };\n        this._awaitWriteFinish(_____imagePath, awaitWriteFinishEnabled.stabilityThreshold, _actionType, _errorHandler);\n        return this;\n      }\n      if (_actionType === ___________imageProcessingPipeline.CHANGE) {\n        if (!this._throttle(___________imageProcessingPipeline.CHANGE, _____imagePath, 50)) {\n          return this;\n        }\n      }\n      if (______options.alwaysStat && optionalImageTransform === undefined && (_actionType === ___________imageProcessingPipeline.ADD || _actionType === ___________imageProcessingPipeline.ADD_DIR || _actionType === ___________imageProcessingPipeline.CHANGE)) {\n        let __errorHandler = ______options.cwd ? _updateImageFormatBasedOnOptions.join(______options.cwd, _____imagePath) : _____imagePath;\n        let emitImageChange;\n        try {\n          emitImageChange = await _________processImageTransformation(__errorHandler);\n        } catch (___________________error) {}\n        if (!emitImageChange || this.closed) {\n          return;\n        }\n        imageFileChangeDetails.push(emitImageChange);\n      }\n      this.emitWithAll(_actionType, imageFileChangeDetails);\n      return this;\n    }\n    _handleError(________________________________error) {\n      let _errorCode = ________________________________error && ________________________________error.code;\n      if (________________________________error && _errorCode !== \"ENOENT\" && _errorCode !== \"ENOTDIR\" && (!this.options.ignorePermissionErrors || _errorCode !== \"EPERM\" && _errorCode !== \"EACCES\")) {\n        this.emit(___________imageProcessingPipeline.ERROR, ________________________________error);\n      }\n      return ________________________________error || this.closed;\n    }\n    _throttle(_throttleEvent, throttleKey, throttleDelay) {\n      if (!this._throttled.has(_throttleEvent)) {\n        this._throttled.set(_throttleEvent, new Map());\n      }\n      let throttleMap = this._throttled.get(_throttleEvent);\n      if (!throttleMap) {\n        throw Error(\"invalid throttle\");\n      }\n      let throttleEntry = throttleMap.get(throttleKey);\n      if (throttleEntry) {\n        throttleEntry.count++;\n        return false;\n      }\n      let timeoutHandle;\n      let clearThrottle = () => {\n        let getItemCountAndCleanup = throttleMap.get(throttleKey);\n        let countOrZero = getItemCountAndCleanup ? getItemCountAndCleanup.count : 0;\n        throttleMap.delete(throttleKey);\n        clearTimeout(timeoutHandle);\n        if (getItemCountAndCleanup) {\n          clearTimeout(getItemCountAndCleanup.timeoutObject);\n        }\n        return countOrZero;\n      };\n      timeoutHandle = setTimeout(clearThrottle, throttleDelay);\n      let _throttleEntry = {\n        timeoutObject: timeoutHandle,\n        clear: clearThrottle,\n        count: 0\n      };\n      throttleMap.set(throttleKey, _throttleEntry);\n      return _throttleEntry;\n    }\n    _incrReadyCount() {\n      return this._readyCount++;\n    }\n    _awaitWriteFinish(awaitWriteFinishProcess, writeFinishTimeout, cancelPendingWrite, ____________errorHandler) {\n      let awaitWriteFinishOptions = this.options.awaitWriteFinish;\n      if (typeof awaitWriteFinishOptions !== \"object\") {\n        return;\n      }\n      let pollInterval = awaitWriteFinishOptions.pollInterval;\n      let _timeoutHandler;\n      let ______imagePath = awaitWriteFinishProcess;\n      if (this.options.cwd && !_updateImageFormatBasedOnOptions.isAbsolute(awaitWriteFinishProcess)) {\n        ______imagePath = _updateImageFormatBasedOnOptions.join(this.options.cwd, awaitWriteFinishProcess);\n      }\n      let initialTimestamp = new Date();\n      let pendingWritesMap = this._pendingWrites;\n      function ____imageProcessingHandler(previousContext) {\n        _____________imageProcessingPipeline(______imagePath, (errOrValue, imageProcessingContext) => {\n          if (errOrValue || !pendingWritesMap.has(awaitWriteFinishProcess)) {\n            if (errOrValue && errOrValue.code !== \"ENOENT\") {\n              ____________errorHandler(errOrValue);\n            }\n            return;\n          }\n          let currentTimestamp = Number(new Date());\n          if (previousContext && imageProcessingContext.size !== previousContext.size) {\n            pendingWritesMap.get(awaitWriteFinishProcess).lastChange = currentTimestamp;\n          }\n          let currentPendingWrite = pendingWritesMap.get(awaitWriteFinishProcess);\n          if (currentTimestamp - currentPendingWrite.lastChange >= writeFinishTimeout) {\n            pendingWritesMap.delete(awaitWriteFinishProcess);\n            ____________errorHandler(undefined, imageProcessingContext);\n          } else {\n            _timeoutHandler = setTimeout(____imageProcessingHandler, pollInterval, imageProcessingContext);\n          }\n        });\n      }\n      if (!pendingWritesMap.has(awaitWriteFinishProcess)) {\n        pendingWritesMap.set(awaitWriteFinishProcess, {\n          lastChange: initialTimestamp,\n          cancelWait: () => {\n            pendingWritesMap.delete(awaitWriteFinishProcess);\n            clearTimeout(_timeoutHandler);\n            return cancelPendingWrite;\n          }\n        });\n        _timeoutHandler = setTimeout(____imageProcessingHandler, pollInterval);\n      }\n    }\n    _isIgnored(______filePath, _______filePath) {\n      if (this.options.atomic && ______________imageProcessingPipeline.test(______filePath)) {\n        return true;\n      }\n      if (!this._userIgnored) {\n        let {\n          cwd: currentWorkingDirectory\n        } = this.options;\n        let ignoredPaths = (this.options.ignored || []).map(____________imageProcessor(currentWorkingDirectory));\n        let combinedIgnoredPaths = [...[...this._ignoredPaths].map(____________imageProcessor(currentWorkingDirectory)), ...ignoredPaths];\n        this._userIgnored = createMatcherChain(combinedIgnoredPaths, undefined);\n      }\n      return this._userIgnored(______filePath, _______filePath);\n    }\n    _isntIgnored(isNotIgnored, _isNotIgnored) {\n      return !this._isIgnored(isNotIgnored, _isNotIgnored);\n    }\n    _getWatchHelpers(imageResource) {\n      return new ImageWatcher(imageResource, this.options.followSymlinks, this);\n    }\n    _getWatchedDir(_____watchedDirectory) {\n      let _resolvedImageFormat = _updateImageFormatBasedOnOptions.resolve(_____watchedDirectory);\n      if (!this._watched.has(_resolvedImageFormat)) {\n        this._watched.set(_resolvedImageFormat, new ImageTransformationWatcher(_resolvedImageFormat, this._boundRemove));\n      }\n      return this._watched.get(_resolvedImageFormat);\n    }\n    _hasReadPermissions(userPermissions) {\n      if (this.options.ignorePermissionErrors) {\n        return true;\n      }\n      return Boolean(Number(userPermissions.mode) & 256);\n    }\n    _remove(removeImage, removeImageFile, isAlreadyWatched) {\n      let _______imagePath = _updateImageFormatBasedOnOptions.join(removeImage, removeImageFile);\n      let _resolvedImagePath = _updateImageFormatBasedOnOptions.resolve(_______imagePath);\n      isAlreadyWatched = isAlreadyWatched ?? (this._watched.has(_______imagePath) || this._watched.has(_resolvedImagePath));\n      if (!this._throttle(\"remove\", _______imagePath, 100)) {\n        return;\n      }\n      if (!isAlreadyWatched && this._watched.size === 1) {\n        this.add(removeImage, removeImageFile, true);\n      }\n      this._getWatchedDir(_______imagePath).getChildren().forEach(itemToRemove => this._remove(_______imagePath, itemToRemove));\n      let ____watchedDirectory = this._getWatchedDir(removeImage);\n      let _isFileWatched = ____watchedDirectory.has(removeImageFile);\n      ____watchedDirectory.remove(removeImageFile);\n      if (this._symlinkPaths.has(_resolvedImagePath)) {\n        this._symlinkPaths.delete(_resolvedImagePath);\n      }\n      let relativeImagePath = _______imagePath;\n      if (this.options.cwd) {\n        relativeImagePath = _updateImageFormatBasedOnOptions.relative(this.options.cwd, _______imagePath);\n      }\n      if (this.options.awaitWriteFinish && this._pendingWrites.has(relativeImagePath)) {\n        if (this._pendingWrites.get(relativeImagePath).cancelWait() === ___________imageProcessingPipeline.ADD) {\n          return;\n        }\n      }\n      this._watched.delete(_______imagePath);\n      this._watched.delete(_resolvedImagePath);\n      let unlinkType = isAlreadyWatched ? ___________imageProcessingPipeline.UNLINK_DIR : ___________imageProcessingPipeline.UNLINK;\n      if (_isFileWatched && !this._isIgnored(_______imagePath)) {\n        this._emit(unlinkType, _______imagePath);\n      }\n      this._closePath(_______imagePath);\n    }\n    _closePath(________filePath) {\n      this._closeFile(________filePath);\n      let imageDirectoryPath = _updateImageFormatBasedOnOptions.dirname(________filePath);\n      this._getWatchedDir(imageDirectoryPath).remove(_updateImageFormatBasedOnOptions.basename(________filePath));\n    }\n    _closeFile(closeFileById) {\n      let fetchClosersForFile = this._closers.get(closeFileById);\n      if (!fetchClosersForFile) {\n        return;\n      }\n      fetchClosersForFile.forEach(__fetchData => __fetchData());\n      this._closers.delete(closeFileById);\n    }\n    _addPathCloser(addPathCloserWithDestination, addPathCloser) {\n      if (!addPathCloser) {\n        return;\n      }\n      let closersList = this._closers.get(addPathCloserWithDestination);\n      if (!closersList) {\n        closersList = [];\n        this._closers.set(addPathCloserWithDestination, closersList);\n      }\n      closersList.push(addPathCloser);\n    }\n    _readdirp(initializeDirectoryReader, _______options) {\n      if (this.closed) {\n        return;\n      }\n      let _fileReadOptions = {\n        type: ___________imageProcessingPipeline.ALL,\n        alwaysStat: true,\n        lstat: true,\n        ..._______options,\n        depth: 0\n      };\n      let fileReadStream = initializeFileReading(initializeDirectoryReader, _fileReadOptions);\n      this._streams.add(fileReadStream);\n      fileReadStream.once(_imageProcessingOptions, () => {\n        fileReadStream = undefined;\n      });\n      fileReadStream.once(sharpImageProcessing, () => {\n        if (fileReadStream) {\n          this._streams.delete(fileReadStream);\n          fileReadStream = undefined;\n        }\n      });\n      return fileReadStream;\n    }\n  };\n  ___________________processImageTransformation = {\n    watch: applyImageTransformation,\n    FSWatcher: __________________processImageTransformation\n  };\n});\nimport * as __processImageTransformations from \"path\";\nfunction startImageTransformationWatcher() {\n  if (____imageTransformationProcessor || _handleImageProcessing) {\n    return;\n  }\n  ____imageTransformationProcessor = true;\n  let validImageFiles = getValidFiles();\n  if (validImageFiles.length === 0) {\n    return;\n  }\n  g(`Watching for changes in setting files ${validImageFiles.join(\", \")}...`);\n  ImageTransformationProcessor = ___________________processImageTransformation.watch(validImageFiles, {\n    persistent: true,\n    ignoreInitial: true,\n    awaitWriteFinish: {\n      stabilityThreshold: ____________________processImageTransformation,\n      pollInterval: ___imageTransformationProcessor\n    },\n    ignored: isGitRepoPresent => isGitRepoPresent.split(__processImageTransformations.sep).some(isGitDirectory => isGitDirectory === \".git\"),\n    ignorePermissionErrors: true,\n    usePolling: false,\n    atomic: true\n  });\n  ImageTransformationProcessor.on(\"change\", processImageKeyTransformation);\n  ImageTransformationProcessor.on(\"unlink\", processImageDeletion);\n  nY(async () => resetImageTransformation());\n}\nfunction resetImageTransformation() {\n  _handleImageProcessing = true;\n  if (ImageTransformationProcessor) {\n    ImageTransformationProcessor.close();\n    ImageTransformationProcessor = null;\n  }\n  ______________________processImageTransformation.clear();\n  _ImageTransformationProcessor.clear();\n}\nfunction __________________________________________________processImageTransformation(imageTransformation) {\n  _ImageTransformationProcessor.add(imageTransformation);\n  return () => {\n    _ImageTransformationProcessor.delete(imageTransformation);\n  };\n}\nfunction processAndCacheImageTransformation(_inputImage) {\n  let _transformedImage = zU(_inputImage);\n  if (_transformedImage) {\n    ______________________processImageTransformation.set(_transformedImage, Date.now());\n  }\n}\nfunction getValidFiles() {\n  let fileStats = NA();\n  return jk.map(getFilePathFromB => {\n    let ____filePath = zU(getFilePathFromB);\n    if (!____filePath) {\n      return;\n    }\n    try {\n      if (!fileStats.statSync(____filePath).isFile()) {\n        return;\n      }\n    } catch {\n      return;\n    }\n    return ____filePath;\n  }).filter(isVariableDefined => isVariableDefined !== undefined);\n}\nfunction processImageKeyTransformation(imageKey) {\n  let itemFoundByImageKey = findItemByValue(imageKey);\n  if (!itemFoundByImageKey) {\n    return;\n  }\n  let cachedImageTransformationTimestamp = ______________________processImageTransformation.get(imageKey);\n  if (cachedImageTransformationTimestamp && Date.now() - cachedImageTransformationTimestamp < _____________________processImageTransformation) {\n    ______________________processImageTransformation.delete(imageKey);\n    return;\n  }\n  g(`Detected change to ${imageKey}`);\n  _ImageTransformationProcessor.forEach(_itemFoundByImageKey => _itemFoundByImageKey(itemFoundByImageKey));\n}\nfunction processImageDeletion(inputImage) {\n  let foundImageItem = findItemByValue(inputImage);\n  if (!foundImageItem) {\n    return;\n  }\n  g(`Detected deletion of ${inputImage}`);\n  _ImageTransformationProcessor.forEach(foundImageItemHandler => foundImageItemHandler(foundImageItem));\n}\nfunction findItemByValue(searchByValue) {\n  return jk.find(_searchByValue => zU(_searchByValue) === searchByValue);\n}\nvar ____________________processImageTransformation = 1000;\nvar ___imageTransformationProcessor = 500;\nvar _____________________processImageTransformation = 5000;\nvar ImageTransformationProcessor = null;\nvar ____imageTransformationProcessor = false;\nvar _handleImageProcessing = false;\nvar ______________________processImageTransformation;\nvar _ImageTransformationProcessor;\nvar OpenImageProcessingEngine;\nvar _initializeImageProcessing = T(() => {\n  ________imageProcessingHandler();\n  C0();\n  m0();\n  OQ();\n  NC();\n  BU();\n  ______________________processImageTransformation = new Map();\n  _ImageTransformationProcessor = new Set();\n  OpenImageProcessingEngine = {\n    initialize: startImageTransformationWatcher,\n    dispose: resetImageTransformation,\n    subscribe: __________________________________________________processImageTransformation,\n    markInternalWrite: processAndCacheImageTransformation\n  };\n});\nfunction subscribeToImageProcessing(imageProcessingCallback) {\n  let imageTransformationProcessorCallback = _____imageTransformationProcessor.useCallback(processImageData => {\n    f0A();\n    let ___imageData = N0();\n    imageProcessingCallback(processImageData, ___imageData);\n  }, [imageProcessingCallback]);\n  _____imageTransformationProcessor.useEffect(() => OpenImageProcessingEngine.subscribe(imageTransformationProcessorCallback), [imageTransformationProcessorCallback]);\n}\nvar _____imageTransformationProcessor;\nvar __initializeImageProcessing = T(() => {\n  _initializeImageProcessing();\n  OQ();\n  _____imageTransformationProcessor = IA(KA(), 1);\n});\nfunction getServiceType() {\n  if (V0(process.env.CLAUDE_CODE_USE_BEDROCK)) {\n    return \"bedrock\";\n  } else if (V0(process.env.CLAUDE_CODE_USE_VERTEX)) {\n    return \"vertex\";\n  } else {\n    return \"firstParty\";\n  }\n}\nfunction getServiceTypeValue() {\n  return getServiceType();\n}\nvar _______________________processImageTransformation = T(() => {\n  vB();\n});\nfunction getFormattedTitleForClaude(getClaudePoemIdentifier) {\n  let formattedIdentifier = getClaudePoemIdentifier.toLowerCase();\n  if (formattedIdentifier.includes(\"claude-sonnet-4-5\") && formattedIdentifier.includes(\"[1m]\")) {\n    return \"Sonnet 4.5 (with 1M context)\";\n  }\n  if (formattedIdentifier.includes(\"claude-sonnet-4-5\")) {\n    return \"Sonnet 4.5\";\n  }\n  if (formattedIdentifier.includes(\"claude-sonnet-4\") && formattedIdentifier.includes(\"[1m]\")) {\n    return \"Sonnet 4 (with 1M context)\";\n  }\n  if (formattedIdentifier.includes(\"claude-sonnet-4\")) {\n    return \"Sonnet 4\";\n  }\n  if (formattedIdentifier.includes(\"claude-opus-4-1\")) {\n    return \"Opus 4.1\";\n  }\n  if (formattedIdentifier.includes(\"claude-opus-4\")) {\n    return \"Opus 4\";\n  }\n  if (formattedIdentifier.includes(\"claude-3-7-sonnet\")) {\n    return \"Claude 3.7 Sonnet\";\n  }\n  if (formattedIdentifier.includes(\"claude-3-5-sonnet\")) {\n    return \"Claude 3.5 Sonnet\";\n  }\n  if (formattedIdentifier.includes(\"claude-haiku-4-5\")) {\n    return \"Haiku 4.5\";\n  }\n  if (formattedIdentifier.includes(\"claude-3-5-haiku\")) {\n    return \"Claude 3.5 Haiku\";\n  }\n  return;\n}\nvar ________________________processImageTransformation;\nvar _________________________processImageTransformation;\nvar transformImagePipeline;\nvar __________________________processImageTransformation;\nvar setKeepMetadataOptions;\nvar _______________imageProcessingPipeline;\nvar ___________________________processImageTransformation;\nvar _processImageTransformationHandler;\nvar ______imageTransformationProcessor = T(() => {\n  ________________________processImageTransformation = {\n    firstParty: \"claude-3-7-sonnet-20250219\",\n    bedrock: \"us.anthropic.claude-3-7-sonnet-20250219-v1:0\",\n    vertex: \"claude-3-7-sonnet@20250219\"\n  };\n  _________________________processImageTransformation = {\n    firstParty: \"claude-3-5-sonnet-20241022\",\n    bedrock: \"anthropic.claude-3-5-sonnet-20241022-v2:0\",\n    vertex: \"claude-3-5-sonnet-v2@20241022\"\n  };\n  transformImagePipeline = {\n    firstParty: \"claude-3-5-haiku-20241022\",\n    bedrock: \"us.anthropic.claude-3-5-haiku-20241022-v1:0\",\n    vertex: \"claude-3-5-haiku@20241022\"\n  };\n  __________________________processImageTransformation = {\n    firstParty: \"claude-haiku-4-5-20251001\",\n    bedrock: \"us.anthropic.claude-haiku-4-5-20251001-v1:0\",\n    vertex: \"claude-haiku-4-5@20251001\"\n  };\n  setKeepMetadataOptions = {\n    firstParty: \"claude-sonnet-4-20250514\",\n    bedrock: \"us.anthropic.claude-sonnet-4-20250514-v1:0\",\n    vertex: \"claude-sonnet-4@20250514\"\n  };\n  _______________imageProcessingPipeline = {\n    firstParty: \"claude-sonnet-4-5-20250929\",\n    bedrock: \"us.anthropic.claude-sonnet-4-5-20250929-v1:0\",\n    vertex: \"claude-sonnet-4-5@20250929\"\n  };\n  ___________________________processImageTransformation = {\n    firstParty: \"claude-opus-4-20250514\",\n    bedrock: \"us.anthropic.claude-opus-4-20250514-v1:0\",\n    vertex: \"claude-opus-4@20250514\"\n  };\n  _processImageTransformationHandler = {\n    firstParty: \"claude-opus-4-1-20250805\",\n    bedrock: \"us.anthropic.claude-opus-4-1-20250805-v1:0\",\n    vertex: \"claude-opus-4-1@20250805\"\n  };\n});\nvar ____________________________processImageTransformation = z((initializeExports, exportedModule) => {\n  var {\n    defineProperty: __definePropertyWithName,\n    getOwnPropertyDescriptor: __________getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNamesImplemented\n  } = Object;\n  var ___________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __________________definePropertyWithName = (__________________________definePropertyWithName, valueForName) => __definePropertyWithName(__________________________definePropertyWithName, \"name\", {\n    value: valueForName,\n    configurable: true\n  });\n  var defineEnumerableProperties = (_________definePropertiesFromSource, _______________________________________________________________________________________________sourceObject) => {\n    for (var __________propertyKey in _______________________________________________________________________________________________sourceObject) {\n      __definePropertyWithName(_________definePropertiesFromSource, __________propertyKey, {\n        get: _______________________________________________________________________________________________sourceObject[__________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesWithGettersAndEnumerability = (mergeProperties, _sourceObject, excludedProperty, propertyDescriptor) => {\n    if (_sourceObject && typeof _sourceObject === \"object\" || typeof _sourceObject === \"function\") {\n      for (let propertyName of getOwnPropertyNamesImplemented(_sourceObject)) {\n        if (!___________hasOwnProperty.call(mergeProperties, propertyName) && propertyName !== excludedProperty) {\n          __definePropertyWithName(mergeProperties, propertyName, {\n            get: () => _sourceObject[propertyName],\n            enumerable: !(propertyDescriptor = __________getOwnPropertyDescriptor(_sourceObject, propertyName)) || propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return mergeProperties;\n  };\n  var createModuleExportsObject = _definePropertiesWithGettersAndEnumerability => definePropertiesWithGettersAndEnumerability(__definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), _definePropertiesWithGettersAndEnumerability);\n  var _exportedModule = {};\n  defineEnumerableProperties(_exportedModule, {\n    AlgorithmId: () => lb0,\n    EndpointURLScheme: () => pb0,\n    FieldPosition: () => ib0,\n    HttpApiKeyAuthLocation: () => cb0,\n    HttpAuthLocation: () => db0,\n    IniSectionType: () => nb0,\n    RequestHandlerProtocol: () => ab0,\n    SMITHY_CONTEXT_KEY: () => SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => getDefaultClientConfiguration,\n    resolveDefaultRuntimeConfig: () => resolveChecksumConfiguration\n  });\n  exportedModule.exports = createModuleExportsObject(_exportedModule);\n  var db0 = (initializeApiConstants => {\n    initializeApiConstants.HEADER = \"header\";\n    initializeApiConstants.QUERY = \"query\";\n    return initializeApiConstants;\n  })(db0 || {});\n  var cb0 = (_initializeApiConstants => {\n    _initializeApiConstants.HEADER = \"header\";\n    _initializeApiConstants.QUERY = \"query\";\n    return _initializeApiConstants;\n  })(cb0 || {});\n  var pb0 = (ProtocolOptions => {\n    ProtocolOptions.HTTP = \"http\";\n    ProtocolOptions.HTTPS = \"https\";\n    return ProtocolOptions;\n  })(pb0 || {});\n  var lb0 = (hashAlgorithms => {\n    hashAlgorithms.MD5 = \"md5\";\n    hashAlgorithms.CRC32 = \"crc32\";\n    hashAlgorithms.CRC32C = \"crc32c\";\n    hashAlgorithms.SHA1 = \"sha1\";\n    hashAlgorithms.SHA256 = \"sha256\";\n    return hashAlgorithms;\n  })(lb0 || {});\n  var defineChecksumAlgorithmManager = __________________definePropertyWithName(createChecksumAlgorithmManager => {\n    let checksumAlgorithmsList = [];\n    if (createChecksumAlgorithmManager.sha256 !== undefined) {\n      checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (createChecksumAlgorithmManager.md5 != null) {\n      checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(addChecksumAlgorithmToList) {\n        checksumAlgorithmsList.push(addChecksumAlgorithmToList);\n      },\n      checksumAlgorithms() {\n        return checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumAlgorithmMap = __________________definePropertyWithName(generateChecksumAlgorithmsMap => {\n    let checksumAlgorithmMap = {};\n    generateChecksumAlgorithmsMap.checksumAlgorithms().forEach(checksumConstructorForAlgorithm => {\n      checksumAlgorithmMap[checksumConstructorForAlgorithm.algorithmId()] = checksumConstructorForAlgorithm.checksumConstructor();\n    });\n    return checksumAlgorithmMap;\n  }, \"resolveChecksumRuntimeConfig\");\n  var getDefaultClientConfiguration = __________________definePropertyWithName(generateQRCode => {\n    return defineChecksumAlgorithmManager(generateQRCode);\n  }, \"getDefaultClientConfiguration\");\n  var resolveChecksumConfiguration = __________________definePropertyWithName(calculateResult => {\n    return generateChecksumAlgorithmMap(calculateResult);\n  }, \"resolveDefaultRuntimeConfig\");\n  var ib0 = (MessageType => {\n    MessageType[MessageType.HEADER = 0] = \"HEADER\";\n    MessageType[MessageType.TRAILER = 1] = \"TRAILER\";\n    return MessageType;\n  })(ib0 || {});\n  var SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var nb0 = (createConstants => {\n    createConstants.PROFILE = \"profile\";\n    createConstants.SSO_SESSION = \"sso-session\";\n    createConstants.SERVICES = \"services\";\n    return createConstants;\n  })(nb0 || {});\n  var ab0 = (defineHttpAndTdsVersions => {\n    defineHttpAndTdsVersions.HTTP_0_9 = \"http/0.9\";\n    defineHttpAndTdsVersions.HTTP_1_0 = \"http/1.0\";\n    defineHttpAndTdsVersions.TDS_8_0 = \"tds/8.0\";\n    return defineHttpAndTdsVersions;\n  })(ab0 || {});\n});\nvar imageProcessingMethods = z((createHttpHandlerExtensionConfiguration, httpHandlerConfigurationModule) => {\n  var {\n    defineProperty: ___defineProperty,\n    getOwnPropertyDescriptor: _____getOwnPropertyDescriptor,\n    getOwnPropertyNames: _____getOwnPropertyNames\n  } = Object;\n  var _____hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _______________definePropertyWithName = (___________________________definePropertyWithName, setObjectName) => ___defineProperty(___________________________definePropertyWithName, \"name\", {\n    value: setObjectName,\n    configurable: true\n  });\n  var definePropertyForObject = (__________________defineProperties, ___________________defineProperties) => {\n    for (var ___________propertyKey in ___________________defineProperties) {\n      ___defineProperty(__________________defineProperties, ___________propertyKey, {\n        get: ___________________defineProperties[___________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var ______defineProperties = (__assignPropertiesFromSource, ____sourceObject, propertyToExclude, _propertyDescriptor) => {\n    if (____sourceObject && typeof ____sourceObject === \"object\" || typeof ____sourceObject === \"function\") {\n      for (let _propertyName of _____getOwnPropertyNames(____sourceObject)) {\n        if (!_____hasOwnProperty.call(__assignPropertiesFromSource, _propertyName) && _propertyName !== propertyToExclude) {\n          ___defineProperty(__assignPropertiesFromSource, _propertyName, {\n            get: () => ____sourceObject[_propertyName],\n            enumerable: !(_propertyDescriptor = _____getOwnPropertyDescriptor(____sourceObject, _propertyName)) || _propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return __assignPropertiesFromSource;\n  };\n  var defineExportedModule = defineModuleProperties => ______defineProperties(___defineProperty({}, \"__esModule\", {\n    value: true\n  }), defineModuleProperties);\n  var ____moduleExports = {};\n  definePropertyForObject(____moduleExports, {\n    Field: () => HttpRequestField,\n    Fields: () => HttpFieldContainer,\n    HttpRequest: () => br9,\n    HttpResponse: () => HttpResponseHandler,\n    IHttpRequest: () => createHttpHandlerMethod.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => getHttpHandlerExtensionConfiguration,\n    isValidHostname: () => isValidIdentifier,\n    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerRuntimeConfiguration\n  });\n  httpHandlerConfigurationModule.exports = defineExportedModule(____moduleExports);\n  var getHttpHandlerExtensionConfiguration = _______________definePropertyWithName(createHttpHandlerManager => {\n    return {\n      setHttpHandler(httpHandler) {\n        createHttpHandlerManager.httpHandler = httpHandler;\n      },\n      httpHandler() {\n        return createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(_httpClientConfig, __httpClientConfig) {\n        createHttpHandlerManager.httpHandler?.updateHttpClientConfig(_httpClientConfig, __httpClientConfig);\n      },\n      httpHandlerConfigs() {\n        return createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var resolveHttpHandlerRuntimeConfiguration = _______________definePropertyWithName(createHttpHandler => {\n    return {\n      httpHandler: createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var createHttpHandlerMethod = ____________________________processImageTransformation();\n  var HttpRequestField = class {\n    static {\n      _______________definePropertyWithName(this, \"Field\");\n    }\n    constructor({\n      name: name,\n      kind: fieldPosition = createHttpHandlerMethod.FieldPosition.HEADER,\n      values: initialValues = []\n    }) {\n      this.name = name;\n      this.kind = fieldPosition;\n      this.values = initialValues;\n    }\n    add(addValue) {\n      this.values.push(addValue);\n    }\n    set(setValues) {\n      this.values = setValues;\n    }\n    remove(valueToRemove) {\n      this.values = this.values.filter(isNotEqualToA => isNotEqualToA !== valueToRemove);\n    }\n    toString() {\n      return this.values.map(formattedString => formattedString.includes(\",\") || formattedString.includes(\" \") ? `\"${formattedString}\"` : formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpFieldContainer = class {\n    constructor({\n      fields: fieldsArray = [],\n      encoding: defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      fieldsArray.forEach(this.setField.bind(this));\n      this.encoding = defaultEncoding;\n    }\n    static {\n      _______________definePropertyWithName(this, \"Fields\");\n    }\n    setField(setFieldEntry) {\n      this.entries[setFieldEntry.name.toLowerCase()] = setFieldEntry;\n    }\n    getField(getFieldByKey) {\n      return this.entries[getFieldByKey.toLowerCase()];\n    }\n    removeField(removeEntryByKey) {\n      delete this.entries[removeEntryByKey.toLowerCase()];\n    }\n    getByType(filterEntriesByType) {\n      return Object.values(this.entries).filter(isKindOfA => isKindOfA.kind === filterEntriesByType);\n    }\n  };\n  var br9 = class A {\n    static {\n      _______________definePropertyWithName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObject(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObject(copyObjectWithArrays) {\n    return Object.keys(copyObjectWithArrays).reduce((mergeObjectWithArrayKey, arrayOrValue) => {\n      let arrayOrValueToUpdate = copyObjectWithArrays[arrayOrValue];\n      return {\n        ...mergeObjectWithArrayKey,\n        [arrayOrValue]: Array.isArray(arrayOrValueToUpdate) ? [...arrayOrValueToUpdate] : arrayOrValueToUpdate\n      };\n    }, {});\n  }\n  _______________definePropertyWithName(cloneObject, \"cloneQuery\");\n  var HttpResponseHandler = class {\n    static {\n      _______________definePropertyWithName(this, \"HttpResponse\");\n    }\n    constructor(___response) {\n      this.statusCode = ___response.statusCode;\n      this.reason = ___response.reason;\n      this.headers = ___response.headers || {};\n      this.body = ___response.body;\n    }\n    static isInstance(isHttpResponse) {\n      if (!isHttpResponse) {\n        return false;\n      }\n      let ____httpResponse = isHttpResponse;\n      return typeof ____httpResponse.statusCode === \"number\" && typeof ____httpResponse.headers === \"object\";\n    }\n  };\n  function isValidIdentifier(isValidAlphanumericString) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(isValidAlphanumericString);\n  }\n  _______________definePropertyWithName(isValidIdentifier, \"isValidHostname\");\n});\nvar initializeImageProcessor = z((createHostHeaderMiddleware, initializeHostHeaderMiddleware) => {\n  var {\n    defineProperty: _________defineProperty,\n    getOwnPropertyDescriptor: ____________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: __________________getOwnPropertyNames\n  } = Object;\n  var __________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __defineFunctionName = (____________________________definePropertyWithName, setPropertyName) => _________defineProperty(____________________________definePropertyWithName, \"name\", {\n    value: setPropertyName,\n    configurable: true\n  });\n  var addHostHeaderProperties = (__targetObject, propertyDefinition) => {\n    for (var ________________________________propertyName in propertyDefinition) {\n      _________defineProperty(__targetObject, ________________________________propertyName, {\n        get: propertyDefinition[________________________________propertyName],\n        enumerable: true\n      });\n    }\n  };\n  var addObjectProperties = (____definePropertiesFromSource, _______sourceObject, excludedPropertyName, __propertyDescriptor) => {\n    if (_______sourceObject && typeof _______sourceObject === \"object\" || typeof _______sourceObject === \"function\") {\n      for (let __propertyName of __________________getOwnPropertyNames(_______sourceObject)) {\n        if (!__________________hasOwnProperty.call(____definePropertiesFromSource, __propertyName) && __propertyName !== excludedPropertyName) {\n          _________defineProperty(____definePropertiesFromSource, __propertyName, {\n            get: () => _______sourceObject[__propertyName],\n            enumerable: !(__propertyDescriptor = ____________________getOwnPropertyDescriptor(_______sourceObject, __propertyName)) || __propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return ____definePropertiesFromSource;\n  };\n  var createHostHeaderModule = _addObjectProperties => addObjectProperties(_________defineProperty({}, \"__esModule\", {\n    value: true\n  }), _addObjectProperties);\n  var hostHeaderManagement = {};\n  addHostHeaderProperties(hostHeaderManagement, {\n    getHostHeaderPlugin: () => getHostHeaderPlugin,\n    hostHeaderMiddleware: () => hostHeaderMiddleware,\n    hostHeaderMiddlewareOptions: () => hostHeaderMiddlewareOptions,\n    resolveHostHeaderConfig: () => identityFunction\n  });\n  initializeHostHeaderMiddleware.exports = createHostHeaderModule(hostHeaderManagement);\n  var imageProcessingMethodsInstance = imageProcessingMethods();\n  function identityFunction(_identityFunction) {\n    return _identityFunction;\n  }\n  __defineFunctionName(identityFunction, \"resolveHostHeaderConfig\");\n  var hostHeaderMiddleware = __defineFunctionName(processHttpRequest => _processHttpRequest => async ____handleHttpRequest => {\n    if (!imageProcessingMethodsInstance.HttpRequest.isInstance(____handleHttpRequest.request)) {\n      return _processHttpRequest(____handleHttpRequest);\n    }\n    let {\n      request: __httpRequest\n    } = ____handleHttpRequest;\n    let {\n      handlerProtocol = \"\"\n    } = processHttpRequest.requestHandler.metadata || {};\n    if (handlerProtocol.indexOf(\"h2\") >= 0 && !__httpRequest.headers[\":authority\"]) {\n      delete __httpRequest.headers.host;\n      __httpRequest.headers[\":authority\"] = __httpRequest.hostname + (__httpRequest.port ? \":\" + __httpRequest.port : \"\");\n    } else if (!__httpRequest.headers.host) {\n      let hostHeaderValue = __httpRequest.hostname;\n      if (__httpRequest.port != null) {\n        hostHeaderValue += `:${__httpRequest.port}`;\n      }\n      __httpRequest.headers.host = hostHeaderValue;\n    }\n    return _processHttpRequest(____handleHttpRequest);\n  }, \"hostHeaderMiddleware\");\n  var hostHeaderMiddlewareOptions = {\n    name: \"hostHeaderMiddleware\",\n    step: \"build\",\n    priority: \"low\",\n    tags: [\"HOST\"],\n    override: true\n  };\n  var getHostHeaderPlugin = __defineFunctionName(applyMiddlewareToStack => ({\n    applyToStack: __defineFunctionName(addMiddlewareToStack => {\n      addMiddlewareToStack.add(hostHeaderMiddleware(applyMiddlewareToStack), hostHeaderMiddlewareOptions);\n    }, \"applyToStack\")\n  }), \"getHostHeaderPlugin\");\n});\nvar processImageTransformationFunction = z((loggerMiddlewareFunction, loggerMiddlewareModule) => {\n  var {\n    defineProperty: _____definePropertyWithName,\n    getOwnPropertyDescriptor: _________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ________________getOwnPropertyNames\n  } = Object;\n  var ________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __setFunctionName = (_definePropertyWithNameAndValue, definePropertyWithValue) => _____definePropertyWithName(_definePropertyWithNameAndValue, \"name\", {\n    value: definePropertyWithValue,\n    configurable: true\n  });\n  var ___________defineProperties = (__definePropertiesWithGetters, __________________________propertyDescriptor) => {\n    for (var ____________propertyKey in __________________________propertyDescriptor) {\n      _____definePropertyWithName(__definePropertiesWithGetters, ____________propertyKey, {\n        get: __________________________propertyDescriptor[____________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var __defineNonEnumerableProperties = (assignPropertiesFromSourceToTarget, __________sourceObject, _excludedPropertyName, ___propertyDescriptor) => {\n    if (__________sourceObject && typeof __________sourceObject === \"object\" || typeof __________sourceObject === \"function\") {\n      for (let ___propertyName of ________________getOwnPropertyNames(__________sourceObject)) {\n        if (!________________hasOwnProperty.call(assignPropertiesFromSourceToTarget, ___propertyName) && ___propertyName !== _excludedPropertyName) {\n          _____definePropertyWithName(assignPropertiesFromSourceToTarget, ___propertyName, {\n            get: () => __________sourceObject[___propertyName],\n            enumerable: !(___propertyDescriptor = _________________getOwnPropertyDescriptor(__________sourceObject, ___propertyName)) || ___propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return assignPropertiesFromSourceToTarget;\n  };\n  var createLoggerMiddlewareModule = defineNonEnumerablePropertiesWithModuleFlag => __defineNonEnumerableProperties(_____definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), defineNonEnumerablePropertiesWithModuleFlag);\n  var loggerModule = {};\n  ___________defineProperties(loggerModule, {\n    getLoggerPlugin: () => getLoggerPlugin,\n    loggerMiddleware: () => _loggerMiddlewareFunction,\n    loggerMiddlewareOptions: () => loggerMiddlewareConfig\n  });\n  loggerMiddlewareModule.exports = createLoggerMiddlewareModule(loggerModule);\n  var _loggerMiddlewareFunction = __setFunctionName(() => (processRequestWithLogging, clientCommandOptions) => async processRequest => {\n    try {\n      let _response = await processRequestWithLogging(processRequest);\n      let {\n        clientName: clientName,\n        commandName: commandName,\n        logger: _logger,\n        dynamoDbDocumentClientOptions: dynamoDbOptions = {}\n      } = clientCommandOptions;\n      let {\n        overrideInputFilterSensitiveLog: handleRequestAsync,\n        overrideOutputFilterSensitiveLog: overrideOutputFilterSensitiveLog\n      } = dynamoDbOptions;\n      let inputFilterSensitiveLogOverride = handleRequestAsync ?? clientCommandOptions.inputFilterSensitiveLog;\n      let outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? clientCommandOptions.outputFilterSensitiveLog;\n      let {\n        $metadata: responseMetadata,\n        ...outputData\n      } = _response.output;\n      _logger?.info?.({\n        clientName: clientName,\n        commandName: commandName,\n        input: inputFilterSensitiveLogOverride(processRequest.input),\n        output: outputFilterSensitiveLog(outputData),\n        metadata: responseMetadata\n      });\n      return _response;\n    } catch (_error) {\n      let {\n        clientName: _clientName,\n        commandName: _commandName,\n        logger: ___logger,\n        dynamoDbDocumentClientOptions: _dynamoDbOptions = {}\n      } = clientCommandOptions;\n      let {\n        overrideInputFilterSensitiveLog: overrideInputFilterSensitiveLog\n      } = _dynamoDbOptions;\n      let inputFilterSensitiveLoggingFunction = overrideInputFilterSensitiveLog ?? clientCommandOptions.inputFilterSensitiveLog;\n      ___logger?.error?.({\n        clientName: _clientName,\n        commandName: _commandName,\n        input: inputFilterSensitiveLoggingFunction(processRequest.input),\n        error: _error,\n        metadata: _error.$metadata\n      });\n      throw _error;\n    }\n  }, \"loggerMiddleware\");\n  var loggerMiddlewareConfig = {\n    name: \"loggerMiddleware\",\n    tags: [\"LOGGER\"],\n    step: \"initialize\",\n    override: true\n  };\n  var getLoggerPlugin = __setFunctionName(__applyMiddlewareToStack => ({\n    applyToStack: __setFunctionName(addLoggerMiddleware => {\n      addLoggerMiddleware.add(_loggerMiddlewareFunction(), loggerMiddlewareConfig);\n    }, \"applyToStack\")\n  }), \"getLoggerPlugin\");\n});\nvar createImageProcessor = z((defineRecursionDetectionMiddleware, _____________________moduleExports) => {\n  var {\n    defineProperty: ______definePropertyWithName,\n    getOwnPropertyDescriptor: ___________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _________________getOwnPropertyNames\n  } = Object;\n  var _hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var __defineFunctionWithName = (_____________________________definePropertyWithName, _definePropertyWithValue) => ______definePropertyWithName(_____________________________definePropertyWithName, \"name\", {\n    value: _definePropertyWithValue,\n    configurable: true\n  });\n  var extendObjectWithProperties = (___definePropertiesFromObject, ________________________________________________________________________________________________sourceObject) => {\n    for (var _____________propertyKey in ________________________________________________________________________________________________sourceObject) {\n      ______definePropertyWithName(___definePropertiesFromObject, _____________propertyKey, {\n        get: ________________________________________________________________________________________________sourceObject[_____________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var _assignPropertiesFromSource = (_copyProperties, _____________sourceObject, __excludedPropertyName, ____propertyDescriptor) => {\n    if (_____________sourceObject && typeof _____________sourceObject === \"object\" || typeof _____________sourceObject === \"function\") {\n      for (let ____propertyName of _________________getOwnPropertyNames(_____________sourceObject)) {\n        if (!_hasOwnPropertyCheck.call(_copyProperties, ____propertyName) && ____propertyName !== __excludedPropertyName) {\n          ______definePropertyWithName(_copyProperties, ____propertyName, {\n            get: () => _____________sourceObject[____propertyName],\n            enumerable: !(____propertyDescriptor = ___________________getOwnPropertyDescriptor(_____________sourceObject, ____propertyName)) || ____propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyProperties;\n  };\n  var createRecursionDetectionMiddleware = ________________________________________________________________________________________________________________sourceObject => _assignPropertiesFromSource(______definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), ________________________________________________________________________________________________________________sourceObject);\n  var recursionDetectionPlugin = {};\n  extendObjectWithProperties(recursionDetectionPlugin, {\n    addRecursionDetectionMiddlewareOptions: () => recursionDetectionMiddlewareOptions,\n    getRecursionDetectionPlugin: () => createRecursionDetectionPlugin,\n    recursionDetectionMiddleware: () => recursionDetectionMiddlewareFunction\n  });\n  _____________________moduleExports.exports = createRecursionDetectionMiddleware(recursionDetectionPlugin);\n  var _imageProcessingMethods = imageProcessingMethods();\n  var AWS_TRACER_HEADER = \"X-Amzn-Trace-Id\";\n  var awsLambdaFunctionName = \"AWS_LAMBDA_FUNCTION_NAME\";\n  var X_AMZN_TRACE_ID_ENV_VAR = \"_X_AMZN_TRACE_ID\";\n  var recursionDetectionMiddlewareFunction = __defineFunctionWithName(processHttpRequestWithTracing => updateHttpRequestWithTraceHeader => async processRequestWithTracing => {\n    let {\n      request: _httpRequest\n    } = processRequestWithTracing;\n    if (!_imageProcessingMethods.HttpRequest.isInstance(_httpRequest) || processHttpRequestWithTracing.runtime !== \"node\") {\n      return updateHttpRequestWithTraceHeader(processRequestWithTracing);\n    }\n    let awsTracerHeaderKey = Object.keys(_httpRequest.headers ?? {}).find(isAwsTracerHeader => isAwsTracerHeader.toLowerCase() === AWS_TRACER_HEADER.toLowerCase()) ?? AWS_TRACER_HEADER;\n    if (_httpRequest.headers.hasOwnProperty(awsTracerHeaderKey)) {\n      return updateHttpRequestWithTraceHeader(processRequestWithTracing);\n    }\n    let lambdaFunctionName = process.env[awsLambdaFunctionName];\n    let traceId = process.env[X_AMZN_TRACE_ID_ENV_VAR];\n    let isNonEmptyString = __defineFunctionWithName(inputStringIsValid => typeof inputStringIsValid === \"string\" && inputStringIsValid.length > 0, \"nonEmptyString\");\n    if (isNonEmptyString(lambdaFunctionName) && isNonEmptyString(traceId)) {\n      _httpRequest.headers[AWS_TRACER_HEADER] = traceId;\n    }\n    return updateHttpRequestWithTraceHeader({\n      ...processRequestWithTracing,\n      request: _httpRequest\n    });\n  }, \"recursionDetectionMiddleware\");\n  var recursionDetectionMiddlewareOptions = {\n    step: \"build\",\n    tags: [\"RECURSION_DETECTION\"],\n    name: \"recursionDetectionMiddleware\",\n    override: true,\n    priority: \"low\"\n  };\n  var createRecursionDetectionPlugin = __defineFunctionWithName(_applyMiddlewareToStack => ({\n    applyToStack: __defineFunctionWithName(_addMiddlewareToStack => {\n      _addMiddlewareToStack.add(recursionDetectionMiddlewareFunction(_applyMiddlewareToStack), recursionDetectionMiddlewareOptions);\n    }, \"applyToStack\")\n  }), \"getRecursionDetectionPlugin\");\n});\nvar _____________________________processImageTransformation = z((initializeChecksumConfiguration, __________moduleExports) => {\n  var {\n    defineProperty: ___definePropertyWithName,\n    getOwnPropertyDescriptor: ___________getOwnPropertyDescriptor,\n    getOwnPropertyNames: __________getOwnPropertyNames\n  } = Object;\n  var ____________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___________________definePropertyWithName = (______________________________definePropertyWithName, _______________________________definePropertyWithName) => ___definePropertyWithName(______________________________definePropertyWithName, \"name\", {\n    value: _______________________________definePropertyWithName,\n    configurable: true\n  });\n  var _________defineProperties = (__________definePropertiesFromSource, _________________________________________________________________________________________________sourceObject) => {\n    for (var ______________propertyKey in _________________________________________________________________________________________________sourceObject) {\n      ___definePropertyWithName(__________definePropertiesFromSource, ______________propertyKey, {\n        get: _________________________________________________________________________________________________sourceObject[______________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var _definePropertiesFromSource = (copyPropertiesWithGetters, ________________sourceObject, propName, descriptor) => {\n    if (________________sourceObject && typeof ________________sourceObject === \"object\" || typeof ________________sourceObject === \"function\") {\n      for (let _____propertyName of __________getOwnPropertyNames(________________sourceObject)) {\n        if (!____________hasOwnProperty.call(copyPropertiesWithGetters, _____propertyName) && _____propertyName !== propName) {\n          ___definePropertyWithName(copyPropertiesWithGetters, _____propertyName, {\n            get: () => ________________sourceObject[_____propertyName],\n            enumerable: !(descriptor = ___________getOwnPropertyDescriptor(________________sourceObject, _____propertyName)) || descriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyPropertiesWithGetters;\n  };\n  var initializeModuleExportsWithChecksum = ____________definePropertiesFromSource => _definePropertiesFromSource(___definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), ____________definePropertiesFromSource);\n  var ___________moduleExports = {};\n  _________defineProperties(___________moduleExports, {\n    AlgorithmId: () => Uf0,\n    EndpointURLScheme: () => zf0,\n    FieldPosition: () => wf0,\n    HttpApiKeyAuthLocation: () => Hf0,\n    HttpAuthLocation: () => Ef0,\n    IniSectionType: () => $f0,\n    RequestHandlerProtocol: () => qf0,\n    SMITHY_CONTEXT_KEY: () => _SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => _getDefaultClientConfiguration,\n    resolveDefaultRuntimeConfig: () => _resolveChecksumConfiguration\n  });\n  __________moduleExports.exports = initializeModuleExportsWithChecksum(___________moduleExports);\n  var Ef0 = (createQueryConstants => {\n    createQueryConstants.HEADER = \"header\";\n    createQueryConstants.QUERY = \"query\";\n    return createQueryConstants;\n  })(Ef0 || {});\n  var Hf0 = (_createConstants => {\n    _createConstants.HEADER = \"header\";\n    _createConstants.QUERY = \"query\";\n    return _createConstants;\n  })(Hf0 || {});\n  var zf0 = (ProtocolConstants => {\n    ProtocolConstants.HTTP = \"http\";\n    ProtocolConstants.HTTPS = \"https\";\n    return ProtocolConstants;\n  })(zf0 || {});\n  var Uf0 = (_hashAlgorithms => {\n    _hashAlgorithms.MD5 = \"md5\";\n    _hashAlgorithms.CRC32 = \"crc32\";\n    _hashAlgorithms.CRC32C = \"crc32c\";\n    _hashAlgorithms.SHA1 = \"sha1\";\n    _hashAlgorithms.SHA256 = \"sha256\";\n    return _hashAlgorithms;\n  })(Uf0 || {});\n  var _____createChecksumAlgorithmManager = ___________________definePropertyWithName(_createChecksumAlgorithmManager => {\n    let _checksumAlgorithmsList = [];\n    if (_createChecksumAlgorithmManager.sha256 !== undefined) {\n      _checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => _createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (_createChecksumAlgorithmManager.md5 != null) {\n      _checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => _createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(checksumAlgorithm) {\n        _checksumAlgorithmsList.push(checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return _checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumConstructorsMap = ___________________definePropertyWithName(generateChecksumConstructors => {\n    let checksumConstructorsMap = {};\n    generateChecksumConstructors.checksumAlgorithms().forEach(checksumConstructor => {\n      checksumConstructorsMap[checksumConstructor.algorithmId()] = checksumConstructor.checksumConstructor();\n    });\n    return checksumConstructorsMap;\n  }, \"resolveChecksumRuntimeConfig\");\n  var _getDefaultClientConfiguration = ___________________definePropertyWithName(calculateSum => {\n    return _____createChecksumAlgorithmManager(calculateSum);\n  }, \"getDefaultClientConfiguration\");\n  var _resolveChecksumConfiguration = ___________________definePropertyWithName(__processData => {\n    return generateChecksumConstructorsMap(__processData);\n  }, \"resolveDefaultRuntimeConfig\");\n  var wf0 = (_MessageType => {\n    _MessageType[_MessageType.HEADER = 0] = \"HEADER\";\n    _MessageType[_MessageType.TRAILER = 1] = \"TRAILER\";\n    return _MessageType;\n  })(wf0 || {});\n  var _SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var $f0 = (createUserProfileSettings => {\n    createUserProfileSettings.PROFILE = \"profile\";\n    createUserProfileSettings.SSO_SESSION = \"sso-session\";\n    createUserProfileSettings.SERVICES = \"services\";\n    return createUserProfileSettings;\n  })($f0 || {});\n  var qf0 = (defineHttpProtocols => {\n    defineHttpProtocols.HTTP_0_9 = \"http/0.9\";\n    defineHttpProtocols.HTTP_1_0 = \"http/1.0\";\n    defineHttpProtocols.TDS_8_0 = \"tds/8.0\";\n    return defineHttpProtocols;\n  })(qf0 || {});\n});\nvar ______________________________processImageTransformation = z((validateAndDefineExportedProperties, ____________moduleExports) => {\n  var {\n    defineProperty: _____defineProperty,\n    getOwnPropertyDescriptor: ____________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ___________getOwnPropertyNames\n  } = Object;\n  var _____________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ____________________definePropertyWithName = (________________________________definePropertyWithName, _setObjectName) => _____defineProperty(________________________________definePropertyWithName, \"name\", {\n    value: _setObjectName,\n    configurable: true\n  });\n  var defineGetters = (____________________defineProperties, _propertyDefinition) => {\n    for (var _______________propertyKey in _propertyDefinition) {\n      _____defineProperty(____________________defineProperties, _______________propertyKey, {\n        get: _propertyDefinition[_______________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var defineExportedProperties = (_________________defineProperties, ___________________sourceObject, ___propertyKey, _____propertyDescriptor) => {\n    if (___________________sourceObject && typeof ___________________sourceObject === \"object\" || typeof ___________________sourceObject === \"function\") {\n      for (let ______propertyName of ___________getOwnPropertyNames(___________________sourceObject)) {\n        if (!_____________hasOwnProperty.call(_________________defineProperties, ______propertyName) && ______propertyName !== ___propertyKey) {\n          _____defineProperty(_________________defineProperties, ______propertyName, {\n            get: () => ___________________sourceObject[______propertyName],\n            enumerable: !(_____propertyDescriptor = ____________getOwnPropertyDescriptor(___________________sourceObject, ______propertyName)) || _____propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _________________defineProperties;\n  };\n  var createExportedModule = __defineExportedProperties => defineExportedProperties(_____defineProperty({}, \"__esModule\", {\n    value: true\n  }), __defineExportedProperties);\n  var _____________moduleExports = {};\n  defineGetters(_____________moduleExports, {\n    AlgorithmId: () => Tf0,\n    EndpointURLScheme: () => Rf0,\n    FieldPosition: () => Pf0,\n    HttpApiKeyAuthLocation: () => Of0,\n    HttpAuthLocation: () => Mf0,\n    IniSectionType: () => jf0,\n    RequestHandlerProtocol: () => Sf0,\n    SMITHY_CONTEXT_KEY: () => __SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => __getDefaultClientConfiguration,\n    resolveDefaultRuntimeConfig: () => __resolveChecksumConfiguration\n  });\n  ____________moduleExports.exports = createExportedModule(_____________moduleExports);\n  var Mf0 = (__initializeApiConstants => {\n    __initializeApiConstants.HEADER = \"header\";\n    __initializeApiConstants.QUERY = \"query\";\n    return __initializeApiConstants;\n  })(Mf0 || {});\n  var Of0 = (initializeConstants => {\n    initializeConstants.HEADER = \"header\";\n    initializeConstants.QUERY = \"query\";\n    return initializeConstants;\n  })(Of0 || {});\n  var Rf0 = (ProtocolConfig => {\n    ProtocolConfig.HTTP = \"http\";\n    ProtocolConfig.HTTPS = \"https\";\n    return ProtocolConfig;\n  })(Rf0 || {});\n  var Tf0 = (__hashAlgorithms => {\n    __hashAlgorithms.MD5 = \"md5\";\n    __hashAlgorithms.CRC32 = \"crc32\";\n    __hashAlgorithms.CRC32C = \"crc32c\";\n    __hashAlgorithms.SHA1 = \"sha1\";\n    __hashAlgorithms.SHA256 = \"sha256\";\n    return __hashAlgorithms;\n  })(Tf0 || {});\n  var _createChecksumAlgorithmProvider = ____________________definePropertyWithName(createChecksumAlgorithmProvider => {\n    let __checksumAlgorithmsList = [];\n    if (createChecksumAlgorithmProvider.sha256 !== undefined) {\n      __checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => createChecksumAlgorithmProvider.sha256\n      });\n    }\n    if (createChecksumAlgorithmProvider.md5 != null) {\n      __checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => createChecksumAlgorithmProvider.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(_checksumAlgorithm) {\n        __checksumAlgorithmsList.push(_checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return __checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumAlgorithmsMapping = ____________________definePropertyWithName(_generateChecksumAlgorithmsMap => {\n    let checksumConstructorsByAlgorithmId = {};\n    _generateChecksumAlgorithmsMap.checksumAlgorithms().forEach(_checksumConstructor => {\n      checksumConstructorsByAlgorithmId[_checksumConstructor.algorithmId()] = _checksumConstructor.checksumConstructor();\n    });\n    return checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var __getDefaultClientConfiguration = ____________________definePropertyWithName(processRo9 => {\n    return _createChecksumAlgorithmProvider(processRo9);\n  }, \"getDefaultClientConfiguration\");\n  var __resolveChecksumConfiguration = ____________________definePropertyWithName(__processInput => {\n    return generateChecksumAlgorithmsMapping(__processInput);\n  }, \"resolveDefaultRuntimeConfig\");\n  var Pf0 = (__MessageType => {\n    __MessageType[__MessageType.HEADER = 0] = \"HEADER\";\n    __MessageType[__MessageType.TRAILER = 1] = \"TRAILER\";\n    return __MessageType;\n  })(Pf0 || {});\n  var __SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var jf0 = (createUserSettings => {\n    createUserSettings.PROFILE = \"profile\";\n    createUserSettings.SSO_SESSION = \"sso-session\";\n    createUserSettings.SERVICES = \"services\";\n    return createUserSettings;\n  })(jf0 || {});\n  var Sf0 = (HttpProtocolVersions => {\n    HttpProtocolVersions.HTTP_0_9 = \"http/0.9\";\n    HttpProtocolVersions.HTTP_1_0 = \"http/1.0\";\n    HttpProtocolVersions.TDS_8_0 = \"tds/8.0\";\n    return HttpProtocolVersions;\n  })(Sf0 || {});\n});\nvar ______________imageTransformationProcessor = z((_imageTransformationHandler, ________________________moduleExports) => {\n  var {\n    defineProperty: ___________definePropertyWithName,\n    getOwnPropertyDescriptor: _________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _______________________getOwnPropertyNames\n  } = Object;\n  var ______________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _______________________definePropertyWithName = (__definePropertyWithValue, valueToDefine) => ___________definePropertyWithName(__definePropertyWithValue, \"name\", {\n    value: valueToDefine,\n    configurable: true\n  });\n  var _defineGetters = (definePropertyWithNames, propertyDefinitions) => {\n    for (var ________________propertyKey in propertyDefinitions) {\n      ___________definePropertyWithName(definePropertyWithNames, ________________propertyKey, {\n        get: propertyDefinitions[________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var assignPropertiesIfNotPresent = (copyPropertiesExcept, ______________________sourceObject, ____propertyKey, ______propertyDescriptor) => {\n    if (______________________sourceObject && typeof ______________________sourceObject === \"object\" || typeof ______________________sourceObject === \"function\") {\n      for (let _______propertyName of _______________________getOwnPropertyNames(______________________sourceObject)) {\n        if (!______________________hasOwnProperty.call(copyPropertiesExcept, _______propertyName) && _______propertyName !== ____propertyKey) {\n          ___________definePropertyWithName(copyPropertiesExcept, _______propertyName, {\n            get: () => ______________________sourceObject[_______propertyName],\n            enumerable: !(______propertyDescriptor = _________________________getOwnPropertyDescriptor(______________________sourceObject, _______propertyName)) || ______propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyPropertiesExcept;\n  };\n  var createModuleExportsWithContext = _assignPropertiesIfNotPresent => assignPropertiesIfNotPresent(___________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), _assignPropertiesIfNotPresent);\n  var contextProvider = {};\n  _defineGetters(contextProvider, {\n    getSmithyContext: () => getSmithyContext,\n    normalizeProvider: () => normalizeToPromiseProvider\n  });\n  ________________________moduleExports.exports = createModuleExportsWithContext(contextProvider);\n  var processImageTransformationResult = ______________________________processImageTransformation();\n  var getSmithyContext = _______________________definePropertyWithName(_smithyContext => _smithyContext[processImageTransformationResult.SMITHY_CONTEXT_KEY] ||= {}, \"getSmithyContext\");\n  var normalizeToPromiseProvider = _______________________definePropertyWithName(getPromiseOrFunction => {\n    if (typeof getPromiseOrFunction === \"function\") {\n      return getPromiseOrFunction;\n    }\n    let createPromise = Promise.resolve(getPromiseOrFunction);\n    return () => createPromise;\n  }, \"normalizeProvider\");\n});\nvar _validateImageOutputOptions = z((defineExportedModules, ______________moduleExports) => {\n  var {\n    defineProperty: ______defineProperty,\n    getOwnPropertyDescriptor: _____________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ____________getOwnPropertyNames\n  } = Object;\n  var hasOwnPropertyFallback = Object.prototype.hasOwnProperty;\n  var ___definePropertyWithConfig = (assignPropertyName, propertyNameSetter) => ______defineProperty(assignPropertyName, \"name\", {\n    value: propertyNameSetter,\n    configurable: true\n  });\n  var _defineExportedProperties = (___definePropertiesWithGetters, __propertyDefinition) => {\n    for (var _________________propertyKey in __propertyDefinition) {\n      ______defineProperty(___definePropertiesWithGetters, _________________propertyKey, {\n        get: __propertyDefinition[_________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var _defineObjectProperties = (copyPropertiesExcludeSymbol, _________________________sourceObject, _____propertyKey, _______propertyDescriptor) => {\n    if (_________________________sourceObject && typeof _________________________sourceObject === \"object\" || typeof _________________________sourceObject === \"function\") {\n      for (let propertyKey of ____________getOwnPropertyNames(_________________________sourceObject)) {\n        if (!hasOwnPropertyFallback.call(copyPropertiesExcludeSymbol, propertyKey) && propertyKey !== _____propertyKey) {\n          ______defineProperty(copyPropertiesExcludeSymbol, propertyKey, {\n            get: () => _________________________sourceObject[propertyKey],\n            enumerable: !(_______propertyDescriptor = _____________getOwnPropertyDescriptor(_________________________sourceObject, propertyKey)) || _______propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyPropertiesExcludeSymbol;\n  };\n  var defineExportedModuleProperties = __defineModuleExports => _defineObjectProperties(______defineProperty({}, \"__esModule\", {\n    value: true\n  }), __defineModuleExports);\n  var exportedModules = {};\n  _defineExportedProperties(exportedModules, {\n    AlgorithmId: () => mf0,\n    EndpointURLScheme: () => uf0,\n    FieldPosition: () => df0,\n    HttpApiKeyAuthLocation: () => gf0,\n    HttpAuthLocation: () => hf0,\n    IniSectionType: () => cf0,\n    RequestHandlerProtocol: () => pf0,\n    SMITHY_CONTEXT_KEY: () => ___SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => ___getDefaultClientConfiguration,\n    resolveDefaultRuntimeConfig: () => generateChecksumMapFromInput\n  });\n  ______________moduleExports.exports = defineExportedModuleProperties(exportedModules);\n  var hf0 = (initializeRequestConstants => {\n    initializeRequestConstants.HEADER = \"header\";\n    initializeRequestConstants.QUERY = \"query\";\n    return initializeRequestConstants;\n  })(hf0 || {});\n  var gf0 = (_initializeConstants => {\n    _initializeConstants.HEADER = \"header\";\n    _initializeConstants.QUERY = \"query\";\n    return _initializeConstants;\n  })(gf0 || {});\n  var uf0 = (_ProtocolConstants => {\n    _ProtocolConstants.HTTP = \"http\";\n    _ProtocolConstants.HTTPS = \"https\";\n    return _ProtocolConstants;\n  })(uf0 || {});\n  var mf0 = (setHashAlgorithms => {\n    setHashAlgorithms.MD5 = \"md5\";\n    setHashAlgorithms.CRC32 = \"crc32\";\n    setHashAlgorithms.CRC32C = \"crc32c\";\n    setHashAlgorithms.SHA1 = \"sha1\";\n    setHashAlgorithms.SHA256 = \"sha256\";\n    return setHashAlgorithms;\n  })(mf0 || {});\n  var _defineChecksumAlgorithmManager = ___definePropertyWithConfig(__createChecksumAlgorithmManager => {\n    let ___checksumAlgorithmsList = [];\n    if (__createChecksumAlgorithmManager.sha256 !== undefined) {\n      ___checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => __createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (__createChecksumAlgorithmManager.md5 != null) {\n      ___checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => __createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(__checksumAlgorithm) {\n        ___checksumAlgorithmsList.push(__checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return ___checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumMapFromAlgorithms = ___definePropertyWithConfig(generateChecksumMap => {\n    let algorithmChecksums = {};\n    generateChecksumMap.checksumAlgorithms().forEach(algorithmChecksumUpdater => {\n      algorithmChecksums[algorithmChecksumUpdater.algorithmId()] = algorithmChecksumUpdater.checksumConstructor();\n    });\n    return algorithmChecksums;\n  }, \"resolveChecksumRuntimeConfig\");\n  var ___getDefaultClientConfiguration = ___definePropertyWithConfig(getLo9Value => {\n    return _defineChecksumAlgorithmManager(getLo9Value);\n  }, \"getDefaultClientConfiguration\");\n  var generateChecksumMapFromInput = ___definePropertyWithConfig(___processInput => {\n    return generateChecksumMapFromAlgorithms(___processInput);\n  }, \"resolveDefaultRuntimeConfig\");\n  var df0 = (___MessageType => {\n    ___MessageType[___MessageType.HEADER = 0] = \"HEADER\";\n    ___MessageType[___MessageType.TRAILER = 1] = \"TRAILER\";\n    return ___MessageType;\n  })(df0 || {});\n  var ___SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var cf0 = (createUserProfileConstants => {\n    createUserProfileConstants.PROFILE = \"profile\";\n    createUserProfileConstants.SSO_SESSION = \"sso-session\";\n    createUserProfileConstants.SERVICES = \"services\";\n    return createUserProfileConstants;\n  })(cf0 || {});\n  var pf0 = (defineHttpAndProtocolVersions => {\n    defineHttpAndProtocolVersions.HTTP_0_9 = \"http/0.9\";\n    defineHttpAndProtocolVersions.HTTP_1_0 = \"http/1.0\";\n    defineHttpAndProtocolVersions.TDS_8_0 = \"tds/8.0\";\n    return defineHttpAndProtocolVersions;\n  })(pf0 || {});\n});\nvar _processImageTransform = z((initializeHttpHandlerModule, _____moduleExports) => {\n  var {\n    defineProperty: definePropertyWithName,\n    getOwnPropertyDescriptor: ______getOwnPropertyDescriptor,\n    getOwnPropertyNames: ______getOwnPropertyNames\n  } = Object;\n  var ______hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _defineFunctionName = (_________________________________definePropertyWithName, valueToAssign) => definePropertyWithName(_________________________________definePropertyWithName, \"name\", {\n    value: valueToAssign,\n    configurable: true\n  });\n  var definePropertiesWithGetters = (____definePropertiesWithGetters, __________________________________________________________________________________________________sourceObject) => {\n    for (var __________________propertyKey in __________________________________________________________________________________________________sourceObject) {\n      definePropertyWithName(____definePropertiesWithGetters, __________________propertyKey, {\n        get: __________________________________________________________________________________________________sourceObject[__________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var defineNonEnumerableProperties = (assignPropertiesToObject, ___________________________sourceObject, propertyNameToIgnore, ________propertyDescriptor) => {\n    if (___________________________sourceObject && typeof ___________________________sourceObject === \"object\" || typeof ___________________________sourceObject === \"function\") {\n      for (let ________propertyName of ______getOwnPropertyNames(___________________________sourceObject)) {\n        if (!______hasOwnProperty.call(assignPropertiesToObject, ________propertyName) && ________propertyName !== propertyNameToIgnore) {\n          definePropertyWithName(assignPropertiesToObject, ________propertyName, {\n            get: () => ___________________________sourceObject[________propertyName],\n            enumerable: !(________propertyDescriptor = ______getOwnPropertyDescriptor(___________________________sourceObject, ________propertyName)) || ________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return assignPropertiesToObject;\n  };\n  var defineModuleExports = _____defineNonEnumerableProperties => defineNonEnumerableProperties(definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), _____defineNonEnumerableProperties);\n  var ______moduleExports = {};\n  definePropertiesWithGetters(______moduleExports, {\n    Field: () => HttpField,\n    Fields: () => FieldCollection,\n    HttpRequest: () => Yt9,\n    HttpResponse: () => HttpResponse,\n    IHttpRequest: () => __validateImageOutputOptions.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => _createHttpHandlerExtensionConfiguration,\n    isValidHostname: () => _isValidIdentifier,\n    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerRuntimeConfig\n  });\n  _____moduleExports.exports = defineModuleExports(______moduleExports);\n  var _createHttpHandlerExtensionConfiguration = _defineFunctionName(_createHttpHandlerManager => {\n    return {\n      setHttpHandler(httpHandlerCallback) {\n        _createHttpHandlerManager.httpHandler = httpHandlerCallback;\n      },\n      httpHandler() {\n        return _createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(___httpClientConfig, ____httpClientConfig) {\n        _createHttpHandlerManager.httpHandler?.updateHttpClientConfig(___httpClientConfig, ____httpClientConfig);\n      },\n      httpHandlerConfigs() {\n        return _createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var resolveHttpHandlerRuntimeConfig = _defineFunctionName(_createHttpHandler => {\n    return {\n      httpHandler: _createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var __validateImageOutputOptions = _validateImageOutputOptions();\n  var HttpField = class {\n    static {\n      _defineFunctionName(this, \"Field\");\n    }\n    constructor({\n      name: _headerName,\n      kind: headerPosition = __validateImageOutputOptions.FieldPosition.HEADER,\n      values: _initialValues = []\n    }) {\n      this.name = _headerName;\n      this.kind = headerPosition;\n      this.values = _initialValues;\n    }\n    add(_addValue) {\n      this.values.push(_addValue);\n    }\n    set(_setValues) {\n      this.values = _setValues;\n    }\n    remove(removeValue) {\n      this.values = this.values.filter(_isNotEqualToA => _isNotEqualToA !== removeValue);\n    }\n    toString() {\n      return this.values.map(_formattedString => _formattedString.includes(\",\") || _formattedString.includes(\" \") ? `\"${_formattedString}\"` : _formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var FieldCollection = class {\n    constructor({\n      fields: fieldDefinitions = [],\n      encoding: _defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      fieldDefinitions.forEach(this.setField.bind(this));\n      this.encoding = _defaultEncoding;\n    }\n    static {\n      _defineFunctionName(this, \"Fields\");\n    }\n    setField(_setFieldEntry) {\n      this.entries[_setFieldEntry.name.toLowerCase()] = _setFieldEntry;\n    }\n    getField(_getFieldByKey) {\n      return this.entries[_getFieldByKey.toLowerCase()];\n    }\n    removeField(removeFieldByKey) {\n      delete this.entries[removeFieldByKey.toLowerCase()];\n    }\n    getByType(getByTypeAndKind) {\n      return Object.values(this.entries).filter(_isKindOfA => _isKindOfA.kind === getByTypeAndKind);\n    }\n  };\n  var Yt9 = class A {\n    static {\n      _defineFunctionName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObjectWithArrayValues(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObjectWithArrayValues(sourceObject) {\n    return Object.keys(sourceObject).reduce((mergeSourceWithKey, queryKey) => {\n      let valueFromSource = sourceObject[queryKey];\n      return {\n        ...mergeSourceWithKey,\n        [queryKey]: Array.isArray(valueFromSource) ? [...valueFromSource] : valueFromSource\n      };\n    }, {});\n  }\n  _defineFunctionName(cloneObjectWithArrayValues, \"cloneQuery\");\n  var HttpResponse = class {\n    static {\n      _defineFunctionName(this, \"HttpResponse\");\n    }\n    constructor(_responseObject) {\n      this.statusCode = _responseObject.statusCode;\n      this.reason = _responseObject.reason;\n      this.headers = _responseObject.headers || {};\n      this.body = _responseObject.body;\n    }\n    static isInstance(_isValidHttpResponse) {\n      if (!_isValidHttpResponse) {\n        return false;\n      }\n      let _____httpResponse = _isValidHttpResponse;\n      return typeof _____httpResponse.statusCode === \"number\" && typeof _____httpResponse.headers === \"object\";\n    }\n  };\n  function _isValidIdentifier(isValidUsername) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(isValidUsername);\n  }\n  _defineFunctionName(_isValidIdentifier, \"isValidHostname\");\n});\nvar ___________________imageTransformationProcessor = z((createDeserializerMiddleware, _________moduleExports) => {\n  var {\n    defineProperty: _definePropertyWithName,\n    getOwnPropertyDescriptor: _________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _________getOwnPropertyNames\n  } = Object;\n  var __________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var defineFunctionWithName = (___definePropertyWithValue, setPropertyValue) => _definePropertyWithName(___definePropertyWithValue, \"name\", {\n    value: setPropertyValue,\n    configurable: true\n  });\n  var ________defineProperties = (definePropertiesWithDescriptor, propertyAccessor) => {\n    for (var ___________________propertyKey in propertyAccessor) {\n      _definePropertyWithName(definePropertiesWithDescriptor, ___________________propertyKey, {\n        get: propertyAccessor[___________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesFromSource = (_definePropertiesIfNotExists, ______________________________sourceObject, propertyBlacklisted, _________propertyDescriptor) => {\n    if (______________________________sourceObject && typeof ______________________________sourceObject === \"object\" || typeof ______________________________sourceObject === \"function\") {\n      for (let _________propertyName of _________getOwnPropertyNames(______________________________sourceObject)) {\n        if (!__________hasOwnProperty.call(_definePropertiesIfNotExists, _________propertyName) && _________propertyName !== propertyBlacklisted) {\n          _definePropertyWithName(_definePropertiesIfNotExists, _________propertyName, {\n            get: () => ______________________________sourceObject[_________propertyName],\n            enumerable: !(_________propertyDescriptor = _________getOwnPropertyDescriptor(______________________________sourceObject, _________propertyName)) || _________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _definePropertiesIfNotExists;\n  };\n  var createModuleWithProperties = definePropertiesFromModule => definePropertiesFromSource(_definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), definePropertiesFromModule);\n  var serializerAndDeserializerSetup = {};\n  ________defineProperties(serializerAndDeserializerSetup, {\n    deserializerMiddleware: () => deserializerMiddleware,\n    deserializerMiddlewareOption: () => deserializerMiddlewareOptions,\n    getSerdePlugin: () => createMiddlewareStack,\n    serializerMiddleware: () => serializerMiddlewareFunction,\n    serializerMiddlewareOption: () => _serializerMiddlewareOptions\n  });\n  _________moduleExports.exports = createModuleWithProperties(serializerAndDeserializerSetup);\n  var ___________________________________________________processImageTransformation = _processImageTransform();\n  var deserializerMiddleware = defineFunctionWithName((handleApiResponse, processResponse) => (apiRequestHandler, loggerObject) => async handleApiRequest => {\n    let {\n      response: apiResponse\n    } = await apiRequestHandler(handleApiRequest);\n    try {\n      let processedResponse = await processResponse(apiResponse, handleApiResponse);\n      return {\n        response: apiResponse,\n        output: processedResponse\n      };\n    } catch (errorObject) {\n      Object.defineProperty(errorObject, \"$response\", {\n        value: apiResponse\n      });\n      if (!(\"$metadata\" in errorObject)) {\n        try {\n          errorObject.message += `\n  Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;\n        } catch (__error) {\n          if (!loggerObject.logger || loggerObject.logger?.constructor?.name === \"NoOpLogger\") {\n            console.warn(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          } else {\n            loggerObject.logger?.warn?.(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          }\n        }\n        if (typeof errorObject.$responseBodyText !== \"undefined\") {\n          if (errorObject.$response) {\n            errorObject.$response.body = errorObject.$responseBodyText;\n          }\n        }\n        try {\n          if (___________________________________________________processImageTransformation.HttpResponse.isInstance(apiResponse)) {\n            let {\n              headers: errorHandling = {}\n            } = apiResponse;\n            let responseHeadersArray = Object.entries(errorHandling);\n            errorObject.$metadata = {\n              httpStatusCode: apiResponse.statusCode,\n              requestId: findHeaderInResponseHeaders(/^x-[\\w-]+-request-?id$/, responseHeadersArray),\n              extendedRequestId: findHeaderInResponseHeaders(/^x-[\\w-]+-id-2$/, responseHeadersArray),\n              cfId: findHeaderInResponseHeaders(/^x-[\\w-]+-cf-id$/, responseHeadersArray)\n            };\n          }\n        } catch (____________________error) {}\n      }\n      throw errorObject;\n    }\n  }, \"deserializerMiddleware\");\n  var findHeaderInResponseHeaders = defineFunctionWithName((findMatchingValue, _findMatchingElement) => {\n    return (_findMatchingElement.find(([matchAgainstFindValue]) => {\n      return matchAgainstFindValue.match(findMatchingValue);\n    }) || [undefined, undefined])[1];\n  }, \"findHeader\");\n  var serializerMiddlewareFunction = defineFunctionWithName((createRequestHandler, processInputAndEndpoint) => (_processRequest, endpoint) => async __processRequest => {\n    let endpointProvider = createRequestHandler;\n    let _getEndpointUrl = endpoint.endpointV2?.url && endpointProvider.urlParser ? async () => endpointProvider.urlParser(endpoint.endpointV2.url) : endpointProvider.endpoint;\n    if (!_getEndpointUrl) {\n      throw Error(\"No valid endpoint provider available.\");\n    }\n    let fetchDataWithEndpoint = await processInputAndEndpoint(__processRequest.input, {\n      ...createRequestHandler,\n      endpoint: _getEndpointUrl\n    });\n    return _processRequest({\n      ...__processRequest,\n      request: fetchDataWithEndpoint\n    });\n  }, \"serializerMiddleware\");\n  var deserializerMiddlewareOptions = {\n    name: \"deserializerMiddleware\",\n    step: \"deserialize\",\n    tags: [\"DESERIALIZER\"],\n    override: true\n  };\n  var _serializerMiddlewareOptions = {\n    name: \"serializerMiddleware\",\n    step: \"serialize\",\n    tags: [\"SERIALIZER\"],\n    override: true\n  };\n  function createMiddlewareStack(____inputData, dataProcessingFunction, queueProcessor) {\n    return {\n      applyToStack: middlewareManager => {\n        middlewareManager.add(deserializerMiddleware(____inputData, queueProcessor), deserializerMiddlewareOptions);\n        middlewareManager.add(serializerMiddlewareFunction(____inputData, dataProcessingFunction), _serializerMiddlewareOptions);\n      }\n    };\n  }\n  defineFunctionWithName(createMiddlewareStack, \"getSerdePlugin\");\n});\nvar updateMetadata = z((configureHttpHandler, httpHandlerExtensionConfig) => {\n  var {\n    defineProperty: ____defineProperty,\n    getOwnPropertyDescriptor: _______getOwnPropertyDescriptor,\n    getOwnPropertyNames: _______getOwnPropertyNames\n  } = Object;\n  var _______hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ________________definePropertyWithName = (__________________________________definePropertyWithName, _____setFunctionName) => ____defineProperty(__________________________________definePropertyWithName, \"name\", {\n    value: _____setFunctionName,\n    configurable: true\n  });\n  var assignProperties = (_____________________defineProperties, ___propertyDefinition) => {\n    for (var ____________________propertyKey in ___propertyDefinition) {\n      ____defineProperty(_____________________defineProperties, ____________________propertyKey, {\n        get: ___propertyDefinition[____________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesFromObject = (_copyPropertiesWithGetters, _________________________________sourceObject, __________________________________sourceObject, __________propertyDescriptor) => {\n    if (_________________________________sourceObject && typeof _________________________________sourceObject === \"object\" || typeof _________________________________sourceObject === \"function\") {\n      for (let __________propertyName of _______getOwnPropertyNames(_________________________________sourceObject)) {\n        if (!_______hasOwnProperty.call(_copyPropertiesWithGetters, __________propertyName) && __________propertyName !== __________________________________sourceObject) {\n          ____defineProperty(_copyPropertiesWithGetters, __________propertyName, {\n            get: () => _________________________________sourceObject[__________propertyName],\n            enumerable: !(__________propertyDescriptor = _______getOwnPropertyDescriptor(_________________________________sourceObject, __________propertyName)) || __________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyPropertiesWithGetters;\n  };\n  var defineExportProperties = _____definePropertiesFromObject => definePropertiesFromObject(____defineProperty({}, \"__esModule\", {\n    value: true\n  }), _____definePropertiesFromObject);\n  var httpHandlerExtensions = {};\n  assignProperties(httpHandlerExtensions, {\n    Field: () => FieldDefinition,\n    Fields: () => HttpFieldsManager,\n    HttpRequest: () => Ot9,\n    HttpResponse: () => _HttpResponse,\n    IHttpRequest: () => __________________imageTransformationProcessor.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => _getHttpHandlerExtensionConfiguration,\n    isValidHostname: () => _isValidUsername,\n    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerConfig\n  });\n  httpHandlerExtensionConfig.exports = defineExportProperties(httpHandlerExtensions);\n  var _getHttpHandlerExtensionConfiguration = ________________definePropertyWithName(__createHttpHandlerManager => {\n    return {\n      setHttpHandler(_httpHandler) {\n        __createHttpHandlerManager.httpHandler = _httpHandler;\n      },\n      httpHandler() {\n        return __createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(_____httpClientConfig, httpClientConfigOptions) {\n        __createHttpHandlerManager.httpHandler?.updateHttpClientConfig(_____httpClientConfig, httpClientConfigOptions);\n      },\n      httpHandlerConfigs() {\n        return __createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var resolveHttpHandlerConfig = ________________definePropertyWithName(__createHttpHandler => {\n    return {\n      httpHandler: __createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var __________________imageTransformationProcessor = _____________________________processImageTransformation();\n  var FieldDefinition = class {\n    static {\n      ________________definePropertyWithName(this, \"Field\");\n    }\n    constructor({\n      name: _name,\n      kind: fieldPositionType = __________________imageTransformationProcessor.FieldPosition.HEADER,\n      values: __initialValues = []\n    }) {\n      this.name = _name;\n      this.kind = fieldPositionType;\n      this.values = __initialValues;\n    }\n    add(__addValue) {\n      this.values.push(__addValue);\n    }\n    set(__setValues) {\n      this.values = __setValues;\n    }\n    remove(_removeValue) {\n      this.values = this.values.filter(isDifferentFromA => isDifferentFromA !== _removeValue);\n    }\n    toString() {\n      return this.values.map(__formattedString => __formattedString.includes(\",\") || __formattedString.includes(\" \") ? `\"${__formattedString}\"` : __formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpFieldsManager = class {\n    constructor({\n      fields: fieldList = [],\n      encoding: __defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      fieldList.forEach(this.setField.bind(this));\n      this.encoding = __defaultEncoding;\n    }\n    static {\n      ________________definePropertyWithName(this, \"Fields\");\n    }\n    setField(__setFieldEntry) {\n      this.entries[__setFieldEntry.name.toLowerCase()] = __setFieldEntry;\n    }\n    getField(getFieldByEntryKey) {\n      return this.entries[getFieldByEntryKey.toLowerCase()];\n    }\n    removeField(_removeFieldByKey) {\n      delete this.entries[_removeFieldByKey.toLowerCase()];\n    }\n    getByType(getByType) {\n      return Object.values(this.entries).filter(__isKindOfA => __isKindOfA.kind === getByType);\n    }\n  };\n  var Ot9 = class A {\n    static {\n      ________________definePropertyWithName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = _cloneObjectWithArrayValues(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function _cloneObjectWithArrayValues(inputObject) {\n    return Object.keys(inputObject).reduce((mergeInputWithExisting, _____key) => {\n      let ______inputValue = inputObject[_____key];\n      return {\n        ...mergeInputWithExisting,\n        [_____key]: Array.isArray(______inputValue) ? [...______inputValue] : ______inputValue\n      };\n    }, {});\n  }\n  ________________definePropertyWithName(_cloneObjectWithArrayValues, \"cloneQuery\");\n  var _HttpResponse = class {\n    static {\n      ________________definePropertyWithName(this, \"HttpResponse\");\n    }\n    constructor(____response) {\n      this.statusCode = ____response.statusCode;\n      this.reason = ____response.reason;\n      this.headers = ____response.headers || {};\n      this.body = ____response.body;\n    }\n    static isInstance(__isValidHttpResponse) {\n      if (!__isValidHttpResponse) {\n        return false;\n      }\n      let checkHttpResponse = __isValidHttpResponse;\n      return typeof checkHttpResponse.statusCode === \"number\" && typeof checkHttpResponse.headers === \"object\";\n    }\n  };\n  function _isValidUsername(_____inputString) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(_____inputString);\n  }\n  ________________definePropertyWithName(_isValidUsername, \"isValidHostname\");\n});\nvar ________________imageProcessingPipeline = z((validateArrayBuffer, defineArrayBufferChecker) => {\n  var {\n    defineProperty: ______________definePropertyWithName,\n    getOwnPropertyDescriptor: ___________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: __________________________getOwnPropertyNames\n  } = Object;\n  var ________________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ____setFunctionName = (__definePropertyWithNameAndValue, ____definePropertyWithValue) => ______________definePropertyWithName(__definePropertyWithNameAndValue, \"name\", {\n    value: ____definePropertyWithValue,\n    configurable: true\n  });\n  var assignGetterProperties = (_____definePropertiesWithGetters, ___________________________________________________________________________________________________sourceObject) => {\n    for (var _____________________propertyKey in ___________________________________________________________________________________________________sourceObject) {\n      ______________definePropertyWithName(_____definePropertiesWithGetters, _____________________propertyKey, {\n        get: ___________________________________________________________________________________________________sourceObject[_____________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesIfNotDefined = (_copyPropertiesFromSourceToTarget, _____________________________________sourceObject, ___excludedPropertyName, _descriptor) => {\n    if (_____________________________________sourceObject && typeof _____________________________________sourceObject === \"object\" || typeof _____________________________________sourceObject === \"function\") {\n      for (let ___________propertyName of __________________________getOwnPropertyNames(_____________________________________sourceObject)) {\n        if (!________________________hasOwnProperty.call(_copyPropertiesFromSourceToTarget, ___________propertyName) && ___________propertyName !== ___excludedPropertyName) {\n          ______________definePropertyWithName(_copyPropertiesFromSourceToTarget, ___________propertyName, {\n            get: () => _____________________________________sourceObject[___________propertyName],\n            enumerable: !(_descriptor = ___________________________getOwnPropertyDescriptor(_____________________________________sourceObject, ___________propertyName)) || _descriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyPropertiesFromSourceToTarget;\n  };\n  var createArrayBufferModule = __copyPropertiesIfNotDefined => copyPropertiesIfNotDefined(______________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), __copyPropertiesIfNotDefined);\n  var arrayBufferUtils = {};\n  assignGetterProperties(arrayBufferUtils, {\n    isArrayBuffer: () => isArrayBufferChecker\n  });\n  defineArrayBufferChecker.exports = createArrayBufferModule(arrayBufferUtils);\n  var isArrayBufferChecker = ____setFunctionName(inputIsArrayBuffer => typeof ArrayBuffer === \"function\" && inputIsArrayBuffer instanceof ArrayBuffer || Object.prototype.toString.call(inputIsArrayBuffer) === \"[object ArrayBuffer]\", \"isArrayBuffer\");\n});\nvar ________________________________________processImageTransformation = z((_________________imageProcessingPipeline, initializeBufferConversion) => {\n  var {\n    defineProperty: _________definePropertyWithName,\n    getOwnPropertyDescriptor: ______________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ____________________getOwnPropertyNames\n  } = Object;\n  var ____________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___defineFunctionWithName = (___________________________________definePropertyWithName, _____definePropertyWithValue) => _________definePropertyWithName(___________________________________definePropertyWithName, \"name\", {\n    value: _____definePropertyWithValue,\n    configurable: true\n  });\n  var _______________defineProperties = (createPropertyWithGetters, propertySetter) => {\n    for (var ______________________propertyKey in propertySetter) {\n      _________definePropertyWithName(createPropertyWithGetters, ______________________propertyKey, {\n        get: propertySetter[______________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesIfNotExist = (__copyPropertiesFromSource, ______________________________________sourceObject, propertyToCopy, __descriptor) => {\n    if (______________________________________sourceObject && typeof ______________________________________sourceObject === \"object\" || typeof ______________________________________sourceObject === \"function\") {\n      for (let ____________propertyName of ____________________getOwnPropertyNames(______________________________________sourceObject)) {\n        if (!____________________hasOwnProperty.call(__copyPropertiesFromSource, ____________propertyName) && ____________propertyName !== propertyToCopy) {\n          _________definePropertyWithName(__copyPropertiesFromSource, ____________propertyName, {\n            get: () => ______________________________________sourceObject[____________propertyName],\n            enumerable: !(__descriptor = ______________________getOwnPropertyDescriptor(______________________________________sourceObject, ____________propertyName)) || __descriptor.enumerable\n          });\n        }\n      }\n    }\n    return __copyPropertiesFromSource;\n  };\n  var createBufferConversionModule = _definePropertiesIfNotExist => definePropertiesIfNotExist(_________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), _definePropertiesIfNotExist);\n  var bufferConversionHandlers = {};\n  _______________defineProperties(bufferConversionHandlers, {\n    fromArrayBuffer: () => _createBufferFromArrayBuffer,\n    fromString: () => convertStringToBuffer\n  });\n  initializeBufferConversion.exports = createBufferConversionModule(bufferConversionHandlers);\n  var initializeImageProcessingPipeline = ________________imageProcessingPipeline();\n  var bufferLibrary = EA(\"buffer\");\n  var _createBufferFromArrayBuffer = ___defineFunctionWithName((createBufferFromArrayBuffer, arrayBufferOffset = 0, byteArraySliceLength = createBufferFromArrayBuffer.byteLength - arrayBufferOffset) => {\n    if (!(0, initializeImageProcessingPipeline.isArrayBuffer)(createBufferFromArrayBuffer)) {\n      throw TypeError(`The \"input\" argument must be ArrayBuffer. Received type ${typeof createBufferFromArrayBuffer} (${createBufferFromArrayBuffer})`);\n    }\n    return bufferLibrary.Buffer.from(createBufferFromArrayBuffer, arrayBufferOffset, byteArraySliceLength);\n  }, \"fromArrayBuffer\");\n  var convertStringToBuffer = ___defineFunctionWithName((inputStringToBuffer, encoding) => {\n    if (typeof inputStringToBuffer !== \"string\") {\n      throw TypeError(`The \"input\" argument must be of type string. Received type ${typeof inputStringToBuffer} (${inputStringToBuffer})`);\n    }\n    if (encoding) {\n      return bufferLibrary.Buffer.from(inputStringToBuffer, encoding);\n    } else {\n      return bufferLibrary.Buffer.from(inputStringToBuffer);\n    }\n  }, \"fromString\");\n});\nvar __processImageTransform = z(base64Decoder => {\n  Object.defineProperty(base64Decoder, \"__esModule\", {\n    value: true\n  });\n  base64Decoder.fromBase64 = undefined;\n  var processImageBase64Transformation = ________________________________________processImageTransformation();\n  var base64ValidationRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n  var decodeBase64ToUint8Array = base64ToUint8Array => {\n    if (base64ToUint8Array.length * 3 % 4 !== 0) {\n      throw TypeError(\"Incorrect padding on base64 string.\");\n    }\n    if (!base64ValidationRegex.exec(base64ToUint8Array)) {\n      throw TypeError(\"Invalid base64 string.\");\n    }\n    let decodedBase64ImageBuffer = (0, processImageBase64Transformation.fromString)(base64ToUint8Array, \"base64\");\n    return new Uint8Array(decodedBase64ImageBuffer.buffer, decodedBase64ImageBuffer.byteOffset, decodedBase64ImageBuffer.byteLength);\n  };\n  base64Decoder.fromBase64 = decodeBase64ToUint8Array;\n});\nvar ___________________imageProcessingPipeline = z((utf8ConversionFunctions, utf8Utilities) => {\n  var {\n    defineProperty: _______definePropertyWithName,\n    getOwnPropertyDescriptor: _____________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _getObjectOwnPropertyNames\n  } = Object;\n  var ___________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var definePropertyWithNameForExport = (____________________________________definePropertyWithName, ______definePropertyWithValue) => _______definePropertyWithName(____________________________________definePropertyWithName, \"name\", {\n    value: ______definePropertyWithValue,\n    configurable: true\n  });\n  var _____________defineProperties = (______definePropertiesWithGetters, _propertyAccessor) => {\n    for (var _______________________propertyKey in _propertyAccessor) {\n      _______definePropertyWithName(______definePropertiesWithGetters, _______________________propertyKey, {\n        get: _propertyAccessor[_______________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var ___definePropertiesFromSource = (copyObjectPropertiesIfNotExists, _________________________________________sourceObject, ____excludedPropertyName, ___________propertyDescriptor) => {\n    if (_________________________________________sourceObject && typeof _________________________________________sourceObject === \"object\" || typeof _________________________________________sourceObject === \"function\") {\n      for (let _____________propertyName of _getObjectOwnPropertyNames(_________________________________________sourceObject)) {\n        if (!___________________hasOwnProperty.call(copyObjectPropertiesIfNotExists, _____________propertyName) && _____________propertyName !== ____excludedPropertyName) {\n          _______definePropertyWithName(copyObjectPropertiesIfNotExists, _____________propertyName, {\n            get: () => _________________________________________sourceObject[_____________propertyName],\n            enumerable: !(___________propertyDescriptor = _____________________getOwnPropertyDescriptor(_________________________________________sourceObject, _____________propertyName)) || ___________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyObjectPropertiesIfNotExists;\n  };\n  var createUtf8ConversionsModule = _____________definePropertiesFromSource => ___definePropertiesFromSource(_______definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), _____________definePropertiesFromSource);\n  var utf8Conversions = {};\n  _____________defineProperties(utf8Conversions, {\n    fromUtf8: () => convertFromUtf8,\n    toUint8Array: () => __convertToUint8Array,\n    toUtf8: () => convertToUtf8String\n  });\n  utf8Utilities.exports = createUtf8ConversionsModule(utf8Conversions);\n  var _____processImageTransformationFunction = ________________________________________processImageTransformation();\n  var convertFromUtf8 = definePropertyWithNameForExport(convertStringToUint8Array => {\n    let stringToUint8Array = (0, _____processImageTransformationFunction.fromString)(convertStringToUint8Array, \"utf8\");\n    return new Uint8Array(stringToUint8Array.buffer, stringToUint8Array.byteOffset, stringToUint8Array.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n  }, \"fromUtf8\");\n  var __convertToUint8Array = definePropertyWithNameForExport(convertToUint8Array => {\n    if (typeof convertToUint8Array === \"string\") {\n      return convertFromUtf8(convertToUint8Array);\n    }\n    if (ArrayBuffer.isView(convertToUint8Array)) {\n      return new Uint8Array(convertToUint8Array.buffer, convertToUint8Array.byteOffset, convertToUint8Array.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n    }\n    return new Uint8Array(convertToUint8Array);\n  }, \"toUint8Array\");\n  var convertToUtf8String = definePropertyWithNameForExport(convertToUtf8 => {\n    if (typeof convertToUtf8 === \"string\") {\n      return convertToUtf8;\n    }\n    if (typeof convertToUtf8 !== \"object\" || typeof convertToUtf8.byteOffset !== \"number\" || typeof convertToUtf8.byteLength !== \"number\") {\n      throw Error(\"@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.\");\n    }\n    return (0, _____processImageTransformationFunction.fromArrayBuffer)(convertToUtf8.buffer, convertToUtf8.byteOffset, convertToUtf8.byteLength).toString(\"utf8\");\n  }, \"toUtf8\");\n});\nvar _____________________imageProcessingPipeline = z(Base64Encoder => {\n  Object.defineProperty(Base64Encoder, \"__esModule\", {\n    value: true\n  });\n  Base64Encoder.toBase64 = undefined;\n  var processImageToBase64 = ________________________________________processImageTransformation();\n  var _________________________________imageProcessingPipeline = ___________________imageProcessingPipeline();\n  var encodeToBase64 = convertInputToBase64 => {\n    let inputBuffer;\n    if (typeof convertInputToBase64 === \"string\") {\n      inputBuffer = (0, _________________________________imageProcessingPipeline.fromUtf8)(convertInputToBase64);\n    } else {\n      inputBuffer = convertInputToBase64;\n    }\n    if (typeof inputBuffer !== \"object\" || typeof inputBuffer.byteOffset !== \"number\" || typeof inputBuffer.byteLength !== \"number\") {\n      throw Error(\"@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.\");\n    }\n    return (0, processImageToBase64.fromArrayBuffer)(inputBuffer.buffer, inputBuffer.byteOffset, inputBuffer.byteLength).toString(\"base64\");\n  };\n  Base64Encoder.toBase64 = encodeToBase64;\n});\nvar _____________imageProcessor = z((defineAndExportModule, moduleExporter) => {\n  var {\n    defineProperty: __________defineProperty,\n    getOwnPropertyDescriptor: ____________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ___________________________getOwnPropertyNames\n  } = Object;\n  var _________________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var copyPropertiesToTarget = (_____definePropertiesFromSource, ____________________________________________sourceObject, excludePropertyKey, ____________propertyDescriptor) => {\n    if (____________________________________________sourceObject && typeof ____________________________________________sourceObject === \"object\" || typeof ____________________________________________sourceObject === \"function\") {\n      for (let ______________propertyName of ___________________________getOwnPropertyNames(____________________________________________sourceObject)) {\n        if (!_________________________hasOwnProperty.call(_____definePropertiesFromSource, ______________propertyName) && ______________propertyName !== excludePropertyKey) {\n          __________defineProperty(_____definePropertiesFromSource, ______________propertyName, {\n            get: () => ____________________________________________sourceObject[______________propertyName],\n            enumerable: !(____________propertyDescriptor = ____________________________getOwnPropertyDescriptor(____________________________________________sourceObject, ______________propertyName)) || ____________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _____definePropertiesFromSource;\n  };\n  var copyDefaultProperties = (__________________________________________________________________________________________________________sourceObject, ___________________________________________________________________________________________________________sourceObject, ____________________________________________________________________________________________________________sourceObject) => {\n    copyPropertiesToTarget(__________________________________________________________________________________________________________sourceObject, ___________________________________________________________________________________________________________sourceObject, \"default\");\n    return ____________________________________________________________________________________________________________sourceObject && copyPropertiesToTarget(____________________________________________________________________________________________________________sourceObject, ___________________________________________________________________________________________________________sourceObject, \"default\");\n  };\n  var createModuleExport = _sourceModule => copyPropertiesToTarget(__________defineProperty({}, \"__esModule\", {\n    value: true\n  }), _sourceModule);\n  var __________________________moduleExports = {};\n  moduleExporter.exports = createModuleExport(__________________________moduleExports);\n  copyDefaultProperties(__________________________moduleExports, __processImageTransform(), moduleExporter.exports);\n  copyDefaultProperties(__________________________moduleExports, _____________________imageProcessingPipeline(), moduleExporter.exports);\n});\nvar ____________________________________imageProcessingPipeline = z(ChecksumStreamModule => {\n  Object.defineProperty(ChecksumStreamModule, \"__esModule\", {\n    value: true\n  });\n  ChecksumStreamModule.ChecksumStream = undefined;\n  var _________________imageProcessor = _____________imageProcessor();\n  var createChecksumStream = EA(\"stream\");\n  class _ChecksumStream extends createChecksumStream.Duplex {\n    constructor({\n      expectedChecksum: expectedChecksumValue,\n      checksum: computedChecksum,\n      source: _inputStream,\n      checksumSourceLocation: checksumSourceLocation,\n      base64Encoder: base64EncoderFunction\n    }) {\n      super();\n      if (typeof _inputStream.pipe === \"function\") {\n        this.source = _inputStream;\n      } else {\n        throw Error(`@smithy/util-stream: unsupported source type ${_inputStream?.constructor?.name ?? _inputStream} in ChecksumStream.`);\n      }\n      this.base64Encoder = base64EncoderFunction ?? _________________imageProcessor.toBase64;\n      this.expectedChecksum = expectedChecksumValue;\n      this.checksum = computedChecksum;\n      this.checksumSourceLocation = checksumSourceLocation;\n      this.source.pipe(this);\n    }\n    _read(readData) {}\n    _write(dataToWrite, dataWriteHandler, _____handleError) {\n      try {\n        this.checksum.update(dataToWrite);\n        this.push(dataToWrite);\n      } catch (_______________error) {\n        return _____handleError(_______________error);\n      }\n      return _____handleError();\n    }\n    async _final(________________callbackFunction) {\n      try {\n        let _computedChecksum = await this.checksum.digest();\n        let encodedChecksum = this.base64Encoder(_computedChecksum);\n        if (this.expectedChecksum !== encodedChecksum) {\n          return ________________callbackFunction(Error(`Checksum mismatch: expected \"${this.expectedChecksum}\" but received \"${encodedChecksum}\" in response header \"${this.checksumSourceLocation}\".`));\n        }\n      } catch (________________error) {\n        return ________________callbackFunction(________________error);\n      }\n      this.push(null);\n      return ________________callbackFunction();\n    }\n  }\n  ChecksumStreamModule.ChecksumStream = _ChecksumStream;\n});\nvar processImageTransformatio = z(streamAndBlobUtils => {\n  Object.defineProperty(streamAndBlobUtils, \"__esModule\", {\n    value: true\n  });\n  streamAndBlobUtils.isBlob = streamAndBlobUtils.isReadableStream = undefined;\n  var isReadableStream = isInstanceOfReadableStream => {\n    return typeof ReadableStream === \"function\" && (isInstanceOfReadableStream?.constructor?.name === ReadableStream.name || isInstanceOfReadableStream instanceof ReadableStream);\n  };\n  streamAndBlobUtils.isReadableStream = isReadableStream;\n  var isBlob = _isBlob => {\n    return typeof Blob === \"function\" && (_isBlob?.constructor?.name === Blob.name || _isBlob instanceof Blob);\n  };\n  streamAndBlobUtils.isBlob = isBlob;\n});\nvar ___validateOutputFilePath = z(ChecksumStream => {\n  Object.defineProperty(ChecksumStream, \"__esModule\", {\n    value: true\n  });\n  ChecksumStream.ChecksumStream = undefined;\n  var StreamReader = typeof ReadableStream === \"function\" ? ReadableStream : function () {};\n  class FileStreamReader extends StreamReader {}\n  ChecksumStream.ChecksumStream = FileStreamReader;\n});\nvar _____processImagePipeline = z(_createChecksumStream => {\n  Object.defineProperty(_createChecksumStream, \"__esModule\", {\n    value: true\n  });\n  _createChecksumStream.createChecksumStream = undefined;\n  var initializeChecksumProcessor = _____________imageProcessor();\n  var __createChecksumStream = processImageTransformatio();\n  var ____validateOutputFilePath = ___validateOutputFilePath();\n  var ___createChecksumStream = ({\n    expectedChecksum: expectedChecksum,\n    checksum: checksumProcessor,\n    source: sourceStream,\n    checksumSourceLocation: checksumSourceHeader,\n    base64Encoder: base64EncodeFunction\n  }) => {\n    if (!(0, __createChecksumStream.isReadableStream)(sourceStream)) {\n      throw Error(`@smithy/util-stream: unsupported source type ${sourceStream?.constructor?.name ?? sourceStream} in ChecksumStream.`);\n    }\n    let _base64EncodeFunction = base64EncodeFunction ?? initializeChecksumProcessor.toBase64;\n    if (typeof TransformStream !== \"function\") {\n      throw Error(\"@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.\");\n    }\n    let checksumTransformStream = new TransformStream({\n      start() {},\n      async transform(dataTransform, enqueueData) {\n        checksumProcessor.update(dataTransform);\n        enqueueData.enqueue(dataTransform);\n      },\n      async flush(_callbackHandler) {\n        let digestResult = await checksumProcessor.digest();\n        let verifiedChecksum = _base64EncodeFunction(digestResult);\n        if (expectedChecksum !== verifiedChecksum) {\n          let checksumError = Error(`Checksum mismatch: expected \"${expectedChecksum}\" but received \"${verifiedChecksum}\" in response header \"${checksumSourceHeader}\".`);\n          _callbackHandler.error(checksumError);\n        } else {\n          _callbackHandler.terminate();\n        }\n      }\n    });\n    sourceStream.pipeThrough(checksumTransformStream);\n    let checksumStream = checksumTransformStream.readable;\n    Object.setPrototypeOf(checksumStream, ____validateOutputFilePath.ChecksumStream.prototype);\n    return checksumStream;\n  };\n  _createChecksumStream.createChecksumStream = ___createChecksumStream;\n});\nvar __________________imageProcessor = z(___________________________moduleExports => {\n  Object.defineProperty(___________________________moduleExports, \"__esModule\", {\n    value: true\n  });\n  ___________________________moduleExports.createChecksumStream = processInputStream;\n  var imageTransformationProcess = processImageTransformatio();\n  var __ChecksumStream = ____________________________________imageProcessingPipeline();\n  var ______processImagePipeline = _____processImagePipeline();\n  function processInputStream(input) {\n    if (typeof ReadableStream === \"function\" && (0, imageTransformationProcess.isReadableStream)(input.source)) {\n      return (0, ______processImagePipeline.createChecksumStream)(input);\n    }\n    return new __ChecksumStream.ChecksumStream(input);\n  }\n});\nvar __updateImageFormatBasedOnOptions = z(ByteArrayModule => {\n  Object.defineProperty(ByteArrayModule, \"__esModule\", {\n    value: true\n  });\n  ByteArrayModule.ByteArrayCollector = undefined;\n  class ByteArrayCollector {\n    constructor(_allocatedByteArray) {\n      this.allocByteArray = _allocatedByteArray;\n      this.byteLength = 0;\n      this.byteArrays = [];\n    }\n    push(pushByteArray) {\n      this.byteArrays.push(pushByteArray);\n      this.byteLength += pushByteArray.byteLength;\n    }\n    flush() {\n      if (this.byteArrays.length === 1) {\n        let byteArrayToReturn = this.byteArrays[0];\n        this.reset();\n        return byteArrayToReturn;\n      }\n      let allocatedByteArray = this.allocByteArray(this.byteLength);\n      let byteArrayOffset = 0;\n      for (let byteArrayIndex = 0; byteArrayIndex < this.byteArrays.length; ++byteArrayIndex) {\n        let currentByteArray = this.byteArrays[byteArrayIndex];\n        allocatedByteArray.set(currentByteArray, byteArrayOffset);\n        byteArrayOffset += currentByteArray.byteLength;\n      }\n      this.reset();\n      return allocatedByteArray;\n    }\n    reset() {\n      this.byteArrays = [];\n      this.byteLength = 0;\n    }\n  }\n  ByteArrayModule.ByteArrayCollector = ByteArrayCollector;\n});\nvar _________________________________________processImageTransformation = z(ReadableBufferedStream => {\n  Object.defineProperty(ReadableBufferedStream, \"__esModule\", {\n    value: true\n  });\n  ReadableBufferedStream.createBufferedReadable = undefined;\n  ReadableBufferedStream.createBufferedReadableStream = processStream;\n  ReadableBufferedStream.merge = updateValueInArray;\n  ReadableBufferedStream.flush = flushStreamByIndex;\n  ReadableBufferedStream.sizeOf = getArrayByteLength;\n  ReadableBufferedStream.modeOf = getBufferType;\n  var updateImageFormat = __updateImageFormatBasedOnOptions();\n  function processStream(processStreamChunks, minChunkSize, logger) {\n    let reader = processStreamChunks.getReader();\n    let hasBufferedChunks = false;\n    let totalBufferedSize = 0;\n    let chunkBuffer = [\"\", new updateImageFormat.ByteArrayCollector(byteArrayData => new Uint8Array(byteArrayData))];\n    let _currentChunkIndex = -1;\n    let readAndProcessStreamChunk = async processStreamChunk => {\n      let {\n        value: readAndProcessStream,\n        done: ____isStreamDone\n      } = await reader.read();\n      let currentChunkValue = readAndProcessStream;\n      if (____isStreamDone) {\n        if (_currentChunkIndex !== -1) {\n          let processChunk = flushStreamByIndex(chunkBuffer, _currentChunkIndex);\n          if (getArrayByteLength(processChunk) > 0) {\n            processStreamChunk.enqueue(processChunk);\n          }\n        }\n        processStreamChunk.close();\n      } else {\n        let bufferTypeIndex = getBufferType(currentChunkValue, false);\n        if (_currentChunkIndex !== bufferTypeIndex) {\n          if (_currentChunkIndex >= 0) {\n            processStreamChunk.enqueue(flushStreamByIndex(chunkBuffer, _currentChunkIndex));\n          }\n          _currentChunkIndex = bufferTypeIndex;\n        }\n        if (_currentChunkIndex === -1) {\n          processStreamChunk.enqueue(currentChunkValue);\n          return;\n        }\n        let currentDataByteLength = getArrayByteLength(currentChunkValue);\n        totalBufferedSize += currentDataByteLength;\n        let currentChunkByteLength = getArrayByteLength(chunkBuffer[_currentChunkIndex]);\n        if (currentDataByteLength >= minChunkSize && currentChunkByteLength === 0) {\n          processStreamChunk.enqueue(currentChunkValue);\n        } else {\n          let _processChunk = updateValueInArray(chunkBuffer, _currentChunkIndex, currentChunkValue);\n          if (!hasBufferedChunks && totalBufferedSize > minChunkSize * 2) {\n            hasBufferedChunks = true;\n            if (logger !== null && logger !== undefined) {\n              logger.warn(`@smithy/util-stream - stream chunk size ${currentDataByteLength} is below threshold of ${minChunkSize}, automatically buffering.`);\n            }\n          }\n          if (_processChunk >= minChunkSize) {\n            processStreamChunk.enqueue(flushStreamByIndex(chunkBuffer, _currentChunkIndex));\n          } else {\n            await readAndProcessStreamChunk(processStreamChunk);\n          }\n        }\n      }\n    };\n    return new ReadableStream({\n      pull: readAndProcessStreamChunk\n    });\n  }\n  ReadableBufferedStream.createBufferedReadable = processStream;\n  function updateValueInArray(updateArrayWithValue, actionType, valueToAdd) {\n    switch (actionType) {\n      case 0:\n        updateArrayWithValue[0] += valueToAdd;\n        return getArrayByteLength(updateArrayWithValue[0]);\n      case 1:\n      case 2:\n        updateArrayWithValue[actionType].push(valueToAdd);\n        return getArrayByteLength(updateArrayWithValue[actionType]);\n    }\n  }\n  function flushStreamByIndex(streamOrItem, indexOrOperation) {\n    switch (indexOrOperation) {\n      case 0:\n        let firstStreamItem = streamOrItem[0];\n        streamOrItem[0] = \"\";\n        return firstStreamItem;\n      case 1:\n      case 2:\n        return streamOrItem[indexOrOperation].flush();\n    }\n    throw Error(`@smithy/util-stream - invalid index ${indexOrOperation} given to flush()`);\n  }\n  function getArrayByteLength(getArrayOrStringLength) {\n    return getArrayOrStringLength?.byteLength ?? getArrayOrStringLength?.length ?? 0;\n  }\n  function getBufferType(dataTypeChecker, isBufferSupported = true) {\n    if (isBufferSupported && typeof Buffer !== \"undefined\" && dataTypeChecker instanceof Buffer) {\n      return 2;\n    }\n    if (dataTypeChecker instanceof Uint8Array) {\n      return 1;\n    }\n    if (typeof dataTypeChecker === \"string\") {\n      return 0;\n    }\n    return -1;\n  }\n});\nvar ____________________imageTransformationProcessor = z(streamUtils => {\n  Object.defineProperty(streamUtils, \"__esModule\", {\n    value: true\n  });\n  streamUtils.createBufferedReadable = processImageStream;\n  var streamModule = EA(\"node:stream\");\n  var ___updateImageFormatBasedOnOptions = __updateImageFormatBasedOnOptions();\n  var _createImageProcessor = _________________________________________processImageTransformation();\n  var ______________________________________________processImageTransformation = processImageTransformatio();\n  function processImageStream(inputStream, thresholdSize, warningLogger) {\n    if ((0, ______________________________________________processImageTransformation.isReadableStream)(inputStream)) {\n      return (0, _createImageProcessor.createBufferedReadableStream)(inputStream, thresholdSize, warningLogger);\n    }\n    let bufferedReadableStream = new streamModule.Readable({\n      read() {}\n    });\n    let isWarningLogged = false;\n    let processedBytesCount = 0;\n    let bufferCollectors = [\"\", new ___updateImageFormatBasedOnOptions.ByteArrayCollector(byteArray => new Uint8Array(byteArray)), new ___updateImageFormatBasedOnOptions.ByteArrayCollector(byteArrayBuffer => Buffer.from(new Uint8Array(byteArrayBuffer)))];\n    let currentModeIndex = -1;\n    inputStream.on(\"data\", processImageChunk => {\n      let computedMode = (0, _createImageProcessor.modeOf)(processImageChunk, true);\n      if (currentModeIndex !== computedMode) {\n        if (currentModeIndex >= 0) {\n          bufferedReadableStream.push((0, _createImageProcessor.flush)(bufferCollectors, currentModeIndex));\n        }\n        currentModeIndex = computedMode;\n      }\n      if (currentModeIndex === -1) {\n        bufferedReadableStream.push(processImageChunk);\n        return;\n      }\n      let currentChunkSize = (0, _createImageProcessor.sizeOf)(processImageChunk);\n      processedBytesCount += currentChunkSize;\n      let _currentChunkSize = (0, _createImageProcessor.sizeOf)(bufferCollectors[currentModeIndex]);\n      if (currentChunkSize >= thresholdSize && _currentChunkSize === 0) {\n        bufferedReadableStream.push(processImageChunk);\n      } else {\n        let mergedSize = (0, _createImageProcessor.merge)(bufferCollectors, currentModeIndex, processImageChunk);\n        if (!isWarningLogged && processedBytesCount > thresholdSize * 2) {\n          isWarningLogged = true;\n          if (warningLogger !== null && warningLogger !== undefined) {\n            warningLogger.warn(`@smithy/util-stream - stream chunk size ${currentChunkSize} is below threshold of ${thresholdSize}, automatically buffering.`);\n          }\n        }\n        if (mergedSize >= thresholdSize) {\n          bufferedReadableStream.push((0, _createImageProcessor.flush)(bufferCollectors, currentModeIndex));\n        }\n      }\n    });\n    inputStream.on(\"end\", () => {\n      if (currentModeIndex !== -1) {\n        let _flushedData = (0, _createImageProcessor.flush)(bufferCollectors, currentModeIndex);\n        if ((0, _createImageProcessor.sizeOf)(_flushedData) > 0) {\n          bufferedReadableStream.push(_flushedData);\n        }\n      }\n      bufferedReadableStream.push(null);\n    });\n    return bufferedReadableStream;\n  }\n});\nvar ______imageProcessor = z(awsChunkedEncodingStream => {\n  Object.defineProperty(awsChunkedEncodingStream, \"__esModule\", {\n    value: true\n  });\n  awsChunkedEncodingStream.getAwsChunkedEncodingStream = undefined;\n  var createAwsChunkedEncodingStream = EA(\"stream\");\n  var createChunkedEncodingStream = (processStreamWithChecksum, streamProcessingOptions) => {\n    let {\n      base64Encoder: base64Encoder,\n      bodyLengthChecker: calculateBodyLength,\n      checksumAlgorithmFn: checksumCalculationFunction,\n      checksumLocationName: checksumLocationKey,\n      streamHasher: streamHasherFunc\n    } = streamProcessingOptions;\n    let isEncodingEnabled = base64Encoder !== undefined && checksumCalculationFunction !== undefined && checksumLocationKey !== undefined && streamHasherFunc !== undefined;\n    let __computedChecksum = isEncodingEnabled ? streamHasherFunc(checksumCalculationFunction, processStreamWithChecksum) : undefined;\n    let chunkedEncodingStream = new createAwsChunkedEncodingStream.Readable({\n      read: () => {}\n    });\n    processStreamWithChecksum.on(\"data\", processChunkedEncoding => {\n      let bodyLength = calculateBodyLength(processChunkedEncoding) || 0;\n      chunkedEncodingStream.push(`${bodyLength.toString(16)}\\r\n`);\n      chunkedEncodingStream.push(processChunkedEncoding);\n      chunkedEncodingStream.push(`\\r\n`);\n    });\n    processStreamWithChecksum.on(\"end\", async () => {\n      chunkedEncodingStream.push(`0\\r\n`);\n      if (isEncodingEnabled) {\n        let fetchDataAndLog = base64Encoder(await __computedChecksum);\n        chunkedEncodingStream.push(`${checksumLocationKey}:${fetchDataAndLog}\\r\n`);\n        chunkedEncodingStream.push(`\\r\n`);\n      }\n      chunkedEncodingStream.push(null);\n    });\n    return chunkedEncodingStream;\n  };\n  awsChunkedEncodingStream.getAwsChunkedEncodingStream = createChunkedEncodingStream;\n});\nvar _______________________________processImageTransformation = z(streamReaderModule => {\n  Object.defineProperty(streamReaderModule, \"__esModule\", {\n    value: true\n  });\n  streamReaderModule.headStream = readDataChunks;\n  async function readDataChunks(readDataIntoBuffer, byteLimit) {\n    let totalBytesRead = 0;\n    let dataChunks = [];\n    let streamReader = readDataIntoBuffer.getReader();\n    let isReadingComplete = false;\n    while (!isReadingComplete) {\n      let {\n        done: isDone,\n        value: chunk\n      } = await streamReader.read();\n      if (chunk) {\n        dataChunks.push(chunk);\n        totalBytesRead += chunk?.byteLength ?? 0;\n      }\n      if (totalBytesRead >= byteLimit) {\n        break;\n      }\n      isReadingComplete = isDone;\n    }\n    streamReader.releaseLock();\n    let bufferArray = new Uint8Array(Math.min(byteLimit, totalBytesRead));\n    let writePointer = 0;\n    for (let dataChunk of dataChunks) {\n      if (dataChunk.byteLength > bufferArray.byteLength - writePointer) {\n        bufferArray.set(dataChunk.subarray(0, bufferArray.byteLength - writePointer), writePointer);\n        break;\n      } else {\n        bufferArray.set(dataChunk, writePointer);\n      }\n      writePointer += dataChunk.length;\n    }\n    return bufferArray;\n  }\n});\nvar _______________imageTransformationProcessor = z(imageStreamHandler => {\n  Object.defineProperty(imageStreamHandler, \"__esModule\", {\n    value: true\n  });\n  imageStreamHandler.headStream = undefined;\n  var StreamWritable = EA(\"stream\");\n  var _imageTransformProcessor = _______________________________processImageTransformation();\n  var ________________________________________________processImageTransformation = processImageTransformatio();\n  var streamToBufferWithLimit = (___inputStream, maxBytesToWrite) => {\n    if ((0, ________________________________________________processImageTransformation.isReadableStream)(___inputStream)) {\n      return (0, _imageTransformProcessor.headStream)(___inputStream, maxBytesToWrite);\n    }\n    return new Promise((_processBufferedData, ____handleError) => {\n      let bufferedStreamWriter = new BufferedStreamWriter();\n      bufferedStreamWriter.limit = maxBytesToWrite;\n      ___inputStream.pipe(bufferedStreamWriter);\n      ___inputStream.on(\"error\", currentState => {\n        bufferedStreamWriter.end();\n        ____handleError(currentState);\n      });\n      bufferedStreamWriter.on(\"error\", ____handleError);\n      bufferedStreamWriter.on(\"finish\", function () {\n        let combinedBuffer = new Uint8Array(Buffer.concat(this.buffers));\n        _processBufferedData(combinedBuffer);\n      });\n    });\n  };\n  imageStreamHandler.headStream = streamToBufferWithLimit;\n  class BufferedStreamWriter extends StreamWritable.Writable {\n    constructor() {\n      super(...arguments);\n      this.buffers = [];\n      this.limit = Infinity;\n      this.bytesBuffered = 0;\n    }\n    _write(writeBufferedData, _____________callbackFunction, __callback) {\n      this.buffers.push(writeBufferedData);\n      this.bytesBuffered += writeBufferedData.byteLength ?? 0;\n      if (this.bytesBuffered >= this.limit) {\n        let bytesOverLimit = this.bytesBuffered - this.limit;\n        let lastBufferedChunk = this.buffers[this.buffers.length - 1];\n        this.buffers[this.buffers.length - 1] = lastBufferedChunk.subarray(0, lastBufferedChunk.byteLength - bytesOverLimit);\n        this.emit(\"finish\");\n      }\n      __callback();\n    }\n  }\n});\nvar ________________________________processImageTransformation = z((initializeApiConfigurations, _______________moduleExports) => {\n  var {\n    defineProperty: ____definePropertyWithName,\n    getOwnPropertyDescriptor: ______________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _____________getOwnPropertyNames\n  } = Object;\n  var hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var _____________________definePropertyWithName = (_____________________________________definePropertyWithName, valueSetter) => ____definePropertyWithName(_____________________________________definePropertyWithName, \"name\", {\n    value: valueSetter,\n    configurable: true\n  });\n  var definePropertiesFrom = (_______definePropertiesWithGetters, ___________________________propertyDescriptor) => {\n    for (var ________________________propertyKey in ___________________________propertyDescriptor) {\n      ____definePropertyWithName(_______definePropertiesWithGetters, ________________________propertyKey, {\n        get: ___________________________propertyDescriptor[________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var copyProperties = (_copyPropertiesIfNotDefined, _______________________________________________sourceObject, _____excludedPropertyName, _____________propertyDescriptor) => {\n    if (_______________________________________________sourceObject && typeof _______________________________________________sourceObject === \"object\" || typeof _______________________________________________sourceObject === \"function\") {\n      for (let _______________propertyName of _____________getOwnPropertyNames(_______________________________________________sourceObject)) {\n        if (!hasOwnPropertyCheck.call(_copyPropertiesIfNotDefined, _______________propertyName) && _______________propertyName !== _____excludedPropertyName) {\n          ____definePropertyWithName(_copyPropertiesIfNotDefined, _______________propertyName, {\n            get: () => _______________________________________________sourceObject[_______________propertyName],\n            enumerable: !(_____________propertyDescriptor = ______________getOwnPropertyDescriptor(_______________________________________________sourceObject, _______________propertyName)) || _____________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyPropertiesIfNotDefined;\n  };\n  var initializeExportedModule = importedModule => copyProperties(____definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), importedModule);\n  var __exportedModule = {};\n  definePropertiesFrom(__exportedModule, {\n    AlgorithmId: () => Dg0,\n    EndpointURLScheme: () => Kg0,\n    FieldPosition: () => Eg0,\n    HttpApiKeyAuthLocation: () => Vg0,\n    HttpAuthLocation: () => Cg0,\n    IniSectionType: () => Hg0,\n    RequestHandlerProtocol: () => zg0,\n    SMITHY_CONTEXT_KEY: () => SMITHY_CONTEXT_IDENTIFIER,\n    getDefaultClientConfiguration: () => ____getDefaultClientConfiguration,\n    resolveDefaultRuntimeConfig: () => mapChecksumConstructorByAlgorithm\n  });\n  _______________moduleExports.exports = initializeExportedModule(__exportedModule);\n  var Cg0 = (createQueryHeaderConstants => {\n    createQueryHeaderConstants.HEADER = \"header\";\n    createQueryHeaderConstants.QUERY = \"query\";\n    return createQueryHeaderConstants;\n  })(Cg0 || {});\n  var Vg0 = (___initializeApiConstants => {\n    ___initializeApiConstants.HEADER = \"header\";\n    ___initializeApiConstants.QUERY = \"query\";\n    return ___initializeApiConstants;\n  })(Vg0 || {});\n  var Kg0 = (_ProtocolConfig => {\n    _ProtocolConfig.HTTP = \"http\";\n    _ProtocolConfig.HTTPS = \"https\";\n    return _ProtocolConfig;\n  })(Kg0 || {});\n  var Dg0 = (_setHashAlgorithms => {\n    _setHashAlgorithms.MD5 = \"md5\";\n    _setHashAlgorithms.CRC32 = \"crc32\";\n    _setHashAlgorithms.CRC32C = \"crc32c\";\n    _setHashAlgorithms.SHA1 = \"sha1\";\n    _setHashAlgorithms.SHA256 = \"sha256\";\n    return _setHashAlgorithms;\n  })(Dg0 || {});\n  var createChecksumAlgorithmHandlerWithProperties = _____________________definePropertyWithName(createChecksumAlgorithmHandler => {\n    let ____checksumAlgorithmsList = [];\n    if (createChecksumAlgorithmHandler.sha256 !== undefined) {\n      ____checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => createChecksumAlgorithmHandler.sha256\n      });\n    }\n    if (createChecksumAlgorithmHandler.md5 != null) {\n      ____checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => createChecksumAlgorithmHandler.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(addChecksumAlgorithm) {\n        ____checksumAlgorithmsList.push(addChecksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return ____checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumConstructorMap = _____________________definePropertyWithName(_generateChecksumMap => {\n    let _checksumConstructorsByAlgorithmId = {};\n    _generateChecksumMap.checksumAlgorithms().forEach(checksumConstructorByAlgorithmId => {\n      _checksumConstructorsByAlgorithmId[checksumConstructorByAlgorithmId.algorithmId()] = checksumConstructorByAlgorithmId.checksumConstructor();\n    });\n    return _checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var ____getDefaultClientConfiguration = _____________________definePropertyWithName(____processInput => {\n    return createChecksumAlgorithmHandlerWithProperties(____processInput);\n  }, \"getDefaultClientConfiguration\");\n  var mapChecksumConstructorByAlgorithm = _____________________definePropertyWithName(___processData => {\n    return generateChecksumConstructorMap(___processData);\n  }, \"resolveDefaultRuntimeConfig\");\n  var Eg0 = (StatusTypes => {\n    StatusTypes[StatusTypes.HEADER = 0] = \"HEADER\";\n    StatusTypes[StatusTypes.TRAILER = 1] = \"TRAILER\";\n    return StatusTypes;\n  })(Eg0 || {});\n  var SMITHY_CONTEXT_IDENTIFIER = \"__smithy_context\";\n  var Hg0 = (defineConstants => {\n    defineConstants.PROFILE = \"profile\";\n    defineConstants.SSO_SESSION = \"sso-session\";\n    defineConstants.SERVICES = \"services\";\n    return defineConstants;\n  })(Hg0 || {});\n  var zg0 = (HTTPVersion => {\n    HTTPVersion.HTTP_0_9 = \"http/0.9\";\n    HTTPVersion.HTTP_1_0 = \"http/1.0\";\n    HTTPVersion.TDS_8_0 = \"tds/8.0\";\n    return HTTPVersion;\n  })(zg0 || {});\n});\nvar __________________________________________processImageTransformation = z((setupHttpHandlerExtensionConfiguration, _______moduleExports) => {\n  var {\n    defineProperty: _definePropertyWithConfig,\n    getOwnPropertyDescriptor: ________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ________getOwnPropertyNames\n  } = Object;\n  var ________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __definePropertyWithConfig = (configurePropertyWithName, newValue) => _definePropertyWithConfig(configurePropertyWithName, \"name\", {\n    value: newValue,\n    configurable: true\n  });\n  var _______defineProperties = (definePropertiesWithConfig, properties) => {\n    for (var _________________________propertyKey in properties) {\n      _definePropertyWithConfig(definePropertiesWithConfig, _________________________propertyKey, {\n        get: properties[_________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var copyOwnProperties = (___copyPropertiesFromSource, __________________________________________________sourceObject, ______propertyKey, ______________propertyDescriptor) => {\n    if (__________________________________________________sourceObject && typeof __________________________________________________sourceObject === \"object\" || typeof __________________________________________________sourceObject === \"function\") {\n      for (let ________________propertyName of ________getOwnPropertyNames(__________________________________________________sourceObject)) {\n        if (!________hasOwnProperty.call(___copyPropertiesFromSource, ________________propertyName) && ________________propertyName !== ______propertyKey) {\n          _definePropertyWithConfig(___copyPropertiesFromSource, ________________propertyName, {\n            get: () => __________________________________________________sourceObject[________________propertyName],\n            enumerable: !(______________propertyDescriptor = ________getOwnPropertyDescriptor(__________________________________________________sourceObject, ________________propertyName)) || ______________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return ___copyPropertiesFromSource;\n  };\n  var createHttpHandlerModule = ______copyProperties => copyOwnProperties(_definePropertyWithConfig({}, \"__esModule\", {\n    value: true\n  }), ______copyProperties);\n  var _httpHandlerExports = {};\n  _______defineProperties(_httpHandlerExports, {\n    Field: () => _HttpField,\n    Fields: () => HttpFieldCollection,\n    HttpRequest: () => XA4,\n    HttpResponse: () => HttpResponseClass,\n    IHttpRequest: () => createHttpRequestInstance.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => __createHttpHandlerExtensionConfiguration,\n    isValidHostname: () => __isValidIdentifier,\n    resolveHttpHandlerRuntimeConfig: () => _resolveHttpHandlerConfig\n  });\n  _______moduleExports.exports = createHttpHandlerModule(_httpHandlerExports);\n  var __createHttpHandlerExtensionConfiguration = __definePropertyWithConfig(___createHttpHandlerManager => {\n    return {\n      setHttpHandler(__httpHandler) {\n        ___createHttpHandlerManager.httpHandler = __httpHandler;\n      },\n      httpHandler() {\n        return ___createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(______httpClientConfig, clientConfig) {\n        ___createHttpHandlerManager.httpHandler?.updateHttpClientConfig(______httpClientConfig, clientConfig);\n      },\n      httpHandlerConfigs() {\n        return ___createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var _resolveHttpHandlerConfig = __definePropertyWithConfig(___createHttpHandler => {\n    return {\n      httpHandler: ___createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var createHttpRequestInstance = ________________________________processImageTransformation();\n  var _HttpField = class {\n    static {\n      __definePropertyWithConfig(this, \"Field\");\n    }\n    constructor({\n      name: __headerName,\n      kind: _fieldPosition = createHttpRequestInstance.FieldPosition.HEADER,\n      values: ___initialValues = []\n    }) {\n      this.name = __headerName;\n      this.kind = _fieldPosition;\n      this.values = ___initialValues;\n    }\n    add(___addValue) {\n      this.values.push(___addValue);\n    }\n    set(___setValues) {\n      this.values = ___setValues;\n    }\n    remove(__removeValue) {\n      this.values = this.values.filter(_isDifferentFromA => _isDifferentFromA !== __removeValue);\n    }\n    toString() {\n      return this.values.map(___formattedString => ___formattedString.includes(\",\") || ___formattedString.includes(\" \") ? `\"${___formattedString}\"` : ___formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpFieldCollection = class {\n    constructor({\n      fields: inputFields = [],\n      encoding: ___defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      inputFields.forEach(this.setField.bind(this));\n      this.encoding = ___defaultEncoding;\n    }\n    static {\n      __definePropertyWithConfig(this, \"Fields\");\n    }\n    setField(setFieldByEntry) {\n      this.entries[setFieldByEntry.name.toLowerCase()] = setFieldByEntry;\n    }\n    getField(__getFieldByKey) {\n      return this.entries[__getFieldByKey.toLowerCase()];\n    }\n    removeField(removeFieldByName) {\n      delete this.entries[removeFieldByName.toLowerCase()];\n    }\n    getByType(_getByType) {\n      return Object.values(this.entries).filter(isKindOfTypeA => isKindOfTypeA.kind === _getByType);\n    }\n  };\n  var XA4 = class A {\n    static {\n      __definePropertyWithConfig(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObjectWithArrays(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObjectWithArrays(createShallowCopy) {\n    return Object.keys(createShallowCopy).reduce((combineWithShallowCopy, ______key) => {\n      let shallowCopyOfQ = createShallowCopy[______key];\n      return {\n        ...combineWithShallowCopy,\n        [______key]: Array.isArray(shallowCopyOfQ) ? [...shallowCopyOfQ] : shallowCopyOfQ\n      };\n    }, {});\n  }\n  __definePropertyWithConfig(cloneObjectWithArrays, \"cloneQuery\");\n  var HttpResponseClass = class {\n    static {\n      __definePropertyWithConfig(this, \"HttpResponse\");\n    }\n    constructor(httpResponseOptions) {\n      this.statusCode = httpResponseOptions.statusCode;\n      this.reason = httpResponseOptions.reason;\n      this.headers = httpResponseOptions.headers || {};\n      this.body = httpResponseOptions.body;\n    }\n    static isInstance(_isHttpResponse) {\n      if (!_isHttpResponse) {\n        return false;\n      }\n      let __response = _isHttpResponse;\n      return typeof __response.statusCode === \"number\" && typeof __response.headers === \"object\";\n    }\n  };\n  function __isValidIdentifier(___isValidIdentifier) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(___isValidIdentifier);\n  }\n  __definePropertyWithConfig(__isValidIdentifier, \"isValidHostname\");\n});\nvar _processImageTransformationFunction = z((exportModule, _________________________moduleExports) => {\n  var {\n    defineProperty: ____________definePropertyWithName,\n    getOwnPropertyDescriptor: getOwnPropertyDescriptorInsteadFA4,\n    getOwnPropertyNames: ________________________getOwnPropertyNames\n  } = Object;\n  var _______________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var definePropertyWithNameAndValue = (___definePropertyWithNameAndValue, _______definePropertyWithValue) => ____________definePropertyWithName(___definePropertyWithNameAndValue, \"name\", {\n    value: _______definePropertyWithValue,\n    configurable: true\n  });\n  var ________________defineProperties = (__definePropertyForObject, ___________definePropertiesFromSource) => {\n    for (var __________________________propertyKey in ___________definePropertiesFromSource) {\n      ____________definePropertyWithName(__definePropertyForObject, __________________________propertyKey, {\n        get: ___________definePropertiesFromSource[__________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var ____defineNonEnumerableProperties = (defineProxyProperties, _____________________________________________________sourceObject, property, _______________propertyDescriptor) => {\n    if (_____________________________________________________sourceObject && typeof _____________________________________________________sourceObject === \"object\" || typeof _____________________________________________________sourceObject === \"function\") {\n      for (let _________________propertyName of ________________________getOwnPropertyNames(_____________________________________________________sourceObject)) {\n        if (!_______________________hasOwnProperty.call(defineProxyProperties, _________________propertyName) && _________________propertyName !== property) {\n          ____________definePropertyWithName(defineProxyProperties, _________________propertyName, {\n            get: () => _____________________________________________________sourceObject[_________________propertyName],\n            enumerable: !(_______________propertyDescriptor = getOwnPropertyDescriptorInsteadFA4(_____________________________________________________sourceObject, _________________propertyName)) || _______________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return defineProxyProperties;\n  };\n  var createNonEnumerableProperties = ______defineNonEnumerableProperties => ____defineNonEnumerableProperties(____________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), ______defineNonEnumerableProperties);\n  var exportedUriUtils = {};\n  ________________defineProperties(exportedUriUtils, {\n    escapeUri: () => escapeUriFn,\n    escapeUriPath: () => escapeUriPathFn\n  });\n  _________________________moduleExports.exports = createNonEnumerableProperties(exportedUriUtils);\n  var escapeUriFn = definePropertyWithNameAndValue(urlEncodeAndTransform => encodeURIComponent(urlEncodeAndTransform).replace(/[!'()*]/g, convertCharacterToHexadecimal), \"escapeUri\");\n  var convertCharacterToHexadecimal = definePropertyWithNameAndValue(getHexadecimalRepresentation => `%${getHexadecimalRepresentation.charCodeAt(0).toString(16).toUpperCase()}`, \"hexEncode\");\n  var escapeUriPathFn = definePropertyWithNameAndValue(splitAndTransformPath => splitAndTransformPath.split(\"/\").map(escapeUriFn).join(\"/\"), \"escapeUriPath\");\n});\nvar imageProcessingTransformation = z((buildQueryStringModule, _buildQueryStringModule) => {\n  var {\n    defineProperty: __________definePropertyWithName,\n    getOwnPropertyDescriptor: _______________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _____________________getOwnPropertyNames\n  } = Object;\n  var _____________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ____defineFunctionName = (____definePropertyWithNameAndValue, _valueSetter) => __________definePropertyWithName(____definePropertyWithNameAndValue, \"name\", {\n    value: _valueSetter,\n    configurable: true\n  });\n  var associateProperties = (________________________definePropertyWithName, _________________________definePropertyWithName) => {\n    for (var ___________________________propertyKey in _________________________definePropertyWithName) {\n      __________definePropertyWithName(________________________definePropertyWithName, ___________________________propertyKey, {\n        get: _________________________definePropertyWithName[___________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var ___defineNonEnumerableProperties = (assignPropertiesIfNotOwned, ________________________________________________________sourceObject, _______propertyKey, ___descriptor) => {\n    if (________________________________________________________sourceObject && typeof ________________________________________________________sourceObject === \"object\" || typeof ________________________________________________________sourceObject === \"function\") {\n      for (let _propertyKey of _____________________getOwnPropertyNames(________________________________________________________sourceObject)) {\n        if (!_____________________hasOwnProperty.call(assignPropertiesIfNotOwned, _propertyKey) && _propertyKey !== _______propertyKey) {\n          __________definePropertyWithName(assignPropertiesIfNotOwned, _propertyKey, {\n            get: () => ________________________________________________________sourceObject[_propertyKey],\n            enumerable: !(___descriptor = _______________________getOwnPropertyDescriptor(________________________________________________________sourceObject, _propertyKey)) || ___descriptor.enumerable\n          });\n        }\n      }\n    }\n    return assignPropertiesIfNotOwned;\n  };\n  var createQueryStringBuilder = _______defineNonEnumerableProperties => ___defineNonEnumerableProperties(__________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), _______defineNonEnumerableProperties);\n  var queryStringBuilder = {};\n  associateProperties(queryStringBuilder, {\n    buildQueryString: () => serializeQueryParamsToString\n  });\n  _buildQueryStringModule.exports = createQueryStringBuilder(queryStringBuilder);\n  var ___processImageTransformationFunction = _processImageTransformationFunction();\n  function serializeQueryParamsToString(serializeQueryParams) {\n    let queryParamStringArray = [];\n    for (let _queryParamKey of Object.keys(serializeQueryParams).sort()) {\n      let queryParamValue = serializeQueryParams[_queryParamKey];\n      _queryParamKey = (0, ___processImageTransformationFunction.escapeUri)(_queryParamKey);\n      if (Array.isArray(queryParamValue)) {\n        for (let ________index = 0, queryParamCount = queryParamValue.length; ________index < queryParamCount; ________index++) {\n          queryParamStringArray.push(`${_queryParamKey}=${(0, ___processImageTransformationFunction.escapeUri)(queryParamValue[________index])}`);\n        }\n      } else {\n        let ___index = _queryParamKey;\n        if (queryParamValue || typeof queryParamValue === \"string\") {\n          ___index += `=${(0, ___processImageTransformationFunction.escapeUri)(queryParamValue)}`;\n        }\n        queryParamStringArray.push(___index);\n      }\n    }\n    return queryParamStringArray.join(\"&\");\n  }\n  ____defineFunctionName(serializeQueryParamsToString, \"buildQueryString\");\n});\nvar processAndExportImageTransformation = z((handleHttpRequest, nodeHttpHandler) => {\n  var {\n    create: createObject,\n    defineProperty: definePropertyWithDescriptor,\n    getOwnPropertyDescriptor: getOwnPropertyDescriptorFromObject,\n    getOwnPropertyNames: _getOwnPropertyNames,\n    getPrototypeOf: getPrototypeOfObject\n  } = Object;\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var setFunctionName = (________definePropertyWithValue, _propertyValue) => definePropertyWithDescriptor(________definePropertyWithValue, \"name\", {\n    value: _propertyValue,\n    configurable: true\n  });\n  var _defineProperties = (________definePropertiesWithGetters, ____________________________________________________________________________________________________sourceObject) => {\n    for (var ____________________________propertyKey in ____________________________________________________________________________________________________sourceObject) {\n      definePropertyWithDescriptor(________definePropertiesWithGetters, ____________________________propertyKey, {\n        get: ____________________________________________________________________________________________________sourceObject[____________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesFromSource = (_copyPropertiesExcept, ___________________________________________________________sourceObject, ______excludedPropertyName, ________________propertyDescriptor) => {\n    if (___________________________________________________________sourceObject && typeof ___________________________________________________________sourceObject === \"object\" || typeof ___________________________________________________________sourceObject === \"function\") {\n      for (let __________________propertyName of _getOwnPropertyNames(___________________________________________________________sourceObject)) {\n        if (!_hasOwnProperty.call(_copyPropertiesExcept, __________________propertyName) && __________________propertyName !== ______excludedPropertyName) {\n          definePropertyWithDescriptor(_copyPropertiesExcept, __________________propertyName, {\n            get: () => ___________________________________________________________sourceObject[__________________propertyName],\n            enumerable: !(________________propertyDescriptor = getOwnPropertyDescriptorFromObject(___________________________________________________________sourceObject, __________________propertyName)) || ________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyPropertiesExcept;\n  };\n  var _initializeModule = (createOrUpdateObject, sourceModule, ___targetObject) => {\n    if (createOrUpdateObject != null) {\n      ___targetObject = createObject(getPrototypeOfObject(createOrUpdateObject));\n    } else {\n      ___targetObject = {};\n    }\n    return copyPropertiesFromSource(sourceModule || !createOrUpdateObject || !createOrUpdateObject.__esModule ? definePropertyWithDescriptor(___targetObject, \"default\", {\n      value: createOrUpdateObject,\n      enumerable: true\n    }) : ___targetObject, createOrUpdateObject);\n  };\n  var transformExportedNodeHttpHandler = _____copyPropertiesFromSource => copyPropertiesFromSource(definePropertyWithDescriptor({}, \"__esModule\", {\n    value: true\n  }), _____copyPropertiesFromSource);\n  var nodeHttpHandlerExports = {};\n  _defineProperties(nodeHttpHandlerExports, {\n    DEFAULT_REQUEST_TIMEOUT: () => __defaultRequestTimeout,\n    NodeHttp2Handler: () => dA4,\n    NodeHttpHandler: () => hA4,\n    streamCollector: () => streamDataCollector\n  });\n  nodeHttpHandler.exports = transformExportedNodeHttpHandler(nodeHttpHandlerExports);\n  var initializeHttpResponseProcessor = __________________________________________processImageTransformation();\n  var _imageProcessingTransformation = imageProcessingTransformation();\n  var httpAgent = EA(\"http\");\n  var HttpsAgentInstance = EA(\"https\");\n  var commonNetworkErrors = [\"ECONNRESET\", \"EPIPE\", \"ETIMEDOUT\"];\n  var transformHeadersToString = setFunctionName(convertObjectValuesToString => {\n    let processedData = {};\n    for (let _key of Object.keys(convertObjectValuesToString)) {\n      let __value = convertObjectValuesToString[_key];\n      processedData[_key] = Array.isArray(__value) ? __value.join(\",\") : __value;\n    }\n    return processedData;\n  }, \"getTransformedHeaders\");\n  var timeoutHandler = {\n    setTimeout: (executeAfterDelay, delayExecution) => setTimeout(executeAfterDelay, delayExecution),\n    clearTimeout: timeoutId => clearTimeout(timeoutId)\n  };\n  var DEFAULT_REQUEST_TIMEOUT = 1000;\n  var setConnectionTimeoutHandler = setFunctionName((handleSocketConnectionTimeout, handleSocketTimeout, timeoutDuration = 0) => {\n    if (!timeoutDuration) {\n      return -1;\n    }\n    let registerSocketTimeout = setFunctionName(initiateSocketConnectionTimeout => {\n      let socketConnectionTimeoutHandle = timeoutHandler.setTimeout(() => {\n        handleSocketConnectionTimeout.destroy();\n        handleSocketTimeout(Object.assign(Error(`Socket timed out without establishing a connection within ${timeoutDuration} ms`), {\n          name: \"TimeoutError\"\n        }));\n      }, timeoutDuration - initiateSocketConnectionTimeout);\n      let handleSocketConnection = setFunctionName(connectionHandler => {\n        if (connectionHandler?.connecting) {\n          connectionHandler.on(\"connect\", () => {\n            timeoutHandler.clearTimeout(socketConnectionTimeoutHandle);\n          });\n        } else {\n          timeoutHandler.clearTimeout(socketConnectionTimeoutHandle);\n        }\n      }, \"doWithSocket\");\n      if (handleSocketConnectionTimeout.socket) {\n        handleSocketConnection(handleSocketConnectionTimeout.socket);\n      } else {\n        handleSocketConnectionTimeout.on(\"socket\", handleSocketConnection);\n      }\n    }, \"registerTimeout\");\n    if (timeoutDuration < 2000) {\n      registerSocketTimeout(0);\n      return 0;\n    }\n    return timeoutHandler.setTimeout(registerSocketTimeout.bind(null, DEFAULT_REQUEST_TIMEOUT), DEFAULT_REQUEST_TIMEOUT);\n  }, \"setConnectionTimeout\");\n  var DEFAULT_SOCKET_TIMEOUT = 3000;\n  var _setSocketKeepAlive = setFunctionName((setSocketKeepAlive, {\n    keepAlive: shouldKeepSocketAlive,\n    keepAliveMsecs: keepAliveTimeout\n  }, socketTimeout = DEFAULT_SOCKET_TIMEOUT) => {\n    if (shouldKeepSocketAlive !== true) {\n      return -1;\n    }\n    let registerKeepAliveListener = setFunctionName(() => {\n      if (setSocketKeepAlive.socket) {\n        setSocketKeepAlive.socket.setKeepAlive(shouldKeepSocketAlive, keepAliveTimeout || 0);\n      } else {\n        setSocketKeepAlive.on(\"socket\", socketManager => {\n          socketManager.setKeepAlive(shouldKeepSocketAlive, keepAliveTimeout || 0);\n        });\n      }\n    }, \"registerListener\");\n    if (socketTimeout === 0) {\n      registerKeepAliveListener();\n      return 0;\n    }\n    return timeoutHandler.setTimeout(registerKeepAliveListener, socketTimeout);\n  }, \"setSocketKeepAlive\");\n  var defaultRequestTimeout = 3000;\n  var _handleSocketTimeout = setFunctionName((handleConnectionTimeout, handleTimeoutError, requestTimeout = __defaultRequestTimeout) => {\n    let registerTimeout = setFunctionName(setupConnectionTimeoutHandler => {\n      let remainingTimeout = requestTimeout - setupConnectionTimeoutHandler;\n      let onTimeoutCallback = setFunctionName(() => {\n        handleConnectionTimeout.destroy();\n        handleTimeoutError(Object.assign(Error(`Connection timed out after ${requestTimeout} ms`), {\n          name: \"TimeoutError\"\n        }));\n      }, \"onTimeout\");\n      if (handleConnectionTimeout.socket) {\n        handleConnectionTimeout.socket.setTimeout(remainingTimeout, onTimeoutCallback);\n        handleConnectionTimeout.on(\"close\", () => handleConnectionTimeout.socket?.removeListener(\"timeout\", onTimeoutCallback));\n      } else {\n        handleConnectionTimeout.setTimeout(remainingTimeout, onTimeoutCallback);\n      }\n    }, \"registerTimeout\");\n    if (requestTimeout > 0 && requestTimeout < 6000) {\n      registerTimeout(0);\n      return 0;\n    }\n    return timeoutHandler.setTimeout(registerTimeout.bind(null, requestTimeout === 0 ? 0 : defaultRequestTimeout), defaultRequestTimeout);\n  }, \"setSocketTimeout\");\n  var createStreamModule = EA(\"stream\");\n  var _defaultRequestTimeout = 6000;\n  async function handleContinueExpectations(handleRequestWithContinueExpectation, request, ___defaultRequestTimeout = _defaultRequestTimeout) {\n    let requestHeaders = request.headers ?? {};\n    let expectationHeaderValue = requestHeaders.Expect || requestHeaders.expect;\n    let _timeoutId = -1;\n    let isContinueExpectationFulfilled = true;\n    if (expectationHeaderValue === \"100-continue\") {\n      isContinueExpectationFulfilled = await Promise.race([new Promise(scheduleTimeout => {\n        _timeoutId = Number(timeoutHandler.setTimeout(() => scheduleTimeout(true), Math.max(_defaultRequestTimeout, ___defaultRequestTimeout)));\n      }), new Promise(handleContinueExpectationResponse => {\n        handleRequestWithContinueExpectation.on(\"continue\", () => {\n          timeoutHandler.clearTimeout(_timeoutId);\n          handleContinueExpectationResponse(true);\n        });\n        handleRequestWithContinueExpectation.on(\"response\", () => {\n          timeoutHandler.clearTimeout(_timeoutId);\n          handleContinueExpectationResponse(false);\n        });\n        handleRequestWithContinueExpectation.on(\"error\", () => {\n          timeoutHandler.clearTimeout(_timeoutId);\n          handleContinueExpectationResponse(false);\n        });\n      })]);\n    }\n    if (isContinueExpectationFulfilled) {\n      pipeToDestinationStream(handleRequestWithContinueExpectation, request.body);\n    }\n  }\n  setFunctionName(handleContinueExpectations, \"writeRequestBody\");\n  function pipeToDestinationStream(destinationStream, _inputData) {\n    if (_inputData instanceof createStreamModule.Readable) {\n      _inputData.pipe(destinationStream);\n      return;\n    }\n    if (_inputData) {\n      if (Buffer.isBuffer(_inputData) || typeof _inputData === \"string\") {\n        destinationStream.end(_inputData);\n        return;\n      }\n      let inputDataObject = _inputData;\n      if (typeof inputDataObject === \"object\" && inputDataObject.buffer && typeof inputDataObject.byteOffset === \"number\" && typeof inputDataObject.byteLength === \"number\") {\n        destinationStream.end(Buffer.from(inputDataObject.buffer, inputDataObject.byteOffset, inputDataObject.byteLength));\n        return;\n      }\n      destinationStream.end(Buffer.from(_inputData));\n      return;\n    }\n    destinationStream.end();\n  }\n  setFunctionName(pipeToDestinationStream, \"writeBody\");\n  var __defaultRequestTimeout = 0;\n  var hA4 = class A {\n    constructor(defaultConfigOrHandler) {\n      this.socketWarningTimestamp = 0;\n      this.metadata = {\n        handlerProtocol: \"http/1.1\"\n      };\n      this.configProvider = new Promise((callbackHandler, ___errorHandler) => {\n        if (typeof defaultConfigOrHandler === \"function\") {\n          defaultConfigOrHandler().then(defaultConfigHandler => {\n            callbackHandler(this.resolveDefaultConfig(defaultConfigHandler));\n          }).catch(___errorHandler);\n        } else {\n          callbackHandler(this.resolveDefaultConfig(defaultConfigOrHandler));\n        }\n      });\n    }\n    static {\n      setFunctionName(this, \"NodeHttpHandler\");\n    }\n    static create(B) {\n      if (typeof B?.handle === \"function\") {\n        return B;\n      }\n      return new A(B);\n    }\n    static checkSocketUsage(B, Q, __logger = console) {\n      let {\n        sockets: G,\n        requests: Z,\n        maxSockets: Y\n      } = B;\n      if (typeof Y !== \"number\" || Y === Infinity) {\n        return Q;\n      }\n      let J = 15000;\n      if (Date.now() - J < Q) {\n        return Q;\n      }\n      if (G && Z) {\n        for (let __index in G) {\n          let socketUsageCount = G[__index]?.length ?? 0;\n          let additionalRequestsQueued = Z[__index]?.length ?? 0;\n          if (socketUsageCount >= Y && additionalRequestsQueued >= Y * 2) {\n            __logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketUsageCount} and ${additionalRequestsQueued} additional requests are enqueued.\nSee https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html\nor increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);\n            return Date.now();\n          }\n        }\n      }\n      return Q;\n    }\n    resolveDefaultConfig(B) {\n      let {\n        requestTimeout: Q,\n        connectionTimeout: I,\n        socketTimeout: G,\n        socketAcquisitionWarningTimeout: Z,\n        httpAgent: Y,\n        httpsAgent: J\n      } = B || {};\n      let X = true;\n      let W = 50;\n      return {\n        connectionTimeout: I,\n        requestTimeout: Q ?? G,\n        socketAcquisitionWarningTimeout: Z,\n        httpAgent: (() => {\n          if (Y instanceof httpAgent.Agent || typeof Y?.destroy === \"function\") {\n            return Y;\n          }\n          return new httpAgent.Agent({\n            keepAlive: true,\n            maxSockets: 50,\n            ...Y\n          });\n        })(),\n        httpsAgent: (() => {\n          if (J instanceof HttpsAgentInstance.Agent || typeof J?.destroy === \"function\") {\n            return J;\n          }\n          return new HttpsAgentInstance.Agent({\n            keepAlive: true,\n            maxSockets: 50,\n            ...J\n          });\n        })(),\n        logger: console\n      };\n    }\n    destroy() {\n      this.config?.httpAgent?.destroy();\n      this.config?.httpsAgent?.destroy();\n    }\n    async handle(B, {\n      abortSignal: _abortSignal\n    } = {}) {\n      if (!this.config) {\n        this.config = await this.configProvider;\n      }\n      return new Promise((handleSuccess, onRequestFailure) => {\n        let requestPromise = undefined;\n        let timeoutHandlers = [];\n        let handleResponse = setFunctionName(async handleRequestResponse => {\n          await requestPromise;\n          timeoutHandlers.forEach(timeoutHandler.clearTimeout);\n          handleSuccess(handleRequestResponse);\n        }, \"resolve\");\n        let promiseRejectHandler = setFunctionName(async handleRequestFailure => {\n          await requestPromise;\n          timeoutHandlers.forEach(timeoutHandler.clearTimeout);\n          onRequestFailure(handleRequestFailure);\n        }, \"reject\");\n        if (!this.config) {\n          throw Error(\"Node HTTP request handler config is not resolved\");\n        }\n        if (_abortSignal?.aborted) {\n          let requestCallback = Error(\"Request aborted\");\n          requestCallback.name = \"AbortError\";\n          promiseRejectHandler(requestCallback);\n          return;\n        }\n        let isHttpsRequest = B.protocol === \"https:\";\n        let agent = isHttpsRequest ? this.config.httpsAgent : this.config.httpAgent;\n        timeoutHandlers.push(timeoutHandler.setTimeout(() => {\n          this.socketWarningTimestamp = A.checkSocketUsage(agent, this.socketWarningTimestamp, this.config.logger);\n        }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));\n        let queryString = (0, _imageProcessingTransformation.buildQueryString)(B.query || {});\n        let credentials = undefined;\n        if (B.username != null || B.password != null) {\n          let requestAbortedError = B.username ?? \"\";\n          let promiseHandler = B.password ?? \"\";\n          credentials = `${requestAbortedError}:${promiseHandler}`;\n        }\n        let requestPath = B.path;\n        if (queryString) {\n          requestPath += `?${queryString}`;\n        }\n        if (B.fragment) {\n          requestPath += `#${B.fragment}`;\n        }\n        let _hostname = B.hostname ?? \"\";\n        if (_hostname[0] === \"[\" && _hostname.endsWith(\"]\")) {\n          _hostname = B.hostname.slice(1, -1);\n        } else {\n          _hostname = B.hostname;\n        }\n        let requestOptions = {\n          headers: B.headers,\n          host: _hostname,\n          method: B.method,\n          path: requestPath,\n          port: B.port,\n          agent: agent,\n          auth: credentials\n        };\n        let httpRequest = (isHttpsRequest ? HttpsAgentInstance.request : httpAgent.request)(requestOptions, __httpResponse => {\n          let ___httpResponse = new initializeHttpResponseProcessor.HttpResponse({\n            statusCode: __httpResponse.statusCode || -1,\n            reason: __httpResponse.statusMessage,\n            headers: transformHeadersToString(__httpResponse.headers),\n            body: __httpResponse\n          });\n          handleResponse({\n            response: ___httpResponse\n          });\n        });\n        httpRequest.on(\"error\", errorResponse => {\n          if (commonNetworkErrors.includes(errorResponse.code)) {\n            promiseRejectHandler(Object.assign(errorResponse, {\n              name: \"TimeoutError\"\n            }));\n          } else {\n            promiseRejectHandler(errorResponse);\n          }\n        });\n        if (_abortSignal) {\n          let errorCallback = setFunctionName(() => {\n            httpRequest.destroy();\n            let _abortError = Error(\"Request aborted\");\n            _abortError.name = \"AbortError\";\n            promiseRejectHandler(_abortError);\n          }, \"onAbort\");\n          if (typeof _abortSignal.addEventListener === \"function\") {\n            let handleRequest = _abortSignal;\n            handleRequest.addEventListener(\"abort\", errorCallback, {\n              once: true\n            });\n            httpRequest.once(\"close\", () => handleRequest.removeEventListener(\"abort\", errorCallback));\n          } else {\n            _abortSignal.onabort = errorCallback;\n          }\n        }\n        timeoutHandlers.push(setConnectionTimeoutHandler(httpRequest, promiseRejectHandler, this.config.connectionTimeout));\n        timeoutHandlers.push(_handleSocketTimeout(httpRequest, promiseRejectHandler, this.config.requestTimeout));\n        let _agent = requestOptions.agent;\n        if (typeof _agent === \"object\" && \"keepAlive\" in _agent) {\n          timeoutHandlers.push(_setSocketKeepAlive(httpRequest, {\n            keepAlive: _agent.keepAlive,\n            keepAliveMsecs: _agent.keepAliveMsecs\n          }));\n        }\n        requestPromise = handleContinueExpectations(httpRequest, B, this.config.requestTimeout).catch(requestFailureHandler => {\n          timeoutHandlers.forEach(timeoutHandler.clearTimeout);\n          return onRequestFailure(requestFailureHandler);\n        });\n      });\n    }\n    updateHttpClientConfig(B, Q) {\n      this.config = undefined;\n      this.configProvider = this.configProvider.then(mergeWithNewProperty => {\n        return {\n          ...mergeWithNewProperty,\n          [B]: Q\n        };\n      });\n    }\n    httpHandlerConfigs() {\n      return this.config ?? {};\n    }\n  };\n  var Http2Protocol = EA(\"http2\");\n  var http2ModuleInitializer = _initializeModule(EA(\"http2\"));\n  var NodeHttp2ConnectionPool = class {\n    constructor(initialSessions) {\n      this.sessions = [];\n      this.sessions = initialSessions ?? [];\n    }\n    static {\n      setFunctionName(this, \"NodeHttp2ConnectionPool\");\n    }\n    poll() {\n      if (this.sessions.length > 0) {\n        return this.sessions.shift();\n      }\n    }\n    offerLast(offerLastSession) {\n      this.sessions.push(offerLastSession);\n    }\n    contains(sessionExists) {\n      return this.sessions.includes(sessionExists);\n    }\n    remove(sessionToRemove) {\n      this.sessions = this.sessions.filter(isBDifferentFromA => isBDifferentFromA !== sessionToRemove);\n    }\n    [Symbol.iterator]() {\n      return this.sessions[Symbol.iterator]();\n    }\n    destroy(destroySession) {\n      for (let session of this.sessions) {\n        if (session === destroySession) {\n          if (!session.destroyed) {\n            session.destroy();\n          }\n        }\n      }\n    }\n  };\n  var NodeHttp2ConnectionManager = class {\n    constructor(_configuration) {\n      this.sessionCache = new Map();\n      this.config = _configuration;\n      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {\n        throw RangeError(\"maxConcurrency must be greater than zero.\");\n      }\n    }\n    static {\n      setFunctionName(this, \"NodeHttp2ConnectionManager\");\n    }\n    lease(createHttp2Session, _requestOptions) {\n      let urlString = this.getUrlString(createHttp2Session);\n      let cachedSession = this.sessionCache.get(urlString);\n      if (cachedSession) {\n        let response = cachedSession.poll();\n        if (response && !this.config.disableConcurrency) {\n          return response;\n        }\n      }\n      let http2Connection = http2ModuleInitializer.default.connect(urlString);\n      if (this.config.maxConcurrency) {\n        http2Connection.settings({\n          maxConcurrentStreams: this.config.maxConcurrency\n        }, isErrorCondition => {\n          if (isErrorCondition) {\n            throw Error(\"Fail to set maxConcurrentStreams to \" + this.config.maxConcurrency + \"when creating new session for \" + createHttp2Session.destination.toString());\n          }\n        });\n      }\n      http2Connection.unref();\n      let cleanupSessionCallback = setFunctionName(() => {\n        http2Connection.destroy();\n        this.deleteSession(urlString, http2Connection);\n      }, \"destroySessionCb\");\n      http2Connection.on(\"goaway\", cleanupSessionCallback);\n      http2Connection.on(\"error\", cleanupSessionCallback);\n      http2Connection.on(\"frameError\", cleanupSessionCallback);\n      http2Connection.on(\"close\", () => this.deleteSession(urlString, http2Connection));\n      if (_requestOptions.requestTimeout) {\n        http2Connection.setTimeout(_requestOptions.requestTimeout, cleanupSessionCallback);\n      }\n      let connectionPool = this.sessionCache.get(urlString) || new NodeHttp2ConnectionPool();\n      connectionPool.offerLast(http2Connection);\n      this.sessionCache.set(urlString, connectionPool);\n      return http2Connection;\n    }\n    deleteSession(sessionIdentifier, sessionId) {\n      let sessionData = this.sessionCache.get(sessionIdentifier);\n      if (!sessionData) {\n        return;\n      }\n      if (!sessionData.contains(sessionId)) {\n        return;\n      }\n      sessionData.remove(sessionId);\n      this.sessionCache.set(sessionIdentifier, sessionData);\n    }\n    release(releaseSessionToCache, offerLastToSessionCache) {\n      let _urlString = this.getUrlString(releaseSessionToCache);\n      this.sessionCache.get(_urlString)?.offerLast(offerLastToSessionCache);\n    }\n    destroy() {\n      for (let [sessionKey, sessionItems] of this.sessionCache) {\n        for (let sessionItem of sessionItems) {\n          if (!sessionItem.destroyed) {\n            sessionItem.destroy();\n          }\n          sessionItems.remove(sessionItem);\n        }\n        this.sessionCache.delete(sessionKey);\n      }\n    }\n    setMaxConcurrentStreams(maxConcurrentStreams) {\n      if (maxConcurrentStreams && maxConcurrentStreams <= 0) {\n        throw RangeError(\"maxConcurrentStreams must be greater than zero.\");\n      }\n      this.config.maxConcurrency = maxConcurrentStreams;\n    }\n    setDisableConcurrentStreams(setDisableConcurrentStreamsDisableConcurrency) {\n      this.config.disableConcurrency = setDisableConcurrentStreamsDisableConcurrency;\n    }\n    getUrlString(getUrlStringDestinationObject) {\n      return getUrlStringDestinationObject.destination.toString();\n    }\n  };\n  var dA4 = class A {\n    constructor(getData) {\n      this.metadata = {\n        handlerProtocol: \"h2\"\n      };\n      this.connectionManager = new NodeHttp2ConnectionManager({});\n      this.configProvider = new Promise((callbackWithDefaultData, ____errorHandler) => {\n        if (typeof getData === \"function\") {\n          getData().then(defaultDataCallback => {\n            callbackWithDefaultData(defaultDataCallback || {});\n          }).catch(____errorHandler);\n        } else {\n          callbackWithDefaultData(getData || {});\n        }\n      });\n    }\n    static {\n      setFunctionName(this, \"NodeHttp2Handler\");\n    }\n    static create(B) {\n      if (typeof B?.handle === \"function\") {\n        return B;\n      }\n      return new A(B);\n    }\n    destroy() {\n      this.connectionManager.destroy();\n    }\n    async handle(B, {\n      abortSignal: abortSignal\n    } = {}) {\n      if (!this.config) {\n        this.config = await this.configProvider;\n        this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);\n        if (this.config.maxConcurrentStreams) {\n          this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);\n        }\n      }\n      let {\n        requestTimeout: I,\n        disableConcurrentStreams: G\n      } = this.config;\n      return new Promise((_handleHttpRequest, handleRejection) => {\n        let isRequestAborted = false;\n        let httpRequestPromise = undefined;\n        let resolvePromise = setFunctionName(async httpRequestData => {\n          await httpRequestPromise;\n          _handleHttpRequest(httpRequestData);\n        }, \"resolve\");\n        let handleReject = setFunctionName(async requestPayload => {\n          await httpRequestPromise;\n          handleRejection(requestPayload);\n        }, \"reject\");\n        if (abortSignal?.aborted) {\n          isRequestAborted = true;\n          let callbackFunction = Error(\"Request aborted\");\n          callbackFunction.name = \"AbortError\";\n          handleReject(callbackFunction);\n          return;\n        }\n        let {\n          hostname: hostname,\n          method: httpMethod,\n          port: portNumber,\n          protocol: protocolScheme,\n          query: queryParams\n        } = B;\n        let authCredentials = \"\";\n        if (B.username != null || B.password != null) {\n          let callback = B.username ?? \"\";\n          let password = B.password ?? \"\";\n          authCredentials = `${callback}:${password}@`;\n        }\n        let requestUrl = `${protocolScheme}//${authCredentials}${hostname}${portNumber ? `:${portNumber}` : \"\"}`;\n        let connectionRequest = {\n          destination: new URL(requestUrl)\n        };\n        let connectionLease = this.connectionManager.lease(connectionRequest, {\n          requestTimeout: this.config?.sessionTimeout,\n          disableConcurrentStreams: G || false\n        });\n        let handleRequestError = setFunctionName(_____error => {\n          if (G) {\n            this.destroySession(connectionLease);\n          }\n          isRequestAborted = true;\n          handleReject(_____error);\n        }, \"rejectWithDestroy\");\n        let buildQueryString = (0, _imageProcessingTransformation.buildQueryString)(queryParams || {});\n        let P = B.path;\n        if (buildQueryString) {\n          P += `?${buildQueryString}`;\n        }\n        if (B.fragment) {\n          P += `#${B.fragment}`;\n        }\n        let k = connectionLease.request({\n          ...B.headers,\n          [Http2Protocol.constants.HTTP2_HEADER_PATH]: P,\n          [Http2Protocol.constants.HTTP2_HEADER_METHOD]: httpMethod\n        });\n        connectionLease.ref();\n        k.on(\"response\", httpResponseStatus => {\n          let _httpResponse = new initializeHttpResponseProcessor.HttpResponse({\n            statusCode: httpResponseStatus[\":status\"] || -1,\n            headers: transformHeadersToString(httpResponseStatus),\n            body: k\n          });\n          isRequestAborted = true;\n          resolvePromise({\n            response: _httpResponse\n          });\n          if (G) {\n            connectionLease.close();\n            this.connectionManager.deleteSession(requestUrl, connectionLease);\n          }\n        });\n        if (I) {\n          k.setTimeout(I, () => {\n            k.close();\n            let timeoutError = Error(`Stream timed out because of no activity for ${I} ms`);\n            timeoutError.name = \"TimeoutError\";\n            handleRequestError(timeoutError);\n          });\n        }\n        if (abortSignal) {\n          let _callback = setFunctionName(() => {\n            k.close();\n            let abortedRequestError = Error(\"Request aborted\");\n            abortedRequestError.name = \"AbortError\";\n            handleRequestError(abortedRequestError);\n          }, \"onAbort\");\n          if (typeof abortSignal.addEventListener === \"function\") {\n            let _password = abortSignal;\n            _password.addEventListener(\"abort\", _callback, {\n              once: true\n            });\n            k.once(\"close\", () => _password.removeEventListener(\"abort\", _callback));\n          } else {\n            abortSignal.onabort = _callback;\n          }\n        }\n        k.on(\"frameError\", (frameTypeId, errorCode, frameId) => {\n          handleRequestError(Error(`Frame type id ${frameTypeId} in stream id ${frameId} has failed with code ${errorCode}.`));\n        });\n        k.on(\"error\", handleRequestError);\n        k.on(\"aborted\", () => {\n          handleRequestError(Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${k.rstCode}.`));\n        });\n        k.on(\"close\", () => {\n          connectionLease.unref();\n          if (G) {\n            connectionLease.destroy();\n          }\n          if (!isRequestAborted) {\n            handleRequestError(Error(\"Unexpected error: http2 request did not get a response\"));\n          }\n        });\n        httpRequestPromise = handleContinueExpectations(k, B, I);\n      });\n    }\n    updateHttpClientConfig(B, Q) {\n      this.config = undefined;\n      this.configProvider = this.configProvider.then(updateObjectWithNewKey => {\n        return {\n          ...updateObjectWithNewKey,\n          [B]: Q\n        };\n      });\n    }\n    httpHandlerConfigs() {\n      return this.config ?? {};\n    }\n    destroySession(B) {\n      if (!B.destroyed) {\n        B.destroy();\n      }\n    }\n  };\n  var CollectorWritableStream = class extends createStreamModule.Writable {\n    constructor() {\n      super(...arguments);\n      this.bufferedBytes = [];\n    }\n    static {\n      setFunctionName(this, \"Collector\");\n    }\n    _write(writeDataToBuffer, _____processData, _______________callbackFunction) {\n      this.bufferedBytes.push(writeDataToBuffer);\n      _______________callbackFunction();\n    }\n  };\n  var streamDataCollector = setFunctionName(processStreamData => {\n    if (_isReadableStream(processStreamData)) {\n      return readStreamToUint8Array(processStreamData);\n    }\n    return new Promise((processBufferedData, _handleError) => {\n      let streamProcessor = new CollectorWritableStream();\n      processStreamData.pipe(streamProcessor);\n      processStreamData.on(\"error\", handleStreamEnd => {\n        streamProcessor.end();\n        _handleError(handleStreamEnd);\n      });\n      streamProcessor.on(\"error\", _handleError);\n      streamProcessor.on(\"finish\", function () {\n        let bufferedBytesArray = new Uint8Array(Buffer.concat(this.bufferedBytes));\n        processBufferedData(bufferedBytesArray);\n      });\n    });\n  }, \"streamCollector\");\n  var _isReadableStream = setFunctionName(isReadableStreamInstance => typeof ReadableStream === \"function\" && isReadableStreamInstance instanceof ReadableStream, \"isReadableStreamInstance\");\n  async function readStreamToUint8Array(readStreamToByteArray) {\n    let chunksArray = [];\n    let readableStreamReader = readStreamToByteArray.getReader();\n    let isStreamDone = false;\n    let _totalBytesRead = 0;\n    while (!isStreamDone) {\n      let {\n        done: _isDone,\n        value: readAllChunks\n      } = await readableStreamReader.read();\n      if (readAllChunks) {\n        chunksArray.push(readAllChunks);\n        _totalBytesRead += readAllChunks.length;\n      }\n      isStreamDone = _isDone;\n    }\n    let uint8Array = new Uint8Array(_totalBytesRead);\n    let currentIndex = 0;\n    for (let _chunk of chunksArray) {\n      uint8Array.set(_chunk, currentIndex);\n      currentIndex += _chunk.length;\n    }\n    return uint8Array;\n  }\n  setFunctionName(readStreamToUint8Array, \"collectReadableStream\");\n});\nvar _________________________________processImageTransformation = z((initializeModuleExports, ________________moduleExports) => {\n  var {\n    defineProperty: _______defineProperty,\n    getOwnPropertyDescriptor: _______________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ______________getOwnPropertyNames\n  } = Object;\n  var ______________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _defineFunctionWithName = (_________definePropertyWithValue, _setPropertyName) => _______defineProperty(_________definePropertyWithValue, \"name\", {\n    value: _setPropertyName,\n    configurable: true\n  });\n  var definePropertyGetters = (_________definePropertiesWithGetters, _____________________________________________________________________________________________________sourceObject) => {\n    for (var _______key in _____________________________________________________________________________________________________sourceObject) {\n      _______defineProperty(_________definePropertiesWithGetters, _______key, {\n        get: _____________________________________________________________________________________________________sourceObject[_______key],\n        enumerable: true\n      });\n    }\n  };\n  var __definePropertiesFromSource = (__copyProperties, ______________________________________________________________sourceObject, ________propertyKey, _________________propertyDescriptor) => {\n    if (______________________________________________________________sourceObject && typeof ______________________________________________________________sourceObject === \"object\" || typeof ______________________________________________________________sourceObject === \"function\") {\n      for (let ___________________propertyName of ______________getOwnPropertyNames(______________________________________________________________sourceObject)) {\n        if (!______________hasOwnProperty.call(__copyProperties, ___________________propertyName) && ___________________propertyName !== ________propertyKey) {\n          _______defineProperty(__copyProperties, ___________________propertyName, {\n            get: () => ______________________________________________________________sourceObject[___________________propertyName],\n            enumerable: !(_________________propertyDescriptor = _______________getOwnPropertyDescriptor(______________________________________________________________sourceObject, ___________________propertyName)) || _________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return __copyProperties;\n  };\n  var _createModuleExports = ______________definePropertiesFromSource => __definePropertiesFromSource(_______defineProperty({}, \"__esModule\", {\n    value: true\n  }), ______________definePropertiesFromSource);\n  var _________________moduleExports = {};\n  definePropertyGetters(_________________moduleExports, {\n    AlgorithmId: () => tg0,\n    EndpointURLScheme: () => og0,\n    FieldPosition: () => eg0,\n    HttpApiKeyAuthLocation: () => rg0,\n    HttpAuthLocation: () => sg0,\n    IniSectionType: () => Au0,\n    RequestHandlerProtocol: () => Bu0,\n    SMITHY_CONTEXT_KEY: () => ____SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => getDefaultClientChecksumConfiguration,\n    resolveDefaultRuntimeConfig: () => resolveChecksumConstructorMap\n  });\n  ________________moduleExports.exports = _createModuleExports(_________________moduleExports);\n  var sg0 = (_defineConstants => {\n    _defineConstants.HEADER = \"header\";\n    _defineConstants.QUERY = \"query\";\n    return _defineConstants;\n  })(sg0 || {});\n  var rg0 = (createQueryHeader => {\n    createQueryHeader.HEADER = \"header\";\n    createQueryHeader.QUERY = \"query\";\n    return createQueryHeader;\n  })(rg0 || {});\n  var og0 = (protocols => {\n    protocols.HTTP = \"http\";\n    protocols.HTTPS = \"https\";\n    return protocols;\n  })(og0 || {});\n  var tg0 = (hashAlgorithmConstants => {\n    hashAlgorithmConstants.MD5 = \"md5\";\n    hashAlgorithmConstants.CRC32 = \"crc32\";\n    hashAlgorithmConstants.CRC32C = \"crc32c\";\n    hashAlgorithmConstants.SHA1 = \"sha1\";\n    hashAlgorithmConstants.SHA256 = \"sha256\";\n    return hashAlgorithmConstants;\n  })(tg0 || {});\n  var ______createChecksumAlgorithmManager = _defineFunctionWithName(___createChecksumAlgorithmManager => {\n    let _____checksumAlgorithmsList = [];\n    if (___createChecksumAlgorithmManager.sha256 !== undefined) {\n      _____checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => ___createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (___createChecksumAlgorithmManager.md5 != null) {\n      _____checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => ___createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(___checksumAlgorithm) {\n        _____checksumAlgorithmsList.push(___checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return _____checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var _generateChecksumConstructorMap = _defineFunctionWithName(__generateChecksumMap => {\n    let __checksumConstructorsByAlgorithmId = {};\n    __generateChecksumMap.checksumAlgorithms().forEach(__checksumConstructor => {\n      __checksumConstructorsByAlgorithmId[__checksumConstructor.algorithmId()] = __checksumConstructor.checksumConstructor();\n    });\n    return __checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var getDefaultClientChecksumConfiguration = _defineFunctionWithName(calculateTax => {\n    return ______createChecksumAlgorithmManager(calculateTax);\n  }, \"getDefaultClientConfiguration\");\n  var resolveChecksumConstructorMap = _defineFunctionWithName(getProcessedValue => {\n    return _generateChecksumConstructorMap(getProcessedValue);\n  }, \"resolveDefaultRuntimeConfig\");\n  var eg0 = (MessageTypes => {\n    MessageTypes[MessageTypes.HEADER = 0] = \"HEADER\";\n    MessageTypes[MessageTypes.TRAILER = 1] = \"TRAILER\";\n    return MessageTypes;\n  })(eg0 || {});\n  var ____SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var Au0 = (setUserProfileConstants => {\n    setUserProfileConstants.PROFILE = \"profile\";\n    setUserProfileConstants.SSO_SESSION = \"sso-session\";\n    setUserProfileConstants.SERVICES = \"services\";\n    return setUserProfileConstants;\n  })(Au0 || {});\n  var Bu0 = (defineProtocolVersions => {\n    defineProtocolVersions.HTTP_0_9 = \"http/0.9\";\n    defineProtocolVersions.HTTP_1_0 = \"http/1.0\";\n    defineProtocolVersions.TDS_8_0 = \"tds/8.0\";\n    return defineProtocolVersions;\n  })(Bu0 || {});\n});\nvar ________________imageTransformationProcessor = z((httpHandlerExtensionConfigFactory, ________moduleExports) => {\n  var {\n    defineProperty: definePropertyWithMetadata,\n    getOwnPropertyDescriptor: getPropertyDescriptor,\n    getOwnPropertyNames: getObjectPropertyNames\n  } = Object;\n  var _________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _________________definePropertyWithName = (definePropertyWithMetadataAndName, __propertyValue) => definePropertyWithMetadata(definePropertyWithMetadataAndName, \"name\", {\n    value: __propertyValue,\n    configurable: true\n  });\n  var _definePropertiesWithGetters = (__________definePropertiesWithGetters, ____________________________propertyDescriptor) => {\n    for (var _____________________________propertyKey in ____________________________propertyDescriptor) {\n      definePropertyWithMetadata(__________definePropertiesWithGetters, _____________________________propertyKey, {\n        get: ____________________________propertyDescriptor[_____________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var _defineNonEnumerableProperties = (__definePropertiesFromObject, _________________________________________________________________sourceObject, _______excludedPropertyName, __________________propertyDescriptor) => {\n    if (_________________________________________________________________sourceObject && typeof _________________________________________________________________sourceObject === \"object\" || typeof _________________________________________________________________sourceObject === \"function\") {\n      for (let ____________________propertyName of getObjectPropertyNames(_________________________________________________________________sourceObject)) {\n        if (!_________hasOwnProperty.call(__definePropertiesFromObject, ____________________propertyName) && ____________________propertyName !== _______excludedPropertyName) {\n          definePropertyWithMetadata(__definePropertiesFromObject, ____________________propertyName, {\n            get: () => _________________________________________________________________sourceObject[____________________propertyName],\n            enumerable: !(__________________propertyDescriptor = getPropertyDescriptor(_________________________________________________________________sourceObject, ____________________propertyName)) || __________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return __definePropertiesFromObject;\n  };\n  var defineHttpHandlerExtensionConfiguration = initializeModuleProperties => _defineNonEnumerableProperties(definePropertyWithMetadata({}, \"__esModule\", {\n    value: true\n  }), initializeModuleProperties);\n  var httpHandlerConfiguration = {};\n  _definePropertiesWithGetters(httpHandlerConfiguration, {\n    Field: () => HttpHeader,\n    Fields: () => HttpHeadersCollection,\n    HttpRequest: () => K14,\n    HttpResponse: () => _HttpResponseHandler,\n    IHttpRequest: () => ____________________________________________processImageTransformation.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => __getHttpHandlerExtensionConfiguration,\n    isValidHostname: () => __isValidUsername,\n    resolveHttpHandlerRuntimeConfig: () => __resolveHttpHandlerConfig\n  });\n  ________moduleExports.exports = defineHttpHandlerExtensionConfiguration(httpHandlerConfiguration);\n  var __getHttpHandlerExtensionConfiguration = _________________definePropertyWithName(____createHttpHandlerManager => {\n    return {\n      setHttpHandler(___httpHandler) {\n        ____createHttpHandlerManager.httpHandler = ___httpHandler;\n      },\n      httpHandler() {\n        return ____createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(_______httpClientConfig, ________httpClientConfig) {\n        ____createHttpHandlerManager.httpHandler?.updateHttpClientConfig(_______httpClientConfig, ________httpClientConfig);\n      },\n      httpHandlerConfigs() {\n        return ____createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var __resolveHttpHandlerConfig = _________________definePropertyWithName(____createHttpHandler => {\n    return {\n      httpHandler: ____createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var ____________________________________________processImageTransformation = _________________________________processImageTransformation();\n  var HttpHeader = class {\n    static {\n      _________________definePropertyWithName(this, \"Field\");\n    }\n    constructor({\n      name: ___headerName,\n      kind: __fieldPosition = ____________________________________________processImageTransformation.FieldPosition.HEADER,\n      values: defaultValues = []\n    }) {\n      this.name = ___headerName;\n      this.kind = __fieldPosition;\n      this.values = defaultValues;\n    }\n    add(____addValue) {\n      this.values.push(____addValue);\n    }\n    set(____setValues) {\n      this.values = ____setValues;\n    }\n    remove(___removeValue) {\n      this.values = this.values.filter(isBNotEqualToA => isBNotEqualToA !== ___removeValue);\n    }\n    toString() {\n      return this.values.map(____formattedString => ____formattedString.includes(\",\") || ____formattedString.includes(\" \") ? `\"${____formattedString}\"` : ____formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpHeadersCollection = class {\n    constructor({\n      fields: _fieldsArray = [],\n      encoding: ____defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      _fieldsArray.forEach(this.setField.bind(this));\n      this.encoding = ____defaultEncoding;\n    }\n    static {\n      _________________definePropertyWithName(this, \"Fields\");\n    }\n    setField(setFieldWithEntry) {\n      this.entries[setFieldWithEntry.name.toLowerCase()] = setFieldWithEntry;\n    }\n    getField(___getFieldByKey) {\n      return this.entries[___getFieldByKey.toLowerCase()];\n    }\n    removeField(_removeFieldByName) {\n      delete this.entries[_removeFieldByName.toLowerCase()];\n    }\n    getByType(_getByTypeAndKind) {\n      return Object.values(this.entries).filter(___isKindOfA => ___isKindOfA.kind === _getByTypeAndKind);\n    }\n  };\n  var K14 = class A {\n    static {\n      _________________definePropertyWithName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObjectProperties(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObjectProperties(copyObjectWithArrayValues) {\n    return Object.keys(copyObjectWithArrayValues).reduce((mergeAndCopyArrayValues, arrayValueKey) => {\n      let arrayCopy = copyObjectWithArrayValues[arrayValueKey];\n      return {\n        ...mergeAndCopyArrayValues,\n        [arrayValueKey]: Array.isArray(arrayCopy) ? [...arrayCopy] : arrayCopy\n      };\n    }, {});\n  }\n  _________________definePropertyWithName(cloneObjectProperties, \"cloneQuery\");\n  var _HttpResponseHandler = class {\n    static {\n      _________________definePropertyWithName(this, \"HttpResponse\");\n    }\n    constructor(__responseObject) {\n      this.statusCode = __responseObject.statusCode;\n      this.reason = __responseObject.reason;\n      this.headers = __responseObject.headers || {};\n      this.body = __responseObject.body;\n    }\n    static isInstance(__isHttpResponse) {\n      if (!__isHttpResponse) {\n        return false;\n      }\n      let responseObject = __isHttpResponse;\n      return typeof responseObject.statusCode === \"number\" && typeof responseObject.headers === \"object\";\n    }\n  };\n  function __isValidUsername(___isValidUsername) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(___isValidUsername);\n  }\n  _________________definePropertyWithName(__isValidUsername, \"isValidHostname\");\n});\nvar __________________________________processImageTransformation = z((defineEscapeUriFunctions, _initializeExports) => {\n  var {\n    defineProperty: _____________definePropertyWithName,\n    getOwnPropertyDescriptor: __________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _________________________getOwnPropertyNames\n  } = Object;\n  var ____hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var definePropertyWithNameAndDescription = (_____definePropertyWithNameAndValue, __valueSetter) => _____________definePropertyWithName(_____definePropertyWithNameAndValue, \"name\", {\n    value: __valueSetter,\n    configurable: true\n  });\n  var defineGetterProperties = (defineAndAssignProperties, ______________________________________________________________________________________________________sourceObject) => {\n    for (var _________________________________propertyName in ______________________________________________________________________________________________________sourceObject) {\n      _____________definePropertyWithName(defineAndAssignProperties, _________________________________propertyName, {\n        get: ______________________________________________________________________________________________________sourceObject[_________________________________propertyName],\n        enumerable: true\n      });\n    }\n  };\n  var _definePropertyForObject = (____copyPropertiesFromSource, ____________________________________________________________________sourceObject, excludeProperty, ____descriptor) => {\n    if (____________________________________________________________________sourceObject && typeof ____________________________________________________________________sourceObject === \"object\" || typeof ____________________________________________________________________sourceObject === \"function\") {\n      for (let _____________________propertyName of _________________________getOwnPropertyNames(____________________________________________________________________sourceObject)) {\n        if (!____hasOwnPropertyCheck.call(____copyPropertiesFromSource, _____________________propertyName) && _____________________propertyName !== excludeProperty) {\n          _____________definePropertyWithName(____copyPropertiesFromSource, _____________________propertyName, {\n            get: () => ____________________________________________________________________sourceObject[_____________________propertyName],\n            enumerable: !(____descriptor = __________________________getOwnPropertyDescriptor(____________________________________________________________________sourceObject, _____________________propertyName)) || ____descriptor.enumerable\n          });\n        }\n      }\n    }\n    return ____copyPropertiesFromSource;\n  };\n  var createModuleWithExport = definePropertyForModuleExport => _definePropertyForObject(_____________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), definePropertyForModuleExport);\n  var uriEncoderModule = {};\n  defineGetterProperties(uriEncoderModule, {\n    escapeUri: () => escapeUriFunction,\n    escapeUriPath: () => escapeUriPathFunction\n  });\n  _initializeExports.exports = createModuleWithExport(uriEncoderModule);\n  var escapeUriFunction = definePropertyWithNameAndDescription(encodedURIComponent => encodeURIComponent(encodedURIComponent).replace(/[!'()*]/g, convertCharacterToHexString), \"escapeUri\");\n  var convertCharacterToHexString = definePropertyWithNameAndDescription(convertCharToHexString => `%${convertCharToHexString.charCodeAt(0).toString(16).toUpperCase()}`, \"hexEncode\");\n  var escapeUriPathFunction = definePropertyWithNameAndDescription(_splitAndTransformPath => _splitAndTransformPath.split(\"/\").map(escapeUriFunction).join(\"/\"), \"escapeUriPath\");\n});\nvar __processImageTransformationFunction = z((transformImageAndBuildQueryString, processAndExportModule) => {\n  var {\n    defineProperty: definePropertyDescriptor,\n    getOwnPropertyDescriptor: ________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ______________________getOwnPropertyNames\n  } = Object;\n  var ___hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var _____defineFunctionName = (______________________________________definePropertyWithName, ___propertyValue) => definePropertyDescriptor(______________________________________definePropertyWithName, \"name\", {\n    value: ___propertyValue,\n    configurable: true\n  });\n  var _assignProperties = (______________________defineProperties, propertyDescriptorMap) => {\n    for (var ______________________________propertyKey in propertyDescriptorMap) {\n      definePropertyDescriptor(______________________defineProperties, ______________________________propertyKey, {\n        get: propertyDescriptorMap[______________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var copyObjectProperties = (definePropertiesIfNeeded, _______________________________________________________________________sourceObject, excludedPropertyKey, ___________________propertyDescriptor) => {\n    if (_______________________________________________________________________sourceObject && typeof _______________________________________________________________________sourceObject === \"object\" || typeof _______________________________________________________________________sourceObject === \"function\") {\n      for (let __propertyKey of ______________________getOwnPropertyNames(_______________________________________________________________________sourceObject)) {\n        if (!___hasOwnPropertyCheck.call(definePropertiesIfNeeded, __propertyKey) && __propertyKey !== excludedPropertyKey) {\n          definePropertyDescriptor(definePropertiesIfNeeded, __propertyKey, {\n            get: () => _______________________________________________________________________sourceObject[__propertyKey],\n            enumerable: !(___________________propertyDescriptor = ________________________getOwnPropertyDescriptor(_______________________________________________________________________sourceObject, __propertyKey)) || ___________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return definePropertiesIfNeeded;\n  };\n  var createModuleExportsWithEscapedProperties = copyObjectWithEsModuleFlag => copyObjectProperties(definePropertyDescriptor({}, \"__esModule\", {\n    value: true\n  }), copyObjectWithEsModuleFlag);\n  var _______________________moduleExports = {};\n  _assignProperties(_______________________moduleExports, {\n    buildQueryString: () => _convertObjectToQueryString\n  });\n  processAndExportModule.exports = createModuleExportsWithEscapedProperties(_______________________moduleExports);\n  var _______________________________________________processImageTransformation = __________________________________processImageTransformation();\n  function _convertObjectToQueryString(convertObjectToQueryString) {\n    let queryStringParams = [];\n    for (let ________key of Object.keys(convertObjectToQueryString).sort()) {\n      let value = convertObjectToQueryString[________key];\n      ________key = (0, _______________________________________________processImageTransformation.escapeUri)(________key);\n      if (Array.isArray(value)) {\n        for (let _________index = 0, valueLength = value.length; _________index < valueLength; _________index++) {\n          queryStringParams.push(`${________key}=${(0, _______________________________________________processImageTransformation.escapeUri)(value[_________index])}`);\n        }\n      } else {\n        let ____index = ________key;\n        if (value || typeof value === \"string\") {\n          ____index += `=${(0, _______________________________________________processImageTransformation.escapeUri)(value)}`;\n        }\n        queryStringParams.push(____index);\n      }\n    }\n    return queryStringParams.join(\"&\");\n  }\n  _____defineFunctionName(_convertObjectToQueryString, \"buildQueryString\");\n});\nvar ______________imageProcessor = z((httpRequestHandler, ModuleExports) => {\n  var {\n    defineProperty: definePropertyWithSetter,\n    getOwnPropertyDescriptor: ____getOwnPropertyDescriptor,\n    getOwnPropertyNames: ____getOwnPropertyNames\n  } = Object;\n  var ____hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _setFunctionName = (__setObjectName, ____propertyValue) => definePropertyWithSetter(__setObjectName, \"name\", {\n    value: ____propertyValue,\n    configurable: true\n  });\n  var _____defineProperties = (initializeProperties, _propertyDefinitions) => {\n    for (var _______________________________propertyKey in _propertyDefinitions) {\n      definePropertyWithSetter(initializeProperties, _______________________________propertyKey, {\n        get: _propertyDefinitions[_______________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var assignPropertiesFromSource = (___copyProperties, _________________________________________________________________________sourceObject, ________excludedPropertyName, ____________________propertyDescriptor) => {\n    if (_________________________________________________________________________sourceObject && typeof _________________________________________________________________________sourceObject === \"object\" || typeof _________________________________________________________________________sourceObject === \"function\") {\n      for (let ______________________propertyName of ____getOwnPropertyNames(_________________________________________________________________________sourceObject)) {\n        if (!____hasOwnProperty.call(___copyProperties, ______________________propertyName) && ______________________propertyName !== ________excludedPropertyName) {\n          definePropertyWithSetter(___copyProperties, ______________________propertyName, {\n            get: () => _________________________________________________________________________sourceObject[______________________propertyName],\n            enumerable: !(____________________propertyDescriptor = ____getOwnPropertyDescriptor(_________________________________________________________________________sourceObject, ______________________propertyName)) || ____________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return ___copyProperties;\n  };\n  var createModuleExports = ___assignPropertiesFromSource => assignPropertiesFromSource(definePropertyWithSetter({}, \"__esModule\", {\n    value: true\n  }), ___assignPropertiesFromSource);\n  var httpHandlerExports = {};\n  _____defineProperties(httpHandlerExports, {\n    FetchHttpHandler: () => f14,\n    keepAliveSupport: () => httpKeepAliveSupport,\n    streamCollector: () => _convertBlobToUint8Array\n  });\n  ModuleExports.exports = createModuleExports(httpHandlerExports);\n  var ________________________imageTransformationProcessor = ________________imageTransformationProcessor();\n  var ____processImageTransformationFunction = __processImageTransformationFunction();\n  function createRequest(urlOrRequestOptions, requestInitOptions) {\n    return new Request(urlOrRequestOptions, requestInitOptions);\n  }\n  _setFunctionName(createRequest, \"createRequest\");\n  function createTimeoutPromise(__timeoutDuration = 0) {\n    return new Promise((_handleTimeoutError, ___handleError) => {\n      if (__timeoutDuration) {\n        setTimeout(() => {\n          let _timeoutError = Error(`Request did not complete within ${__timeoutDuration} ms`);\n          _timeoutError.name = \"TimeoutError\";\n          ___handleError(_timeoutError);\n        }, __timeoutDuration);\n      }\n    });\n  }\n  _setFunctionName(createTimeoutPromise, \"requestTimeout\");\n  var httpKeepAliveSupport = {\n    supported: undefined\n  };\n  var f14 = class A {\n    static {\n      _setFunctionName(this, \"FetchHttpHandler\");\n    }\n    static create(B) {\n      if (typeof B?.handle === \"function\") {\n        return B;\n      }\n      return new A(B);\n    }\n    constructor(B) {\n      if (typeof B === \"function\") {\n        this.configProvider = B().then(optionsObject => optionsObject || {});\n      } else {\n        this.config = B ?? {};\n        this.configProvider = Promise.resolve(this.config);\n      }\n      if (httpKeepAliveSupport.supported === undefined) {\n        httpKeepAliveSupport.supported = Boolean(typeof Request !== \"undefined\" && \"keepalive\" in createRequest(\"https://[::1]\"));\n      }\n    }\n    destroy() {}\n    async handle(B, {\n      abortSignal: __abortSignal\n    } = {}) {\n      if (!this.config) {\n        this.config = await this.configProvider;\n      }\n      let I = this.config.requestTimeout;\n      let G = this.config.keepAlive === true;\n      let Z = this.config.credentials;\n      if (__abortSignal?.aborted) {\n        let abortError = Error(\"Request aborted\");\n        abortError.name = \"AbortError\";\n        return Promise.reject(abortError);\n      }\n      let Y = B.path;\n      let J = (0, ____processImageTransformationFunction.buildQueryString)(B.query || {});\n      if (J) {\n        Y += `?${J}`;\n      }\n      if (B.fragment) {\n        Y += `#${B.fragment}`;\n      }\n      let X = \"\";\n      if (B.username != null || B.password != null) {\n        let errorAbort = B.username ?? \"\";\n        let __password = B.password ?? \"\";\n        X = `${errorAbort}:${__password}@`;\n      }\n      let {\n        port: W,\n        method: F\n      } = B;\n      let C = `${B.protocol}//${X}${B.hostname}${W ? `:${W}` : \"\"}${Y}`;\n      let V = F === \"GET\" || F === \"HEAD\" ? undefined : B.body;\n      let K = {\n        body: V,\n        headers: new Headers(B.headers),\n        method: F,\n        credentials: Z\n      };\n      if (this.config?.cache) {\n        K.cache = this.config.cache;\n      }\n      if (V) {\n        K.duplex = \"half\";\n      }\n      if (typeof AbortController !== \"undefined\") {\n        K.signal = __abortSignal;\n      }\n      if (httpKeepAliveSupport.supported) {\n        K.keepalive = G;\n      }\n      if (typeof this.config.requestInit === \"function\") {\n        Object.assign(K, this.config.requestInit(B));\n      }\n      let D = _setFunctionName(() => {}, \"removeSignalEventListener\");\n      let E = createRequest(C, K);\n      let H = [fetch(E).then(httpResponseHandler => {\n        let responseHeaders = httpResponseHandler.headers;\n        let headersMap = {};\n        for (let headerEntry of responseHeaders.entries()) {\n          headersMap[headerEntry[0]] = headerEntry[1];\n        }\n        if (httpResponseHandler.body == null) {\n          return httpResponseHandler.blob().then(httpResponseBody => ({\n            response: new ________________________imageTransformationProcessor.HttpResponse({\n              headers: headersMap,\n              reason: httpResponseHandler.statusText,\n              statusCode: httpResponseHandler.status,\n              body: httpResponseBody\n            })\n          }));\n        }\n        return {\n          response: new ________________________imageTransformationProcessor.HttpResponse({\n            headers: headersMap,\n            reason: httpResponseHandler.statusText,\n            statusCode: httpResponseHandler.status,\n            body: httpResponseHandler.body\n          })\n        };\n      }), createTimeoutPromise(I)];\n      if (__abortSignal) {\n        H.push(new Promise((onAbortSignalReceived, handleAbortError) => {\n          let handleAbortSignal = _setFunctionName(() => {\n            let __abortError = Error(\"Request aborted\");\n            __abortError.name = \"AbortError\";\n            handleAbortError(__abortError);\n          }, \"onAbort\");\n          if (typeof __abortSignal.addEventListener === \"function\") {\n            let abortErrorCreator = __abortSignal;\n            abortErrorCreator.addEventListener(\"abort\", handleAbortSignal, {\n              once: true\n            });\n            D = _setFunctionName(() => abortErrorCreator.removeEventListener(\"abort\", handleAbortSignal), \"removeSignalEventListener\");\n          } else {\n            __abortSignal.onabort = handleAbortSignal;\n          }\n        }));\n      }\n      return Promise.race(H).finally(D);\n    }\n    updateHttpClientConfig(B, Q) {\n      this.config = undefined;\n      this.configProvider = this.configProvider.then(indexMapping => {\n        indexMapping[B] = Q;\n        return indexMapping;\n      });\n    }\n    httpHandlerConfigs() {\n      return this.config ?? {};\n    }\n  };\n  var _______________imageProcessor = _____________imageProcessor();\n  var _convertBlobToUint8Array = _setFunctionName(async convertBlobToUint8Array => {\n    if (typeof Blob === \"function\" && convertBlobToUint8Array instanceof Blob || convertBlobToUint8Array.constructor?.name === \"Blob\") {\n      if (Blob.prototype.arrayBuffer !== undefined) {\n        return new Uint8Array(await convertBlobToUint8Array.arrayBuffer());\n      }\n      return processImageFromFile(convertBlobToUint8Array);\n    }\n    return _readStreamToUint8Array(convertBlobToUint8Array);\n  }, \"streamCollector\");\n  async function processImageFromFile(fileInput) {\n    let imageDataURL = await readFileAsDataURL(fileInput);\n    let __processedImage = (0, _______________imageProcessor.fromBase64)(imageDataURL);\n    return new Uint8Array(__processedImage);\n  }\n  _setFunctionName(processImageFromFile, \"collectBlob\");\n  async function _readStreamToUint8Array(__readStreamToUint8Array) {\n    let _chunksArray = [];\n    let _readableStreamReader = __readStreamToUint8Array.getReader();\n    let __isStreamDone = false;\n    let __totalBytesRead = 0;\n    while (!__isStreamDone) {\n      let {\n        done: __isDone,\n        value: readStreamIntoUint8Array\n      } = await _readableStreamReader.read();\n      if (readStreamIntoUint8Array) {\n        _chunksArray.push(readStreamIntoUint8Array);\n        __totalBytesRead += readStreamIntoUint8Array.length;\n      }\n      __isStreamDone = __isDone;\n    }\n    let combinedUint8Array = new Uint8Array(__totalBytesRead);\n    let currentOffset = 0;\n    for (let __chunk of _chunksArray) {\n      combinedUint8Array.set(__chunk, currentOffset);\n      currentOffset += __chunk.length;\n    }\n    return combinedUint8Array;\n  }\n  _setFunctionName(_readStreamToUint8Array, \"collectStream\");\n  function readFileAsDataURL(_readFileAsDataURL) {\n    return new Promise((handleFileRead, ___errorCallback) => {\n      let fileReader = new FileReader();\n      fileReader.onloadend = () => {\n        if (fileReader.readyState !== 2) {\n          return ___errorCallback(Error(\"Reader aborted too early\"));\n        }\n        let resultData = fileReader.result ?? \"\";\n        let commaIndex = resultData.indexOf(\",\");\n        let substringStartIndex = commaIndex > -1 ? commaIndex + 1 : resultData.length;\n        handleFileRead(resultData.substring(substringStartIndex));\n      };\n      fileReader.onabort = () => ___errorCallback(Error(\"Read aborted\"));\n      fileReader.onerror = () => ___errorCallback(fileReader.error);\n      fileReader.readAsDataURL(_readFileAsDataURL);\n    });\n  }\n  _setFunctionName(readFileAsDataURL, \"readToBase64\");\n});\nvar imageTransformationHandler = z((hexadecimalConverter, ______________________moduleExports) => {\n  var {\n    defineProperty: ________definePropertyWithName,\n    getOwnPropertyDescriptor: getObjectPropertyDescriptor,\n    getOwnPropertyNames: ___________________getOwnPropertyNames\n  } = Object;\n  var __hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var ___defineFunctionName = (_______________________________________definePropertyWithName, _valueToDefine) => ________definePropertyWithName(_______________________________________definePropertyWithName, \"name\", {\n    value: _valueToDefine,\n    configurable: true\n  });\n  var ______________defineProperties = (definePropertiesWithGetter, _______________________________________________________________________________________________________sourceObject) => {\n    for (var ________________________________propertyKey in _______________________________________________________________________________________________________sourceObject) {\n      ________definePropertyWithName(definePropertiesWithGetter, ________________________________propertyKey, {\n        get: _______________________________________________________________________________________________________sourceObject[________________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesIfNotExists = (____copyProperties, ____________________________________________________________________________sourceObject, propertyMapper, _____________________propertyDescriptor) => {\n    if (____________________________________________________________________________sourceObject && typeof ____________________________________________________________________________sourceObject === \"object\" || typeof ____________________________________________________________________________sourceObject === \"function\") {\n      for (let _______________________propertyName of ___________________getOwnPropertyNames(____________________________________________________________________________sourceObject)) {\n        if (!__hasOwnPropertyCheck.call(____copyProperties, _______________________propertyName) && _______________________propertyName !== propertyMapper) {\n          ________definePropertyWithName(____copyProperties, _______________________propertyName, {\n            get: () => ____________________________________________________________________________sourceObject[_______________________propertyName],\n            enumerable: !(_____________________propertyDescriptor = getObjectPropertyDescriptor(____________________________________________________________________________sourceObject, _______________________propertyName)) || _____________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return ____copyProperties;\n  };\n  var __createModuleExports = ___definePropertiesIfNotExists => definePropertiesIfNotExists(________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), ___definePropertiesIfNotExists);\n  var hexConversionModule = {};\n  ______________defineProperties(hexConversionModule, {\n    fromHex: () => convertHexStringToUint8Array,\n    toHex: () => convertByteArrayToHexString\n  });\n  ______________________moduleExports.exports = __createModuleExports(hexConversionModule);\n  var hexValueMap = {};\n  var hexCharacterToDecimalMap = {};\n  for (let decimalToHexMappingIndex = 0; decimalToHexMappingIndex < 256; decimalToHexMappingIndex++) {\n    let hexValue = decimalToHexMappingIndex.toString(16).toLowerCase();\n    if (hexValue.length === 1) {\n      hexValue = `0${hexValue}`;\n    }\n    hexValueMap[decimalToHexMappingIndex] = hexValue;\n    hexCharacterToDecimalMap[hexValue] = decimalToHexMappingIndex;\n  }\n  function convertHexStringToUint8Array(hexStringToUint8Array) {\n    if (hexStringToUint8Array.length % 2 !== 0) {\n      throw Error(\"Hex encoded strings must have an even number length\");\n    }\n    let _uint8Array = new Uint8Array(hexStringToUint8Array.length / 2);\n    for (let hexStringIndex = 0; hexStringIndex < hexStringToUint8Array.length; hexStringIndex += 2) {\n      let hexPair = hexStringToUint8Array.slice(hexStringIndex, hexStringIndex + 2).toLowerCase();\n      if (hexPair in hexCharacterToDecimalMap) {\n        _uint8Array[hexStringIndex / 2] = hexCharacterToDecimalMap[hexPair];\n      } else {\n        throw Error(`Cannot decode unrecognized sequence ${hexPair} as hexadecimal`);\n      }\n    }\n    return _uint8Array;\n  }\n  ___defineFunctionName(convertHexStringToUint8Array, \"fromHex\");\n  function convertByteArrayToHexString(byteArrayToHexString) {\n    let hexString = \"\";\n    for (let currentByteIndex = 0; currentByteIndex < byteArrayToHexString.byteLength; currentByteIndex++) {\n      hexString += hexValueMap[byteArrayToHexString[currentByteIndex]];\n    }\n    return hexString;\n  }\n  ___defineFunctionName(convertByteArrayToHexString, \"toHex\");\n});\nvar _________________________________________________________processImageTransformation = z(streamTransformationMixin => {\n  Object.defineProperty(streamTransformationMixin, \"__esModule\", {\n    value: true\n  });\n  streamTransformationMixin.sdkStreamMixin = undefined;\n  var imageStreamTransformer = ______________imageProcessor();\n  var ________________imageProcessor = _____________imageProcessor();\n  var __imageTransformationHandler = imageTransformationHandler();\n  var ________________________________imageProcessingPipeline = ___________________imageProcessingPipeline();\n  var _____________________________________________processImageTransformation = processImageTransformatio();\n  var streamTransformationErrorMessage = \"The stream has already been transformed.\";\n  var createStreamTransformationMixin = ________processImage => {\n    if (!isBlobInstance(________processImage) && !(0, _____________________________________________processImageTransformation.isReadableStream)(________processImage)) {\n      let inputInstanceName = ________processImage?.__proto__?.constructor?.name || ________processImage;\n      throw Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${inputInstanceName}`);\n    }\n    let isTransformationInProgress = false;\n    let fetchImageStream = async () => {\n      if (isTransformationInProgress) {\n        throw Error(streamTransformationErrorMessage);\n      }\n      isTransformationInProgress = true;\n      return await (0, imageStreamTransformer.streamCollector)(________processImage);\n    };\n    let convertBlobToWebStream = blobToStreamConverter => {\n      if (typeof blobToStreamConverter.stream !== \"function\") {\n        throw Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);\n      }\n      return blobToStreamConverter.stream();\n    };\n    return Object.assign(________processImage, {\n      transformToByteArray: fetchImageStream,\n      transformToString: async format => {\n        let ____imageData = await fetchImageStream();\n        if (format === \"base64\") {\n          return (0, ________________imageProcessor.toBase64)(____imageData);\n        } else if (format === \"hex\") {\n          return (0, __imageTransformationHandler.toHex)(____imageData);\n        } else if (format === undefined || format === \"utf8\" || format === \"utf-8\") {\n          return (0, ________________________________imageProcessingPipeline.toUtf8)(____imageData);\n        } else if (typeof TextDecoder === \"function\") {\n          return new TextDecoder(format).decode(____imageData);\n        } else {\n          throw Error(\"TextDecoder is not available, please make sure polyfill is provided.\");\n        }\n      },\n      transformToWebStream: () => {\n        if (isTransformationInProgress) {\n          throw Error(streamTransformationErrorMessage);\n        }\n        isTransformationInProgress = true;\n        if (isBlobInstance(________processImage)) {\n          return convertBlobToWebStream(________processImage);\n        } else if ((0, _____________________________________________processImageTransformation.isReadableStream)(________processImage)) {\n          return ________processImage;\n        } else {\n          throw Error(`Cannot transform payload to web stream, got ${________processImage}`);\n        }\n      }\n    });\n  };\n  streamTransformationMixin.sdkStreamMixin = createStreamTransformationMixin;\n  var isBlobInstance = _isBlobInstance => typeof Blob === \"function\" && _isBlobInstance instanceof Blob;\n});\nvar ___________________imageProcessor = z(_streamTransformationMixin => {\n  Object.defineProperty(_streamTransformationMixin, \"__esModule\", {\n    value: true\n  });\n  _streamTransformationMixin.sdkStreamMixin = undefined;\n  var initializeStreamTransformation = processAndExportImageTransformation();\n  var processImageTransformationUtil = ________________________________________processImageTransformation();\n  var StreamMixin = EA(\"stream\");\n  var __streamTransformationMixin = _________________________________________________________processImageTransformation();\n  var errorMessageStreamTransformed = \"The stream has already been transformed.\";\n  var applyStreamTransformation = transformStream => {\n    if (!(transformStream instanceof StreamMixin.Readable)) {\n      try {\n        return (0, __streamTransformationMixin.sdkStreamMixin)(transformStream);\n      } catch (____error) {\n        let constructorName = transformStream?.__proto__?.constructor?.name || transformStream;\n        throw Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${constructorName}`);\n      }\n    }\n    let isStreamTransformed = false;\n    let _initializeStreamTransformation = async () => {\n      if (isStreamTransformed) {\n        throw Error(errorMessageStreamTransformed);\n      }\n      isStreamTransformed = true;\n      return await (0, initializeStreamTransformation.streamCollector)(transformStream);\n    };\n    return Object.assign(transformStream, {\n      transformToByteArray: _initializeStreamTransformation,\n      transformToString: async transformImageWithEncoding => {\n        let _imageBuffer = await _initializeStreamTransformation();\n        if (transformImageWithEncoding === undefined || Buffer.isEncoding(transformImageWithEncoding)) {\n          return (0, processImageTransformationUtil.fromArrayBuffer)(_imageBuffer.buffer, _imageBuffer.byteOffset, _imageBuffer.byteLength).toString(transformImageWithEncoding);\n        } else {\n          return new TextDecoder(transformImageWithEncoding).decode(_imageBuffer);\n        }\n      },\n      transformToWebStream: () => {\n        if (isStreamTransformed) {\n          throw Error(errorMessageStreamTransformed);\n        }\n        if (transformStream.readableFlowing !== null) {\n          throw Error(\"The stream has been consumed by other callbacks.\");\n        }\n        if (typeof StreamMixin.Readable.toWeb !== \"function\") {\n          throw Error(\"Readable.toWeb() is not supported. Please ensure a polyfill is available.\");\n        }\n        isStreamTransformed = true;\n        return StreamMixin.Readable.toWeb(transformStream);\n      }\n    });\n  };\n  _streamTransformationMixin.sdkStreamMixin = applyStreamTransformation;\n});\nvar ___________________________________processImageTransformation = z(___streamUtils => {\n  Object.defineProperty(___streamUtils, \"__esModule\", {\n    value: true\n  });\n  ___streamUtils.splitStream = streamTeeProcessor;\n  async function streamTeeProcessor(streamSource) {\n    if (typeof streamSource.stream === \"function\") {\n      streamSource = streamSource.stream();\n    }\n    return streamSource.tee();\n  }\n});\nvar _________________imageTransformationProcessor = z(_streamUtils => {\n  Object.defineProperty(_streamUtils, \"__esModule\", {\n    value: true\n  });\n  _streamUtils.splitStream = processInputStreamForImageTransformation;\n  var __streamUtils = EA(\"stream\");\n  var _________________________________________________processImageTransformation = ___________________________________processImageTransformation();\n  var imageTransformationUtils = processImageTransformatio();\n  async function processInputStreamForImageTransformation(__inputStream) {\n    if ((0, imageTransformationUtils.isReadableStream)(__inputStream) || (0, imageTransformationUtils.isBlob)(__inputStream)) {\n      return (0, _________________________________________________processImageTransformation.splitStream)(__inputStream);\n    }\n    let outputStreamSplitter = new __streamUtils.PassThrough();\n    let imageTransformationStream = new __streamUtils.PassThrough();\n    __inputStream.pipe(outputStreamSplitter);\n    __inputStream.pipe(imageTransformationStream);\n    return [outputStreamSplitter, imageTransformationStream];\n  }\n});\nvar ____________________imageProcessor = z((_initializeModuleExports, ___________________moduleExports) => {\n  var {\n    defineProperty: ________defineProperty,\n    getOwnPropertyDescriptor: __________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNamesEnhanced\n  } = Object;\n  var _________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___setFunctionName = (________________________________________definePropertyWithName, ______setFunctionName) => ________defineProperty(________________________________________definePropertyWithName, \"name\", {\n    value: ______setFunctionName,\n    configurable: true\n  });\n  var ____________defineProperties = (definePropertiesBasedOnObject, propertyGetter) => {\n    for (var _________________________________propertyKey in propertyGetter) {\n      ________defineProperty(definePropertiesBasedOnObject, _________________________________propertyKey, {\n        get: propertyGetter[_________________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var addPropertiesFromObject = (_____copyProperties, _______________________________________________________________________________sourceObject, _________propertyKey, ______________________propertyDescriptor) => {\n    if (_______________________________________________________________________________sourceObject && typeof _______________________________________________________________________________sourceObject === \"object\" || typeof _______________________________________________________________________________sourceObject === \"function\") {\n      for (let ________________________propertyName of getOwnPropertyNamesEnhanced(_______________________________________________________________________________sourceObject)) {\n        if (!_________________hasOwnProperty.call(_____copyProperties, ________________________propertyName) && ________________________propertyName !== _________propertyKey) {\n          ________defineProperty(_____copyProperties, ________________________propertyName, {\n            get: () => _______________________________________________________________________________sourceObject[________________________propertyName],\n            enumerable: !(______________________propertyDescriptor = __________________getOwnPropertyDescriptor(_______________________________________________________________________________sourceObject, ________________________propertyName)) || ______________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _____copyProperties;\n  };\n  var addPropertiesAndExport = (_____________________________________________________________________________________________________________sourceObject, ______________________________________________________________________________________________________________sourceObject, additionalProperties) => {\n    addPropertiesFromObject(_____________________________________________________________________________________________________________sourceObject, ______________________________________________________________________________________________________________sourceObject, \"default\");\n    return additionalProperties && addPropertiesFromObject(additionalProperties, ______________________________________________________________________________________________________________sourceObject, \"default\");\n  };\n  var createModuleWithExports = _addPropertiesFromObject => addPropertiesFromObject(________defineProperty({}, \"__esModule\", {\n    value: true\n  }), _addPropertiesFromObject);\n  var ____________________moduleExports = {};\n  ____________defineProperties(____________________moduleExports, {\n    Uint8ArrayBlobAdapter: () => $X1\n  });\n  ___________________moduleExports.exports = createModuleWithExports(____________________moduleExports);\n  var imageProcessorInstance = _____________imageProcessor();\n  var _______________________________imageProcessingPipeline = ___________________imageProcessingPipeline();\n  function processInputData(_____inputData, __encodingFormat = \"utf-8\") {\n    if (__encodingFormat === \"base64\") {\n      return (0, imageProcessorInstance.toBase64)(_____inputData);\n    }\n    return (0, _______________________________imageProcessingPipeline.toUtf8)(_____inputData);\n  }\n  ___setFunctionName(processInputData, \"transformToString\");\n  function ou0(___inputString, encodingType) {\n    if (encodingType === \"base64\") {\n      return $X1.mutate((0, imageProcessorInstance.fromBase64)(___inputString));\n    }\n    return $X1.mutate((0, _______________________________imageProcessingPipeline.fromUtf8)(___inputString));\n  }\n  ___setFunctionName(ou0, \"transformFromString\");\n  var $X1 = class A extends Uint8Array {\n    static {\n      ___setFunctionName(this, \"Uint8ArrayBlobAdapter\");\n    }\n    static fromString(__inputString, encodingFormat = \"utf-8\") {\n      switch (typeof __inputString) {\n        case \"string\":\n          return ou0(__inputString, encodingFormat);\n        default:\n          throw Error(`Unsupported conversion from ${typeof __inputString} to Uint8ArrayBlobAdapter.`);\n      }\n    }\n    static mutate(B) {\n      Object.setPrototypeOf(B, A.prototype);\n      return B;\n    }\n    transformToString(_encodingFormat = \"utf-8\") {\n      return processInputData(this, _encodingFormat);\n    }\n  };\n  addPropertiesAndExport(____________________moduleExports, ____________________________________imageProcessingPipeline(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, __________________imageProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, ____________________imageTransformationProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, ______imageProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, _______________imageTransformationProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, ___________________imageProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, _________________imageTransformationProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, processImageTransformatio(), ___________________moduleExports.exports);\n});\nvar __processImagePipeline = z((createSchemaExports, importSchema) => {\n  var {\n    defineProperty: __defineProperty,\n    getOwnPropertyDescriptor: __getOwnPropertyDescriptor,\n    getOwnPropertyNames: __getOwnPropertyNames\n  } = Object;\n  var ___hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___defineProperties = (___________definePropertiesWithGetters, _properties) => {\n    for (var __________________________________propertyKey in _properties) {\n      __defineProperty(___________definePropertiesWithGetters, __________________________________propertyKey, {\n        get: _properties[__________________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesForObject = (__definePropertiesIfNotExists, __________________________________________________________________________________sourceObject, _________excludedPropertyName, _______________________propertyDescriptor) => {\n    if (__________________________________________________________________________________sourceObject && typeof __________________________________________________________________________________sourceObject === \"object\" || typeof __________________________________________________________________________________sourceObject === \"function\") {\n      for (let _________________________propertyName of __getOwnPropertyNames(__________________________________________________________________________________sourceObject)) {\n        if (!___hasOwnProperty.call(__definePropertiesIfNotExists, _________________________propertyName) && _________________________propertyName !== _________excludedPropertyName) {\n          __defineProperty(__definePropertiesIfNotExists, _________________________propertyName, {\n            get: () => __________________________________________________________________________________sourceObject[_________________________propertyName],\n            enumerable: !(_______________________propertyDescriptor = __getOwnPropertyDescriptor(__________________________________________________________________________________sourceObject, _________________________propertyName)) || _______________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return __definePropertiesIfNotExists;\n  };\n  var _createSchemaExports = _definePropertiesForObject => definePropertiesForObject(__defineProperty({}, \"__esModule\", {\n    value: true\n  }), _definePropertiesForObject);\n  var schemaExports = {};\n  ___defineProperties(schemaExports, {\n    ErrorSchema: () => ExtendedStructureSchema,\n    ListSchema: () => ListSchemaDefinition,\n    MapSchema: () => MapSchemaDefinition,\n    NormalizedSchema: () => j04,\n    OperationSchema: () => OperationSchema,\n    SCHEMA: () => SchemaTypeRegistry,\n    Schema: () => SchemaDefinition,\n    SimpleSchema: () => ReactiveSchema,\n    StructureSchema: () => StructureSchema,\n    TypeRegistry: () => Si,\n    deref: () => invokeOrReturnValue,\n    deserializerMiddlewareOption: () => deserializerMiddlewareOption,\n    error: () => T04,\n    getSchemaSerdePlugin: () => _createRequestHandler,\n    list: () => L04,\n    map: () => M04,\n    op: () => O04,\n    serializerMiddlewareOption: () => serializerMiddlewareOptions,\n    sim: () => P04,\n    struct: () => R04\n  });\n  importSchema.exports = _createSchemaExports(schemaExports);\n  var invokeOrReturnValue = executeOrReturnValue => {\n    if (typeof executeOrReturnValue === \"function\") {\n      return executeOrReturnValue();\n    }\n    return executeOrReturnValue;\n  };\n  var metadataUpdate = updateMetadata();\n  var _____________________imageTransformationProcessor = ______________imageTransformationProcessor();\n  var handleOperationResponseWithDeserialization = handleOperationResponseWrapper => (handleHttpOperationResponse, operationContext) => async handleOperationResponse => {\n    let {\n      response: httpResponse\n    } = await handleHttpOperationResponse(handleOperationResponse);\n    let {\n      operationSchema: operationSchema\n    } = (0, _____________________imageTransformationProcessor.getSmithyContext)(operationContext);\n    try {\n      let deserializedOutput = await handleOperationResponseWrapper.protocol.deserializeResponse(operationSchema, {\n        ...handleOperationResponseWrapper,\n        ...operationContext\n      }, httpResponse);\n      return {\n        response: httpResponse,\n        output: deserializedOutput\n      };\n    } catch (deserializationError) {\n      Object.defineProperty(deserializationError, \"$response\", {\n        value: httpResponse\n      });\n      if (!(\"$metadata\" in deserializationError)) {\n        try {\n          deserializationError.message += `\n  Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;\n        } catch (_deserializationError) {\n          if (!operationContext.logger || operationContext.logger?.constructor?.name === \"NoOpLogger\") {\n            console.warn(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          } else {\n            operationContext.logger?.warn?.(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          }\n        }\n        if (typeof deserializationError.$responseBodyText !== \"undefined\") {\n          if (deserializationError.$response) {\n            deserializationError.$response.body = deserializationError.$responseBodyText;\n          }\n        }\n        try {\n          if (metadataUpdate.HttpResponse.isInstance(httpResponse)) {\n            let {\n              headers: error = {}\n            } = httpResponse;\n            let _responseHeadersArray = Object.entries(error);\n            deserializationError.$metadata = {\n              httpStatusCode: httpResponse.statusCode,\n              requestId: extractRequestIdFromHeaders(/^x-[\\w-]+-request-?id$/, _responseHeadersArray),\n              extendedRequestId: extractRequestIdFromHeaders(/^x-[\\w-]+-id-2$/, _responseHeadersArray),\n              cfId: extractRequestIdFromHeaders(/^x-[\\w-]+-cf-id$/, _responseHeadersArray)\n            };\n          }\n        } catch (_____________________error) {}\n      }\n      throw deserializationError;\n    }\n  };\n  var extractRequestIdFromHeaders = (stringMatcher, findMatchingString) => {\n    return (findMatchingString.find(([______inputString]) => {\n      return ______inputString.match(stringMatcher);\n    }) || [undefined, undefined])[1];\n  };\n  var ______________________imageTransformationProcessor = ______________imageTransformationProcessor();\n  var createOperationRequest = handleImageTransformationRequest => (___processRequest, ___smithyContext) => async _handleRequest => {\n    let {\n      operationSchema: _operationSchema\n    } = (0, ______________________imageTransformationProcessor.getSmithyContext)(___smithyContext);\n    let getEndpointUrl = ___smithyContext.endpointV2?.url && handleImageTransformationRequest.urlParser ? async () => handleImageTransformationRequest.urlParser(___smithyContext.endpointV2.url) : handleImageTransformationRequest.endpoint;\n    let serializedRequest = await handleImageTransformationRequest.protocol.serializeRequest(_operationSchema, _handleRequest.input, {\n      ...handleImageTransformationRequest,\n      ...___smithyContext,\n      endpoint: getEndpointUrl\n    });\n    return ___processRequest({\n      ..._handleRequest,\n      request: serializedRequest\n    });\n  };\n  var deserializerMiddlewareOption = {\n    name: \"deserializerMiddleware\",\n    step: \"deserialize\",\n    tags: [\"DESERIALIZER\"],\n    override: true\n  };\n  var serializerMiddlewareOptions = {\n    name: \"serializerMiddleware\",\n    step: \"serialize\",\n    tags: [\"SERIALIZER\"],\n    override: true\n  };\n  function _createRequestHandler(data) {\n    return {\n      applyToStack: middlewareStack => {\n        middlewareStack.add(createOperationRequest(data), serializerMiddlewareOptions);\n        middlewareStack.add(handleOperationResponseWithDeserialization(data), deserializerMiddlewareOption);\n        data.protocol.setSerdeContext(data);\n      }\n    };\n  }\n  var Si = class A {\n    constructor(B, schemaMap = new Map()) {\n      this.namespace = B;\n      this.schemas = schemaMap;\n    }\n    static {\n      this.registries = new Map();\n    }\n    static for(B) {\n      if (!A.registries.has(B)) {\n        A.registries.set(B, new A(B));\n      }\n      return A.registries.get(B);\n    }\n    register(B, Q) {\n      let I = this.normalizeShapeId(B);\n      A.for(this.getNamespace(B)).schemas.set(I, Q);\n    }\n    getSchema(B) {\n      let Q = this.normalizeShapeId(B);\n      if (!this.schemas.has(Q)) {\n        throw Error(`@smithy/core/schema - schema not found for ${Q}`);\n      }\n      return this.schemas.get(Q);\n    }\n    getBaseException() {\n      for (let [schemaEntry, serviceExceptionSchema] of this.schemas.entries()) {\n        if (schemaEntry.startsWith(\"smithy.ts.sdk.synthetic.\") && schemaEntry.endsWith(\"ServiceException\")) {\n          return serviceExceptionSchema;\n        }\n      }\n      return;\n    }\n    find(B) {\n      return [...this.schemas.values()].find(B);\n    }\n    destroy() {\n      A.registries.delete(this.namespace);\n      this.schemas.clear();\n    }\n    normalizeShapeId(B) {\n      if (B.includes(\"#\")) {\n        return B;\n      }\n      return this.namespace + \"#\" + B;\n    }\n    getNamespace(B) {\n      return this.normalizeShapeId(B).split(\"#\")[0];\n    }\n  };\n  var SchemaDefinition = class {\n    constructor(__name, traits) {\n      this.name = __name;\n      this.traits = traits;\n    }\n  };\n  var ListSchemaDefinition = class extends SchemaDefinition {\n    constructor(___name, ____traits, __valueSchema) {\n      super(___name, ____traits);\n      this.name = ___name;\n      this.traits = ____traits;\n      this.valueSchema = __valueSchema;\n    }\n  };\n  function L04(createAndRegisterMX1Instance, _dataHandler, Q = {}, initializationFunction) {\n    let G = new ListSchemaDefinition(createAndRegisterMX1Instance + \"#\" + _dataHandler, Q, typeof initializationFunction === \"function\" ? initializationFunction() : initializationFunction);\n    Si.for(createAndRegisterMX1Instance).register(_dataHandler, G);\n    return G;\n  }\n  var MapSchemaDefinition = class extends SchemaDefinition {\n    constructor(entityName, __traits, keySchema, _valueSchema) {\n      super(entityName, __traits);\n      this.name = entityName;\n      this.traits = __traits;\n      this.keySchema = keySchema;\n      this.valueSchema = _valueSchema;\n    }\n  };\n  function M04(createAndRegisterInstance, resourceIdentifier, Q = {}, identifier, callbackOrValue) {\n    let Z = new MapSchemaDefinition(createAndRegisterInstance + \"#\" + resourceIdentifier, Q, identifier, typeof callbackOrValue === \"function\" ? callbackOrValue() : callbackOrValue);\n    Si.for(createAndRegisterInstance).register(resourceIdentifier, Z);\n    return Z;\n  }\n  var OperationSchema = class extends SchemaDefinition {\n    constructor(_entityName, ___traits, _________inputData, outputSignal) {\n      super(_entityName, ___traits);\n      this.name = _entityName;\n      this.traits = ___traits;\n      this.input = _________inputData;\n      this.output = outputSignal;\n    }\n  };\n  function O04(_createRegisteredObject, ResourceManager, Q = {}, inputParameter, createBm0Instance) {\n    let Z = new OperationSchema(_createRegisteredObject + \"#\" + ResourceManager, Q, inputParameter, createBm0Instance);\n    Si.for(_createRegisteredObject).register(ResourceManager, Z);\n    return Z;\n  }\n  var StructureSchema = class extends SchemaDefinition {\n    constructor(nameParameter, _traits, memberNames, memberData) {\n      super(nameParameter, _traits);\n      this.name = nameParameter;\n      this.traits = _traits;\n      this.memberNames = memberNames;\n      this.memberList = memberData;\n      this.members = {};\n      for (let __memberIndex = 0; __memberIndex < memberNames.length; ++__memberIndex) {\n        this.members[memberNames[__memberIndex]] = Array.isArray(memberData[__memberIndex]) ? memberData[__memberIndex] : [memberData[__memberIndex], 0];\n      }\n    }\n  };\n  function R04(______inputData, userIdentifier, notificationService, _identifier, createNSAObject) {\n    let Z = new StructureSchema(______inputData + \"#\" + userIdentifier, notificationService, _identifier, createNSAObject);\n    Si.for(______inputData).register(userIdentifier, Z);\n    return Z;\n  }\n  var ExtendedStructureSchema = class extends StructureSchema {\n    constructor(constructorNameTraitsMemberNamesMemberListConstructorFunction, ______traits, _memberNames, memberList, constructorFunction) {\n      super(constructorNameTraitsMemberNamesMemberListConstructorFunction, ______traits, _memberNames, memberList);\n      this.name = constructorNameTraitsMemberNamesMemberListConstructorFunction;\n      this.traits = ______traits;\n      this.memberNames = _memberNames;\n      this.memberList = memberList;\n      this.ctor = constructorFunction;\n    }\n  };\n  function T04(_createAndRegisterInstance, resourceName, Q = {}, ______index, createRegisteredObject, dataProcessor) {\n    let Y = new ExtendedStructureSchema(_createAndRegisterInstance + \"#\" + resourceName, Q, ______index, createRegisteredObject, dataProcessor);\n    Si.for(_createAndRegisterInstance).register(resourceName, Y);\n    return Y;\n  }\n  var SchemaTypeRegistry = {\n    BLOB: 21,\n    STREAMING_BLOB: 42,\n    BOOLEAN: 2,\n    STRING: 0,\n    NUMERIC: 1,\n    BIG_INTEGER: 17,\n    BIG_DECIMAL: 19,\n    DOCUMENT: 15,\n    TIMESTAMP_DEFAULT: 4,\n    TIMESTAMP_DATE_TIME: 5,\n    TIMESTAMP_HTTP_DATE: 6,\n    TIMESTAMP_EPOCH_SECONDS: 7,\n    LIST_MODIFIER: 64,\n    MAP_MODIFIER: 128\n  };\n  var ReactiveSchema = class extends SchemaDefinition {\n    constructor(constructorEntityNameSchemaReferenceTraits, schemaReference, _____traits) {\n      super(constructorEntityNameSchemaReferenceTraits, _____traits);\n      this.name = constructorEntityNameSchemaReferenceTraits;\n      this.schemaRef = schemaReference;\n      this.traits = _____traits;\n    }\n  };\n  function P04(createNewRX1Instance, inputParameterB, createReactiveInstance, instanceIdentifier) {\n    let G = new ReactiveSchema(createNewRX1Instance + \"#\" + inputParameterB, createReactiveInstance, instanceIdentifier);\n    Si.for(createNewRX1Instance).register(inputParameterB, G);\n    return G;\n  }\n  var j04 = class A {\n    constructor(B, Q) {\n      this.ref = B;\n      this.memberName = Q;\n      let I = [];\n      let G = B;\n      let Z = B;\n      this._isMemberSchema = false;\n      while (Array.isArray(G)) {\n        I.push(G[1]);\n        G = G[0];\n        Z = invokeOrReturnValue(G);\n        this._isMemberSchema = true;\n      }\n      if (I.length > 0) {\n        this.memberTraits = {};\n        for (let _____index = I.length - 1; _____index >= 0; --_____index) {\n          let trait = I[_____index];\n          Object.assign(this.memberTraits, A.translateTraits(trait));\n        }\n      } else {\n        this.memberTraits = 0;\n      }\n      if (Z instanceof A) {\n        this.name = Z.name;\n        this.traits = Z.traits;\n        this._isMemberSchema = Z._isMemberSchema;\n        this.schema = Z.schema;\n        this.memberTraits = Object.assign({}, Z.getMemberTraits(), this.getMemberTraits());\n        this.normalizedTraits = undefined;\n        this.ref = Z.ref;\n        this.memberName = Q ?? Z.memberName;\n        return;\n      }\n      this.schema = invokeOrReturnValue(Z);\n      if (this.schema && typeof this.schema === \"object\") {\n        this.traits = this.schema?.traits ?? {};\n      } else {\n        this.traits = 0;\n      }\n      this.name = (typeof this.schema === \"object\" ? this.schema?.name : undefined) ?? this.memberName ?? this.getSchemaName();\n      if (this._isMemberSchema && !Q) {\n        throw Error(`@smithy/core/schema - NormalizedSchema member schema ${this.getName(true)} must initialize with memberName argument.`);\n      }\n    }\n    static of(B, Q) {\n      if (B instanceof A) {\n        return B;\n      }\n      return new A(B, Q);\n    }\n    static translateTraits(B) {\n      if (typeof B === \"object\") {\n        return B;\n      }\n      B = B | 0;\n      let Q = {};\n      if ((B & 1) === 1) {\n        Q.httpLabel = 1;\n      }\n      if ((B >> 1 & 1) === 1) {\n        Q.idempotent = 1;\n      }\n      if ((B >> 2 & 1) === 1) {\n        Q.idempotencyToken = 1;\n      }\n      if ((B >> 3 & 1) === 1) {\n        Q.sensitive = 1;\n      }\n      if ((B >> 4 & 1) === 1) {\n        Q.httpPayload = 1;\n      }\n      if ((B >> 5 & 1) === 1) {\n        Q.httpResponseCode = 1;\n      }\n      if ((B >> 6 & 1) === 1) {\n        Q.httpQueryParams = 1;\n      }\n      return Q;\n    }\n    static memberFrom(B, Q) {\n      if (B instanceof A) {\n        B.memberName = Q;\n        B._isMemberSchema = true;\n        return B;\n      }\n      return new A(B, Q);\n    }\n    getSchema() {\n      if (this.schema instanceof A) {\n        return this.schema = this.schema.getSchema();\n      }\n      if (this.schema instanceof ReactiveSchema) {\n        return invokeOrReturnValue(this.schema.schemaRef);\n      }\n      return invokeOrReturnValue(this.schema);\n    }\n    getName(isNameHashtagExcluded = false) {\n      if (!isNameHashtagExcluded) {\n        if (this.name && this.name.includes(\"#\")) {\n          return this.name.split(\"#\")[1];\n        }\n      }\n      return this.name || undefined;\n    }\n    getMemberName() {\n      if (!this.isMemberSchema()) {\n        throw Error(`@smithy/core/schema - cannot get member name on non-member schema: ${this.getName(true)}`);\n      }\n      return this.memberName;\n    }\n    isMemberSchema() {\n      return this._isMemberSchema;\n    }\n    isUnitSchema() {\n      return this.getSchema() === \"unit\";\n    }\n    isListSchema() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        return B >= SchemaTypeRegistry.LIST_MODIFIER && B < SchemaTypeRegistry.MAP_MODIFIER;\n      }\n      return B instanceof ListSchemaDefinition;\n    }\n    isMapSchema() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        return B >= SchemaTypeRegistry.MAP_MODIFIER && B <= 255;\n      }\n      return B instanceof MapSchemaDefinition;\n    }\n    isDocumentSchema() {\n      return this.getSchema() === SchemaTypeRegistry.DOCUMENT;\n    }\n    isStructSchema() {\n      let B = this.getSchema();\n      return B !== null && typeof B === \"object\" && \"members\" in B || B instanceof StructureSchema;\n    }\n    isBlobSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BLOB || this.getSchema() === SchemaTypeRegistry.STREAMING_BLOB;\n    }\n    isTimestampSchema() {\n      let B = this.getSchema();\n      return typeof B === \"number\" && B >= SchemaTypeRegistry.TIMESTAMP_DEFAULT && B <= SchemaTypeRegistry.TIMESTAMP_EPOCH_SECONDS;\n    }\n    isStringSchema() {\n      return this.getSchema() === SchemaTypeRegistry.STRING;\n    }\n    isBooleanSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BOOLEAN;\n    }\n    isNumericSchema() {\n      return this.getSchema() === SchemaTypeRegistry.NUMERIC;\n    }\n    isBigIntegerSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BIG_INTEGER;\n    }\n    isBigDecimalSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BIG_DECIMAL;\n    }\n    isStreaming() {\n      if (this.getMergedTraits().streaming) {\n        return true;\n      }\n      return this.getSchema() === SchemaTypeRegistry.STREAMING_BLOB;\n    }\n    getMergedTraits() {\n      if (this.normalizedTraits) {\n        return this.normalizedTraits;\n      }\n      this.normalizedTraits = {\n        ...this.getOwnTraits(),\n        ...this.getMemberTraits()\n      };\n      return this.normalizedTraits;\n    }\n    getMemberTraits() {\n      return A.translateTraits(this.memberTraits);\n    }\n    getOwnTraits() {\n      return A.translateTraits(this.traits);\n    }\n    getKeySchema() {\n      if (this.isDocumentSchema()) {\n        return A.memberFrom([SchemaTypeRegistry.DOCUMENT, 0], \"key\");\n      }\n      if (!this.isMapSchema()) {\n        throw Error(`@smithy/core/schema - cannot get key schema for non-map schema: ${this.getName(true)}`);\n      }\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        return A.memberFrom([B & 63, 0], \"key\");\n      }\n      return A.memberFrom([B.keySchema, 0], \"key\");\n    }\n    getValueSchema() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        if (this.isMapSchema()) {\n          return A.memberFrom([B & 63, 0], \"value\");\n        } else if (this.isListSchema()) {\n          return A.memberFrom([B & 63, 0], \"member\");\n        }\n      }\n      if (B && typeof B === \"object\") {\n        if (this.isStructSchema()) {\n          throw Error(`cannot call getValueSchema() with StructureSchema ${this.getName(true)}`);\n        }\n        let schemaDefinition = B;\n        if (\"valueSchema\" in schemaDefinition) {\n          if (this.isMapSchema()) {\n            return A.memberFrom([schemaDefinition.valueSchema, 0], \"value\");\n          } else if (this.isListSchema()) {\n            return A.memberFrom([schemaDefinition.valueSchema, 0], \"member\");\n          }\n        }\n      }\n      if (this.isDocumentSchema()) {\n        return A.memberFrom([SchemaTypeRegistry.DOCUMENT, 0], \"value\");\n      }\n      throw Error(`@smithy/core/schema - the schema ${this.getName(true)} does not have a value member.`);\n    }\n    getMemberSchema(B) {\n      if (this.isStructSchema()) {\n        let _schemaDefinition = this.getSchema();\n        if (!(B in _schemaDefinition.members)) {\n          throw Error(`@smithy/core/schema - the schema ${this.getName(true)} does not have a member with name=${B}.`);\n        }\n        return A.memberFrom(_schemaDefinition.members[B], B);\n      }\n      if (this.isDocumentSchema()) {\n        return A.memberFrom([SchemaTypeRegistry.DOCUMENT, 0], B);\n      }\n      throw Error(`@smithy/core/schema - the schema ${this.getName(true)} does not have members.`);\n    }\n    getMemberSchemas() {\n      let {\n        schema: B\n      } = this;\n      let Q = B;\n      if (!Q || typeof Q !== \"object\") {\n        return {};\n      }\n      if (\"members\" in Q) {\n        let __memberSchemas = {};\n        for (let _memberName of Q.memberNames) {\n          __memberSchemas[_memberName] = this.getMemberSchema(_memberName);\n        }\n        return __memberSchemas;\n      }\n      return {};\n    }\n    *structIterator() {\n      if (this.isUnitSchema()) {\n        return;\n      }\n      if (!this.isStructSchema()) {\n        throw Error(\"@smithy/core/schema - cannot acquire structIterator on non-struct schema.\");\n      }\n      let B = this.getSchema();\n      for (let memberIndex = 0; memberIndex < B.memberNames.length; ++memberIndex) {\n        yield [B.memberNames[memberIndex], A.memberFrom([B.memberList[memberIndex], 0], B.memberNames[memberIndex])];\n      }\n    }\n    getSchemaName() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        let modifierMask = B & 63;\n        let schemaModifier = B & 192;\n        let schemaType = Object.entries(SchemaTypeRegistry).find(([, isModifierMaskEqual]) => {\n          return isModifierMaskEqual === modifierMask;\n        })?.[0] ?? \"Unknown\";\n        switch (schemaModifier) {\n          case SchemaTypeRegistry.MAP_MODIFIER:\n            return `${schemaType}Map`;\n          case SchemaTypeRegistry.LIST_MODIFIER:\n            return `${schemaType}List`;\n          case 0:\n            return schemaType;\n        }\n      }\n      return \"Unknown\";\n    }\n  };\n});\nvar ____________________________________________________processImageTransformation = z((initializeModule, __moduleExports) => {\n  var {\n    defineProperty: _defineProperty,\n    getOwnPropertyDescriptor: _getOwnPropertyDescriptor,\n    getOwnPropertyNames: getObjectOwnPropertyNames\n  } = Object;\n  var __hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __defineProperties = (_______________________defineProperties, __propertyAccessor) => {\n    for (var ___________________________________propertyKey in __propertyAccessor) {\n      _defineProperty(_______________________defineProperties, ___________________________________propertyKey, {\n        get: __propertyAccessor[___________________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var assignPropertiesIfNew = (______definePropertiesFromSource, _____________________________________________________________________________________sourceObject, propertyNameToExclude, isEnumerable) => {\n    if (_____________________________________________________________________________________sourceObject && typeof _____________________________________________________________________________________sourceObject === \"object\" || typeof _____________________________________________________________________________________sourceObject === \"function\") {\n      for (let __________________________propertyName of getObjectOwnPropertyNames(_____________________________________________________________________________________sourceObject)) {\n        if (!__hasOwnProperty.call(______definePropertiesFromSource, __________________________propertyName) && __________________________propertyName !== propertyNameToExclude) {\n          _defineProperty(______definePropertiesFromSource, __________________________propertyName, {\n            get: () => _____________________________________________________________________________________sourceObject[__________________________propertyName],\n            enumerable: !(isEnumerable = _getOwnPropertyDescriptor(_____________________________________________________________________________________sourceObject, __________________________propertyName)) || isEnumerable.enumerable\n          });\n        }\n      }\n    }\n    return ______definePropertiesFromSource;\n  };\n  var assignPropertiesToModule = _assignPropertiesIfNew => assignPropertiesIfNew(_defineProperty({}, \"__esModule\", {\n    value: true\n  }), _assignPropertiesIfNew);\n  var ___moduleExports = {};\n  __defineProperties(___moduleExports, {\n    LazyJsonString: () => createStringWithJSONMethods,\n    NumericValue: () => NumericValue,\n    copyDocumentWithTransform: () => mJA,\n    dateToUtcString: () => convertDateToUtcString,\n    expectBoolean: () => convertToBooleanValue,\n    expectByte: () => validateTypedInteger8Bit,\n    expectFloat32: () => validateFloat32,\n    expectInt: () => validateIntegerInput,\n    expectInt32: () => expectInt32Value,\n    expectLong: () => validateIntegerValue,\n    expectNonNull: () => expectNonNullValue,\n    expectNumber: () => convertToNumber,\n    expectObject: () => expectObject,\n    expectShort: () => expectShortInteger,\n    expectString: () => expectStringValue,\n    expectUnion: () => expectUnionValue,\n    handleFloat: () => handleSpecialFloatValue,\n    limitedParseDouble: () => __parseSpecialFloatValue,\n    limitedParseFloat: () => parseSpecialFloatString,\n    limitedParseFloat32: () => validateFloat32WithSpecialCases,\n    logger: () => consoleLogger,\n    nv: () => convertToBigDecimal,\n    parseBoolean: () => parseBooleanString,\n    parseEpochTimestamp: () => parseEpochTimestampToDate,\n    parseRfc3339DateTime: () => parseRfc3339DateTime,\n    parseRfc3339DateTimeWithOffset: () => parseRFC3339DateTimeWithOffset,\n    parseRfc7231DateTime: () => parseRfc7231DateTimeString,\n    quoteHeader: () => wrapStringInQuotesIfNeeded,\n    splitEvery: () => splitIntoChunksByDelimiter,\n    splitHeader: () => splitCSV,\n    strictParseByte: () => _validateTypedInteger8Bit,\n    strictParseDouble: () => strictParseDouble,\n    strictParseFloat: () => strictParseFloatValue,\n    strictParseFloat32: () => validateFloat32Input,\n    strictParseInt: () => strictParsePositiveInteger,\n    strictParseInt32: () => expectInt32ValueFromInput,\n    strictParseLong: () => strictParseLongInteger,\n    strictParseShort: () => validateShortIntegerInput\n  });\n  __moduleExports.exports = assignPropertiesToModule(___moduleExports);\n  var ______________________________imageProcessingPipeline = __processImagePipeline();\n  var mJA = (A, B, Q = ___________index => ___________index) => {\n    let I = ______________________________imageProcessingPipeline.NormalizedSchema.of(B);\n    switch (typeof A) {\n      case \"undefined\":\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n      case \"bigint\":\n      case \"symbol\":\n        return Q(A, I);\n      case \"function\":\n      case \"object\":\n        if (A === null) {\n          return Q(null, I);\n        }\n        if (Array.isArray(A)) {\n          let element = Array(A.length);\n          let arrayIndex = 0;\n          for (let ____item of A) {\n            element[arrayIndex++] = mJA(____item, I.getValueSchema(), Q);\n          }\n          return Q(element, I);\n        }\n        if (\"byteLength\" in A) {\n          let transformedArray = new Uint8Array(A.byteLength);\n          transformedArray.set(A, 0);\n          return Q(transformedArray, I);\n        }\n        if (A instanceof Date) {\n          return Q(A, I);\n        }\n        let G = {};\n        if (I.isMapSchema()) {\n          for (let __key of Object.keys(A)) {\n            G[__key] = mJA(A[__key], I.getValueSchema(), Q);\n          }\n        } else if (I.isStructSchema()) {\n          for (let [itemKey, itemValue] of I.structIterator()) {\n            G[itemKey] = mJA(A[itemKey], itemValue, Q);\n          }\n        } else if (I.isDocumentSchema()) {\n          for (let ___key of Object.keys(A)) {\n            G[___key] = mJA(A[___key], I.getValueSchema(), Q);\n          }\n        }\n        return Q(G, I);\n      default:\n        return Q(A, I);\n    }\n  };\n  var parseBooleanString = parseBooleanValue => {\n    switch (parseBooleanValue) {\n      case \"true\":\n        return true;\n      case \"false\":\n        return false;\n      default:\n        throw Error(`Unable to parse boolean value \"${parseBooleanValue}\"`);\n    }\n  };\n  var convertToBooleanValue = convertToBoolean => {\n    if (convertToBoolean === null || convertToBoolean === undefined) {\n      return;\n    }\n    if (typeof convertToBoolean === \"number\") {\n      if (convertToBoolean === 0 || convertToBoolean === 1) {\n        consoleLogger.warn(generateStackTrace(`Expected boolean, got ${typeof convertToBoolean}: ${convertToBoolean}`));\n      }\n      if (convertToBoolean === 0) {\n        return false;\n      }\n      if (convertToBoolean === 1) {\n        return true;\n      }\n    }\n    if (typeof convertToBoolean === \"string\") {\n      let normalizedString = convertToBoolean.toLowerCase();\n      if (normalizedString === \"false\" || normalizedString === \"true\") {\n        consoleLogger.warn(generateStackTrace(`Expected boolean, got ${typeof convertToBoolean}: ${convertToBoolean}`));\n      }\n      if (normalizedString === \"false\") {\n        return false;\n      }\n      if (normalizedString === \"true\") {\n        return true;\n      }\n    }\n    if (typeof convertToBoolean === \"boolean\") {\n      return convertToBoolean;\n    }\n    throw TypeError(`Expected boolean, got ${typeof convertToBoolean}: ${convertToBoolean}`);\n  };\n  var convertToNumber = _convertToNumber => {\n    if (_convertToNumber === null || _convertToNumber === undefined) {\n      return;\n    }\n    if (typeof _convertToNumber === \"string\") {\n      let parsedNumber = parseFloat(_convertToNumber);\n      if (!Number.isNaN(parsedNumber)) {\n        if (String(parsedNumber) !== String(_convertToNumber)) {\n          consoleLogger.warn(generateStackTrace(`Expected number but observed string: ${_convertToNumber}`));\n        }\n        return parsedNumber;\n      }\n    }\n    if (typeof _convertToNumber === \"number\") {\n      return _convertToNumber;\n    }\n    throw TypeError(`Expected number, got ${typeof _convertToNumber}: ${_convertToNumber}`);\n  };\n  var MAX_32_BIT_FLOAT = Math.ceil(3.4028234663852886e+38);\n  var validateFloat32 = convertAndValidateInput => {\n    let convertedNumber = convertToNumber(convertAndValidateInput);\n    if (convertedNumber !== undefined && !Number.isNaN(convertedNumber) && convertedNumber !== Infinity && convertedNumber !== -Infinity) {\n      if (Math.abs(convertedNumber) > MAX_32_BIT_FLOAT) {\n        throw TypeError(`Expected 32-bit float, got ${convertAndValidateInput}`);\n      }\n    }\n    return convertedNumber;\n  };\n  var validateIntegerValue = validateInteger => {\n    if (validateInteger === null || validateInteger === undefined) {\n      return;\n    }\n    if (Number.isInteger(validateInteger) && !Number.isNaN(validateInteger)) {\n      return validateInteger;\n    }\n    throw TypeError(`Expected integer, got ${typeof validateInteger}: ${validateInteger}`);\n  };\n  var validateIntegerInput = validateIntegerValue;\n  var expectInt32Value = ___________inputValue => validateTypedInteger(___________inputValue, 32);\n  var expectShortInteger = typedIntegerValidation => validateTypedInteger(typedIntegerValidation, 16);\n  var validateTypedInteger8Bit = ____________inputValue => validateTypedInteger(____________inputValue, 8);\n  var validateTypedInteger = (__________inputValue, bitWidth) => {\n    let validatedIntegerValue = validateIntegerValue(__________inputValue);\n    if (validatedIntegerValue !== undefined && convertToTypedInteger(validatedIntegerValue, bitWidth) !== validatedIntegerValue) {\n      throw TypeError(`Expected ${bitWidth}-bit integer, got ${__________inputValue}`);\n    }\n    return validatedIntegerValue;\n  };\n  var convertToTypedInteger = (convertNumberToTypedArray, bitDepth) => {\n    switch (bitDepth) {\n      case 32:\n        return Int32Array.of(convertNumberToTypedArray)[0];\n      case 16:\n        return Int16Array.of(convertNumberToTypedArray)[0];\n      case 8:\n        return Int8Array.of(convertNumberToTypedArray)[0];\n    }\n  };\n  var expectNonNullValue = (__validateInput, valueOrThrow) => {\n    if (__validateInput === null || __validateInput === undefined) {\n      if (valueOrThrow) {\n        throw TypeError(`Expected a non-null value for ${valueOrThrow}`);\n      }\n      throw TypeError(\"Expected a non-null value\");\n    }\n    return __validateInput;\n  };\n  var expectObject = validateInput => {\n    if (validateInput === null || validateInput === undefined) {\n      return;\n    }\n    if (typeof validateInput === \"object\" && !Array.isArray(validateInput)) {\n      return validateInput;\n    }\n    let dataTypeDescription = Array.isArray(validateInput) ? \"array\" : typeof validateInput;\n    throw TypeError(`Expected object, got ${dataTypeDescription}: ${validateInput}`);\n  };\n  var expectStringValue = processInputValue => {\n    if (processInputValue === null || processInputValue === undefined) {\n      return;\n    }\n    if (typeof processInputValue === \"string\") {\n      return processInputValue;\n    }\n    if ([\"boolean\", \"number\", \"bigint\"].includes(typeof processInputValue)) {\n      consoleLogger.warn(generateStackTrace(`Expected string, got ${typeof processInputValue}: ${processInputValue}`));\n      return String(processInputValue);\n    }\n    throw TypeError(`Expected string, got ${typeof processInputValue}: ${processInputValue}`);\n  };\n  var expectUnionValue = validateAndExtractNonNullMember => {\n    if (validateAndExtractNonNullMember === null || validateAndExtractNonNullMember === undefined) {\n      return;\n    }\n    let validatedObject = expectObject(validateAndExtractNonNullMember);\n    let nonNullKeys = Object.entries(validatedObject).filter(([, __inputValue]) => __inputValue != null).map(([_____inputValue]) => _____inputValue);\n    if (nonNullKeys.length === 0) {\n      throw TypeError(\"Unions must have exactly one non-null member. None were found.\");\n    }\n    if (nonNullKeys.length > 1) {\n      throw TypeError(`Unions must have exactly one non-null member. Keys ${nonNullKeys} were not null.`);\n    }\n    return validatedObject;\n  };\n  var strictParseDouble = inputToNumberConverter => {\n    if (typeof inputToNumberConverter == \"string\") {\n      return convertToNumber(parseNumericString(inputToNumberConverter));\n    }\n    return convertToNumber(inputToNumberConverter);\n  };\n  var strictParseFloatValue = strictParseDouble;\n  var validateFloat32Input = float32ValidatorOrParser => {\n    if (typeof float32ValidatorOrParser == \"string\") {\n      return validateFloat32(parseNumericString(float32ValidatorOrParser));\n    }\n    return validateFloat32(float32ValidatorOrParser);\n  };\n  var numericRegexPattern = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\n  var parseNumericString = parseAndValidateNumericString => {\n    let matchedNumericValues = parseAndValidateNumericString.match(numericRegexPattern);\n    if (matchedNumericValues === null || matchedNumericValues[0].length !== parseAndValidateNumericString.length) {\n      throw TypeError(\"Expected real number, got implicit NaN\");\n    }\n    return parseFloat(parseAndValidateNumericString);\n  };\n  var __parseSpecialFloatValue = __processInputValue => {\n    if (typeof __processInputValue == \"string\") {\n      return parseSpecialFloatValue(__processInputValue);\n    }\n    return convertToNumber(__processInputValue);\n  };\n  var handleSpecialFloatValue = __parseSpecialFloatValue;\n  var parseSpecialFloatString = __parseSpecialFloatValue;\n  var validateFloat32WithSpecialCases = ____processInputValue => {\n    if (typeof ____processInputValue == \"string\") {\n      return parseSpecialFloatValue(____processInputValue);\n    }\n    return validateFloat32(____processInputValue);\n  };\n  var parseSpecialFloatValue = _parseSpecialFloatValue => {\n    switch (_parseSpecialFloatValue) {\n      case \"NaN\":\n        return NaN;\n      case \"Infinity\":\n        return Infinity;\n      case \"-Infinity\":\n        return -Infinity;\n      default:\n        throw Error(`Unable to parse float value: ${_parseSpecialFloatValue}`);\n    }\n  };\n  var strictParseLongInteger = validateAndConvertToInteger => {\n    if (typeof validateAndConvertToInteger === \"string\") {\n      return validateIntegerValue(parseNumericString(validateAndConvertToInteger));\n    }\n    return validateIntegerValue(validateAndConvertToInteger);\n  };\n  var strictParsePositiveInteger = strictParseLongInteger;\n  var expectInt32ValueFromInput = validateAndConvertToInt32 => {\n    if (typeof validateAndConvertToInt32 === \"string\") {\n      return expectInt32Value(parseNumericString(validateAndConvertToInt32));\n    }\n    return expectInt32Value(validateAndConvertToInt32);\n  };\n  var validateShortIntegerInput = processInputAndValidate => {\n    if (typeof processInputAndValidate === \"string\") {\n      return expectShortInteger(parseNumericString(processInputAndValidate));\n    }\n    return expectShortInteger(processInputAndValidate);\n  };\n  var _validateTypedInteger8Bit = _validateIntegerInput => {\n    if (typeof _validateIntegerInput === \"string\") {\n      return validateTypedInteger8Bit(parseNumericString(_validateIntegerInput));\n    }\n    return validateTypedInteger8Bit(_validateIntegerInput);\n  };\n  var generateStackTrace = getErrorStackTrace => {\n    return String(TypeError(getErrorStackTrace).stack || getErrorStackTrace).split(`\n`).slice(0, 5).filter(isNotStackTraceWarning => !isNotStackTraceWarning.includes(\"stackTraceWarning\")).join(`\n`);\n  };\n  var consoleLogger = {\n    warn: console.warn\n  };\n  var weekDaysShort = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n  var monthsArray = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  function convertDateToUtcString(dateToUtcString) {\n    let year = dateToUtcString.getUTCFullYear();\n    let monthIndex = dateToUtcString.getUTCMonth();\n    let dayOfWeek = dateToUtcString.getUTCDay();\n    let utcDate = dateToUtcString.getUTCDate();\n    let utchan = dateToUtcString.getUTCHours();\n    let utcMinutes = dateToUtcString.getUTCMinutes();\n    let seconds = dateToUtcString.getUTCSeconds();\n    let formattedDate = utcDate < 10 ? `0${utcDate}` : `${utcDate}`;\n    let formattedHours = utchan < 10 ? `0${utchan}` : `${utchan}`;\n    let formattedMinutes = utcMinutes < 10 ? `0${utcMinutes}` : `${utcMinutes}`;\n    let formattedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;\n    return `${weekDaysShort[dayOfWeek]}, ${formattedDate} ${monthsArray[monthIndex]} ${year} ${formattedHours}:${formattedMinutes}:${formattedSeconds} GMT`;\n  }\n  var RFC3339DateTimePattern = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?[zZ]$/);\n  var parseRfc3339DateTime = ____parseRFC3339DateTime => {\n    if (____parseRFC3339DateTime === null || ____parseRFC3339DateTime === undefined) {\n      return;\n    }\n    if (typeof ____parseRFC3339DateTime !== \"string\") {\n      throw TypeError(\"RFC-3339 date-times must be expressed as strings\");\n    }\n    let matchedRFC3339Parts = RFC3339DateTimePattern.exec(____parseRFC3339DateTime);\n    if (!matchedRFC3339Parts) {\n      throw TypeError(\"Invalid RFC-3339 date-time value\");\n    }\n    let [__dateTimeComponents, hourString, _monthValue, ______day, hoursInTimeString, ____minutes, parsedSeconds, ____fractionalMilliseconds] = matchedRFC3339Parts;\n    let parsedYear = validateShortIntegerInput(removeLeadingZeros(hourString));\n    let validatedMonth = validateIntegerInRange(_monthValue, \"month\", 1, 12);\n    let validatedDay = validateIntegerInRange(______day, \"day\", 1, 31);\n    return createDateFromComponents(parsedYear, validatedMonth, validatedDay, {\n      hours: hoursInTimeString,\n      minutes: ____minutes,\n      seconds: parsedSeconds,\n      fractionalMilliseconds: ____fractionalMilliseconds\n    });\n  };\n  var rfc3339DateTimeRegex = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\d{2}\\:\\d{2})|[zZ])$/);\n  var parseRFC3339DateTimeWithOffset = parseRFC3339DateTime => {\n    if (parseRFC3339DateTime === null || parseRFC3339DateTime === undefined) {\n      return;\n    }\n    if (typeof parseRFC3339DateTime !== \"string\") {\n      throw TypeError(\"RFC-3339 date-times must be expressed as strings\");\n    }\n    let regexMatchResult = rfc3339DateTimeRegex.exec(parseRFC3339DateTime);\n    if (!regexMatchResult) {\n      throw TypeError(\"Invalid RFC-3339 date-time value\");\n    }\n    let [dateTimeString, parsedDate, monthValue, _____day, timeZoneHours, ___minutes, __parseRFC3339DateTime, ___fractionalMilliseconds, ___parseRFC3339DateTime] = regexMatchResult;\n    let validatedYear = validateShortIntegerInput(removeLeadingZeros(parsedDate));\n    let __monthIndex = validateIntegerInRange(monthValue, \"month\", 1, 12);\n    let dayOfMonth = validateIntegerInRange(_____day, \"day\", 1, 31);\n    let dateObject = createDateFromComponents(validatedYear, __monthIndex, dayOfMonth, {\n      hours: timeZoneHours,\n      minutes: ___minutes,\n      seconds: __parseRFC3339DateTime,\n      fractionalMilliseconds: ___fractionalMilliseconds\n    });\n    if (___parseRFC3339DateTime.toUpperCase() != \"Z\") {\n      dateObject.setTime(dateObject.getTime() - parseTimezoneOffset(___parseRFC3339DateTime));\n    }\n    return dateObject;\n  };\n  var RFC7231DateTimeRegex = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\n  var rfcWeekdayDateTimeFormat = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\n  var rfc7231DateTimeRegex = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\n  var parseRfc7231DateTimeString = parseRFC7231DateTime => {\n    if (parseRFC7231DateTime === null || parseRFC7231DateTime === undefined) {\n      return;\n    }\n    if (typeof parseRFC7231DateTime !== \"string\") {\n      throw TypeError(\"RFC-7231 date-times must be expressed as strings\");\n    }\n    let matchedDateComponents = RFC7231DateTimeRegex.exec(parseRFC7231DateTime);\n    if (matchedDateComponents) {\n      let [dateTimeComponents, _day, dayString, dayOrYearPart, hours, minutes, __parseRFC7231DateTime, fractionalMilliseconds] = matchedDateComponents;\n      return createDateFromComponents(validateShortIntegerInput(removeLeadingZeros(dayOrYearPart)), convertMonthToIndex(dayString), validateIntegerInRange(_day, \"day\", 1, 31), {\n        hours: hours,\n        minutes: minutes,\n        seconds: __parseRFC7231DateTime,\n        fractionalMilliseconds: fractionalMilliseconds\n      });\n    }\n    matchedDateComponents = rfcWeekdayDateTimeFormat.exec(parseRFC7231DateTime);\n    if (matchedDateComponents) {\n      let [_dateTimeComponents, __day, ___day, hourComponent, _hours, _minutes, ___parseRFC7231DateTime, _fractionalMilliseconds] = matchedDateComponents;\n      return adjustDateForHistoricalLimit(createDateFromComponents(normalizeYearForTwoDigitFormat(hourComponent), convertMonthToIndex(___day), validateIntegerInRange(__day, \"day\", 1, 31), {\n        hours: _hours,\n        minutes: _minutes,\n        seconds: ___parseRFC7231DateTime,\n        fractionalMilliseconds: _fractionalMilliseconds\n      }));\n    }\n    matchedDateComponents = rfc7231DateTimeRegex.exec(parseRFC7231DateTime);\n    if (matchedDateComponents) {\n      let [matchedPattern, ____day, _dayString, timeZone, _seconds, __minutes, ____parseRFC7231DateTime, __fractionalMilliseconds] = matchedDateComponents;\n      return createDateFromComponents(validateShortIntegerInput(removeLeadingZeros(__fractionalMilliseconds)), convertMonthToIndex(____day), validateIntegerInRange(_dayString.trimLeft(), \"day\", 1, 31), {\n        hours: timeZone,\n        minutes: _seconds,\n        seconds: __minutes,\n        fractionalMilliseconds: ____parseRFC7231DateTime\n      });\n    }\n    throw TypeError(\"Invalid RFC-7231 date-time value\");\n  };\n  var parseEpochTimestampToDate = convertToDate => {\n    if (convertToDate === null || convertToDate === undefined) {\n      return;\n    }\n    let epochTimestamp;\n    if (typeof convertToDate === \"number\") {\n      epochTimestamp = convertToDate;\n    } else if (typeof convertToDate === \"string\") {\n      epochTimestamp = strictParseDouble(convertToDate);\n    } else if (typeof convertToDate === \"object\" && convertToDate.tag === 1) {\n      epochTimestamp = convertToDate.value;\n    } else {\n      throw TypeError(\"Epoch timestamps must be expressed as floating point numbers or their string representation\");\n    }\n    if (Number.isNaN(epochTimestamp) || epochTimestamp === Infinity || epochTimestamp === -Infinity) {\n      throw TypeError(\"Epoch timestamps must be valid, non-Infinite, non-NaN numerics\");\n    }\n    return new Date(Math.round(epochTimestamp * 1000));\n  };\n  var createDateFromComponents = (createDateTimeFromInputs, month, day, timeObject) => {\n    let previousMonthIndex = month - 1;\n    validateDayInMonth(createDateTimeFromInputs, previousMonthIndex, day);\n    return new Date(Date.UTC(createDateTimeFromInputs, previousMonthIndex, day, validateIntegerInRange(timeObject.hours, \"hour\", 0, 23), validateIntegerInRange(timeObject.minutes, \"minute\", 0, 59), validateIntegerInRange(timeObject.seconds, \"seconds\", 0, 60), convertFractionalMillisecondsToFloat32(timeObject.fractionalMilliseconds)));\n  };\n  var normalizeYearForTwoDigitFormat = calculateCenturyYear => {\n    let currentYear = new Date().getUTCFullYear();\n    let calculateFullCenturyYear = Math.floor(currentYear / 100) * 100 + validateShortIntegerInput(removeLeadingZeros(calculateCenturyYear));\n    if (calculateFullCenturyYear < currentYear) {\n      return calculateFullCenturyYear + 100;\n    }\n    return calculateFullCenturyYear;\n  };\n  var MAX_DATE_DIFF_MILLIS = 1576800000000;\n  var adjustDateForHistoricalLimit = adjustDateIfTooFarInFuture => {\n    if (adjustDateIfTooFarInFuture.getTime() - new Date().getTime() > MAX_DATE_DIFF_MILLIS) {\n      return new Date(Date.UTC(adjustDateIfTooFarInFuture.getUTCFullYear() - 100, adjustDateIfTooFarInFuture.getUTCMonth(), adjustDateIfTooFarInFuture.getUTCDate(), adjustDateIfTooFarInFuture.getUTCHours(), adjustDateIfTooFarInFuture.getUTCMinutes(), adjustDateIfTooFarInFuture.getUTCSeconds(), adjustDateIfTooFarInFuture.getUTCMilliseconds()));\n    }\n    return adjustDateIfTooFarInFuture;\n  };\n  var convertMonthToIndex = getMonthIndex => {\n    let _monthIndex = monthsArray.indexOf(getMonthIndex);\n    if (_monthIndex < 0) {\n      throw TypeError(`Invalid month: ${getMonthIndex}`);\n    }\n    return _monthIndex + 1;\n  };\n  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  var validateDayInMonth = (validateDate, monthValidation, dayToValidate) => {\n    let maxDaysInMonth = daysInMonth[monthValidation];\n    if (monthValidation === 1 && isLeapYear(validateDate)) {\n      maxDaysInMonth = 29;\n    }\n    if (dayToValidate > maxDaysInMonth) {\n      throw TypeError(`Invalid day for ${monthsArray[monthValidation]} in ${validateDate}: ${dayToValidate}`);\n    }\n  };\n  var isLeapYear = _isLeapYear => {\n    return _isLeapYear % 4 === 0 && (_isLeapYear % 100 !== 0 || _isLeapYear % 400 === 0);\n  };\n  var validateIntegerInRange = (validateAndRangeCheckInteger, valueToCheck, minValue, upperLimit) => {\n    let validatedIntegerInRange = _validateTypedInteger8Bit(removeLeadingZeros(validateAndRangeCheckInteger));\n    if (validatedIntegerInRange < minValue || validatedIntegerInRange > upperLimit) {\n      throw TypeError(`${valueToCheck} must be between ${minValue} and ${upperLimit}, inclusive`);\n    }\n    return validatedIntegerInRange;\n  };\n  var convertFractionalMillisecondsToFloat32 = calculateWeightInGrams => {\n    if (calculateWeightInGrams === null || calculateWeightInGrams === undefined) {\n      return 0;\n    }\n    return validateFloat32Input(\"0.\" + calculateWeightInGrams) * 1000;\n  };\n  var parseTimezoneOffset = parseTimeOffset => {\n    let offsetDirection = parseTimeOffset[0];\n    let offsetDirectionMultiplier = 1;\n    if (offsetDirection == \"+\") {\n      offsetDirectionMultiplier = 1;\n    } else if (offsetDirection == \"-\") {\n      offsetDirectionMultiplier = -1;\n    } else {\n      throw TypeError(`Offset direction, ${offsetDirection}, must be \"+\" or \"-\"`);\n    }\n    let offsetMinutes = Number(parseTimeOffset.substring(1, 3));\n    let calculateMillisecondsFromOffset = Number(parseTimeOffset.substring(4, 6));\n    return offsetDirectionMultiplier * (offsetMinutes * 60 + calculateMillisecondsFromOffset) * 60 * 1000;\n  };\n  var removeLeadingZeros = _removeLeadingZeros => {\n    let leadingZeroCount = 0;\n    while (leadingZeroCount < _removeLeadingZeros.length - 1 && _removeLeadingZeros.charAt(leadingZeroCount) === \"0\") {\n      leadingZeroCount++;\n    }\n    if (leadingZeroCount === 0) {\n      return _removeLeadingZeros;\n    }\n    return _removeLeadingZeros.slice(leadingZeroCount);\n  };\n  function createStringWithJSONMethods(_inputString) {\n    return Object.assign(new String(_inputString), {\n      deserializeJSON() {\n        return JSON.parse(String(_inputString));\n      },\n      toString() {\n        return String(_inputString);\n      },\n      toJSON() {\n        return String(_inputString);\n      }\n    });\n  }\n  createStringWithJSONMethods.from = deserializeInput => {\n    if (deserializeInput && typeof deserializeInput === \"object\" && (deserializeInput instanceof createStringWithJSONMethods || \"deserializeJSON\" in deserializeInput)) {\n      return deserializeInput;\n    } else if (typeof deserializeInput === \"string\" || Object.getPrototypeOf(deserializeInput) === String.prototype) {\n      return createStringWithJSONMethods(String(deserializeInput));\n    }\n    return createStringWithJSONMethods(JSON.stringify(deserializeInput));\n  };\n  createStringWithJSONMethods.fromObject = createStringWithJSONMethods.from;\n  function wrapStringInQuotesIfNeeded(formatStringForJSON) {\n    if (formatStringForJSON.includes(\",\") || formatStringForJSON.includes(\"\\\"\")) {\n      formatStringForJSON = `\"${formatStringForJSON.replace(/\"/g, \"\\\\\\\"\")}\"`;\n    }\n    return formatStringForJSON;\n  }\n  function splitIntoChunksByDelimiter(splitStringByDelimiterEveryN, delimiter, numberOfDelimiters) {\n    if (numberOfDelimiters <= 0 || !Number.isInteger(numberOfDelimiters)) {\n      throw Error(\"Invalid number of delimiters (\" + numberOfDelimiters + \") for splitEvery.\");\n    }\n    let splitStringByDelimiter = splitStringByDelimiterEveryN.split(delimiter);\n    if (numberOfDelimiters === 1) {\n      return splitStringByDelimiter;\n    }\n    let chunkedStrings = [];\n    let currentChunk = \"\";\n    for (let ______________index = 0; ______________index < splitStringByDelimiter.length; ______________index++) {\n      if (currentChunk === \"\") {\n        currentChunk = splitStringByDelimiter[______________index];\n      } else {\n        currentChunk += delimiter + splitStringByDelimiter[______________index];\n      }\n      if ((______________index + 1) % numberOfDelimiters === 0) {\n        chunkedStrings.push(currentChunk);\n        currentChunk = \"\";\n      }\n    }\n    if (currentChunk !== \"\") {\n      chunkedStrings.push(currentChunk);\n    }\n    return chunkedStrings;\n  }\n  var splitCSV = parseCSV => {\n    let inputStringLength = parseCSV.length;\n    let parsedElements = [];\n    let isInsideQuotes = false;\n    let previousCharacter = undefined;\n    let startIndex = 0;\n    for (let ____________index = 0; ____________index < inputStringLength; ++____________index) {\n      let currentCharacter = parseCSV[____________index];\n      switch (currentCharacter) {\n        case \"\\\"\":\n          if (previousCharacter !== \"\\\\\") {\n            isInsideQuotes = !isInsideQuotes;\n          }\n          break;\n        case \",\":\n          if (!isInsideQuotes) {\n            parsedElements.push(parseCSV.slice(startIndex, ____________index));\n            startIndex = ____________index + 1;\n          }\n          break;\n        default:\n      }\n      previousCharacter = currentCharacter;\n    }\n    parsedElements.push(parseCSV.slice(startIndex));\n    return parsedElements.map(sanitizeInput => {\n      sanitizeInput = sanitizeInput.trim();\n      let trimmedLength = sanitizeInput.length;\n      if (trimmedLength < 2) {\n        return sanitizeInput;\n      }\n      if (sanitizeInput[0] === \"\\\"\" && sanitizeInput[trimmedLength - 1] === \"\\\"\") {\n        sanitizeInput = sanitizeInput.slice(1, trimmedLength - 1);\n      }\n      return sanitizeInput.replace(/\\\\\"/g, \"\\\"\");\n    });\n  };\n  var NumericValue = class {\n    constructor(numericString, numericValueType) {\n      this.string = numericString;\n      this.type = numericValueType;\n      let decimalPointCount = 0;\n      for (let index = 0; index < numericString.length; ++index) {\n        let charCode = numericString.charCodeAt(index);\n        if (index === 0 && charCode === 45) {\n          continue;\n        }\n        if (charCode === 46) {\n          if (decimalPointCount) {\n            throw Error(\"@smithy/core/serde - NumericValue must contain at most one decimal point.\");\n          }\n          decimalPointCount = 1;\n          continue;\n        }\n        if (charCode < 48 || charCode > 57) {\n          throw Error(\"@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point \\\".\\\", and an optional negation prefix \\\"-\\\".\");\n        }\n      }\n    }\n    toString() {\n      return this.string;\n    }\n    [Symbol.hasInstance](isNumericValueInstance) {\n      if (!isNumericValueInstance || typeof isNumericValueInstance !== \"object\") {\n        return false;\n      }\n      let numericValueObject = isNumericValueInstance;\n      if (typeof numericValueObject.string === \"string\" && typeof numericValueObject.type === \"string\" && numericValueObject.constructor?.name === \"NumericValue\") {\n        return true;\n      }\n      return false;\n    }\n  };\n  function convertToBigDecimal(inputValue) {\n    return new NumericValue(String(inputValue), \"bigDecimal\");\n  }\n});\nvar _____imageTransformationPipeline = z(Base64Converter => {\n  Object.defineProperty(Base64Converter, \"__esModule\", {\n    value: true\n  });\n  Base64Converter.fromBase64 = undefined;\n  var processBase64String = ________________________________________processImageTransformation();\n  var _base64ValidationRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n  var _decodeBase64ToUint8Array = __decodeBase64ToUint8Array => {\n    if (__decodeBase64ToUint8Array.length * 3 % 4 !== 0) {\n      throw TypeError(\"Incorrect padding on base64 string.\");\n    }\n    if (!_base64ValidationRegex.exec(__decodeBase64ToUint8Array)) {\n      throw TypeError(\"Invalid base64 string.\");\n    }\n    let processedBase64String = (0, processBase64String.fromString)(__decodeBase64ToUint8Array, \"base64\");\n    return new Uint8Array(processedBase64String.buffer, processedBase64String.byteOffset, processedBase64String.byteLength);\n  };\n  Base64Converter.fromBase64 = _decodeBase64ToUint8Array;\n});\nvar ______imageTransformationPipeline = z(_Base64Encoder => {\n  Object.defineProperty(_Base64Encoder, \"__esModule\", {\n    value: true\n  });\n  _Base64Encoder.toBase64 = undefined;\n  var imageToBase64Encoder = ________________________________________processImageTransformation();\n  var __________________________________imageProcessingPipeline = ___________________imageProcessingPipeline();\n  var _encodeToBase64 = __encodeToBase64 => {\n    let processedInput;\n    if (typeof __encodeToBase64 === \"string\") {\n      processedInput = (0, __________________________________imageProcessingPipeline.fromUtf8)(__encodeToBase64);\n    } else {\n      processedInput = __encodeToBase64;\n    }\n    if (typeof processedInput !== \"object\" || typeof processedInput.byteOffset !== \"number\" || typeof processedInput.byteLength !== \"number\") {\n      throw Error(\"@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.\");\n    }\n    return (0, imageToBase64Encoder.fromArrayBuffer)(processedInput.buffer, processedInput.byteOffset, processedInput.byteLength).toString(\"base64\");\n  };\n  _Base64Encoder.toBase64 = _encodeToBase64;\n});\nvar ___imageTransformationHandler = z((defineObjectProperties, exportsModule) => {\n  var {\n    defineProperty: ___________defineProperty,\n    getOwnPropertyDescriptor: _____________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNamesWithOwnerCheck\n  } = Object;\n  var __________________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _definePropertiesFromObject = (copyPropertiesFromObject, _targetObject, _______________________________propertyName, _____descriptor) => {\n    if (_targetObject && typeof _targetObject === \"object\" || typeof _targetObject === \"function\") {\n      for (let ___________________________propertyName of getOwnPropertyNamesWithOwnerCheck(_targetObject)) {\n        if (!__________________________hasOwnProperty.call(copyPropertiesFromObject, ___________________________propertyName) && ___________________________propertyName !== _______________________________propertyName) {\n          ___________defineProperty(copyPropertiesFromObject, ___________________________propertyName, {\n            get: () => _targetObject[___________________________propertyName],\n            enumerable: !(_____descriptor = _____________________________getOwnPropertyDescriptor(_targetObject, ___________________________propertyName)) || _____descriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyPropertiesFromObject;\n  };\n  var defineAndExportProperties = (________________________defineProperties, propertiesObject, _______________________________________________________________________________________________________________sourceObject) => {\n    _definePropertiesFromObject(________________________defineProperties, propertiesObject, \"default\");\n    return _______________________________________________________________________________________________________________sourceObject && _definePropertiesFromObject(_______________________________________________________________________________________________________________sourceObject, propertiesObject, \"default\");\n  };\n  var _defineModuleExports = definePropertiesWithESModuleFlag => _definePropertiesFromObject(___________defineProperty({}, \"__esModule\", {\n    value: true\n  }), definePropertiesWithESModuleFlag);\n  var _exportModule = {};\n  exportsModule.exports = _defineModuleExports(_exportModule);\n  defineAndExportProperties(_exportModule, _____imageTransformationPipeline(), exportsModule.exports);\n  defineAndExportProperties(_exportModule, ______imageTransformationPipeline(), exportsModule.exports);\n});\nvar createImageProcessingPipeline = z((initializeImportsAndSetup, moduleExports) => {\n  var {\n    defineProperty: defineProperty,\n    getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNames\n  } = Object;\n  var objectHasOwnProperty = Object.prototype.hasOwnProperty;\n  var defineProperties = (____definePropertiesFromObject, ________________________________________________________________________________________________________sourceObject) => {\n    for (var ____________________________________propertyKey in ________________________________________________________________________________________________________sourceObject) {\n      defineProperty(____definePropertiesFromObject, ____________________________________propertyKey, {\n        get: ________________________________________________________________________________________________________sourceObject[____________________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesFromSourceToTarget = (_mergeProperties, _source, _excludedProperty, ______descriptor) => {\n    if (_source && typeof _source === \"object\" || typeof _source === \"function\") {\n      for (let ____________________________propertyName of getOwnPropertyNames(_source)) {\n        if (!objectHasOwnProperty.call(_mergeProperties, ____________________________propertyName) && ____________________________propertyName !== _excludedProperty) {\n          defineProperty(_mergeProperties, ____________________________propertyName, {\n            get: () => _source[____________________________propertyName],\n            enumerable: !(______descriptor = getOwnPropertyDescriptor(_source, ____________________________propertyName)) || ______descriptor.enumerable\n          });\n        }\n      }\n    }\n    return _mergeProperties;\n  };\n  var copyAndDefineProperties = ____copyPropertiesFromSourceToTarget => copyPropertiesFromSourceToTarget(defineProperty({}, \"__esModule\", {\n    value: true\n  }), ____copyPropertiesFromSourceToTarget);\n  var _moduleExports = {};\n  defineProperties(_moduleExports, {\n    FromStringShapeDeserializer: () => FromStringShapeDeserializer,\n    HttpBindingProtocol: () => gB4,\n    HttpInterceptingShapeDeserializer: () => HttpInterceptingShapeDeserializer,\n    HttpInterceptingShapeSerializer: () => HttpInterceptingShapeSerializer,\n    RequestBuilder: () => RequestBuilder,\n    RpcProtocol: () => mB4,\n    ToStringShapeSerializer: () => StringShapeSerializer,\n    collectBody: () => collectBodyFromHttpResponse,\n    determineTimestampFormat: () => validateTimestampSchema,\n    extendedEncodeURIComponent: () => encodeUriComponentWithSpecialChars,\n    requestBuilder: () => createRequestBuilder,\n    resolvedPath: () => replaceHttpLabelInPath\n  });\n  moduleExports.exports = copyAndDefineProperties(_moduleExports);\n  var ___initializeImageProcessing = ____________________imageProcessor();\n  var collectBodyFromHttpResponse = async (_____imageData = new Uint8Array(), streamCollector) => {\n    if (_____imageData instanceof Uint8Array) {\n      return ___initializeImageProcessing.Uint8ArrayBlobAdapter.mutate(_____imageData);\n    }\n    if (!_____imageData) {\n      return ___initializeImageProcessing.Uint8ArrayBlobAdapter.mutate(new Uint8Array());\n    }\n    let streamedDataCollector = streamCollector.streamCollector(_____imageData);\n    return ___initializeImageProcessing.Uint8ArrayBlobAdapter.mutate(await streamedDataCollector);\n  };\n  function encodeUriComponentWithSpecialChars(encodeUriComponentWithEscape) {\n    return encodeURIComponent(encodeUriComponentWithEscape).replace(/[!'()*]/g, function (characterToHexString) {\n      return \"%\" + characterToHexString.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n  var _initializeImageProcessingPipeline = __processImagePipeline();\n  var initializeAndExportMetadata = updateMetadata();\n  var ______________________imageProcessingPipeline = __processImagePipeline();\n  var _____________________________imageTransformationProcessor = ____________________________________________________processImageTransformation();\n  var httpMetadataManager = updateMetadata();\n  var getImageProcessor = ____________________imageProcessor();\n  var HttpRequestHandler = class {\n    constructor(A) {\n      this.options = A;\n    }\n    getRequestType() {\n      return httpMetadataManager.HttpRequest;\n    }\n    getResponseType() {\n      return httpMetadataManager.HttpResponse;\n    }\n    setSerdeContext(A) {\n      this.serdeContext = A;\n      this.serializer.setSerdeContext(A);\n      this.deserializer.setSerdeContext(A);\n      if (this.getPayloadCodec()) {\n        this.getPayloadCodec().setSerdeContext(A);\n      }\n    }\n    updateServiceEndpoint(A, B) {\n      if (\"url\" in B) {\n        A.protocol = B.url.protocol;\n        A.hostname = B.url.hostname;\n        A.port = B.url.port ? Number(B.url.port) : undefined;\n        A.path = B.url.pathname;\n        A.fragment = B.url.hash || undefined;\n        A.username = B.url.username || undefined;\n        A.password = B.url.password || undefined;\n        for (let [queryParamKey, _value] of B.url.searchParams.entries()) {\n          if (!A.query) {\n            A.query = {};\n          }\n          A.query[queryParamKey] = _value;\n        }\n        return A;\n      } else {\n        A.protocol = B.protocol;\n        A.hostname = B.hostname;\n        A.port = B.port ? Number(B.port) : undefined;\n        A.path = B.path;\n        A.query = {\n          ...B.query\n        };\n        return A;\n      }\n    }\n    setHostPrefix(A, B, Q) {\n      let I = ______________________imageProcessingPipeline.NormalizedSchema.of(B);\n      let G = ______________________imageProcessingPipeline.NormalizedSchema.of(B.input);\n      if (I.getMergedTraits().endpoint) {\n        let endpointTemplate = I.getMergedTraits().endpoint?.[0];\n        if (typeof endpointTemplate === \"string\") {\n          let hostLabelEntries = [...G.structIterator()].filter(([, getMergedTraitsHostLabel]) => getMergedTraitsHostLabel.getMergedTraits().hostLabel);\n          for (let [hostLabelKey] of hostLabelEntries) {\n            let hostLabelValue = Q[hostLabelKey];\n            if (typeof hostLabelValue !== \"string\") {\n              throw Error(`@smithy/core/schema - ${hostLabelKey} in input must be a string as hostLabel.`);\n            }\n            endpointTemplate = endpointTemplate.replace(`{${hostLabelKey}}`, hostLabelValue);\n          }\n          A.hostname = endpointTemplate + A.hostname;\n        }\n      }\n    }\n    deserializeMetadata(A) {\n      return {\n        httpStatusCode: A.statusCode,\n        requestId: A.headers[\"x-amzn-requestid\"] ?? A.headers[\"x-amzn-request-id\"] ?? A.headers[\"x-amz-request-id\"],\n        extendedRequestId: A.headers[\"x-amz-id-2\"],\n        cfId: A.headers[\"x-amz-cf-id\"]\n      };\n    }\n    async deserializeHttpMessage(A, B, Q, I, G) {\n      let Z;\n      if (I instanceof Set) {\n        Z = G;\n      } else {\n        Z = I;\n      }\n      let Y = this.deserializer;\n      let J = ______________________imageProcessingPipeline.NormalizedSchema.of(A);\n      let X = [];\n      for (let [memberName, member] of J.structIterator()) {\n        let memberTraits = member.getMemberTraits();\n        if (memberTraits.httpPayload) {\n          if (member.isStreaming()) {\n            if (member.isStructSchema()) {\n              let serdeContext = this.serdeContext;\n              if (!serdeContext.eventStreamMarshaller) {\n                throw Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n              }\n              let memberSchemas = member.getMemberSchemas();\n              Z[memberName] = serdeContext.eventStreamMarshaller.deserialize(Q.body, async processMemberSchema => {\n                let firstNonSpecialKey = Object.keys(processMemberSchema).find(isNotType => {\n                  return isNotType !== \"__type\";\n                }) ?? \"\";\n                if (firstNonSpecialKey in memberSchemas) {\n                  let schemaKey = memberSchemas[firstNonSpecialKey];\n                  return {\n                    [firstNonSpecialKey]: await Y.read(schemaKey, processMemberSchema[firstNonSpecialKey].body)\n                  };\n                } else {\n                  return {\n                    $unknown: processMemberSchema\n                  };\n                }\n              });\n            } else {\n              Z[memberName] = (0, getImageProcessor.sdkStreamMixin)(Q.body);\n            }\n          } else if (Q.body) {\n            let httpHeaderValue = await collectBodyFromHttpResponse(Q.body, B);\n            if (httpHeaderValue.byteLength > 0) {\n              Z[memberName] = await Y.read(member, httpHeaderValue);\n            }\n          }\n        } else if (memberTraits.httpHeader) {\n          let httpHeaderKey = String(memberTraits.httpHeader).toLowerCase();\n          let _httpHeaderValue = Q.headers[httpHeaderKey];\n          if (_httpHeaderValue != null) {\n            if (member.isListSchema()) {\n              let _serdeContext = member.getValueSchema();\n              let _memberSchemas;\n              if (_serdeContext.isTimestampSchema() && _serdeContext.getSchema() === ______________________imageProcessingPipeline.SCHEMA.TIMESTAMP_DEFAULT) {\n                _memberSchemas = (0, _____________________________imageTransformationProcessor.splitEvery)(_httpHeaderValue, \",\", 2);\n              } else {\n                _memberSchemas = (0, _____________________________imageTransformationProcessor.splitHeader)(_httpHeaderValue);\n              }\n              let httpPayloadDeserializer = [];\n              for (let __memberSchema of _memberSchemas) {\n                httpPayloadDeserializer.push(await Y.read([_serdeContext, {\n                  httpHeader: httpHeaderKey\n                }], __memberSchema.trim()));\n              }\n              Z[memberName] = httpPayloadDeserializer;\n            } else {\n              Z[memberName] = await Y.read(member, _httpHeaderValue);\n            }\n          }\n        } else if (memberTraits.httpPrefixHeaders !== undefined) {\n          Z[memberName] = {};\n          for (let [headerName, __httpHeaderValue] of Object.entries(Q.headers)) {\n            if (headerName.startsWith(memberTraits.httpPrefixHeaders)) {\n              Z[memberName][headerName.slice(memberTraits.httpPrefixHeaders.length)] = await Y.read([member.getValueSchema(), {\n                httpHeader: headerName\n              }], __httpHeaderValue);\n            }\n          }\n        } else if (memberTraits.httpResponseCode) {\n          Z[memberName] = Q.statusCode;\n        } else {\n          X.push(memberName);\n        }\n      }\n      return X;\n    }\n  };\n  var gB4 = class extends HttpRequestHandler {\n    async serializeRequest(A, B, Q) {\n      let I = this.serializer;\n      let G = {};\n      let Z = {};\n      let Y = await Q.endpoint();\n      let J = _initializeImageProcessingPipeline.NormalizedSchema.of(A?.input);\n      let X = J.getSchema();\n      let W = false;\n      let F;\n      let C = new initializeAndExportMetadata.HttpRequest({\n        protocol: \"\",\n        hostname: \"\",\n        port: undefined,\n        path: \"\",\n        fragment: undefined,\n        query: G,\n        headers: Z,\n        body: undefined\n      });\n      if (Y) {\n        this.updateServiceEndpoint(C, Y);\n        this.setHostPrefix(C, A, B);\n        let translatedTraits = _initializeImageProcessingPipeline.NormalizedSchema.translateTraits(A.traits);\n        if (translatedTraits.http) {\n          C.method = translatedTraits.http[0];\n          let [memberSchema, httpTraits] = translatedTraits.http[1].split(\"?\");\n          if (C.path == \"/\") {\n            C.path = memberSchema;\n          } else {\n            C.path += memberSchema;\n          }\n          let httpRequestBody = new URLSearchParams(httpTraits ?? \"\");\n          Object.assign(G, Object.fromEntries(httpRequestBody));\n        }\n      }\n      let V = {\n        ...B\n      };\n      for (let key of Object.keys(V)) {\n        let _memberSchema = J.getMemberSchema(key);\n        if (_memberSchema === undefined) {\n          continue;\n        }\n        let mergedTraits = _memberSchema.getMergedTraits();\n        let memberValue = V[key];\n        if (mergedTraits.httpPayload) {\n          if (_memberSchema.isStreaming()) {\n            if (_memberSchema.isStructSchema()) {\n              throw Error(\"serialization of event streams is not yet implemented\");\n            } else {\n              F = memberValue;\n            }\n          } else {\n            I.write(_memberSchema, memberValue);\n            F = I.flush();\n          }\n        } else if (mergedTraits.httpLabel) {\n          I.write(_memberSchema, memberValue);\n          let resultFromFlush = I.flush();\n          if (C.path.includes(`{${key}+}`)) {\n            C.path = C.path.replace(`{${key}+}`, resultFromFlush.split(\"/\").map(encodeUriComponentWithSpecialChars).join(\"/\"));\n          } else if (C.path.includes(`{${key}}`)) {\n            C.path = C.path.replace(`{${key}}`, encodeUriComponentWithSpecialChars(resultFromFlush));\n          }\n          delete V[key];\n        } else if (mergedTraits.httpHeader) {\n          I.write(_memberSchema, memberValue);\n          Z[mergedTraits.httpHeader.toLowerCase()] = String(I.flush());\n          delete V[key];\n        } else if (typeof mergedTraits.httpPrefixHeaders === \"string\") {\n          for (let [memberValueKey, ___httpHeaderValue] of Object.entries(memberValue)) {\n            let httpHeaderWithPrefix = mergedTraits.httpPrefixHeaders + memberValueKey;\n            I.write([_memberSchema.getValueSchema(), {\n              httpHeader: httpHeaderWithPrefix\n            }], ___httpHeaderValue);\n            Z[httpHeaderWithPrefix.toLowerCase()] = I.flush();\n          }\n          delete V[key];\n        } else if (mergedTraits.httpQuery || mergedTraits.httpQueryParams) {\n          this.serializeQuery(_memberSchema, memberValue, G);\n          delete V[key];\n        } else {\n          W = true;\n        }\n      }\n      if (W && B) {\n        I.write(X, V);\n        F = I.flush();\n      }\n      C.headers = Z;\n      C.query = G;\n      C.body = F;\n      return C;\n    }\n    serializeQuery(A, B, Q) {\n      let I = this.serializer;\n      let G = A.getMergedTraits();\n      if (G.httpQueryParams) {\n        for (let [httpQueryKey, httpResponseData] of Object.entries(B)) {\n          if (!(httpQueryKey in Q)) {\n            this.serializeQuery(_initializeImageProcessingPipeline.NormalizedSchema.of([A.getValueSchema(), {\n              ...G,\n              httpQuery: httpQueryKey,\n              httpQueryParams: undefined\n            }]), httpResponseData, Q);\n          }\n        }\n        return;\n      }\n      if (A.isListSchema()) {\n        let httpQueryParamKey = !!A.getMergedTraits().sparse;\n        let httpQueryParamsValue = [];\n        for (let item of B) {\n          I.write([A.getValueSchema(), G], item);\n          let flushedData = I.flush();\n          if (httpQueryParamKey || flushedData !== undefined) {\n            httpQueryParamsValue.push(flushedData);\n          }\n        }\n        Q[G.httpQuery] = httpQueryParamsValue;\n      } else {\n        I.write([A, G], B);\n        Q[G.httpQuery] = I.flush();\n      }\n    }\n    async deserializeResponse(A, B, Q) {\n      let I = this.deserializer;\n      let G = _initializeImageProcessingPipeline.NormalizedSchema.of(A.output);\n      let Z = {};\n      if (Q.statusCode >= 300) {\n        let responseBody = await collectBodyFromHttpResponse(Q.body, B);\n        if (responseBody.byteLength > 0) {\n          Object.assign(Z, await I.read(_initializeImageProcessingPipeline.SCHEMA.DOCUMENT, responseBody));\n        }\n        await this.handleError(A, B, Q, Z, this.deserializeMetadata(Q));\n        throw Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n      }\n      for (let header in Q.headers) {\n        let _headerValue = Q.headers[header];\n        delete Q.headers[header];\n        Q.headers[header.toLowerCase()] = _headerValue;\n      }\n      let Y = await this.deserializeHttpMessage(G, B, Q, Z);\n      if (Y.length) {\n        let responseBodyBuffer = await collectBodyFromHttpResponse(Q.body, B);\n        if (responseBodyBuffer.byteLength > 0) {\n          let headerValue = await I.read(G, responseBodyBuffer);\n          for (let ____key of Y) {\n            Z[____key] = headerValue[____key];\n          }\n        }\n      }\n      return {\n        $metadata: this.deserializeMetadata(Q),\n        ...Z\n      };\n    }\n  };\n  var _______________________imageProcessingPipeline = __processImagePipeline();\n  var updateMetadataUtil = updateMetadata();\n  var mB4 = class extends HttpRequestHandler {\n    async serializeRequest(A, B, Q) {\n      let I = this.serializer;\n      let G = {};\n      let Z = {};\n      let Y = await Q.endpoint();\n      let X = _______________________imageProcessingPipeline.NormalizedSchema.of(A?.input).getSchema();\n      let W;\n      let F = new updateMetadataUtil.HttpRequest({\n        protocol: \"\",\n        hostname: \"\",\n        port: undefined,\n        path: \"/\",\n        fragment: undefined,\n        query: G,\n        headers: Z,\n        body: undefined\n      });\n      if (Y) {\n        this.updateServiceEndpoint(F, Y);\n        this.setHostPrefix(F, A, B);\n      }\n      let C = {\n        ...B\n      };\n      if (B) {\n        I.write(X, C);\n        W = I.flush();\n      }\n      F.headers = Z;\n      F.query = G;\n      F.body = W;\n      F.method = \"POST\";\n      return F;\n    }\n    async deserializeResponse(A, B, Q) {\n      let I = this.deserializer;\n      let G = _______________________imageProcessingPipeline.NormalizedSchema.of(A.output);\n      let Z = {};\n      if (Q.statusCode >= 300) {\n        let _responseBody = await collectBodyFromHttpResponse(Q.body, B);\n        if (_responseBody.byteLength > 0) {\n          Object.assign(Z, await I.read(_______________________imageProcessingPipeline.SCHEMA.DOCUMENT, _responseBody));\n        }\n        await this.handleError(A, B, Q, Z, this.deserializeMetadata(Q));\n        throw Error(\"@smithy/core/protocols - RPC Protocol error handler failed to throw.\");\n      }\n      for (let headerKey in Q.headers) {\n        let __headerValue = Q.headers[headerKey];\n        delete Q.headers[headerKey];\n        Q.headers[headerKey.toLowerCase()] = __headerValue;\n      }\n      let Y = await collectBodyFromHttpResponse(Q.body, B);\n      if (Y.byteLength > 0) {\n        Object.assign(Z, await I.read(G, Y));\n      }\n      return {\n        $metadata: this.deserializeMetadata(Q),\n        ...Z\n      };\n    }\n  };\n  var updateMetadataHook = updateMetadata();\n  var replaceHttpLabelInPath = (processHttpLabel, _________inputValue, inputLabelKey, getInputValue, patternToReplace, shouldEncodeUriComponent) => {\n    if (_________inputValue != null && _________inputValue[inputLabelKey] !== undefined) {\n      let inputHttpLabelValue = getInputValue();\n      if (inputHttpLabelValue.length <= 0) {\n        throw Error(\"Empty value provided for input HTTP label: \" + inputLabelKey + \".\");\n      }\n      processHttpLabel = processHttpLabel.replace(patternToReplace, shouldEncodeUriComponent ? inputHttpLabelValue.split(\"/\").map(_encodeUriComponentWithSpecialChars => encodeUriComponentWithSpecialChars(_encodeUriComponentWithSpecialChars)).join(\"/\") : encodeUriComponentWithSpecialChars(inputHttpLabelValue));\n    } else {\n      throw Error(\"No value provided for input HTTP label: \" + inputLabelKey + \".\");\n    }\n    return processHttpLabel;\n  };\n  function createRequestBuilder(createPm0, createNewPmObject) {\n    return new RequestBuilder(createPm0, createNewPmObject);\n  }\n  var RequestBuilder = class {\n    constructor(_____________inputValue, contextObject) {\n      this.input = _____________inputValue;\n      this.context = contextObject;\n      this.query = {};\n      this.method = \"\";\n      this.headers = {};\n      this.path = \"\";\n      this.body = null;\n      this.hostname = \"\";\n      this.resolvePathStack = [];\n    }\n    async build() {\n      let {\n        hostname: __hostname,\n        protocol: defaultProtocol = \"https\",\n        port: port,\n        path: endpointPath\n      } = await this.context.endpoint();\n      this.path = endpointPath;\n      for (let ________callbackFunction of this.resolvePathStack) {\n        ________callbackFunction(this.path);\n      }\n      return new updateMetadataHook.HttpRequest({\n        protocol: defaultProtocol,\n        hostname: this.hostname || __hostname,\n        port: port,\n        method: this.method,\n        path: this.path,\n        query: this.query,\n        body: this.body,\n        headers: this.headers\n      });\n    }\n    hn(setHostname) {\n      this.hostname = setHostname;\n      return this;\n    }\n    bp(appendToPath) {\n      this.resolvePathStack.push(basePath => {\n        this.path = `${basePath?.endsWith(\"/\") ? basePath.slice(0, -1) : basePath || \"\"}${appendToPath}`;\n      });\n      return this;\n    }\n    p(replaceHttpLabelInPathUsingInput, pathGenerator, httpLabelPathGenerator, inputIdentifier) {\n      this.resolvePathStack.push(generatePath => {\n        this.path = replaceHttpLabelInPath(generatePath, this.input, replaceHttpLabelInPathUsingInput, pathGenerator, httpLabelPathGenerator, inputIdentifier);\n      });\n      return this;\n    }\n    h(setHeaders) {\n      this.headers = setHeaders;\n      return this;\n    }\n    q(setQuery) {\n      this.query = setQuery;\n      return this;\n    }\n    b(setBody) {\n      this.body = setBody;\n      return this;\n    }\n    m(setMethod) {\n      this.method = setMethod;\n      return this;\n    }\n  };\n  var ________________________imageProcessingPipeline = __processImagePipeline();\n  var _____________________________________________________processImageTransformation = ____________________________________________________processImageTransformation();\n  var _____imageTransformationHandler = ___imageTransformationHandler();\n  var _________________________imageProcessingPipeline = ___________________imageProcessingPipeline();\n  var ____processImagePipeline = __processImagePipeline();\n  function validateTimestampSchema(schemaValidator, timestampOptions) {\n    if (timestampOptions.timestampFormat.useTrait) {\n      if (schemaValidator.isTimestampSchema() && (schemaValidator.getSchema() === ____processImagePipeline.SCHEMA.TIMESTAMP_DATE_TIME || schemaValidator.getSchema() === ____processImagePipeline.SCHEMA.TIMESTAMP_HTTP_DATE || schemaValidator.getSchema() === ____processImagePipeline.SCHEMA.TIMESTAMP_EPOCH_SECONDS)) {\n        return schemaValidator.getSchema();\n      }\n    }\n    let {\n      httpLabel: httpLabel,\n      httpPrefixHeaders: httpPrefixHeaders,\n      httpHeader: httpHeaderProvided,\n      httpQuery: httpQueryParameter\n    } = schemaValidator.getMergedTraits();\n    return (timestampOptions.httpBindings ? typeof httpPrefixHeaders === \"string\" || Boolean(httpHeaderProvided) ? ____processImagePipeline.SCHEMA.TIMESTAMP_HTTP_DATE : Boolean(httpQueryParameter) || Boolean(httpLabel) ? ____processImagePipeline.SCHEMA.TIMESTAMP_DATE_TIME : undefined : undefined) ?? timestampOptions.timestampFormat.default;\n  }\n  var FromStringShapeDeserializer = class {\n    constructor(_settings) {\n      this.settings = _settings;\n    }\n    setSerdeContext(setSerdeContextContext) {\n      this.serdeContext = setSerdeContextContext;\n    }\n    read(readValueFromSchema, ___________inputData) {\n      let __schemaDefinition = ________________________imageProcessingPipeline.NormalizedSchema.of(readValueFromSchema);\n      if (__schemaDefinition.isListSchema()) {\n        return (0, _____________________________________________________processImageTransformation.splitHeader)(___________inputData).map(valueSchema => this.read(__schemaDefinition.getValueSchema(), valueSchema));\n      }\n      if (__schemaDefinition.isBlobSchema()) {\n        return (this.serdeContext?.base64Decoder ?? _____imageTransformationHandler.fromBase64)(___________inputData);\n      }\n      if (__schemaDefinition.isTimestampSchema()) {\n        switch (validateTimestampSchema(__schemaDefinition, this.settings)) {\n          case ________________________imageProcessingPipeline.SCHEMA.TIMESTAMP_DATE_TIME:\n            return (0, _____________________________________________________processImageTransformation.parseRfc3339DateTimeWithOffset)(___________inputData);\n          case ________________________imageProcessingPipeline.SCHEMA.TIMESTAMP_HTTP_DATE:\n            return (0, _____________________________________________________processImageTransformation.parseRfc7231DateTime)(___________inputData);\n          case ________________________imageProcessingPipeline.SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n            return (0, _____________________________________________________processImageTransformation.parseEpochTimestamp)(___________inputData);\n          default:\n            console.warn(\"Missing timestamp format, parsing value with Date constructor:\", ___________inputData);\n            return new Date(___________inputData);\n        }\n      }\n      if (__schemaDefinition.isStringSchema()) {\n        let _mediaType = __schemaDefinition.getMergedTraits().mediaType;\n        let parsedValue = ___________inputData;\n        if (_mediaType) {\n          if (__schemaDefinition.getMergedTraits().httpHeader) {\n            parsedValue = this.base64ToUtf8(parsedValue);\n          }\n          if (_mediaType === \"application/json\" || _mediaType.endsWith(\"+json\")) {\n            parsedValue = _____________________________________________________processImageTransformation.LazyJsonString.from(parsedValue);\n          }\n          return parsedValue;\n        }\n      }\n      switch (true) {\n        case __schemaDefinition.isNumericSchema():\n          return Number(___________inputData);\n        case __schemaDefinition.isBigIntegerSchema():\n          return BigInt(___________inputData);\n        case __schemaDefinition.isBigDecimalSchema():\n          return new _____________________________________________________processImageTransformation.NumericValue(___________inputData, \"bigDecimal\");\n        case __schemaDefinition.isBooleanSchema():\n          return String(___________inputData).toLowerCase() === \"true\";\n      }\n      return ___________inputData;\n    }\n    base64ToUtf8(base64Input) {\n      return (this.serdeContext?.utf8Encoder ?? _________________________imageProcessingPipeline.toUtf8)((this.serdeContext?.base64Decoder ?? _____imageTransformationHandler.fromBase64)(base64Input));\n    }\n  };\n  var __________________________imageProcessingPipeline = __processImagePipeline();\n  var ___________________________imageProcessingPipeline = ___________________imageProcessingPipeline();\n  var HttpInterceptingShapeDeserializer = class {\n    constructor(codecDeserializer, stringDeserializerConfig) {\n      this.codecDeserializer = codecDeserializer;\n      this.stringDeserializer = new FromStringShapeDeserializer(stringDeserializerConfig);\n    }\n    setSerdeContext(setSerializerContext) {\n      this.stringDeserializer.setSerdeContext(setSerializerContext);\n      this.codecDeserializer.setSerdeContext(setSerializerContext);\n      this.serdeContext = setSerializerContext;\n    }\n    read(dataSchema, inputData) {\n      let normalizedSchema = __________________________imageProcessingPipeline.NormalizedSchema.of(dataSchema);\n      let _mergedTraits = normalizedSchema.getMergedTraits();\n      let utf8EncoderOrDefault = this.serdeContext?.utf8Encoder ?? ___________________________imageProcessingPipeline.toUtf8;\n      if (_mergedTraits.httpHeader || _mergedTraits.httpResponseCode) {\n        return this.stringDeserializer.read(normalizedSchema, utf8EncoderOrDefault(inputData));\n      }\n      if (_mergedTraits.httpPayload) {\n        if (normalizedSchema.isBlobSchema()) {\n          let utf8Decoder = this.serdeContext?.utf8Decoder ?? ___________________________imageProcessingPipeline.fromUtf8;\n          if (typeof inputData === \"string\") {\n            return utf8Decoder(inputData);\n          }\n          return inputData;\n        } else if (normalizedSchema.isStringSchema()) {\n          if (\"byteLength\" in inputData) {\n            return utf8EncoderOrDefault(inputData);\n          }\n          return inputData;\n        }\n      }\n      return this.codecDeserializer.read(normalizedSchema, inputData);\n    }\n  };\n  var ____________________________imageProcessingPipeline = __processImagePipeline();\n  var _____________________________imageProcessingPipeline = __processImagePipeline();\n  var ______________________________________________________processImageTransformation = ____________________________________________________processImageTransformation();\n  var ______imageTransformationHandler = ___imageTransformationHandler();\n  var StringShapeSerializer = class {\n    constructor(settings) {\n      this.settings = settings;\n      this.stringBuffer = \"\";\n      this.serdeContext = undefined;\n    }\n    setSerdeContext(serdeContextData) {\n      this.serdeContext = serdeContextData;\n    }\n    write(writeValueToBufferBasedOnSchema, ______________inputValue) {\n      let schemaDescriptor = _____________________________imageProcessingPipeline.NormalizedSchema.of(writeValueToBufferBasedOnSchema);\n      switch (typeof ______________inputValue) {\n        case \"object\":\n          if (______________inputValue === null) {\n            this.stringBuffer = \"null\";\n            return;\n          }\n          if (schemaDescriptor.isTimestampSchema()) {\n            if (!(______________inputValue instanceof Date)) {\n              throw Error(`@smithy/core/protocols - received non-Date value ${______________inputValue} when schema expected Date in ${schemaDescriptor.getName(true)}`);\n            }\n            switch (validateTimestampSchema(schemaDescriptor, this.settings)) {\n              case _____________________________imageProcessingPipeline.SCHEMA.TIMESTAMP_DATE_TIME:\n                this.stringBuffer = ______________inputValue.toISOString().replace(\".000Z\", \"Z\");\n                break;\n              case _____________________________imageProcessingPipeline.SCHEMA.TIMESTAMP_HTTP_DATE:\n                this.stringBuffer = (0, ______________________________________________________processImageTransformation.dateToUtcString)(______________inputValue);\n                break;\n              case _____________________________imageProcessingPipeline.SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                this.stringBuffer = String(______________inputValue.getTime() / 1000);\n                break;\n              default:\n                console.warn(\"Missing timestamp format, using epoch seconds\", ______________inputValue);\n                this.stringBuffer = String(______________inputValue.getTime() / 1000);\n            }\n            return;\n          }\n          if (schemaDescriptor.isBlobSchema() && \"byteLength\" in ______________inputValue) {\n            this.stringBuffer = (this.serdeContext?.base64Encoder ?? ______imageTransformationHandler.toBase64)(______________inputValue);\n            return;\n          }\n          if (schemaDescriptor.isListSchema() && Array.isArray(______________inputValue)) {\n            let concatenatedResults = \"\";\n            for (let resultItem of ______________inputValue) {\n              this.write([schemaDescriptor.getValueSchema(), schemaDescriptor.getMergedTraits()], resultItem);\n              let flushedResult = this.flush();\n              let _formattedOutput = schemaDescriptor.getValueSchema().isTimestampSchema() ? flushedResult : (0, ______________________________________________________processImageTransformation.quoteHeader)(flushedResult);\n              if (concatenatedResults !== \"\") {\n                concatenatedResults += \", \";\n              }\n              concatenatedResults += _formattedOutput;\n            }\n            this.stringBuffer = concatenatedResults;\n            return;\n          }\n          this.stringBuffer = JSON.stringify(______________inputValue, null, 2);\n          break;\n        case \"string\":\n          let mediaType = schemaDescriptor.getMergedTraits().mediaType;\n          let inputString = ______________inputValue;\n          if (mediaType) {\n            if (mediaType === \"application/json\" || mediaType.endsWith(\"+json\")) {\n              inputString = ______________________________________________________processImageTransformation.LazyJsonString.from(inputString);\n            }\n            if (schemaDescriptor.getMergedTraits().httpHeader) {\n              this.stringBuffer = (this.serdeContext?.base64Encoder ?? ______imageTransformationHandler.toBase64)(inputString.toString());\n              return;\n            }\n          }\n          this.stringBuffer = ______________inputValue;\n          break;\n        default:\n          this.stringBuffer = String(______________inputValue);\n      }\n    }\n    flush() {\n      let getAndClearStringBuffer = this.stringBuffer;\n      this.stringBuffer = \"\";\n      return getAndClearStringBuffer;\n    }\n  };\n  var HttpInterceptingShapeSerializer = class {\n    constructor(codecSerializer, stringSerializer, serializerInstance = new StringShapeSerializer(stringSerializer)) {\n      this.codecSerializer = codecSerializer;\n      this.stringSerializer = serializerInstance;\n    }\n    setSerdeContext(__serdeContext) {\n      this.codecSerializer.setSerdeContext(__serdeContext);\n      this.stringSerializer.setSerdeContext(__serdeContext);\n    }\n    write(____________inputData, outputStream) {\n      let normalizedImageSchema = ____________________________imageProcessingPipeline.NormalizedSchema.of(____________inputData);\n      let __mergedTraits = normalizedImageSchema.getMergedTraits();\n      if (__mergedTraits.httpHeader || __mergedTraits.httpLabel || __mergedTraits.httpQuery) {\n        this.stringSerializer.write(normalizedImageSchema, outputStream);\n        this.buffer = this.stringSerializer.flush();\n        return;\n      }\n      return this.codecSerializer.write(normalizedImageSchema, outputStream);\n    }\n    flush() {\n      if (this.buffer !== undefined) {\n        let bufferContent = this.buffer;\n        this.buffer = undefined;\n        return bufferContent;\n      }\n      return this.codecSerializer.flush();\n    }\n  };\n});\nvar _createHttpRequestSigningMiddleware = z((createHttpRequestSigningMiddleware, identityProviderExports) => {\n  var {\n    defineProperty: definePropertyWithConfig,\n    getOwnPropertyDescriptor: ___getOwnPropertyDescriptor,\n    getOwnPropertyNames: ___getOwnPropertyNames\n  } = Object;\n  var _objectHasOwnProperty = Object.prototype.hasOwnProperty;\n  var defineFunctionName = (____definePropertyWithConfig, _newValue) => definePropertyWithConfig(____definePropertyWithConfig, \"name\", {\n    value: _newValue,\n    configurable: true\n  });\n  var ____defineProperties = (_definePropertiesWithConfig, __propertyDefinitions) => {\n    for (var _____________________________________propertyKey in __propertyDefinitions) {\n      definePropertyWithConfig(_definePropertiesWithConfig, _____________________________________propertyKey, {\n        get: __propertyDefinitions[_____________________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesNonEnumerably = (definePropertiesFromSourceObject, __________________________________________________________________________________________sourceObject, propertyProxy, ________________________propertyDescriptor) => {\n    if (__________________________________________________________________________________________sourceObject && typeof __________________________________________________________________________________________sourceObject === \"object\" || typeof __________________________________________________________________________________________sourceObject === \"function\") {\n      for (let _____________________________propertyName of ___getOwnPropertyNames(__________________________________________________________________________________________sourceObject)) {\n        if (!_objectHasOwnProperty.call(definePropertiesFromSourceObject, _____________________________propertyName) && _____________________________propertyName !== propertyProxy) {\n          definePropertyWithConfig(definePropertiesFromSourceObject, _____________________________propertyName, {\n            get: () => __________________________________________________________________________________________sourceObject[_____________________________propertyName],\n            enumerable: !(________________________propertyDescriptor = ___getOwnPropertyDescriptor(__________________________________________________________________________________________sourceObject, _____________________________propertyName)) || ________________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return definePropertiesFromSourceObject;\n  };\n  var createIdentityProviderExports = copyPropertiesNonEnumerablyOriginalPropertiesModuleExports => copyPropertiesNonEnumerably(definePropertyWithConfig({}, \"__esModule\", {\n    value: true\n  }), copyPropertiesNonEnumerablyOriginalPropertiesModuleExports);\n  var _identityProviderExports = {};\n  ____defineProperties(_identityProviderExports, {\n    DefaultIdentityProviderConfig: () => DefaultIdentityProviderConfig,\n    EXPIRATION_MS: () => DEFAULT_IDENTITY_EXPIRATION_MS,\n    HttpApiKeyAuthSigner: () => HttpApiKeyAuthSigner,\n    HttpBearerAuthSigner: () => HttpBearerAuthSigner,\n    NoAuthSigner: () => NoAuthSignatory,\n    createIsIdentityExpiredFunction: () => createIsIdentityExpiredFunction,\n    createPaginator: () => paginateOperation,\n    doesIdentityRequireRefresh: () => checkIfIdentityNeedsRefresh,\n    getHttpAuthSchemeEndpointRuleSetPlugin: () => getHttpAuthSchemeEndpointRuleSetPlugin,\n    getHttpAuthSchemePlugin: () => getHttpAuthSchemePlugin,\n    getHttpSigningPlugin: () => getHttpSigningMiddleware,\n    getSmithyContext: () => getSmithyContextFromRequest,\n    httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => httpAuthSchemeEndpointRuleSetMiddlewareOptions,\n    httpAuthSchemeMiddleware: () => httpAuthSchemeMiddlewareFunction,\n    httpAuthSchemeMiddlewareOptions: () => httpAuthSchemeMiddlewareOptions,\n    httpSigningMiddleware: () => signHttpRequestMiddleware,\n    httpSigningMiddlewareOptions: () => httpSigningMiddlewareOptions,\n    isIdentityExpired: () => isIdentityExpired,\n    memoizeIdentityProvider: () => memoizeRequestDataProvider,\n    normalizeProvider: () => normalizeIdentityProvider,\n    requestBuilder: () => _____________________________________imageProcessingPipeline.requestBuilder,\n    setFeature: () => setSmithyFeature\n  });\n  identityProviderExports.exports = createIdentityProviderExports(_identityProviderExports);\n  var ___________________________________________processImageTransformation = _____________________________processImageTransformation();\n  var getSmithyContextFromRequest = defineFunctionName(__smithyContext => __smithyContext[___________________________________________processImageTransformation.SMITHY_CONTEXT_KEY] ||= {}, \"getSmithyContext\");\n  var _______________________imageTransformationProcessor = ______________imageTransformationProcessor();\n  var filterAuthOptionsBySchemeIds = defineFunctionName((filterAndMergeItems, filterBySchemeIds) => {\n    if (!filterBySchemeIds || filterBySchemeIds.length === 0) {\n      return filterAndMergeItems;\n    }\n    let filteredSchemes = [];\n    for (let schemeId of filterBySchemeIds) {\n      for (let ___item of filterAndMergeItems) {\n        if (___item.schemeId.split(\"#\")[1] === schemeId) {\n          filteredSchemes.push(___item);\n        }\n      }\n    }\n    for (let __item of filterAndMergeItems) {\n      if (!filteredSchemes.find(({\n        schemeId: schemeIdCheck\n      }) => schemeIdCheck === __item.schemeId)) {\n        filteredSchemes.push(__item);\n      }\n    }\n    return filteredSchemes;\n  }, \"resolveAuthOptions\");\n  function createSchemeMap(_createSchemeMap) {\n    let schemeMap = new Map();\n    for (let schemeEntry of _createSchemeMap) {\n      schemeMap.set(schemeEntry.schemeId, schemeEntry);\n    }\n    return schemeMap;\n  }\n  defineFunctionName(createSchemeMap, \"convertHttpAuthSchemesToMap\");\n  var httpAuthSchemeMiddlewareFunction = defineFunctionName((httpAuthSchemeSelectionHandler, httpAuthSchemeProvider) => (processAuthorization, httpRequestContext) => async processHttpAuthScheme => {\n    let httpAuthScheme = httpAuthSchemeSelectionHandler.httpAuthSchemeProvider(await httpAuthSchemeProvider.httpAuthSchemeParametersProvider(httpAuthSchemeSelectionHandler, httpRequestContext, processHttpAuthScheme.input));\n    let authSchemePreferences = httpAuthSchemeSelectionHandler.authSchemePreference ? await httpAuthSchemeSelectionHandler.authSchemePreference() : [];\n    let authSchemeDetails = filterAuthOptionsBySchemeIds(httpAuthScheme, authSchemePreferences);\n    let selectedHttpAuthScheme = createSchemeMap(httpAuthSchemeSelectionHandler.httpAuthSchemes);\n    let smithyContext = (0, _______________________imageTransformationProcessor.getSmithyContext)(httpRequestContext);\n    let _errorMessages = [];\n    for (let authSchemeDetail of authSchemeDetails) {\n      let _httpAuthScheme = selectedHttpAuthScheme.get(authSchemeDetail.schemeId);\n      if (!_httpAuthScheme) {\n        _errorMessages.push(`HttpAuthScheme \\`${authSchemeDetail.schemeId}\\` was not enabled for this service.`);\n        continue;\n      }\n      let identityProvider = _httpAuthScheme.identityProvider(await httpAuthSchemeProvider.identityProviderConfigProvider(httpAuthSchemeSelectionHandler));\n      if (!identityProvider) {\n        _errorMessages.push(`HttpAuthScheme \\`${authSchemeDetail.schemeId}\\` did not have an IdentityProvider configured.`);\n        continue;\n      }\n      let {\n        identityProperties = {},\n        signingProperties: _signingProperties = {}\n      } = authSchemeDetail.propertiesExtractor?.(httpAuthSchemeSelectionHandler, httpRequestContext) || {};\n      authSchemeDetail.identityProperties = Object.assign(authSchemeDetail.identityProperties || {}, identityProperties);\n      authSchemeDetail.signingProperties = Object.assign(authSchemeDetail.signingProperties || {}, _signingProperties);\n      smithyContext.selectedHttpAuthScheme = {\n        httpAuthOption: authSchemeDetail,\n        identity: await identityProvider(authSchemeDetail.identityProperties),\n        signer: _httpAuthScheme.signer\n      };\n      break;\n    }\n    if (!smithyContext.selectedHttpAuthScheme) {\n      throw Error(_errorMessages.join(`\n`));\n    }\n    return processAuthorization(processHttpAuthScheme);\n  }, \"httpAuthSchemeMiddleware\");\n  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n    step: \"serialize\",\n    tags: [\"HTTP_AUTH_SCHEME\"],\n    name: \"httpAuthSchemeMiddleware\",\n    override: true,\n    relation: \"before\",\n    toMiddleware: \"endpointV2Middleware\"\n  };\n  var getHttpAuthSchemeEndpointRuleSetPlugin = defineFunctionName((httpClientConfig, {\n    httpAuthSchemeParametersProvider: httpAuthSchemeParamsProvider,\n    identityProviderConfigProvider: identityProviderConfigProvider\n  }) => ({\n    applyToStack: httpClientConfigurator => {\n      httpClientConfigurator.addRelativeTo(httpAuthSchemeMiddlewareFunction(httpClientConfig, {\n        httpAuthSchemeParametersProvider: httpAuthSchemeParamsProvider,\n        identityProviderConfigProvider: identityProviderConfigProvider\n      }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);\n    }\n  }), \"getHttpAuthSchemeEndpointRuleSetPlugin\");\n  var ___________________________imageTransformationProcessor = ___________________imageTransformationProcessor();\n  var httpAuthSchemeMiddlewareOptions = {\n    step: \"serialize\",\n    tags: [\"HTTP_AUTH_SCHEME\"],\n    name: \"httpAuthSchemeMiddleware\",\n    override: true,\n    relation: \"before\",\n    toMiddleware: ___________________________imageTransformationProcessor.serializerMiddlewareOption.name\n  };\n  var getHttpAuthSchemePlugin = defineFunctionName((createAuthHandler, {\n    httpAuthSchemeParametersProvider: _httpAuthSchemeParamsProvider,\n    identityProviderConfigProvider: identityProviderConfig\n  }) => ({\n    applyToStack: addAuthHandlerToProvider => {\n      addAuthHandlerToProvider.addRelativeTo(httpAuthSchemeMiddlewareFunction(createAuthHandler, {\n        httpAuthSchemeParametersProvider: _httpAuthSchemeParamsProvider,\n        identityProviderConfigProvider: identityProviderConfig\n      }), httpAuthSchemeMiddlewareOptions);\n    }\n  }), \"getHttpAuthSchemePlugin\");\n  var httpRequestUtil = updateMetadata();\n  var defaultErrorHandler = defineFunctionName(__handleError => throwError => {\n    throw throwError;\n  }, \"defaultErrorHandler\");\n  var defaultSuccessHandler = defineFunctionName((____processData, ___________callbackFunction) => {}, \"defaultSuccessHandler\");\n  var signHttpRequestMiddleware = defineFunctionName(signHttpRequest => (__handleHttpRequest, httpAuthContext) => async ___handleHttpRequest => {\n    if (!httpRequestUtil.HttpRequest.isInstance(___handleHttpRequest.request)) {\n      return __handleHttpRequest(___handleHttpRequest);\n    }\n    let _selectedHttpAuthScheme = (0, _______________________imageTransformationProcessor.getSmithyContext)(httpAuthContext).selectedHttpAuthScheme;\n    if (!_selectedHttpAuthScheme) {\n      throw Error(\"No HttpAuthScheme was selected: unable to sign request\");\n    }\n    let {\n      httpAuthOption: {\n        signingProperties = {}\n      },\n      identity: userIdentity,\n      signer: signerFunction\n    } = _selectedHttpAuthScheme;\n    let signedHttpResponse = await __handleHttpRequest({\n      ...___handleHttpRequest,\n      request: await signerFunction.sign(___handleHttpRequest.request, userIdentity, signingProperties)\n    }).catch((signerFunction.errorHandler || defaultErrorHandler)(signingProperties));\n    (signerFunction.successHandler || defaultSuccessHandler)(signedHttpResponse.response, signingProperties);\n    return signedHttpResponse;\n  }, \"httpSigningMiddleware\");\n  var httpSigningMiddlewareOptions = {\n    step: \"finalizeRequest\",\n    tags: [\"HTTP_SIGNING\"],\n    name: \"httpSigningMiddleware\",\n    aliases: [\"apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n    override: true,\n    relation: \"after\",\n    toMiddleware: \"retryMiddleware\"\n  };\n  var getHttpSigningMiddleware = defineFunctionName(createMiddlewareApplicator => ({\n    applyToStack: addMiddlewareToHttp => {\n      addMiddlewareToHttp.addRelativeTo(signHttpRequestMiddleware(createMiddlewareApplicator), httpSigningMiddlewareOptions);\n    }\n  }), \"getHttpSigningPlugin\");\n  var normalizeIdentityProvider = defineFunctionName(resolveValueOrFunction => {\n    if (typeof resolveValueOrFunction === \"function\") {\n      return resolveValueOrFunction;\n    }\n    let resolveValue = Promise.resolve(resolveValueOrFunction);\n    return () => resolveValue;\n  }, \"normalizeProvider\");\n  var makePagedClientRequest = defineFunctionName(async (createAndSendObject, messageSender, _dataProcessor, inputProcessor = placeholder => placeholder, ...additionalArgs) => {\n    let transformInput = new createAndSendObject(_dataProcessor);\n    transformInput = inputProcessor(transformInput) ?? transformInput;\n    return await messageSender.send(transformInput, ...additionalArgs);\n  }, \"makePagedClientRequest\");\n  function paginateOperation(clientType, fetchPaginatedData, paginationToken, tokenModifier, paginationTokenKey) {\n    return defineFunctionName(async function* (asyncGeneratorFunction, sourceData, ...additionalArguments) {\n      let sourceDataReference = sourceData;\n      let fetchNextToken = asyncGeneratorFunction.startingToken ?? sourceDataReference[paginationToken];\n      let shouldContinueFetching = true;\n      let fetchedData;\n      while (shouldContinueFetching) {\n        sourceDataReference[paginationToken] = fetchNextToken;\n        if (paginationTokenKey) {\n          sourceDataReference[paginationTokenKey] = sourceDataReference[paginationTokenKey] ?? asyncGeneratorFunction.pageSize;\n        }\n        if (asyncGeneratorFunction.client instanceof clientType) {\n          fetchedData = await makePagedClientRequest(fetchPaginatedData, asyncGeneratorFunction.client, sourceData, asyncGeneratorFunction.withCommand, ...additionalArguments);\n        } else {\n          throw Error(`Invalid client, expected instance of ${clientType.name}`);\n        }\n        yield fetchedData;\n        let previousToken = fetchNextToken;\n        fetchNextToken = fetchNextTokenFromPaginationResult(fetchedData, tokenModifier);\n        shouldContinueFetching = !!fetchNextToken && (!asyncGeneratorFunction.stopOnSameToken || fetchNextToken !== previousToken);\n      }\n      return;\n    }, \"paginateOperation\");\n  }\n  defineFunctionName(paginateOperation, \"createPaginator\");\n  var fetchNextTokenFromPaginationResult = defineFunctionName((getNestedProperty, _getNestedProperty) => {\n    let __getNestedProperty = getNestedProperty;\n    let propertyPath = _getNestedProperty.split(\".\");\n    for (let currentProperty of propertyPath) {\n      if (!__getNestedProperty || typeof __getNestedProperty !== \"object\") {\n        return;\n      }\n      __getNestedProperty = __getNestedProperty[currentProperty];\n    }\n    return __getNestedProperty;\n  }, \"get\");\n  var _____________________________________imageProcessingPipeline = createImageProcessingPipeline();\n  function setSmithyFeature(contextualizeFeature, featureKey, featureValue) {\n    if (!contextualizeFeature.__smithy_context) {\n      contextualizeFeature.__smithy_context = {\n        features: {}\n      };\n    } else if (!contextualizeFeature.__smithy_context.features) {\n      contextualizeFeature.__smithy_context.features = {};\n    }\n    contextualizeFeature.__smithy_context.features[featureKey] = featureValue;\n  }\n  defineFunctionName(setSmithyFeature, \"setFeature\");\n  var DefaultIdentityProviderConfig = class {\n    constructor(authSchemesConfig) {\n      this.authSchemes = new Map();\n      for (let [authSchemeKey, authSchemeValue] of Object.entries(authSchemesConfig)) {\n        if (authSchemeValue !== undefined) {\n          this.authSchemes.set(authSchemeKey, authSchemeValue);\n        }\n      }\n    }\n    static {\n      defineFunctionName(this, \"DefaultIdentityProviderConfig\");\n    }\n    getIdentityProvider(identityProviderKey) {\n      return this.authSchemes.get(identityProviderKey);\n    }\n  };\n  var HttpApiKeyAuthSigner = class {\n    static {\n      defineFunctionName(this, \"HttpApiKeyAuthSigner\");\n    }\n    async sign(signRequestWithApiKey, apiKeyConfig, apiKeyOptions) {\n      if (!apiKeyOptions) {\n        throw Error(\"request could not be signed with `apiKey` since the `name` and `in` signer properties are missing\");\n      }\n      if (!apiKeyOptions.name) {\n        throw Error(\"request could not be signed with `apiKey` since the `name` signer property is missing\");\n      }\n      if (!apiKeyOptions.in) {\n        throw Error(\"request could not be signed with `apiKey` since the `in` signer property is missing\");\n      }\n      if (!apiKeyConfig.apiKey) {\n        throw Error(\"request could not be signed with `apiKey` since the `apiKey` is not defined\");\n      }\n      let clonedHttpRequest = httpRequestUtil.HttpRequest.clone(signRequestWithApiKey);\n      if (apiKeyOptions.in === ___________________________________________processImageTransformation.HttpApiKeyAuthLocation.QUERY) {\n        clonedHttpRequest.query[apiKeyOptions.name] = apiKeyConfig.apiKey;\n      } else if (apiKeyOptions.in === ___________________________________________processImageTransformation.HttpApiKeyAuthLocation.HEADER) {\n        clonedHttpRequest.headers[apiKeyOptions.name] = apiKeyOptions.scheme ? `${apiKeyOptions.scheme} ${apiKeyConfig.apiKey}` : apiKeyConfig.apiKey;\n      } else {\n        throw Error(\"request can only be signed with `apiKey` locations `query` or `header`, but found: `\" + apiKeyOptions.in + \"`\");\n      }\n      return clonedHttpRequest;\n    }\n  };\n  var HttpBearerAuthSigner = class {\n    static {\n      defineFunctionName(this, \"HttpBearerAuthSigner\");\n    }\n    async sign(sourceHttpRequest, authDetails, signRequestWithToken) {\n      let clonedRequest = httpRequestUtil.HttpRequest.clone(sourceHttpRequest);\n      if (!authDetails.token) {\n        throw Error(\"request could not be signed with `token` since the `token` is not defined\");\n      }\n      clonedRequest.headers.Authorization = `Bearer ${authDetails.token}`;\n      return clonedRequest;\n    }\n  };\n  var NoAuthSignatory = class {\n    static {\n      defineFunctionName(this, \"NoAuthSigner\");\n    }\n    async sign(getSign, userId, signature) {\n      return getSign;\n    }\n  };\n  var createIsIdentityExpiredFunction = defineFunctionName(expirationCheck => isTokenExpired => checkIfIdentityNeedsRefresh(isTokenExpired) && isTokenExpired.expiration.getTime() - Date.now() < expirationCheck, \"createIsIdentityExpiredFunction\");\n  var DEFAULT_IDENTITY_EXPIRATION_MS = 300000;\n  var isIdentityExpired = createIsIdentityExpiredFunction(DEFAULT_IDENTITY_EXPIRATION_MS);\n  var checkIfIdentityNeedsRefresh = defineFunctionName(expirationExists => expirationExists.expiration !== undefined, \"doesIdentityRequireRefresh\");\n  var memoizeRequestDataProvider = defineFunctionName((processData, responseValidator, isQualified) => {\n    if (processData === undefined) {\n      return;\n    }\n    let valueProvider = typeof processData !== \"function\" ? async () => Promise.resolve(processData) : processData;\n    let resolvedValue;\n    let cachedPromise;\n    let isDataAvailable;\n    let isProcessingResponse = false;\n    let coalesceProviderFunction = defineFunctionName(async fetchAndCacheValue => {\n      if (!cachedPromise) {\n        cachedPromise = valueProvider(fetchAndCacheValue);\n      }\n      try {\n        resolvedValue = await cachedPromise;\n        isDataAvailable = true;\n        isProcessingResponse = false;\n      } finally {\n        cachedPromise = undefined;\n      }\n      return resolvedValue;\n    }, \"coalesceProvider\");\n    if (responseValidator === undefined) {\n      return async _fetchData => {\n        if (!isDataAvailable || _fetchData?.forceRefresh) {\n          resolvedValue = await coalesceProviderFunction(_fetchData);\n        }\n        return resolvedValue;\n      };\n    }\n    return async handleDataRequest => {\n      if (!isDataAvailable || handleDataRequest?.forceRefresh) {\n        resolvedValue = await coalesceProviderFunction(handleDataRequest);\n      }\n      if (isProcessingResponse) {\n        return resolvedValue;\n      }\n      if (!isQualified(resolvedValue)) {\n        isProcessingResponse = true;\n        return resolvedValue;\n      }\n      if (responseValidator(resolvedValue)) {\n        await coalesceProviderFunction(handleDataRequest);\n        return resolvedValue;\n      }\n      return resolvedValue;\n    };\n  }, \"memoizeIdentityProvider\");\n});\nvar _______imageTransformationProcessor = z((defineAndExportClientConfiguration, __________________moduleExports) => {\n  var {\n    defineProperty: _definePropertyWithDescriptor,\n    getOwnPropertyDescriptor: ________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _______________getOwnPropertyNames\n  } = Object;\n  var _______________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ______________________definePropertyWithName = (_________________________________________definePropertyWithName, descriptorValue) => _definePropertyWithDescriptor(_________________________________________definePropertyWithName, \"name\", {\n    value: descriptorValue,\n    configurable: true\n  });\n  var __________defineProperties = (____________definePropertiesWithGetters, propertyDescriptors) => {\n    for (var ______________________________________propertyKey in propertyDescriptors) {\n      _definePropertyWithDescriptor(____________definePropertiesWithGetters, ______________________________________propertyKey, {\n        get: propertyDescriptors[______________________________________propertyKey],\n        enumerable: true\n      });\n    }\n  };\n  var _copyPropertiesFromSource = (__assignProperties, __source, __________excludedPropertyName, _________________________propertyDescriptor) => {\n    if (__source && typeof __source === \"object\" || typeof __source === \"function\") {\n      for (let ______________________________propertyName of _______________getOwnPropertyNames(__source)) {\n        if (!_______________hasOwnProperty.call(__assignProperties, ______________________________propertyName) && ______________________________propertyName !== __________excludedPropertyName) {\n          _definePropertyWithDescriptor(__assignProperties, ______________________________propertyName, {\n            get: () => __source[______________________________propertyName],\n            enumerable: !(_________________________propertyDescriptor = ________________getOwnPropertyDescriptor(__source, ______________________________propertyName)) || _________________________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return __assignProperties;\n  };\n  var createClientConfigurationExport = ______copyPropertiesFromSource => _copyPropertiesFromSource(_definePropertyWithDescriptor({}, \"__esModule\", {\n    value: true\n  }), ______copyPropertiesFromSource);\n  var clientConfigurationExports = {};\n  __________defineProperties(clientConfigurationExports, {\n    AlgorithmId: () => sm0,\n    EndpointURLScheme: () => am0,\n    FieldPosition: () => rm0,\n    HttpApiKeyAuthLocation: () => nm0,\n    HttpAuthLocation: () => im0,\n    IniSectionType: () => om0,\n    RequestHandlerProtocol: () => tm0,\n    SMITHY_CONTEXT_KEY: () => _____SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => getDefaultChecksumAlgorithmConfiguration,\n    resolveDefaultRuntimeConfig: () => resolveDefaultChecksumConstructors\n  });\n  __________________moduleExports.exports = createClientConfigurationExport(clientConfigurationExports);\n  var im0 = (setUpApiConstants => {\n    setUpApiConstants.HEADER = \"header\";\n    setUpApiConstants.QUERY = \"query\";\n    return setUpApiConstants;\n  })(im0 || {});\n  var nm0 = (____initializeApiConstants => {\n    ____initializeApiConstants.HEADER = \"header\";\n    ____initializeApiConstants.QUERY = \"query\";\n    return ____initializeApiConstants;\n  })(nm0 || {});\n  var am0 = (_protocols => {\n    _protocols.HTTP = \"http\";\n    _protocols.HTTPS = \"https\";\n    return _protocols;\n  })(am0 || {});\n  var sm0 = (HashAlgorithms => {\n    HashAlgorithms.MD5 = \"md5\";\n    HashAlgorithms.CRC32 = \"crc32\";\n    HashAlgorithms.CRC32C = \"crc32c\";\n    HashAlgorithms.SHA1 = \"sha1\";\n    HashAlgorithms.SHA256 = \"sha256\";\n    return HashAlgorithms;\n  })(sm0 || {});\n  var _______createChecksumAlgorithmManager = ______________________definePropertyWithName(____createChecksumAlgorithmManager => {\n    let checksumAlgorithms = [];\n    if (____createChecksumAlgorithmManager.sha256 !== undefined) {\n      checksumAlgorithms.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => ____createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (____createChecksumAlgorithmManager.md5 != null) {\n      checksumAlgorithms.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => ____createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(_addChecksumAlgorithm) {\n        checksumAlgorithms.push(_addChecksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return checksumAlgorithms;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var resolveChecksumConstructorsByAlgorithmId = ______________________definePropertyWithName(_generateChecksumConstructors => {\n    let ___checksumConstructorsByAlgorithmId = {};\n    _generateChecksumConstructors.checksumAlgorithms().forEach(_checksumConstructorForAlgorithm => {\n      ___checksumConstructorsByAlgorithmId[_checksumConstructorForAlgorithm.algorithmId()] = _checksumConstructorForAlgorithm.checksumConstructor();\n    });\n    return ___checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var getDefaultChecksumAlgorithmConfiguration = ______________________definePropertyWithName(_____processInput => {\n    return _______createChecksumAlgorithmManager(_____processInput);\n  }, \"getDefaultClientConfiguration\");\n  var resolveDefaultChecksumConstructors = ______________________definePropertyWithName(performRQ4Calculation => {\n    return resolveChecksumConstructorsByAlgorithmId(performRQ4Calculation);\n  }, \"resolveDefaultRuntimeConfig\");\n  var rm0 = (_MessageTypes => {\n    _MessageTypes[_MessageTypes.HEADER = 0] = \"HEADER\";\n    _MessageTypes[_MessageTypes.TRAILER = 1] = \"TRAILER\";\n    return _MessageTypes;\n  })(rm0 || {});\n  var _____SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var om0 = (setupConstants => {\n    setupConstants.PROFILE = \"profile\";\n    setupConstants.SSO_SESSION = \"sso-session\";\n    setupConstants.SERVICES = \"services\";\n    return setupConstants;\n  })(om0 || {});\n  var tm0 = (initializeHttpVersionConstants => {\n    initializeHttpVersionConstants.HTTP_0_9 = \"http/0.9\";\n    initializeHttpVersionConstants.HTTP_1_0 = \"http/1.0\";\n    initializeHttpVersionConstants.TDS_8_0 = \"tds/8.0\";\n    return initializeHttpVersionConstants;\n  })(tm0 || {});\n});",
  "originalFile": "test-samples/claude.js",
  "originalProvider": "openai",
  "originalModel": "gpt-4o-mini",
  "originalArgs": {
    "provider": "openai",
    "outputDir": "output/claude-2025-11-16T19:49:17",
    "baseURL": "https://api.openai.com/v1",
    "contextSize": "100000",
    "maxConcurrent": "25",
    "minBatchSize": "3",
    "maxBatchSize": "100",
    "dependencyMode": "balanced",
    "perf": true,
    "maxMemory": "4096",
    "validate": true,
    "chunkSize": "300000",
    "chunking": true,
    "debugChunks": false,
    "turbo": true,
    "refine": true
  }
}