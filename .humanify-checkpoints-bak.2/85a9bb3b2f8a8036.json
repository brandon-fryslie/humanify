{
  "version": "2.0.0",
  "timestamp": 1763351015454,
  "inputHash": "85a9bb3b2f8a8036",
  "completedBatches": 3,
  "totalBatches": 119,
  "renames": {
    "cu9": "devToolsInitialization",
    "tj0": "devToolsConnection",
    "QS0": "rendererInstance",
    "AS0": "getDifferenceBetweenTwoObjects",
    "BS0": "cleanupYogaNode",
    "Ph": "renderComponent",
    "pu9": "getComputedWidthMinusPaddingAndBorders",
    "IS0": "calculateElementWidth",
    "ZS0": "borderStyles",
    "iu9": "colorPalette",
    "nu9": "lightAnsiColor",
    "au9": "darkAnsiColors",
    "su9": "lightDaltonizedColor",
    "ru9": "getDefaultColorPalette",
    "ou9": "areaDarkenedColorTheme",
    "WS0": "loadColorPalette",
    "tu9": "colorRegexPattern",
    "eu9": "ansiColorRegex",
    "CS0": "borderStyleMap",
    "Bm9": "_borderStyleMap",
    "VS0": "Renderer",
    "sZ1": "processAndDisplayNodes",
    "HS0": "initializeApplication",
    "Gm9": "processDelayedReactComponent",
    "Zm9": "isInsideStatic",
    "Ym9": "maxDigit",
    "tZ1": "extractInputColorChannels",
    "oZ1": "colorMapping",
    "US0": "customTransformation",
    "wS0": "colorSettings",
    "WPA": "colorManagementHelper",
    "AY1": "colorManagementSystem",
    "FPA": "Foreground_Pen_Actions",
    "BY1": "processManagement",
    "qS0": "connectionSource",
    "AyI": "InputProcessor",
    "Vm9": "formatText",
    "MS0": "initializeDevelopmentTools",
    "Dm9": "getModuleDetails",
    "Em9": "maxAllowedValue",
    "Hm9": "renderContainer",
    "zm9": "debuggingToolConnection",
    "CY1": "initializeAppState",
    "qm9": "defaultStyledChar",
    "Nm9": "emptySpace",
    "Om9": "SegmentColorer",
    "EPA": "environmentVariableDetection",
    "myI": "isNodeEnvironment",
    "dyI": "isBunEnvironment",
    "cyI": "runtimeEnvironmentDetected",
    "pyI": "isElectronEnvironment",
    "lyI": "isRunningInJsdomEnvironment",
    "iyI": "isWebWorkerContext",
    "nyI": "isDedicatedWorkerGlobalScope",
    "ayI": "platformGlobalContext",
    "syI": "isServiceWorkerGlobalScope",
    "IJA": "getUserAgentPlatform",
    "ryI": "isMacOS",
    "oyI": "getOSInformation",
    "tyI": "isLinuxOS",
    "eyI": "isOperatingInMobileEnvironment",
    "AkI": "isAndroidPlatform",
    "CH": "terminalCommands",
    "DY1": "processModule",
    "xI": "escapeSequence",
    "ZJA": "decodingString",
    "D0A": "alert",
    "GJA": "handleDevToolsConnection",
    "_S0": "compositeColorTransformFunction",
    "Pm9": "formatTextCursorPosition",
    "jm9": "updateVisualization",
    "vS0": "cursorLeftPosition",
    "vm9": "setCursorToPosition",
    "bm9": "commitUpdate",
    "fm9": "getCursorPosition",
    "hm9": "cursorMoveToNextLine",
    "gm9": "cursorPreviousLine",
    "um9": "hideCursor",
    "EY1": "cursorShow",
    "dm9": "clearLine",
    "cm9": "eraseStartLine",
    "bS0": "clearTargetNode",
    "pm9": "removeChildFromContainer",
    "lm9": "eraseCharacters",
    "KY1": "clearScreen",
    "im9": "handleChildHostContext",
    "nm9": "connectToDevTools",
    "am9": "clearTerminal",
    "sm9": "clearTerminalDisplay",
    "rm9": "enterAlternativeScreenCommand",
    "om9": "exitAlternativeScreenAction",
    "tm9": "processScrollEvents",
    "Bd9": "getAndSetReactDevTools",
    "Qd9": "updateDefaultRenderer",
    "xk": "colorManagement",
    "Id9": "handleComponentInitialization",
    "Sh": "initializeDevTools",
    "cS0": "processData",
    "pS0": "processState",
    "wY1": "_initializeDevelopmentTools",
    "lS0": "__initializeDevelopmentTools",
    "iS0": "rendererSetup",
    "wPA": "initializeReactDevTools",
    "nS0": "___initializeDevelopmentTools",
    "aS0": "____initializeDevelopmentTools",
    "$PA": "_processAndDisplayNodes",
    "rS0": "_initializeDevTools",
    "Fd9": "initializeDevToolsConnection",
    "By0": "__initializeDevTools",
    "Cd9": "_initializeDevToolsConnection",
    "Iy0": "initializeDebugTools",
    "NPA": "___initializeDevTools",
    "LY1": "__initializeDevToolsConnection",
    "S": "__processAndDisplayNodes",
    "MPA": "___initializeDevToolsConnection",
    "yh": "_initializeReactDevTools",
    "OY1": "____initializeDevToolsConnection",
    "Zy0": "_____initializeDevToolsConnection",
    "RPA": "DevToolsManager",
    "Xy0": "______initializeDevToolsConnection",
    "GX": "getDifferencesBetweenObjects",
    "SY1": "_______initializeDevToolsConnection",
    "Jy0": "________initializeDevToolsConnection",
    "Kd9": "_________initializeDevToolsConnection",
    "Dd9": "initializeRenderer",
    "Ed9": "__________initializeDevToolsConnection",
    "Hd9": "_____initializeDevelopmentTools",
    "TPA": "___________initializeDevToolsConnection",
    "Ud9": "____initializeDevTools",
    "wd9": "_initializeRenderer",
    "Cy0": "____________initializeDevToolsConnection",
    "Ky0": "_____initializeDevTools",
    "Dy0": "______initializeDevelopmentTools",
    "qd9": "______initializeDevTools",
    "Nd9": "_____________initializeDevToolsConnection",
    "PPA": "ProcessPublicAccess",
    "Ey0": "______________initializeDevToolsConnection",
    "jPA": "initializeDebuggerConnection",
    "Hy0": "_______initializeDevTools",
    "SPA": "SinglePageApplication",
    "cT": "_cleanupYogaNode",
    "Md9": "__initializeRenderer",
    "Od9": "________initializeDevTools",
    "Rd9": "_________initializeDevTools",
    "Td9": "_______initializeDevelopmentTools",
    "yPA": "_colorPalette",
    "JJA": "initializeDebuggingTools",
    "Uy0": "_______________initializeDevToolsConnection",
    "wy0": "__________initializeDevTools",
    "W_I": "________________initializeDevToolsConnection",
    "Ny0": "________initializeDevelopmentTools",
    "My0": "_________________initializeDevToolsConnection",
    "yd9": "___________initializeDevTools",
    "I5": "___initializeRenderer",
    "gY1": "retrieveColorSettings",
    "bd9": "initDevToolsConnection",
    "fd9": "__________________initializeDevToolsConnection",
    "u$": "devToolsHandler",
    "Py0": "___________________initializeDevToolsConnection",
    "jy0": "____________________initializeDevToolsConnection",
    "Sy0": "_____________________initializeDevToolsConnection",
    "yy0": "______________________initializeDevToolsConnection",
    "hd9": "_________initializeDevelopmentTools",
    "_y0": "devToolsInitializationHandler",
    "_h": "__________initializeDevelopmentTools",
    "mY1": "___________initializeDevelopmentTools",
    "h1": "renderAndSetupComponent",
    "md9": "____________initializeDevTools",
    "dY1": "renderingFunction1",
    "dd9": "_______________________initializeDevToolsConnection",
    "cd9": "____initializeRenderer",
    "cY1": "rendererInitialization",
    "xh": "_____________initializeDevTools",
    "gy0": "______________initializeDevTools",
    "xPA": "initializeColorPalette",
    "ly0": "_______________initializeDevTools",
    "ld9": "_____initializeRenderer",
    "ry0": "________________initializeDevTools",
    "ny0": "________________________initializeDevToolsConnection",
    "ay0": "_________________________initializeDevToolsConnection",
    "nY1": "_devToolsInitializationHandler",
    "id9": "__________________________initializeDevToolsConnection",
    "nd9": "initializeRendererComponent",
    "ad9": "___________________________initializeDevToolsConnection",
    "sd9": "_________________initializeDevTools",
    "aY1": "______initializeRenderer",
    "m$": "insertIndex",
    "hPA": "setupDevToolsConnection",
    "lT": "getLeftPadding",
    "uPA": "updateParentAttributes",
    "Qk0": "calculateObjectDifference",
    "rd9": "__________________initializeDevTools",
    "rV": "initializeRendering",
    "od9": "initializeDevToolsFromConnection",
    "dPA": "addDevicePixelDensity",
    "rY1": "initializeRenderTree",
    "oY1": "initializeRenderingProcess",
    "iT": "_______initializeRenderer",
    "Kk0": "___________________initializeDevTools",
    "Hk0": "____________________________initializeDevToolsConnection",
    "WJA": "_handleDevToolsConnection",
    "FJA": "_____________________________initializeDevToolsConnection",
    "nPA": "________initializeRenderer",
    "AJ1": "__initializeReactDevTools",
    "tk0": "_initializeDebugTools",
    "XJ1": "_________initializeRenderer",
    "KJ1": "______________________________initializeDevToolsConnection",
    "k_0": "calculateDifferencesBetweenObjects",
    "nvI": "colorFormatMappingFunction",
    "m_0": "colorConverter",
    "u_0": "colorKeywordMapping",
    "M2": "colorConversionMethods",
    "ovI": "createInputOptions",
    "a_0": "exportInputUtilities",
    "Ml9": "textAlignmentMap",
    "AbI": "processImageTransformations",
    "Zx0": "exportImageProcessingMethods",
    "Gx0": "PrecisionTypes",
    "A": "_ImageProcessor",
    "B": "inputDescriptor",
    "Q": "_________focusedOption",
    "G": "_currentOption",
    "vvI": "parseSemverRange",
    "D_0": "EjaExport",
    "Cp9": "whitespacePattern",
    "V_0": "isPrereleaseVersion",
    "$p9": "isEmptyVersion",
    "K_0": "checkIntersection",
    "ND": "isWildcard",
    "rvI": "colorModelConstructor",
    "i_0": "ColorConverter",
    "l_0": "colorModelNames",
    "zJ1": "colorLabelMap",
    "JjA": "colorModelTransformations",
    "tvI": "setupImageManipulationOptions",
    "Ax0": "exportImageResizingMethods",
    "o_0": "directions",
    "t_0": "PositionMapping",
    "r_0": "imageProcessingOptions",
    "e_0": "resizePositionStrategy",
    "wJ1": "resamplingMethods",
    "yl9": "resizeFitOptions",
    "kl9": "imageFitOptions",
    "NvI": "createSemanticVersion",
    "ck0": "SemVer",
    "fvI": "createSharpModule",
    "xp9": "_createSharpModule",
    "MkI": "createErrorStackCleaner",
    "eS0": "createStackTraceCleaner",
    "Yd9": "currentWorkingDirectory",
    "process": "getCurrentWorkingDirectory",
    "tS0": "nodeInternalPatterns",
    "Xd9": "stackTraceLinePattern",
    "Wd9": "functionNamePattern",
    "dvI": "createImageProcessor",
    "P_0": "ImageProcessor",
    "Gl9": "loadUtilModule",
    "VJ1": "StreamProcessingModule",
    "ivI": "_colorConverter",
    "h_0": "colorModule",
    "b_0": "objectHasOwnProperty",
    "f_0": "colorMap",
    "zJA": "colorKey",
    "cvI": "exportColorPalette",
    "S_0": "colorPaletteModule",
    "hvI": "processLibvipsSetup",
    "O_0": "moduleExports",
    "QjA": "spawnChildProcess",
    "vp9": "createHash",
    "mp9": "supportedPlatforms",
    "IjA": "spawnOptions",
    "dp9": "logInstallationError",
    "lp9": "getSharpLibvipsCPlusPlusDir",
    "N_0": "isUsingEmscripten",
    "WJ1": "handleGlobalLibvipsUsage",
    "I": "________focusedOption",
    "Z": "__visibleToIndexLimit",
    "Y": "visibleToIndexAdjustment",
    "J": "totalOptionsCount",
    "X": "focusOptionHandler"
  },
  "partialCode": "var devToolsInitialization = {};\nvar devToolsConnection;\nvar ej0 = T(() => {\n  rj0();\n  devToolsConnection = IA(oj0(), 1);\n  devToolsConnection.default.connectToDevTools();\n});\nvar rendererInstance;\nvar getDifferenceBetweenTwoObjects = (A, B) => {\n  if (A === B) {\n    return;\n  }\n  if (!A) {\n    return B;\n  }\n  let Q = {};\n  let I = false;\n  for (let G of Object.keys(A)) {\n    if (B ? !Object.hasOwn(B, G) : true) {\n      Q[G] = undefined;\n      I = true;\n    }\n  }\n  if (B) {\n    for (let G of Object.keys(B)) {\n      if (B[G] !== A[G]) {\n        Q[G] = B[G];\n        I = true;\n      }\n    }\n  }\n  if (I) {\n    return Q;\n  } else {\n    return undefined;\n  }\n};\nvar cleanupYogaNode = A => {\n  A?.unsetMeasureFunc();\n  A?.freeRecursive();\n};\nvar renderComponent;\nvar iZ1 = T(() => {\n  Ej0();\n  wi();\n  ZPA();\n  sj0();\n  rendererInstance = IA(Dj0(), 1);\n  if (process.env.DEV === \"true\") {\n    try {\n      Promise.resolve().then(() => ej0());\n    } catch (A) {\n      if (A.code === \"ERR_MODULE_NOT_FOUND\") {\n        console.warn(`${`\nThe environment variable DEV is set to true, so Ink tried to import \\`react-devtools-core\\`,\nbut this failed as it was not installed. Debugging with React Devtools requires it.\n\nTo install use this command:\n\n$ npm install --save-dev react-devtools-core\n\t\t\t\t`.trim()}\n`);\n      } else {\n        throw A;\n      }\n    }\n  }\n  renderComponent = rendererInstance.default({\n    getRootHostContext: () => ({\n      isInsideText: false\n    }),\n    prepareForCommit: () => null,\n    preparePortalMount: () => null,\n    clearContainer: () => false,\n    resetAfterCommit(A) {\n      if (typeof A.onComputeLayout === \"function\") {\n        A.onComputeLayout();\n      }\n      if (A.isStaticDirty) {\n        A.isStaticDirty = false;\n        if (typeof A.onImmediateRender === \"function\") {\n          A.onImmediateRender();\n        }\n        return;\n      }\n      A.onRender?.();\n    },\n    getChildHostContext(A, B) {\n      let Q = A.isInsideText;\n      let I = B === \"ink-text\" || B === \"ink-virtual-text\";\n      if (Q === I) {\n        return A;\n      }\n      return {\n        isInsideText: I\n      };\n    },\n    shouldSetTextContent: () => false,\n    createInstance(A, B, Q, I) {\n      if (I.isInsideText && A === \"ink-box\") {\n        throw Error(\"<Box> can’t be nested inside <Text> component\");\n      }\n      let G = A === \"ink-text\" && I.isInsideText ? \"ink-virtual-text\" : A;\n      let Z = QPA(G);\n      for (let [Y, J] of Object.entries(B)) {\n        if (Y === \"children\") {\n          continue;\n        }\n        if (Y === \"style\") {\n          cZ1(Z, J);\n          if (Z.yogaNode) {\n            pZ1(Z.yogaNode, J);\n          }\n          continue;\n        }\n        if (Y === \"internal_transform\") {\n          Z.internal_transform = J;\n          continue;\n        }\n        if (Y === \"internal_static\") {\n          Z.internal_static = true;\n          continue;\n        }\n        dZ1(Z, Y, J);\n      }\n      return Z;\n    },\n    createTextInstance(A, B, Q) {\n      if (!Q.isInsideText) {\n        throw Error(`Text string \"${A}\" must be rendered inside <Text> component`);\n      }\n      return nj0(A);\n    },\n    resetTextContent() {},\n    hideTextInstance(A) {\n      eYA(A, \"\");\n    },\n    unhideTextInstance(A, B) {\n      eYA(A, B);\n    },\n    getPublicInstance: A => A,\n    hideInstance(A) {\n      A.yogaNode?.setDisplay(TM.None);\n    },\n    unhideInstance(A) {\n      A.yogaNode?.setDisplay(TM.Flex);\n    },\n    appendInitialChild: IPA,\n    appendChild: IPA,\n    insertBefore: mZ1,\n    finalizeInitialChildren(A, B, Q, I) {\n      if (A.internal_static) {\n        I.isStaticDirty = true;\n        I.staticNode = A;\n      }\n      return false;\n    },\n    isPrimaryRenderer: true,\n    supportsMutation: true,\n    supportsPersistence: false,\n    supportsHydration: false,\n    scheduleTimeout: setTimeout,\n    cancelTimeout: clearTimeout,\n    noTimeout: -1,\n    getCurrentEventPriority: () => RZ1,\n    beforeActiveInstanceBlur() {},\n    afterActiveInstanceBlur() {},\n    detachDeletedInstance() {},\n    getInstanceFromNode: () => null,\n    prepareScopeUpdate() {},\n    getInstanceFromScope: () => null,\n    appendChildToContainer: IPA,\n    insertInContainerBefore: mZ1,\n    removeChildFromContainer(A, B) {\n      tYA(A, B);\n      cleanupYogaNode(B.yogaNode);\n    },\n    prepareUpdate(A, B, Q, I, G) {\n      if (A.internal_static) {\n        G.isStaticDirty = true;\n      }\n      let Z = getDifferenceBetweenTwoObjects(Q, I);\n      let Y = getDifferenceBetweenTwoObjects(Q.style, I.style);\n      if (!Z && !Y) {\n        return null;\n      }\n      return {\n        props: Z,\n        style: Y\n      };\n    },\n    commitUpdate(A, B) {\n      let {\n        props: Q,\n        style: I\n      } = B;\n      if (Q) {\n        for (let [G, Z] of Object.entries(Q)) {\n          if (G === \"style\") {\n            cZ1(A, Z);\n            continue;\n          }\n          if (G === \"internal_transform\") {\n            A.internal_transform = Z;\n            continue;\n          }\n          if (G === \"internal_static\") {\n            A.internal_static = true;\n            continue;\n          }\n          dZ1(A, G, Z);\n        }\n      }\n      if (I && A.yogaNode) {\n        pZ1(A.yogaNode, I);\n      }\n    },\n    commitTextUpdate(A, B, Q) {\n      eYA(A, Q);\n    },\n    removeChild(A, B) {\n      tYA(A, B);\n      cleanupYogaNode(B.yogaNode);\n    }\n  });\n});\nfunction nZ1(A, B = 1, Q = {}) {\n  let {\n    indent: I = \" \",\n    includeEmptyLines: G = false\n  } = Q;\n  if (typeof A !== \"string\") {\n    throw TypeError(`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof A}\\``);\n  }\n  if (typeof B !== \"number\") {\n    throw TypeError(`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof B}\\``);\n  }\n  if (B < 0) {\n    throw RangeError(`Expected \\`count\\` to be at least 0, got \\`${B}\\``);\n  }\n  if (typeof I !== \"string\") {\n    throw TypeError(`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof I}\\``);\n  }\n  if (B === 0) {\n    return A;\n  }\n  let Z = G ? /^/gm : /^(?!\\s*$)/gm;\n  return A.replace(Z, I.repeat(B));\n}\nvar getComputedWidthMinusPaddingAndBorders = A => {\n  return A.getComputedWidth() - A.getComputedPadding(l8.Left) - A.getComputedPadding(l8.Right) - A.getComputedBorder(l8.Left) - A.getComputedBorder(l8.Right);\n};\nvar calculateElementWidth;\nvar GS0 = T(() => {\n  wi();\n  calculateElementWidth = getComputedWidthMinusPaddingAndBorders;\n});\nvar borderStyles = z((SSI, lu9) => {\n  lu9.exports = {\n    single: {\n      topLeft: \"┌\",\n      top: \"─\",\n      topRight: \"┐\",\n      right: \"│\",\n      bottomRight: \"┘\",\n      bottom: \"─\",\n      bottomLeft: \"└\",\n      left: \"│\"\n    },\n    double: {\n      topLeft: \"╔\",\n      top: \"═\",\n      topRight: \"╗\",\n      right: \"║\",\n      bottomRight: \"╝\",\n      bottom: \"═\",\n      bottomLeft: \"╚\",\n      left: \"║\"\n    },\n    round: {\n      topLeft: \"╭\",\n      top: \"─\",\n      topRight: \"╮\",\n      right: \"│\",\n      bottomRight: \"╯\",\n      bottom: \"─\",\n      bottomLeft: \"╰\",\n      left: \"│\"\n    },\n    bold: {\n      topLeft: \"┏\",\n      top: \"━\",\n      topRight: \"┓\",\n      right: \"┃\",\n      bottomRight: \"┛\",\n      bottom: \"━\",\n      bottomLeft: \"┗\",\n      left: \"┃\"\n    },\n    singleDouble: {\n      topLeft: \"╓\",\n      top: \"─\",\n      topRight: \"╖\",\n      right: \"║\",\n      bottomRight: \"╜\",\n      bottom: \"─\",\n      bottomLeft: \"╙\",\n      left: \"║\"\n    },\n    doubleSingle: {\n      topLeft: \"╒\",\n      top: \"═\",\n      topRight: \"╕\",\n      right: \"│\",\n      bottomRight: \"╛\",\n      bottom: \"═\",\n      bottomLeft: \"╘\",\n      left: \"│\"\n    },\n    classic: {\n      topLeft: \"+\",\n      top: \"-\",\n      topRight: \"+\",\n      right: \"|\",\n      bottomRight: \"+\",\n      bottom: \"-\",\n      bottomLeft: \"+\",\n      left: \"|\"\n    },\n    arrow: {\n      topLeft: \"↘\",\n      top: \"↓\",\n      topRight: \"↙\",\n      right: \"←\",\n      bottomRight: \"↖\",\n      bottom: \"↑\",\n      bottomLeft: \"↗\",\n      left: \"→\"\n    }\n  };\n});\nvar JS0 = z((ySI, aZ1) => {\n  var YS0 = borderStyles();\n  aZ1.exports = YS0;\n  aZ1.exports.default = YS0;\n});\nfunction XS0(A) {\n  switch (A) {\n    case \"light\":\n      return colorPalette;\n    case \"light-ansi\":\n      return lightAnsiColor;\n    case \"dark-ansi\":\n      return darkAnsiColors;\n    case \"light-daltonized\":\n      return lightDaltonizedColor;\n    case \"dark-daltonized\":\n      return areaDarkenedColorTheme;\n    default:\n      return getDefaultColorPalette;\n  }\n}\nvar colorPalette;\nvar lightAnsiColor;\nvar darkAnsiColors;\nvar lightDaltonizedColor;\nvar getDefaultColorPalette;\nvar areaDarkenedColorTheme;\nvar loadColorPalette = T(() => {\n  colorPalette = {\n    autoAccept: \"rgb(135,0,255)\",\n    bashBorder: \"rgb(255,0,135)\",\n    claude: \"rgb(215,119,87)\",\n    claudeShimmer: \"rgb(245,149,117)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(87,105,247)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(117,135,255)\",\n    permission: \"rgb(87,105,247)\",\n    permissionShimmer: \"rgb(137,155,255)\",\n    planMode: \"rgb(0,102,102)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(153,153,153)\",\n    promptBorderShimmer: \"rgb(183,183,183)\",\n    text: \"rgb(0,0,0)\",\n    inverseText: \"rgb(255,255,255)\",\n    inactive: \"rgb(102,102,102)\",\n    subtle: \"rgb(175,175,175)\",\n    suggestion: \"rgb(87,105,247)\",\n    remember: \"rgb(0,0,255)\",\n    background: \"rgb(0,153,153)\",\n    success: \"rgb(44,122,57)\",\n    error: \"rgb(171,43,63)\",\n    warning: \"rgb(150,108,30)\",\n    warningShimmer: \"rgb(200,158,80)\",\n    diffAdded: \"rgb(105,219,124)\",\n    diffRemoved: \"rgb(255,168,180)\",\n    diffAddedDimmed: \"rgb(199,225,203)\",\n    diffRemovedDimmed: \"rgb(253,210,216)\",\n    diffAddedWord: \"rgb(47,157,68)\",\n    diffRemovedWord: \"rgb(209,69,75)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(220,38,38)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(37,99,235)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(22,163,74)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(202,138,4)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(147,51,234)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(234,88,12)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(219,39,119)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(8,145,178)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(240, 240, 240)\",\n    bashMessageBackgroundColor: \"rgb(250, 245, 250)\",\n    memoryBackgroundColor: \"rgb(230, 245, 250)\",\n    rate_limit_fill: \"rgb(87,105,247)\",\n    rate_limit_empty: \"rgb(39,47,111)\"\n  };\n  lightAnsiColor = {\n    autoAccept: \"ansi:magenta\",\n    bashBorder: \"ansi:magenta\",\n    claude: \"ansi:redBright\",\n    claudeShimmer: \"ansi:yellowBright\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"ansi:blue\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"ansi:blueBright\",\n    permission: \"ansi:blue\",\n    permissionShimmer: \"ansi:blueBright\",\n    planMode: \"ansi:cyan\",\n    ide: \"ansi:blueBright\",\n    promptBorder: \"ansi:white\",\n    promptBorderShimmer: \"ansi:whiteBright\",\n    text: \"ansi:black\",\n    inverseText: \"ansi:white\",\n    inactive: \"ansi:blackBright\",\n    subtle: \"ansi:blackBright\",\n    suggestion: \"ansi:blue\",\n    remember: \"ansi:blue\",\n    background: \"ansi:cyan\",\n    success: \"ansi:green\",\n    error: \"ansi:red\",\n    warning: \"ansi:yellow\",\n    warningShimmer: \"ansi:yellowBright\",\n    diffAdded: \"ansi:green\",\n    diffRemoved: \"ansi:red\",\n    diffAddedDimmed: \"ansi:green\",\n    diffRemovedDimmed: \"ansi:red\",\n    diffAddedWord: \"ansi:greenBright\",\n    diffRemovedWord: \"ansi:redBright\",\n    red_FOR_SUBAGENTS_ONLY: \"ansi:red\",\n    blue_FOR_SUBAGENTS_ONLY: \"ansi:blue\",\n    green_FOR_SUBAGENTS_ONLY: \"ansi:green\",\n    yellow_FOR_SUBAGENTS_ONLY: \"ansi:yellow\",\n    purple_FOR_SUBAGENTS_ONLY: \"ansi:magenta\",\n    orange_FOR_SUBAGENTS_ONLY: \"ansi:redBright\",\n    pink_FOR_SUBAGENTS_ONLY: \"ansi:magentaBright\",\n    cyan_FOR_SUBAGENTS_ONLY: \"ansi:cyan\",\n    professionalBlue: \"ansi:blueBright\",\n    rainbow_red: \"ansi:red\",\n    rainbow_orange: \"ansi:redBright\",\n    rainbow_yellow: \"ansi:yellow\",\n    rainbow_green: \"ansi:green\",\n    rainbow_blue: \"ansi:cyan\",\n    rainbow_indigo: \"ansi:blue\",\n    rainbow_violet: \"ansi:magenta\",\n    rainbow_red_shimmer: \"ansi:redBright\",\n    rainbow_orange_shimmer: \"ansi:yellow\",\n    rainbow_yellow_shimmer: \"ansi:yellowBright\",\n    rainbow_green_shimmer: \"ansi:greenBright\",\n    rainbow_blue_shimmer: \"ansi:cyanBright\",\n    rainbow_indigo_shimmer: \"ansi:blueBright\",\n    rainbow_violet_shimmer: \"ansi:magentaBright\",\n    clawd_body: \"ansi:redBright\",\n    clawd_background: \"ansi:black\",\n    userMessageBackground: \"ansi:white\",\n    bashMessageBackgroundColor: \"ansi:whiteBright\",\n    memoryBackgroundColor: \"ansi:white\",\n    rate_limit_fill: \"ansi:yellow\",\n    rate_limit_empty: \"ansi:black\"\n  };\n  darkAnsiColors = {\n    autoAccept: \"ansi:magentaBright\",\n    bashBorder: \"ansi:magentaBright\",\n    claude: \"ansi:redBright\",\n    claudeShimmer: \"ansi:yellowBright\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"ansi:blueBright\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"ansi:blueBright\",\n    permission: \"ansi:blueBright\",\n    permissionShimmer: \"ansi:blueBright\",\n    planMode: \"ansi:cyanBright\",\n    ide: \"ansi:blue\",\n    promptBorder: \"ansi:white\",\n    promptBorderShimmer: \"ansi:whiteBright\",\n    text: \"ansi:whiteBright\",\n    inverseText: \"ansi:black\",\n    inactive: \"ansi:white\",\n    subtle: \"ansi:white\",\n    suggestion: \"ansi:blueBright\",\n    remember: \"ansi:blueBright\",\n    background: \"ansi:cyanBright\",\n    success: \"ansi:greenBright\",\n    error: \"ansi:redBright\",\n    warning: \"ansi:yellowBright\",\n    warningShimmer: \"ansi:yellowBright\",\n    diffAdded: \"ansi:green\",\n    diffRemoved: \"ansi:red\",\n    diffAddedDimmed: \"ansi:green\",\n    diffRemovedDimmed: \"ansi:red\",\n    diffAddedWord: \"ansi:greenBright\",\n    diffRemovedWord: \"ansi:redBright\",\n    red_FOR_SUBAGENTS_ONLY: \"ansi:redBright\",\n    blue_FOR_SUBAGENTS_ONLY: \"ansi:blueBright\",\n    green_FOR_SUBAGENTS_ONLY: \"ansi:greenBright\",\n    yellow_FOR_SUBAGENTS_ONLY: \"ansi:yellowBright\",\n    purple_FOR_SUBAGENTS_ONLY: \"ansi:magentaBright\",\n    orange_FOR_SUBAGENTS_ONLY: \"ansi:redBright\",\n    pink_FOR_SUBAGENTS_ONLY: \"ansi:magentaBright\",\n    cyan_FOR_SUBAGENTS_ONLY: \"ansi:cyanBright\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"ansi:red\",\n    rainbow_orange: \"ansi:redBright\",\n    rainbow_yellow: \"ansi:yellow\",\n    rainbow_green: \"ansi:green\",\n    rainbow_blue: \"ansi:cyan\",\n    rainbow_indigo: \"ansi:blue\",\n    rainbow_violet: \"ansi:magenta\",\n    rainbow_red_shimmer: \"ansi:redBright\",\n    rainbow_orange_shimmer: \"ansi:yellow\",\n    rainbow_yellow_shimmer: \"ansi:yellowBright\",\n    rainbow_green_shimmer: \"ansi:greenBright\",\n    rainbow_blue_shimmer: \"ansi:cyanBright\",\n    rainbow_indigo_shimmer: \"ansi:blueBright\",\n    rainbow_violet_shimmer: \"ansi:magentaBright\",\n    clawd_body: \"ansi:redBright\",\n    clawd_background: \"ansi:black\",\n    userMessageBackground: \"ansi:blackBright\",\n    bashMessageBackgroundColor: \"ansi:black\",\n    memoryBackgroundColor: \"ansi:blackBright\",\n    rate_limit_fill: \"ansi:yellow\",\n    rate_limit_empty: \"ansi:white\"\n  };\n  lightDaltonizedColor = {\n    autoAccept: \"rgb(135,0,255)\",\n    bashBorder: \"rgb(0,102,204)\",\n    claude: \"rgb(255,153,51)\",\n    claudeShimmer: \"rgb(255,183,101)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(51,102,255)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(101,152,255)\",\n    permission: \"rgb(51,102,255)\",\n    permissionShimmer: \"rgb(101,152,255)\",\n    planMode: \"rgb(51,102,102)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(153,153,153)\",\n    promptBorderShimmer: \"rgb(183,183,183)\",\n    text: \"rgb(0,0,0)\",\n    inverseText: \"rgb(255,255,255)\",\n    inactive: \"rgb(102,102,102)\",\n    subtle: \"rgb(175,175,175)\",\n    suggestion: \"rgb(51,102,255)\",\n    remember: \"rgb(51,102,255)\",\n    background: \"rgb(0,153,153)\",\n    success: \"rgb(0,102,153)\",\n    error: \"rgb(204,0,0)\",\n    warning: \"rgb(255,153,0)\",\n    warningShimmer: \"rgb(255,183,50)\",\n    diffAdded: \"rgb(153,204,255)\",\n    diffRemoved: \"rgb(255,204,204)\",\n    diffAddedDimmed: \"rgb(209,231,253)\",\n    diffRemovedDimmed: \"rgb(255,233,233)\",\n    diffAddedWord: \"rgb(51,102,204)\",\n    diffRemovedWord: \"rgb(153,51,51)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(204,0,0)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(0,102,204)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(0,204,0)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(255,204,0)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(128,0,128)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(255,128,0)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(255,102,178)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(0,178,178)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(220, 220, 220)\",\n    bashMessageBackgroundColor: \"rgb(250, 245, 250)\",\n    memoryBackgroundColor: \"rgb(230, 245, 250)\",\n    rate_limit_fill: \"rgb(51,102,255)\",\n    rate_limit_empty: \"rgb(23,46,114)\"\n  };\n  getDefaultColorPalette = {\n    autoAccept: \"rgb(175,135,255)\",\n    bashBorder: \"rgb(253,93,177)\",\n    claude: \"rgb(215,119,87)\",\n    claudeShimmer: \"rgb(235,159,127)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(147,165,255)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(177,195,255)\",\n    permission: \"rgb(177,185,249)\",\n    permissionShimmer: \"rgb(207,215,255)\",\n    planMode: \"rgb(72,150,140)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(136,136,136)\",\n    promptBorderShimmer: \"rgb(166,166,166)\",\n    text: \"rgb(255,255,255)\",\n    inverseText: \"rgb(0,0,0)\",\n    inactive: \"rgb(153,153,153)\",\n    subtle: \"rgb(80,80,80)\",\n    suggestion: \"rgb(177,185,249)\",\n    remember: \"rgb(177,185,249)\",\n    background: \"rgb(0,204,204)\",\n    success: \"rgb(78,186,101)\",\n    error: \"rgb(255,107,128)\",\n    warning: \"rgb(255,193,7)\",\n    warningShimmer: \"rgb(255,223,57)\",\n    diffAdded: \"rgb(34,92,43)\",\n    diffRemoved: \"rgb(122,41,54)\",\n    diffAddedDimmed: \"rgb(71,88,74)\",\n    diffRemovedDimmed: \"rgb(105,72,77)\",\n    diffAddedWord: \"rgb(56,166,96)\",\n    diffRemovedWord: \"rgb(179,89,107)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(220,38,38)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(37,99,235)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(22,163,74)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(202,138,4)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(147,51,234)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(234,88,12)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(219,39,119)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(8,145,178)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(55, 55, 55)\",\n    bashMessageBackgroundColor: \"rgb(65, 60, 65)\",\n    memoryBackgroundColor: \"rgb(55, 65, 70)\",\n    rate_limit_fill: \"rgb(177,185,249)\",\n    rate_limit_empty: \"rgb(80,83,112)\"\n  };\n  areaDarkenedColorTheme = {\n    autoAccept: \"rgb(175,135,255)\",\n    bashBorder: \"rgb(51,153,255)\",\n    claude: \"rgb(255,153,51)\",\n    claudeShimmer: \"rgb(255,183,101)\",\n    claudeBlue_FOR_SYSTEM_SPINNER: \"rgb(153,204,255)\",\n    claudeBlueShimmer_FOR_SYSTEM_SPINNER: \"rgb(183,224,255)\",\n    permission: \"rgb(153,204,255)\",\n    permissionShimmer: \"rgb(183,224,255)\",\n    planMode: \"rgb(102,153,153)\",\n    ide: \"rgb(71,130,200)\",\n    promptBorder: \"rgb(136,136,136)\",\n    promptBorderShimmer: \"rgb(166,166,166)\",\n    text: \"rgb(255,255,255)\",\n    inverseText: \"rgb(0,0,0)\",\n    inactive: \"rgb(153,153,153)\",\n    subtle: \"rgb(80,80,80)\",\n    suggestion: \"rgb(153,204,255)\",\n    remember: \"rgb(153,204,255)\",\n    background: \"rgb(0,204,204)\",\n    success: \"rgb(51,153,255)\",\n    error: \"rgb(255,102,102)\",\n    warning: \"rgb(255,204,0)\",\n    warningShimmer: \"rgb(255,234,50)\",\n    diffAdded: \"rgb(0,68,102)\",\n    diffRemoved: \"rgb(102,0,0)\",\n    diffAddedDimmed: \"rgb(62,81,91)\",\n    diffRemovedDimmed: \"rgb(62,44,44)\",\n    diffAddedWord: \"rgb(0,119,179)\",\n    diffRemovedWord: \"rgb(179,0,0)\",\n    red_FOR_SUBAGENTS_ONLY: \"rgb(255,102,102)\",\n    blue_FOR_SUBAGENTS_ONLY: \"rgb(102,178,255)\",\n    green_FOR_SUBAGENTS_ONLY: \"rgb(102,255,102)\",\n    yellow_FOR_SUBAGENTS_ONLY: \"rgb(255,255,102)\",\n    purple_FOR_SUBAGENTS_ONLY: \"rgb(178,102,255)\",\n    orange_FOR_SUBAGENTS_ONLY: \"rgb(255,178,102)\",\n    pink_FOR_SUBAGENTS_ONLY: \"rgb(255,153,204)\",\n    cyan_FOR_SUBAGENTS_ONLY: \"rgb(102,204,204)\",\n    professionalBlue: \"rgb(106,155,204)\",\n    rainbow_red: \"rgb(235,95,87)\",\n    rainbow_orange: \"rgb(245,139,87)\",\n    rainbow_yellow: \"rgb(250,195,95)\",\n    rainbow_green: \"rgb(145,200,130)\",\n    rainbow_blue: \"rgb(130,170,220)\",\n    rainbow_indigo: \"rgb(155,130,200)\",\n    rainbow_violet: \"rgb(200,130,180)\",\n    rainbow_red_shimmer: \"rgb(250,155,147)\",\n    rainbow_orange_shimmer: \"rgb(255,185,137)\",\n    rainbow_yellow_shimmer: \"rgb(255,225,155)\",\n    rainbow_green_shimmer: \"rgb(185,230,180)\",\n    rainbow_blue_shimmer: \"rgb(180,205,240)\",\n    rainbow_indigo_shimmer: \"rgb(195,180,230)\",\n    rainbow_violet_shimmer: \"rgb(230,180,210)\",\n    clawd_body: \"rgb(215,119,87)\",\n    clawd_background: \"rgb(0,0,0)\",\n    userMessageBackground: \"rgb(55, 55, 55)\",\n    bashMessageBackgroundColor: \"rgb(65, 60, 65)\",\n    memoryBackgroundColor: \"rgb(55, 65, 70)\",\n    rate_limit_fill: \"rgb(153,204,255)\",\n    rate_limit_empty: \"rgb(69,92,115)\"\n  };\n});\nfunction OB(A, B, Q = \"foreground\") {\n  return I => Am9(I, A ? XS0(B)[A] : undefined, Q);\n}\nvar colorRegexPattern;\nvar ansiColorRegex;\nvar Am9 = (A, B, Q) => {\n  if (!B) {\n    return A;\n  }\n  if (B.startsWith(\"ansi:\")) {\n    switch (B.substring(5)) {\n      case \"black\":\n        if (Q === \"foreground\") {\n          return iA.black(A);\n        } else {\n          return iA.bgBlack(A);\n        }\n      case \"red\":\n        if (Q === \"foreground\") {\n          return iA.red(A);\n        } else {\n          return iA.bgRed(A);\n        }\n      case \"green\":\n        if (Q === \"foreground\") {\n          return iA.green(A);\n        } else {\n          return iA.bgGreen(A);\n        }\n      case \"yellow\":\n        if (Q === \"foreground\") {\n          return iA.yellow(A);\n        } else {\n          return iA.bgYellow(A);\n        }\n      case \"blue\":\n        if (Q === \"foreground\") {\n          return iA.blue(A);\n        } else {\n          return iA.bgBlue(A);\n        }\n      case \"magenta\":\n        if (Q === \"foreground\") {\n          return iA.magenta(A);\n        } else {\n          return iA.bgMagenta(A);\n        }\n      case \"cyan\":\n        if (Q === \"foreground\") {\n          return iA.cyan(A);\n        } else {\n          return iA.bgCyan(A);\n        }\n      case \"white\":\n        if (Q === \"foreground\") {\n          return iA.white(A);\n        } else {\n          return iA.bgWhite(A);\n        }\n      case \"blackBright\":\n        if (Q === \"foreground\") {\n          return iA.blackBright(A);\n        } else {\n          return iA.bgBlackBright(A);\n        }\n      case \"redBright\":\n        if (Q === \"foreground\") {\n          return iA.redBright(A);\n        } else {\n          return iA.bgRedBright(A);\n        }\n      case \"greenBright\":\n        if (Q === \"foreground\") {\n          return iA.greenBright(A);\n        } else {\n          return iA.bgGreenBright(A);\n        }\n      case \"yellowBright\":\n        if (Q === \"foreground\") {\n          return iA.yellowBright(A);\n        } else {\n          return iA.bgYellowBright(A);\n        }\n      case \"blueBright\":\n        if (Q === \"foreground\") {\n          return iA.blueBright(A);\n        } else {\n          return iA.bgBlueBright(A);\n        }\n      case \"magentaBright\":\n        if (Q === \"foreground\") {\n          return iA.magentaBright(A);\n        } else {\n          return iA.bgMagentaBright(A);\n        }\n      case \"cyanBright\":\n        if (Q === \"foreground\") {\n          return iA.cyanBright(A);\n        } else {\n          return iA.bgCyanBright(A);\n        }\n      case \"whiteBright\":\n        if (Q === \"foreground\") {\n          return iA.whiteBright(A);\n        } else {\n          return iA.bgWhiteBright(A);\n        }\n    }\n  }\n  if (B.startsWith(\"#\")) {\n    if (Q === \"foreground\") {\n      return iA.hex(B)(A);\n    } else {\n      return iA.bgHex(B)(A);\n    }\n  }\n  if (B.startsWith(\"ansi256\")) {\n    let I = ansiColorRegex.exec(B);\n    if (!I) {\n      return A;\n    }\n    let G = Number(I[1]);\n    if (Q === \"foreground\") {\n      return iA.ansi256(G)(A);\n    } else {\n      return iA.bgAnsi256(G)(A);\n    }\n  }\n  if (B.startsWith(\"rgb\")) {\n    let I = colorRegexPattern.exec(B);\n    if (!I) {\n      return A;\n    }\n    let G = Number(I[1]);\n    let Z = Number(I[2]);\n    let Y = Number(I[3]);\n    if (Q === \"foreground\") {\n      return iA.rgb(G, Z, Y)(A);\n    } else {\n      return iA.bgRgb(G, Z, Y)(A);\n    }\n  }\n  return A;\n};\nvar XPA = T(() => {\n  f2();\n  loadColorPalette();\n  colorRegexPattern = /^rgb\\(\\s?(\\d+),\\s?(\\d+),\\s?(\\d+)\\s?\\)$/;\n  ansiColorRegex = /^ansi256\\(\\s?(\\d+)\\s?\\)$/;\n});\nfunction FS0(A, B, Q, I = 0, G) {\n  let Z = k7(B);\n  let Y = A.length;\n  if (Z >= Y - 2) {\n    return B.substring(0, Y);\n  }\n  let J;\n  if (Q === \"center\") {\n    J = Math.floor((Y - Z) / 2);\n  } else if (Q === \"start\") {\n    J = I + 1;\n  } else {\n    J = Y - Z - I - 1;\n  }\n  J = Math.max(1, Math.min(J, Y - Z - 1));\n  let X = G.repeat(J - 1);\n  let W = G.repeat(Y - J - Z - 1);\n  return A.substring(0, 1) + X + B + W + A.substring(A.length - 1);\n}\nvar borderStyleMap;\nvar _borderStyleMap;\nvar Qm9 = (A, B, Q, I, G) => {\n  if (Q.style.borderStyle) {\n    let Z = Math.floor(Q.yogaNode.getComputedWidth());\n    let Y = Math.floor(Q.yogaNode.getComputedHeight());\n    let J = typeof Q.style.borderStyle === \"string\" ? _borderStyleMap[Q.style.borderStyle] ?? borderStyleMap.default[Q.style.borderStyle] : Q.style.borderStyle;\n    let X = Q.style.borderTopColor ?? Q.style.borderColor;\n    let W = Q.style.borderBottomColor ?? Q.style.borderColor;\n    let F = Q.style.borderLeftColor ?? Q.style.borderColor;\n    let C = Q.style.borderRightColor ?? Q.style.borderColor;\n    let V = Q.style.borderTopDimColor ?? Q.style.borderDimColor;\n    let K = Q.style.borderBottomDimColor ?? Q.style.borderDimColor;\n    let D = Q.style.borderLeftDimColor ?? Q.style.borderDimColor;\n    let E = Q.style.borderRightDimColor ?? Q.style.borderDimColor;\n    let H = Q.style.borderTop !== false;\n    let w = Q.style.borderBottom !== false;\n    let L = Q.style.borderLeft !== false;\n    let N = Q.style.borderRight !== false;\n    let $ = Z - (L ? 1 : 0) - (N ? 1 : 0);\n    let O = H ? (L ? J.topLeft : \"\") + J.top.repeat($) + (N ? J.topRight : \"\") : \"\";\n    if (H && Q.style.borderText?.position === \"top\") {\n      let l = Q.style.borderText;\n      O = FS0(O, l.content, l.align, l.offset, J.top);\n    }\n    let P = H ? OB(X, G)(O) : undefined;\n    if (H && V) {\n      P = iA.dim(P);\n    }\n    let k = Y;\n    if (H) {\n      k -= 1;\n    }\n    if (w) {\n      k -= 1;\n    }\n    let b = `${OB(F, G)(J.left)}\n`.repeat(k);\n    if (D) {\n      b = iA.dim(b);\n    }\n    let x = `${OB(C, G)(J.right)}\n`.repeat(k);\n    if (E) {\n      x = iA.dim(x);\n    }\n    let n = w ? (L ? J.bottomLeft : \"\") + J.bottom.repeat($) + (N ? J.bottomRight : \"\") : \"\";\n    if (w && Q.style.borderText?.position === \"bottom\") {\n      let l = Q.style.borderText;\n      n = FS0(n, l.content, l.align, l.offset, J.bottom);\n    }\n    let m = w ? OB(W, G)(n) : undefined;\n    if (w && K) {\n      m = iA.dim(m);\n    }\n    let o = H ? 1 : 0;\n    if (P) {\n      I.write(A, B, P, {\n        transformers: []\n      });\n    }\n    if (L) {\n      I.write(A, B + o, b, {\n        transformers: []\n      });\n    }\n    if (N) {\n      I.write(A + Z - 1, B + o, x, {\n        transformers: []\n      });\n    }\n    if (m) {\n      I.write(A, B + Y - 1, m, {\n        transformers: []\n      });\n    }\n  }\n};\nvar Renderer;\nvar KS0 = T(() => {\n  f2();\n  F0A();\n  XPA();\n  borderStyleMap = IA(JS0(), 1);\n  _borderStyleMap = {\n    dashed: {\n      top: \"╌\",\n      left: \"╎\",\n      right: \"╎\",\n      bottom: \"╌\",\n      topLeft: \" \",\n      topRight: \" \",\n      bottomLeft: \" \",\n      bottomRight: \" \"\n    }\n  };\n  Renderer = Qm9;\n});\nvar Im9 = (A, B) => {\n  let Q = A.childNodes[0]?.yogaNode;\n  if (Q) {\n    let I = Q.getComputedLeft();\n    let G = Q.getComputedTop();\n    B = `\n`.repeat(G) + nZ1(B, I);\n  }\n  return B;\n};\nvar DS0 = (A, B, {\n  offsetX: Q = 0,\n  offsetY: I = 0,\n  transformers: G = [],\n  skipStaticElements: Z,\n  theme: Y\n}) => {\n  if (Z && A.internal_static) {\n    return;\n  }\n  let {\n    yogaNode: J\n  } = A;\n  if (J) {\n    if (J.getDisplay() === TM.None) {\n      return;\n    }\n    let X = Q + J.getComputedLeft();\n    let W = I + J.getComputedTop();\n    let F = G;\n    if (typeof A.internal_transform === \"function\") {\n      F = [A.internal_transform, ...G];\n    }\n    if (A.nodeName === \"ink-text\") {\n      let V = BPA(A);\n      if (V.length > 0) {\n        let K = W0A(V);\n        let D = calculateElementWidth(J);\n        if (K > D) {\n          let E = A.style.textWrap ?? \"wrap\";\n          V = Th(V, D, E);\n        }\n        V = Im9(A, V);\n        B.write(X, W, V, {\n          transformers: F\n        });\n      }\n      return;\n    }\n    let C = false;\n    if (A.nodeName === \"ink-box\") {\n      Renderer(X, W, A, B, Y);\n      let V = A.style.overflowX === \"hidden\" || A.style.overflow === \"hidden\";\n      let K = A.style.overflowY === \"hidden\" || A.style.overflow === \"hidden\";\n      if (V || K) {\n        let D = V ? X + J.getComputedBorder(l8.Left) : undefined;\n        let E = V ? X + J.getComputedWidth() - J.getComputedBorder(l8.Right) : undefined;\n        let H = K ? W + J.getComputedBorder(l8.Top) : undefined;\n        let w = K ? W + J.getComputedHeight() - J.getComputedBorder(l8.Bottom) : undefined;\n        B.clip({\n          x1: D,\n          x2: E,\n          y1: H,\n          y2: w\n        });\n        C = true;\n      }\n    }\n    if (A.nodeName === \"ink-root\" || A.nodeName === \"ink-box\") {\n      for (let V of A.childNodes) {\n        DS0(V, B, {\n          offsetX: X,\n          offsetY: W,\n          transformers: F,\n          skipStaticElements: Z,\n          theme: Y\n        });\n      }\n      if (C) {\n        B.unclip();\n      }\n    }\n  }\n};\nvar processAndDisplayNodes;\nvar ES0 = T(() => {\n  sTA();\n  wi();\n  APA();\n  GS0();\n  gZ1();\n  KS0();\n  processAndDisplayNodes = DS0;\n});\nfunction rZ1(A) {\n  if (!Number.isInteger(A)) {\n    return false;\n  }\n  return X0A(A) === 2;\n}\nvar initializeApplication = T(() => {\n  sYA();\n});\nfunction Jm9(A) {\n  if (extractInputColorChannels.has(A)) {\n    return A;\n  }\n  if (colorMapping.has(A)) {\n    return colorMapping.get(A);\n  }\n  A = A.slice(2);\n  if (A.includes(\";\")) {\n    A = A[0] + \"0\";\n  }\n  let B = A3.codes.get(Number.parseInt(A, 10));\n  if (B) {\n    return A3.color.ansi(B);\n  }\n  return A3.reset.open;\n}\nfunction Xm9(A) {\n  for (let B = 0; B < A.length; B++) {\n    let Q = A.codePointAt(B);\n    if (Q >= isInsideStatic && Q <= maxDigit) {\n      return B;\n    }\n  }\n  return -1;\n}\nfunction Wm9(A, B) {\n  A = A.slice(B, B + 19);\n  let Q = Xm9(A);\n  if (Q !== -1) {\n    let I = A.indexOf(\"m\", Q);\n    if (I === -1) {\n      I = A.length;\n    }\n    return A.slice(0, I + 1);\n  }\n}\nfunction Fm9(A, B = Number.POSITIVE_INFINITY) {\n  let Q = [];\n  let I = 0;\n  let G = 0;\n  while (I < A.length) {\n    let Z = A.codePointAt(I);\n    if (processDelayedReactComponent.has(Z)) {\n      let X = Wm9(A, I);\n      if (X) {\n        Q.push({\n          type: \"ansi\",\n          code: X,\n          endCode: Jm9(X)\n        });\n        I += X.length;\n        continue;\n      }\n    }\n    let Y = rZ1(Z);\n    let J = String.fromCodePoint(Z);\n    Q.push({\n      type: \"character\",\n      value: J,\n      isFullWidth: Y\n    });\n    I += J.length;\n    if (Y) {\n      G += 2;\n    } else {\n      G += J.length;\n    }\n    if (G >= B) {\n      break;\n    }\n  }\n  return Q;\n}\nfunction zS0(A) {\n  let B = [];\n  for (let Q of A) {\n    if (Q.code === A3.reset.open) {\n      B = [];\n    } else if (extractInputColorChannels.has(Q.code)) {\n      B = B.filter(I => I.endCode !== Q.code);\n    } else {\n      B = B.filter(I => I.endCode !== Q.endCode);\n      B.push(Q);\n    }\n  }\n  return B;\n}\nfunction Cm9(A) {\n  return zS0(A).map(({\n    endCode: I\n  }) => I).reverse().join(\"\");\n}\nfunction $i(A, B, Q) {\n  let I = Fm9(A, Q);\n  let G = [];\n  let Z = 0;\n  let Y = \"\";\n  let J = false;\n  for (let X of I) {\n    if (Q !== undefined && Z >= Q) {\n      break;\n    }\n    if (X.type === \"ansi\") {\n      G.push(X);\n      if (J) {\n        Y += X.code;\n      }\n    } else {\n      if (!J && Z >= B) {\n        J = true;\n        G = zS0(G);\n        Y = G.map(({\n          code: W\n        }) => W).join(\"\");\n      }\n      if (J) {\n        Y += X.value;\n      }\n      if (X.isFullWidth) {\n        Z += 2;\n      } else {\n        Z += X.value.length;\n      }\n    }\n  }\n  Y += Cm9(G);\n  return Y;\n}\nvar processDelayedReactComponent;\nvar isInsideStatic;\nvar maxDigit;\nvar extractInputColorChannels;\nvar colorMapping;\nvar eZ1 = T(() => {\n  C0A();\n  initializeApplication();\n  processDelayedReactComponent = new Set([27, 155]);\n  isInsideStatic = \"0\".codePointAt(0);\n  maxDigit = \"9\".codePointAt(0);\n  extractInputColorChannels = new Set();\n  colorMapping = new Map();\n  for (let [A, B] of A3.codes) {\n    extractInputColorChannels.add(A3.color.ansi(B));\n    colorMapping.set(A3.color.ansi(A), A3.color.ansi(B));\n  }\n});\nfunction QY1(A) {\n  if (colorManagementHelper.has(A)) {\n    return A;\n  }\n  if (colorManagementSystem.has(A)) {\n    return colorManagementSystem.get(A);\n  }\n  if (A.startsWith(Foreground_Pen_Actions)) {\n    return formatText;\n  }\n  A = A.slice(2);\n  if (A.startsWith(\"38\")) {\n    return A3.color.close;\n  } else if (A.startsWith(\"48\")) {\n    return A3.bgColor.close;\n  }\n  let B = A3.codes.get(parseInt(A, 10));\n  if (B) {\n    return A3.color.ansi(B);\n  } else {\n    return A3.reset.open;\n  }\n}\nfunction _k(A) {\n  return A.map(B => B.code).join(\"\");\n}\nvar customTransformation;\nvar colorSettings;\nvar $S0;\nvar colorManagementHelper;\nvar colorManagementSystem;\nvar Foreground_Pen_Actions = \"\u001b]8;;\";\nvar processManagement;\nvar connectionSource = \"\u0007\";\nvar InputProcessor;\nvar formatText;\nvar AJA = T(() => {\n  C0A();\n  customTransformation = new Set([27, 155]);\n  colorSettings = \"[\".codePointAt(0);\n  $S0 = \"]\".codePointAt(0);\n  colorManagementHelper = new Set();\n  colorManagementSystem = new Map();\n  for (let [A, B] of A3.codes) {\n    colorManagementHelper.add(A3.color.ansi(B));\n    colorManagementSystem.set(A3.color.ansi(A), A3.color.ansi(B));\n  }\n  processManagement = Foreground_Pen_Actions.split(\"\").map(A => A.charCodeAt(0));\n  InputProcessor = connectionSource.charCodeAt(0);\n  formatText = `\\x1B]8;;${connectionSource}`;\n});\nfunction IY1(A) {\n  return CPA([], A);\n}\nfunction CPA(A, B) {\n  let Q = [...A];\n  for (let I of B) {\n    if (I.code === A3.reset.open) {\n      Q = [];\n    } else if (colorManagementHelper.has(I.code)) {\n      Q = Q.filter(G => G.endCode !== I.code);\n    } else if (I.code === A3.bold.open || I.code === A3.dim.open) {\n      if (!Q.find(Z => Z.code === I.code && Z.endCode === I.endCode)) {\n        Q.push(I);\n      }\n    } else {\n      Q = Q.filter(Z => Z.endCode !== I.endCode);\n      Q.push(I);\n    }\n  }\n  return Q;\n}\nvar VPA = T(() => {\n  C0A();\n  AJA();\n});\nfunction GY1(A) {\n  return IY1(A).reverse().map(B => ({\n    ...B,\n    code: B.endCode\n  }));\n}\nvar ZY1 = T(() => {\n  VPA();\n});\nfunction jh(A, B) {\n  let Q = new Set(B.map(G => G.endCode));\n  let I = new Set(A.map(G => G.code));\n  return [...GY1(A.filter(G => !Q.has(G.endCode))), ...B.filter(G => !I.has(G.code))];\n}\nvar YY1 = T(() => {\n  ZY1();\n});\nfunction JY1(A) {\n  let B = [];\n  let Q = [];\n  for (let I of A) {\n    if (I.type === \"ansi\") {\n      B = CPA(B, [I]);\n    } else if (I.type === \"char\") {\n      Q.push({\n        ...I,\n        styles: [...B]\n      });\n    }\n  }\n  return Q;\n}\nfunction NS0(A) {\n  let B = \"\";\n  for (let Q = 0; Q < A.length; Q++) {\n    let I = A[Q];\n    if (Q === 0) {\n      B += _k(I.styles);\n    } else {\n      B += _k(jh(A[Q - 1].styles, I.styles));\n    }\n    B += I.value;\n    if (Q === A.length - 1) {\n      B += _k(jh(I.styles, []));\n    }\n  }\n  return B;\n}\nvar LS0 = T(() => {\n  AJA();\n  YY1();\n  VPA();\n});\nfunction XY1(A) {\n  if (!Number.isInteger(A)) {\n    return false;\n  }\n  return nYA(A) || aYA(A);\n}\nvar initializeDevelopmentTools = T(() => {\n  sYA();\n});\nfunction Km9(A, B) {\n  A = A.slice(B);\n  for (let I = 1; I < processManagement.length; I++) {\n    if (A.charCodeAt(I) !== processManagement[I]) {\n      return;\n    }\n  }\n  let Q = A.indexOf(\"\u0007\", Foreground_Pen_Actions.length);\n  if (Q === -1) {\n    return;\n  }\n  return A.slice(0, Q + 1);\n}\nfunction Um9(A) {\n  for (let B = 2; B < A.length; B++) {\n    let Q = A.charCodeAt(B);\n    if (Q === debuggingToolConnection) {\n      return B;\n    }\n    if (Q === renderContainer) {\n      continue;\n    }\n    if (Q >= getModuleDetails && Q <= maxAllowedValue) {\n      continue;\n    }\n    break;\n  }\n  return -1;\n}\nfunction wm9(A, B) {\n  A = A.slice(B);\n  let Q = Um9(A);\n  if (Q === -1) {\n    return;\n  }\n  return A.slice(0, Q + 1);\n}\nfunction $m9(A) {\n  if (!A.includes(\";\")) {\n    return [A];\n  }\n  let B = A.slice(2, -1).split(\";\");\n  let Q = [];\n  for (let I = 0; I < B.length; I++) {\n    let G = B[I];\n    if (G === \"38\" || G === \"48\") {\n      if (I + 2 < B.length && B[I + 1] === \"5\") {\n        Q.push(B.slice(I, I + 3).join(\";\"));\n        I += 2;\n        continue;\n      } else if (I + 4 < B.length && B[I + 1] === \"2\") {\n        Q.push(B.slice(I, I + 5).join(\";\"));\n        I += 4;\n        continue;\n      }\n    }\n    Q.push(G);\n  }\n  return Q.map(I => `\\x1B[${I}m`);\n}\nfunction WY1(A, B = Number.POSITIVE_INFINITY) {\n  let Q = [];\n  let I = 0;\n  let G = 0;\n  while (I < A.length) {\n    let Z = A.codePointAt(I);\n    if (customTransformation.has(Z)) {\n      let X;\n      let W = A.codePointAt(I + 1);\n      if (W === $S0) {\n        X = Km9(A, I);\n        if (X) {\n          Q.push({\n            type: \"ansi\",\n            code: X,\n            endCode: QY1(X)\n          });\n        }\n      } else if (W === colorSettings) {\n        X = wm9(A, I);\n        if (X) {\n          let F = $m9(X);\n          for (let C of F) {\n            Q.push({\n              type: \"ansi\",\n              code: C,\n              endCode: QY1(C)\n            });\n          }\n        }\n      }\n      if (X) {\n        I += X.length;\n        continue;\n      }\n    }\n    let Y = XY1(Z);\n    let J = String.fromCodePoint(Z);\n    Q.push({\n      type: \"char\",\n      value: J,\n      fullWidth: Y\n    });\n    I += J.length;\n    if (Y) {\n      G += 2;\n    } else {\n      G += J.length;\n    }\n    if (G >= B) {\n      break;\n    }\n  }\n  return Q;\n}\nvar getModuleDetails = 48;\nvar maxAllowedValue = 57;\nvar renderContainer = 59;\nvar debuggingToolConnection = 109;\nvar OS0 = T(() => {\n  initializeDevelopmentTools();\n  AJA();\n});\nvar FY1 = T(() => {\n  AJA();\n  YY1();\n  VPA();\n  ZY1();\n  LS0();\n  OS0();\n});\nfunction KPA(A, B) {\n  return B.x < A.width && B.y < A.height;\n}\nfunction sY(A, B) {\n  if (A === undefined) {\n    return;\n  }\n  if (Number.isInteger(A)) {\n    return;\n  }\n  g(`${B} should be an integer, got ${A}`, {\n    level: \"warn\"\n  });\n}\nvar initializeAppState = T(() => {\n  C0();\n});\nfunction Lm9(A, B) {\n  if (A.char !== B.char || A.width !== B.width) {\n    return false;\n  }\n  if (A.styles.length !== B.styles.length) {\n    return false;\n  }\n  for (let Q = 0; Q < A.styles.length; Q++) {\n    if (A.styles[Q].code !== B.styles[Q].code) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction K0A(A, B) {\n  sY(A, \"createScreen width\");\n  sY(B, \"createScreen height\");\n  if (!Number.isInteger(A) || A < 0) {\n    A = Math.max(0, Math.floor(A) || 0);\n  }\n  if (!Number.isInteger(B) || B < 0) {\n    B = Math.max(0, Math.floor(B) || 0);\n  }\n  let Q = Array(A * B).fill(defaultStyledChar);\n  return {\n    width: A,\n    height: B,\n    cells: Q\n  };\n}\nfunction DPA(A, B) {\n  if (!KPA(A, B)) {\n    return;\n  }\n  let Q = B.y * A.width + B.x;\n  return A.cells[Q];\n}\nfunction TS0(A, B) {\n  let {\n    x: Q,\n    y: I\n  } = B;\n  let G = A.width;\n  return I * G + Q;\n}\nfunction PS0(A, B, Q) {\n  if (!KPA(A, B)) {\n    return;\n  }\n  let I = TS0(A, B);\n  A.cells[I] = Q;\n  if (Q.width === 1) {\n    let G = {\n      x: B.x + 1,\n      y: B.y\n    };\n    if (KPA(A, G)) {\n      let Z = TS0(A, G);\n      A.cells[Z] = emptySpace;\n    }\n  }\n}\nfunction jS0(A, B) {\n  let Q = [];\n  let I = Math.max(A.height, B.height);\n  let G = Math.max(A.width, B.width);\n  for (let Z = 0; Z < I; Z += 1) {\n    for (let Y = 0; Y < G; Y += 1) {\n      let J = {\n        x: Y,\n        y: Z\n      };\n      let X = DPA(A, J);\n      let W = DPA(B, J);\n      if (X && W && Lm9(X, W)) {\n        continue;\n      }\n      Q.push([J, X, W]);\n    }\n  }\n  return Q;\n}\nvar defaultStyledChar;\nvar emptySpace;\nvar BJA = T(() => {\n  initializeAppState();\n  defaultStyledChar = Object.freeze({\n    char: \" \",\n    styles: [],\n    width: 0\n  });\n  emptySpace = Object.freeze({\n    char: \"\",\n    styles: [],\n    width: 2\n  });\n});\nclass QJA {\n  width;\n  height;\n  ink2;\n  operations = [];\n  charCache = {};\n  styledCharsToStringCache = {};\n  constructor(A) {\n    let {\n      width: B,\n      height: Q,\n      ink2: I = false\n    } = A;\n    this.width = B;\n    this.height = Q;\n    this.ink2 = I;\n  }\n  write(A, B, Q, I) {\n    let {\n      transformers: G\n    } = I;\n    if (!Q) {\n      return;\n    }\n    this.operations.push({\n      type: \"write\",\n      x: A,\n      y: B,\n      text: Q,\n      transformers: G\n    });\n  }\n  clip(A) {\n    this.operations.push({\n      type: \"clip\",\n      clip: A\n    });\n  }\n  unclip() {\n    this.operations.push({\n      type: \"unclip\"\n    });\n  }\n  get() {\n    let A = [];\n    for (let G = 0; G < this.height; G++) {\n      let Z = [];\n      for (let Y = 0; Y < this.width; Y++) {\n        Z.push({\n          type: \"char\",\n          value: \" \",\n          fullWidth: false,\n          styles: []\n        });\n      }\n      A.push(Z);\n    }\n    let B = K0A(this.width, this.height);\n    let Q = [];\n    for (let G of this.operations) {\n      if (G.type === \"clip\") {\n        Q.push(G.clip);\n      }\n      if (G.type === \"unclip\") {\n        Q.pop();\n      }\n      if (G.type === \"write\") {\n        let {\n          text: Z,\n          transformers: Y\n        } = G;\n        let {\n          x: J,\n          y: X\n        } = G;\n        let W = Z.split(`\n`);\n        let F = Q.at(-1);\n        if (F) {\n          let V = typeof F?.x1 === \"number\" && typeof F?.x2 === \"number\";\n          let K = typeof F?.y1 === \"number\" && typeof F?.y2 === \"number\";\n          if (V) {\n            let D = W0A(Z);\n            if (J + D < F.x1 || J > F.x2) {\n              continue;\n            }\n          }\n          if (K) {\n            let D = W.length;\n            if (X + D < F.y1 || X > F.y2) {\n              continue;\n            }\n          }\n          if (V) {\n            W = W.map(D => {\n              let E = J < F.x1 ? F.x1 - J : 0;\n              let H = k7(D);\n              let w = J + H > F.x2 ? F.x2 - J : H;\n              return $i(D, E, w);\n            });\n            if (J < F.x1) {\n              J = F.x1;\n            }\n          }\n          if (K) {\n            let D = X < F.y1 ? F.y1 - X : 0;\n            let E = W.length;\n            let H = X + E > F.y2 ? F.y2 - X : E;\n            W = W.slice(D, H);\n            if (X < F.y1) {\n              X = F.y1;\n            }\n          }\n        }\n        let C = 0;\n        for (let [V, K] of W.entries()) {\n          let D = A[X + C];\n          if (!D) {\n            continue;\n          }\n          for (let w of Y) {\n            K = w(K, V);\n          }\n          if (!Object.prototype.hasOwnProperty.call(this.charCache, K)) {\n            this.charCache[K] = this.ink2 ? Tm9(JY1(WY1(K))) : JY1(WY1(K));\n          }\n          let E = this.charCache[K];\n          let H = J;\n          for (let w of E) {\n            D[H] = w;\n            let L = w.fullWidth || w.value.length > 1;\n            if (this.ink2) {\n              PS0(B, {\n                x: H,\n                y: X + C\n              }, {\n                char: w.value,\n                styles: w.styles,\n                width: L ? 1 : 0\n              });\n            }\n            if (L) {\n              D[H + 1] = {\n                type: \"char\",\n                value: \"\",\n                fullWidth: false,\n                styles: w.styles\n              };\n            }\n            if (L) {\n              H += 2;\n            } else {\n              H += 1;\n            }\n          }\n          C++;\n        }\n      }\n    }\n    return {\n      output: this.ink2 ? \"\" : A.map(G => {\n        let Z = G.filter(J => J !== undefined);\n        let Y = JSON.stringify(Z);\n        if (!Object.prototype.hasOwnProperty.call(this.styledCharsToStringCache, Y)) {\n          let J = NS0(Z).trimEnd();\n          this.styledCharsToStringCache[Y] = J;\n        }\n        return this.styledCharsToStringCache[Y];\n      }).join(`\n`),\n      height: A.length,\n      screen: B\n    };\n  }\n}\nfunction Rm9(A, B) {\n  if (A.length !== B.length) {\n    return false;\n  }\n  for (let Q = 0; Q < A.length; Q++) {\n    if (A[Q].code !== B[Q].code) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction Tm9(A) {\n  let B = [];\n  let Q = \"\";\n  let I = [];\n  function G() {\n    if (Q.length === 0) {\n      return;\n    }\n    for (let {\n      segment: Z\n    } of SegmentColorer.segment(Q)) {\n      B.push({\n        type: \"char\",\n        value: Z,\n        fullWidth: sV(Z) === 2,\n        styles: I\n      });\n    }\n    Q = \"\";\n  }\n  for (let Z of A) {\n    if (Q.length > 0 && !Rm9(Z.styles, I)) {\n      G();\n    }\n    Q += Z.value;\n    I = Z.styles;\n  }\n  G();\n  return B;\n}\nvar SegmentColorer;\nvar SS0 = T(() => {\n  eZ1();\n  sTA();\n  FY1();\n  F0A();\n  BJA();\n  rYA();\n  SegmentColorer = new Intl.Segmenter();\n});\nfunction VY1(A) {\n  return B => {\n    let {\n      theme: Q,\n      terminalWidth: I,\n      terminalRows: G,\n      isTTY: Z,\n      ink2: Y\n    } = B;\n    if (!A.yogaNode) {\n      return {\n        output: \"\",\n        outputHeight: 0,\n        staticOutput: \"\",\n        rows: G,\n        columns: I,\n        cursorVisible: true,\n        screen: K0A(I, 0),\n        viewport: {\n          width: I,\n          height: 0\n        },\n        cursor: {\n          x: 0,\n          y: 0,\n          visible: true\n        }\n      };\n    }\n    A.yogaNode.setWidth(I);\n    A.yogaNode.calculateLayout(undefined, undefined, Hi.LTR);\n    let J = new QJA({\n      width: Math.floor(A.yogaNode.getComputedWidth()),\n      height: Math.floor(A.yogaNode.getComputedHeight()),\n      ink2: Y\n    });\n    processAndDisplayNodes(A, J, {\n      skipStaticElements: true,\n      theme: Q\n    });\n    let X;\n    if (!Y && A.staticNode?.yogaNode) {\n      X = new QJA({\n        width: Math.floor(A.staticNode.yogaNode.getComputedWidth()),\n        height: Math.floor(A.staticNode.yogaNode.getComputedHeight()),\n        ink2: false\n      });\n      processAndDisplayNodes(A.staticNode, X, {\n        skipStaticElements: false,\n        theme: Q\n      });\n    }\n    let {\n      output: W,\n      height: F,\n      screen: C\n    } = J.get();\n    return {\n      output: W,\n      outputHeight: F,\n      staticOutput: X ? `${X.get().output}\n` : \"\",\n      rows: G,\n      columns: I,\n      cursorVisible: !Z || W === \"\",\n      screen: C,\n      viewport: {\n        width: I,\n        height: G\n      },\n      cursor: {\n        x: 0,\n        y: Math.max(0, C.height - 1),\n        visible: true\n      }\n    };\n  };\n}\nvar yS0 = T(() => {\n  ES0();\n  SS0();\n  wi();\n  BJA();\n});\nvar environmentVariableDetection;\nvar isNodeEnvironment;\nvar isBunEnvironment;\nvar runtimeEnvironmentDetected;\nvar isElectronEnvironment;\nvar isRunningInJsdomEnvironment;\nvar isWebWorkerContext;\nvar isDedicatedWorkerGlobalScope;\nvar platformGlobalContext;\nvar isServiceWorkerGlobalScope;\nvar getUserAgentPlatform;\nvar isMacOS;\nvar getOSInformation;\nvar isLinuxOS;\nvar isOperatingInMobileEnvironment;\nvar isAndroidPlatform;\nvar kS0 = T(() => {\n  environmentVariableDetection = globalThis.window?.document !== undefined;\n  isNodeEnvironment = globalThis.process?.versions?.node !== undefined;\n  isBunEnvironment = globalThis.process?.versions?.bun !== undefined;\n  runtimeEnvironmentDetected = globalThis.Deno?.version?.deno !== undefined;\n  isElectronEnvironment = globalThis.process?.versions?.electron !== undefined;\n  isRunningInJsdomEnvironment = globalThis.navigator?.userAgent?.includes(\"jsdom\") === true;\n  isWebWorkerContext = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\n  isDedicatedWorkerGlobalScope = typeof DedicatedWorkerGlobalScope !== \"undefined\" && globalThis instanceof DedicatedWorkerGlobalScope;\n  platformGlobalContext = typeof SharedWorkerGlobalScope !== \"undefined\" && globalThis instanceof SharedWorkerGlobalScope;\n  isServiceWorkerGlobalScope = typeof ServiceWorkerGlobalScope !== \"undefined\" && globalThis instanceof ServiceWorkerGlobalScope;\n  getUserAgentPlatform = globalThis.navigator?.userAgentData?.platform;\n  isMacOS = getUserAgentPlatform === \"macOS\" || globalThis.navigator?.platform === \"MacIntel\" || globalThis.navigator?.userAgent?.includes(\" Mac \") === true || globalThis.process?.platform === \"darwin\";\n  getOSInformation = getUserAgentPlatform === \"Windows\" || globalThis.navigator?.platform === \"Win32\" || globalThis.process?.platform === \"win32\";\n  isLinuxOS = getUserAgentPlatform === \"Linux\" || globalThis.navigator?.platform?.startsWith(\"Linux\") === true || globalThis.navigator?.userAgent?.includes(\" Linux \") === true || globalThis.process?.platform === \"linux\";\n  isOperatingInMobileEnvironment = getUserAgentPlatform === \"iOS\" || globalThis.navigator?.platform === \"MacIntel\" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);\n  isAndroidPlatform = getUserAgentPlatform === \"Android\" || globalThis.navigator?.platform === \"Android\" || globalThis.navigator?.userAgent?.includes(\" Android \") === true || globalThis.process?.platform === \"android\";\n});\nvar terminalCommands = {};\nM$(terminalCommands, {\n  scrollUp: () => handleChildHostContext,\n  scrollDown: () => connectToDevTools,\n  link: () => em9,\n  image: () => Ad9,\n  iTerm: () => getAndSetReactDevTools,\n  exitAlternativeScreen: () => exitAlternativeScreenAction,\n  eraseUp: () => eraseCharacters,\n  eraseStartLine: () => eraseStartLine,\n  eraseScreen: () => clearScreen,\n  eraseLines: () => mm9,\n  eraseLine: () => clearTargetNode,\n  eraseEndLine: () => clearLine,\n  eraseDown: () => removeChildFromContainer,\n  enterAlternativeScreen: () => enterAlternativeScreenCommand,\n  cursorUp: () => xS0,\n  cursorTo: () => Sm9,\n  cursorShow: () => cursorShow,\n  cursorSavePosition: () => setCursorToPosition,\n  cursorRestorePosition: () => commitUpdate,\n  cursorPrevLine: () => cursorPreviousLine,\n  cursorNextLine: () => cursorMoveToNextLine,\n  cursorMove: () => ym9,\n  cursorLeft: () => cursorLeftPosition,\n  cursorHide: () => hideCursor,\n  cursorGetPosition: () => getCursorPosition,\n  cursorForward: () => _m9,\n  cursorDown: () => km9,\n  cursorBackward: () => xm9,\n  clearTerminal: () => clearTerminalDisplay,\n  clearScreen: () => clearTerminal,\n  beep: () => processScrollEvents\n});\nimport processModule from \"node:process\";\nvar escapeSequence = \"\u001b[\";\nvar decodingString = \"\u001b]\";\nvar alert = \"\u0007\";\nvar handleDevToolsConnection = \";\";\nvar compositeColorTransformFunction;\nvar formatTextCursorPosition;\nvar updateVisualization;\nvar Sm9 = (A, B) => {\n  if (typeof A !== \"number\") {\n    throw TypeError(\"The `x` argument is required\");\n  }\n  if (typeof B !== \"number\") {\n    return escapeSequence + (A + 1) + \"G\";\n  }\n  return escapeSequence + (B + 1) + handleDevToolsConnection + (A + 1) + \"H\";\n};\nvar ym9 = (A, B) => {\n  if (typeof A !== \"number\") {\n    throw TypeError(\"The `x` argument is required\");\n  }\n  let Q = \"\";\n  if (A < 0) {\n    Q += escapeSequence + -A + \"D\";\n  } else if (A > 0) {\n    Q += escapeSequence + A + \"C\";\n  }\n  if (B < 0) {\n    Q += escapeSequence + -B + \"A\";\n  } else if (B > 0) {\n    Q += escapeSequence + B + \"B\";\n  }\n  return Q;\n};\nvar xS0 = (A = 1) => escapeSequence + A + \"A\";\nvar km9 = (A = 1) => escapeSequence + A + \"B\";\nvar _m9 = (A = 1) => escapeSequence + A + \"C\";\nvar xm9 = (A = 1) => escapeSequence + A + \"D\";\nvar cursorLeftPosition;\nvar setCursorToPosition;\nvar commitUpdate;\nvar getCursorPosition;\nvar cursorMoveToNextLine;\nvar cursorPreviousLine;\nvar hideCursor;\nvar cursorShow;\nvar mm9 = A => {\n  let B = \"\";\n  for (let Q = 0; Q < A; Q++) {\n    B += clearTargetNode + (Q < A - 1 ? xS0() : \"\");\n  }\n  if (A) {\n    B += cursorLeftPosition;\n  }\n  return B;\n};\nvar clearLine;\nvar eraseStartLine;\nvar clearTargetNode;\nvar removeChildFromContainer;\nvar eraseCharacters;\nvar clearScreen;\nvar handleChildHostContext;\nvar connectToDevTools;\nvar clearTerminal = \"\u001bc\";\nvar clearTerminalDisplay;\nvar enterAlternativeScreenCommand;\nvar exitAlternativeScreenAction;\nvar processScrollEvents;\nvar em9 = (A, B) => [decodingString, \"8\", handleDevToolsConnection, handleDevToolsConnection, B, alert, A, decodingString, \"8\", handleDevToolsConnection, handleDevToolsConnection, alert].join(\"\");\nvar Ad9 = (A, B = {}) => {\n  let Q = `${decodingString}1337;File=inline=1`;\n  if (B.width) {\n    Q += `;width=${B.width}`;\n  }\n  if (B.height) {\n    Q += `;height=${B.height}`;\n  }\n  if (B.preserveAspectRatio === false) {\n    Q += \";preserveAspectRatio=0\";\n  }\n  return Q + \":\" + Buffer.from(A).toString(\"base64\") + alert;\n};\nvar getAndSetReactDevTools;\nvar HY1 = T(() => {\n  kS0();\n  compositeColorTransformFunction = !environmentVariableDetection && processModule.env.TERM_PROGRAM === \"Apple_Terminal\";\n  formatTextCursorPosition = !environmentVariableDetection && processModule.platform === \"win32\";\n  if (environmentVariableDetection) {\n    updateVisualization = () => {\n      throw Error(\"`process.cwd()` only works in Node.js, not the browser.\");\n    };\n  } else {\n    updateVisualization = processModule.cwd;\n  }\n  cursorLeftPosition = escapeSequence + \"G\";\n  if (compositeColorTransformFunction) {\n    setCursorToPosition = \"\u001b7\";\n  } else {\n    setCursorToPosition = escapeSequence + \"s\";\n  }\n  if (compositeColorTransformFunction) {\n    commitUpdate = \"\u001b8\";\n  } else {\n    commitUpdate = escapeSequence + \"u\";\n  }\n  getCursorPosition = escapeSequence + \"6n\";\n  cursorMoveToNextLine = escapeSequence + \"E\";\n  cursorPreviousLine = escapeSequence + \"F\";\n  hideCursor = escapeSequence + \"?25l\";\n  cursorShow = escapeSequence + \"?25h\";\n  clearLine = escapeSequence + \"K\";\n  eraseStartLine = escapeSequence + \"1K\";\n  clearTargetNode = escapeSequence + \"2K\";\n  removeChildFromContainer = escapeSequence + \"J\";\n  eraseCharacters = escapeSequence + \"1J\";\n  clearScreen = escapeSequence + \"2J\";\n  handleChildHostContext = escapeSequence + \"S\";\n  connectToDevTools = escapeSequence + \"T\";\n  if (formatTextCursorPosition) {\n    clearTerminalDisplay = `${clearScreen}${escapeSequence}0f`;\n  } else {\n    clearTerminalDisplay = `${clearScreen}${escapeSequence}3J${escapeSequence}H`;\n  }\n  enterAlternativeScreenCommand = escapeSequence + \"?1049h\";\n  exitAlternativeScreenAction = escapeSequence + \"?1049l\";\n  processScrollEvents = alert;\n  getAndSetReactDevTools = {\n    setCwd: (A = updateVisualization()) => `${decodingString}50;CurrentDir=${A}${alert}`,\n    annotation(A, B = {}) {\n      let Q = `${decodingString}1337;`;\n      let I = B.x !== undefined;\n      let G = B.y !== undefined;\n      if ((I || G) && (!I || !G || B.length === undefined)) {\n        throw Error(\"`x`, `y` and `length` must be defined when `x` or `y` is defined\");\n      }\n      A = A.replaceAll(\"|\", \"\");\n      if (B.isHidden) {\n        Q += \"AddHiddenAnnotation=\";\n      } else {\n        Q += \"AddAnnotation=\";\n      }\n      if (B.length > 0) {\n        Q += (I ? [A, B.length, B.x, B.y] : [B.length, A]).join(\"|\");\n      } else {\n        Q += A;\n      }\n      return Q + alert;\n    }\n  };\n});\nvar YJA = T(() => {\n  HY1();\n  HY1();\n});\nfunction HPA(A, B) {\n  return {\n    output: \"\",\n    outputHeight: 0,\n    staticOutput: \"\",\n    rows: A,\n    columns: B,\n    cursorVisible: true,\n    screen: K0A(0, 0),\n    viewport: {\n      width: 0,\n      height: 0\n    },\n    cursor: {\n      x: 0,\n      y: 0,\n      visible: true\n    }\n  };\n}\nfunction fS0(A, B) {\n  let Q = B.rows !== A.rows || B.columns !== A.columns;\n  let I = B.outputHeight >= B.rows;\n  let G = A.outputHeight >= A.rows;\n  return Q || I || G;\n}\nvar zY1 = T(() => {\n  BJA();\n});\nclass UY1 {\n  options;\n  state;\n  constructor(A, B) {\n    this.options = A;\n    this.state = {\n      fullStaticOutput: \"\",\n      previousOutput: \"\",\n      prevFrame: B\n    };\n  }\n  render(A) {\n    let B = this.options.ink2 ? this.render_v2(this.state.prevFrame, A) : this.render_v1(this.state.prevFrame, A);\n    this.state.prevFrame = A;\n    return B;\n  }\n  render_v1(A, B) {\n    if (this.options.debug) {\n      return this.getRenderOpsDebug_DEPRECATED(B);\n    }\n    if (!this.options.isTTY) {\n      return [{\n        type: \"stdout\",\n        content: B.staticOutput,\n        scrollback: true\n      }];\n    }\n    if (fS0(A, B)) {\n      return this.getRenderOpsForAllOutput_CAUSES_FLICKER(B);\n    }\n    if ((!B.staticOutput || B.staticOutput === `\n`) && B.output === A.output) {\n      return [];\n    }\n    return [...this.getRenderOpsForClearAndRenderStaticOutput(A, B), ...this.renderEfficiently(A, B)];\n  }\n  renderPreviousOutput_DEPRECATED() {\n    if (!this.options.isTTY) {\n      return [{\n        type: \"stdout\",\n        content: this.state.prevFrame.output,\n        scrollback: true\n      }, {\n        type: \"stdout\",\n        content: `\n`,\n        scrollback: true\n      }];\n    } else if (!this.options.debug) {\n      return this.getRenderOpsForDone(this.state.prevFrame);\n    }\n    return [];\n  }\n  reset() {\n    this.state.prevFrame = HPA(this.state.prevFrame.rows, this.state.prevFrame.columns);\n    this.state.previousOutput = \"\";\n  }\n  renderEfficiently(A, B) {\n    let Q = `${B.output}\n`;\n    if (Q === this.state.previousOutput) {\n      return [];\n    }\n    let I = this.state.previousOutput ? oYA(this.state.previousOutput, A.columns) : 0;\n    this.state.previousOutput = Q;\n    let G = [];\n    if (!B.cursorVisible && A.cursorVisible) {\n      G.push({\n        type: \"cursorHide\"\n      });\n    } else if (B.cursorVisible && !A.cursorVisible) {\n      G.push({\n        type: \"cursorShow\"\n      });\n    }\n    if (I > 0) {\n      G.push({\n        type: \"clear\",\n        count: I\n      });\n    }\n    G.push({\n      type: \"stdout\",\n      content: B.output,\n      scrollback: false\n    });\n    G.push({\n      type: \"stdout\",\n      content: `\n`,\n      scrollback: false\n    });\n    return G;\n  }\n  getRenderOpsDebug_DEPRECATED(A) {\n    if (A.staticOutput && A.staticOutput !== `\n`) {\n      this.state.fullStaticOutput += A.staticOutput;\n    }\n    return [{\n      type: \"stdout\",\n      content: this.state.fullStaticOutput,\n      scrollback: true\n    }, {\n      type: \"stdout\",\n      content: A.output,\n      scrollback: true\n    }];\n  }\n  getRenderOpsForAllOutput_CAUSES_FLICKER(A) {\n    if (A.staticOutput && A.staticOutput !== `\n`) {\n      this.state.fullStaticOutput += A.staticOutput;\n    }\n    this.state.previousOutput = `${A.output}\n`;\n    let Q = [];\n    Q.push({\n      type: \"clearTerminal\"\n    });\n    Q.push({\n      type: \"stdout\",\n      content: this.state.fullStaticOutput,\n      scrollback: true\n    });\n    Q.push({\n      type: \"stdout\",\n      content: A.output,\n      scrollback: true\n    });\n    Q.push({\n      type: \"stdout\",\n      content: `\n`,\n      scrollback: true\n    });\n    return Q;\n  }\n  getRenderOpsForClearAndRenderStaticOutput(A, B) {\n    if (!B.staticOutput || B.staticOutput === `\n`) {\n      return [];\n    }\n    this.state.fullStaticOutput += B.staticOutput;\n    let I = this.state.previousOutput ? oYA(this.state.previousOutput, A.columns) : 0;\n    this.state.previousOutput = \"\";\n    let G = [];\n    if (I > 0) {\n      G.push({\n        type: \"clear\",\n        count: I\n      });\n    }\n    G.push({\n      type: \"stdout\",\n      content: B.staticOutput,\n      scrollback: true\n    });\n    return G;\n  }\n  getRenderOpsForDone(A) {\n    this.state.previousOutput = \"\";\n    if (!A.cursorVisible) {\n      return [{\n        type: \"cursorShow\"\n      }];\n    }\n    return [];\n  }\n  render_v2(A, B) {\n    if (B.screen.height === 0 || B.screen.width === 0) {\n      return [];\n    }\n    if (B.viewport.height < A.viewport.height || A.viewport.width !== 0 && B.viewport.width !== A.viewport.width) {\n      return hS0(B);\n    }\n    let Q = new mS0(A.cursor, B.viewport.width);\n    let I = Math.max(B.screen.height, 1) - Math.max(A.screen.height, 1);\n    if (I < 0) {\n      Q.txn(Y => [{\n        type: \"clear\",\n        count: -I\n      }, {\n        dx: -Y.x,\n        dy: I + 1\n      }]);\n      Q.txn(() => [{\n        type: \"cursorMove\",\n        x: 0,\n        y: -1\n      }, {\n        dx: 0,\n        dy: -1\n      }]);\n    } else if (I > 0) {\n      for (let Y = 0; Y < I; Y += 1) {\n        Q.txn(J => [{\n          type: \"stdout\",\n          content: `\n`,\n          scrollback: false\n        }, {\n          dx: -J.x,\n          dy: 1\n        }]);\n      }\n    }\n    let G = Math.max(A.screen.height, B.screen.height) - B.viewport.height;\n    let Z = [];\n    for (let [Y, J, X] of jS0(A.screen, B.screen)) {\n      if (X && (X.width === 2 || X.width === 3)) {\n        continue;\n      }\n      if (J && (J.width === 2 || J.width === 3) && !X) {\n        continue;\n      }\n      if (Y.y < G) {\n        return hS0(B);\n      }\n      uS0(Q, Y);\n      if (X && J) {\n        Z = gS0(Q, X, Z);\n      } else if (X) {\n        Z = gS0(Q, X, Z);\n      } else if (J) {\n        Q.txn(() => [{\n          type: \"del\"\n        }, {\n          dx: 0,\n          dy: 0\n        }]);\n      }\n    }\n    uS0(Q, B.cursor);\n    if (Z.length > 0) {\n      let Y = jh(Z, []);\n      if (Y.length > 0) {\n        Q.diff.push({\n          type: \"stdout\",\n          content: _k(Y),\n          scrollback: false\n        });\n      }\n    }\n    return Q.diff;\n  }\n}\nfunction hS0(A) {\n  let B = [{\n    type: \"clearTerminal\"\n  }];\n  let Q = [];\n  for (let I = 0; I < A.screen.height; I += 1) {\n    for (let G = 0; G < A.screen.width; G += 1) {\n      let Z = DPA(A.screen, {\n        x: G,\n        y: I\n      });\n      if (!Z) {\n        continue;\n      }\n      if (Z.width === 2 || Z.width === 3) {\n        continue;\n      }\n      let Y = jh(Q, Z.styles);\n      let J = Y.length > 0 ? _k(Y) : \"\";\n      Q = Z.styles;\n      B.push({\n        type: \"stdout\",\n        content: J + Z.char,\n        scrollback: false\n      });\n    }\n    B.push({\n      type: \"stdout\",\n      content: `\n`,\n      scrollback: false\n    });\n  }\n  B.push({\n    type: \"cursorMove\",\n    x: 0,\n    y: -1\n  });\n  return B;\n}\nfunction gS0(A, B, Q) {\n  let I = jh(Q, B.styles);\n  let G = I.length > 0 ? _k(I) : \"\";\n  A.txn(Z => {\n    let Y = B.width === 1 ? 2 : 1;\n    let J = Z.x >= A.viewportWidth ? Y - Z.x : Y;\n    let X = Z.x >= A.viewportWidth ? 1 : 0;\n    return [{\n      type: \"stdout\",\n      content: G + B.char,\n      scrollback: false\n    }, {\n      dx: J,\n      dy: X\n    }];\n  });\n  return B.styles;\n}\nfunction uS0(A, B) {\n  A.txn(Q => {\n    if (Q.x < A.viewportWidth) {\n      return [{\n        type: \"stdout\",\n        content: \"\",\n        scrollback: false\n      }, {\n        dx: 0,\n        dy: 0\n      }];\n    }\n    return [{\n      type: \"stdout\",\n      content: \" \\b\",\n      scrollback: false\n    }, {\n      dx: -Q.x,\n      dy: 1\n    }];\n  });\n  A.txn(Q => {\n    let I = B.x - Q.x;\n    let G = B.y - Q.y;\n    if (G !== 0) {\n      return [{\n        type: \"stdout\",\n        content: \"\\r\" + terminalCommands.cursorMove(B.x, G),\n        scrollback: false\n      }, {\n        dx: I,\n        dy: G\n      }];\n    }\n    return [{\n      type: \"cursorMove\",\n      x: I,\n      y: G\n    }, {\n      dx: I,\n      dy: G\n    }];\n  });\n}\nclass mS0 {\n  viewportWidth;\n  cursor;\n  diff = [];\n  constructor(A, B) {\n    this.viewportWidth = B;\n    this.cursor = {\n      ...A\n    };\n  }\n  txn(A) {\n    let [B, Q] = A(this.cursor);\n    this.diff.push(B);\n    this.cursor = {\n      x: this.cursor.x + Q.dx,\n      y: this.cursor.y + Q.dy\n    };\n  }\n}\nvar dS0 = T(() => {\n  YJA();\n  kZ1();\n  zY1();\n  BJA();\n  FY1();\n});\nvar updateDefaultRenderer;\nvar colorManagement;\nvar zPA = T(() => {\n  updateDefaultRenderer = new Map();\n  colorManagement = updateDefaultRenderer;\n});\nclass E0A {\n  _didStopImmediatePropagation = false;\n  didStopImmediatePropagation() {\n    return this._didStopImmediatePropagation;\n  }\n  stopImmediatePropagation() {\n    this._didStopImmediatePropagation = true;\n  }\n}\nimport { EventEmitter as handleComponentInitialization } from \"events\";\nvar initializeDevTools;\nvar UPA = T(() => {\n  initializeDevTools = class Sh extends handleComponentInitialization {\n    emit(A, ...B) {\n      if (A === \"error\") {\n        return super.emit(A, ...B);\n      }\n      let Q = this.rawListeners(A);\n      if (Q.length === 0) {\n        return false;\n      }\n      let I = B[0] instanceof E0A ? B[0] : null;\n      for (let G of Q) {\n        G.apply(this, B);\n        if (I?.didStopImmediatePropagation()) {\n          break;\n        }\n      }\n      return true;\n    }\n  };\n});\nvar processData;\nvar processState;\nvar _initializeDevelopmentTools;\nvar $Y1 = T(() => {\n  processData = IA(KA(), 1);\n  processState = processData.createContext({\n    exit() {}\n  });\n  processState.displayName = \"InternalAppContext\";\n  _initializeDevelopmentTools = processState;\n});\nvar __initializeDevelopmentTools;\nvar rendererSetup;\nvar initializeReactDevTools;\nvar qY1 = T(() => {\n  UPA();\n  __initializeDevelopmentTools = IA(KA(), 1);\n  rendererSetup = __initializeDevelopmentTools.createContext({\n    stdin: process.stdin,\n    internal_eventEmitter: new initializeDevTools(),\n    setRawMode() {},\n    isRawModeSupported: false,\n    internal_exitOnCtrlC: true\n  });\n  rendererSetup.displayName = \"InternalStdinContext\";\n  initializeReactDevTools = rendererSetup;\n});\nvar ___initializeDevelopmentTools;\nvar ____initializeDevelopmentTools;\nvar _processAndDisplayNodes;\nvar qPA = T(() => {\n  ___initializeDevelopmentTools = IA(KA(), 1);\n  ____initializeDevelopmentTools = ___initializeDevelopmentTools.createContext({\n    activeId: undefined,\n    add() {},\n    remove() {},\n    activate() {},\n    deactivate() {},\n    enableFocus() {},\n    disableFocus() {},\n    focusNext() {},\n    focusPrevious() {},\n    focus() {}\n  });\n  ____initializeDevelopmentTools.displayName = \"InternalFocusContext\";\n  _processAndDisplayNodes = ____initializeDevelopmentTools;\n});\nvar _initializeDevTools = z((LkI, sS0) => {\n  var Gd9 = /[|\\\\{}()[\\]^$+*?.-]/g;\n  sS0.exports = A => {\n    if (typeof A !== \"string\") {\n      throw TypeError(\"Expected a string\");\n    }\n    return A.replace(Gd9, \"\\\\$&\");\n  };\n});\nvar Ay0 = z((createErrorStackCleaner, createStackTraceCleaner) => {\n  var Zd9 = _initializeDevTools();\n  var currentWorkingDirectory = typeof process === \"object\" && process && typeof process.cwd === \"function\" ? process.cwd() : \".\";\n  var nodeInternalPatterns = [].concat(EA(\"module\").builtinModules, \"bootstrap_node\", \"node\").map(A => new RegExp(`(?:\\\\((?:node:)?${A}(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?${A}(?:\\\\.js)?:\\\\d+:\\\\d+$)`));\n  nodeInternalPatterns.push(/\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/, /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/);\n  class NY1 {\n    constructor(A) {\n      A = {\n        ignoredPackages: [],\n        ...A\n      };\n      if (\"internals\" in A === false) {\n        A.internals = NY1.nodeInternals();\n      }\n      if (\"cwd\" in A === false) {\n        A.cwd = currentWorkingDirectory;\n      }\n      this._cwd = A.cwd.replace(/\\\\/g, \"/\");\n      this._internals = [].concat(A.internals, Jd9(A.ignoredPackages));\n      this._wrapCallSite = A.wrapCallSite || false;\n    }\n    static nodeInternals() {\n      return [...nodeInternalPatterns];\n    }\n    clean(A, B = 0) {\n      B = \" \".repeat(B);\n      if (!Array.isArray(A)) {\n        A = A.split(`\n`);\n      }\n      if (!/^\\s*at /.test(A[0]) && /^\\s*at /.test(A[1])) {\n        A = A.slice(1);\n      }\n      let Q = false;\n      let I = null;\n      let G = [];\n      A.forEach(Z => {\n        Z = Z.replace(/\\\\/g, \"/\");\n        if (this._internals.some(J => J.test(Z))) {\n          return;\n        }\n        let Y = /^\\s*at /.test(Z);\n        if (Q) {\n          Z = Z.trimEnd().replace(/^(\\s+)at /, \"$1\");\n        } else {\n          Z = Z.trim();\n          if (Y) {\n            Z = Z.slice(3);\n          }\n        }\n        Z = Z.replace(`${this._cwd}/`, \"\");\n        if (Z) {\n          if (Y) {\n            if (I) {\n              G.push(I);\n              I = null;\n            }\n            G.push(Z);\n          } else {\n            Q = true;\n            I = Z;\n          }\n        }\n      });\n      return G.map(Z => `${B}${Z}\n`).join(\"\");\n    }\n    captureString(A, B = this.captureString) {\n      if (typeof A === \"function\") {\n        B = A;\n        A = Infinity;\n      }\n      let {\n        stackTraceLimit: Q\n      } = Error;\n      if (A) {\n        Error.stackTraceLimit = A;\n      }\n      let I = {};\n      Error.captureStackTrace(I, B);\n      let {\n        stack: G\n      } = I;\n      Error.stackTraceLimit = Q;\n      return this.clean(G);\n    }\n    capture(A, B = this.capture) {\n      if (typeof A === \"function\") {\n        B = A;\n        A = Infinity;\n      }\n      let {\n        prepareStackTrace: Q,\n        stackTraceLimit: I\n      } = Error;\n      Error.prepareStackTrace = (Y, J) => {\n        if (this._wrapCallSite) {\n          return J.map(this._wrapCallSite);\n        }\n        return J;\n      };\n      if (A) {\n        Error.stackTraceLimit = A;\n      }\n      let G = {};\n      Error.captureStackTrace(G, B);\n      let {\n        stack: Z\n      } = G;\n      Object.assign(Error, {\n        prepareStackTrace: Q,\n        stackTraceLimit: I\n      });\n      return Z;\n    }\n    at(A = this.at) {\n      let [B] = this.capture(1, A);\n      if (!B) {\n        return {};\n      }\n      let Q = {\n        line: B.getLineNumber(),\n        column: B.getColumnNumber()\n      };\n      oS0(Q, B.getFileName(), this._cwd);\n      if (B.isConstructor()) {\n        Object.defineProperty(Q, \"constructor\", {\n          value: true,\n          configurable: true\n        });\n      }\n      if (B.isEval()) {\n        Q.evalOrigin = B.getEvalOrigin();\n      }\n      if (B.isNative()) {\n        Q.native = true;\n      }\n      let I;\n      try {\n        I = B.getTypeName();\n      } catch (Y) {}\n      if (I && I !== \"Object\" && I !== \"[object Object]\") {\n        Q.type = I;\n      }\n      let G = B.getFunctionName();\n      if (G) {\n        Q.function = G;\n      }\n      let Z = B.getMethodName();\n      if (Z && G !== Z) {\n        Q.method = Z;\n      }\n      return Q;\n    }\n    parseLine(A) {\n      let B = A && A.match(stackTraceLinePattern);\n      if (!B) {\n        return null;\n      }\n      let Q = B[1] === \"new\";\n      let I = B[2];\n      let G = B[3];\n      let Z = B[4];\n      let Y = Number(B[5]);\n      let J = Number(B[6]);\n      let X = B[7];\n      let W = B[8];\n      let F = B[9];\n      let C = B[10] === \"native\";\n      let V = B[11] === \")\";\n      let K;\n      let D = {};\n      if (W) {\n        D.line = Number(W);\n      }\n      if (F) {\n        D.column = Number(F);\n      }\n      if (V && X) {\n        let E = 0;\n        for (let H = X.length - 1; H > 0; H--) {\n          if (X.charAt(H) === \")\") {\n            E++;\n          } else if (X.charAt(H) === \"(\" && X.charAt(H - 1) === \" \") {\n            E--;\n            if (E === -1 && X.charAt(H - 1) === \" \") {\n              let w = X.slice(0, H - 1);\n              X = X.slice(H + 1);\n              I += ` (${w}`;\n              break;\n            }\n          }\n        }\n      }\n      if (I) {\n        let E = I.match(functionNamePattern);\n        if (E) {\n          I = E[1];\n          K = E[2];\n        }\n      }\n      oS0(D, X, this._cwd);\n      if (Q) {\n        Object.defineProperty(D, \"constructor\", {\n          value: true,\n          configurable: true\n        });\n      }\n      if (G) {\n        D.evalOrigin = G;\n        D.evalLine = Y;\n        D.evalColumn = J;\n        D.evalFile = Z && Z.replace(/\\\\/g, \"/\");\n      }\n      if (C) {\n        D.native = true;\n      }\n      if (I) {\n        D.function = I;\n      }\n      if (K && I !== K) {\n        D.method = K;\n      }\n      return D;\n    }\n  }\n  function oS0(A, B, Q) {\n    if (B) {\n      B = B.replace(/\\\\/g, \"/\");\n      if (B.startsWith(`${Q}/`)) {\n        B = B.slice(Q.length + 1);\n      }\n      A.file = B;\n    }\n  }\n  function Jd9(A) {\n    if (A.length === 0) {\n      return [];\n    }\n    let B = A.map(Q => Zd9(Q));\n    return new RegExp(`[/\\\\\\\\]node_modules[/\\\\\\\\](?:${B.join(\"|\")})[/\\\\\\\\][^:]+:\\\\d+:\\\\d+`);\n  }\n  var stackTraceLinePattern = new RegExp(\"^(?:\\\\s*at )?(?:(new) )?(?:(.*?) \\\\()?(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?(?:(.+?):(\\\\d+):(\\\\d+)|(native))(\\\\)?)$\");\n  var functionNamePattern = /^(.*?) \\[as (.*?)\\]$/;\n  createStackTraceCleaner.exports = NY1;\n});\nvar initializeDevToolsConnection = (A, B = 2) => {\n  return A.replace(/^\\t+/gm, Q => \" \".repeat(Q.length * B));\n};\nvar __initializeDevTools;\nvar Qy0 = T(() => {\n  __initializeDevTools = initializeDevToolsConnection;\n});\nvar _initializeDevToolsConnection = (A, B) => {\n  let Q = [];\n  let I = A - B;\n  let G = A + B;\n  for (let Z = I; Z <= G; Z++) {\n    Q.push(Z);\n  }\n  return Q;\n};\nvar Vd9 = (A, B, Q = {}) => {\n  if (typeof A !== \"string\") {\n    throw TypeError(\"Source code is missing.\");\n  }\n  if (!B || B < 1) {\n    throw TypeError(\"Line number must start from `1`.\");\n  }\n  let G = __initializeDevTools(A).split(/\\r?\\n/);\n  if (B > G.length) {\n    return;\n  }\n  return _initializeDevToolsConnection(B, Q.around ?? 3).filter(Z => G[Z - 1] !== undefined).map(Z => ({\n    line: Z,\n    value: G[Z - 1]\n  }));\n};\nvar initializeDebugTools;\nvar Gy0 = T(() => {\n  Qy0();\n  initializeDebugTools = Vd9;\n});\nvar ___initializeDevTools;\nvar __initializeDevToolsConnection;\nvar __processAndDisplayNodes;\nvar LPA = T(() => {\n  initializeAppState();\n  ___initializeDevTools = IA(KA(), 1);\n  __initializeDevToolsConnection = ___initializeDevTools.forwardRef(({\n    children: A,\n    ...B\n  }, Q) => {\n    sY(B.margin, \"margin\");\n    sY(B.marginX, \"marginX\");\n    sY(B.marginY, \"marginY\");\n    sY(B.marginTop, \"marginTop\");\n    sY(B.marginBottom, \"marginBottom\");\n    sY(B.marginLeft, \"marginLeft\");\n    sY(B.marginRight, \"marginRight\");\n    sY(B.padding, \"padding\");\n    sY(B.paddingX, \"paddingX\");\n    sY(B.paddingY, \"paddingY\");\n    sY(B.paddingTop, \"paddingTop\");\n    sY(B.paddingBottom, \"paddingBottom\");\n    sY(B.paddingLeft, \"paddingLeft\");\n    sY(B.paddingRight, \"paddingRight\");\n    sY(B.gap, \"gap\");\n    sY(B.columnGap, \"columnGap\");\n    sY(B.rowGap, \"rowGap\");\n    return ___initializeDevTools.default.createElement(\"ink-box\", {\n      ref: Q,\n      style: {\n        ...B,\n        overflowX: B.overflowX ?? B.overflow ?? \"visible\",\n        overflowY: B.overflowY ?? B.overflow ?? \"visible\"\n      }\n    }, A);\n  });\n  __initializeDevToolsConnection.displayName = \"Box\";\n  __initializeDevToolsConnection.defaultProps = {\n    flexWrap: \"nowrap\",\n    flexDirection: \"row\",\n    flexGrow: 0,\n    flexShrink: 1\n  };\n  __processAndDisplayNodes = __initializeDevToolsConnection;\n});\nfunction RY1({\n  children: A,\n  initialState: B\n}) {\n  let [Q, I] = _initializeReactDevTools.useState(B);\n  let [G, Z] = _initializeReactDevTools.useState(null);\n  let Y = ___initializeDevToolsConnection.useMemo(() => ({\n    theme: Q,\n    setTheme: J => {\n      n0({\n        ...L1(),\n        theme: J\n      });\n      I(J);\n      MY1(J);\n      Z(null);\n    },\n    setPreviewTheme: J => {\n      Z(J);\n      MY1(J);\n    },\n    savePreview: () => {\n      if (G !== null) {\n        n0({\n          ...L1(),\n          theme: G\n        });\n        I(G);\n        Z(null);\n      }\n    },\n    currentTheme: G ?? Q\n  }), [Q, G]);\n  return ___initializeDevToolsConnection.default.createElement(____initializeDevToolsConnection.Provider, {\n    value: Y\n  }, A);\n}\nfunction HQ() {\n  let {\n    currentTheme: A,\n    setTheme: B\n  } = _initializeReactDevTools.useContext(____initializeDevToolsConnection);\n  return [A, B];\n}\nfunction TY1() {\n  let {\n    setPreviewTheme: A,\n    savePreview: B\n  } = _initializeReactDevTools.useContext(____initializeDevToolsConnection);\n  return {\n    setPreviewTheme: A,\n    savePreview: B\n  };\n}\nvar ___initializeDevToolsConnection;\nvar _initializeReactDevTools;\nvar ____initializeDevToolsConnection;\nvar OPA = T(() => {\n  kB();\n  PY1();\n  ___initializeDevToolsConnection = IA(KA(), 1);\n  _initializeReactDevTools = IA(KA(), 1);\n  ____initializeDevToolsConnection = _initializeReactDevTools.createContext({\n    theme: null,\n    setTheme: A => A,\n    setPreviewTheme: A => A,\n    savePreview: () => {},\n    currentTheme: null\n  });\n});\nfunction U({\n  color: A,\n  backgroundColor: B,\n  dimColor: Q = false,\n  bold: I = false,\n  italic: G = false,\n  underline: Z = false,\n  strikethrough: Y = false,\n  inverse: J = false,\n  wrap: X = \"wrap\",\n  children: W\n}) {\n  let [F] = HQ();\n  if (W === undefined || W === null) {\n    return null;\n  }\n  return _____initializeDevToolsConnection.default.createElement(\"ink-text\", {\n    style: {\n      flexGrow: 0,\n      flexShrink: 1,\n      flexDirection: \"row\",\n      textWrap: X\n    },\n    internal_transform: V => {\n      if (Q) {\n        V = OB(\"inactive\", F)(V);\n      }\n      if (A) {\n        V = OB(A, F)(V);\n      }\n      if (B) {\n        V = OB(B, F, \"background\")(V);\n      }\n      if (I) {\n        V = iA.bold(V);\n      }\n      if (G) {\n        V = iA.italic(V);\n      }\n      if (Z) {\n        V = iA.underline(V);\n      }\n      if (Y) {\n        V = iA.strikethrough(V);\n      }\n      if (J) {\n        V = iA.inverse(V);\n      }\n      return V;\n    }\n  }, W);\n}\nvar _____initializeDevToolsConnection;\nvar jY1 = T(() => {\n  f2();\n  XPA();\n  OPA();\n  _____initializeDevToolsConnection = IA(KA(), 1);\n});\nimport * as DevToolsManager from \"node:fs\";\nimport { cwd as ______initializeDevToolsConnection } from \"node:process\";\nfunction yY1({\n  error: A\n}) {\n  let B = A.stack ? A.stack.split(`\n`).slice(1) : undefined;\n  let Q = B ? ________initializeDevToolsConnection.parseLine(B[0]) : undefined;\n  let I = Yy0(Q?.file);\n  let G;\n  let Z = 0;\n  if (I && Q?.line && DevToolsManager.existsSync(I)) {\n    let Y = DevToolsManager.readFileSync(I, \"utf8\");\n    G = initializeDebugTools(Y, Q.line);\n    if (G) {\n      for (let {\n        line: J\n      } of G) {\n        Z = Math.max(Z, String(J).length);\n      }\n    }\n  }\n  return getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    flexDirection: \"column\",\n    padding: 1\n  }, getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, null, getDifferencesBetweenObjects.default.createElement(U, {\n    backgroundColor: \"error\",\n    color: \"text\"\n  }, \" \", \"ERROR\", \" \"), getDifferencesBetweenObjects.default.createElement(U, null, \" \", A.message)), Q && I && getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    marginTop: 1\n  }, getDifferencesBetweenObjects.default.createElement(U, {\n    dimColor: true\n  }, I, \":\", Q.line, \":\", Q.column)), Q && G && getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    marginTop: 1,\n    flexDirection: \"column\"\n  }, G.map(({\n    line: Y,\n    value: J\n  }) => getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    key: Y\n  }, getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    width: Z + 1\n  }, getDifferencesBetweenObjects.default.createElement(U, {\n    dimColor: Y !== Q.line,\n    backgroundColor: Y === Q.line ? \"error\" : undefined,\n    color: Y === Q.line ? \"text\" : undefined\n  }, String(Y).padStart(Z, \" \"), \":\")), getDifferencesBetweenObjects.default.createElement(U, {\n    key: Y,\n    backgroundColor: Y === Q.line ? \"error\" : undefined,\n    color: Y === Q.line ? \"text\" : undefined\n  }, \" \" + J)))), A.stack && getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n    marginTop: 1,\n    flexDirection: \"column\"\n  }, A.stack.split(`\n`).slice(1).map(Y => {\n    let J = ________initializeDevToolsConnection.parseLine(Y);\n    if (!J) {\n      return getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n        key: Y\n      }, getDifferencesBetweenObjects.default.createElement(U, {\n        dimColor: true\n      }, \"- \"), getDifferencesBetweenObjects.default.createElement(U, {\n        dimColor: true,\n        bold: true\n      }, Y));\n    }\n    return getDifferencesBetweenObjects.default.createElement(__processAndDisplayNodes, {\n      key: Y\n    }, getDifferencesBetweenObjects.default.createElement(U, {\n      dimColor: true\n    }, \"- \"), getDifferencesBetweenObjects.default.createElement(U, {\n      dimColor: true,\n      bold: true\n    }, J.function), getDifferencesBetweenObjects.default.createElement(U, {\n      dimColor: true\n    }, \" \", \"(\", Yy0(J.file) ?? \"\", \":\", J.line, \":\", J.column, \")\"));\n  })));\n}\nvar getDifferencesBetweenObjects;\nvar _______initializeDevToolsConnection;\nvar Yy0 = A => {\n  return A?.replace(`file://${______initializeDevToolsConnection()}/`, \"\");\n};\nvar ________initializeDevToolsConnection;\nvar Wy0 = T(() => {\n  Gy0();\n  LPA();\n  jY1();\n  getDifferencesBetweenObjects = IA(KA(), 1);\n  _______initializeDevToolsConnection = IA(Ay0(), 1);\n  ________initializeDevToolsConnection = new _______initializeDevToolsConnection.default({\n    cwd: ______initializeDevToolsConnection(),\n    internals: _______initializeDevToolsConnection.default.nodeInternals()\n  });\n});\nimport { Buffer as _________initializeDevToolsConnection } from \"node:buffer\";\nfunction zd9(A) {\n  return {\n    name: \"\",\n    fn: false,\n    ctrl: false,\n    meta: false,\n    shift: false,\n    option: false,\n    sequence: A,\n    raw: A,\n    isPasted: true\n  };\n}\nfunction $d9(A) {\n  if (_________initializeDevToolsConnection.isBuffer(A)) {\n    if (A[0] > 127 && A[1] === undefined) {\n      A[0] -= 128;\n      return \"\u001b\" + String(A);\n    } else {\n      return String(A);\n    }\n  } else if (A !== undefined && typeof A !== \"string\") {\n    return String(A);\n  } else if (!A) {\n    return \"\";\n  } else {\n    return A;\n  }\n}\nfunction Vy0(A, B = \"\") {\n  let Q = B === null;\n  let I = Q ? \"\" : $d9(B);\n  if (A.mode === \"IN_PASTE\") {\n    if ((A.incomplete.slice(-___________initializeDevToolsConnection.length + 1) + I).indexOf(___________initializeDevToolsConnection) === -1) {\n      return [[], {\n        ...A,\n        incomplete: A.incomplete + I\n      }];\n    }\n  }\n  let G = A.incomplete + I;\n  let Z = {\n    ...A,\n    incomplete: \"\"\n  };\n  let Y = [];\n  let J = {\n    NORMAL: () => {\n      let X = ____initializeDevTools.exec(G);\n      G = G.substring(X[0].length);\n      let W = X[1];\n      if (!X[2] && !Q) {\n        let F = _initializeRenderer.exec(W);\n        Z.incomplete = F[2];\n        W = F[1];\n      }\n      if (W) {\n        Y.push(Fy0(W));\n      }\n      if (X[2] === _____initializeDevelopmentTools) {\n        Z.mode = \"IN_PASTE\";\n      } else if (X[2]) {\n        Y.push(Fy0(X[2]));\n      }\n    },\n    IN_PASTE: () => {\n      let X = G.indexOf(___________initializeDevToolsConnection);\n      if (X === -1) {\n        if (!Q) {\n          Z.incomplete = G;\n          G = \"\";\n          return;\n        }\n        X = G.length;\n      }\n      let W = G.substring(0, X);\n      if (W) {\n        Y.push(zd9(W));\n      }\n      G = G.substring(X + ___________initializeDevToolsConnection.length);\n      Z.mode = \"NORMAL\";\n    }\n  };\n  while (G) {\n    J[Z.mode]();\n  }\n  return [Y, Z];\n}\nvar initializeRenderer;\nvar __________initializeDevToolsConnection;\nvar _____initializeDevelopmentTools = \"\u001b[200~\";\nvar ___________initializeDevToolsConnection = \"\u001b[201~\";\nvar ____initializeDevTools;\nvar _initializeRenderer;\nvar ____________initializeDevToolsConnection;\nvar _____initializeDevTools;\nvar ______initializeDevelopmentTools;\nvar ______initializeDevTools = A => {\n  return [\"[a\", \"[b\", \"[c\", \"[d\", \"[e\", \"[2$\", \"[3$\", \"[5$\", \"[6$\", \"[7$\", \"[8$\", \"[Z\"].includes(A);\n};\nvar _____________initializeDevToolsConnection = A => {\n  return [\"Oa\", \"Ob\", \"Oc\", \"Od\", \"Oe\", \"[2^\", \"[3^\", \"[5^\", \"[6^\", \"[7^\", \"[8^\"].includes(A);\n};\nvar Fy0 = (A = \"\") => {\n  let B;\n  let Q = {\n    name: \"\",\n    fn: false,\n    ctrl: false,\n    meta: false,\n    shift: false,\n    option: false,\n    sequence: A,\n    raw: A,\n    isPasted: false\n  };\n  Q.sequence = Q.sequence || A || Q.name;\n  if (A === \"\\r\") {\n    Q.raw = undefined;\n    Q.name = \"return\";\n  } else if (A === `\n`) {\n    Q.name = \"enter\";\n  } else if (A === \"\\t\") {\n    Q.name = \"tab\";\n  } else if (A === \"\\b\" || A === \"\u001b\\b\") {\n    Q.name = \"backspace\";\n    Q.meta = A.charAt(0) === \"\u001b\";\n  } else if (A === \"\" || A === \"\u001b\") {\n    Q.name = \"backspace\";\n    Q.meta = A.charAt(0) === \"\u001b\";\n  } else if (A === \"\u001b\" || A === \"\u001b\u001b\") {\n    Q.name = \"escape\";\n    Q.meta = A.length === 2;\n  } else if (A === \" \" || A === \"\u001b \") {\n    Q.name = \"space\";\n    Q.meta = A.length === 2;\n  } else if (A === \"\u001f\") {\n    Q.name = \"_\";\n    Q.ctrl = true;\n  } else if (A <= \"\u001a\" && A.length === 1) {\n    Q.name = String.fromCharCode(A.charCodeAt(0) + 97 - 1);\n    Q.ctrl = true;\n  } else if (A.length === 1 && A >= \"0\" && A <= \"9\") {\n    Q.name = \"number\";\n  } else if (A.length === 1 && A >= \"a\" && A <= \"z\") {\n    Q.name = A;\n  } else if (A.length === 1 && A >= \"A\" && A <= \"Z\") {\n    Q.name = A.toLowerCase();\n    Q.shift = true;\n  } else if (B = initializeRenderer.exec(A)) {\n    Q.meta = true;\n    Q.shift = /^[A-Z]$/.test(B[1]);\n  } else if (B = __________initializeDevToolsConnection.exec(A)) {\n    let I = [...A];\n    if (I[0] === \"\u001b\" && I[1] === \"\u001b\") {\n      Q.option = true;\n    }\n    let G = [B[1], B[2], B[4], B[6]].filter(Boolean).join(\"\");\n    let Z = (B[3] || B[5] || 1) - 1;\n    Q.ctrl = !!(Z & 4);\n    Q.meta = !!(Z & 10);\n    Q.shift = !!(Z & 1);\n    Q.code = G;\n    Q.name = _____initializeDevTools[G];\n    Q.shift = ______initializeDevTools(G) || Q.shift;\n    Q.ctrl = _____________initializeDevToolsConnection(G) || Q.ctrl;\n  }\n  if (Q.raw === \"\u001bb\") {\n    Q.meta = true;\n    Q.name = \"left\";\n  } else if (Q.raw === \"\u001bf\") {\n    Q.meta = true;\n    Q.name = \"right\";\n  }\n  switch (A) {\n    case \"\u001b[1~\":\n      return {\n        name: \"home\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n    case \"\u001b[4~\":\n      return {\n        name: \"end\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n    case \"\u001b[5~\":\n      return {\n        name: \"pageup\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n    case \"\u001b[6~\":\n      return {\n        name: \"pagedown\",\n        ctrl: false,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n    case \"\u001b[1;5D\":\n      return {\n        name: \"left\",\n        ctrl: true,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n    case \"\u001b[1;5C\":\n      return {\n        name: \"right\",\n        ctrl: true,\n        meta: false,\n        shift: false,\n        option: false,\n        fn: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n    case \"\u001b[1~\":\n      return {\n        name: \"left\",\n        ctrl: true,\n        fn: true,\n        meta: false,\n        shift: false,\n        option: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n    case \"\u001b[4~\":\n      return {\n        name: \"right\",\n        ctrl: true,\n        fn: true,\n        meta: false,\n        shift: false,\n        option: false,\n        sequence: A,\n        raw: A,\n        isPasted: false\n      };\n  }\n  return Q;\n};\nvar kY1 = T(() => {\n  initializeRenderer = /^(?:\\x1b)([a-zA-Z0-9])$/;\n  __________initializeDevToolsConnection = /^(?:\\x1b+)(O|N|\\[|\\[\\[)(?:(\\d+)(?:;(\\d+))?([~^$])|(?:1;)?(\\d+)?([a-zA-Z]))/;\n  ____initializeDevTools = new RegExp(\"^(.*?)(\" + [\"\\\\x1b\\\\][0-9]*(?:;[^\\\\x07\\\\x1b]*)*(?:\\\\x07|\\\\x1b\\\\\\\\)\", \"\\\\x1bP[^\\\\x1b]*\\\\x1b\\\\\\\\\", \"\\\\x1b\\\\[[0-9]*(?:;[0-9]*)*[A-Za-z~]\", \"\\\\x1bO[A-Za-z]\", \"\\\\x1b[\\\\x00-\\\\x7F]\", \"\\\\x1b\\\\x1b\", \"$\"].map(A => `(?:${A})`).join(\"|\") + \")\", \"s\");\n  _initializeRenderer = new RegExp(\"(.*?)(\" + [\"\\\\x1b\\\\][0-9]*(?:;[^\\\\x07\\\\x1b]*)*$\", \"\\\\x1bP[^\\\\x1b]*$\", \"\\\\x1b\\\\[[0-9]*(?:;[0-9]*)*$\", \"\\\\x1bO$\", \"\\\\x1b$\", \"$\"].map(A => `(?:${A})`).join(\"|\") + \")\", \"s\");\n  ____________initializeDevToolsConnection = {\n    mode: \"NORMAL\",\n    incomplete: \"\"\n  };\n  _____initializeDevTools = {\n    OP: \"f1\",\n    OQ: \"f2\",\n    OR: \"f3\",\n    OS: \"f4\",\n    \"[11~\": \"f1\",\n    \"[12~\": \"f2\",\n    \"[13~\": \"f3\",\n    \"[14~\": \"f4\",\n    \"[[A\": \"f1\",\n    \"[[B\": \"f2\",\n    \"[[C\": \"f3\",\n    \"[[D\": \"f4\",\n    \"[[E\": \"f5\",\n    \"[15~\": \"f5\",\n    \"[17~\": \"f6\",\n    \"[18~\": \"f7\",\n    \"[19~\": \"f8\",\n    \"[20~\": \"f9\",\n    \"[21~\": \"f10\",\n    \"[23~\": \"f11\",\n    \"[24~\": \"f12\",\n    \"[A\": \"up\",\n    \"[B\": \"down\",\n    \"[C\": \"right\",\n    \"[D\": \"left\",\n    \"[E\": \"clear\",\n    \"[F\": \"end\",\n    \"[H\": \"home\",\n    OA: \"up\",\n    OB: \"down\",\n    OC: \"right\",\n    OD: \"left\",\n    OE: \"clear\",\n    OF: \"end\",\n    OH: \"home\",\n    \"[1~\": \"home\",\n    \"[2~\": \"insert\",\n    \"[3~\": \"delete\",\n    \"[4~\": \"end\",\n    \"[5~\": \"pageup\",\n    \"[6~\": \"pagedown\",\n    \"[[5~\": \"pageup\",\n    \"[[6~\": \"pagedown\",\n    \"[7~\": \"home\",\n    \"[8~\": \"end\",\n    \"[a\": \"up\",\n    \"[b\": \"down\",\n    \"[c\": \"right\",\n    \"[d\": \"left\",\n    \"[e\": \"clear\",\n    \"[2$\": \"insert\",\n    \"[3$\": \"delete\",\n    \"[5$\": \"pageup\",\n    \"[6$\": \"pagedown\",\n    \"[7$\": \"home\",\n    \"[8$\": \"end\",\n    Oa: \"up\",\n    Ob: \"down\",\n    Oc: \"right\",\n    Od: \"left\",\n    Oe: \"clear\",\n    \"[2^\": \"insert\",\n    \"[3^\": \"delete\",\n    \"[5^\": \"pageup\",\n    \"[6^\": \"pagedown\",\n    \"[7^\": \"home\",\n    \"[8^\": \"end\",\n    \"[Z\": \"tab\"\n  };\n  ______initializeDevelopmentTools = [...Object.values(_____initializeDevTools), \"backspace\"];\n});\nfunction Ld9(A) {\n  let B = {\n    upArrow: A.name === \"up\",\n    downArrow: A.name === \"down\",\n    leftArrow: A.name === \"left\",\n    rightArrow: A.name === \"right\",\n    pageDown: A.name === \"pagedown\",\n    pageUp: A.name === \"pageup\",\n    home: A.name === \"home\",\n    end: A.name === \"end\",\n    return: A.name === \"return\",\n    escape: A.name === \"escape\",\n    fn: A.fn,\n    ctrl: A.ctrl,\n    shift: A.shift,\n    tab: A.name === \"tab\",\n    backspace: A.name === \"backspace\",\n    delete: A.name === \"delete\",\n    meta: A.meta || A.name === \"escape\" || A.option\n  };\n  let Q = A.ctrl ? A.name : A.sequence;\n  if (Q === undefined) {\n    Q = \"\";\n  }\n  if (A.name && ______initializeDevelopmentTools.includes(A.name)) {\n    Q = \"\";\n  }\n  if (Q.startsWith(\"\u001b\")) {\n    Q = Q.slice(1);\n  }\n  if (Q.length === 1 && typeof Q[0] === \"string\" && Q[0].toUpperCase() === Q[0]) {\n    B.shift = true;\n  }\n  return [B, Q];\n}\nvar ProcessPublicAccess;\nvar _Y1 = T(() => {\n  kY1();\n  ProcessPublicAccess = class PPA extends E0A {\n    keypress;\n    key;\n    input;\n    constructor(A) {\n      super();\n      let [B, Q] = Ld9(A);\n      this.keypress = A;\n      this.key = B;\n      this.input = Q;\n    }\n  };\n});\nvar ______________initializeDevToolsConnection;\nvar initializeDebuggerConnection;\nvar xY1 = T(() => {\n  ______________initializeDevToolsConnection = IA(KA(), 1);\n  initializeDebuggerConnection = ______________initializeDevToolsConnection.createContext(false);\n});\nvar _______initializeDevTools;\nvar SinglePageApplication;\nvar vY1 = T(() => {\n  _______initializeDevTools = IA(KA(), 1);\n  SinglePageApplication = _______initializeDevTools.createContext(null);\n});\nvar _cleanupYogaNode;\nvar __initializeRenderer = \"\\t\";\nvar ________initializeDevTools = \"\u001b[Z\";\nvar _________initializeDevTools = \"\u001b\";\nvar _______initializeDevelopmentTools;\nvar _colorPalette;\nvar zy0 = T(() => {\n  UPA();\n  $Y1();\n  qY1();\n  qPA();\n  Wy0();\n  kY1();\n  OPA();\n  YJA();\n  _Y1();\n  xY1();\n  vY1();\n  _cleanupYogaNode = IA(KA(), 1);\n  _______initializeDevelopmentTools = process.platform !== \"win32\";\n  _colorPalette = class yPA extends _cleanupYogaNode.PureComponent {\n    static displayName = \"InternalApp\";\n    static getDerivedStateFromError(A) {\n      return {\n        error: A\n      };\n    }\n    state = {\n      isFocusEnabled: true,\n      activeFocusId: undefined,\n      focusables: [],\n      error: undefined\n    };\n    rawModeEnabledCount = 0;\n    internal_eventEmitter = new initializeDevTools();\n    keyParseState = ____________initializeDevToolsConnection;\n    incompleteEscapeTimer = null;\n    NORMAL_TIMEOUT = 50;\n    PASTE_TIMEOUT = 500;\n    isRawModeSupported() {\n      return this.props.stdin.isTTY;\n    }\n    render() {\n      return _cleanupYogaNode.default.createElement(SinglePageApplication.Provider, {\n        value: {\n          columns: this.props.terminalColumns,\n          rows: this.props.terminalRows\n        }\n      }, _cleanupYogaNode.default.createElement(initializeDebuggerConnection.Provider, {\n        value: this.props.ink2\n      }, _cleanupYogaNode.default.createElement(_initializeDevelopmentTools.Provider, {\n        value: {\n          exit: this.handleExit\n        }\n      }, _cleanupYogaNode.default.createElement(RY1, {\n        initialState: this.props.initialTheme\n      }, _cleanupYogaNode.default.createElement(initializeReactDevTools.Provider, {\n        value: {\n          stdin: this.props.stdin,\n          setRawMode: this.handleSetRawMode,\n          isRawModeSupported: this.isRawModeSupported(),\n          internal_exitOnCtrlC: this.props.exitOnCtrlC,\n          internal_eventEmitter: this.internal_eventEmitter\n        }\n      }, _cleanupYogaNode.default.createElement(_processAndDisplayNodes.Provider, {\n        value: {\n          activeId: this.state.activeFocusId,\n          add: this.addFocusable,\n          remove: this.removeFocusable,\n          activate: this.activateFocusable,\n          deactivate: this.deactivateFocusable,\n          enableFocus: this.enableFocus,\n          disableFocus: this.disableFocus,\n          focusNext: this.focusNext,\n          focusPrevious: this.focusPrevious,\n          focus: this.focus\n        }\n      }, this.state.error ? _cleanupYogaNode.default.createElement(yY1, {\n        error: this.state.error\n      }) : this.props.children))))));\n    }\n    componentDidMount() {\n      if (this.props.stdout.isTTY) {\n        this.props.stdout.write(terminalCommands.cursorHide);\n      }\n    }\n    componentWillUnmount() {\n      if (this.props.stdout.isTTY) {\n        this.props.stdout.write(terminalCommands.cursorShow);\n      }\n      if (this.incompleteEscapeTimer) {\n        clearTimeout(this.incompleteEscapeTimer);\n        this.incompleteEscapeTimer = null;\n      }\n      if (this.isRawModeSupported()) {\n        this.handleSetRawMode(false);\n      }\n    }\n    componentDidCatch(A) {\n      this.handleExit(A);\n    }\n    handleSetRawMode = A => {\n      let {\n        stdin: B\n      } = this.props;\n      if (!this.isRawModeSupported()) {\n        if (B === process.stdin) {\n          throw Error(`Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);\n        } else {\n          throw Error(`Raw mode is not supported on the stdin provided to Ink.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);\n        }\n      }\n      B.setEncoding(\"utf8\");\n      if (A) {\n        if (this.rawModeEnabledCount === 0) {\n          B.ref();\n          B.setRawMode(true);\n          B.addListener(\"readable\", this.handleReadable);\n          this.props.stdout.write(\"\u001b[?2004h\");\n        }\n        this.rawModeEnabledCount++;\n        return;\n      }\n      if (--this.rawModeEnabledCount === 0) {\n        this.props.stdout.write(\"\u001b[?2004l\");\n        B.setRawMode(false);\n        B.removeListener(\"readable\", this.handleReadable);\n        B.unref();\n      }\n    };\n    flushIncomplete = () => {\n      this.incompleteEscapeTimer = null;\n      if (!this.keyParseState.incomplete) {\n        return;\n      }\n      this.processInput(null);\n    };\n    processInput = A => {\n      let [B, Q] = Vy0(this.keyParseState, A);\n      this.keyParseState = Q;\n      for (let I of B) {\n        this.handleInput(I.sequence);\n        let G = new ProcessPublicAccess(I);\n        this.internal_eventEmitter.emit(\"input\", G);\n      }\n      if (this.keyParseState.incomplete) {\n        if (this.incompleteEscapeTimer) {\n          clearTimeout(this.incompleteEscapeTimer);\n        }\n        this.incompleteEscapeTimer = setTimeout(this.flushIncomplete, this.keyParseState.mode === \"IN_PASTE\" ? this.PASTE_TIMEOUT : this.NORMAL_TIMEOUT);\n      }\n    };\n    handleReadable = () => {\n      let A;\n      while ((A = this.props.stdin.read()) !== null) {\n        this.processInput(A);\n      }\n    };\n    handleInput = A => {\n      if (A === \"\u0003\" && this.props.exitOnCtrlC) {\n        this.handleExit();\n      }\n      if (A === \"\u001a\" && _______initializeDevelopmentTools) {\n        this.handleSuspend();\n      }\n      if (A === _________initializeDevTools && this.state.activeFocusId) {\n        this.setState({\n          activeFocusId: undefined\n        });\n      }\n      if (this.state.isFocusEnabled && this.state.focusables.length > 0) {\n        if (A === __initializeRenderer) {\n          this.focusNext();\n        }\n        if (A === ________initializeDevTools) {\n          this.focusPrevious();\n        }\n      }\n    };\n    handleExit = A => {\n      if (this.isRawModeSupported()) {\n        this.handleSetRawMode(false);\n      }\n      this.props.onExit(A);\n    };\n    handleSuspend = () => {\n      if (!this.isRawModeSupported()) {\n        return;\n      }\n      let A = this.rawModeEnabledCount;\n      while (this.rawModeEnabledCount > 0) {\n        this.handleSetRawMode(false);\n      }\n      if (this.props.stdout.isTTY) {\n        this.props.stdout.write(terminalCommands.cursorShow);\n        this.props.stdout.write(\"\u001b[?1004l\");\n      }\n      this.internal_eventEmitter.emit(\"suspend\");\n      let B = () => {\n        for (let Q = 0; Q < A; Q++) {\n          if (this.isRawModeSupported()) {\n            this.handleSetRawMode(true);\n          }\n        }\n        if (this.props.stdout.isTTY) {\n          this.props.stdout.write(terminalCommands.cursorHide);\n          this.props.stdout.write(\"\u001b[?1004h\");\n        }\n        this.internal_eventEmitter.emit(\"resume\");\n        process.removeListener(\"SIGCONT\", B);\n      };\n      process.on(\"SIGCONT\", B);\n      process.kill(process.pid, \"SIGSTOP\");\n    };\n    enableFocus = () => {\n      this.setState({\n        isFocusEnabled: true\n      });\n    };\n    disableFocus = () => {\n      this.setState({\n        isFocusEnabled: false\n      });\n    };\n    focus = A => {\n      this.setState(B => {\n        if (!B.focusables.some(I => I?.id === A)) {\n          return B;\n        }\n        return {\n          activeFocusId: A\n        };\n      });\n    };\n    focusNext = () => {\n      this.setState(A => {\n        let B = A.focusables.find(I => I.isActive)?.id;\n        return {\n          activeFocusId: this.findNextFocusable(A) ?? B\n        };\n      });\n    };\n    focusPrevious = () => {\n      this.setState(A => {\n        let B = A.focusables.findLast(I => I.isActive)?.id;\n        return {\n          activeFocusId: this.findPreviousFocusable(A) ?? B\n        };\n      });\n    };\n    addFocusable = (A, {\n      autoFocus: B\n    }) => {\n      this.setState(Q => {\n        let I = Q.activeFocusId;\n        if (!I && B) {\n          I = A;\n        }\n        return {\n          activeFocusId: I,\n          focusables: [...Q.focusables, {\n            id: A,\n            isActive: true\n          }]\n        };\n      });\n    };\n    removeFocusable = A => {\n      this.setState(B => ({\n        activeFocusId: B.activeFocusId === A ? undefined : B.activeFocusId,\n        focusables: B.focusables.filter(Q => {\n          return Q.id !== A;\n        })\n      }));\n    };\n    activateFocusable = A => {\n      this.setState(B => ({\n        focusables: B.focusables.map(Q => {\n          if (Q.id !== A) {\n            return Q;\n          }\n          return {\n            id: A,\n            isActive: true\n          };\n        })\n      }));\n    };\n    deactivateFocusable = A => {\n      this.setState(B => ({\n        activeFocusId: B.activeFocusId === A ? undefined : B.activeFocusId,\n        focusables: B.focusables.map(Q => {\n          if (Q.id !== A) {\n            return Q;\n          }\n          return {\n            id: A,\n            isActive: false\n          };\n        })\n      }));\n    };\n    findNextFocusable = A => {\n      let B = A.focusables.findIndex(Q => {\n        return Q.id === A.activeFocusId;\n      });\n      for (let Q = B + 1; Q < A.focusables.length; Q++) {\n        let I = A.focusables[Q];\n        if (I?.isActive) {\n          return I.id;\n        }\n      }\n      return;\n    };\n    findPreviousFocusable = A => {\n      let B = A.focusables.findIndex(Q => {\n        return Q.id === A.activeFocusId;\n      });\n      for (let Q = B - 1; Q >= 0; Q--) {\n        let I = A.focusables[Q];\n        if (I?.isActive) {\n          return I.id;\n        }\n      }\n      return;\n    };\n  };\n});\nfunction Pd9() {}\nvar initializeDebuggingTools;\nvar bY1 = T(() => {\n  initializeDebuggingTools = Pd9;\n});\nvar _______________initializeDevToolsConnection = \"\u001b[?2026h\";\nvar __________initializeDevTools = \"\u001b[?2026l\";\nfunction jd9() {\n  return process.platform === \"win32\" && !!process.env.WT_SESSION;\n}\nfunction Sd9() {\n  if (jd9()) {\n    return true;\n  }\n  if (process.platform === \"win32\" && process.env.TERM_PROGRAM === \"vscode\" && process.env.TERM_PROGRAM_VERSION) {\n    return true;\n  }\n  return false;\n}\nfunction fY1() {\n  if (process.platform === \"win32\") {\n    if (Sd9()) {\n      return \"\u001b[2J\u001b[3J\u001b[H\";\n    } else {\n      return \"\u001b[2J\u001b[0f\";\n    }\n  } else {\n    return \"\u001b[2J\u001b[3J\u001b[H\";\n  }\n}\nvar ________________initializeDevToolsConnection;\nvar $y0 = T(() => {\n  ________________initializeDevToolsConnection = fY1();\n});\nfunction hY1(A, B) {\n  if (B.length === 0) {\n    return;\n  }\n  let Q = _______________initializeDevToolsConnection;\n  for (let I of B) {\n    switch (I.type) {\n      case \"stdout\":\n        Q += I.content;\n        break;\n      case \"clear\":\n        if (I.count > 0) {\n          Q += terminalCommands.eraseLines(I.count);\n        }\n        break;\n      case \"clearTerminal\":\n        Q += fY1();\n        break;\n      case \"cursorHide\":\n        Q += terminalCommands.cursorHide;\n        break;\n      case \"cursorShow\":\n        Q += terminalCommands.cursorShow;\n        break;\n      case \"cursorMove\":\n        Q += terminalCommands.cursorMove(I.x, I.y);\n        break;\n      case \"del\":\n        Q += \"\u001b[P\";\n        break;\n    }\n  }\n  Q += __________initializeDevTools;\n  A.stdout.write(Q);\n}\nvar qy0 = T(() => {\n  YJA();\n  $y0();\n});\nclass kPA {\n  options;\n  log;\n  terminal;\n  scheduleRender;\n  isUnmounted = false;\n  isPaused = false;\n  container;\n  rootNode;\n  renderer;\n  exitPromise;\n  restoreConsole;\n  unsubscribeTTYHandlers;\n  terminalColumns;\n  terminalRows;\n  currentNode = null;\n  constructor(A) {\n    this.options = A;\n    KZ1(this);\n    if (this.options.patchConsole) {\n      this.restoreConsole = this.patchConsole();\n    }\n    this.terminal = {\n      stdout: A.stdout,\n      stderr: A.stderr\n    };\n    this.terminalColumns = A.stdout.columns || 80;\n    this.terminalRows = A.stdout.rows || 24;\n    this.log = new UY1({\n      debug: A.debug,\n      isTTY: A.stdout.isTTY || false,\n      onFlicker: A.onFlicker,\n      ink2: A.ink2\n    }, HPA(this.terminalRows, this.terminalColumns));\n    this.scheduleRender = A.debug ? this.onRender : VZ1(this.onRender, 32, {\n      leading: true,\n      trailing: true\n    });\n    this.isUnmounted = false;\n    this.unsubscribeExit = jTA(this.unmount, {\n      alwaysLast: false\n    });\n    if (A.stdout.isTTY) {\n      A.stdout.on(\"resize\", this.handleResize);\n      process.on(\"SIGCONT\", this.handleResume);\n      this.unsubscribeTTYHandlers = () => {\n        A.stdout.off(\"resize\", this.handleResize);\n        process.off(\"SIGCONT\", this.handleResume);\n      };\n    }\n    this.rootNode = QPA(\"ink-root\");\n    this.renderer = VY1(this.rootNode);\n    this.rootNode.onRender = this.scheduleRender;\n    this.rootNode.onImmediateRender = this.onRender;\n    this.container = renderComponent.createContainer(this.rootNode, 0, null, false, null, \"id\", () => {}, null);\n    if (process.env.DEV === \"true\") {\n      renderComponent.injectIntoDevTools({\n        bundleType: 0,\n        version: \"16.13.1\",\n        rendererPackageName: \"ink\"\n      });\n    }\n  }\n  handleResume = () => {\n    if (!this.options.stdout.isTTY) {\n      return;\n    }\n    this.log.reset();\n  };\n  handleResize = () => {\n    this.terminalColumns = this.options.stdout.columns || 80;\n    this.terminalRows = this.options.stdout.rows || 24;\n    if (this.currentNode !== null) {\n      this.render(this.currentNode);\n    }\n    this.scheduleRender();\n  };\n  resolveExitPromise = () => {};\n  rejectExitPromise = () => {};\n  unsubscribeExit = () => {};\n  setTheme(A) {\n    this.options.theme = A;\n  }\n  onRender() {\n    if (this.isUnmounted || this.isPaused) {\n      return;\n    }\n    let A = this.options.stdout.rows || 24;\n    let B = this.options.stdout.columns || 80;\n    let Q = this.renderer({\n      theme: this.options.theme,\n      terminalWidth: B,\n      terminalRows: A,\n      isTTY: this.options.stdout.isTTY,\n      ink2: this.options.ink2\n    });\n    let I = this.log.render(Q);\n    for (let G of I) {\n      if (G.type === \"clearTerminal\") {\n        this.options.onFlicker?.(Q.outputHeight, Q.rows, this.options.ink2);\n      }\n    }\n    hY1(this.terminal, I);\n  }\n  pause() {\n    renderComponent.flushSync();\n    this.onRender();\n    this.isPaused = true;\n  }\n  resume() {\n    this.isPaused = false;\n    this.onRender();\n  }\n  stdinListeners = [];\n  wasRawMode = false;\n  suspendStdin() {\n    let A = this.options.stdin;\n    if (!A.isTTY) {\n      return;\n    }\n    A.listeners(\"readable\").forEach(I => {\n      this.stdinListeners.push({\n        event: \"readable\",\n        listener: I\n      });\n      A.removeListener(\"readable\", I);\n    });\n    let Q = A;\n    if (Q.isRaw && Q.setRawMode) {\n      Q.setRawMode(false);\n      this.wasRawMode = true;\n    }\n  }\n  resumeStdin() {\n    let A = this.options.stdin;\n    if (!A.isTTY) {\n      return;\n    }\n    this.stdinListeners.forEach(({\n      event: B,\n      listener: Q\n    }) => {\n      A.addListener(B, Q);\n    });\n    this.stdinListeners = [];\n    if (this.wasRawMode) {\n      let B = A;\n      if (B.setRawMode) {\n        B.setRawMode(true);\n      }\n      this.wasRawMode = false;\n    }\n  }\n  render(A) {\n    this.currentNode = A;\n    let B = ________initializeDevelopmentTools.default.createElement(_colorPalette, {\n      initialTheme: this.options.theme,\n      stdin: this.options.stdin,\n      stdout: this.options.stdout,\n      stderr: this.options.stderr,\n      exitOnCtrlC: this.options.exitOnCtrlC,\n      onExit: this.unmount,\n      ink2: this.options.ink2,\n      terminalColumns: this.terminalColumns,\n      terminalRows: this.terminalRows\n    }, A);\n    renderComponent.updateContainer(B, this.container, null, initializeDebuggingTools);\n  }\n  unmount(A) {\n    if (this.isUnmounted) {\n      return;\n    }\n    this.onRender();\n    this.unsubscribeExit();\n    if (typeof this.restoreConsole === \"function\") {\n      this.restoreConsole();\n    }\n    this.unsubscribeTTYHandlers?.();\n    let B = this.log.renderPreviousOutput_DEPRECATED();\n    hY1(this.terminal, B);\n    this.isUnmounted = true;\n    renderComponent.updateContainer(null, this.container, null, initializeDebuggingTools);\n    colorManagement.delete(this.options.stdout);\n    if (A instanceof Error) {\n      this.rejectExitPromise(A);\n    } else {\n      this.resolveExitPromise();\n    }\n  }\n  async waitUntilExit() {\n    this.exitPromise ||= new Promise((A, B) => {\n      this.resolveExitPromise = A;\n      this.rejectExitPromise = B;\n    });\n    return this.exitPromise;\n  }\n  resetLineCount() {\n    if (this.options.stdout.isTTY && !this.options.debug) {\n      this.log.reset();\n    }\n  }\n  patchConsole() {\n    if (this.options.debug) {\n      return;\n    }\n    return Gj0((A, B) => {\n      if (A === \"stdout\") {\n        g(`console.log: ${B}`);\n      }\n      if (A === \"stderr\") {\n        BA(Error(`console.error: ${B}`), lJ0);\n      }\n    });\n  }\n}\nfunction MY1(A) {\n  colorManagement.forEach(B => {\n    B.setTheme(A);\n  });\n}\nvar ________initializeDevelopmentTools;\nvar PY1 = T(() => {\n  Bj0();\n  dG1();\n  Zj0();\n  iZ1();\n  yS0();\n  ZPA();\n  dS0();\n  zPA();\n  zy0();\n  c1();\n  C0();\n  bY1();\n  qy0();\n  zY1();\n  ________initializeDevelopmentTools = IA(KA(), 1);\n});\nfunction Ly0() {\n  if (Nf(undefined)) {\n    return false;\n  }\n  return V0(undefined) || false;\n}\nvar _________________initializeDevToolsConnection = T(() => {\n  vB();\n  f4();\n});\nimport { Stream as ___________initializeDevTools } from \"node:stream\";\nvar kd9 = (A, B) => {\n  let Q = xd9(B);\n  let I = {\n    stdout: process.stdout,\n    stdin: process.stdin,\n    stderr: process.stderr,\n    debug: false,\n    exitOnCtrlC: true,\n    patchConsole: true,\n    ...Q,\n    theme: Q.theme ?? L1().theme,\n    ink2: Q.ink2 ?? Ly0()\n  };\n  let G = vd9(I.stdout, () => new kPA(I));\n  G.render(A);\n  return {\n    rerender: G.render,\n    unmount() {\n      G.unmount();\n    },\n    waitUntilExit: G.waitUntilExit,\n    cleanup: () => colorManagement.delete(I.stdout)\n  };\n};\nvar _d9 = async (A, B) => {\n  await ij0();\n  return kd9(A, B);\n};\nvar ___initializeRenderer;\nvar xd9 = (A = {}) => {\n  if (A instanceof ___________initializeDevTools) {\n    return {\n      stdout: A,\n      stdin: process.stdin\n    };\n  }\n  return A;\n};\nvar vd9 = (A, B) => {\n  let Q = colorManagement.get(A);\n  if (!Q) {\n    Q = B();\n    colorManagement.set(A, Q);\n  }\n  return Q;\n};\nvar Oy0 = T(() => {\n  PY1();\n  ZPA();\n  zPA();\n  kB();\n  _________________initializeDevToolsConnection();\n  ___initializeRenderer = _d9;\n});\nfunction Ry0({\n  children: A\n}) {\n  return retrieveColorSettings.default.createElement(__________________initializeDevToolsConnection.Provider, {\n    value: true\n  }, A);\n}\nvar retrieveColorSettings;\nvar initDevToolsConnection;\nvar __________________initializeDevToolsConnection;\nvar uY1 = T(() => {\n  retrieveColorSettings = IA(KA(), 1);\n  initDevToolsConnection = IA(KA(), 1);\n  __________________initializeDevToolsConnection = retrieveColorSettings.default.createContext(false);\n});\nfunction kh(A) {\n  let {\n    items: B,\n    children: Q\n  } = A;\n  let I = devToolsHandler.useContext(initializeDebuggerConnection);\n  let [G, Z] = devToolsHandler.useState(0);\n  let Y = devToolsHandler.useMemo(() => {\n    return B.slice(G);\n  }, [B, G]);\n  devToolsHandler.useLayoutEffect(() => {\n    Z(B.length);\n  }, [B.length]);\n  if (I) {\n    let X = B.map((W, F) => Q(W, F));\n    return devToolsHandler.default.createElement(\"ink-box\", {\n      style: {\n        flexDirection: \"column\"\n      }\n    }, X);\n  }\n  let J = Y.map((X, W) => {\n    return Q(X, G + W);\n  });\n  return devToolsHandler.default.createElement(Ry0, null, devToolsHandler.default.createElement(\"ink-box\", {\n    internal_static: true,\n    style: {\n      position: \"absolute\",\n      flexDirection: \"column\"\n    }\n  }, J));\n}\nvar devToolsHandler;\nvar Ty0 = T(() => {\n  uY1();\n  xY1();\n  devToolsHandler = IA(KA(), 1);\n});\nfunction jM({\n  children: A,\n  transform: B\n}) {\n  if (A === undefined || A === null) {\n    return null;\n  }\n  return ___________________initializeDevToolsConnection.default.createElement(\"ink-text\", {\n    style: {\n      flexGrow: 0,\n      flexShrink: 1,\n      flexDirection: \"row\"\n    },\n    internal_transform: B\n  }, A);\n}\nvar ___________________initializeDevToolsConnection;\nvar ____________________initializeDevToolsConnection = T(() => {\n  ___________________initializeDevToolsConnection = IA(KA(), 1);\n});\nfunction AF({\n  count: A = 1\n}) {\n  return _____________________initializeDevToolsConnection.default.createElement(\"ink-text\", null, `\n`.repeat(A));\n}\nvar _____________________initializeDevToolsConnection;\nvar ______________________initializeDevToolsConnection = T(() => {\n  _____________________initializeDevToolsConnection = IA(KA(), 1);\n});\nvar _________initializeDevelopmentTools;\nvar ky0 = T(() => {\n  LPA();\n  _________initializeDevelopmentTools = IA(KA(), 1);\n});\nvar devToolsInitializationHandler;\nvar gd9 = () => devToolsInitializationHandler.useContext(initializeReactDevTools);\nvar __________initializeDevelopmentTools;\nvar _PA = T(() => {\n  qY1();\n  devToolsInitializationHandler = IA(KA(), 1);\n  __________initializeDevelopmentTools = gd9;\n});\nvar ___________initializeDevelopmentTools;\nvar ud9 = (A, B = {}) => {\n  let {\n    stdin: Q,\n    setRawMode: I,\n    internal_exitOnCtrlC: G,\n    internal_eventEmitter: Z\n  } = __________initializeDevelopmentTools();\n  ___________initializeDevelopmentTools.useEffect(() => {\n    if (B.isActive === false) {\n      return;\n    }\n    I(true);\n    return () => {\n      I(false);\n    };\n  }, [B.isActive, I]);\n  ___________initializeDevelopmentTools.useEffect(() => {\n    if (B.isActive === false) {\n      return;\n    }\n    let Y = J => {\n      let {\n        input: X,\n        key: W\n      } = J;\n      if (X !== \"c\" || !W.ctrl || !G) {\n        renderComponent.batchedUpdates(() => {\n          A(X, W, J);\n        });\n      }\n    };\n    Z?.on(\"input\", Y);\n    return () => {\n      Z?.removeListener(\"input\", Y);\n    };\n  }, [B.isActive, Q, G, A]);\n};\nvar renderAndSetupComponent;\nvar xy0 = T(() => {\n  iZ1();\n  _PA();\n  ___________initializeDevelopmentTools = IA(KA(), 1);\n  renderAndSetupComponent = ud9;\n});\nvar ____________initializeDevTools;\nvar vy0 = T(() => {\n  $Y1();\n  ____________initializeDevTools = IA(KA(), 1);\n});\nvar renderingFunction1;\nvar by0 = T(() => {\n  qPA();\n  _PA();\n  renderingFunction1 = IA(KA(), 1);\n});\nvar _______________________initializeDevToolsConnection;\nvar fy0 = T(() => {\n  qPA();\n  _______________________initializeDevToolsConnection = IA(KA(), 1);\n});\nvar ____initializeRenderer = A => ({\n  width: A.yogaNode?.getComputedWidth() ?? 0,\n  height: A.yogaNode?.getComputedHeight() ?? 0\n});\nvar rendererInitialization;\nvar hy0 = T(() => {\n  rendererInitialization = ____initializeRenderer;\n});\nvar nA = T(() => {\n  Oy0();\n  LPA();\n  jY1();\n  Ty0();\n  ____________________initializeDevToolsConnection();\n  ______________________initializeDevToolsConnection();\n  ky0();\n  xy0();\n  vy0();\n  _PA();\n  by0();\n  fy0();\n  hy0();\n  uY1();\n  OPA();\n  XPA();\n  APA();\n  _Y1();\n  UPA();\n});\nfunction vk(A, B, Q) {\n  let I = _____________initializeDevTools.useRef(0);\n  let G = _____________initializeDevTools.useRef();\n  let Z = _____________initializeDevTools.useCallback(() => {\n    if (G.current) {\n      clearTimeout(G.current);\n      G.current = undefined;\n    }\n  }, []);\n  _____________initializeDevTools.useEffect(() => {\n    return () => {\n      Z();\n    };\n  }, [Z]);\n  return _____________initializeDevTools.useCallback(() => {\n    let Y = Date.now();\n    if (Y - I.current <= ______________initializeDevTools && G.current !== undefined) {\n      Z();\n      A(false);\n      B();\n    } else {\n      Q?.();\n      A(true);\n      Z();\n      G.current = setTimeout(() => {\n        A(false);\n        G.current = undefined;\n      }, ______________initializeDevTools);\n    }\n    I.current = Y;\n  }, [A, B, Q, Z]);\n}\nvar _____________initializeDevTools;\nvar ______________initializeDevTools = 800;\nvar initializeColorPalette = T(() => {\n  _____________initializeDevTools = IA(KA(), 1);\n});\nfunction CG(A, B, Q = false) {\n  let I = A;\n  if (Q) {\n    let G = A.indexOf(`\n`);\n    if (G !== -1) {\n      I = A.substring(0, G);\n      if (I.length + 1 > B) {\n        return `${I.substring(0, B - 1)}…`;\n      }\n      return `${I}…`;\n    }\n  }\n  if (I.length <= B) {\n    return I;\n  }\n  return `${I.substring(0, B - 1)}…`;\n}\nfunction KU(A) {\n  if (A < 60000) {\n    if (A === 0) {\n      return \"0s\";\n    }\n    if (A < 1) {\n      return `${(A / 1000).toFixed(1)}s`;\n    }\n    return `${Math.round(A / 1000).toString()}s`;\n  }\n  let B = Math.floor(A / 3600000);\n  let Q = Math.floor(A % 3600000 / 60000);\n  let I = Math.round(A % 60000 / 1000);\n  if (B > 0) {\n    return `${B}h ${Q}m ${I}s`;\n  }\n  if (Q > 0) {\n    return `${Q}m ${I}s`;\n  }\n  return `${I}s`;\n}\nfunction yZ(A) {\n  let B = A >= 1000;\n  return new Intl.NumberFormat(\"en\", {\n    notation: \"compact\",\n    minimumFractionDigits: B ? 1 : 0,\n    maximumFractionDigits: 1\n  }).format(A).toLowerCase();\n}\nfunction vPA(A, B = {}) {\n  let {\n    style: Q = \"narrow\",\n    numeric: I = \"always\",\n    now: G = new Date()\n  } = B;\n  let Z = A.getTime() - G.getTime();\n  let Y = Math.trunc(Z / 1000);\n  let J = [{\n    unit: \"year\",\n    seconds: 31536000,\n    shortUnit: \"y\"\n  }, {\n    unit: \"month\",\n    seconds: 2592000,\n    shortUnit: \"mo\"\n  }, {\n    unit: \"week\",\n    seconds: 604800,\n    shortUnit: \"w\"\n  }, {\n    unit: \"day\",\n    seconds: 86400,\n    shortUnit: \"d\"\n  }, {\n    unit: \"hour\",\n    seconds: 3600,\n    shortUnit: \"h\"\n  }, {\n    unit: \"minute\",\n    seconds: 60,\n    shortUnit: \"m\"\n  }, {\n    unit: \"second\",\n    seconds: 1,\n    shortUnit: \"s\"\n  }];\n  for (let {\n    unit: W,\n    seconds: F,\n    shortUnit: C\n  } of J) {\n    if (Math.abs(Y) >= F) {\n      let V = Math.trunc(Y / F);\n      if (Q === \"narrow\") {\n        if (Y < 0) {\n          return `${Math.abs(V)}${C} ago`;\n        } else {\n          return `in ${V}${C}`;\n        }\n      }\n      return new Intl.RelativeTimeFormat(\"en\", {\n        style: \"long\",\n        numeric: I\n      }).format(V, W);\n    }\n  }\n  if (Q === \"narrow\") {\n    if (Y <= 0) {\n      return \"0s ago\";\n    } else {\n      return \"in 0s\";\n    }\n  }\n  return new Intl.RelativeTimeFormat(\"en\", {\n    style: Q,\n    numeric: I\n  }).format(0, \"second\");\n}\nfunction vh(A, B = {}) {\n  let {\n    now: Q = new Date(),\n    ...I\n  } = B;\n  if (A > Q) {\n    return vPA(A, {\n      ...I,\n      now: Q\n    });\n  }\n  return vPA(A, {\n    ...I,\n    numeric: \"always\",\n    now: Q\n  });\n}\nfunction pT(A, B = false) {\n  if (!A) {\n    return;\n  }\n  let Q = new Date(A * 1000);\n  let I = new Date();\n  let G = Q.getMinutes();\n  if ((Q.getTime() - I.getTime()) / 3600000 > 24) {\n    let X = {\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"numeric\",\n      minute: G === 0 ? undefined : \"2-digit\",\n      hour12: true\n    };\n    if (Q.getFullYear() !== I.getFullYear()) {\n      X.year = \"numeric\";\n    }\n    return Q.toLocaleString(\"en-US\", X).replace(/ ([AP]M)/i, (F, C) => C.toLowerCase()) + (B ? ` (${Intl.DateTimeFormat().resolvedOptions().timeZone})` : \"\");\n  }\n  let Y = Q.toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: G === 0 ? undefined : \"2-digit\",\n    hour12: true\n  });\n  let J = Intl.DateTimeFormat().resolvedOptions().timeZone;\n  return Y.replace(/ ([AP]M)/i, (X, W) => W.toLowerCase()) + (B ? ` (${J})` : \"\");\n}\nvar _______________initializeDevTools = z((fxI, py0) => {\n  var cy0 = EA(\"child_process\");\n  var uy0 = cy0.spawn;\n  var pd9 = cy0.exec;\n  py0.exports = function (A, B, Q) {\n    if (typeof B === \"function\" && Q === undefined) {\n      Q = B;\n      B = undefined;\n    }\n    A = parseInt(A);\n    if (Number.isNaN(A)) {\n      if (Q) {\n        return Q(Error(\"pid must be a number\"));\n      } else {\n        throw Error(\"pid must be a number\");\n      }\n    }\n    var I = {};\n    var G = {};\n    I[A] = [];\n    G[A] = 1;\n    switch (process.platform) {\n      case \"win32\":\n        pd9(\"taskkill /pid \" + A + \" /T /F\", Q);\n        break;\n      case \"darwin\":\n        pY1(A, I, G, function (Z) {\n          return uy0(\"pgrep\", [\"-P\", Z]);\n        }, function () {\n          my0(I, B, Q);\n        });\n        break;\n      default:\n        pY1(A, I, G, function (Z) {\n          return uy0(\"ps\", [\"-o\", \"pid\", \"--no-headers\", \"--ppid\", Z]);\n        }, function () {\n          my0(I, B, Q);\n        });\n        break;\n    }\n  };\n  function my0(A, B, Q) {\n    var I = {};\n    try {\n      Object.keys(A).forEach(function (G) {\n        A[G].forEach(function (Z) {\n          if (!I[Z]) {\n            dy0(Z, B);\n            I[Z] = 1;\n          }\n        });\n        if (!I[G]) {\n          dy0(G, B);\n          I[G] = 1;\n        }\n      });\n    } catch (G) {\n      if (Q) {\n        return Q(G);\n      } else {\n        throw G;\n      }\n    }\n    if (Q) {\n      return Q();\n    }\n  }\n  function dy0(A, B) {\n    try {\n      process.kill(parseInt(A, 10), B);\n    } catch (Q) {\n      if (Q.code !== \"ESRCH\") {\n        throw Q;\n      }\n    }\n  }\n  function pY1(A, B, Q, I, G) {\n    var Z = I(A);\n    var Y = \"\";\n    Z.stdout.on(\"data\", function (W) {\n      var W = W.toString(\"ascii\");\n      Y += W;\n    });\n    function J(X) {\n      delete Q[A];\n      if (X != 0) {\n        if (Object.keys(Q).length == 0) {\n          G();\n        }\n        return;\n      }\n      Y.match(/\\d+/g).forEach(function (W) {\n        W = parseInt(W, 10);\n        B[A].push(W);\n        B[W] = [];\n        Q[W] = 1;\n        pY1(W, B, Q, I, G);\n      });\n    }\n    Z.on(\"close\", J);\n  }\n});\nclass XJA {\n  capacity;\n  buffer;\n  head = 0;\n  size = 0;\n  constructor(A) {\n    this.capacity = A;\n    this.buffer = Array(A);\n  }\n  add(A) {\n    this.buffer[this.head] = A;\n    this.head = (this.head + 1) % this.capacity;\n    if (this.size < this.capacity) {\n      this.size++;\n    }\n  }\n  addAll(A) {\n    for (let B of A) {\n      this.add(B);\n    }\n  }\n  getRecent(A) {\n    let B = [];\n    let Q = this.size < this.capacity ? 0 : this.head;\n    let I = Math.min(A, this.size);\n    for (let G = 0; G < I; G++) {\n      let Z = (Q + this.size - I + G) % this.capacity;\n      B.push(this.buffer[Z]);\n    }\n    return B;\n  }\n  toArray() {\n    if (this.size === 0) {\n      return [];\n    }\n    let A = [];\n    let B = this.size < this.capacity ? 0 : this.head;\n    for (let Q = 0; Q < this.size; Q++) {\n      let I = (B + Q) % this.capacity;\n      A.push(this.buffer[I]);\n    }\n    return A;\n  }\n  clear() {\n    this.head = 0;\n    this.size = 0;\n  }\n  length() {\n    return this.size;\n  }\n}\nfunction lY1(A, B = \",\", Q = 67108736) {\n  let G = \"\";\n  for (let Z of A) {\n    let Y = G ? B : \"\";\n    let J = Y + Z;\n    if (G.length + J.length <= Q) {\n      G += J;\n    } else {\n      let X = Q - G.length - Y.length - 14;\n      if (X > 0) {\n        G += Y + Z.slice(0, X) + \"...[truncated]\";\n      } else {\n        G += \"...[truncated]\";\n      }\n      return G;\n    }\n  }\n  return G;\n}\nclass H0A {\n  maxSize;\n  content = \"\";\n  isTruncated = false;\n  totalBytesReceived = 0;\n  constructor(A = 67108736) {\n    this.maxSize = A;\n  }\n  append(A) {\n    let B = typeof A === \"string\" ? A : A.toString();\n    this.totalBytesReceived += B.length;\n    if (this.isTruncated && this.content.length >= this.maxSize) {\n      return;\n    }\n    if (this.content.length + B.length > this.maxSize) {\n      let Q = this.maxSize - this.content.length;\n      if (Q > 0) {\n        this.content += B.slice(0, Q);\n      }\n      this.isTruncated = true;\n    } else {\n      this.content += B;\n    }\n  }\n  toString() {\n    if (!this.isTruncated) {\n      return this.content;\n    }\n    let A = this.totalBytesReceived - this.maxSize;\n    let B = Math.round(A / 1024);\n    return `${this.content}\n... [output truncated - ${B}KB removed]`;\n  }\n  clear() {\n    this.content = \"\";\n    this.isTruncated = false;\n    this.totalBytesReceived = 0;\n  }\n  get length() {\n    return this.content.length;\n  }\n  get truncated() {\n    return this.isTruncated;\n  }\n  get totalBytes() {\n    return this.totalBytesReceived;\n  }\n}\nfunction iy0(A, B) {\n  if (A.length <= B) {\n    return A;\n  }\n  let Q = A.length - B;\n  let G = `\n\n... [tool result truncated - ${Math.round(Q / 1024)}KB removed]`;\n  return A.slice(0, B) + G;\n}\nimport { PassThrough as _____initializeRenderer } from \"stream\";\nfunction sy0(A) {\n  let B = null;\n  let Q = new H0A();\n  A.on(\"data\", G => {\n    if (B) {\n      B.write(G);\n    } else {\n      Q.append(G);\n    }\n  });\n  let I = () => Q.toString();\n  return {\n    get: I,\n    asStream() {\n      B = new _____initializeRenderer({\n        highWaterMark: 10485760\n      });\n      B.write(I());\n      Q.clear();\n      return B;\n    }\n  };\n}\nfunction bPA(A, B, Q, I, G = false) {\n  let Z = \"running\";\n  let Y;\n  let J = sy0(A.stdout);\n  let X = sy0(A.stderr);\n  if (I) {\n    let H = new XJA(1000);\n    let w = 0;\n    let L = N => {\n      let O = N.toString().split(`\n`).filter(k => k.trim());\n      H.addAll(O);\n      w += O.length;\n      let P = H.getRecent(5);\n      if (P.length > 0) {\n        I(lY1(P, `\n`), lY1(H.getRecent(100), `\n`), w);\n      }\n    };\n    A.stdout.on(\"data\", L);\n    A.stderr.on(\"data\", L);\n  }\n  let W = H => {\n    Z = \"killed\";\n    if (A.pid) {\n      ________________initializeDevTools.default(A.pid, \"SIGKILL\");\n    }\n  };\n  let F = null;\n  let C;\n  let V;\n  let K = H => {\n    if (Z === \"running\") {\n      Y = H;\n      Z = \"backgrounded\";\n      C();\n      return {\n        stdoutStream: J.asStream(),\n        stderrStream: X.asStream()\n      };\n    }\n    return null;\n  };\n  let D = new Promise(H => {\n    let w = () => W();\n    C = () => {\n      if (F) {\n        clearTimeout(F);\n        F = null;\n      }\n      B.removeEventListener(\"abort\", w);\n    };\n    B.addEventListener(\"abort\", w, {\n      once: true\n    });\n    new Promise(L => {\n      let N = W;\n      W = $ => {\n        N();\n        L($ || ________________________initializeDevToolsConnection);\n      };\n      F = setTimeout(() => {\n        if (G && V) {\n          V(K);\n        } else {\n          W(_________________________initializeDevToolsConnection);\n        }\n      }, Q);\n      A.on(\"close\", ($, O) => {\n        L($ ?? (O === \"SIGTERM\" ? 144 : 1));\n      });\n      A.on(\"error\", () => L(1));\n    }).then(L => {\n      C();\n      if (Z === \"running\" || Z === \"backgrounded\") {\n        Z = \"completed\";\n      }\n      let N = {\n        code: L,\n        stdout: J.get(),\n        stderr: X.get(),\n        interrupted: L === ________________________initializeDevToolsConnection,\n        backgroundTaskId: Y\n      };\n      if (L === _________________________initializeDevToolsConnection) {\n        N.stderr = [`Command timed out after ${KU(Q)}`, N.stderr].filter(Boolean).join(\" \");\n      }\n      H(N);\n    });\n  });\n  let E = {\n    get status() {\n      return Z;\n    },\n    background: K,\n    kill: () => W(),\n    result: D\n  };\n  if (G) {\n    E.onTimeout = H => {\n      V = H;\n    };\n  }\n  return E;\n}\nfunction oy0(A) {\n  return {\n    get status() {\n      return \"killed\";\n    },\n    background: () => null,\n    kill: () => {},\n    result: Promise.resolve({\n      code: 145,\n      stdout: \"\",\n      stderr: \"Command aborted before execution\",\n      interrupted: true,\n      backgroundTaskId: A\n    })\n  };\n}\nvar ________________initializeDevTools;\nvar ________________________initializeDevToolsConnection = 137;\nvar _________________________initializeDevToolsConnection = 143;\nvar iY1 = T(() => {\n  ________________initializeDevTools = IA(_______________initializeDevTools(), 1);\n});\nfunction fPA(A, B) {\n  let Q = A.lastIndexOf(\" -\");\n  if (Q > 0) {\n    let I = A.substring(0, Q);\n    let G = A.substring(Q + 1);\n    return `${q8([I])} ${G} ${q8([B])}`;\n  } else {\n    return `${q8([A])} ${q8([B])}`;\n  }\n}\nvar _devToolsInitializationHandler = T(() => {\n  $D();\n});\nimport { readFileSync as __________________________initializeDevToolsConnection, existsSync as initializeRendererComponent, mkdirSync as ___________________________initializeDevToolsConnection, readdirSync as _________________initializeDevTools } from \"node:fs\";\nimport { join as ______initializeRenderer } from \"node:path\";\nfunction ty0() {\n  let A = ______initializeRenderer(mB(), \"session-env\", L0());\n  ___________________________initializeDevToolsConnection(A, {\n    recursive: true\n  });\n  return A;\n}\nfunction ey0(A) {\n  return ______initializeRenderer(ty0(), `hook-${A}.sh`);\n}\nfunction Ak0() {\n  g(\"Invalidating session environment cache\");\n  insertIndex = undefined;\n}\nfunction Bk0() {\n  if (EB() === \"windows\") {\n    g(\"Session environment not yet supported on Windows\");\n    return null;\n  }\n  if (insertIndex !== undefined) {\n    return insertIndex;\n  }\n  let A = ty0();\n  if (!initializeRendererComponent(A)) {\n    g(\"No session environment directory found\");\n    insertIndex = null;\n    return insertIndex;\n  }\n  try {\n    let Q = _________________initializeDevTools(A).filter(G => G.startsWith(\"hook-\") && G.endsWith(\".sh\")).sort((G, Z) => {\n      let Y = parseInt(G.match(/hook-(\\d+)\\.sh/)?.[1] || \"0\", 10);\n      let J = parseInt(Z.match(/hook-(\\d+)\\.sh/)?.[1] || \"0\", 10);\n      return Y - J;\n    });\n    if (Q.length === 0) {\n      g(\"No hook environment files found\");\n      insertIndex = null;\n      return insertIndex;\n    }\n    insertIndex = Q.map(G => {\n      let Z = ______initializeRenderer(A, G);\n      return __________________________initializeDevToolsConnection(Z, \"utf8\").trim();\n    }).join(`\n`);\n    g(`Session environment loaded from ${Q.length} hook file(s) (${insertIndex.length} chars)`);\n    return insertIndex;\n  } catch (B) {\n    g(`Failed to load session environment: ${B instanceof Error ? B.message : String(B)}`);\n    insertIndex = null;\n    return insertIndex;\n  }\n}\nvar insertIndex = undefined;\nvar setupDevToolsConnection = T(() => {\n  C0();\n  E5();\n  vB();\n  i0();\n});\nfunction bh({\n  isFocused: A,\n  isSelected: B,\n  children: Q,\n  description: I,\n  shouldShowDownArrow: G,\n  shouldShowUpArrow: Z\n}) {\n  return getLeftPadding.default.createElement(__processAndDisplayNodes, {\n    flexDirection: \"column\"\n  }, getLeftPadding.default.createElement(__processAndDisplayNodes, {\n    flexDirection: \"row\",\n    gap: 1\n  }, A ? getLeftPadding.default.createElement(U, {\n    color: \"suggestion\"\n  }, E1.pointer) : G ? getLeftPadding.default.createElement(U, {\n    dimColor: true\n  }, E1.arrowDown) : Z ? getLeftPadding.default.createElement(U, {\n    dimColor: true\n  }, E1.arrowUp) : getLeftPadding.default.createElement(U, null, \" \"), Q, B && getLeftPadding.default.createElement(U, {\n    color: \"success\"\n  }, E1.tick)), I && getLeftPadding.default.createElement(__processAndDisplayNodes, {\n    paddingLeft: 5\n  }, getLeftPadding.default.createElement(U, {\n    color: \"inactive\"\n  }, I)));\n}\nvar getLeftPadding;\nvar gPA = T(() => {\n  s2();\n  nA();\n  getLeftPadding = IA(KA(), 1);\n});\nvar updateParentAttributes;\nvar calculateObjectDifference = T(() => {\n  updateParentAttributes = class uPA extends Map {\n    first;\n    last;\n    constructor(A) {\n      let B = [];\n      let Q;\n      let I;\n      let G;\n      let Z = 0;\n      for (let Y of A) {\n        let J = {\n          label: Y.label,\n          value: Y.value,\n          description: Y.description,\n          previous: G,\n          next: undefined,\n          index: Z\n        };\n        if (G) {\n          G.next = J;\n        }\n        Q ||= J;\n        I = J;\n        B.push([Y.value, J]);\n        Z++;\n        G = J;\n      }\n      super(B);\n      this.first = Q;\n      this.last = I;\n    }\n  };\n});\nimport { isDeepStrictEqual as __________________initializeDevTools } from \"node:util\";\nfunction mPA({\n  visibleOptionCount: A = 5,\n  options: B,\n  initialFocusValue: Q,\n  onFocus: I,\n  focusValue: G\n}) {\n  let [Z, Y] = initializeRendering.useReducer(initializeDevToolsFromConnection, {\n    visibleOptionCount: A,\n    options: B,\n    initialFocusValue: G || Q\n  }, Ik0);\n  let [J, X] = initializeRendering.useState(B);\n  if (B !== J && !__________________initializeDevTools(B, J)) {\n    Y({\n      type: \"reset\",\n      state: Ik0({\n        visibleOptionCount: A,\n        options: B,\n        initialFocusValue: G ?? Z.focusedValue ?? Q,\n        currentViewport: {\n          visibleFromIndex: Z.visibleFromIndex,\n          visibleToIndex: Z.visibleToIndex\n        }\n      })\n    });\n    X(B);\n  }\n  let W = initializeRendering.useCallback(() => {\n    Y({\n      type: \"focus-next-option\"\n    });\n  }, []);\n  let F = initializeRendering.useCallback(() => {\n    Y({\n      type: \"focus-previous-option\"\n    });\n  }, []);\n  let C = initializeRendering.useCallback(() => {\n    Y({\n      type: \"focus-next-page\"\n    });\n  }, []);\n  let V = initializeRendering.useCallback(() => {\n    Y({\n      type: \"focus-previous-page\"\n    });\n  }, []);\n  let K = initializeRendering.useCallback(H => {\n    if (H !== undefined) {\n      Y({\n        type: \"set-focus\",\n        value: H\n      });\n    }\n  }, []);\n  let D = initializeRendering.useMemo(() => {\n    return B.map((H, w) => ({\n      ...H,\n      index: w\n    })).slice(Z.visibleFromIndex, Z.visibleToIndex);\n  }, [B, Z.visibleFromIndex, Z.visibleToIndex]);\n  initializeRendering.useEffect(() => {\n    if (Z.focusedValue !== undefined) {\n      I?.(Z.focusedValue);\n    }\n  }, [Z.focusedValue, I]);\n  initializeRendering.useEffect(() => {\n    if (G !== undefined) {\n      Y({\n        type: \"set-focus\",\n        value: G\n      });\n    }\n  }, [G]);\n  let E = initializeRendering.useMemo(() => {\n    return B.find(w => w.value === Z.focusedValue)?.type === \"input\";\n  }, [Z.focusedValue, B]);\n  return {\n    focusedValue: Z.focusedValue,\n    visibleFromIndex: Z.visibleFromIndex,\n    visibleToIndex: Z.visibleToIndex,\n    visibleOptions: D,\n    isInInput: E ?? false,\n    focusNextOption: W,\n    focusPreviousOption: F,\n    focusNextPage: C,\n    focusPreviousPage: V,\n    focusOption: K,\n    options: B\n  };\n}\nvar initializeRendering;\nvar initializeDevToolsFromConnection = (A, B) => {\n  switch (B.type) {\n    case \"focus-next-option\":\n      {\n        if (A.focusedValue === undefined) {\n          return A;\n        }\n        let focusedOption = A.optionMap.get(A.focusedValue);\n        if (!focusedOption) {\n          return A;\n        }\n        let nextOption = focusedOption.next || A.optionMap.first;\n        if (!nextOption) {\n          return A;\n        }\n        if (!focusedOption.next && nextOption === A.optionMap.first) {\n          return {\n            ...A,\n            focusedValue: nextOption.value,\n            visibleFromIndex: 0,\n            visibleToIndex: A.visibleOptionCount\n          };\n        }\n        if (!(nextOption.index >= A.visibleToIndex)) {\n          return {\n            ...A,\n            focusedValue: nextOption.value\n          };\n        }\n        let nextVisibleOptionCount = Math.min(A.optionMap.size, A.visibleToIndex + 1);\n        let visibleToIndexLimit = nextVisibleOptionCount - A.visibleOptionCount;\n        return {\n          ...A,\n          focusedValue: nextOption.value,\n          visibleFromIndex: visibleToIndexLimit,\n          visibleToIndex: nextVisibleOptionCount\n        };\n      }\n    case \"focus-previous-option\":\n      {\n        if (A.focusedValue === undefined) {\n          return A;\n        }\n        let ___focusedOption = A.optionMap.get(A.focusedValue);\n        if (!___focusedOption) {\n          return A;\n        }\n        let nextFocusedOption = ___focusedOption.previous || A.optionMap.last;\n        if (!nextFocusedOption) {\n          return A;\n        }\n        if (!___focusedOption.previous && nextFocusedOption === A.optionMap.last) {\n          let totalOptionsCount = A.optionMap.size;\n          let focusOptionHandler = Math.max(0, totalOptionsCount - A.visibleOptionCount);\n          return {\n            ...A,\n            focusedValue: nextFocusedOption.value,\n            visibleFromIndex: focusOptionHandler,\n            visibleToIndex: totalOptionsCount\n          };\n        }\n        if (!(nextFocusedOption.index <= A.visibleFromIndex)) {\n          return {\n            ...A,\n            focusedValue: nextFocusedOption.value\n          };\n        }\n        let _visibleToIndexLimit = Math.max(0, A.visibleFromIndex - 1);\n        let visibleOptionStart = _visibleToIndexLimit + A.visibleOptionCount;\n        return {\n          ...A,\n          focusedValue: nextFocusedOption.value,\n          visibleFromIndex: _visibleToIndexLimit,\n          visibleToIndex: visibleOptionStart\n        };\n      }\n    case \"focus-next-page\":\n      {\n        if (A.focusedValue === undefined) {\n          return A;\n        }\n        let ______focusedOption = A.optionMap.get(A.focusedValue);\n        if (!______focusedOption) {\n          return A;\n        }\n        let ________focusedOption = Math.min(A.optionMap.size - 1, ______focusedOption.index + A.visibleOptionCount);\n        let currentOption = A.optionMap.first;\n        while (currentOption && currentOption.index < ________focusedOption) {\n          if (currentOption.next) {\n            currentOption = currentOption.next;\n          } else {\n            break;\n          }\n        }\n        if (!currentOption) {\n          return A;\n        }\n        let __visibleToIndexLimit = Math.min(A.optionMap.size, currentOption.index + 1);\n        let visibleToIndexAdjustment = Math.max(0, __visibleToIndexLimit - A.visibleOptionCount);\n        return {\n          ...A,\n          focusedValue: currentOption.value,\n          visibleFromIndex: visibleToIndexAdjustment,\n          visibleToIndex: __visibleToIndexLimit\n        };\n      }\n    case \"focus-previous-page\":\n      {\n        if (A.focusedValue === undefined) {\n          return A;\n        }\n        let _________focusedOption = A.optionMap.get(A.focusedValue);\n        if (!_________focusedOption) {\n          return A;\n        }\n        let I = Math.max(0, _________focusedOption.index - A.visibleOptionCount);\n        let G = A.optionMap.first;\n        while (G && G.index < I) {\n          if (G.next) {\n            G = G.next;\n          } else {\n            break;\n          }\n        }\n        if (!G) {\n          return A;\n        }\n        let Z = Math.max(0, G.index);\n        let Y = Math.min(A.optionMap.size, Z + A.visibleOptionCount);\n        return {\n          ...A,\n          focusedValue: G.value,\n          visibleFromIndex: Z,\n          visibleToIndex: Y\n        };\n      }\n    case \"reset\":\n      return B.state;\n    case \"set-focus\":\n      {\n        let Q = A.optionMap.get(B.value);\n        if (!Q) {\n          return A;\n        }\n        if (Q.index >= A.visibleFromIndex && Q.index < A.visibleToIndex) {\n          return {\n            ...A,\n            focusedValue: B.value\n          };\n        }\n        let I;\n        let G;\n        if (Q.index < A.visibleFromIndex) {\n          I = Q.index;\n          G = Math.min(A.optionMap.size, I + A.visibleOptionCount);\n        } else {\n          G = Math.min(A.optionMap.size, Q.index + 1);\n          I = Math.max(0, G - A.visibleOptionCount);\n        }\n        return {\n          ...A,\n          focusedValue: B.value,\n          visibleFromIndex: I,\n          visibleToIndex: G\n        };\n      }\n  }\n};\nvar Ik0 = ({\n  visibleOptionCount: A,\n  options: B,\n  initialFocusValue: Q,\n  currentViewport: I\n}) => {\n  let G = typeof A === \"number\" ? Math.min(A, B.length) : B.length;\n  let Z = new updateParentAttributes(B);\n  let Y = Q !== undefined && Z.get(Q);\n  let J = Y ? Q : Z.first?.value;\n  let X = 0;\n  let W = G;\n  if (Y && I) {\n    let F = Y.index;\n    if (F >= I.visibleFromIndex && F < I.visibleToIndex) {\n      X = I.visibleFromIndex;\n      W = Math.min(Z.size, I.visibleToIndex);\n    } else if (F < I.visibleFromIndex) {\n      X = F;\n      W = Math.min(Z.size, X + G);\n    } else {\n      W = Math.min(Z.size, F + 1);\n      X = Math.max(0, W - G);\n    }\n    X = Math.max(0, Math.min(X, Z.size - 1));\n    W = Math.min(Z.size, Math.max(G, W));\n  }\n  return {\n    optionMap: Z,\n    visibleOptionCount: G,\n    focusedValue: J,\n    visibleFromIndex: X,\n    visibleToIndex: W\n  };\n};\nvar sY1 = T(() => {\n  calculateObjectDifference();\n  initializeRendering = IA(KA(), 1);\n});\nfunction Gk0({\n  visibleOptionCount: A = 5,\n  options: B,\n  defaultValue: Q,\n  onChange: I,\n  onCancel: G,\n  onFocus: Z,\n  focusValue: Y\n}) {\n  let [J, X] = addDevicePixelDensity.useState(Q);\n  let W = mPA({\n    visibleOptionCount: A,\n    options: B,\n    initialFocusValue: undefined,\n    onFocus: Z,\n    focusValue: Y\n  });\n  let F = addDevicePixelDensity.useCallback(() => {\n    X(W.focusedValue);\n  }, [W.focusedValue]);\n  return {\n    ...W,\n    value: J,\n    selectFocusedOption: F,\n    onChange: I,\n    onCancel: G\n  };\n}\nvar addDevicePixelDensity;\nvar Zk0 = T(() => {\n  sY1();\n  addDevicePixelDensity = IA(KA(), 1);\n});\nvar Yk0 = ({\n  isDisabled: A = false,\n  disableSelection: B = false,\n  state: Q,\n  options: I,\n  isMultiSelect: G = false\n}) => {\n  renderAndSetupComponent((Z, Y) => {\n    if (I.find(W => W.value === Q.focusedValue)?.type === \"input\") {\n      if (!Y.upArrow && !Y.downArrow && !Y.escape && (!Y.ctrl || Z !== \"n\" && Z !== \"p\")) {\n        return;\n      }\n    }\n    if (Y.downArrow || Y.ctrl && Z === \"n\" || !Y.ctrl && !Y.shift && Z === \"j\") {\n      Q.focusNextOption();\n    }\n    if (Y.upArrow || Y.ctrl && Z === \"p\" || !Y.ctrl && !Y.shift && Z === \"k\") {\n      Q.focusPreviousOption();\n    }\n    if (Y.pageDown) {\n      Q.focusNextPage();\n    }\n    if (Y.pageUp) {\n      Q.focusPreviousPage();\n    }\n    if (B !== true) {\n      if ((G ? Y.return || Z === \" \" : Y.return) && Q.focusedValue !== undefined) {\n        Q.selectFocusedOption?.();\n        Q.onChange?.(Q.focusedValue);\n      }\n      if (B !== \"numeric\" && /^[0-9]+$/.test(Z)) {\n        let F = parseInt(Z) - 1;\n        if (F >= 0 && F < Q.options.length) {\n          let C = Q.options[F];\n          if (C.type === \"input\") {\n            Q.focusOption(C.value);\n            return;\n          }\n          Q.onChange?.(C.value);\n          return;\n        }\n      }\n    }\n    if (Y.escape) {\n      Q.onCancel?.();\n    }\n  }, {\n    isActive: !A\n  });\n};\nvar Jk0 = T(() => {\n  nA();\n});\nclass vI {\n  measuredText;\n  selection;\n  offset;\n  constructor(A, B = 0, Q = 0) {\n    this.measuredText = A;\n    this.selection = Q;\n    this.offset = Math.max(0, Math.min(this.text.length, B));\n  }\n  static fromText(A, B, Q = 0, I = 0) {\n    return new vI(new Xk0(A, B - 1), Q, I);\n  }\n  render(A, B, Q) {\n    let {\n      line: I,\n      column: G\n    } = this.getPosition();\n    return this.measuredText.getWrappedText().map((Z, Y, J) => {\n      let X = Z;\n      if (B && Y === J.length - 1) {\n        let E = Math.max(0, Z.length - 6);\n        X = B.repeat(E) + Z.slice(E);\n      }\n      if (I !== Y) {\n        return X.trimEnd();\n      }\n      let W = this.measuredText.displayWidthToStringIndex(X, G);\n      let F = Array.from(initializeRenderTree.segment(X)).map(({\n        segment: E,\n        index: H\n      }) => ({\n        segment: E,\n        index: H\n      }));\n      let C = \"\";\n      let V = A;\n      let K = \"\";\n      for (let {\n        segment: E,\n        index: H\n      } of F) {\n        let w = H + E.length;\n        if (w <= W) {\n          C += E;\n        } else if (H < W && w > W) {\n          V = E;\n        } else if (H === W) {\n          V = E;\n        } else {\n          K += E;\n        }\n      }\n      let D = A ? Q(V) : V;\n      return C + D + K.trimEnd();\n    }).join(`\n`);\n  }\n  left() {\n    if (this.offset === 0) {\n      return this;\n    }\n    let A = this.measuredText.prevOffset(this.offset);\n    return new vI(this.measuredText, A);\n  }\n  right() {\n    if (this.offset >= this.text.length) {\n      return this;\n    }\n    let A = this.measuredText.nextOffset(this.offset);\n    return new vI(this.measuredText, Math.min(A, this.text.length));\n  }\n  up() {\n    let {\n      line: A,\n      column: B\n    } = this.getPosition();\n    if (A === 0) {\n      return this;\n    }\n    let Q = this.measuredText.getWrappedText()[A - 1];\n    if (!Q) {\n      return this;\n    }\n    let I = k7(Q);\n    if (B > I) {\n      let Z = this.getOffset({\n        line: A - 1,\n        column: I\n      });\n      return new vI(this.measuredText, Z, 0);\n    }\n    let G = this.getOffset({\n      line: A - 1,\n      column: B\n    });\n    return new vI(this.measuredText, G, 0);\n  }\n  down() {\n    let {\n      line: A,\n      column: B\n    } = this.getPosition();\n    if (A >= this.measuredText.lineCount - 1) {\n      return this;\n    }\n    let Q = this.measuredText.getWrappedText()[A + 1];\n    if (!Q) {\n      return this;\n    }\n    let I = k7(Q);\n    if (B > I) {\n      let Z = this.getOffset({\n        line: A + 1,\n        column: I\n      });\n      return new vI(this.measuredText, Z, 0);\n    }\n    let G = this.getOffset({\n      line: A + 1,\n      column: B\n    });\n    return new vI(this.measuredText, G, 0);\n  }\n  startOfLine() {\n    let {\n      line: A\n    } = this.getPosition();\n    return new vI(this.measuredText, this.getOffset({\n      line: A,\n      column: 0\n    }), 0);\n  }\n  firstNonBlankInLine() {\n    let {\n      line: A\n    } = this.getPosition();\n    let Q = (this.measuredText.getWrappedText()[A] || \"\").match(/^\\s*\\S/);\n    let I = Q?.index ? Q.index + Q[0].length - 1 : 0;\n    let G = this.getOffset({\n      line: A,\n      column: I\n    });\n    return new vI(this.measuredText, G, 0);\n  }\n  endOfLine() {\n    let {\n      line: A\n    } = this.getPosition();\n    let B = this.measuredText.getLineLength(A);\n    let Q = this.getOffset({\n      line: A,\n      column: B\n    });\n    return new vI(this.measuredText, Q, 0);\n  }\n  findLogicalLineStart(A = this.offset) {\n    let B = this.text.lastIndexOf(`\n`, A - 1);\n    if (B === -1) {\n      return 0;\n    } else {\n      return B + 1;\n    }\n  }\n  findLogicalLineEnd(A = this.offset) {\n    let B = this.text.indexOf(`\n`, A);\n    if (B === -1) {\n      return this.text.length;\n    } else {\n      return B;\n    }\n  }\n  getLogicalLineBounds() {\n    return {\n      start: this.findLogicalLineStart(),\n      end: this.findLogicalLineEnd()\n    };\n  }\n  createCursorWithColumn(A, B, Q) {\n    let I = B - A;\n    let G = Math.min(Q, I);\n    return new vI(this.measuredText, A + G, 0);\n  }\n  endOfLogicalLine() {\n    return new vI(this.measuredText, this.findLogicalLineEnd(), 0);\n  }\n  startOfLogicalLine() {\n    return new vI(this.measuredText, this.findLogicalLineStart(), 0);\n  }\n  firstNonBlankInLogicalLine() {\n    let {\n      start: A,\n      end: B\n    } = this.getLogicalLineBounds();\n    let I = this.text.slice(A, B).match(/\\S/);\n    let G = A + (I?.index ?? 0);\n    return new vI(this.measuredText, G, 0);\n  }\n  upLogicalLine() {\n    let {\n      start: A\n    } = this.getLogicalLineBounds();\n    if (A === 0) {\n      return new vI(this.measuredText, 0, 0);\n    }\n    let B = this.offset - A;\n    let Q = A - 1;\n    let I = this.findLogicalLineStart(Q);\n    return this.createCursorWithColumn(I, Q, B);\n  }\n  downLogicalLine() {\n    let {\n      start: A,\n      end: B\n    } = this.getLogicalLineBounds();\n    if (B >= this.text.length) {\n      return new vI(this.measuredText, this.text.length, 0);\n    }\n    let Q = this.offset - A;\n    let I = B + 1;\n    let G = this.findLogicalLineEnd(I);\n    return this.createCursorWithColumn(I, G, Q);\n  }\n  nextWord() {\n    let A = this;\n    while (A.isOverWordChar() && !A.isAtEnd()) {\n      A = A.right();\n    }\n    while (!A.isOverWordChar() && !A.isAtEnd()) {\n      A = A.right();\n    }\n    return A;\n  }\n  endOfWord() {\n    let A = this;\n    if (A.isOverWordChar() && (!A.right().isOverWordChar() || A.right().isAtEnd())) {\n      A = A.right();\n      return A.endOfWord();\n    }\n    if (!A.isOverWordChar()) {\n      A = A.nextWord();\n    }\n    while (A.right().isOverWordChar() && !A.isAtEnd()) {\n      A = A.right();\n    }\n    return A;\n  }\n  prevWord() {\n    let A = this;\n    if (!A.left().isOverWordChar()) {\n      A = A.left();\n    }\n    while (!A.isOverWordChar() && !A.isAtStart()) {\n      A = A.left();\n    }\n    if (A.isOverWordChar()) {\n      while (A.left().isOverWordChar() && !A.isAtStart()) {\n        A = A.left();\n      }\n    }\n    return A;\n  }\n  nextWORD() {\n    let A = this;\n    while (!A.isOverWhitespace() && !A.isAtEnd()) {\n      A = A.right();\n    }\n    while (A.isOverWhitespace() && !A.isAtEnd()) {\n      A = A.right();\n    }\n    return A;\n  }\n  endOfWORD() {\n    let A = this;\n    if (!A.isOverWhitespace() && (A.right().isOverWhitespace() || A.right().isAtEnd())) {\n      A = A.right();\n      return A.endOfWORD();\n    }\n    if (A.isOverWhitespace()) {\n      A = A.nextWORD();\n    }\n    while (!A.right().isOverWhitespace() && !A.isAtEnd()) {\n      A = A.right();\n    }\n    return A;\n  }\n  prevWORD() {\n    let A = this;\n    if (A.left().isOverWhitespace()) {\n      A = A.left();\n    }\n    while (A.isOverWhitespace() && !A.isAtStart()) {\n      A = A.left();\n    }\n    if (!A.isOverWhitespace()) {\n      while (!A.left().isOverWhitespace() && !A.isAtStart()) {\n        A = A.left();\n      }\n    }\n    return A;\n  }\n  modifyText(A, B = \"\") {\n    let Q = this.offset;\n    let I = A.offset;\n    let G = this.text.slice(0, Q) + B + this.text.slice(I);\n    return vI.fromText(G, this.columns, Q + B.normalize(\"NFC\").length);\n  }\n  insert(A) {\n    return this.modifyText(this, A);\n  }\n  del() {\n    if (this.isAtEnd()) {\n      return this;\n    }\n    return this.modifyText(this.right());\n  }\n  backspace() {\n    if (this.isAtStart()) {\n      return this;\n    }\n    return this.left().modifyText(this);\n  }\n  deleteToLineStart() {\n    return this.startOfLine().modifyText(this);\n  }\n  deleteToLineEnd() {\n    if (this.text[this.offset] === `\n`) {\n      return this.modifyText(this.right());\n    }\n    return this.modifyText(this.endOfLine());\n  }\n  deleteToLogicalLineEnd() {\n    if (this.text[this.offset] === `\n`) {\n      return this.modifyText(this.right());\n    }\n    return this.modifyText(this.endOfLogicalLine());\n  }\n  deleteWordBefore() {\n    if (this.isAtStart()) {\n      return this;\n    }\n    return this.prevWord().modifyText(this);\n  }\n  deleteWordAfter() {\n    if (this.isAtEnd()) {\n      return this;\n    }\n    return this.modifyText(this.nextWord());\n  }\n  isOverWordChar() {\n    let A = this.text[this.offset] ?? \"\";\n    return /\\w/.test(A);\n  }\n  isOverWhitespace() {\n    let A = this.text[this.offset] ?? \"\";\n    return /\\s/.test(A);\n  }\n  equals(A) {\n    return this.offset === A.offset && this.measuredText === A.measuredText;\n  }\n  isAtStart() {\n    return this.offset === 0;\n  }\n  isAtEnd() {\n    return this.offset >= this.text.length;\n  }\n  startOfFirstLine() {\n    return new vI(this.measuredText, 0, 0);\n  }\n  startOfLastLine() {\n    let A = this.text.lastIndexOf(`\n`);\n    if (A === -1) {\n      return this.startOfLine();\n    }\n    return new vI(this.measuredText, A + 1, 0);\n  }\n  get text() {\n    return this.measuredText.text;\n  }\n  get columns() {\n    return this.measuredText.columns + 1;\n  }\n  getPosition() {\n    return this.measuredText.getPositionFromOffset(this.offset);\n  }\n  getOffset(A) {\n    return this.measuredText.getOffsetFromPosition(A);\n  }\n}\nclass cPA {\n  text;\n  startOffset;\n  isPrecededByNewline;\n  endsWithNewline;\n  constructor(A, B, Q, I = false) {\n    this.text = A;\n    this.startOffset = B;\n    this.isPrecededByNewline = Q;\n    this.endsWithNewline = I;\n  }\n  equals(A) {\n    return this.text === A.text && this.startOffset === A.startOffset;\n  }\n  get length() {\n    return this.text.length + (this.endsWithNewline ? 1 : 0);\n  }\n}\nclass Xk0 {\n  columns;\n  _wrappedLines;\n  text;\n  navigationCache;\n  graphemeBoundaries;\n  constructor(A, B) {\n    this.columns = B;\n    this.text = A.normalize(\"NFC\");\n    this.navigationCache = new Map();\n  }\n  get wrappedLines() {\n    if (!this._wrappedLines) {\n      this._wrappedLines = this.measureWrappedText();\n    }\n    return this._wrappedLines;\n  }\n  getGraphemeBoundaries() {\n    if (!this.graphemeBoundaries) {\n      this.graphemeBoundaries = [];\n      for (let {\n        index: A\n      } of initializeRenderTree.segment(this.text)) {\n        this.graphemeBoundaries.push(A);\n      }\n      this.graphemeBoundaries.push(this.text.length);\n    }\n    return this.graphemeBoundaries;\n  }\n  binarySearchBoundary(A, B, Q) {\n    let I = 0;\n    let G = A.length - 1;\n    let Z = Q ? this.text.length : 0;\n    while (I <= G) {\n      let Y = Math.floor((I + G) / 2);\n      let J = A[Y];\n      if (J === undefined) {\n        break;\n      }\n      if (Q) {\n        if (J > B) {\n          Z = J;\n          G = Y - 1;\n        } else {\n          I = Y + 1;\n        }\n      } else if (J < B) {\n        Z = J;\n        I = Y + 1;\n      } else {\n        G = Y - 1;\n      }\n    }\n    return Z;\n  }\n  stringIndexToDisplayWidth(A, B) {\n    if (B <= 0) {\n      return 0;\n    }\n    if (B >= A.length) {\n      return k7(A);\n    }\n    return k7(A.substring(0, B));\n  }\n  displayWidthToStringIndex(A, B) {\n    if (B <= 0) {\n      return 0;\n    }\n    if (!A) {\n      return 0;\n    }\n    if (A === this.text) {\n      return this.offsetAtDisplayWidth(B);\n    }\n    let Q = 0;\n    let I = 0;\n    for (let {\n      segment: G,\n      index: Z\n    } of initializeRenderTree.segment(A)) {\n      let Y = k7(G);\n      if (Q + Y > B) {\n        break;\n      }\n      Q += Y;\n      I = Z + G.length;\n    }\n    return I;\n  }\n  offsetAtDisplayWidth(A) {\n    if (A <= 0) {\n      return 0;\n    }\n    let B = 0;\n    let Q = this.getGraphemeBoundaries();\n    for (let I = 0; I < Q.length - 1; I++) {\n      let G = Q[I];\n      let Z = Q[I + 1];\n      if (G === undefined || Z === undefined) {\n        continue;\n      }\n      let Y = this.text.substring(G, Z);\n      let J = k7(Y);\n      if (B + J > A) {\n        return G;\n      }\n      B += J;\n    }\n    return this.text.length;\n  }\n  measureWrappedText() {\n    let A = V0A(this.text, this.columns, {\n      hard: true,\n      trim: false\n    });\n    let B = [];\n    let Q = 0;\n    let I = -1;\n    let G = A.split(`\n`);\n    for (let Z = 0; Z < G.length; Z++) {\n      let Y = G[Z];\n      let J = X => Z === 0 || X > 0 && this.text[X - 1] === `\n`;\n      if (Y.length === 0) {\n        I = this.text.indexOf(`\n`, I + 1);\n        if (I !== -1) {\n          let X = I;\n          let W = true;\n          B.push(new cPA(Y, X, J(X), true));\n        } else {\n          let X = this.text.length;\n          B.push(new cPA(Y, X, J(X), false));\n        }\n      } else {\n        let X = this.text.indexOf(Y, Q);\n        if (X === -1) {\n          throw Error(\"Failed to find wrapped line in text\");\n        }\n        Q = X + Y.length;\n        let W = X + Y.length;\n        let F = W < this.text.length && this.text[W] === `\n`;\n        if (F) {\n          I = W;\n        }\n        B.push(new cPA(Y, X, J(X), F));\n      }\n    }\n    return B;\n  }\n  getWrappedText() {\n    return this.wrappedLines.map(A => A.isPrecededByNewline ? A.text : A.text.trimStart());\n  }\n  getWrappedLines() {\n    return this.wrappedLines;\n  }\n  getLine(A) {\n    let B = this.wrappedLines;\n    return B[Math.max(0, Math.min(A, B.length - 1))];\n  }\n  getOffsetFromPosition(A) {\n    let B = this.getLine(A.line);\n    if (B.text.length === 0 && B.endsWithNewline) {\n      return B.startOffset;\n    }\n    let Q = B.isPrecededByNewline ? 0 : B.text.length - B.text.trimStart().length;\n    let I = A.column + Q;\n    let G = this.displayWidthToStringIndex(B.text, I);\n    let Z = B.startOffset + G;\n    let Y = B.startOffset + B.text.length;\n    let J = Y;\n    let X = k7(B.text);\n    if (B.endsWithNewline && A.column > X) {\n      J = Y + 1;\n    }\n    return Math.min(Z, J);\n  }\n  getLineLength(A) {\n    let B = this.getLine(A);\n    return k7(B.text);\n  }\n  getPositionFromOffset(A) {\n    let B = this.wrappedLines;\n    for (let G = 0; G < B.length; G++) {\n      let Z = B[G];\n      let Y = B[G + 1];\n      if (A >= Z.startOffset && (!Y || A < Y.startOffset)) {\n        let J = A - Z.startOffset;\n        let X;\n        if (Z.isPrecededByNewline) {\n          X = this.stringIndexToDisplayWidth(Z.text, J);\n        } else {\n          let W = Z.text.length - Z.text.trimStart().length;\n          if (J < W) {\n            X = 0;\n          } else {\n            let F = Z.text.trimStart();\n            let C = J - W;\n            X = this.stringIndexToDisplayWidth(F, C);\n          }\n        }\n        return {\n          line: G,\n          column: Math.max(0, X)\n        };\n      }\n    }\n    let Q = B.length - 1;\n    let I = this.wrappedLines[Q];\n    return {\n      line: Q,\n      column: k7(I.text)\n    };\n  }\n  get lineCount() {\n    return this.wrappedLines.length;\n  }\n  withCache(A, B) {\n    let Q = this.navigationCache.get(A);\n    if (Q !== undefined) {\n      return Q;\n    }\n    let I = B();\n    this.navigationCache.set(A, I);\n    return I;\n  }\n  nextOffset(A) {\n    return this.withCache(`next:${A}`, () => {\n      let B = this.getGraphemeBoundaries();\n      return this.binarySearchBoundary(B, A, true);\n    });\n  }\n  prevOffset(A) {\n    if (A <= 0) {\n      return 0;\n    }\n    return this.withCache(`prev:${A}`, () => {\n      let B = this.getGraphemeBoundaries();\n      return this.binarySearchBoundary(B, A, false);\n    });\n  }\n}\nvar initializeRenderTree;\nvar initializeRenderingProcess = T(() => {\n  bZ1();\n  F0A();\n  initializeRenderTree = new Intl.Segmenter(undefined, {\n    granularity: \"grapheme\"\n  });\n});\nvar _______initializeRenderer = z((DvI, Fk0) => {\n  function Wk0(A) {\n    return typeof A !== \"undefined\" && A !== null;\n  }\n  function td9(A) {\n    return typeof A === \"object\";\n  }\n  function ed9(A) {\n    return Object.prototype.toString.call(A) === \"[object Object]\";\n  }\n  function Ac9(A) {\n    return typeof A === \"function\";\n  }\n  function Bc9(A) {\n    return typeof A === \"boolean\";\n  }\n  function Qc9(A) {\n    return A instanceof Buffer;\n  }\n  function Ic9(A) {\n    if (Wk0(A)) {\n      switch (A.constructor) {\n        case Uint8Array:\n        case Uint8ClampedArray:\n        case Int8Array:\n        case Uint16Array:\n        case Int16Array:\n        case Uint32Array:\n        case Int32Array:\n        case Float32Array:\n        case Float64Array:\n          return true;\n      }\n    }\n    return false;\n  }\n  function Gc9(A) {\n    return A instanceof ArrayBuffer;\n  }\n  function Zc9(A) {\n    return typeof A === \"string\" && A.length > 0;\n  }\n  function Yc9(A) {\n    return typeof A === \"number\" && !Number.isNaN(A);\n  }\n  function Jc9(A) {\n    return Number.isInteger(A);\n  }\n  function Xc9(A, B, Q) {\n    return A >= B && A <= Q;\n  }\n  function Wc9(A, B) {\n    return B.includes(A);\n  }\n  function Fc9(A, B, Q) {\n    return Error(`Expected ${B} for ${A} but received ${Q} of type ${typeof Q}`);\n  }\n  function Cc9(A, B) {\n    B.message = A.message;\n    return B;\n  }\n  Fk0.exports = {\n    defined: Wk0,\n    object: td9,\n    plainObject: ed9,\n    fn: Ac9,\n    bool: Bc9,\n    buffer: Qc9,\n    typedArray: Ic9,\n    arrayBuffer: Gc9,\n    string: Zc9,\n    number: Yc9,\n    integer: Jc9,\n    inRange: Xc9,\n    inArray: Wc9,\n    invalidParameterError: Fc9,\n    nativeError: Cc9\n  };\n});\nvar ___________________initializeDevTools = z((EvI, Vk0) => {\n  var Ck0 = () => process.platform === \"linux\";\n  var pPA = null;\n  var Vc9 = () => {\n    if (!pPA) {\n      if (Ck0() && process.report) {\n        let A = process.report.excludeNetwork;\n        process.report.excludeNetwork = true;\n        pPA = process.report.getReport();\n        process.report.excludeNetwork = A;\n      } else {\n        pPA = {};\n      }\n    }\n    return pPA;\n  };\n  Vk0.exports = {\n    isLinux: Ck0,\n    getReport: Vc9\n  };\n});\nvar ____________________________initializeDevToolsConnection = z((HvI, Ek0) => {\n  var Dk0 = EA(\"fs\");\n  var Kc9 = A => Dk0.readFileSync(A, \"utf-8\");\n  var Dc9 = A => new Promise((B, Q) => {\n    Dk0.readFile(A, \"utf-8\", (I, G) => {\n      if (I) {\n        Q(I);\n      } else {\n        B(G);\n      }\n    });\n  });\n  Ek0.exports = {\n    LDD_PATH: \"/usr/bin/ldd\",\n    readFileSync: Kc9,\n    readFile: Dc9\n  };\n});\nvar iPA = z((zvI, kk0) => {\n  var Uk0 = EA(\"child_process\");\n  var {\n    isLinux: U0A,\n    getReport: wk0\n  } = ___________________initializeDevTools();\n  var {\n    LDD_PATH: lPA,\n    readFile: $k0,\n    readFileSync: qk0\n  } = ____________________________initializeDevToolsConnection();\n  var nT;\n  var aT;\n  var fh = \"\";\n  var Nk0 = () => {\n    if (!fh) {\n      return new Promise(A => {\n        Uk0.exec(\"getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true\", (B, Q) => {\n          if (B) {\n            fh = \" \";\n          } else {\n            fh = Q;\n          }\n          A(fh);\n        });\n      });\n    }\n    return fh;\n  };\n  var Lk0 = () => {\n    if (!fh) {\n      try {\n        fh = Uk0.execSync(\"getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true\", {\n          encoding: \"utf8\"\n        });\n      } catch (A) {\n        fh = \" \";\n      }\n    }\n    return fh;\n  };\n  var hh = \"glibc\";\n  var Mk0 = /LIBC[a-z0-9 \\-).]*?(\\d+\\.\\d+)/i;\n  var z0A = \"musl\";\n  var Ec9 = A => A.includes(\"libc.musl-\") || A.includes(\"ld-musl-\");\n  var Ok0 = () => {\n    let A = wk0();\n    if (A.header && A.header.glibcVersionRuntime) {\n      return hh;\n    }\n    if (Array.isArray(A.sharedObjects)) {\n      if (A.sharedObjects.some(Ec9)) {\n        return z0A;\n      }\n    }\n    return null;\n  };\n  var Rk0 = A => {\n    let [B, Q] = A.split(/[\\r\\n]+/);\n    if (B && B.includes(hh)) {\n      return hh;\n    }\n    if (Q && Q.includes(z0A)) {\n      return z0A;\n    }\n    return null;\n  };\n  var Tk0 = A => {\n    if (A.includes(\"musl\")) {\n      return z0A;\n    }\n    if (A.includes(\"GNU C Library\")) {\n      return hh;\n    }\n    return null;\n  };\n  var Hc9 = async () => {\n    if (nT !== undefined) {\n      return nT;\n    }\n    nT = null;\n    try {\n      let A = await $k0(lPA);\n      nT = Tk0(A);\n    } catch (A) {}\n    return nT;\n  };\n  var zc9 = () => {\n    if (nT !== undefined) {\n      return nT;\n    }\n    nT = null;\n    try {\n      let A = qk0(lPA);\n      nT = Tk0(A);\n    } catch (A) {}\n    return nT;\n  };\n  var Pk0 = async () => {\n    let A = null;\n    if (U0A()) {\n      A = await Hc9();\n      if (!A) {\n        A = Ok0();\n      }\n      if (!A) {\n        let B = await Nk0();\n        A = Rk0(B);\n      }\n    }\n    return A;\n  };\n  var jk0 = () => {\n    let A = null;\n    if (U0A()) {\n      A = zc9();\n      if (!A) {\n        A = Ok0();\n      }\n      if (!A) {\n        let B = Lk0();\n        A = Rk0(B);\n      }\n    }\n    return A;\n  };\n  var Uc9 = async () => U0A() && (await Pk0()) !== hh;\n  var wc9 = () => U0A() && jk0() !== hh;\n  var $c9 = async () => {\n    if (aT !== undefined) {\n      return aT;\n    }\n    aT = null;\n    try {\n      let B = (await $k0(lPA)).match(Mk0);\n      if (B) {\n        aT = B[1];\n      }\n    } catch (A) {}\n    return aT;\n  };\n  var qc9 = () => {\n    if (aT !== undefined) {\n      return aT;\n    }\n    aT = null;\n    try {\n      let B = qk0(lPA).match(Mk0);\n      if (B) {\n        aT = B[1];\n      }\n    } catch (A) {}\n    return aT;\n  };\n  var Sk0 = () => {\n    let A = wk0();\n    if (A.header && A.header.glibcVersionRuntime) {\n      return A.header.glibcVersionRuntime;\n    }\n    return null;\n  };\n  var zk0 = A => A.trim().split(/\\s+/)[1];\n  var yk0 = A => {\n    let [B, Q, I] = A.split(/[\\r\\n]+/);\n    if (B && B.includes(hh)) {\n      return zk0(B);\n    }\n    if (Q && I && Q.includes(z0A)) {\n      return zk0(I);\n    }\n    return null;\n  };\n  var Nc9 = async () => {\n    let A = null;\n    if (U0A()) {\n      A = await $c9();\n      if (!A) {\n        A = Sk0();\n      }\n      if (!A) {\n        let B = await Nk0();\n        A = yk0(B);\n      }\n    }\n    return A;\n  };\n  var Lc9 = () => {\n    let A = null;\n    if (U0A()) {\n      A = qc9();\n      if (!A) {\n        A = Sk0();\n      }\n      if (!A) {\n        let B = Lk0();\n        A = yk0(B);\n      }\n    }\n    return A;\n  };\n  kk0.exports = {\n    GLIBC: hh,\n    MUSL: z0A,\n    family: Pk0,\n    familySync: jk0,\n    isNonGlibcLinux: Uc9,\n    isNonGlibcLinuxSync: wc9,\n    version: Nc9,\n    versionSync: Lc9\n  };\n});\nvar _handleDevToolsConnection = z((UvI, _k0) => {\n  var Mc9 = typeof process === \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...A) => console.error(\"SEMVER\", ...A) : () => {};\n  _k0.exports = Mc9;\n});\nvar _____________________________initializeDevToolsConnection = z((wvI, xk0) => {\n  var Oc9 = Number.MAX_SAFE_INTEGER || 9007199254740991;\n  var Rc9 = [\"major\", \"premajor\", \"minor\", \"preminor\", \"patch\", \"prepatch\", \"prerelease\"];\n  xk0.exports = {\n    MAX_LENGTH: 256,\n    MAX_SAFE_COMPONENT_LENGTH: 16,\n    MAX_SAFE_BUILD_LENGTH: 250,\n    MAX_SAFE_INTEGER: Oc9,\n    RELEASE_TYPES: Rc9,\n    SEMVER_SPEC_VERSION: \"2.0.0\",\n    FLAG_INCLUDE_PRERELEASE: 1,\n    FLAG_LOOSE: 2\n  };\n});\nvar w0A = z((sT, vk0) => {\n  var {\n    MAX_SAFE_COMPONENT_LENGTH: tY1,\n    MAX_SAFE_BUILD_LENGTH: Tc9,\n    MAX_LENGTH: Pc9\n  } = _____________________________initializeDevToolsConnection();\n  var jc9 = _handleDevToolsConnection();\n  sT = vk0.exports = {};\n  var Sc9 = sT.re = [];\n  var yc9 = sT.safeRe = [];\n  var jQ = sT.src = [];\n  var kc9 = sT.safeSrc = [];\n  var SQ = sT.t = {};\n  var _c9 = 0;\n  var eY1 = \"[a-zA-Z0-9-]\";\n  var xc9 = [[\"\\\\s\", 1], [\"\\\\d\", Pc9], [eY1, Tc9]];\n  var vc9 = A => {\n    for (let [B, Q] of xc9) {\n      A = A.split(`${B}*`).join(`${B}{0,${Q}}`).split(`${B}+`).join(`${B}{1,${Q}}`);\n    }\n    return A;\n  };\n  var c4 = (A, B, Q) => {\n    let I = vc9(B);\n    let G = _c9++;\n    jc9(A, G, B);\n    SQ[A] = G;\n    jQ[G] = B;\n    kc9[G] = I;\n    Sc9[G] = new RegExp(B, Q ? \"g\" : undefined);\n    yc9[G] = new RegExp(I, Q ? \"g\" : undefined);\n  };\n  c4(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\");\n  c4(\"NUMERICIDENTIFIERLOOSE\", \"\\\\d+\");\n  c4(\"NONNUMERICIDENTIFIER\", `\\\\d*[a-zA-Z-]${eY1}*`);\n  c4(\"MAINVERSION\", `(${jQ[SQ.NUMERICIDENTIFIER]})\\\\.(${jQ[SQ.NUMERICIDENTIFIER]})\\\\.(${jQ[SQ.NUMERICIDENTIFIER]})`);\n  c4(\"MAINVERSIONLOOSE\", `(${jQ[SQ.NUMERICIDENTIFIERLOOSE]})\\\\.(${jQ[SQ.NUMERICIDENTIFIERLOOSE]})\\\\.(${jQ[SQ.NUMERICIDENTIFIERLOOSE]})`);\n  c4(\"PRERELEASEIDENTIFIER\", `(?:${jQ[SQ.NUMERICIDENTIFIER]}|${jQ[SQ.NONNUMERICIDENTIFIER]})`);\n  c4(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${jQ[SQ.NUMERICIDENTIFIERLOOSE]}|${jQ[SQ.NONNUMERICIDENTIFIER]})`);\n  c4(\"PRERELEASE\", `(?:-(${jQ[SQ.PRERELEASEIDENTIFIER]}(?:\\\\.${jQ[SQ.PRERELEASEIDENTIFIER]})*))`);\n  c4(\"PRERELEASELOOSE\", `(?:-?(${jQ[SQ.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${jQ[SQ.PRERELEASEIDENTIFIERLOOSE]})*))`);\n  c4(\"BUILDIDENTIFIER\", `${eY1}+`);\n  c4(\"BUILD\", `(?:\\\\+(${jQ[SQ.BUILDIDENTIFIER]}(?:\\\\.${jQ[SQ.BUILDIDENTIFIER]})*))`);\n  c4(\"FULLPLAIN\", `v?${jQ[SQ.MAINVERSION]}${jQ[SQ.PRERELEASE]}?${jQ[SQ.BUILD]}?`);\n  c4(\"FULL\", `^${jQ[SQ.FULLPLAIN]}$`);\n  c4(\"LOOSEPLAIN\", `[v=\\\\s]*${jQ[SQ.MAINVERSIONLOOSE]}${jQ[SQ.PRERELEASELOOSE]}?${jQ[SQ.BUILD]}?`);\n  c4(\"LOOSE\", `^${jQ[SQ.LOOSEPLAIN]}$`);\n  c4(\"GTLT\", \"((?:<|>)?=?)\");\n  c4(\"XRANGEIDENTIFIERLOOSE\", `${jQ[SQ.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n  c4(\"XRANGEIDENTIFIER\", `${jQ[SQ.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n  c4(\"XRANGEPLAIN\", `[v=\\\\s]*(${jQ[SQ.XRANGEIDENTIFIER]})(?:\\\\.(${jQ[SQ.XRANGEIDENTIFIER]})(?:\\\\.(${jQ[SQ.XRANGEIDENTIFIER]})(?:${jQ[SQ.PRERELEASE]})?${jQ[SQ.BUILD]}?)?)?`);\n  c4(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${jQ[SQ.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${jQ[SQ.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${jQ[SQ.XRANGEIDENTIFIERLOOSE]})(?:${jQ[SQ.PRERELEASELOOSE]})?${jQ[SQ.BUILD]}?)?)?`);\n  c4(\"XRANGE\", `^${jQ[SQ.GTLT]}\\\\s*${jQ[SQ.XRANGEPLAIN]}$`);\n  c4(\"XRANGELOOSE\", `^${jQ[SQ.GTLT]}\\\\s*${jQ[SQ.XRANGEPLAINLOOSE]}$`);\n  c4(\"COERCEPLAIN\", `(^|[^\\\\d])(\\\\d{1,${tY1}})(?:\\\\.(\\\\d{1,${tY1}}))?(?:\\\\.(\\\\d{1,${tY1}}))?`);\n  c4(\"COERCE\", `${jQ[SQ.COERCEPLAIN]}(?:$|[^\\\\d])`);\n  c4(\"COERCEFULL\", `${jQ[SQ.COERCEPLAIN]}(?:${jQ[SQ.PRERELEASE]})?(?:${jQ[SQ.BUILD]})?(?:$|[^\\\\d])`);\n  c4(\"COERCERTL\", jQ[SQ.COERCE], true);\n  c4(\"COERCERTLFULL\", jQ[SQ.COERCEFULL], true);\n  c4(\"LONETILDE\", \"(?:~>?)\");\n  c4(\"TILDETRIM\", `(\\\\s*)${jQ[SQ.LONETILDE]}\\\\s+`, true);\n  sT.tildeTrimReplace = \"$1~\";\n  c4(\"TILDE\", `^${jQ[SQ.LONETILDE]}${jQ[SQ.XRANGEPLAIN]}$`);\n  c4(\"TILDELOOSE\", `^${jQ[SQ.LONETILDE]}${jQ[SQ.XRANGEPLAINLOOSE]}$`);\n  c4(\"LONECARET\", \"(?:\\\\^)\");\n  c4(\"CARETTRIM\", `(\\\\s*)${jQ[SQ.LONECARET]}\\\\s+`, true);\n  sT.caretTrimReplace = \"$1^\";\n  c4(\"CARET\", `^${jQ[SQ.LONECARET]}${jQ[SQ.XRANGEPLAIN]}$`);\n  c4(\"CARETLOOSE\", `^${jQ[SQ.LONECARET]}${jQ[SQ.XRANGEPLAINLOOSE]}$`);\n  c4(\"COMPARATORLOOSE\", `^${jQ[SQ.GTLT]}\\\\s*(${jQ[SQ.LOOSEPLAIN]})$|^$`);\n  c4(\"COMPARATOR\", `^${jQ[SQ.GTLT]}\\\\s*(${jQ[SQ.FULLPLAIN]})$|^$`);\n  c4(\"COMPARATORTRIM\", `(\\\\s*)${jQ[SQ.GTLT]}\\\\s*(${jQ[SQ.LOOSEPLAIN]}|${jQ[SQ.XRANGEPLAIN]})`, true);\n  sT.comparatorTrimReplace = \"$1$2$3\";\n  c4(\"HYPHENRANGE\", `^\\\\s*(${jQ[SQ.XRANGEPLAIN]})\\\\s+-\\\\s+(${jQ[SQ.XRANGEPLAIN]})\\\\s*$`);\n  c4(\"HYPHENRANGELOOSE\", `^\\\\s*(${jQ[SQ.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${jQ[SQ.XRANGEPLAINLOOSE]})\\\\s*$`);\n  c4(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\");\n  c4(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\");\n  c4(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n});\nvar ________initializeRenderer = z(($vI, bk0) => {\n  var bc9 = Object.freeze({\n    loose: true\n  });\n  var fc9 = Object.freeze({});\n  var hc9 = A => {\n    if (!A) {\n      return fc9;\n    }\n    if (typeof A !== \"object\") {\n      return bc9;\n    }\n    return A;\n  };\n  bk0.exports = hc9;\n});\nvar __initializeReactDevTools = z((qvI, gk0) => {\n  var fk0 = /^[0-9]+$/;\n  var hk0 = (A, B) => {\n    let Q = fk0.test(A);\n    let I = fk0.test(B);\n    if (Q && I) {\n      A = +A;\n      B = +B;\n    }\n    if (A === B) {\n      return 0;\n    } else if (Q && !I) {\n      return -1;\n    } else if (I && !Q) {\n      return 1;\n    } else if (A < B) {\n      return -1;\n    } else {\n      return 1;\n    }\n  };\n  var gc9 = (A, B) => hk0(B, A);\n  gk0.exports = {\n    compareIdentifiers: hk0,\n    rcompareIdentifiers: gc9\n  };\n});\nvar oV = z((createSemanticVersion, SemVer) => {\n  var aPA = _handleDevToolsConnection();\n  var {\n    MAX_LENGTH: uk0,\n    MAX_SAFE_INTEGER: sPA\n  } = _____________________________initializeDevToolsConnection();\n  var {\n    safeRe: mk0,\n    safeSrc: dk0,\n    t: rPA\n  } = w0A();\n  var uc9 = ________initializeRenderer();\n  var {\n    compareIdentifiers: $0A\n  } = __initializeReactDevTools();\n  class SM {\n    constructor(A, B) {\n      B = uc9(B);\n      if (A instanceof SM) {\n        if (A.loose === !!B.loose && A.includePrerelease === !!B.includePrerelease) {\n          return A;\n        } else {\n          A = A.version;\n        }\n      } else if (typeof A !== \"string\") {\n        throw TypeError(`Invalid version. Must be a string. Got type \"${typeof A}\".`);\n      }\n      if (A.length > uk0) {\n        throw TypeError(`version is longer than ${uk0} characters`);\n      }\n      aPA(\"SemVer\", A, B);\n      this.options = B;\n      this.loose = !!B.loose;\n      this.includePrerelease = !!B.includePrerelease;\n      let Q = A.trim().match(B.loose ? mk0[rPA.LOOSE] : mk0[rPA.FULL]);\n      if (!Q) {\n        throw TypeError(`Invalid Version: ${A}`);\n      }\n      this.raw = A;\n      this.major = +Q[1];\n      this.minor = +Q[2];\n      this.patch = +Q[3];\n      if (this.major > sPA || this.major < 0) {\n        throw TypeError(\"Invalid major version\");\n      }\n      if (this.minor > sPA || this.minor < 0) {\n        throw TypeError(\"Invalid minor version\");\n      }\n      if (this.patch > sPA || this.patch < 0) {\n        throw TypeError(\"Invalid patch version\");\n      }\n      if (!Q[4]) {\n        this.prerelease = [];\n      } else {\n        this.prerelease = Q[4].split(\".\").map(I => {\n          if (/^[0-9]+$/.test(I)) {\n            let G = +I;\n            if (G >= 0 && G < sPA) {\n              return G;\n            }\n          }\n          return I;\n        });\n      }\n      this.build = Q[5] ? Q[5].split(\".\") : [];\n      this.format();\n    }\n    format() {\n      this.version = `${this.major}.${this.minor}.${this.patch}`;\n      if (this.prerelease.length) {\n        this.version += `-${this.prerelease.join(\".\")}`;\n      }\n      return this.version;\n    }\n    toString() {\n      return this.version;\n    }\n    compare(A) {\n      aPA(\"SemVer.compare\", this.version, this.options, A);\n      if (!(A instanceof SM)) {\n        if (typeof A === \"string\" && A === this.version) {\n          return 0;\n        }\n        A = new SM(A, this.options);\n      }\n      if (A.version === this.version) {\n        return 0;\n      }\n      return this.compareMain(A) || this.comparePre(A);\n    }\n    compareMain(A) {\n      if (!(A instanceof SM)) {\n        A = new SM(A, this.options);\n      }\n      return $0A(this.major, A.major) || $0A(this.minor, A.minor) || $0A(this.patch, A.patch);\n    }\n    comparePre(A) {\n      if (!(A instanceof SM)) {\n        A = new SM(A, this.options);\n      }\n      if (this.prerelease.length && !A.prerelease.length) {\n        return -1;\n      } else if (!this.prerelease.length && A.prerelease.length) {\n        return 1;\n      } else if (!this.prerelease.length && !A.prerelease.length) {\n        return 0;\n      }\n      let B = 0;\n      do {\n        let Q = this.prerelease[B];\n        let I = A.prerelease[B];\n        aPA(\"prerelease compare\", B, Q, I);\n        if (Q === undefined && I === undefined) {\n          return 0;\n        } else if (I === undefined) {\n          return 1;\n        } else if (Q === undefined) {\n          return -1;\n        } else if (Q === I) {\n          continue;\n        } else {\n          return $0A(Q, I);\n        }\n      } while (++B);\n    }\n    compareBuild(A) {\n      if (!(A instanceof SM)) {\n        A = new SM(A, this.options);\n      }\n      let B = 0;\n      do {\n        let Q = this.build[B];\n        let I = A.build[B];\n        aPA(\"build compare\", B, Q, I);\n        if (Q === undefined && I === undefined) {\n          return 0;\n        } else if (I === undefined) {\n          return 1;\n        } else if (Q === undefined) {\n          return -1;\n        } else if (Q === I) {\n          continue;\n        } else {\n          return $0A(Q, I);\n        }\n      } while (++B);\n    }\n    inc(A, B, Q) {\n      if (A.startsWith(\"pre\")) {\n        if (!B && Q === false) {\n          throw Error(\"invalid increment argument: identifier is empty\");\n        }\n        if (B) {\n          let I = new RegExp(`^${this.options.loose ? dk0[rPA.PRERELEASELOOSE] : dk0[rPA.PRERELEASE]}$`);\n          let G = `-${B}`.match(I);\n          if (!G || G[1] !== B) {\n            throw Error(`invalid identifier: ${B}`);\n          }\n        }\n      }\n      switch (A) {\n        case \"premajor\":\n          this.prerelease.length = 0;\n          this.patch = 0;\n          this.minor = 0;\n          this.major++;\n          this.inc(\"pre\", B, Q);\n          break;\n        case \"preminor\":\n          this.prerelease.length = 0;\n          this.patch = 0;\n          this.minor++;\n          this.inc(\"pre\", B, Q);\n          break;\n        case \"prepatch\":\n          this.prerelease.length = 0;\n          this.inc(\"patch\", B, Q);\n          this.inc(\"pre\", B, Q);\n          break;\n        case \"prerelease\":\n          if (this.prerelease.length === 0) {\n            this.inc(\"patch\", B, Q);\n          }\n          this.inc(\"pre\", B, Q);\n          break;\n        case \"release\":\n          if (this.prerelease.length === 0) {\n            throw Error(`version ${this.raw} is not a prerelease`);\n          }\n          this.prerelease.length = 0;\n          break;\n        case \"major\":\n          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n            this.major++;\n          }\n          this.minor = 0;\n          this.patch = 0;\n          this.prerelease = [];\n          break;\n        case \"minor\":\n          if (this.patch !== 0 || this.prerelease.length === 0) {\n            this.minor++;\n          }\n          this.patch = 0;\n          this.prerelease = [];\n          break;\n        case \"patch\":\n          if (this.prerelease.length === 0) {\n            this.patch++;\n          }\n          this.prerelease = [];\n          break;\n        case \"pre\":\n          {\n            let I = Number(Q) ? 1 : 0;\n            if (this.prerelease.length === 0) {\n              this.prerelease = [I];\n            } else {\n              let G = this.prerelease.length;\n              while (--G >= 0) {\n                if (typeof this.prerelease[G] === \"number\") {\n                  this.prerelease[G]++;\n                  G = -2;\n                }\n              }\n              if (G === -1) {\n                if (B === this.prerelease.join(\".\") && Q === false) {\n                  throw Error(\"invalid increment argument: identifier already exists\");\n                }\n                this.prerelease.push(I);\n              }\n            }\n            if (B) {\n              let G = [B, I];\n              if (Q === false) {\n                G = [B];\n              }\n              if ($0A(this.prerelease[0], B) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = G;\n                }\n              } else {\n                this.prerelease = G;\n              }\n            }\n            break;\n          }\n        default:\n          throw Error(`invalid increment argument: ${A}`);\n      }\n      this.raw = this.format();\n      if (this.build.length) {\n        this.raw += `+${this.build.join(\".\")}`;\n      }\n      return this;\n    }\n  }\n  SemVer.exports = SM;\n});\nvar qi = z((LvI, lk0) => {\n  var pk0 = oV();\n  var mc9 = (A, B, Q = false) => {\n    if (A instanceof pk0) {\n      return A;\n    }\n    try {\n      return new pk0(A, B);\n    } catch (I) {\n      if (!Q) {\n        return null;\n      }\n      throw I;\n    }\n  };\n  lk0.exports = mc9;\n});\nvar BJ1 = z((MvI, ik0) => {\n  var dc9 = oV();\n  var cc9 = qi();\n  var {\n    safeRe: oPA,\n    t: tPA\n  } = w0A();\n  var pc9 = (A, B) => {\n    if (A instanceof dc9) {\n      return A;\n    }\n    if (typeof A === \"number\") {\n      A = String(A);\n    }\n    if (typeof A !== \"string\") {\n      return null;\n    }\n    B = B || {};\n    let Q = null;\n    if (!B.rtl) {\n      Q = A.match(B.includePrerelease ? oPA[tPA.COERCEFULL] : oPA[tPA.COERCE]);\n    } else {\n      let X = B.includePrerelease ? oPA[tPA.COERCERTLFULL] : oPA[tPA.COERCERTL];\n      let W;\n      while ((W = X.exec(A)) && (!Q || Q.index + Q[0].length !== A.length)) {\n        if (!Q || W.index + W[0].length !== Q.index + Q[0].length) {\n          Q = W;\n        }\n        X.lastIndex = W.index + W[1].length + W[2].length;\n      }\n      X.lastIndex = -1;\n    }\n    if (Q === null) {\n      return null;\n    }\n    let I = Q[2];\n    let G = Q[3] || \"0\";\n    let Z = Q[4] || \"0\";\n    let Y = B.includePrerelease && Q[5] ? `-${Q[5]}` : \"\";\n    let J = B.includePrerelease && Q[6] ? `+${Q[6]}` : \"\";\n    return cc9(`${I}.${G}.${Z}${Y}${J}`, B);\n  };\n  ik0.exports = pc9;\n});\nvar d$ = z((OvI, ak0) => {\n  var nk0 = oV();\n  var lc9 = (A, B, Q) => new nk0(A, Q).compare(new nk0(B, Q));\n  ak0.exports = lc9;\n});\nvar CJA = z((RvI, sk0) => {\n  var ic9 = d$();\n  var nc9 = (A, B, Q) => ic9(A, B, Q) >= 0;\n  sk0.exports = nc9;\n});\nvar _initializeDebugTools = z((TvI, ok0) => {\n  class rk0 {\n    constructor() {\n      this.max = 1000;\n      this.map = new Map();\n    }\n    get(A) {\n      let B = this.map.get(A);\n      if (B === undefined) {\n        return;\n      } else {\n        this.map.delete(A);\n        this.map.set(A, B);\n        return B;\n      }\n    }\n    delete(A) {\n      return this.map.delete(A);\n    }\n    set(A, B) {\n      if (!this.delete(A) && B !== undefined) {\n        if (this.map.size >= this.max) {\n          let I = this.map.keys().next().value;\n          this.delete(I);\n        }\n        this.map.set(A, B);\n      }\n      return this;\n    }\n  }\n  ok0.exports = rk0;\n});\nvar QJ1 = z((PvI, ek0) => {\n  var ac9 = d$();\n  var sc9 = (A, B, Q) => ac9(A, B, Q) === 0;\n  ek0.exports = sc9;\n});\nvar IJ1 = z((jvI, A_0) => {\n  var rc9 = d$();\n  var oc9 = (A, B, Q) => rc9(A, B, Q) !== 0;\n  A_0.exports = oc9;\n});\nvar VJA = z((SvI, B_0) => {\n  var tc9 = d$();\n  var ec9 = (A, B, Q) => tc9(A, B, Q) > 0;\n  B_0.exports = ec9;\n});\nvar ePA = z((yvI, Q_0) => {\n  var Ap9 = d$();\n  var Bp9 = (A, B, Q) => Ap9(A, B, Q) < 0;\n  Q_0.exports = Bp9;\n});\nvar AjA = z((kvI, I_0) => {\n  var Qp9 = d$();\n  var Ip9 = (A, B, Q) => Qp9(A, B, Q) <= 0;\n  I_0.exports = Ip9;\n});\nvar GJ1 = z((_vI, G_0) => {\n  var Gp9 = QJ1();\n  var Zp9 = IJ1();\n  var Yp9 = VJA();\n  var Jp9 = CJA();\n  var Xp9 = ePA();\n  var Wp9 = AjA();\n  var Fp9 = (A, B, Q, I) => {\n    switch (B) {\n      case \"===\":\n        if (typeof A === \"object\") {\n          A = A.version;\n        }\n        if (typeof Q === \"object\") {\n          Q = Q.version;\n        }\n        return A === Q;\n      case \"!==\":\n        if (typeof A === \"object\") {\n          A = A.version;\n        }\n        if (typeof Q === \"object\") {\n          Q = Q.version;\n        }\n        return A !== Q;\n      case \"\":\n      case \"=\":\n      case \"==\":\n        return Gp9(A, Q, I);\n      case \"!=\":\n        return Zp9(A, Q, I);\n      case \">\":\n        return Yp9(A, Q, I);\n      case \">=\":\n        return Jp9(A, Q, I);\n      case \"<\":\n        return Xp9(A, Q, I);\n      case \"<=\":\n        return Wp9(A, Q, I);\n      default:\n        throw TypeError(`Invalid operator: ${B}`);\n    }\n  };\n  G_0.exports = Fp9;\n});\nvar DJA = z((xvI, F_0) => {\n  var KJA = Symbol(\"SemVer ANY\");\n  class BjA {\n    static get ANY() {\n      return KJA;\n    }\n    constructor(A, B) {\n      B = Z_0(B);\n      if (A instanceof BjA) {\n        if (A.loose === !!B.loose) {\n          return A;\n        } else {\n          A = A.value;\n        }\n      }\n      A = A.trim().split(/\\s+/).join(\" \");\n      YJ1(\"comparator\", A, B);\n      this.options = B;\n      this.loose = !!B.loose;\n      this.parse(A);\n      if (this.semver === KJA) {\n        this.value = \"\";\n      } else {\n        this.value = this.operator + this.semver.version;\n      }\n      YJ1(\"comp\", this);\n    }\n    parse(A) {\n      let B = this.options.loose ? Y_0[J_0.COMPARATORLOOSE] : Y_0[J_0.COMPARATOR];\n      let Q = A.match(B);\n      if (!Q) {\n        throw TypeError(`Invalid comparator: ${A}`);\n      }\n      this.operator = Q[1] !== undefined ? Q[1] : \"\";\n      if (this.operator === \"=\") {\n        this.operator = \"\";\n      }\n      if (!Q[2]) {\n        this.semver = KJA;\n      } else {\n        this.semver = new X_0(Q[2], this.options.loose);\n      }\n    }\n    toString() {\n      return this.value;\n    }\n    test(A) {\n      YJ1(\"Comparator.test\", A, this.options.loose);\n      if (this.semver === KJA || A === KJA) {\n        return true;\n      }\n      if (typeof A === \"string\") {\n        try {\n          A = new X_0(A, this.options);\n        } catch (B) {\n          return false;\n        }\n      }\n      return ZJ1(A, this.operator, this.semver, this.options);\n    }\n    intersects(A, B) {\n      if (!(A instanceof BjA)) {\n        throw TypeError(\"a Comparator is required\");\n      }\n      if (this.operator === \"\") {\n        if (this.value === \"\") {\n          return true;\n        }\n        return new W_0(A.value, B).test(this.value);\n      } else if (A.operator === \"\") {\n        if (A.value === \"\") {\n          return true;\n        }\n        return new W_0(this.value, B).test(A.semver);\n      }\n      B = Z_0(B);\n      if (B.includePrerelease && (this.value === \"<0.0.0-0\" || A.value === \"<0.0.0-0\")) {\n        return false;\n      }\n      if (!B.includePrerelease && (this.value.startsWith(\"<0.0.0\") || A.value.startsWith(\"<0.0.0\"))) {\n        return false;\n      }\n      if (this.operator.startsWith(\">\") && A.operator.startsWith(\">\")) {\n        return true;\n      }\n      if (this.operator.startsWith(\"<\") && A.operator.startsWith(\"<\")) {\n        return true;\n      }\n      if (this.semver.version === A.semver.version && this.operator.includes(\"=\") && A.operator.includes(\"=\")) {\n        return true;\n      }\n      if (ZJ1(this.semver, \"<\", A.semver, B) && this.operator.startsWith(\">\") && A.operator.startsWith(\"<\")) {\n        return true;\n      }\n      if (ZJ1(this.semver, \">\", A.semver, B) && this.operator.startsWith(\"<\") && A.operator.startsWith(\">\")) {\n        return true;\n      }\n      return false;\n    }\n  }\n  F_0.exports = BjA;\n  var Z_0 = ________initializeRenderer();\n  var {\n    safeRe: Y_0,\n    t: J_0\n  } = w0A();\n  var ZJ1 = GJ1();\n  var YJ1 = _handleDevToolsConnection();\n  var X_0 = oV();\n  var W_0 = c$();\n});\nvar c$ = z((parseSemverRange, EjaExport) => {\n  var whitespacePattern = /\\s+/g;\n  class EJA {\n    constructor(A, B) {\n      B = Kp9(B);\n      if (A instanceof EJA) {\n        if (A.loose === !!B.loose && A.includePrerelease === !!B.includePrerelease) {\n          return A;\n        } else {\n          return new EJA(A.raw, B);\n        }\n      }\n      if (A instanceof JJ1) {\n        this.raw = A.value;\n        this.set = [[A]];\n        this.formatted = undefined;\n        return this;\n      }\n      this.options = B;\n      this.loose = !!B.loose;\n      this.includePrerelease = !!B.includePrerelease;\n      this.raw = A.trim().replace(whitespacePattern, \" \");\n      this.set = this.raw.split(\"||\").map(Q => this.parseRange(Q.trim())).filter(Q => Q.length);\n      if (!this.set.length) {\n        throw TypeError(`Invalid SemVer Range: ${this.raw}`);\n      }\n      if (this.set.length > 1) {\n        let Q = this.set[0];\n        this.set = this.set.filter(I => !isPrereleaseVersion(I[0]));\n        if (this.set.length === 0) {\n          this.set = [Q];\n        } else if (this.set.length > 1) {\n          for (let I of this.set) {\n            if (I.length === 1 && isEmptyVersion(I[0])) {\n              this.set = [I];\n              break;\n            }\n          }\n        }\n      }\n      this.formatted = undefined;\n    }\n    get range() {\n      if (this.formatted === undefined) {\n        this.formatted = \"\";\n        for (let A = 0; A < this.set.length; A++) {\n          if (A > 0) {\n            this.formatted += \"||\";\n          }\n          let B = this.set[A];\n          for (let Q = 0; Q < B.length; Q++) {\n            if (Q > 0) {\n              this.formatted += \" \";\n            }\n            this.formatted += B[Q].toString().trim();\n          }\n        }\n      }\n      return this.formatted;\n    }\n    format() {\n      return this.range;\n    }\n    toString() {\n      return this.range;\n    }\n    parseRange(A) {\n      let Q = ((this.options.includePrerelease && Up9) | (this.options.loose && wp9)) + \":\" + A;\n      let I = C_0.get(Q);\n      if (I) {\n        return I;\n      }\n      let G = this.options.loose;\n      let Z = G ? VH[qD.HYPHENRANGELOOSE] : VH[qD.HYPHENRANGE];\n      A = A.replace(Z, Sp9(this.options.includePrerelease));\n      VG(\"hyphen replace\", A);\n      A = A.replace(VH[qD.COMPARATORTRIM], Ep9);\n      VG(\"comparator trim\", A);\n      A = A.replace(VH[qD.TILDETRIM], Hp9);\n      VG(\"tilde trim\", A);\n      A = A.replace(VH[qD.CARETTRIM], zp9);\n      VG(\"caret trim\", A);\n      let Y = A.split(\" \").map(F => qp9(F, this.options)).join(\" \").split(/\\s+/).map(F => jp9(F, this.options));\n      if (G) {\n        Y = Y.filter(F => {\n          VG(\"loose invalid filter\", F, this.options);\n          return !!F.match(VH[qD.COMPARATORLOOSE]);\n        });\n      }\n      VG(\"range list\", Y);\n      let J = new Map();\n      let X = Y.map(F => new JJ1(F, this.options));\n      for (let F of X) {\n        if (isPrereleaseVersion(F)) {\n          return [F];\n        }\n        J.set(F.value, F);\n      }\n      if (J.size > 1 && J.has(\"\")) {\n        J.delete(\"\");\n      }\n      let W = [...J.values()];\n      C_0.set(Q, W);\n      return W;\n    }\n    intersects(A, B) {\n      if (!(A instanceof EJA)) {\n        throw TypeError(\"a Range is required\");\n      }\n      return this.set.some(Q => {\n        return checkIntersection(Q, B) && A.set.some(I => {\n          return checkIntersection(I, B) && Q.every(G => {\n            return I.every(Z => {\n              return G.intersects(Z, B);\n            });\n          });\n        });\n      });\n    }\n    test(A) {\n      if (!A) {\n        return false;\n      }\n      if (typeof A === \"string\") {\n        try {\n          A = new Dp9(A, this.options);\n        } catch (B) {\n          return false;\n        }\n      }\n      for (let B = 0; B < this.set.length; B++) {\n        if (yp9(this.set[B], A, this.options)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  EjaExport.exports = EJA;\n  var Vp9 = _initializeDebugTools();\n  var C_0 = new Vp9();\n  var Kp9 = ________initializeRenderer();\n  var JJ1 = DJA();\n  var VG = _handleDevToolsConnection();\n  var Dp9 = oV();\n  var {\n    safeRe: VH,\n    t: qD,\n    comparatorTrimReplace: Ep9,\n    tildeTrimReplace: Hp9,\n    caretTrimReplace: zp9\n  } = w0A();\n  var {\n    FLAG_INCLUDE_PRERELEASE: Up9,\n    FLAG_LOOSE: wp9\n  } = _____________________________initializeDevToolsConnection();\n  var isPrereleaseVersion = A => A.value === \"<0.0.0-0\";\n  var isEmptyVersion = A => A.value === \"\";\n  var checkIntersection = (A, B) => {\n    let Q = true;\n    let I = A.slice();\n    let G = I.pop();\n    while (Q && I.length) {\n      Q = I.every(Z => {\n        return G.intersects(Z, B);\n      });\n      G = I.pop();\n    }\n    return Q;\n  };\n  var qp9 = (A, B) => {\n    VG(\"comp\", A, B);\n    A = Mp9(A, B);\n    VG(\"caret\", A);\n    A = Np9(A, B);\n    VG(\"tildes\", A);\n    A = Rp9(A, B);\n    VG(\"xrange\", A);\n    A = Pp9(A, B);\n    VG(\"stars\", A);\n    return A;\n  };\n  var isWildcard = A => !A || A.toLowerCase() === \"x\" || A === \"*\";\n  var Np9 = (A, B) => {\n    return A.trim().split(/\\s+/).map(Q => Lp9(Q, B)).join(\" \");\n  };\n  var Lp9 = (A, B) => {\n    let Q = B.loose ? VH[qD.TILDELOOSE] : VH[qD.TILDE];\n    return A.replace(Q, (I, G, Z, Y, J) => {\n      VG(\"tilde\", A, I, G, Z, Y, J);\n      let X;\n      if (isWildcard(G)) {\n        X = \"\";\n      } else if (isWildcard(Z)) {\n        X = `>=${G}.0.0 <${+G + 1}.0.0-0`;\n      } else if (isWildcard(Y)) {\n        X = `>=${G}.${Z}.0 <${G}.${+Z + 1}.0-0`;\n      } else if (J) {\n        VG(\"replaceTilde pr\", J);\n        X = `>=${G}.${Z}.${Y}-${J} <${G}.${+Z + 1}.0-0`;\n      } else {\n        X = `>=${G}.${Z}.${Y} <${G}.${+Z + 1}.0-0`;\n      }\n      VG(\"tilde return\", X);\n      return X;\n    });\n  };\n  var Mp9 = (A, B) => {\n    return A.trim().split(/\\s+/).map(Q => Op9(Q, B)).join(\" \");\n  };\n  var Op9 = (A, B) => {\n    VG(\"caret\", A, B);\n    let Q = B.loose ? VH[qD.CARETLOOSE] : VH[qD.CARET];\n    let I = B.includePrerelease ? \"-0\" : \"\";\n    return A.replace(Q, (G, Z, Y, J, X) => {\n      VG(\"caret\", A, G, Z, Y, J, X);\n      let W;\n      if (isWildcard(Z)) {\n        W = \"\";\n      } else if (isWildcard(Y)) {\n        W = `>=${Z}.0.0${I} <${+Z + 1}.0.0-0`;\n      } else if (isWildcard(J)) {\n        if (Z === \"0\") {\n          W = `>=${Z}.${Y}.0${I} <${Z}.${+Y + 1}.0-0`;\n        } else {\n          W = `>=${Z}.${Y}.0${I} <${+Z + 1}.0.0-0`;\n        }\n      } else if (X) {\n        VG(\"replaceCaret pr\", X);\n        if (Z === \"0\") {\n          if (Y === \"0\") {\n            W = `>=${Z}.${Y}.${J}-${X} <${Z}.${Y}.${+J + 1}-0`;\n          } else {\n            W = `>=${Z}.${Y}.${J}-${X} <${Z}.${+Y + 1}.0-0`;\n          }\n        } else {\n          W = `>=${Z}.${Y}.${J}-${X} <${+Z + 1}.0.0-0`;\n        }\n      } else {\n        VG(\"no pr\");\n        if (Z === \"0\") {\n          if (Y === \"0\") {\n            W = `>=${Z}.${Y}.${J}${I} <${Z}.${Y}.${+J + 1}-0`;\n          } else {\n            W = `>=${Z}.${Y}.${J}${I} <${Z}.${+Y + 1}.0-0`;\n          }\n        } else {\n          W = `>=${Z}.${Y}.${J} <${+Z + 1}.0.0-0`;\n        }\n      }\n      VG(\"caret return\", W);\n      return W;\n    });\n  };\n  var Rp9 = (A, B) => {\n    VG(\"replaceXRanges\", A, B);\n    return A.split(/\\s+/).map(Q => Tp9(Q, B)).join(\" \");\n  };\n  var Tp9 = (A, B) => {\n    A = A.trim();\n    let Q = B.loose ? VH[qD.XRANGELOOSE] : VH[qD.XRANGE];\n    return A.replace(Q, (I, G, Z, Y, J, X) => {\n      VG(\"xRange\", A, I, G, Z, Y, J, X);\n      let W = isWildcard(Z);\n      let F = W || isWildcard(Y);\n      let C = F || isWildcard(J);\n      let V = C;\n      if (G === \"=\" && V) {\n        G = \"\";\n      }\n      if (B.includePrerelease) {\n        X = \"-0\";\n      } else {\n        X = \"\";\n      }\n      if (W) {\n        if (G === \">\" || G === \"<\") {\n          I = \"<0.0.0-0\";\n        } else {\n          I = \"*\";\n        }\n      } else if (G && V) {\n        if (F) {\n          Y = 0;\n        }\n        J = 0;\n        if (G === \">\") {\n          G = \">=\";\n          if (F) {\n            Z = +Z + 1;\n            Y = 0;\n            J = 0;\n          } else {\n            Y = +Y + 1;\n            J = 0;\n          }\n        } else if (G === \"<=\") {\n          G = \"<\";\n          if (F) {\n            Z = +Z + 1;\n          } else {\n            Y = +Y + 1;\n          }\n        }\n        if (G === \"<\") {\n          X = \"-0\";\n        }\n        I = `${G + Z}.${Y}.${J}${X}`;\n      } else if (F) {\n        I = `>=${Z}.0.0${X} <${+Z + 1}.0.0-0`;\n      } else if (C) {\n        I = `>=${Z}.${Y}.0${X} <${Z}.${+Y + 1}.0-0`;\n      }\n      VG(\"xRange return\", I);\n      return I;\n    });\n  };\n  var Pp9 = (A, B) => {\n    VG(\"replaceStars\", A, B);\n    return A.trim().replace(VH[qD.STAR], \"\");\n  };\n  var jp9 = (A, B) => {\n    VG(\"replaceGTE0\", A, B);\n    return A.trim().replace(VH[B.includePrerelease ? qD.GTE0PRE : qD.GTE0], \"\");\n  };\n  var Sp9 = A => (B, Q, I, G, Z, Y, J, X, W, F, C, V) => {\n    if (isWildcard(I)) {\n      Q = \"\";\n    } else if (isWildcard(G)) {\n      Q = `>=${I}.0.0${A ? \"-0\" : \"\"}`;\n    } else if (isWildcard(Z)) {\n      Q = `>=${I}.${G}.0${A ? \"-0\" : \"\"}`;\n    } else if (Y) {\n      Q = `>=${Q}`;\n    } else {\n      Q = `>=${Q}${A ? \"-0\" : \"\"}`;\n    }\n    if (isWildcard(W)) {\n      X = \"\";\n    } else if (isWildcard(F)) {\n      X = `<${+W + 1}.0.0-0`;\n    } else if (isWildcard(C)) {\n      X = `<${W}.${+F + 1}.0-0`;\n    } else if (V) {\n      X = `<=${W}.${F}.${C}-${V}`;\n    } else if (A) {\n      X = `<${W}.${F}.${+C + 1}-0`;\n    } else {\n      X = `<=${X}`;\n    }\n    return `${Q} ${X}`.trim();\n  };\n  var yp9 = (A, B, Q) => {\n    for (let I = 0; I < A.length; I++) {\n      if (!A[I].test(B)) {\n        return false;\n      }\n    }\n    if (B.prerelease.length && !Q.includePrerelease) {\n      for (let I = 0; I < A.length; I++) {\n        VG(A[I].semver);\n        if (A[I].semver === JJ1.ANY) {\n          continue;\n        }\n        if (A[I].semver.prerelease.length > 0) {\n          let G = A[I].semver;\n          if (G.major === B.major && G.minor === B.minor && G.patch === B.patch) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    return true;\n  };\n});\nvar q0A = z((bvI, E_0) => {\n  var kp9 = c$();\n  var _p9 = (A, B, Q) => {\n    try {\n      B = new kp9(B, Q);\n    } catch (I) {\n      return false;\n    }\n    return B.test(A);\n  };\n  E_0.exports = _p9;\n});\nvar _________initializeRenderer = z((createSharpModule, _createSharpModule) => {\n  _createSharpModule.exports = {\n    name: \"sharp\",\n    description: \"High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images\",\n    version: \"0.33.5\",\n    author: \"Lovell Fuller <npm@lovell.info>\",\n    homepage: \"https://sharp.pixelplumbing.com\",\n    contributors: [\"Pierre Inglebert <pierre.inglebert@gmail.com>\", \"Jonathan Ong <jonathanrichardong@gmail.com>\", \"Chanon Sajjamanochai <chanon.s@gmail.com>\", \"Juliano Julio <julianojulio@gmail.com>\", \"Daniel Gasienica <daniel@gasienica.ch>\", \"Julian Walker <julian@fiftythree.com>\", \"Amit Pitaru <pitaru.amit@gmail.com>\", \"Brandon Aaron <hello.brandon@aaron.sh>\", \"Andreas Lind <andreas@one.com>\", \"Maurus Cuelenaere <mcuelenaere@gmail.com>\", \"Linus Unnebäck <linus@folkdatorn.se>\", \"Victor Mateevitsi <mvictoras@gmail.com>\", \"Alaric Holloway <alaric.holloway@gmail.com>\", \"Bernhard K. Weisshuhn <bkw@codingforce.com>\", \"Chris Riley <criley@primedia.com>\", \"David Carley <dacarley@gmail.com>\", \"John Tobin <john@limelightmobileinc.com>\", \"Kenton Gray <kentongray@gmail.com>\", \"Felix Bünemann <Felix.Buenemann@gmail.com>\", \"Samy Al Zahrani <samyalzahrany@gmail.com>\", \"Chintan Thakkar <lemnisk8@gmail.com>\", \"F. Orlando Galashan <frulo@gmx.de>\", \"Kleis Auke Wolthuizen <info@kleisauke.nl>\", \"Matt Hirsch <mhirsch@media.mit.edu>\", \"Matthias Thoemmes <thoemmes@gmail.com>\", \"Patrick Paskaris <patrick@paskaris.gr>\", \"Jérémy Lal <kapouer@melix.org>\", \"Rahul Nanwani <r.nanwani@gmail.com>\", \"Alice Monday <alice0meta@gmail.com>\", \"Kristo Jorgenson <kristo.jorgenson@gmail.com>\", \"YvesBos <yves_bos@outlook.com>\", \"Guy Maliar <guy@tailorbrands.com>\", \"Nicolas Coden <nicolas@ncoden.fr>\", \"Matt Parrish <matt.r.parrish@gmail.com>\", \"Marcel Bretschneider <marcel.bretschneider@gmail.com>\", \"Matthew McEachen <matthew+github@mceachen.org>\", \"Jarda Kotěšovec <jarda.kotesovec@gmail.com>\", \"Kenric D'Souza <kenric.dsouza@gmail.com>\", \"Oleh Aleinyk <oleg.aleynik@gmail.com>\", \"Marcel Bretschneider <marcel.bretschneider@gmail.com>\", \"Andrea Bianco <andrea.bianco@unibas.ch>\", \"Rik Heywood <rik@rik.org>\", \"Thomas Parisot <hi@oncletom.io>\", \"Nathan Graves <nathanrgraves+github@gmail.com>\", \"Tom Lokhorst <tom@lokhorst.eu>\", \"Espen Hovlandsdal <espen@hovlandsdal.com>\", \"Sylvain Dumont <sylvain.dumont35@gmail.com>\", \"Alun Davies <alun.owain.davies@googlemail.com>\", \"Aidan Hoolachan <ajhoolachan21@gmail.com>\", \"Axel Eirola <axel.eirola@iki.fi>\", \"Freezy <freezy@xbmc.org>\", \"Daiz <taneli.vatanen@gmail.com>\", \"Julian Aubourg <j@ubourg.net>\", \"Keith Belovay <keith@picthrive.com>\", \"Michael B. Klein <mbklein@gmail.com>\", \"Jordan Prudhomme <jordan@raboland.fr>\", \"Ilya Ovdin <iovdin@gmail.com>\", \"Andargor <andargor@yahoo.com>\", \"Paul Neave <paul.neave@gmail.com>\", \"Brendan Kennedy <brenwken@gmail.com>\", \"Brychan Bennett-Odlum <git@brychan.io>\", \"Edward Silverton <e.silverton@gmail.com>\", \"Roman Malieiev <aromaleev@gmail.com>\", \"Tomas Szabo <tomas.szabo@deftomat.com>\", \"Robert O'Rourke <robert@o-rourke.org>\", \"Guillermo Alfonso Varela Chouciño <guillevch@gmail.com>\", \"Christian Flintrup <chr@gigahost.dk>\", \"Manan Jadhav <manan@motionden.com>\", \"Leon Radley <leon@radley.se>\", \"alza54 <alza54@thiocod.in>\", \"Jacob Smith <jacob@frende.me>\", \"Michael Nutt <michael@nutt.im>\", \"Brad Parham <baparham@gmail.com>\", \"Taneli Vatanen <taneli.vatanen@gmail.com>\", \"Joris Dugué <zaruike10@gmail.com>\", \"Chris Banks <christopher.bradley.banks@gmail.com>\", \"Ompal Singh <ompal.hitm09@gmail.com>\", \"Brodan <christopher.hranj@gmail.com>\", \"Ankur Parihar <ankur.github@gmail.com>\", \"Brahim Ait elhaj <brahima@gmail.com>\", \"Mart Jansink <m.jansink@gmail.com>\", \"Lachlan Newman <lachnewman007@gmail.com>\", \"Dennis Beatty <dennis@dcbeatty.com>\", \"Ingvar Stepanyan <me@rreverser.com>\", \"Don Denton <don@happycollision.com>\"],\n    scripts: {\n      install: \"node install/check\",\n      clean: \"rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*\",\n      test: \"npm run test-lint && npm run test-unit && npm run test-licensing && npm run test-types\",\n      \"test-lint\": \"semistandard && cpplint\",\n      \"test-unit\": \"nyc --reporter=lcov --reporter=text --check-coverage --branches=100 mocha\",\n      \"test-licensing\": \"license-checker --production --summary --onlyAllow=\\\"Apache-2.0;BSD;ISC;LGPL-3.0-or-later;MIT\\\"\",\n      \"test-leak\": \"./test/leak/leak.sh\",\n      \"test-types\": \"tsd\",\n      \"package-from-local-build\": \"node npm/from-local-build\",\n      \"package-from-github-release\": \"node npm/from-github-release\",\n      \"docs-build\": \"node docs/build && node docs/search-index/build\",\n      \"docs-serve\": \"cd docs && npx serve\",\n      \"docs-publish\": \"cd docs && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp\"\n    },\n    type: \"commonjs\",\n    main: \"lib/index.js\",\n    types: \"lib/index.d.ts\",\n    files: [\"install\", \"lib\", \"src/*.{cc,h,gyp}\"],\n    repository: {\n      type: \"git\",\n      url: \"git://github.com/lovell/sharp.git\"\n    },\n    keywords: [\"jpeg\", \"png\", \"webp\", \"avif\", \"tiff\", \"gif\", \"svg\", \"jp2\", \"dzi\", \"image\", \"resize\", \"thumbnail\", \"crop\", \"embed\", \"libvips\", \"vips\"],\n    dependencies: {\n      color: \"^4.2.3\",\n      \"detect-libc\": \"^2.0.3\",\n      semver: \"^7.6.3\"\n    },\n    optionalDependencies: {\n      \"@img/sharp-darwin-arm64\": \"0.33.5\",\n      \"@img/sharp-darwin-x64\": \"0.33.5\",\n      \"@img/sharp-libvips-darwin-arm64\": \"1.0.4\",\n      \"@img/sharp-libvips-darwin-x64\": \"1.0.4\",\n      \"@img/sharp-libvips-linux-arm\": \"1.0.5\",\n      \"@img/sharp-libvips-linux-arm64\": \"1.0.4\",\n      \"@img/sharp-libvips-linux-s390x\": \"1.0.4\",\n      \"@img/sharp-libvips-linux-x64\": \"1.0.4\",\n      \"@img/sharp-libvips-linuxmusl-arm64\": \"1.0.4\",\n      \"@img/sharp-libvips-linuxmusl-x64\": \"1.0.4\",\n      \"@img/sharp-linux-arm\": \"0.33.5\",\n      \"@img/sharp-linux-arm64\": \"0.33.5\",\n      \"@img/sharp-linux-s390x\": \"0.33.5\",\n      \"@img/sharp-linux-x64\": \"0.33.5\",\n      \"@img/sharp-linuxmusl-arm64\": \"0.33.5\",\n      \"@img/sharp-linuxmusl-x64\": \"0.33.5\",\n      \"@img/sharp-wasm32\": \"0.33.5\",\n      \"@img/sharp-win32-ia32\": \"0.33.5\",\n      \"@img/sharp-win32-x64\": \"0.33.5\"\n    },\n    devDependencies: {\n      \"@emnapi/runtime\": \"^1.2.0\",\n      \"@img/sharp-libvips-dev\": \"1.0.4\",\n      \"@img/sharp-libvips-dev-wasm32\": \"1.0.5\",\n      \"@img/sharp-libvips-win32-ia32\": \"1.0.4\",\n      \"@img/sharp-libvips-win32-x64\": \"1.0.4\",\n      \"@types/node\": \"*\",\n      async: \"^3.2.5\",\n      cc: \"^3.0.1\",\n      emnapi: \"^1.2.0\",\n      \"exif-reader\": \"^2.0.1\",\n      \"extract-zip\": \"^2.0.1\",\n      icc: \"^3.0.0\",\n      \"jsdoc-to-markdown\": \"^8.0.3\",\n      \"license-checker\": \"^25.0.1\",\n      mocha: \"^10.7.3\",\n      \"node-addon-api\": \"^8.1.0\",\n      nyc: \"^17.0.0\",\n      prebuild: \"^13.0.1\",\n      semistandard: \"^17.0.0\",\n      \"tar-fs\": \"^3.0.6\",\n      tsd: \"^0.31.1\"\n    },\n    license: \"Apache-2.0\",\n    engines: {\n      node: \"^18.17.0 || ^20.3.0 || >=21.0.0\"\n    },\n    config: {\n      libvips: \">=8.15.3\"\n    },\n    funding: {\n      url: \"https://opencollective.com/libvips\"\n    },\n    binary: {\n      napi_versions: [9]\n    },\n    semistandard: {\n      env: [\"mocha\"]\n    },\n    cc: {\n      linelength: \"120\",\n      filter: [\"build/include\"]\n    },\n    nyc: {\n      include: [\"lib\"]\n    },\n    tsd: {\n      directory: \"test/types/\"\n    }\n  };\n});\nvar FJ1 = z((processLibvipsSetup, moduleExports) => {\n  var {\n    spawnSync: spawnChildProcess\n  } = EA(\"node:child_process\");\n  var {\n    createHash: createHash\n  } = EA(\"node:crypto\");\n  var w_0 = BJ1();\n  var bp9 = CJA();\n  var fp9 = q0A();\n  var H_0 = iPA();\n  var {\n    config: hp9,\n    engines: z_0,\n    optionalDependencies: gp9\n  } = _________initializeRenderer();\n  var up9 = process.env.npm_package_config_libvips || hp9.libvips;\n  var $_0 = w_0(up9).version;\n  var supportedPlatforms = [\"darwin-arm64\", \"darwin-x64\", \"linux-arm\", \"linux-arm64\", \"linux-s390x\", \"linux-x64\", \"linuxmusl-arm64\", \"linuxmusl-x64\", \"win32-ia32\", \"win32-x64\"];\n  var spawnOptions = {\n    encoding: \"utf8\",\n    shell: true\n  };\n  var logInstallationError = A => {\n    if (A instanceof Error) {\n      console.error(`sharp: Installation error: ${A.message}`);\n    } else {\n      console.log(`sharp: ${A}`);\n    }\n  };\n  var q_0 = () => H_0.isNonGlibcLinuxSync() ? H_0.familySync() : \"\";\n  var cp9 = () => `${process.platform}${q_0()}-${process.arch}`;\n  var N0A = () => {\n    if (isUsingEmscripten()) {\n      return \"wasm32\";\n    }\n    let {\n      npm_config_arch: A,\n      npm_config_platform: B,\n      npm_config_libc: Q\n    } = process.env;\n    let I = typeof Q === \"string\" ? Q : q_0();\n    return `${B || process.platform}${I}-${A || process.arch}`;\n  };\n  var pp9 = () => {\n    try {\n      return EA(`@img/sharp-libvips-dev-${N0A()}/include`);\n    } catch {\n      try {\n        return (() => {\n          throw new Error(\"Cannot require module @img/sharp-libvips-dev/include\");\n        })();\n      } catch {}\n    }\n    return \"\";\n  };\n  var getSharpLibvipsCPlusPlusDir = () => {\n    try {\n      return (() => {\n        throw new Error(\"Cannot require module @img/sharp-libvips-dev/cplusplus\");\n      })();\n    } catch {}\n    return \"\";\n  };\n  var ip9 = () => {\n    try {\n      return EA(`@img/sharp-libvips-dev-${N0A()}/lib`);\n    } catch {\n      try {\n        return EA(`@img/sharp-libvips-${N0A()}/lib`);\n      } catch {}\n    }\n    return \"\";\n  };\n  var np9 = () => {\n    if (process.release?.name === \"node\" && process.versions) {\n      if (!fp9(process.versions.node, z_0.node)) {\n        return {\n          found: process.versions.node,\n          expected: z_0.node\n        };\n      }\n    }\n  };\n  var isUsingEmscripten = () => {\n    let {\n      CC: A\n    } = process.env;\n    return Boolean(A && A.endsWith(\"/emcc\"));\n  };\n  var ap9 = () => {\n    if (process.platform === \"darwin\" && process.arch === \"x64\") {\n      return (spawnChildProcess(\"sysctl sysctl.proc_translated\", spawnOptions).stdout || \"\").trim() === \"sysctl.proc_translated: 1\";\n    }\n    return false;\n  };\n  var U_0 = A => createHash(\"sha512\").update(A).digest(\"hex\");\n  var sp9 = () => {\n    try {\n      let A = U_0(`imgsharp-libvips-${N0A()}`);\n      let B = w_0(gp9[`@img/sharp-libvips-${N0A()}`]).version;\n      return U_0(`${A}npm:${B}`).slice(0, 10);\n    } catch {}\n    return \"\";\n  };\n  var rp9 = () => spawnChildProcess(`node-gyp rebuild --directory=src ${isUsingEmscripten() ? \"--nodedir=emscripten\" : \"\"}`, {\n    ...spawnOptions,\n    stdio: \"inherit\"\n  }).status;\n  var L_0 = () => {\n    if (process.platform !== \"win32\") {\n      return (spawnChildProcess(\"pkg-config --modversion vips-cpp\", {\n        ...spawnOptions,\n        env: {\n          ...process.env,\n          PKG_CONFIG_PATH: M_0()\n        }\n      }).stdout || \"\").trim();\n    } else {\n      return \"\";\n    }\n  };\n  var M_0 = () => {\n    if (process.platform !== \"win32\") {\n      return [(spawnChildProcess(\"which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d\\\" \\\" -f2\", spawnOptions).stdout || \"\").trim(), process.env.PKG_CONFIG_PATH, \"/usr/local/lib/pkgconfig\", \"/usr/lib/pkgconfig\", \"/usr/local/libdata/pkgconfig\", \"/usr/libdata/pkgconfig\"].filter(Boolean).join(\":\");\n    } else {\n      return \"\";\n    }\n  };\n  var handleGlobalLibvipsUsage = (A, B, Q) => {\n    if (Q) {\n      Q(`Detected ${B}, skipping search for globally-installed libvips`);\n    }\n    return A;\n  };\n  var op9 = A => {\n    if (Boolean(process.env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {\n      return handleGlobalLibvipsUsage(false, \"SHARP_IGNORE_GLOBAL_LIBVIPS\", A);\n    }\n    if (Boolean(process.env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {\n      return handleGlobalLibvipsUsage(true, \"SHARP_FORCE_GLOBAL_LIBVIPS\", A);\n    }\n    if (ap9()) {\n      return handleGlobalLibvipsUsage(false, \"Rosetta\", A);\n    }\n    let B = L_0();\n    return !!B && bp9(B, $_0);\n  };\n  moduleExports.exports = {\n    minimumLibvipsVersion: $_0,\n    prebuiltPlatforms: supportedPlatforms,\n    buildPlatformArch: N0A,\n    buildSharpLibvipsIncludeDir: pp9,\n    buildSharpLibvipsCPlusPlusDir: getSharpLibvipsCPlusPlusDir,\n    buildSharpLibvipsLibDir: ip9,\n    isUnsupportedNodeRuntime: np9,\n    runtimePlatformArch: cp9,\n    log: logInstallationError,\n    yarnLocator: sp9,\n    spawnRebuild: rp9,\n    globalLibvipsVersion: L_0,\n    pkgConfigPath: M_0,\n    useGlobalLibvips: op9\n  };\n});\nvar HJA = z((uvI, T_0) => {\n  var {\n    familySync: tp9,\n    versionSync: ep9\n  } = iPA();\n  var {\n    runtimePlatformArch: Al9,\n    isUnsupportedNodeRuntime: R_0,\n    prebuiltPlatforms: Bl9,\n    minimumLibvipsVersion: Ql9\n  } = FJ1();\n  var Ni = Al9();\n  var Il9 = [`../src/build/Release/sharp-${Ni}.node`, \"../src/build/Release/sharp-wasm32.node\", `@img/sharp-${Ni}/sharp.node`, \"@img/sharp-wasm32/sharp.node\"];\n  var CJ1;\n  var GjA = [];\n  for (let A of Il9) {\n    try {\n      CJ1 = EA(A);\n      break;\n    } catch (B) {\n      GjA.push(B);\n    }\n  }\n  if (CJ1) {\n    T_0.exports = CJ1;\n  } else {\n    let [A, B, Q] = [\"linux\", \"darwin\", \"win32\"].map(Z => Ni.startsWith(Z));\n    let I = [`Could not load the \"sharp\" module using the ${Ni} runtime`];\n    GjA.forEach(Z => {\n      if (Z.code !== \"MODULE_NOT_FOUND\") {\n        I.push(`${Z.code}: ${Z.message}`);\n      }\n    });\n    let G = GjA.map(Z => Z.message).join(\" \");\n    I.push(\"Possible solutions:\");\n    if (R_0()) {\n      let {\n        found: Z,\n        expected: Y\n      } = R_0();\n      I.push(\"- Please upgrade Node.js:\", `    Found ${Z}`, `    Requires ${Y}`);\n    } else if (Bl9.includes(Ni)) {\n      let [Z, Y] = Ni.split(\"-\");\n      let J = Z.endsWith(\"musl\") ? \" --libc=musl\" : \"\";\n      I.push(\"- Ensure optional dependencies can be installed:\", \"    npm install --include=optional sharp\", \"- Ensure your package manager supports multi-platform installation:\", \"    See https://sharp.pixelplumbing.com/install#cross-platform\", \"- Add platform-specific dependencies:\", `    npm install --os=${Z.replace(\"musl\", \"\")}${J} --cpu=${Y} sharp`);\n    } else {\n      I.push(`- Manually install libvips >= ${Ql9}`, \"- Add experimental WebAssembly-based dependencies:\", \"    npm install --cpu=wasm32 sharp\", \"    npm install @img/sharp-wasm32\");\n    }\n    if (A && /(symbol not found|CXXABI_)/i.test(G)) {\n      try {\n        let {\n          config: Z\n        } = EA(`@img/sharp-libvips-${Ni}/package`);\n        let Y = `${tp9()} ${ep9()}`;\n        let J = `${Z.musl ? \"musl\" : \"glibc\"} ${Z.musl || Z.glibc}`;\n        I.push(\"- Update your OS:\", `    Found ${Y}`, `    Requires ${J}`);\n      } catch (Z) {}\n    }\n    if (A && /\\/snap\\/core[0-9]{2}/.test(G)) {\n      I.push(\"- Remove the Node.js Snap, which does not support native modules\", \"    snap remove node\");\n    }\n    if (B && /Incompatible library version/.test(G)) {\n      I.push(\"- Update Homebrew:\", \"    brew update && brew upgrade vips\");\n    }\n    if (GjA.some(Z => Z.code === \"ERR_DLOPEN_DISABLED\")) {\n      I.push(\"- Run Node.js without using the --no-addons flag\");\n    }\n    if (Q && /The specified procedure could not be found/.test(G)) {\n      I.push(\"- Using the canvas package on Windows?\", \"    See https://sharp.pixelplumbing.com/install#canvas-and-windows\", \"- Check for outdated versions of sharp in the dependency tree:\", \"    npm ls sharp\");\n    }\n    I.push(\"- Consult the installation documentation:\", \"    See https://sharp.pixelplumbing.com/install\");\n    throw Error(I.join(`\n`));\n  }\n});\nvar j_0 = z((createImageProcessor, ImageProcessor) => {\n  var loadUtilModule = EA(\"node:util\");\n  var StreamProcessingModule = EA(\"node:stream\");\n  var Zl9 = _______initializeRenderer();\n  HJA();\n  var Yl9 = loadUtilModule.debuglog(\"sharp\");\n  function Li(_ImageProcessor, inputDescriptor) {\n    if (arguments.length === 1 && !Zl9.defined(_ImageProcessor)) {\n      throw Error(\"Invalid input\");\n    }\n    if (!(this instanceof Li)) {\n      return new Li(_ImageProcessor, inputDescriptor);\n    }\n    StreamProcessingModule.Duplex.call(this);\n    this.options = {\n      topOffsetPre: -1,\n      leftOffsetPre: -1,\n      widthPre: -1,\n      heightPre: -1,\n      topOffsetPost: -1,\n      leftOffsetPost: -1,\n      widthPost: -1,\n      heightPost: -1,\n      width: -1,\n      height: -1,\n      canvas: \"crop\",\n      position: 0,\n      resizeBackground: [0, 0, 0, 255],\n      useExifOrientation: false,\n      angle: 0,\n      rotationAngle: 0,\n      rotationBackground: [0, 0, 0, 255],\n      rotateBeforePreExtract: false,\n      flip: false,\n      flop: false,\n      extendTop: 0,\n      extendBottom: 0,\n      extendLeft: 0,\n      extendRight: 0,\n      extendBackground: [0, 0, 0, 255],\n      extendWith: \"background\",\n      withoutEnlargement: false,\n      withoutReduction: false,\n      affineMatrix: [],\n      affineBackground: [0, 0, 0, 255],\n      affineIdx: 0,\n      affineIdy: 0,\n      affineOdx: 0,\n      affineOdy: 0,\n      affineInterpolator: this.constructor.interpolators.bilinear,\n      kernel: \"lanczos3\",\n      fastShrinkOnLoad: true,\n      tint: [-1, 0, 0, 0],\n      flatten: false,\n      flattenBackground: [0, 0, 0],\n      unflatten: false,\n      negate: false,\n      negateAlpha: true,\n      medianSize: 0,\n      blurSigma: 0,\n      precision: \"integer\",\n      minAmpl: 0.2,\n      sharpenSigma: 0,\n      sharpenM1: 1,\n      sharpenM2: 2,\n      sharpenX1: 2,\n      sharpenY2: 10,\n      sharpenY3: 20,\n      threshold: 0,\n      thresholdGrayscale: true,\n      trimBackground: [],\n      trimThreshold: -1,\n      trimLineArt: false,\n      gamma: 0,\n      gammaOut: 0,\n      greyscale: false,\n      normalise: false,\n      normaliseLower: 1,\n      normaliseUpper: 99,\n      claheWidth: 0,\n      claheHeight: 0,\n      claheMaxSlope: 3,\n      brightness: 1,\n      saturation: 1,\n      hue: 0,\n      lightness: 0,\n      booleanBufferIn: null,\n      booleanFileIn: \"\",\n      joinChannelIn: [],\n      extractChannel: -1,\n      removeAlpha: false,\n      ensureAlpha: -1,\n      colourspace: \"srgb\",\n      colourspacePipeline: \"last\",\n      composite: [],\n      fileOut: \"\",\n      formatOut: \"input\",\n      streamOut: false,\n      keepMetadata: 0,\n      withMetadataOrientation: -1,\n      withMetadataDensity: 0,\n      withIccProfile: \"\",\n      withExif: {},\n      withExifMerge: true,\n      resolveWithObject: false,\n      jpegQuality: 80,\n      jpegProgressive: false,\n      jpegChromaSubsampling: \"4:2:0\",\n      jpegTrellisQuantisation: false,\n      jpegOvershootDeringing: false,\n      jpegOptimiseScans: false,\n      jpegOptimiseCoding: true,\n      jpegQuantisationTable: 0,\n      pngProgressive: false,\n      pngCompressionLevel: 6,\n      pngAdaptiveFiltering: false,\n      pngPalette: false,\n      pngQuality: 100,\n      pngEffort: 7,\n      pngBitdepth: 8,\n      pngDither: 1,\n      jp2Quality: 80,\n      jp2TileHeight: 512,\n      jp2TileWidth: 512,\n      jp2Lossless: false,\n      jp2ChromaSubsampling: \"4:4:4\",\n      webpQuality: 80,\n      webpAlphaQuality: 100,\n      webpLossless: false,\n      webpNearLossless: false,\n      webpSmartSubsample: false,\n      webpPreset: \"default\",\n      webpEffort: 4,\n      webpMinSize: false,\n      webpMixed: false,\n      gifBitdepth: 8,\n      gifEffort: 7,\n      gifDither: 1,\n      gifInterFrameMaxError: 0,\n      gifInterPaletteMaxError: 3,\n      gifReuse: true,\n      gifProgressive: false,\n      tiffQuality: 80,\n      tiffCompression: \"jpeg\",\n      tiffPredictor: \"horizontal\",\n      tiffPyramid: false,\n      tiffMiniswhite: false,\n      tiffBitdepth: 8,\n      tiffTile: false,\n      tiffTileHeight: 256,\n      tiffTileWidth: 256,\n      tiffXres: 1,\n      tiffYres: 1,\n      tiffResolutionUnit: \"inch\",\n      heifQuality: 50,\n      heifLossless: false,\n      heifCompression: \"av1\",\n      heifEffort: 4,\n      heifChromaSubsampling: \"4:4:4\",\n      heifBitdepth: 8,\n      jxlDistance: 1,\n      jxlDecodingTier: 0,\n      jxlEffort: 7,\n      jxlLossless: false,\n      rawDepth: \"uchar\",\n      tileSize: 256,\n      tileOverlap: 0,\n      tileContainer: \"fs\",\n      tileLayout: \"dz\",\n      tileFormat: \"last\",\n      tileDepth: \"last\",\n      tileAngle: 0,\n      tileSkipBlanks: -1,\n      tileBackground: [255, 255, 255, 255],\n      tileCentre: false,\n      tileId: \"https://example.com/iiif\",\n      tileBasename: \"\",\n      timeoutSeconds: 0,\n      linearA: [],\n      linearB: [],\n      debuglog: Q => {\n        this.emit(\"warning\", Q);\n        Yl9(Q);\n      },\n      queueListener: function (Q) {\n        Li.queue.emit(\"change\", Q);\n      }\n    };\n    this.options.input = this._createInputDescriptor(_ImageProcessor, inputDescriptor, {\n      allowStream: true\n    });\n    return this;\n  }\n  Object.setPrototypeOf(Li.prototype, StreamProcessingModule.Duplex.prototype);\n  Object.setPrototypeOf(Li, StreamProcessingModule.Duplex);\n  function Jl9() {\n    let A = this.constructor.call();\n    let {\n      debuglog: B,\n      queueListener: Q,\n      ...I\n    } = this.options;\n    A.options = structuredClone(I);\n    A.options.debuglog = B;\n    A.options.queueListener = Q;\n    if (this._isStreamInput()) {\n      this.on(\"finish\", () => {\n        this._flattenBufferIn();\n        A.options.input.buffer = this.options.input.buffer;\n        A.emit(\"finish\");\n      });\n    }\n    return A;\n  }\n  Object.assign(Li.prototype, {\n    clone: Jl9\n  });\n  ImageProcessor.exports = Li;\n});\nvar ______________________________initializeDevToolsConnection = z((exportColorPalette, colorPaletteModule) => {\n  colorPaletteModule.exports = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    rebeccapurple: [102, 51, 153],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  };\n});\nvar calculateDifferencesBetweenObjects = z((pvI, y_0) => {\n  y_0.exports = function (B) {\n    if (!B || typeof B === \"string\") {\n      return false;\n    }\n    return B instanceof Array || Array.isArray(B) || B.length >= 0 && (B.splice instanceof Function || Object.getOwnPropertyDescriptor(B, B.length - 1) && B.constructor.name !== \"String\");\n  };\n});\nvar v_0 = z((lvI, x_0) => {\n  var Xl9 = calculateDifferencesBetweenObjects();\n  var Wl9 = Array.prototype.concat;\n  var Fl9 = Array.prototype.slice;\n  var __0 = x_0.exports = function (B) {\n    var Q = [];\n    var I = 0;\n    for (var G = B.length; I < G; I++) {\n      var Z = B[I];\n      if (Xl9(Z)) {\n        Q = Wl9.call(Q, Fl9.call(Z));\n      } else {\n        Q.push(Z);\n      }\n    }\n    return Q;\n  };\n  __0.wrap = function (A) {\n    return function () {\n      return A(__0(arguments));\n    };\n  };\n});\nvar g_0 = z((_colorConverter, colorModule) => {\n  var UJA = ______________________________initializeDevToolsConnection();\n  var wJA = v_0();\n  var objectHasOwnProperty = Object.hasOwnProperty;\n  var colorMap = Object.create(null);\n  for (colorKey in UJA) {\n    if (objectHasOwnProperty.call(UJA, colorKey)) {\n      colorMap[UJA[colorKey]] = colorKey;\n    }\n  }\n  var colorKey;\n  var DU = colorModule.exports = {\n    to: {},\n    get: {}\n  };\n  DU.get = function (A) {\n    var B = A.substring(0, 3).toLowerCase();\n    var Q;\n    var I;\n    switch (B) {\n      case \"hsl\":\n        Q = DU.get.hsl(A);\n        I = \"hsl\";\n        break;\n      case \"hwb\":\n        Q = DU.get.hwb(A);\n        I = \"hwb\";\n        break;\n      default:\n        Q = DU.get.rgb(A);\n        I = \"rgb\";\n        break;\n    }\n    if (!Q) {\n      return null;\n    }\n    return {\n      model: I,\n      value: Q\n    };\n  };\n  DU.get.rgb = function (A) {\n    if (!A) {\n      return null;\n    }\n    var B = /^#([a-f0-9]{3,4})$/i;\n    var Q = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;\n    var I = /^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n    var G = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/;\n    var Z = /^(\\w+)$/;\n    var Y = [0, 0, 0, 1];\n    var J;\n    var X;\n    var W;\n    if (J = A.match(Q)) {\n      W = J[2];\n      J = J[1];\n      for (X = 0; X < 3; X++) {\n        var F = X * 2;\n        Y[X] = parseInt(J.slice(F, F + 2), 16);\n      }\n      if (W) {\n        Y[3] = parseInt(W, 16) / 255;\n      }\n    } else if (J = A.match(B)) {\n      J = J[1];\n      W = J[3];\n      for (X = 0; X < 3; X++) {\n        Y[X] = parseInt(J[X] + J[X], 16);\n      }\n      if (W) {\n        Y[3] = parseInt(W + W, 16) / 255;\n      }\n    } else if (J = A.match(I)) {\n      for (X = 0; X < 3; X++) {\n        Y[X] = parseInt(J[X + 1], 0);\n      }\n      if (J[4]) {\n        if (J[5]) {\n          Y[3] = parseFloat(J[4]) * 0.01;\n        } else {\n          Y[3] = parseFloat(J[4]);\n        }\n      }\n    } else if (J = A.match(G)) {\n      for (X = 0; X < 3; X++) {\n        Y[X] = Math.round(parseFloat(J[X + 1]) * 2.55);\n      }\n      if (J[4]) {\n        if (J[5]) {\n          Y[3] = parseFloat(J[4]) * 0.01;\n        } else {\n          Y[3] = parseFloat(J[4]);\n        }\n      }\n    } else if (J = A.match(Z)) {\n      if (J[1] === \"transparent\") {\n        return [0, 0, 0, 0];\n      }\n      if (!objectHasOwnProperty.call(UJA, J[1])) {\n        return null;\n      }\n      Y = UJA[J[1]];\n      Y[3] = 1;\n      return Y;\n    } else {\n      return null;\n    }\n    for (X = 0; X < 3; X++) {\n      Y[X] = gh(Y[X], 0, 255);\n    }\n    Y[3] = gh(Y[3], 0, 1);\n    return Y;\n  };\n  DU.get.hsl = function (A) {\n    if (!A) {\n      return null;\n    }\n    var B = /^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*(?:[,|\\/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n    var Q = A.match(B);\n    if (Q) {\n      var I = parseFloat(Q[4]);\n      var G = (parseFloat(Q[1]) % 360 + 360) % 360;\n      var Z = gh(parseFloat(Q[2]), 0, 100);\n      var Y = gh(parseFloat(Q[3]), 0, 100);\n      var J = gh(isNaN(I) ? 1 : I, 0, 1);\n      return [G, Z, Y, J];\n    }\n    return null;\n  };\n  DU.get.hwb = function (A) {\n    if (!A) {\n      return null;\n    }\n    var B = /^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/;\n    var Q = A.match(B);\n    if (Q) {\n      var I = parseFloat(Q[4]);\n      var G = (parseFloat(Q[1]) % 360 + 360) % 360;\n      var Z = gh(parseFloat(Q[2]), 0, 100);\n      var Y = gh(parseFloat(Q[3]), 0, 100);\n      var J = gh(isNaN(I) ? 1 : I, 0, 1);\n      return [G, Z, Y, J];\n    }\n    return null;\n  };\n  DU.to.hex = function () {\n    var A = wJA(arguments);\n    return \"#\" + ZjA(A[0]) + ZjA(A[1]) + ZjA(A[2]) + (A[3] < 1 ? ZjA(Math.round(A[3] * 255)) : \"\");\n  };\n  DU.to.rgb = function () {\n    var A = wJA(arguments);\n    if (A.length < 4 || A[3] === 1) {\n      return \"rgb(\" + Math.round(A[0]) + \", \" + Math.round(A[1]) + \", \" + Math.round(A[2]) + \")\";\n    } else {\n      return \"rgba(\" + Math.round(A[0]) + \", \" + Math.round(A[1]) + \", \" + Math.round(A[2]) + \", \" + A[3] + \")\";\n    }\n  };\n  DU.to.rgb.percent = function () {\n    var A = wJA(arguments);\n    var B = Math.round(A[0] / 255 * 100);\n    var Q = Math.round(A[1] / 255 * 100);\n    var I = Math.round(A[2] / 255 * 100);\n    if (A.length < 4 || A[3] === 1) {\n      return \"rgb(\" + B + \"%, \" + Q + \"%, \" + I + \"%)\";\n    } else {\n      return \"rgba(\" + B + \"%, \" + Q + \"%, \" + I + \"%, \" + A[3] + \")\";\n    }\n  };\n  DU.to.hsl = function () {\n    var A = wJA(arguments);\n    if (A.length < 4 || A[3] === 1) {\n      return \"hsl(\" + A[0] + \", \" + A[1] + \"%, \" + A[2] + \"%)\";\n    } else {\n      return \"hsla(\" + A[0] + \", \" + A[1] + \"%, \" + A[2] + \"%, \" + A[3] + \")\";\n    }\n  };\n  DU.to.hwb = function () {\n    var A = wJA(arguments);\n    var B = \"\";\n    if (A.length >= 4 && A[3] !== 1) {\n      B = \", \" + A[3];\n    }\n    return \"hwb(\" + A[0] + \", \" + A[1] + \"%, \" + A[2] + \"%\" + B + \")\";\n  };\n  DU.to.keyword = function (A) {\n    return colorMap[A.slice(0, 3)];\n  };\n  function gh(A, B, Q) {\n    return Math.min(Math.max(B, A), Q);\n  }\n  function ZjA(A) {\n    var B = Math.round(A).toString(16).toUpperCase();\n    if (B.length < 2) {\n      return \"0\" + B;\n    } else {\n      return B;\n    }\n  }\n});\nvar DJ1 = z((colorFormatMappingFunction, colorConverter) => {\n  var $JA = ______________________________initializeDevToolsConnection();\n  var colorKeywordMapping = {};\n  for (let A of Object.keys($JA)) {\n    colorKeywordMapping[$JA[A]] = A;\n  }\n  var colorConversionMethods = {\n    rgb: {\n      channels: 3,\n      labels: \"rgb\"\n    },\n    hsl: {\n      channels: 3,\n      labels: \"hsl\"\n    },\n    hsv: {\n      channels: 3,\n      labels: \"hsv\"\n    },\n    hwb: {\n      channels: 3,\n      labels: \"hwb\"\n    },\n    cmyk: {\n      channels: 4,\n      labels: \"cmyk\"\n    },\n    xyz: {\n      channels: 3,\n      labels: \"xyz\"\n    },\n    lab: {\n      channels: 3,\n      labels: \"lab\"\n    },\n    lch: {\n      channels: 3,\n      labels: \"lch\"\n    },\n    hex: {\n      channels: 1,\n      labels: [\"hex\"]\n    },\n    keyword: {\n      channels: 1,\n      labels: [\"keyword\"]\n    },\n    ansi16: {\n      channels: 1,\n      labels: [\"ansi16\"]\n    },\n    ansi256: {\n      channels: 1,\n      labels: [\"ansi256\"]\n    },\n    hcg: {\n      channels: 3,\n      labels: [\"h\", \"c\", \"g\"]\n    },\n    apple: {\n      channels: 3,\n      labels: [\"r16\", \"g16\", \"b16\"]\n    },\n    gray: {\n      channels: 1,\n      labels: [\"gray\"]\n    }\n  };\n  colorConverter.exports = colorConversionMethods;\n  for (let A of Object.keys(colorConversionMethods)) {\n    if (!(\"channels\" in colorConversionMethods[A])) {\n      throw Error(\"missing channels property: \" + A);\n    }\n    if (!(\"labels\" in colorConversionMethods[A])) {\n      throw Error(\"missing channel labels property: \" + A);\n    }\n    if (colorConversionMethods[A].labels.length !== colorConversionMethods[A].channels) {\n      throw Error(\"channel and label counts mismatch: \" + A);\n    }\n    let {\n      channels: B,\n      labels: Q\n    } = colorConversionMethods[A];\n    delete colorConversionMethods[A].channels;\n    delete colorConversionMethods[A].labels;\n    Object.defineProperty(colorConversionMethods[A], \"channels\", {\n      value: B\n    });\n    Object.defineProperty(colorConversionMethods[A], \"labels\", {\n      value: Q\n    });\n  }\n  colorConversionMethods.rgb.hsl = function (A) {\n    let B = A[0] / 255;\n    let Q = A[1] / 255;\n    let I = A[2] / 255;\n    let G = Math.min(B, Q, I);\n    let Z = Math.max(B, Q, I);\n    let Y = Z - G;\n    let J;\n    let X;\n    if (Z === G) {\n      J = 0;\n    } else if (B === Z) {\n      J = (Q - I) / Y;\n    } else if (Q === Z) {\n      J = 2 + (I - B) / Y;\n    } else if (I === Z) {\n      J = 4 + (B - Q) / Y;\n    }\n    J = Math.min(J * 60, 360);\n    if (J < 0) {\n      J += 360;\n    }\n    let W = (G + Z) / 2;\n    if (Z === G) {\n      X = 0;\n    } else if (W <= 0.5) {\n      X = Y / (Z + G);\n    } else {\n      X = Y / (2 - Z - G);\n    }\n    return [J, X * 100, W * 100];\n  };\n  colorConversionMethods.rgb.hsv = function (A) {\n    let B;\n    let Q;\n    let I;\n    let G;\n    let Z;\n    let Y = A[0] / 255;\n    let J = A[1] / 255;\n    let X = A[2] / 255;\n    let W = Math.max(Y, J, X);\n    let F = W - Math.min(Y, J, X);\n    let C = function (V) {\n      return (W - V) / 6 / F + 0.5;\n    };\n    if (F === 0) {\n      G = 0;\n      Z = 0;\n    } else {\n      Z = F / W;\n      B = C(Y);\n      Q = C(J);\n      I = C(X);\n      if (Y === W) {\n        G = I - Q;\n      } else if (J === W) {\n        G = 0.3333333333333333 + B - I;\n      } else if (X === W) {\n        G = 0.6666666666666666 + Q - B;\n      }\n      if (G < 0) {\n        G += 1;\n      } else if (G > 1) {\n        G -= 1;\n      }\n    }\n    return [G * 360, Z * 100, W * 100];\n  };\n  colorConversionMethods.rgb.hwb = function (A) {\n    let B = A[0];\n    let Q = A[1];\n    let I = A[2];\n    let G = colorConversionMethods.rgb.hsl(A)[0];\n    let Z = Math.min(B, Math.min(Q, I)) * 0.00392156862745098;\n    I = 1 - Math.max(B, Math.max(Q, I)) * 0.00392156862745098;\n    return [G, Z * 100, I * 100];\n  };\n  colorConversionMethods.rgb.cmyk = function (A) {\n    let B = A[0] / 255;\n    let Q = A[1] / 255;\n    let I = A[2] / 255;\n    let G = Math.min(1 - B, 1 - Q, 1 - I);\n    let Z = (1 - B - G) / (1 - G) || 0;\n    let Y = (1 - Q - G) / (1 - G) || 0;\n    let J = (1 - I - G) / (1 - G) || 0;\n    return [Z * 100, Y * 100, J * 100, G * 100];\n  };\n  function Cl9(A, B) {\n    return (A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2 + (A[2] - B[2]) ** 2;\n  }\n  colorConversionMethods.rgb.keyword = function (A) {\n    let B = colorKeywordMapping[A];\n    if (B) {\n      return B;\n    }\n    let Q = Infinity;\n    let I;\n    for (let G of Object.keys($JA)) {\n      let Z = $JA[G];\n      let Y = Cl9(A, Z);\n      if (Y < Q) {\n        Q = Y;\n        I = G;\n      }\n    }\n    return I;\n  };\n  colorConversionMethods.keyword.rgb = function (A) {\n    return $JA[A];\n  };\n  colorConversionMethods.rgb.xyz = function (A) {\n    let B = A[0] / 255;\n    let Q = A[1] / 255;\n    let I = A[2] / 255;\n    if (B > 0.04045) {\n      B = ((B + 0.055) / 1.055) ** 2.4;\n    } else {\n      B = B / 12.92;\n    }\n    if (Q > 0.04045) {\n      Q = ((Q + 0.055) / 1.055) ** 2.4;\n    } else {\n      Q = Q / 12.92;\n    }\n    if (I > 0.04045) {\n      I = ((I + 0.055) / 1.055) ** 2.4;\n    } else {\n      I = I / 12.92;\n    }\n    let G = B * 0.4124 + Q * 0.3576 + I * 0.1805;\n    let Z = B * 0.2126 + Q * 0.7152 + I * 0.0722;\n    let Y = B * 0.0193 + Q * 0.1192 + I * 0.9505;\n    return [G * 100, Z * 100, Y * 100];\n  };\n  colorConversionMethods.rgb.lab = function (A) {\n    let B = colorConversionMethods.rgb.xyz(A);\n    let Q = B[0];\n    let I = B[1];\n    let G = B[2];\n    Q /= 95.047;\n    I /= 100;\n    G /= 108.883;\n    if (Q > 0.008856) {\n      Q = Q ** 0.3333333333333333;\n    } else {\n      Q = Q * 7.787 + 0.13793103448275862;\n    }\n    if (I > 0.008856) {\n      I = I ** 0.3333333333333333;\n    } else {\n      I = I * 7.787 + 0.13793103448275862;\n    }\n    if (G > 0.008856) {\n      G = G ** 0.3333333333333333;\n    } else {\n      G = G * 7.787 + 0.13793103448275862;\n    }\n    let Z = I * 116 - 16;\n    let Y = (Q - I) * 500;\n    let J = (I - G) * 200;\n    return [Z, Y, J];\n  };\n  colorConversionMethods.hsl.rgb = function (A) {\n    let B = A[0] / 360;\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    let G;\n    let Z;\n    let Y;\n    if (Q === 0) {\n      Y = I * 255;\n      return [Y, Y, Y];\n    }\n    if (I < 0.5) {\n      G = I * (1 + Q);\n    } else {\n      G = I + Q - I * Q;\n    }\n    let J = I * 2 - G;\n    let X = [0, 0, 0];\n    for (let W = 0; W < 3; W++) {\n      Z = B + -(W - 1) * 0.3333333333333333;\n      if (Z < 0) {\n        Z++;\n      }\n      if (Z > 1) {\n        Z--;\n      }\n      if (Z * 6 < 1) {\n        Y = J + (G - J) * 6 * Z;\n      } else if (Z * 2 < 1) {\n        Y = G;\n      } else if (Z * 3 < 2) {\n        Y = J + (G - J) * (0.6666666666666666 - Z) * 6;\n      } else {\n        Y = J;\n      }\n      X[W] = Y * 255;\n    }\n    return X;\n  };\n  colorConversionMethods.hsl.hsv = function (A) {\n    let B = A[0];\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    let G = Q;\n    let Z = Math.max(I, 0.01);\n    I *= 2;\n    if (I <= 1) {\n      Q *= I;\n    } else {\n      Q *= 2 - I;\n    }\n    if (Z <= 1) {\n      G *= Z;\n    } else {\n      G *= 2 - Z;\n    }\n    let Y = (I + Q) / 2;\n    let J = I === 0 ? G * 2 / (Z + G) : Q * 2 / (I + Q);\n    return [B, J * 100, Y * 100];\n  };\n  colorConversionMethods.hsv.rgb = function (A) {\n    let B = A[0] / 60;\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    let G = Math.floor(B) % 6;\n    let Z = B - Math.floor(B);\n    let Y = I * 255 * (1 - Q);\n    let J = I * 255 * (1 - Q * Z);\n    let X = I * 255 * (1 - Q * (1 - Z));\n    I *= 255;\n    switch (G) {\n      case 0:\n        return [I, X, Y];\n      case 1:\n        return [J, I, Y];\n      case 2:\n        return [Y, I, X];\n      case 3:\n        return [Y, J, I];\n      case 4:\n        return [X, Y, I];\n      case 5:\n        return [I, Y, J];\n    }\n  };\n  colorConversionMethods.hsv.hsl = function (A) {\n    let B = A[0];\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    let G = Math.max(I, 0.01);\n    let Z;\n    let Y;\n    Y = (2 - Q) * I;\n    let J = (2 - Q) * G;\n    Z = Q * G;\n    if (J <= 1) {\n      Z /= J;\n    } else {\n      Z /= 2 - J;\n    }\n    Z = Z || 0;\n    Y /= 2;\n    return [B, Z * 100, Y * 100];\n  };\n  colorConversionMethods.hwb.rgb = function (A) {\n    let B = A[0] / 360;\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    let G = Q + I;\n    let Z;\n    if (G > 1) {\n      Q /= G;\n      I /= G;\n    }\n    let Y = Math.floor(B * 6);\n    let J = 1 - I;\n    Z = B * 6 - Y;\n    if ((Y & 1) !== 0) {\n      Z = 1 - Z;\n    }\n    let X = Q + Z * (J - Q);\n    let W;\n    let F;\n    let C;\n    switch (Y) {\n      default:\n      case 6:\n      case 0:\n        W = J;\n        F = X;\n        C = Q;\n        break;\n      case 1:\n        W = X;\n        F = J;\n        C = Q;\n        break;\n      case 2:\n        W = Q;\n        F = J;\n        C = X;\n        break;\n      case 3:\n        W = Q;\n        F = X;\n        C = J;\n        break;\n      case 4:\n        W = X;\n        F = Q;\n        C = J;\n        break;\n      case 5:\n        W = J;\n        F = Q;\n        C = X;\n        break;\n    }\n    return [W * 255, F * 255, C * 255];\n  };\n  colorConversionMethods.cmyk.rgb = function (A) {\n    let B = A[0] / 100;\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    let G = A[3] / 100;\n    let Z = 1 - Math.min(1, B * (1 - G) + G);\n    let Y = 1 - Math.min(1, Q * (1 - G) + G);\n    let J = 1 - Math.min(1, I * (1 - G) + G);\n    return [Z * 255, Y * 255, J * 255];\n  };\n  colorConversionMethods.xyz.rgb = function (A) {\n    let B = A[0] / 100;\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    let G;\n    let Z;\n    let Y;\n    G = B * 3.2406 + Q * -1.5372 + I * -0.4986;\n    Z = B * -0.9689 + Q * 1.8758 + I * 0.0415;\n    Y = B * 0.0557 + Q * -0.204 + I * 1.057;\n    if (G > 0.0031308) {\n      G = G ** 0.4166666666666667 * 1.055 - 0.055;\n    } else {\n      G = G * 12.92;\n    }\n    if (Z > 0.0031308) {\n      Z = Z ** 0.4166666666666667 * 1.055 - 0.055;\n    } else {\n      Z = Z * 12.92;\n    }\n    if (Y > 0.0031308) {\n      Y = Y ** 0.4166666666666667 * 1.055 - 0.055;\n    } else {\n      Y = Y * 12.92;\n    }\n    G = Math.min(Math.max(0, G), 1);\n    Z = Math.min(Math.max(0, Z), 1);\n    Y = Math.min(Math.max(0, Y), 1);\n    return [G * 255, Z * 255, Y * 255];\n  };\n  colorConversionMethods.xyz.lab = function (A) {\n    let B = A[0];\n    let Q = A[1];\n    let I = A[2];\n    B /= 95.047;\n    Q /= 100;\n    I /= 108.883;\n    if (B > 0.008856) {\n      B = B ** 0.3333333333333333;\n    } else {\n      B = B * 7.787 + 0.13793103448275862;\n    }\n    if (Q > 0.008856) {\n      Q = Q ** 0.3333333333333333;\n    } else {\n      Q = Q * 7.787 + 0.13793103448275862;\n    }\n    if (I > 0.008856) {\n      I = I ** 0.3333333333333333;\n    } else {\n      I = I * 7.787 + 0.13793103448275862;\n    }\n    let G = Q * 116 - 16;\n    let Z = (B - Q) * 500;\n    let Y = (Q - I) * 200;\n    return [G, Z, Y];\n  };\n  colorConversionMethods.lab.xyz = function (A) {\n    let B = A[0];\n    let Q = A[1];\n    let I = A[2];\n    let G;\n    let Z;\n    let Y;\n    Z = (B + 16) / 116;\n    G = Q / 500 + Z;\n    Y = Z - I / 200;\n    let J = Z ** 3;\n    let X = G ** 3;\n    let W = Y ** 3;\n    if (J > 0.008856) {\n      Z = J;\n    } else {\n      Z = (Z - 0.13793103448275862) / 7.787;\n    }\n    if (X > 0.008856) {\n      G = X;\n    } else {\n      G = (G - 0.13793103448275862) / 7.787;\n    }\n    if (W > 0.008856) {\n      Y = W;\n    } else {\n      Y = (Y - 0.13793103448275862) / 7.787;\n    }\n    G *= 95.047;\n    Z *= 100;\n    Y *= 108.883;\n    return [G, Z, Y];\n  };\n  colorConversionMethods.lab.lch = function (A) {\n    let B = A[0];\n    let Q = A[1];\n    let I = A[2];\n    let G;\n    G = Math.atan2(I, Q) * 360 / 2 / Math.PI;\n    if (G < 0) {\n      G += 360;\n    }\n    let Y = Math.sqrt(Q * Q + I * I);\n    return [B, Y, G];\n  };\n  colorConversionMethods.lch.lab = function (A) {\n    let B = A[0];\n    let Q = A[1];\n    let G = A[2] / 360 * 2 * Math.PI;\n    let Z = Q * Math.cos(G);\n    let Y = Q * Math.sin(G);\n    return [B, Z, Y];\n  };\n  colorConversionMethods.rgb.ansi16 = function (A, B = null) {\n    let [Q, I, G] = A;\n    let Z = B === null ? colorConversionMethods.rgb.hsv(A)[2] : B;\n    Z = Math.round(Z / 50);\n    if (Z === 0) {\n      return 30;\n    }\n    let Y = 30 + (Math.round(G / 255) << 2 | Math.round(I / 255) << 1 | Math.round(Q / 255));\n    if (Z === 2) {\n      Y += 60;\n    }\n    return Y;\n  };\n  colorConversionMethods.hsv.ansi16 = function (A) {\n    return colorConversionMethods.rgb.ansi16(colorConversionMethods.hsv.rgb(A), A[2]);\n  };\n  colorConversionMethods.rgb.ansi256 = function (A) {\n    let B = A[0];\n    let Q = A[1];\n    let I = A[2];\n    if (B === Q && Q === I) {\n      if (B < 8) {\n        return 16;\n      }\n      if (B > 248) {\n        return 231;\n      }\n      return Math.round((B - 8) / 247 * 24) + 232;\n    }\n    return 16 + Math.round(B / 255 * 5) * 36 + Math.round(Q / 255 * 5) * 6 + Math.round(I / 255 * 5);\n  };\n  colorConversionMethods.ansi16.rgb = function (A) {\n    let B = A % 10;\n    if (B === 0 || B === 7) {\n      if (A > 50) {\n        B += 3.5;\n      }\n      B = B / 10.5 * 255;\n      return [B, B, B];\n    }\n    let Q = (~~(A > 50) + 1) * 0.5;\n    let I = (B & 1) * Q * 255;\n    let G = (B >> 1 & 1) * Q * 255;\n    let Z = (B >> 2 & 1) * Q * 255;\n    return [I, G, Z];\n  };\n  colorConversionMethods.ansi256.rgb = function (A) {\n    if (A >= 232) {\n      let Z = (A - 232) * 10 + 8;\n      return [Z, Z, Z];\n    }\n    A -= 16;\n    let B;\n    let Q = Math.floor(A / 36) / 5 * 255;\n    let I = Math.floor((B = A % 36) / 6) / 5 * 255;\n    let G = B % 6 / 5 * 255;\n    return [Q, I, G];\n  };\n  colorConversionMethods.rgb.hex = function (A) {\n    let Q = (((Math.round(A[0]) & 255) << 16) + ((Math.round(A[1]) & 255) << 8) + (Math.round(A[2]) & 255)).toString(16).toUpperCase();\n    return \"000000\".substring(Q.length) + Q;\n  };\n  colorConversionMethods.hex.rgb = function (A) {\n    let B = A.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n    if (!B) {\n      return [0, 0, 0];\n    }\n    let Q = B[0];\n    if (B[0].length === 3) {\n      Q = Q.split(\"\").map(J => {\n        return J + J;\n      }).join(\"\");\n    }\n    let I = parseInt(Q, 16);\n    let G = I >> 16 & 255;\n    let Z = I >> 8 & 255;\n    let Y = I & 255;\n    return [G, Z, Y];\n  };\n  colorConversionMethods.rgb.hcg = function (A) {\n    let B = A[0] / 255;\n    let Q = A[1] / 255;\n    let I = A[2] / 255;\n    let G = Math.max(Math.max(B, Q), I);\n    let Z = Math.min(Math.min(B, Q), I);\n    let Y = G - Z;\n    let J;\n    let X;\n    if (Y < 1) {\n      J = Z / (1 - Y);\n    } else {\n      J = 0;\n    }\n    if (Y <= 0) {\n      X = 0;\n    } else if (G === B) {\n      X = (Q - I) / Y % 6;\n    } else if (G === Q) {\n      X = 2 + (I - B) / Y;\n    } else {\n      X = 4 + (B - Q) / Y;\n    }\n    X /= 6;\n    X %= 1;\n    return [X * 360, Y * 100, J * 100];\n  };\n  colorConversionMethods.hsl.hcg = function (A) {\n    let B = A[1] / 100;\n    let Q = A[2] / 100;\n    let I = Q < 0.5 ? B * 2 * Q : B * 2 * (1 - Q);\n    let G = 0;\n    if (I < 1) {\n      G = (Q - I * 0.5) / (1 - I);\n    }\n    return [A[0], I * 100, G * 100];\n  };\n  colorConversionMethods.hsv.hcg = function (A) {\n    let B = A[1] / 100;\n    let Q = A[2] / 100;\n    let I = B * Q;\n    let G = 0;\n    if (I < 1) {\n      G = (Q - I) / (1 - I);\n    }\n    return [A[0], I * 100, G * 100];\n  };\n  colorConversionMethods.hcg.rgb = function (A) {\n    let B = A[0] / 360;\n    let Q = A[1] / 100;\n    let I = A[2] / 100;\n    if (Q === 0) {\n      return [I * 255, I * 255, I * 255];\n    }\n    let G = [0, 0, 0];\n    let Z = B % 1 * 6;\n    let Y = Z % 1;\n    let J = 1 - Y;\n    let X = 0;\n    switch (Math.floor(Z)) {\n      case 0:\n        G[0] = 1;\n        G[1] = Y;\n        G[2] = 0;\n        break;\n      case 1:\n        G[0] = J;\n        G[1] = 1;\n        G[2] = 0;\n        break;\n      case 2:\n        G[0] = 0;\n        G[1] = 1;\n        G[2] = Y;\n        break;\n      case 3:\n        G[0] = 0;\n        G[1] = J;\n        G[2] = 1;\n        break;\n      case 4:\n        G[0] = Y;\n        G[1] = 0;\n        G[2] = 1;\n        break;\n      default:\n        G[0] = 1;\n        G[1] = 0;\n        G[2] = J;\n    }\n    X = (1 - Q) * I;\n    return [(Q * G[0] + X) * 255, (Q * G[1] + X) * 255, (Q * G[2] + X) * 255];\n  };\n  colorConversionMethods.hcg.hsv = function (A) {\n    let B = A[1] / 100;\n    let Q = A[2] / 100;\n    let I = B + Q * (1 - B);\n    let G = 0;\n    if (I > 0) {\n      G = B / I;\n    }\n    return [A[0], G * 100, I * 100];\n  };\n  colorConversionMethods.hcg.hsl = function (A) {\n    let B = A[1] / 100;\n    let I = A[2] / 100 * (1 - B) + B * 0.5;\n    let G = 0;\n    if (I > 0 && I < 0.5) {\n      G = B / (I * 2);\n    } else if (I >= 0.5 && I < 1) {\n      G = B / ((1 - I) * 2);\n    }\n    return [A[0], G * 100, I * 100];\n  };\n  colorConversionMethods.hcg.hwb = function (A) {\n    let B = A[1] / 100;\n    let Q = A[2] / 100;\n    let I = B + Q * (1 - B);\n    return [A[0], (I - B) * 100, (1 - I) * 100];\n  };\n  colorConversionMethods.hwb.hcg = function (A) {\n    let B = A[1] / 100;\n    let I = 1 - A[2] / 100;\n    let G = I - B;\n    let Z = 0;\n    if (G < 1) {\n      Z = (I - G) / (1 - G);\n    }\n    return [A[0], G * 100, Z * 100];\n  };\n  colorConversionMethods.apple.rgb = function (A) {\n    return [A[0] / 65535 * 255, A[1] / 65535 * 255, A[2] / 65535 * 255];\n  };\n  colorConversionMethods.rgb.apple = function (A) {\n    return [A[0] / 255 * 65535, A[1] / 255 * 65535, A[2] / 255 * 65535];\n  };\n  colorConversionMethods.gray.rgb = function (A) {\n    return [A[0] / 100 * 255, A[0] / 100 * 255, A[0] / 100 * 255];\n  };\n  colorConversionMethods.gray.hsl = function (A) {\n    return [0, 0, A[0]];\n  };\n  colorConversionMethods.gray.hsv = colorConversionMethods.gray.hsl;\n  colorConversionMethods.gray.hwb = function (A) {\n    return [0, 100, A[0]];\n  };\n  colorConversionMethods.gray.cmyk = function (A) {\n    return [0, 0, 0, A[0]];\n  };\n  colorConversionMethods.gray.lab = function (A) {\n    return [A[0], 0, 0];\n  };\n  colorConversionMethods.gray.hex = function (A) {\n    let B = Math.round(A[0] / 100 * 255) & 255;\n    let I = ((B << 16) + (B << 8) + B).toString(16).toUpperCase();\n    return \"000000\".substring(I.length) + I;\n  };\n  colorConversionMethods.rgb.gray = function (A) {\n    return [(A[0] + A[1] + A[2]) / 3 / 255 * 100];\n  };\n});\nvar c_0 = z((avI, d_0) => {\n  var YjA = DJ1();\n  function Vl9() {\n    let A = {};\n    let B = Object.keys(YjA);\n    for (let Q = B.length, I = 0; I < Q; I++) {\n      A[B[I]] = {\n        distance: -1,\n        parent: null\n      };\n    }\n    return A;\n  }\n  function Kl9(A) {\n    let B = Vl9();\n    let Q = [A];\n    B[A].distance = 0;\n    while (Q.length) {\n      let I = Q.pop();\n      let G = Object.keys(YjA[I]);\n      for (let Z = G.length, Y = 0; Y < Z; Y++) {\n        let J = G[Y];\n        let X = B[J];\n        if (X.distance === -1) {\n          X.distance = B[I].distance + 1;\n          X.parent = I;\n          Q.unshift(J);\n        }\n      }\n    }\n    return B;\n  }\n  function Dl9(A, B) {\n    return function (Q) {\n      return B(A(Q));\n    };\n  }\n  function El9(A, B) {\n    let Q = [B[A].parent, A];\n    let I = YjA[B[A].parent][A];\n    let G = B[A].parent;\n    while (B[G].parent) {\n      Q.unshift(B[G].parent);\n      I = Dl9(YjA[B[G].parent][G], I);\n      G = B[G].parent;\n    }\n    I.conversion = Q;\n    return I;\n  }\n  d_0.exports = function (A) {\n    let B = Kl9(A);\n    let Q = {};\n    let I = Object.keys(B);\n    for (let G = I.length, Z = 0; Z < G; Z++) {\n      let Y = I[Z];\n      if (B[Y].parent === null) {\n        continue;\n      }\n      Q[Y] = El9(Y, B);\n    }\n    return Q;\n  };\n});\nvar HJ1 = z((svI, p_0) => {\n  var EJ1 = DJ1();\n  var Hl9 = c_0();\n  var L0A = {};\n  var zl9 = Object.keys(EJ1);\n  function Ul9(A) {\n    let B = function (...Q) {\n      let I = Q[0];\n      if (I === undefined || I === null) {\n        return I;\n      }\n      if (I.length > 1) {\n        Q = I;\n      }\n      return A(Q);\n    };\n    if (\"conversion\" in A) {\n      B.conversion = A.conversion;\n    }\n    return B;\n  }\n  function wl9(A) {\n    let B = function (...Q) {\n      let I = Q[0];\n      if (I === undefined || I === null) {\n        return I;\n      }\n      if (I.length > 1) {\n        Q = I;\n      }\n      let G = A(Q);\n      if (typeof G === \"object\") {\n        for (let Z = G.length, Y = 0; Y < Z; Y++) {\n          G[Y] = Math.round(G[Y]);\n        }\n      }\n      return G;\n    };\n    if (\"conversion\" in A) {\n      B.conversion = A.conversion;\n    }\n    return B;\n  }\n  zl9.forEach(A => {\n    L0A[A] = {};\n    Object.defineProperty(L0A[A], \"channels\", {\n      value: EJ1[A].channels\n    });\n    Object.defineProperty(L0A[A], \"labels\", {\n      value: EJ1[A].labels\n    });\n    let B = Hl9(A);\n    Object.keys(B).forEach(I => {\n      let G = B[I];\n      L0A[A][I] = wl9(G);\n      L0A[A][I].raw = Ul9(G);\n    });\n  });\n  p_0.exports = L0A;\n});\nvar XjA = z((colorModelConstructor, ColorConverter) => {\n  var M0A = g_0();\n  var EU = HJ1();\n  var colorModelNames = [\"keyword\", \"gray\", \"hex\"];\n  var colorLabelMap = {};\n  for (let A of Object.keys(EU)) {\n    colorLabelMap[[...EU[A].labels].sort().join(\"\")] = A;\n  }\n  var colorModelTransformations = {};\n  function BF(A, B) {\n    if (!(this instanceof BF)) {\n      return new BF(A, B);\n    }\n    if (B && B in colorModelNames) {\n      B = null;\n    }\n    if (B && !(B in EU)) {\n      throw Error(\"Unknown model: \" + B);\n    }\n    let Q;\n    let I;\n    if (A == null) {\n      this.model = \"rgb\";\n      this.color = [0, 0, 0];\n      this.valpha = 1;\n    } else if (A instanceof BF) {\n      this.model = A.model;\n      this.color = [...A.color];\n      this.valpha = A.valpha;\n    } else if (typeof A === \"string\") {\n      let G = M0A.get(A);\n      if (G === null) {\n        throw Error(\"Unable to parse color from string: \" + A);\n      }\n      this.model = G.model;\n      I = EU[this.model].channels;\n      this.color = G.value.slice(0, I);\n      this.valpha = typeof G.value[I] === \"number\" ? G.value[I] : 1;\n    } else if (A.length > 0) {\n      this.model = B || \"rgb\";\n      I = EU[this.model].channels;\n      let G = Array.prototype.slice.call(A, 0, I);\n      this.color = UJ1(G, I);\n      this.valpha = typeof A[I] === \"number\" ? A[I] : 1;\n    } else if (typeof A === \"number\") {\n      this.model = \"rgb\";\n      this.color = [A >> 16 & 255, A >> 8 & 255, A & 255];\n      this.valpha = 1;\n    } else {\n      this.valpha = 1;\n      let G = Object.keys(A);\n      if (\"alpha\" in A) {\n        G.splice(G.indexOf(\"alpha\"), 1);\n        this.valpha = typeof A.alpha === \"number\" ? A.alpha : 0;\n      }\n      let Z = G.sort().join(\"\");\n      if (!(Z in colorLabelMap)) {\n        throw Error(\"Unable to parse color from object: \" + JSON.stringify(A));\n      }\n      this.model = colorLabelMap[Z];\n      let {\n        labels: Y\n      } = EU[this.model];\n      let J = [];\n      for (Q = 0; Q < Y.length; Q++) {\n        J.push(A[Y[Q]]);\n      }\n      this.color = UJ1(J);\n    }\n    if (colorModelTransformations[this.model]) {\n      I = EU[this.model].channels;\n      for (Q = 0; Q < I; Q++) {\n        let G = colorModelTransformations[this.model][Q];\n        if (G) {\n          this.color[Q] = G(this.color[Q]);\n        }\n      }\n    }\n    this.valpha = Math.max(0, Math.min(1, this.valpha));\n    if (Object.freeze) {\n      Object.freeze(this);\n    }\n  }\n  BF.prototype = {\n    toString() {\n      return this.string();\n    },\n    toJSON() {\n      return this[this.model]();\n    },\n    string(A) {\n      let B = this.model in M0A.to ? this : this.rgb();\n      B = B.round(typeof A === \"number\" ? A : 1);\n      let Q = B.valpha === 1 ? B.color : [...B.color, this.valpha];\n      return M0A.to[B.model](Q);\n    },\n    percentString(A) {\n      let B = this.rgb().round(typeof A === \"number\" ? A : 1);\n      let Q = B.valpha === 1 ? B.color : [...B.color, this.valpha];\n      return M0A.to.rgb.percent(Q);\n    },\n    array() {\n      if (this.valpha === 1) {\n        return [...this.color];\n      } else {\n        return [...this.color, this.valpha];\n      }\n    },\n    object() {\n      let A = {};\n      let {\n        channels: B\n      } = EU[this.model];\n      let {\n        labels: Q\n      } = EU[this.model];\n      for (let I = 0; I < B; I++) {\n        A[Q[I]] = this.color[I];\n      }\n      if (this.valpha !== 1) {\n        A.alpha = this.valpha;\n      }\n      return A;\n    },\n    unitArray() {\n      let A = this.rgb().color;\n      A[0] /= 255;\n      A[1] /= 255;\n      A[2] /= 255;\n      if (this.valpha !== 1) {\n        A.push(this.valpha);\n      }\n      return A;\n    },\n    unitObject() {\n      let A = this.rgb().object();\n      A.r /= 255;\n      A.g /= 255;\n      A.b /= 255;\n      if (this.valpha !== 1) {\n        A.alpha = this.valpha;\n      }\n      return A;\n    },\n    round(A) {\n      A = Math.max(A || 0, 0);\n      return new BF([...this.color.map(ql9(A)), this.valpha], this.model);\n    },\n    alpha(A) {\n      if (A !== undefined) {\n        return new BF([...this.color, Math.max(0, Math.min(1, A))], this.model);\n      }\n      return this.valpha;\n    },\n    red: DY(\"rgb\", 0, YW(255)),\n    green: DY(\"rgb\", 1, YW(255)),\n    blue: DY(\"rgb\", 2, YW(255)),\n    hue: DY([\"hsl\", \"hsv\", \"hsl\", \"hwb\", \"hcg\"], 0, A => (A % 360 + 360) % 360),\n    saturationl: DY(\"hsl\", 1, YW(100)),\n    lightness: DY(\"hsl\", 2, YW(100)),\n    saturationv: DY(\"hsv\", 1, YW(100)),\n    value: DY(\"hsv\", 2, YW(100)),\n    chroma: DY(\"hcg\", 1, YW(100)),\n    gray: DY(\"hcg\", 2, YW(100)),\n    white: DY(\"hwb\", 1, YW(100)),\n    wblack: DY(\"hwb\", 2, YW(100)),\n    cyan: DY(\"cmyk\", 0, YW(100)),\n    magenta: DY(\"cmyk\", 1, YW(100)),\n    yellow: DY(\"cmyk\", 2, YW(100)),\n    black: DY(\"cmyk\", 3, YW(100)),\n    x: DY(\"xyz\", 0, YW(95.047)),\n    y: DY(\"xyz\", 1, YW(100)),\n    z: DY(\"xyz\", 2, YW(108.833)),\n    l: DY(\"lab\", 0, YW(100)),\n    a: DY(\"lab\", 1),\n    b: DY(\"lab\", 2),\n    keyword(A) {\n      if (A !== undefined) {\n        return new BF(A);\n      }\n      return EU[this.model].keyword(this.color);\n    },\n    hex(A) {\n      if (A !== undefined) {\n        return new BF(A);\n      }\n      return M0A.to.hex(this.rgb().round().color);\n    },\n    hexa(A) {\n      if (A !== undefined) {\n        return new BF(A);\n      }\n      let B = this.rgb().round().color;\n      let Q = Math.round(this.valpha * 255).toString(16).toUpperCase();\n      if (Q.length === 1) {\n        Q = \"0\" + Q;\n      }\n      return M0A.to.hex(B) + Q;\n    },\n    rgbNumber() {\n      let A = this.rgb().color;\n      return (A[0] & 255) << 16 | (A[1] & 255) << 8 | A[2] & 255;\n    },\n    luminosity() {\n      let A = this.rgb().color;\n      let B = [];\n      for (let [Q, I] of A.entries()) {\n        let G = I / 255;\n        B[Q] = G <= 0.04045 ? G / 12.92 : ((G + 0.055) / 1.055) ** 2.4;\n      }\n      return B[0] * 0.2126 + B[1] * 0.7152 + B[2] * 0.0722;\n    },\n    contrast(A) {\n      let B = this.luminosity();\n      let Q = A.luminosity();\n      if (B > Q) {\n        return (B + 0.05) / (Q + 0.05);\n      }\n      return (Q + 0.05) / (B + 0.05);\n    },\n    level(A) {\n      let B = this.contrast(A);\n      if (B >= 7) {\n        return \"AAA\";\n      }\n      if (B >= 4.5) {\n        return \"AA\";\n      } else {\n        return \"\";\n      }\n    },\n    isDark() {\n      let A = this.rgb().color;\n      return (A[0] * 2126 + A[1] * 7152 + A[2] * 722) / 10000 < 128;\n    },\n    isLight() {\n      return !this.isDark();\n    },\n    negate() {\n      let A = this.rgb();\n      for (let B = 0; B < 3; B++) {\n        A.color[B] = 255 - A.color[B];\n      }\n      return A;\n    },\n    lighten(A) {\n      let B = this.hsl();\n      B.color[2] += B.color[2] * A;\n      return B;\n    },\n    darken(A) {\n      let B = this.hsl();\n      B.color[2] -= B.color[2] * A;\n      return B;\n    },\n    saturate(A) {\n      let B = this.hsl();\n      B.color[1] += B.color[1] * A;\n      return B;\n    },\n    desaturate(A) {\n      let B = this.hsl();\n      B.color[1] -= B.color[1] * A;\n      return B;\n    },\n    whiten(A) {\n      let B = this.hwb();\n      B.color[1] += B.color[1] * A;\n      return B;\n    },\n    blacken(A) {\n      let B = this.hwb();\n      B.color[2] += B.color[2] * A;\n      return B;\n    },\n    grayscale() {\n      let A = this.rgb().color;\n      let B = A[0] * 0.3 + A[1] * 0.59 + A[2] * 0.11;\n      return BF.rgb(B, B, B);\n    },\n    fade(A) {\n      return this.alpha(this.valpha - this.valpha * A);\n    },\n    opaquer(A) {\n      return this.alpha(this.valpha + this.valpha * A);\n    },\n    rotate(A) {\n      let B = this.hsl();\n      let Q = B.color[0];\n      Q = (Q + A) % 360;\n      if (Q < 0) {\n        Q = 360 + Q;\n      } else {\n        Q = Q;\n      }\n      B.color[0] = Q;\n      return B;\n    },\n    mix(A, B) {\n      if (!A || !A.rgb) {\n        throw Error(\"Argument to \\\"mix\\\" was not a Color instance, but rather an instance of \" + typeof A);\n      }\n      let Q = A.rgb();\n      let I = this.rgb();\n      let G = B === undefined ? 0.5 : B;\n      let Z = G * 2 - 1;\n      let Y = Q.alpha() - I.alpha();\n      let J = ((Z * Y === -1 ? Z : (Z + Y) / (1 + Z * Y)) + 1) / 2;\n      let X = 1 - J;\n      return BF.rgb(J * Q.red() + X * I.red(), J * Q.green() + X * I.green(), J * Q.blue() + X * I.blue(), Q.alpha() * G + I.alpha() * (1 - G));\n    }\n  };\n  for (let A of Object.keys(EU)) {\n    if (colorModelNames.includes(A)) {\n      continue;\n    }\n    let {\n      channels: B\n    } = EU[A];\n    BF.prototype[A] = function (...Q) {\n      if (this.model === A) {\n        return new BF(this);\n      }\n      if (Q.length > 0) {\n        return new BF(Q, A);\n      }\n      return new BF([...Nl9(EU[this.model][A].raw(this.color)), this.valpha], A);\n    };\n    BF[A] = function (...Q) {\n      let I = Q[0];\n      if (typeof I === \"number\") {\n        I = UJ1(Q, B);\n      }\n      return new BF(I, A);\n    };\n  }\n  function $l9(A, B) {\n    return Number(A.toFixed(B));\n  }\n  function ql9(A) {\n    return function (B) {\n      return $l9(B, A);\n    };\n  }\n  function DY(A, B, Q) {\n    if (Array.isArray(A)) {\n      A = A;\n    } else {\n      A = [A];\n    }\n    for (let I of A) {\n      (colorModelTransformations[I] ||= [])[B] = Q;\n    }\n    A = A[0];\n    return function (I) {\n      let G;\n      if (I !== undefined) {\n        if (Q) {\n          I = Q(I);\n        }\n        G = this[A]();\n        G.color[B] = I;\n        return G;\n      }\n      G = this[A]().color[B];\n      if (Q) {\n        G = Q(G);\n      }\n      return G;\n    };\n  }\n  function YW(A) {\n    return function (B) {\n      return Math.max(0, Math.min(A, B));\n    };\n  }\n  function Nl9(A) {\n    if (Array.isArray(A)) {\n      return A;\n    } else {\n      return [A];\n    }\n  }\n  function UJ1(A, B) {\n    for (let Q = 0; Q < B; Q++) {\n      if (typeof A[Q] !== \"number\") {\n        A[Q] = 0;\n      }\n    }\n    return A;\n  }\n  ColorConverter.exports = BF;\n});\nvar s_0 = z((createInputOptions, exportInputUtilities) => {\n  var Ll9 = XjA();\n  var q0 = _______initializeRenderer();\n  var uh = HJA();\n  var textAlignmentMap = {\n    left: \"low\",\n    center: \"centre\",\n    centre: \"centre\",\n    right: \"high\"\n  };\n  function n_0(A) {\n    let {\n      raw: B,\n      density: Q,\n      limitInputPixels: I,\n      ignoreIcc: G,\n      unlimited: Z,\n      sequentialRead: Y,\n      failOn: J,\n      failOnError: X,\n      animated: W,\n      page: F,\n      pages: C,\n      subifd: V\n    } = A;\n    if ([B, Q, I, G, Z, Y, J, X, W, F, C, V].some(q0.defined)) {\n      return {\n        raw: B,\n        density: Q,\n        limitInputPixels: I,\n        ignoreIcc: G,\n        unlimited: Z,\n        sequentialRead: Y,\n        failOn: J,\n        failOnError: X,\n        animated: W,\n        page: F,\n        pages: C,\n        subifd: V\n      };\n    } else {\n      return undefined;\n    }\n  }\n  function Ol9(inputHandler, inputOptions, inputConfiguration) {\n    let I = {\n      failOn: \"warning\",\n      limitInputPixels: Math.pow(16383, 2),\n      ignoreIcc: false,\n      unlimited: false,\n      sequentialRead: true\n    };\n    if (q0.string(inputHandler)) {\n      I.file = inputHandler;\n    } else if (q0.buffer(inputHandler)) {\n      if (inputHandler.length === 0) {\n        throw Error(\"Input Buffer is empty\");\n      }\n      I.buffer = inputHandler;\n    } else if (q0.arrayBuffer(inputHandler)) {\n      if (inputHandler.byteLength === 0) {\n        throw Error(\"Input bit Array is empty\");\n      }\n      I.buffer = Buffer.from(inputHandler, 0, inputHandler.byteLength);\n    } else if (q0.typedArray(inputHandler)) {\n      if (inputHandler.length === 0) {\n        throw Error(\"Input Bit Array is empty\");\n      }\n      I.buffer = Buffer.from(inputHandler.buffer, inputHandler.byteOffset, inputHandler.byteLength);\n    } else if (q0.plainObject(inputHandler) && !q0.defined(inputOptions)) {\n      inputOptions = inputHandler;\n      if (n_0(inputOptions)) {\n        I.buffer = [];\n      }\n    } else if (!q0.defined(inputHandler) && !q0.defined(inputOptions) && q0.object(inputConfiguration) && inputConfiguration.allowStream) {\n      I.buffer = [];\n    } else {\n      throw Error(`Unsupported input '${inputHandler}' of type ${typeof inputHandler}${q0.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : \"\"}`);\n    }\n    if (q0.object(inputOptions)) {\n      if (q0.defined(inputOptions.failOnError)) {\n        if (q0.bool(inputOptions.failOnError)) {\n          I.failOn = inputOptions.failOnError ? \"warning\" : \"none\";\n        } else {\n          throw q0.invalidParameterError(\"failOnError\", \"boolean\", inputOptions.failOnError);\n        }\n      }\n      if (q0.defined(inputOptions.failOn)) {\n        if (q0.string(inputOptions.failOn) && q0.inArray(inputOptions.failOn, [\"none\", \"truncated\", \"error\", \"warning\"])) {\n          I.failOn = inputOptions.failOn;\n        } else {\n          throw q0.invalidParameterError(\"failOn\", \"one of: none, truncated, error, warning\", inputOptions.failOn);\n        }\n      }\n      if (q0.defined(inputOptions.density)) {\n        if (q0.inRange(inputOptions.density, 1, 100000)) {\n          I.density = inputOptions.density;\n        } else {\n          throw q0.invalidParameterError(\"density\", \"number between 1 and 100000\", inputOptions.density);\n        }\n      }\n      if (q0.defined(inputOptions.ignoreIcc)) {\n        if (q0.bool(inputOptions.ignoreIcc)) {\n          I.ignoreIcc = inputOptions.ignoreIcc;\n        } else {\n          throw q0.invalidParameterError(\"ignoreIcc\", \"boolean\", inputOptions.ignoreIcc);\n        }\n      }\n      if (q0.defined(inputOptions.limitInputPixels)) {\n        if (q0.bool(inputOptions.limitInputPixels)) {\n          I.limitInputPixels = inputOptions.limitInputPixels ? Math.pow(16383, 2) : 0;\n        } else if (q0.integer(inputOptions.limitInputPixels) && q0.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {\n          I.limitInputPixels = inputOptions.limitInputPixels;\n        } else {\n          throw q0.invalidParameterError(\"limitInputPixels\", \"positive integer\", inputOptions.limitInputPixels);\n        }\n      }\n      if (q0.defined(inputOptions.unlimited)) {\n        if (q0.bool(inputOptions.unlimited)) {\n          I.unlimited = inputOptions.unlimited;\n        } else {\n          throw q0.invalidParameterError(\"unlimited\", \"boolean\", inputOptions.unlimited);\n        }\n      }\n      if (q0.defined(inputOptions.sequentialRead)) {\n        if (q0.bool(inputOptions.sequentialRead)) {\n          I.sequentialRead = inputOptions.sequentialRead;\n        } else {\n          throw q0.invalidParameterError(\"sequentialRead\", \"boolean\", inputOptions.sequentialRead);\n        }\n      }\n      if (q0.defined(inputOptions.raw)) {\n        if (q0.object(inputOptions.raw) && q0.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && q0.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && q0.integer(inputOptions.raw.channels) && q0.inRange(inputOptions.raw.channels, 1, 4)) {\n          I.rawWidth = inputOptions.raw.width;\n          I.rawHeight = inputOptions.raw.height;\n          I.rawChannels = inputOptions.raw.channels;\n          I.rawPremultiplied = !!inputOptions.raw.premultiplied;\n          switch (inputHandler.constructor) {\n            case Uint8Array:\n            case Uint8ClampedArray:\n              I.rawDepth = \"uchar\";\n              break;\n            case Int8Array:\n              I.rawDepth = \"char\";\n              break;\n            case Uint16Array:\n              I.rawDepth = \"ushort\";\n              break;\n            case Int16Array:\n              I.rawDepth = \"short\";\n              break;\n            case Uint32Array:\n              I.rawDepth = \"uint\";\n              break;\n            case Int32Array:\n              I.rawDepth = \"int\";\n              break;\n            case Float32Array:\n              I.rawDepth = \"float\";\n              break;\n            case Float64Array:\n              I.rawDepth = \"double\";\n              break;\n            default:\n              I.rawDepth = \"uchar\";\n              break;\n          }\n        } else {\n          throw Error(\"Expected width, height and channels for raw pixel input\");\n        }\n      }\n      if (q0.defined(inputOptions.animated)) {\n        if (q0.bool(inputOptions.animated)) {\n          I.pages = inputOptions.animated ? -1 : 1;\n        } else {\n          throw q0.invalidParameterError(\"animated\", \"boolean\", inputOptions.animated);\n        }\n      }\n      if (q0.defined(inputOptions.pages)) {\n        if (q0.integer(inputOptions.pages) && q0.inRange(inputOptions.pages, -1, 100000)) {\n          I.pages = inputOptions.pages;\n        } else {\n          throw q0.invalidParameterError(\"pages\", \"integer between -1 and 100000\", inputOptions.pages);\n        }\n      }\n      if (q0.defined(inputOptions.page)) {\n        if (q0.integer(inputOptions.page) && q0.inRange(inputOptions.page, 0, 100000)) {\n          I.page = inputOptions.page;\n        } else {\n          throw q0.invalidParameterError(\"page\", \"integer between 0 and 100000\", inputOptions.page);\n        }\n      }\n      if (q0.defined(inputOptions.level)) {\n        if (q0.integer(inputOptions.level) && q0.inRange(inputOptions.level, 0, 256)) {\n          I.level = inputOptions.level;\n        } else {\n          throw q0.invalidParameterError(\"level\", \"integer between 0 and 256\", inputOptions.level);\n        }\n      }\n      if (q0.defined(inputOptions.subifd)) {\n        if (q0.integer(inputOptions.subifd) && q0.inRange(inputOptions.subifd, -1, 100000)) {\n          I.subifd = inputOptions.subifd;\n        } else {\n          throw q0.invalidParameterError(\"subifd\", \"integer between -1 and 100000\", inputOptions.subifd);\n        }\n      }\n      if (q0.defined(inputOptions.create)) {\n        if (q0.object(inputOptions.create) && q0.integer(inputOptions.create.width) && inputOptions.create.width > 0 && q0.integer(inputOptions.create.height) && inputOptions.create.height > 0 && q0.integer(inputOptions.create.channels)) {\n          I.createWidth = inputOptions.create.width;\n          I.createHeight = inputOptions.create.height;\n          I.createChannels = inputOptions.create.channels;\n          if (q0.defined(inputOptions.create.noise)) {\n            if (!q0.object(inputOptions.create.noise)) {\n              throw Error(\"Expected noise to be an object\");\n            }\n            if (!q0.inArray(inputOptions.create.noise.type, [\"gaussian\"])) {\n              throw Error(\"Only gaussian noise is supported at the moment\");\n            }\n            if (!q0.inRange(inputOptions.create.channels, 1, 4)) {\n              throw q0.invalidParameterError(\"create.channels\", \"number between 1 and 4\", inputOptions.create.channels);\n            }\n            I.createNoiseType = inputOptions.create.noise.type;\n            if (q0.number(inputOptions.create.noise.mean) && q0.inRange(inputOptions.create.noise.mean, 0, 10000)) {\n              I.createNoiseMean = inputOptions.create.noise.mean;\n            } else {\n              throw q0.invalidParameterError(\"create.noise.mean\", \"number between 0 and 10000\", inputOptions.create.noise.mean);\n            }\n            if (q0.number(inputOptions.create.noise.sigma) && q0.inRange(inputOptions.create.noise.sigma, 0, 10000)) {\n              I.createNoiseSigma = inputOptions.create.noise.sigma;\n            } else {\n              throw q0.invalidParameterError(\"create.noise.sigma\", \"number between 0 and 10000\", inputOptions.create.noise.sigma);\n            }\n          } else if (q0.defined(inputOptions.create.background)) {\n            if (!q0.inRange(inputOptions.create.channels, 3, 4)) {\n              throw q0.invalidParameterError(\"create.channels\", \"number between 3 and 4\", inputOptions.create.channels);\n            }\n            let backgroundColor = Ll9(inputOptions.create.background);\n            I.createBackground = [backgroundColor.red(), backgroundColor.green(), backgroundColor.blue(), Math.round(backgroundColor.alpha() * 255)];\n          } else {\n            throw Error(\"Expected valid noise or background to create a new input image\");\n          }\n          delete I.buffer;\n        } else {\n          throw Error(\"Expected valid width, height and channels to create a new input image\");\n        }\n      }\n      if (q0.defined(inputOptions.text)) {\n        if (q0.object(inputOptions.text) && q0.string(inputOptions.text.text)) {\n          I.textValue = inputOptions.text.text;\n          if (q0.defined(inputOptions.text.height) && q0.defined(inputOptions.text.dpi)) {\n            throw Error(\"Expected only one of dpi or height\");\n          }\n          if (q0.defined(inputOptions.text.font)) {\n            if (q0.string(inputOptions.text.font)) {\n              I.textFont = inputOptions.text.font;\n            } else {\n              throw q0.invalidParameterError(\"text.font\", \"string\", inputOptions.text.font);\n            }\n          }\n          if (q0.defined(inputOptions.text.fontfile)) {\n            if (q0.string(inputOptions.text.fontfile)) {\n              I.textFontfile = inputOptions.text.fontfile;\n            } else {\n              throw q0.invalidParameterError(\"text.fontfile\", \"string\", inputOptions.text.fontfile);\n            }\n          }\n          if (q0.defined(inputOptions.text.width)) {\n            if (q0.integer(inputOptions.text.width) && inputOptions.text.width > 0) {\n              I.textWidth = inputOptions.text.width;\n            } else {\n              throw q0.invalidParameterError(\"text.width\", \"positive integer\", inputOptions.text.width);\n            }\n          }\n          if (q0.defined(inputOptions.text.height)) {\n            if (q0.integer(inputOptions.text.height) && inputOptions.text.height > 0) {\n              I.textHeight = inputOptions.text.height;\n            } else {\n              throw q0.invalidParameterError(\"text.height\", \"positive integer\", inputOptions.text.height);\n            }\n          }\n          if (q0.defined(inputOptions.text.align)) {\n            if (q0.string(inputOptions.text.align) && q0.string(this.constructor.align[inputOptions.text.align])) {\n              I.textAlign = this.constructor.align[inputOptions.text.align];\n            } else {\n              throw q0.invalidParameterError(\"text.align\", \"valid alignment\", inputOptions.text.align);\n            }\n          }\n          if (q0.defined(inputOptions.text.justify)) {\n            if (q0.bool(inputOptions.text.justify)) {\n              I.textJustify = inputOptions.text.justify;\n            } else {\n              throw q0.invalidParameterError(\"text.justify\", \"boolean\", inputOptions.text.justify);\n            }\n          }\n          if (q0.defined(inputOptions.text.dpi)) {\n            if (q0.integer(inputOptions.text.dpi) && q0.inRange(inputOptions.text.dpi, 1, 1000000)) {\n              I.textDpi = inputOptions.text.dpi;\n            } else {\n              throw q0.invalidParameterError(\"text.dpi\", \"integer between 1 and 1000000\", inputOptions.text.dpi);\n            }\n          }\n          if (q0.defined(inputOptions.text.rgba)) {\n            if (q0.bool(inputOptions.text.rgba)) {\n              I.textRgba = inputOptions.text.rgba;\n            } else {\n              throw q0.invalidParameterError(\"text.rgba\", \"bool\", inputOptions.text.rgba);\n            }\n          }\n          if (q0.defined(inputOptions.text.spacing)) {\n            if (q0.integer(inputOptions.text.spacing) && q0.inRange(inputOptions.text.spacing, -1000000, 1000000)) {\n              I.textSpacing = inputOptions.text.spacing;\n            } else {\n              throw q0.invalidParameterError(\"text.spacing\", \"integer between -1000000 and 1000000\", inputOptions.text.spacing);\n            }\n          }\n          if (q0.defined(inputOptions.text.wrap)) {\n            if (q0.string(inputOptions.text.wrap) && q0.inArray(inputOptions.text.wrap, [\"word\", \"char\", \"word-char\", \"none\"])) {\n              I.textWrap = inputOptions.text.wrap;\n            } else {\n              throw q0.invalidParameterError(\"text.wrap\", \"one of: word, char, word-char, none\", inputOptions.text.wrap);\n            }\n          }\n          delete I.buffer;\n        } else {\n          throw Error(\"Expected a valid string to create an image with text.\");\n        }\n      }\n    } else if (q0.defined(inputOptions)) {\n      throw Error(\"Invalid input options \" + inputOptions);\n    }\n    return I;\n  }\n  function Rl9(A, B, Q) {\n    if (Array.isArray(this.options.input.buffer)) {\n      if (q0.buffer(A)) {\n        if (this.options.input.buffer.length === 0) {\n          this.on(\"finish\", () => {\n            this.streamInFinished = true;\n          });\n        }\n        this.options.input.buffer.push(A);\n        Q();\n      } else {\n        Q(Error(\"Non-Buffer data on Writable Stream\"));\n      }\n    } else {\n      Q(Error(\"Unexpected data on Writable Stream\"));\n    }\n  }\n  function Tl9() {\n    if (this._isStreamInput()) {\n      this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n    }\n  }\n  function Pl9() {\n    return Array.isArray(this.options.input.buffer);\n  }\n  function jl9(A) {\n    let B = Error();\n    if (q0.fn(A)) {\n      if (this._isStreamInput()) {\n        this.on(\"finish\", () => {\n          this._flattenBufferIn();\n          uh.metadata(this.options, (Q, I) => {\n            if (Q) {\n              A(q0.nativeError(Q, B));\n            } else {\n              A(null, I);\n            }\n          });\n        });\n      } else {\n        uh.metadata(this.options, (Q, I) => {\n          if (Q) {\n            A(q0.nativeError(Q, B));\n          } else {\n            A(null, I);\n          }\n        });\n      }\n      return this;\n    } else if (this._isStreamInput()) {\n      return new Promise((Q, I) => {\n        let G = () => {\n          this._flattenBufferIn();\n          uh.metadata(this.options, (Z, Y) => {\n            if (Z) {\n              I(q0.nativeError(Z, B));\n            } else {\n              Q(Y);\n            }\n          });\n        };\n        if (this.writableFinished) {\n          G();\n        } else {\n          this.once(\"finish\", G);\n        }\n      });\n    } else {\n      return new Promise((Q, I) => {\n        uh.metadata(this.options, (G, Z) => {\n          if (G) {\n            I(q0.nativeError(G, B));\n          } else {\n            Q(Z);\n          }\n        });\n      });\n    }\n  }\n  function Sl9(A) {\n    let B = Error();\n    if (q0.fn(A)) {\n      if (this._isStreamInput()) {\n        this.on(\"finish\", () => {\n          this._flattenBufferIn();\n          uh.stats(this.options, (Q, I) => {\n            if (Q) {\n              A(q0.nativeError(Q, B));\n            } else {\n              A(null, I);\n            }\n          });\n        });\n      } else {\n        uh.stats(this.options, (Q, I) => {\n          if (Q) {\n            A(q0.nativeError(Q, B));\n          } else {\n            A(null, I);\n          }\n        });\n      }\n      return this;\n    } else if (this._isStreamInput()) {\n      return new Promise((Q, I) => {\n        this.on(\"finish\", function () {\n          this._flattenBufferIn();\n          uh.stats(this.options, (G, Z) => {\n            if (G) {\n              I(q0.nativeError(G, B));\n            } else {\n              Q(Z);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((Q, I) => {\n        uh.stats(this.options, (G, Z) => {\n          if (G) {\n            I(q0.nativeError(G, B));\n          } else {\n            Q(Z);\n          }\n        });\n      });\n    }\n  }\n  exportInputUtilities.exports = function (A) {\n    Object.assign(A.prototype, {\n      _inputOptionsFromObject: n_0,\n      _createInputDescriptor: Ol9,\n      _write: Rl9,\n      _flattenBufferIn: Tl9,\n      _isStreamInput: Pl9,\n      metadata: jl9,\n      stats: Sl9\n    });\n    A.align = textAlignmentMap;\n  };\n});\nvar Bx0 = z((setupImageManipulationOptions, exportImageResizingMethods) => {\n  var h2 = _______initializeRenderer();\n  var directions = {\n    center: 0,\n    centre: 0,\n    north: 1,\n    east: 2,\n    south: 3,\n    west: 4,\n    northeast: 5,\n    southeast: 6,\n    southwest: 7,\n    northwest: 8\n  };\n  var PositionMapping = {\n    top: 1,\n    right: 2,\n    bottom: 3,\n    left: 4,\n    \"right top\": 5,\n    \"right bottom\": 6,\n    \"left bottom\": 7,\n    \"left top\": 8\n  };\n  var imageProcessingOptions = {\n    background: \"background\",\n    copy: \"copy\",\n    repeat: \"repeat\",\n    mirror: \"mirror\"\n  };\n  var resizePositionStrategy = {\n    entropy: 16,\n    attention: 17\n  };\n  var resamplingMethods = {\n    nearest: \"nearest\",\n    linear: \"linear\",\n    cubic: \"cubic\",\n    mitchell: \"mitchell\",\n    lanczos2: \"lanczos2\",\n    lanczos3: \"lanczos3\"\n  };\n  var resizeFitOptions = {\n    contain: \"contain\",\n    cover: \"cover\",\n    fill: \"fill\",\n    inside: \"inside\",\n    outside: \"outside\"\n  };\n  var imageFitOptions = {\n    contain: \"embed\",\n    cover: \"crop\",\n    fill: \"ignore_aspect\",\n    inside: \"max\",\n    outside: \"min\"\n  };\n  function $J1(A) {\n    return A.angle % 360 !== 0 || A.useExifOrientation === true || A.rotationAngle !== 0;\n  }\n  function WjA(A) {\n    return A.width !== -1 || A.height !== -1;\n  }\n  function _l9(A, B, Q) {\n    if (WjA(this.options)) {\n      this.options.debuglog(\"ignoring previous resize options\");\n    }\n    if (this.options.widthPost !== -1) {\n      this.options.debuglog(\"operation order will be: extract, resize, extract\");\n    }\n    if (h2.defined(A)) {\n      if (h2.object(A) && !h2.defined(Q)) {\n        Q = A;\n      } else if (h2.integer(A) && A > 0) {\n        this.options.width = A;\n      } else {\n        throw h2.invalidParameterError(\"width\", \"positive integer\", A);\n      }\n    } else {\n      this.options.width = -1;\n    }\n    if (h2.defined(B)) {\n      if (h2.integer(B) && B > 0) {\n        this.options.height = B;\n      } else {\n        throw h2.invalidParameterError(\"height\", \"positive integer\", B);\n      }\n    } else {\n      this.options.height = -1;\n    }\n    if (h2.object(Q)) {\n      if (h2.defined(Q.width)) {\n        if (h2.integer(Q.width) && Q.width > 0) {\n          this.options.width = Q.width;\n        } else {\n          throw h2.invalidParameterError(\"width\", \"positive integer\", Q.width);\n        }\n      }\n      if (h2.defined(Q.height)) {\n        if (h2.integer(Q.height) && Q.height > 0) {\n          this.options.height = Q.height;\n        } else {\n          throw h2.invalidParameterError(\"height\", \"positive integer\", Q.height);\n        }\n      }\n      if (h2.defined(Q.fit)) {\n        let I = imageFitOptions[Q.fit];\n        if (h2.string(I)) {\n          this.options.canvas = I;\n        } else {\n          throw h2.invalidParameterError(\"fit\", \"valid fit\", Q.fit);\n        }\n      }\n      if (h2.defined(Q.position)) {\n        let I = h2.integer(Q.position) ? Q.position : resizePositionStrategy[Q.position] || PositionMapping[Q.position] || directions[Q.position];\n        if (h2.integer(I) && (h2.inRange(I, 0, 8) || h2.inRange(I, 16, 17))) {\n          this.options.position = I;\n        } else {\n          throw h2.invalidParameterError(\"position\", \"valid position/gravity/strategy\", Q.position);\n        }\n      }\n      this._setBackgroundColourOption(\"resizeBackground\", Q.background);\n      if (h2.defined(Q.kernel)) {\n        if (h2.string(resamplingMethods[Q.kernel])) {\n          this.options.kernel = resamplingMethods[Q.kernel];\n        } else {\n          throw h2.invalidParameterError(\"kernel\", \"valid kernel name\", Q.kernel);\n        }\n      }\n      if (h2.defined(Q.withoutEnlargement)) {\n        this._setBooleanOption(\"withoutEnlargement\", Q.withoutEnlargement);\n      }\n      if (h2.defined(Q.withoutReduction)) {\n        this._setBooleanOption(\"withoutReduction\", Q.withoutReduction);\n      }\n      if (h2.defined(Q.fastShrinkOnLoad)) {\n        this._setBooleanOption(\"fastShrinkOnLoad\", Q.fastShrinkOnLoad);\n      }\n    }\n    if ($J1(this.options) && WjA(this.options)) {\n      this.options.rotateBeforePreExtract = true;\n    }\n    return this;\n  }\n  function xl9(A) {\n    if (h2.integer(A) && A > 0) {\n      this.options.extendTop = A;\n      this.options.extendBottom = A;\n      this.options.extendLeft = A;\n      this.options.extendRight = A;\n    } else if (h2.object(A)) {\n      if (h2.defined(A.top)) {\n        if (h2.integer(A.top) && A.top >= 0) {\n          this.options.extendTop = A.top;\n        } else {\n          throw h2.invalidParameterError(\"top\", \"positive integer\", A.top);\n        }\n      }\n      if (h2.defined(A.bottom)) {\n        if (h2.integer(A.bottom) && A.bottom >= 0) {\n          this.options.extendBottom = A.bottom;\n        } else {\n          throw h2.invalidParameterError(\"bottom\", \"positive integer\", A.bottom);\n        }\n      }\n      if (h2.defined(A.left)) {\n        if (h2.integer(A.left) && A.left >= 0) {\n          this.options.extendLeft = A.left;\n        } else {\n          throw h2.invalidParameterError(\"left\", \"positive integer\", A.left);\n        }\n      }\n      if (h2.defined(A.right)) {\n        if (h2.integer(A.right) && A.right >= 0) {\n          this.options.extendRight = A.right;\n        } else {\n          throw h2.invalidParameterError(\"right\", \"positive integer\", A.right);\n        }\n      }\n      this._setBackgroundColourOption(\"extendBackground\", A.background);\n      if (h2.defined(A.extendWith)) {\n        if (h2.string(imageProcessingOptions[A.extendWith])) {\n          this.options.extendWith = imageProcessingOptions[A.extendWith];\n        } else {\n          throw h2.invalidParameterError(\"extendWith\", \"one of: background, copy, repeat, mirror\", A.extendWith);\n        }\n      }\n    } else {\n      throw h2.invalidParameterError(\"extend\", \"integer or object\", A);\n    }\n    return this;\n  }\n  function vl9(A) {\n    let B = WjA(this.options) || this.options.widthPre !== -1 ? \"Post\" : \"Pre\";\n    if (this.options[`width${B}`] !== -1) {\n      this.options.debuglog(\"ignoring previous extract options\");\n    }\n    [\"left\", \"top\", \"width\", \"height\"].forEach(function (Q) {\n      let I = A[Q];\n      if (h2.integer(I) && I >= 0) {\n        this.options[Q + (Q === \"left\" || Q === \"top\" ? \"Offset\" : \"\") + B] = I;\n      } else {\n        throw h2.invalidParameterError(Q, \"integer\", I);\n      }\n    }, this);\n    if ($J1(this.options) && !WjA(this.options)) {\n      if (this.options.widthPre === -1 || this.options.widthPost === -1) {\n        this.options.rotateBeforePreExtract = true;\n      }\n    }\n    return this;\n  }\n  function bl9(A) {\n    this.options.trimThreshold = 10;\n    if (h2.defined(A)) {\n      if (h2.object(A)) {\n        if (h2.defined(A.background)) {\n          this._setBackgroundColourOption(\"trimBackground\", A.background);\n        }\n        if (h2.defined(A.threshold)) {\n          if (h2.number(A.threshold) && A.threshold >= 0) {\n            this.options.trimThreshold = A.threshold;\n          } else {\n            throw h2.invalidParameterError(\"threshold\", \"positive number\", A.threshold);\n          }\n        }\n        if (h2.defined(A.lineArt)) {\n          this._setBooleanOption(\"trimLineArt\", A.lineArt);\n        }\n      } else {\n        throw h2.invalidParameterError(\"trim\", \"object\", A);\n      }\n    }\n    if ($J1(this.options)) {\n      this.options.rotateBeforePreExtract = true;\n    }\n    return this;\n  }\n  exportImageResizingMethods.exports = function (A) {\n    Object.assign(A.prototype, {\n      resize: _l9,\n      extend: xl9,\n      extract: vl9,\n      trim: bl9\n    });\n    A.gravity = directions;\n    A.strategy = resizePositionStrategy;\n    A.kernel = resamplingMethods;\n    A.fit = resizeFitOptions;\n    A.position = PositionMapping;\n  };\n});\nvar Ix0 = z((evI, Qx0) => {\n  var h3 = _______initializeRenderer();\n  var qJ1 = {\n    clear: \"clear\",\n    source: \"source\",\n    over: \"over\",\n    in: \"in\",\n    out: \"out\",\n    atop: \"atop\",\n    dest: \"dest\",\n    \"dest-over\": \"dest-over\",\n    \"dest-in\": \"dest-in\",\n    \"dest-out\": \"dest-out\",\n    \"dest-atop\": \"dest-atop\",\n    xor: \"xor\",\n    add: \"add\",\n    saturate: \"saturate\",\n    multiply: \"multiply\",\n    screen: \"screen\",\n    overlay: \"overlay\",\n    darken: \"darken\",\n    lighten: \"lighten\",\n    \"colour-dodge\": \"colour-dodge\",\n    \"color-dodge\": \"colour-dodge\",\n    \"colour-burn\": \"colour-burn\",\n    \"color-burn\": \"colour-burn\",\n    \"hard-light\": \"hard-light\",\n    \"soft-light\": \"soft-light\",\n    difference: \"difference\",\n    exclusion: \"exclusion\"\n  };\n  function fl9(A) {\n    if (!Array.isArray(A)) {\n      throw h3.invalidParameterError(\"images to composite\", \"array\", A);\n    }\n    this.options.composite = A.map(B => {\n      if (!h3.object(B)) {\n        throw h3.invalidParameterError(\"image to composite\", \"object\", B);\n      }\n      let Q = this._inputOptionsFromObject(B);\n      let I = {\n        input: this._createInputDescriptor(B.input, Q, {\n          allowStream: false\n        }),\n        blend: \"over\",\n        tile: false,\n        left: 0,\n        top: 0,\n        hasOffset: false,\n        gravity: 0,\n        premultiplied: false\n      };\n      if (h3.defined(B.blend)) {\n        if (h3.string(qJ1[B.blend])) {\n          I.blend = qJ1[B.blend];\n        } else {\n          throw h3.invalidParameterError(\"blend\", \"valid blend name\", B.blend);\n        }\n      }\n      if (h3.defined(B.tile)) {\n        if (h3.bool(B.tile)) {\n          I.tile = B.tile;\n        } else {\n          throw h3.invalidParameterError(\"tile\", \"boolean\", B.tile);\n        }\n      }\n      if (h3.defined(B.left)) {\n        if (h3.integer(B.left)) {\n          I.left = B.left;\n        } else {\n          throw h3.invalidParameterError(\"left\", \"integer\", B.left);\n        }\n      }\n      if (h3.defined(B.top)) {\n        if (h3.integer(B.top)) {\n          I.top = B.top;\n        } else {\n          throw h3.invalidParameterError(\"top\", \"integer\", B.top);\n        }\n      }\n      if (h3.defined(B.top) !== h3.defined(B.left)) {\n        throw Error(\"Expected both left and top to be set\");\n      } else {\n        I.hasOffset = h3.integer(B.top) && h3.integer(B.left);\n      }\n      if (h3.defined(B.gravity)) {\n        if (h3.integer(B.gravity) && h3.inRange(B.gravity, 0, 8)) {\n          I.gravity = B.gravity;\n        } else if (h3.string(B.gravity) && h3.integer(this.constructor.gravity[B.gravity])) {\n          I.gravity = this.constructor.gravity[B.gravity];\n        } else {\n          throw h3.invalidParameterError(\"gravity\", \"valid gravity\", B.gravity);\n        }\n      }\n      if (h3.defined(B.premultiplied)) {\n        if (h3.bool(B.premultiplied)) {\n          I.premultiplied = B.premultiplied;\n        } else {\n          throw h3.invalidParameterError(\"premultiplied\", \"boolean\", B.premultiplied);\n        }\n      }\n      return I;\n    });\n    return this;\n  }\n  Qx0.exports = function (A) {\n    A.prototype.composite = fl9;\n    A.blend = qJ1;\n  };\n});\nvar Yx0 = z((processImageTransformations, exportImageProcessingMethods) => {\n  var hl9 = XjA();\n  var Z0 = _______initializeRenderer();\n  var PrecisionTypes = {\n    integer: \"integer\",\n    float: \"float\",\n    approximate: \"approximate\"\n  };\n  function gl9(A, B) {\n    if (this.options.useExifOrientation || this.options.angle || this.options.rotationAngle) {\n      this.options.debuglog(\"ignoring previous rotate options\");\n    }\n    if (!Z0.defined(A)) {\n      this.options.useExifOrientation = true;\n    } else if (Z0.integer(A) && !(A % 90)) {\n      this.options.angle = A;\n    } else if (Z0.number(A)) {\n      this.options.rotationAngle = A;\n      if (Z0.object(B) && B.background) {\n        let Q = hl9(B.background);\n        this.options.rotationBackground = [Q.red(), Q.green(), Q.blue(), Math.round(Q.alpha() * 255)];\n      }\n    } else {\n      throw Z0.invalidParameterError(\"angle\", \"numeric\", A);\n    }\n    return this;\n  }\n  function ul9(A) {\n    this.options.flip = Z0.bool(A) ? A : true;\n    return this;\n  }\n  function ml9(A) {\n    this.options.flop = Z0.bool(A) ? A : true;\n    return this;\n  }\n  function dl9(A, B) {\n    let Q = [].concat(...A);\n    if (Q.length === 4 && Q.every(Z0.number)) {\n      this.options.affineMatrix = Q;\n    } else {\n      throw Z0.invalidParameterError(\"matrix\", \"1x4 or 2x2 array\", A);\n    }\n    if (Z0.defined(B)) {\n      if (Z0.object(B)) {\n        this._setBackgroundColourOption(\"affineBackground\", B.background);\n        if (Z0.defined(B.idx)) {\n          if (Z0.number(B.idx)) {\n            this.options.affineIdx = B.idx;\n          } else {\n            throw Z0.invalidParameterError(\"options.idx\", \"number\", B.idx);\n          }\n        }\n        if (Z0.defined(B.idy)) {\n          if (Z0.number(B.idy)) {\n            this.options.affineIdy = B.idy;\n          } else {\n            throw Z0.invalidParameterError(\"options.idy\", \"number\", B.idy);\n          }\n        }\n        if (Z0.defined(B.odx)) {\n          if (Z0.number(B.odx)) {\n            this.options.affineOdx = B.odx;\n          } else {\n            throw Z0.invalidParameterError(\"options.odx\", \"number\", B.odx);\n          }\n        }\n        if (Z0.defined(B.ody)) {\n          if (Z0.number(B.ody)) {\n            this.options.affineOdy = B.ody;\n          } else {\n            throw Z0.invalidParameterError(\"options.ody\", \"number\", B.ody);\n          }\n        }\n        if (Z0.defined(B.interpolator)) {\n          if (Z0.inArray(B.interpolator, Object.values(this.constructor.interpolators))) {\n            this.options.affineInterpolator = B.interpolator;\n          } else {\n            throw Z0.invalidParameterError(\"options.interpolator\", \"valid interpolator name\", B.interpolator);\n          }\n        }\n      } else {\n        throw Z0.invalidParameterError(\"options\", \"object\", B);\n      }\n    }\n    return this;\n  }\n  function cl9(A, B, Q) {\n    if (!Z0.defined(A)) {\n      this.options.sharpenSigma = -1;\n    } else if (Z0.bool(A)) {\n      this.options.sharpenSigma = A ? -1 : 0;\n    } else if (Z0.number(A) && Z0.inRange(A, 0.01, 10000)) {\n      this.options.sharpenSigma = A;\n      if (Z0.defined(B)) {\n        if (Z0.number(B) && Z0.inRange(B, 0, 10000)) {\n          this.options.sharpenM1 = B;\n        } else {\n          throw Z0.invalidParameterError(\"flat\", \"number between 0 and 10000\", B);\n        }\n      }\n      if (Z0.defined(Q)) {\n        if (Z0.number(Q) && Z0.inRange(Q, 0, 10000)) {\n          this.options.sharpenM2 = Q;\n        } else {\n          throw Z0.invalidParameterError(\"jagged\", \"number between 0 and 10000\", Q);\n        }\n      }\n    } else if (Z0.plainObject(A)) {\n      if (Z0.number(A.sigma) && Z0.inRange(A.sigma, 0.000001, 10)) {\n        this.options.sharpenSigma = A.sigma;\n      } else {\n        throw Z0.invalidParameterError(\"options.sigma\", \"number between 0.000001 and 10\", A.sigma);\n      }\n      if (Z0.defined(A.m1)) {\n        if (Z0.number(A.m1) && Z0.inRange(A.m1, 0, 1000000)) {\n          this.options.sharpenM1 = A.m1;\n        } else {\n          throw Z0.invalidParameterError(\"options.m1\", \"number between 0 and 1000000\", A.m1);\n        }\n      }\n      if (Z0.defined(A.m2)) {\n        if (Z0.number(A.m2) && Z0.inRange(A.m2, 0, 1000000)) {\n          this.options.sharpenM2 = A.m2;\n        } else {\n          throw Z0.invalidParameterError(\"options.m2\", \"number between 0 and 1000000\", A.m2);\n        }\n      }\n      if (Z0.defined(A.x1)) {\n        if (Z0.number(A.x1) && Z0.inRange(A.x1, 0, 1000000)) {\n          this.options.sharpenX1 = A.x1;\n        } else {\n          throw Z0.invalidParameterError(\"options.x1\", \"number between 0 and 1000000\", A.x1);\n        }\n      }\n      if (Z0.defined(A.y2)) {\n        if (Z0.number(A.y2) && Z0.inRange(A.y2, 0, 1000000)) {\n          this.options.sharpenY2 = A.y2;\n        } else {\n          throw Z0.invalidParameterError(\"options.y2\", \"number between 0 and 1000000\", A.y2);\n        }\n      }\n      if (Z0.defined(A.y3)) {\n        if (Z0.number(A.y3) && Z0.inRange(A.y3, 0, 1000000)) {\n          this.options.sharpenY3 = A.y3;\n        } else {\n          throw Z0.invalidParameterError(\"options.y3\", \"number between 0 and 1000000\", A.y3);\n        }\n      }\n    } else {\n      throw Z0.invalidParameterError(\"sigma\", \"number between 0.01 and 10000\", A);\n    }\n    return this;\n  }\n  function pl9(A) {\n    if (!Z0.defined(A)) {\n      this.options.medianSize = 3;\n    } else if (Z0.integer(A) && Z0.inRange(A, 1, 1000)) {\n      this.options.medianSize = A;\n    } else {\n      throw Z0.invalidParameterError(\"size\", \"integer between 1 and 1000\", A);\n    }\n    return this;\n  }\n  function ll9(A) {\n    let B;\n    if (Z0.number(A)) {\n      B = A;\n    } else if (Z0.plainObject(A)) {\n      if (!Z0.number(A.sigma)) {\n        throw Z0.invalidParameterError(\"options.sigma\", \"number between 0.3 and 1000\", B);\n      }\n      B = A.sigma;\n      if (\"precision\" in A) {\n        if (Z0.string(PrecisionTypes[A.precision])) {\n          this.options.precision = PrecisionTypes[A.precision];\n        } else {\n          throw Z0.invalidParameterError(\"precision\", \"one of: integer, float, approximate\", A.precision);\n        }\n      }\n      if (\"minAmplitude\" in A) {\n        if (Z0.number(A.minAmplitude) && Z0.inRange(A.minAmplitude, 0.001, 1)) {\n          this.options.minAmpl = A.minAmplitude;\n        } else {\n          throw Z0.invalidParameterError(\"minAmplitude\", \"number between 0.001 and 1\", A.minAmplitude);\n        }\n      }\n    }\n    if (!Z0.defined(A)) {\n      this.options.blurSigma = -1;\n    } else if (Z0.bool(A)) {\n      this.options.blurSigma = A ? -1 : 0;\n    } else if (Z0.number(B) && Z0.inRange(B, 0.3, 1000)) {\n      this.options.blurSigma = B;\n    } else {\n      throw Z0.invalidParameterError(\"sigma\", \"number between 0.3 and 1000\", B);\n    }\n    return this;\n  }\n  function il9(A) {\n    this.options.flatten = Z0.bool(A) ? A : true;\n    if (Z0.object(A)) {\n      this._setBackgroundColourOption(\"flattenBackground\", A.background);\n    }\n    return this;\n  }\n  function nl9() {\n    this.options.unflatten = true;\n    return this;\n  }\n  function al9(A, B) {\n    if (!Z0.defined(A)) {\n      this.options.gamma = 2.2;\n    } else if (Z0.number(A) && Z0.inRange(A, 1, 3)) {\n      this.options.gamma = A;\n    } else {\n      throw Z0.invalidParameterError(\"gamma\", \"number between 1.0 and 3.0\", A);\n    }\n    if (!Z0.defined(B)) {\n      this.options.gammaOut = this.options.gamma;\n    } else if (Z0.number(B) && Z0.inRange(B, 1, 3)) {\n      this.options.gammaOut = B;\n    } else {\n      throw Z0.invalidParameterError(\"gammaOut\", \"number between 1.0 and 3.0\", B);\n    }\n    return this;\n  }\n  function sl9(A) {\n    this.options.negate = Z0.bool(A) ? A : true;\n    if (Z0.plainObject(A) && \"alpha\" in A) {\n      if (!Z0.bool(A.alpha)) {\n        throw Z0.invalidParameterError(\"alpha\", \"should be boolean value\", A.alpha);\n      } else {\n        this.options.negateAlpha = A.alpha;\n      }\n    }\n    return this;\n  }\n  function rl9(A) {\n    if (Z0.plainObject(A)) {\n      if (Z0.defined(A.lower)) {\n        if (Z0.number(A.lower) && Z0.inRange(A.lower, 0, 99)) {\n          this.options.normaliseLower = A.lower;\n        } else {\n          throw Z0.invalidParameterError(\"lower\", \"number between 0 and 99\", A.lower);\n        }\n      }\n      if (Z0.defined(A.upper)) {\n        if (Z0.number(A.upper) && Z0.inRange(A.upper, 1, 100)) {\n          this.options.normaliseUpper = A.upper;\n        } else {\n          throw Z0.invalidParameterError(\"upper\", \"number between 1 and 100\", A.upper);\n        }\n      }\n    }\n    if (this.options.normaliseLower >= this.options.normaliseUpper) {\n      throw Z0.invalidParameterError(\"range\", \"lower to be less than upper\", `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);\n    }\n    this.options.normalise = true;\n    return this;\n  }\n  function ol9(A) {\n    return this.normalise(A);\n  }\n  function tl9(A) {\n    if (Z0.plainObject(A)) {\n      if (Z0.integer(A.width) && A.width > 0) {\n        this.options.claheWidth = A.width;\n      } else {\n        throw Z0.invalidParameterError(\"width\", \"integer greater than zero\", A.width);\n      }\n      if (Z0.integer(A.height) && A.height > 0) {\n        this.options.claheHeight = A.height;\n      } else {\n        throw Z0.invalidParameterError(\"height\", \"integer greater than zero\", A.height);\n      }\n      if (Z0.defined(A.maxSlope)) {\n        if (Z0.integer(A.maxSlope) && Z0.inRange(A.maxSlope, 0, 100)) {\n          this.options.claheMaxSlope = A.maxSlope;\n        } else {\n          throw Z0.invalidParameterError(\"maxSlope\", \"integer between 0 and 100\", A.maxSlope);\n        }\n      }\n    } else {\n      throw Z0.invalidParameterError(\"options\", \"plain object\", A);\n    }\n    return this;\n  }\n  function el9(A) {\n    if (!Z0.object(A) || !Array.isArray(A.kernel) || !Z0.integer(A.width) || !Z0.integer(A.height) || !Z0.inRange(A.width, 3, 1001) || !Z0.inRange(A.height, 3, 1001) || A.height * A.width !== A.kernel.length) {\n      throw Error(\"Invalid convolution kernel\");\n    }\n    if (!Z0.integer(A.scale)) {\n      A.scale = A.kernel.reduce(function (B, Q) {\n        return B + Q;\n      }, 0);\n    }\n    if (A.scale < 1) {\n      A.scale = 1;\n    }\n    if (!Z0.integer(A.offset)) {\n      A.offset = 0;\n    }\n    this.options.convKernel = A;\n    return this;\n  }\n  function Ai9(A, B) {\n    if (!Z0.defined(A)) {\n      this.options.threshold = 128;\n    } else if (Z0.bool(A)) {\n      this.options.threshold = A ? 128 : 0;\n    } else if (Z0.integer(A) && Z0.inRange(A, 0, 255)) {\n      this.options.threshold = A;\n    } else {\n      throw Z0.invalidParameterError(\"threshold\", \"integer between 0 and 255\", A);\n    }\n    if (!Z0.object(B) || B.greyscale === true || B.grayscale === true) {\n      this.options.thresholdGrayscale = true;\n    } else {\n      this.options.thresholdGrayscale = false;\n    }\n    return this;\n  }\n  function Bi9(A, B, Q) {\n    this.options.boolean = this._createInputDescriptor(A, Q);\n    if (Z0.string(B) && Z0.inArray(B, [\"and\", \"or\", \"eor\"])) {\n      this.options.booleanOp = B;\n    } else {\n      throw Z0.invalidParameterError(\"operator\", \"one of: and, or, eor\", B);\n    }\n    return this;\n  }\n  function Qi9(A, B) {\n    if (!Z0.defined(A) && Z0.number(B)) {\n      A = 1;\n    } else if (Z0.number(A) && !Z0.defined(B)) {\n      B = 0;\n    }\n    if (!Z0.defined(A)) {\n      this.options.linearA = [];\n    } else if (Z0.number(A)) {\n      this.options.linearA = [A];\n    } else if (Array.isArray(A) && A.length && A.every(Z0.number)) {\n      this.options.linearA = A;\n    } else {\n      throw Z0.invalidParameterError(\"a\", \"number or array of numbers\", A);\n    }\n    if (!Z0.defined(B)) {\n      this.options.linearB = [];\n    } else if (Z0.number(B)) {\n      this.options.linearB = [B];\n    } else if (Array.isArray(B) && B.length && B.every(Z0.number)) {\n      this.options.linearB = B;\n    } else {\n      throw Z0.invalidParameterError(\"b\", \"number or array of numbers\", B);\n    }\n    if (this.options.linearA.length !== this.options.linearB.length) {\n      throw Error(\"Expected a and b to be arrays of the same length\");\n    }\n    return this;\n  }\n  function Ii9(A) {\n    if (!Array.isArray(A)) {\n      throw Z0.invalidParameterError(\"inputMatrix\", \"array\", A);\n    }\n    if (A.length !== 3 && A.length !== 4) {\n      throw Z0.invalidParameterError(\"inputMatrix\", \"3x3 or 4x4 array\", A.length);\n    }\n    let B = A.flat().map(Number);\n    if (B.length !== 9 && B.length !== 16) {\n      throw Z0.invalidParameterError(\"inputMatrix\", \"cardinality of 9 or 16\", B.length);\n    }\n    this.options.recombMatrix = B;\n    return this;\n  }\n  function Gi9(A) {\n    if (!Z0.plainObject(A)) {\n      throw Z0.invalidParameterError(\"options\", \"plain object\", A);\n    }\n    if (\"brightness\" in A) {\n      if (Z0.number(A.brightness) && A.brightness >= 0) {\n        this.options.brightness = A.brightness;\n      } else {\n        throw Z0.invalidParameterError(\"brightness\", \"number above zero\", A.brightness);\n      }\n    }\n    if (\"saturation\" in A) {\n      if (Z0.number(A.saturation) && A.saturation >= 0) {\n        this.options.saturation = A.saturation;\n      } else {\n        throw Z0.invalidParameterError(\"saturation\", \"number above zero\", A.saturation);\n      }\n    }\n    if (\"hue\" in A) {\n      if (Z0.integer(A.hue)) {\n        this.options.hue = A.hue % 360;\n      } else {\n        throw Z0.invalidParameterError(\"hue\", \"number\", A.hue);\n      }\n    }\n    if (\"lightness\" in A) {\n      if (Z0.number(A.lightness)) {\n        this.options.lightness = A.lightness;\n      } else {\n        throw Z0.invalidParameterError(\"lightness\", \"number\", A.lightness);\n      }\n    }\n    return this;\n  }\n  exportImageProcessingMethods.exports = function (A) {\n    Object.assign(A.prototype, {\n      rotate: gl9,\n      flip: ul9,\n      flop: ml9,\n      affine: dl9,\n      sharpen: cl9,\n      median: pl9,\n      blur: ll9,\n      flatten: il9,\n      unflatten: nl9,\n      gamma: al9,\n      negate: sl9,\n      normalise: rl9,\n      normalize: ol9,\n      clahe: tl9,\n      convolve: el9,\n      threshold: Ai9,\n      boolean: Bi9,\n      linear: Qi9,\n      recomb: Ii9,\n      modulate: Gi9\n    });\n  };\n});\nvar Wx0 = z((BbI, Xx0) => {\n  var Zi9 = XjA();\n  var bk = _______initializeRenderer();\n  var Jx0 = {\n    multiband: \"multiband\",\n    \"b-w\": \"b-w\",\n    bw: \"b-w\",\n    cmyk: \"cmyk\",\n    srgb: \"srgb\"\n  };\n  function Yi9(A) {\n    this._setBackgroundColourOption(\"tint\", A);\n    return this;\n  }\n  function Ji9(A) {\n    this.options.greyscale = bk.bool(A) ? A : true;\n    return this;\n  }\n  function Xi9(A) {\n    return this.greyscale(A);\n  }\n  function Wi9(A) {\n    if (!bk.string(A)) {\n      throw bk.invalidParameterError(\"colourspace\", \"string\", A);\n    }\n    this.options.colourspacePipeline = A;\n    return this;\n  }\n  function Fi9(A) {\n    return this.pipelineColourspace(A);\n  }\n  function Ci9(A) {\n    if (!bk.string(A)) {\n      throw bk.invalidParameterError(\"colourspace\", \"string\", A);\n    }\n    this.options.colourspace = A;\n    return this;\n  }\n  function Vi9(A) {\n    return this.toColourspace(A);\n  }\n  function Ki9(A, B) {\n    if (bk.defined(B)) {\n      if (bk.object(B) || bk.string(B)) {\n        let Q = Zi9(B);\n        this.options[A] = [Q.red(), Q.green(), Q.blue(), Math.round(Q.alpha() * 255)];\n      } else {\n        throw bk.invalidParameterError(\"background\", \"object or string\", B);\n      }\n    }\n  }\n  Xx0.exports = function (A) {\n    Object.assign(A.prototype, {\n      tint: Yi9,\n      greyscale: Ji9,\n      grayscale: Xi9,\n      pipelineColourspace: Wi9,\n      pipelineColorspace: Fi9,\n      toColourspace: Ci9,\n      toColorspace: Vi9,\n      _setBackgroundColourOption: Ki9\n    });\n    A.colourspace = Jx0;\n    A.colorspace = Jx0;\n  };\n});\nvar Cx0 = z((QbI, Fx0) => {\n  var rT = _______initializeRenderer();\n  var Di9 = {\n    and: \"and\",\n    or: \"or\",\n    eor: \"eor\"\n  };\n  function Ei9() {\n    this.options.removeAlpha = true;\n    return this;\n  }\n  function Hi9(A) {\n    if (rT.defined(A)) {\n      if (rT.number(A) && rT.inRange(A, 0, 1)) {\n        this.options.ensureAlpha = A;\n      } else {\n        throw rT.invalidParameterError(\"alpha\", \"number between 0 and 1\", A);\n      }\n    } else {\n      this.options.ensureAlpha = 1;\n    }\n    return this;\n  }\n  function zi9(A) {\n    let B = {\n      red: 0,\n      green: 1,\n      blue: 2,\n      alpha: 3\n    };\n    if (Object.keys(B).includes(A)) {\n      A = B[A];\n    }\n    if (rT.integer(A) && rT.inRange(A, 0, 4)) {\n      this.options.extractChannel = A;\n    } else {\n      throw rT.invalidParameterError(\"channel\", \"integer or one of: red, green, blue, alpha\", A);\n    }\n    return this;\n  }\n  function Ui9(A, B) {\n    if (Array.isArray(A)) {\n      A.forEach(function (Q) {\n        this.options.joinChannelIn.push(this._createInputDescriptor(Q, B));\n      }, this);\n    } else {\n      this.options.joinChannelIn.push(this._createInputDescriptor(A, B));\n    }\n    return this;\n  }\n  function wi9(A) {\n    if (rT.string(A) && rT.inArray(A, [\"and\", \"or\", \"eor\"])) {\n      this.options.bandBoolOp = A;\n    } else {\n      throw rT.invalidParameterError(\"boolOp\", \"one of: and, or, eor\", A);\n    }\n    return this;\n  }\n  Fx0.exports = function (A) {\n    Object.assign(A.prototype, {\n      removeAlpha: Ei9,\n      ensureAlpha: Hi9,\n      extractChannel: zi9,\n      joinChannel: Ui9,\n      bandbool: wi9\n    });\n    A.bool = Di9;\n  };\n});",
  "originalFile": "test-samples/claude.js",
  "originalProvider": "openai",
  "originalModel": "gpt-4o-mini",
  "originalArgs": {
    "provider": "openai",
    "outputDir": "output/claude-2025-11-16T19:49:17",
    "baseURL": "https://api.openai.com/v1",
    "contextSize": "100000",
    "maxConcurrent": "25",
    "minBatchSize": "3",
    "maxBatchSize": "100",
    "dependencyMode": "balanced",
    "perf": true,
    "maxMemory": "4096",
    "validate": true,
    "chunkSize": "300000",
    "chunking": true,
    "debugChunks": false,
    "turbo": true,
    "refine": true
  }
}