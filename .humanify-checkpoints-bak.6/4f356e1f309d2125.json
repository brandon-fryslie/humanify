{
  "version": "2.0.0",
  "timestamp": 1763351361663,
  "inputHash": "4f356e1f309d2125",
  "completedBatches": 28,
  "totalBatches": 131,
  "renames": {
    "zx0": "processImageTransformation",
    "qx0": "ImageProcessingEngine",
    "MJ1": "MAX_IMAGE_SIZE",
    "VjA": "maxImageDimension",
    "KjA": "MAX_IMAGE_DIMENSION",
    "DjA": "initializeDjA",
    "EjA": "execSyncChildProcess",
    "Qn9": "extractFileExtension",
    "In9": "getExtensionFromFile",
    "Gn9": "isPathAbsolute",
    "HbI": "getErrorDescriptionForOutputFile",
    "HjA": "HIGHLIGHTED_MAX_WIDTH",
    "Ox0": "outputFileHandler",
    "dh": "displayHandler",
    "Xn9": "imageProcessingFunction",
    "KH": "ReactContext",
    "yx0": "imageProcessingPipeline",
    "Wn9": "imageProcessingOperation",
    "qJA": "componentKey",
    "Cn9": "resolveFilePath",
    "Fn9": "updateImageFormatBasedOnOptions",
    "_x0": "sharpImageProcessor",
    "vx0": "fileFormatMap",
    "Vn9": "defaultImageProcessor",
    "Kn9": "getPathFromHomeDirectory",
    "PJ1": "initializeShapelessPipeline",
    "Hn9": "ImageProcessingModule",
    "zn9": "errorMessages",
    "jJ1": "initializeCustomSettings",
    "yJ1": "generateRandomBytes",
    "B3": "LineSeparator",
    "NjA": "getFolderPath",
    "LjA": "processImageTransformations",
    "$n9": "imageProcessor",
    "hk": "outputImageFormatHandler",
    "qn9": "validateOutputFilePath",
    "ch": "character",
    "nx0": "processImageInput",
    "ax0": "processImage",
    "Rn9": "_imageProcessingPipeline",
    "Tn9": "_processImage",
    "Mi": "setExifData",
    "_J1": "transformImageFormats",
    "ph": "imageProcessingHandler",
    "Av0": "_imageProcessor",
    "Qv0": "ImageProcessingPipeline",
    "Zv0": "processorFunction",
    "Xv0": "__imageProcessingPipeline",
    "Fv0": "__processImage",
    "Vv0": "___imageProcessingPipeline",
    "Dv0": "updateImageOutputOptions",
    "Hv0": "handleImageFormatConversion",
    "Uv0": "imageConversionPipeline",
    "$v0": "____imageProcessingPipeline",
    "RjA": "updateImageFormatSettings",
    "Pv0": "_____imageProcessingPipeline",
    "Sv0": "_imageProcessingHandler",
    "kv0": "enhancedImageProcessingPipeline",
    "vv0": "convertImageFormat",
    "fv0": "processImagePipeline",
    "TjA": "initializeSharpImageProcessing",
    "av0": "______imageProcessingPipeline",
    "rv0": "outputFilePath",
    "Qb0": "outputImageProcessingFunction",
    "uJ1": "processImageAndGenerateOutput",
    "Vs9": "initializeImageProcessingSettings",
    "DH": "ImageHandler",
    "Oi": "setExifMergeOptions",
    "kM": "handleImageProcessing",
    "Ks9": "imageProcessingModule",
    "Xb0": "_______imageProcessingPipeline",
    "Ds9": "imageProcessingOptions",
    "Es9": "_ImageProcessingPipeline",
    "Hs9": "__imageProcessor",
    "Wb0": "__imageProcessingHandler",
    "zs9": "initializeImageProcessingModule",
    "Us9": "processImageOps",
    "ws9": "processImageInWorkflow",
    "HU": "handleImageOutput",
    "mJ1": "maxImageSize",
    "Kb0": "________imageProcessingPipeline",
    "$s9": "jpegOutputFileExtensionRegex",
    "Fb0": "initializeAndLoadImageProcessing",
    "qs9": "processImageConversion",
    "Ns9": "NodePipeline",
    "Ms9": "_________imageProcessingPipeline",
    "Cb0": "__ImageProcessingPipeline",
    "Db0": "_ImageProcessor",
    "Os9": "__________imageProcessingPipeline",
    "zb0": "processAudioFile",
    "Rs9": "ImageProcessor",
    "Ts9": "_processImageInput",
    "wb0": "imageProcessingService",
    "Ps9": "___processImage",
    "dJ1": "updateOutputFilePath",
    "mG": "imageFormatHandler",
    "js9": "___imageProcessor",
    "Ss9": "____imageProcessor",
    "lJ1": "sharpImageProcessing",
    "$b0": "_imageProcessingOptions",
    "yjA": "imagePipeline",
    "kjA": "ImageTransformProcessor",
    "iJ1": "_validateOutputFilePath",
    "ys9": "_processImageTransformation",
    "ks9": "__processImageTransformation",
    "_s9": "updateImageOutputFormat",
    "qb0": "___processImageTransformation",
    "KG": "___________imageProcessingPipeline",
    "_M": "____________imageProcessingPipeline",
    "xs9": "imageTransformationProcessor",
    "vs9": "validateImageOutputOptions",
    "Ti": "_imageTransformationProcessor",
    "PjA": "____processImageTransformation",
    "_0A": "_____imageProcessor",
    "bs9": "_____processImageTransformation",
    "fs9": "__validateOutputFilePath",
    "pJ1": "initializeImageProcessing",
    "RJA": "______processImageTransformation",
    "gs9": "_______processImageTransformation",
    "TJA": "imageTransformationPipeline",
    "Nb0": "________processImageTransformation",
    "jjA": "_processImageTransformations",
    "cJ1": "_imageTransformationPipeline",
    "ds9": "_____________imageProcessingPipeline",
    "cs9": "_________processImageTransformation",
    "ps9": "processImageTransformationHandler",
    "ls9": "__________processImageTransformation",
    "V6": "_updateImageFormatBasedOnOptions",
    "aJ1": "___________processImageTransformation",
    "is9": "isJPEG2000Format",
    "jb0": "____________processImageTransformation",
    "ns9": "__imageTransformationProcessor",
    "as9": "_____________processImageTransformation",
    "ss9": "validateImageOutputSettings",
    "Mb0": "__imageTransformationPipeline",
    "rs9": "______________imageProcessingPipeline",
    "os9": "imageFileProcessor",
    "sJ1": "______________processImageTransformation",
    "Qr9": "_______________processImageTransformation",
    "Ir9": "________________processImageTransformation",
    "Gr9": "_________________processImageTransformation",
    "rJ1": "__________________processImageTransformation",
    "_b0": "___________________processImageTransformation",
    "bb0": "__processImageTransformations",
    "Yr9": "____________________processImageTransformation",
    "Jr9": "___imageTransformationProcessor",
    "Xr9": "_____________________processImageTransformation",
    "x0A": "ImageTransformationProcessor",
    "vb0": "____imageTransformationProcessor",
    "fb0": "_handleImageProcessing",
    "xjA": "______________________processImageTransformation",
    "PJA": "_ImageTransformationProcessor",
    "v0A": "OpenImageProcessingEngine",
    "bjA": "_____imageTransformationProcessor",
    "EH": "_______________________processImageTransformation",
    "jJA": "________________________processImageTransformation",
    "SJA": "_________________________processImageTransformation",
    "yJA": "transformImagePipeline",
    "kJA": "__________________________processImageTransformation",
    "Pi": "setKeepMetadataOptions",
    "oJ1": "_______________imageProcessingPipeline",
    "_JA": "___________________________processImageTransformation",
    "xJA": "_processImageTransformationHandler",
    "vJA": "______imageTransformationProcessor",
    "tJ1": "____________________________processImageTransformation",
    "fJA": "processImageTransformationFunction",
    "BX1": "_____________________________processImageTransformation",
    "kf0": "______________________________processImageTransformation",
    "if0": "_validateImageOutputOptions",
    "Kh0": "________________imageProcessingPipeline",
    "sh": "processImageTransformatio",
    "fh0": "___validateOutputFilePath",
    "XX1": "__updateImageFormatBasedOnOptions",
    "Ig0": "______imageProcessor",
    "Zg0": "_______________________________processImageTransformation",
    "wg0": "________________________________processImageTransformation",
    "jg0": "_processImageTransformationFunction",
    "Iu0": "_________________________________processImageTransformation",
    "Ku0": "__________________________________processImageTransformation",
    "th": "imageTransformationHandler",
    "cu0": "___________________________________processImageTransformation",
    "Ad0": "_______imageTransformationProcessor",
    "IbI": "processImageOutput",
    "Hx0": "registerImageProcessingMethods",
    "NJ1": "pathModule",
    "Y1": "inputValidator",
    "O0A": "_______imageProcessor",
    "Vx0": "supportedImageFormats",
    "$i9": "jp2FileExtensionRegex",
    "Kx0": "generateJP2Error",
    "Dx0": "calculateBitDepth",
    "cgI": "initializeImportsAndSetup",
    "ym0": "moduleExports",
    "dX1": "defineProperty",
    "yB4": "getOwnPropertyDescriptor",
    "kB4": "getOwnPropertyNames",
    "_B4": "objectHasOwnProperty",
    "Om0": "_moduleExports",
    "VgI": "handleHttpRequest",
    "ng0": "nodeHttpHandler",
    "OA4": "createObject",
    "gJA": "definePropertyWithDescriptor",
    "RA4": "getOwnPropertyDescriptorFromObject",
    "TA4": "_getOwnPropertyNames",
    "PA4": "getPrototypeOfObject",
    "jA4": "_hasOwnProperty",
    "gg0": "nodeHttpHandlerExports",
    "CX1": "httpAgent",
    "VX1": "HttpsAgentInstance",
    "_A4": "commonNetworkErrors",
    "zH": "timeoutHandler",
    "xg0": "DEFAULT_REQUEST_TIMEOUT",
    "vA4": "DEFAULT_SOCKET_TIMEOUT",
    "vg0": "defaultRequestTimeout",
    "cg0": "createStreamModule",
    "bg0": "_defaultRequestTimeout",
    "lg0": "__defaultRequestTimeout",
    "fg0": "Http2Protocol",
    "hgI": "initializeModule",
    "Cm0": "__moduleExports",
    "yX1": "_defineProperty",
    "S04": "_getOwnPropertyDescriptor",
    "y04": "getObjectOwnPropertyNames",
    "k04": "__hasOwnProperty",
    "Gm0": "___moduleExports",
    "f04": "parseBooleanString",
    "g04": "MAX_32_BIT_FLOAT",
    "pJA": "validateIntegerValue",
    "m04": "convertToTypedInteger",
    "d04": "expectNonNullValue",
    "Zm0": "expectObject",
    "i04": "numericRegexPattern",
    "Jm0": "parseSpecialFloatValue",
    "MSA": "generateStackTrace",
    "lJA": "consoleLogger",
    "t04": "weekDaysShort",
    "vX1": "monthsArray",
    "AB4": "RFC3339DateTimePattern",
    "QB4": "rfc3339DateTimeRegex",
    "GB4": "RFC7231DateTimeRegex",
    "ZB4": "rfcWeekdayDateTimeFormat",
    "YB4": "rfc7231DateTimeRegex",
    "FB4": "MAX_DATE_DIFF_MILLIS",
    "VB4": "daysInMonth",
    "DB4": "isLeapYear",
    "HB4": "parseTimezoneOffset",
    "d0A": "removeLeadingZeros",
    "wB4": "splitCSV",
    "Fm0": "NumericValue",
    "SgI": "createSchemaExports",
    "Im0": "importSchema",
    "LX1": "__defineProperty",
    "C04": "__getOwnPropertyDescriptor",
    "V04": "__getOwnPropertyNames",
    "K04": "___hasOwnProperty",
    "tu0": "schemaExports",
    "uJA": "invokeOrReturnValue",
    "NX1": "extractRequestIdFromHeaders",
    "eu0": "deserializerMiddlewareOption",
    "Am0": "serializerMiddlewareOptions",
    "u0A": "SchemaDefinition",
    "rY": "SchemaTypeRegistry",
    "tgI": "createHttpRequestSigningMiddleware",
    "pm0": "identityProviderExports",
    "SSA": "definePropertyWithConfig",
    "sB4": "___getOwnPropertyDescriptor",
    "rB4": "___getOwnPropertyNames",
    "oB4": "_objectHasOwnProperty",
    "km0": "_identityProviderExports",
    "vm0": "httpAuthSchemeEndpointRuleSetMiddlewareOptions",
    "hm0": "httpSigningMiddlewareOptions",
    "dm0": "DEFAULT_IDENTITY_EXPIRATION_MS",
    "LgI": "httpRequestHandler",
    "Mu0": "ModuleExports",
    "wSA": "definePropertyWithSetter",
    "S14": "____getOwnPropertyDescriptor",
    "y14": "____getOwnPropertyNames",
    "k14": "____hasOwnProperty",
    "wu0": "httpHandlerExports",
    "USA": "httpKeepAliveSupport",
    "NhI": "createHttpHandlerExtensionConfiguration",
    "Af0": "httpHandlerConfigurationModule",
    "ujA": "___defineProperty",
    "Rr9": "_____getOwnPropertyDescriptor",
    "Tr9": "_____getOwnPropertyNames",
    "Pr9": "_____hasOwnProperty",
    "rb0": "____moduleExports",
    "_hI": "initializeHttpHandlerModule",
    "of0": "_____moduleExports",
    "ejA": "definePropertyWithName",
    "ro9": "______getOwnPropertyDescriptor",
    "oo9": "______getOwnPropertyNames",
    "to9": "______hasOwnProperty",
    "nf0": "______moduleExports",
    "hhI": "configureHttpHandler",
    "Fh0": "httpHandlerExtensionConfig",
    "QSA": "____defineProperty",
    "Et9": "_______getOwnPropertyDescriptor",
    "Ht9": "_______getOwnPropertyNames",
    "zt9": "_______hasOwnProperty",
    "Yh0": "httpHandlerExtensions",
    "YgI": "setupHttpHandlerExtensionConfiguration",
    "Mg0": "_______moduleExports",
    "FSA": "_definePropertyWithConfig",
    "te9": "________getOwnPropertyDescriptor",
    "ee9": "________getOwnPropertyNames",
    "AA4": "________hasOwnProperty",
    "$g0": "_httpHandlerExports",
    "zgI": "httpHandlerExtensionConfigFactory",
    "Xu0": "________moduleExports",
    "ESA": "definePropertyWithMetadata",
    "I14": "getPropertyDescriptor",
    "G14": "getObjectPropertyNames",
    "Z14": "_________hasOwnProperty",
    "Gu0": "httpHandlerConfiguration",
    "mfI": "compareVersionSets",
    "Bb0": "exportVersionComparisonFunction",
    "ov0": "VersionSetComparator",
    "fJ1": "createVersionValidator",
    "OJA": "compareVersionConstraints",
    "hJ1": "compareSemver",
    "Q": "___excludedPropertyName",
    "fhI": "createDeserializerMiddleware",
    "Zh0": "_________moduleExports",
    "ASA": "_definePropertyWithName",
    "Xt9": "_________getOwnPropertyDescriptor",
    "Wt9": "_________getOwnPropertyNames",
    "Ft9": "__________hasOwnProperty",
    "ef0": "serializerAndDeserializerSetup",
    "Qh0": "deserializerMiddlewareOptions",
    "Ih0": "_serializerMiddlewareOptions",
    "A": "_copyPropertiesFromSourceToTarget",
    "Z": "testObject",
    "Y": "inputHttpLabelValue",
    "J": "seconds",
    "X": "formattedDate",
    "W": "formattedHours",
    "F": "formattedMinutes",
    "b": "requestPayload",
    "C": "formattedSeconds",
    "V": "errOrValue",
    "K": "imageProcessingContext",
    "D": "currentTimestamp",
    "E": "_signingProperties",
    "H": "processMemberSchema",
    "x": "errorCode",
    "w": "__memberSchema",
    "L": "isNotType",
    "N": "requestFailureHandler",
    "$": "__abortError",
    "O": "headerEntry",
    "I": "_descriptor",
    "G": "comparisonObject",
    "qhI": "initializeExports",
    "sb0": "exportedModule",
    "hjA": "__definePropertyWithName",
    "Er9": "__________getOwnPropertyDescriptor",
    "Hr9": "getOwnPropertyNamesImplemented",
    "zr9": "___________hasOwnProperty",
    "mb0": "_exportedModule",
    "Or9": "SMITHY_CONTEXT_KEY",
    "jhI": "initializeChecksumConfiguration",
    "Nf0": "__________moduleExports",
    "ijA": "___definePropertyWithName",
    "Wo9": "___________getOwnPropertyDescriptor",
    "Fo9": "__________getOwnPropertyNames",
    "Co9": "____________hasOwnProperty",
    "Df0": "___________moduleExports",
    "wo9": "_SMITHY_CONTEXT_KEY",
    "ShI": "validateAndDefineExportedProperties",
    "yf0": "____________moduleExports",
    "ajA": "_____defineProperty",
    "$o9": "____________getOwnPropertyDescriptor",
    "qo9": "___________getOwnPropertyNames",
    "No9": "_____________hasOwnProperty",
    "Lf0": "_____________moduleExports",
    "So9": "__SMITHY_CONTEXT_KEY",
    "khI": "defineExportedModules",
    "lf0": "______________moduleExports",
    "ojA": "______defineProperty",
    "go9": "_____________getOwnPropertyDescriptor",
    "uo9": "____________getOwnPropertyNames",
    "mo9": "hasOwnPropertyFallback",
    "ff0": "exportedModules",
    "so9": "___SMITHY_CONTEXT_KEY",
    "ZgI": "initializeApiConfigurations",
    "Ug0": "_______________moduleExports",
    "XSA": "____definePropertyWithName",
    "me9": "______________getOwnPropertyDescriptor",
    "de9": "_____________getOwnPropertyNames",
    "ce9": "hasOwnPropertyCheck",
    "Fg0": "__exportedModule",
    "oe9": "SMITHY_CONTEXT_IDENTIFIER",
    "HgI": "initializeModuleExports",
    "Qu0": "________________moduleExports",
    "KSA": "_______defineProperty",
    "iA4": "_______________getOwnPropertyDescriptor",
    "nA4": "______________getOwnPropertyNames",
    "aA4": "______________hasOwnProperty",
    "ag0": "_________________moduleExports",
    "Q14": "____SMITHY_CONTEXT_KEY",
    "IuI": "defineAndExportClientConfiguration",
    "em0": "__________________moduleExports",
    "ySA": "_definePropertyWithDescriptor",
    "wQ4": "________________getOwnPropertyDescriptor",
    "$Q4": "_______________getOwnPropertyNames",
    "qQ4": "_______________hasOwnProperty",
    "lm0": "clientConfigurationExports",
    "jQ4": "_____SMITHY_CONTEXT_KEY",
    "GbI": "initializeSharpModule",
    "$x0": "_initializeSharpModule",
    "ni9": "EventEmitter",
    "FjA": "imageProcessingLibrary",
    "p$": "parameterValidator",
    "ai9": "getRuntimePlatformArch",
    "LD": "libVipsInstance",
    "si9": "interpolationMethods",
    "sh0": "ReadableBufferedStream",
    "B": "_____________________________________sourceObject",
    "ThI": "loggerMiddlewareFunction",
    "Wf0": "loggerMiddlewareModule",
    "cjA": "_____definePropertyWithName",
    "ir9": "_________________getOwnPropertyDescriptor",
    "nr9": "________________getOwnPropertyNames",
    "ar9": "________________hasOwnProperty",
    "Yf0": "loggerModule",
    "Xf0": "loggerMiddlewareConfig",
    "jgI": "_initializeModuleExports",
    "eT": "___________________moduleExports",
    "qSA": "________defineProperty",
    "Y04": "__________________getOwnPropertyDescriptor",
    "J04": "getOwnPropertyNamesEnhanced",
    "X04": "_________________hasOwnProperty",
    "tT": "____________________moduleExports",
    "vu0": "streamTransformationMixin",
    "_u0": "streamTransformationErrorMessage",
    "xu0": "isBlobInstance",
    "PhI": "defineRecursionDetectionMiddleware",
    "Kf0": "_____________________moduleExports",
    "ljA": "______definePropertyWithName",
    "er9": "___________________getOwnPropertyDescriptor",
    "Ao9": "_________________getOwnPropertyNames",
    "Bo9": "_hasOwnPropertyCheck",
    "Ff0": "recursionDetectionPlugin",
    "AX1": "AWS_TRACER_HEADER",
    "Yo9": "awsLambdaFunctionName",
    "Jo9": "X_AMZN_TRACE_ID_ENV_VAR",
    "Vf0": "recursionDetectionMiddlewareOptions",
    "RhI": "createHostHeaderMiddleware",
    "Zf0": "initializeHostHeaderMiddleware",
    "djA": "_________defineProperty",
    "hr9": "____________________getOwnPropertyDescriptor",
    "gr9": "__________________getOwnPropertyNames",
    "ur9": "__________________hasOwnProperty",
    "Bf0": "hostHeaderManagement",
    "Gf0": "hostHeaderMiddlewareOptions",
    "lhI": "utf8ConversionFunctions",
    "Lh0": "utf8Utilities",
    "ZSA": "_______definePropertyWithName",
    "nt9": "_____________________getOwnPropertyDescriptor",
    "at9": "_getObjectOwnPropertyNames",
    "st9": "___________________hasOwnProperty",
    "$h0": "utf8Conversions",
    "dfI": "_imageProcessingModule",
    "Zb0": "imageProcessingExports",
    "gJ1": "___imageProcessingHandler",
    "Ib0": "semverConstants",
    "Pa9": "SemanticVersion",
    "Gb0": "imageIdentifierUtils",
    "ja9": "parseSemver",
    "ha9": "compareVersions",
    "pa9": "getGreaterThan",
    "la9": "lessThanVersion",
    "ia9": "compareSemanticVersions",
    "na9": "isVersionEqual",
    "aa9": "isGreaterThanOrEqualTo",
    "sa9": "lessThanOrEqualTo",
    "ra9": "_compareVersions",
    "oa9": "coerceVersion",
    "ta9": "ComparatorFunction",
    "ea9": "RangeHandler",
    "As9": "satisfiesVersion",
    "MgI": "hexadecimalConverter",
    "yu0": "______________________moduleExports",
    "$SA": "________definePropertyWithName",
    "u14": "getObjectPropertyDescriptor",
    "m14": "___________________getOwnPropertyNames",
    "d14": "__hasOwnPropertyCheck",
    "Tu0": "hexConversionModule",
    "Pu0": "hexValueMap",
    "zX1": "hexCharacterToDecimalMap",
    "gu0": "_streamTransformationMixin",
    "UX1": "StreamMixin",
    "hu0": "errorMessageStreamTransformed",
    "Mx0": "getClipboardImageHandler",
    "eh0": "streamUtils",
    "je9": "streamModule",
    "chI": "_________________imageProcessingPipeline",
    "Hh0": "initializeBufferConversion",
    "GSA": "_________definePropertyWithName",
    "vt9": "______________________getOwnPropertyDescriptor",
    "bt9": "____________________getOwnPropertyNames",
    "ft9": "____________________hasOwnProperty",
    "Eh0": "bufferConversionHandlers",
    "IX1": "bufferLibrary",
    "bfI": "validateVersionConstraints",
    "mv0": "validateSemverRange",
    "Ca9": "__compareVersions",
    "uv0": "createVersionComparisonFunction",
    "Ka9": "VersionRangeValidator",
    "Da9": "evaluateSemverConstraints",
    "hv0": "comparisonOperatorHandler",
    "gv0": "evaluateVersionConstraints",
    "Ea9": "_validateVersionConstraints",
    "Ha9": "validateVersionRange",
    "CgI": "buildQueryStringModule",
    "kg0": "_buildQueryStringModule",
    "VSA": "__________definePropertyWithName",
    "UA4": "_______________________getOwnPropertyDescriptor",
    "wA4": "_____________________getOwnPropertyNames",
    "$A4": "_____________________hasOwnProperty",
    "Sg0": "queryStringBuilder",
    "NgI": "transformImageAndBuildQueryString",
    "Hu0": "processAndExportModule",
    "zSA": "definePropertyDescriptor",
    "L14": "________________________getOwnPropertyDescriptor",
    "M14": "______________________getOwnPropertyNames",
    "O14": "___hasOwnPropertyCheck",
    "Du0": "_______________________moduleExports",
    "Sh0": "ChecksumStreamModule",
    "We9": "createChecksumStream",
    "hh0": "_createChecksumStream",
    "Jg0": "imageStreamHandler",
    "fe9": "StreamWritable",
    "yhI": "_imageTransformationHandler",
    "bf0": "________________________moduleExports",
    "rjA": "___________definePropertyWithName",
    "yo9": "_________________________getOwnPropertyDescriptor",
    "ko9": "_______________________getOwnPropertyNames",
    "_o9": "______________________hasOwnProperty",
    "vf0": "contextProvider",
    "FgI": "exportModule",
    "Pg0": "_________________________moduleExports",
    "CSA": "____________definePropertyWithName",
    "FA4": "getOwnPropertyDescriptorInsteadFA4",
    "CA4": "________________________getOwnPropertyNames",
    "VA4": "_______________________hasOwnProperty",
    "Rg0": "exportedUriUtils",
    "qgI": "defineEscapeUriFunctions",
    "Vu0": "_initializeExports",
    "HSA": "_____________definePropertyWithName",
    "E14": "__________________________getOwnPropertyDescriptor",
    "H14": "_________________________getOwnPropertyNames",
    "z14": "____hasOwnPropertyCheck",
    "Fu0": "uriEncoderModule",
    "xfI": "validateVersion",
    "xv0": "validateSemver",
    "vJ1": "SemverValidator",
    "Ja9": "_validateSemverRange",
    "_v0": "___compareVersions",
    "dhI": "validateArrayBuffer",
    "Vh0": "defineArrayBufferChecker",
    "ISA": "______________definePropertyWithName",
    "Tt9": "___________________________getOwnPropertyDescriptor",
    "Pt9": "__________________________getOwnPropertyNames",
    "jt9": "________________________hasOwnProperty",
    "Ch0": "arrayBufferUtils",
    "ufI": "createConditionalRanges",
    "sv0": "createExportedSortingFunction",
    "La9": "isConditionMet",
    "Ma9": "generateRangePairs",
    "Bg0": "awsChunkedEncodingStream",
    "_e9": "createAwsChunkedEncodingStream",
    "ph0": "ByteArrayModule",
    "ub0": "getFormattedTitleForClaude",
    "qfI": "compareVersionPragmatics",
    "Jv0": "versionComparisonFunction",
    "Yv0": "_createVersionComparisonFunction",
    "nhI": "defineAndExportModule",
    "YSA": "moduleExporter",
    "Th0": "__________defineProperty",
    "Ge9": "____________________________getOwnPropertyDescriptor",
    "Ze9": "___________________________getOwnPropertyNames",
    "Ye9": "_________________________hasOwnProperty",
    "YX1": "__________________________moduleExports",
    "dgI": "defineObjectProperties",
    "OSA": "exportsModule",
    "Um0": "___________defineProperty",
    "TB4": "_____________________________getOwnPropertyDescriptor",
    "PB4": "getOwnPropertyNamesWithOwnerCheck",
    "jB4": "__________________________hasOwnProperty",
    "fX1": "_exportModule",
    "Gg0": "streamReaderModule",
    "ch0": "ByteArrayCollector",
    "Rx0": "detectImageType",
    "ve9": "readDataChunks",
    "Mh0": "Base64Encoder",
    "Em0": "_Base64Encoder",
    "UB4": "splitIntoChunksByDelimiter",
    "zh0": "base64Decoder",
    "lt9": "base64ValidationRegex",
    "Vm0": "Base64Converter",
    "NB4": "_base64ValidationRegex",
    "Lu0": "readFileAsDataURL",
    "kh0": "streamAndBlobUtils",
    "Fe9": "isReadableStream",
    "Ce9": "isBlob",
    "iu0": "_streamUtils",
    "pu0": "__streamUtils",
    "kfI": "findBestMatch",
    "jv0": "exportHighestPriorityMatch",
    "Ba9": "findMatchingElement",
    "Qa9": "createTestInstance",
    "_fI": "_findBestMatch",
    "yv0": "findBestMatchingValue",
    "Ga9": "createComparisonObject",
    "Za9": "createTestObject",
    "ig0": "readStreamToUint8Array",
    "Nu0": "_readStreamToUint8Array",
    "Zn9": "getClipboardScreenshotMessage",
    "Request": "HttpRequest",
    "mh0": "___________________________moduleExports",
    "$fI": "incrementVersion",
    "Gv0": "exportVersionIncrementer",
    "Iv0": "VersionManager",
    "Blob": "_BinaryLargeObject",
    "Vr9": "getValidFiles",
    "JSA": "flushStreamByIndex",
    "$u0": "createTimeoutPromise",
    "vh0": "ChecksumStream",
    "Ke9": "StreamReader",
    "ReadableStream": "__StreamReader",
    "um0": "setSmithyFeature",
    "ah0": "getBufferType",
    "yi": "createStringWithJSONMethods",
    "ox0": "extractReferencesFromText",
    "du0": "___streamUtils",
    "wfI": "getVersionFromInput",
    "Bv0": "getVersion",
    "kn9": "_getVersion",
    "OfI": "getPrereleaseParts",
    "Ev0": "getPrereleaseVersions",
    "dn9": "_getPrereleaseVersions",
    "g3": "getServiceType",
    "Yb0": "formatStringBasedOnType",
    "Px0": "normalizeFilePath",
    "PfI": "compareInstances",
    "Nv0": "_compareInstances",
    "qv0": "ObjectComparator",
    "UfI": "getVersionFromData",
    "ex0": "getVersionFromQuery",
    "Sn9": "_getVersionFromData",
    "vfI": "createRangeWithFallback",
    "bv0": "createRangeFunction",
    "Wa9": "createRangeInstance",
    "tb0": "cloneObject",
    "sf0": "cloneObjectWithArrayValues",
    "Xh0": "_cloneObjectWithArrayValues",
    "Ng0": "cloneObjectWithArrays",
    "Yu0": "cloneObjectProperties",
    "gfI": "checkIntersects",
    "nv0": "checkIntersection",
    "iv0": "IntersectionChecker",
    "uk": "getCommandType",
    "aJA": "encodeUriComponentWithSpecialChars",
    "YbI": "processAndExportImage",
    "Nx0": "exportImageProcessingFunction",
    "fk": "_imageProcessingResult",
    "li9": "startStream",
    "En9": "getAppleTerminalStatus",
    "yfI": "createAndMapValues",
    "Tv0": "createAndExportArrayMapper",
    "en9": "_createAndMapValues",
    "Tx0": "removeQuotesFromString",
    "wn9": "getITerm2SetupStatus",
    "ix0": "handleReturnKey",
    "ArrayBuffer": "isArrayBuffer",
    "zB4": "wrapStringInQuotesIfNeeded",
    "bx0": "incrementProjectOnboardingSeenCount",
    "sx0": "formatPastedText",
    "Dn9": "initializeAppleTerminalSetup",
    "B04": "streamTeeProcessor",
    "xm0": "createSchemeMap",
    "jfI": "sortImageSettingsByFormat",
    "Lv0": "sortImagesByFormat",
    "SfI": "_sortImagesByFormat",
    "Ov0": "__sortImagesByFormat",
    "n": "frameId",
    "Un9": "setupIterm2WithBackupPath",
    "ffI": "sharpImageProcessingFilter",
    "dv0": "exportSharpImageProcessing",
    "hfI": "sharpImageProcessingHandler",
    "pv0": "_sharpImageProcessing",
    "Oi9": "initializeWithExif",
    "NfI": "createMajorInstance",
    "Wv0": "createMajorFromInputs",
    "bn9": "_createMajorInstance",
    "LfI": "createMinorMatrix",
    "Cv0": "createMinorFunction",
    "hn9": "createMinorInstance",
    "MfI": "createPatchFunction",
    "Kv0": "_createPatchFunction",
    "un9": "createPatchInstance",
    "RfI": "requestFunction",
    "zv0": "exportFunction",
    "pn9": "createCustomFunction",
    "TfI": "createIn9Function",
    "wv0": "exportedFunction",
    "in9": "createAndExportFunctionWithParams",
    "_jA": "ensureArray",
    "fi9": "applyAv1Compression",
    "LJA": "_initializeAppleTerminalSetup",
    "S0A": "setupInProgressAndNotify",
    "k0A": "filterOutHookProgress",
    "eb0": "isValidIdentifier",
    "rf0": "_isValidIdentifier",
    "Wh0": "_isValidUsername",
    "Lg0": "__isValidIdentifier",
    "Ju0": "__isValidUsername",
    "Li9": "setKeepMetadataFlag",
    "Ri9": "updateMetadataOptions",
    "Pi9": "setKeepMetadataOption",
    "cx0": "isShiftEnterKeyBindingInstalled",
    "px0": "isMetaKeyOptionInstalled",
    "MjA": "countNewlines",
    "lx0": "checkIfBackslashReturnUsed",
    "g0A": "getArrayByteLength",
    "Jb0": "isSpecialCharacter",
    "gb0": "findItemByValue",
    "HX1": "createRequest",
    "rx0": "generateImageTag",
    "Pn9": "parseJsonString",
    "Qf0": "identityFunction",
    "CjA": "___imageTransformationPipeline",
    "UjA": "________imageTransformationProcessor",
    "Sx0": "_________imageTransformationProcessor",
    "Mv0": "___processImageTransformations",
    "Rv0": "______________________________________processImageTransformation",
    "cv0": "imageTransformProcessor",
    "lv0": "__________imageTransformationProcessor",
    "Ls9": "____imageTransformationPipeline",
    "Vb0": "___________imageTransformationProcessor",
    "hs9": "processImageOutputHandler",
    "SjA": "imageProcessingWorkflow",
    "ms9": "__processImageTransformationHandler",
    "Lb0": "_______________________________________processImageTransformation",
    "Tb0": "____________imageTransformationProcessor",
    "Br9": "_____________imageTransformationProcessor",
    "HH": "imageProcessingMethods",
    "bI": "______________imageTransformationProcessor",
    "tf0": "_processImageTransform",
    "ji": "updateMetadata",
    "dG": "________________________________________processImageTransformation",
    "oh0": "_________________________________________processImageTransformation",
    "Wg0": "_______________imageTransformationProcessor",
    "Og0": "__________________________________________processImageTransformation",
    "_g0": "imageProcessingTransformation",
    "Wu0": "________________imageTransformationProcessor",
    "zu0": "__processImageTransformationFunction",
    "nu0": "_________________imageTransformationProcessor",
    "xB4": "defineProperties",
    "vB4": "copyPropertiesFromSourceToTarget",
    "Tm0": "replaceHttpLabelInPath",
    "W7": "setFunctionName",
    "SA4": "_defineProperties",
    "hg0": "copyPropertiesFromSource",
    "_04": "__defineProperties",
    "x04": "assignPropertiesIfNew",
    "h04": "convertToBooleanValue",
    "cJA": "convertToNumber",
    "u04": "validateIntegerInput",
    "kX1": "validateTypedInteger",
    "c04": "expectStringValue",
    "p04": "expectUnionValue",
    "c0A": "parseNumericString",
    "CB4": "adjustDateForHistoricalLimit",
    "TX1": "convertMonthToIndex",
    "KB4": "validateDayInMonth",
    "D04": "___defineProperties",
    "E04": "definePropertiesForObject",
    "MX1": "ListSchemaDefinition",
    "OX1": "MapSchemaDefinition",
    "Bm0": "OperationSchema",
    "NSA": "StructureSchema",
    "RX1": "ReactiveSchema",
    "cG": "defineFunctionName",
    "tB4": "____defineProperties",
    "eB4": "copyPropertiesNonEnumerably",
    "jSA": "___________________________________________processImageTransformation",
    "oT": "_setFunctionName",
    "_14": "_____defineProperties",
    "x14": "assignPropertiesFromSource",
    "ih": "_______________definePropertyWithName",
    "jr9": "definePropertyForObject",
    "Sr9": "______defineProperties",
    "ob0": "createHttpHandlerMethod",
    "nh": "_defineFunctionName",
    "eo9": "definePropertiesWithGetters",
    "At9": "defineNonEnumerableProperties",
    "af0": "__validateImageOutputOptions",
    "ah": "________________definePropertyWithName",
    "Ut9": "assignProperties",
    "wt9": "definePropertiesFromObject",
    "Jh0": "__________________imageTransformationProcessor",
    "rh": "__definePropertyWithConfig",
    "BA4": "_______defineProperties",
    "QA4": "copyOwnProperties",
    "qg0": "createHttpRequestInstance",
    "oh": "_________________definePropertyWithName",
    "Y14": "_definePropertiesWithGetters",
    "J14": "_defineNonEnumerableProperties",
    "Zu0": "____________________________________________processImageTransformation",
    "bJ1": "ANY_VERSION",
    "Ra9": "prereleaseValidator",
    "tv0": "defaultVersionConstraints",
    "ev0": "____compareVersions",
    "Ab0": "compareSemverConstraints",
    "BSA": "defineFunctionWithName",
    "Ct9": "________defineProperties",
    "Vt9": "definePropertiesFromSource",
    "mi9": "validateAndSetTileOptions",
    "bi9": "setTiffOptions",
    "gjA": "__________________definePropertyWithName",
    "Ur9": "defineEnumerableProperties",
    "wr9": "definePropertiesWithGettersAndEnumerability",
    "njA": "___________________definePropertyWithName",
    "Vo9": "_________defineProperties",
    "Ko9": "_definePropertiesFromSource",
    "sjA": "____________________definePropertyWithName",
    "Lo9": "defineGetters",
    "Mo9": "defineExportedProperties",
    "tjA": "___definePropertyWithConfig",
    "do9": "_defineExportedProperties",
    "co9": "_defineObjectProperties",
    "WSA": "_____________________definePropertyWithName",
    "pe9": "definePropertiesFrom",
    "le9": "copyProperties",
    "DSA": "_defineFunctionWithName",
    "sA4": "definePropertyGetters",
    "rA4": "__definePropertiesFromSource",
    "kSA": "______________________definePropertyWithName",
    "NQ4": "__________defineProperties",
    "LQ4": "_copyPropertiesFromSource",
    "Ux0": "getPlatformArchitecture",
    "LJ1": "libVipsVersion",
    "mh": "imageFormatManager",
    "oi9": "eventEmitterInstance",
    "yi9": "configureJpegCompressionOptions",
    "Le9": "updateImageFormat",
    "ii9": "_processImagePipeline",
    "eJ1": "__setFunctionName",
    "sr9": "___________defineProperties",
    "rr9": "__defineNonEnumerableProperties",
    "Nn9": "installWezTermShiftEnterKeyBinding",
    "ki9": "configurePngOptions",
    "qX1": "___setFunctionName",
    "W04": "____________defineProperties",
    "wX1": "addPropertiesFromObject",
    "a14": "__imageTransformationHandler",
    "ku0": "_____________________________________________processImageTransformation",
    "hi9": "setHeifOptions",
    "pjA": "__defineFunctionWithName",
    "Qo9": "extendObjectWithProperties",
    "Io9": "_assignPropertiesFromSource",
    "mjA": "__defineFunctionName",
    "mr9": "addHostHeaderProperties",
    "dr9": "addObjectProperties",
    "Ln9": "installGhosttyShiftEnterKeyBindingHandler",
    "GX1": "definePropertyWithNameForExport",
    "rt9": "_____________defineProperties",
    "ot9": "___definePropertiesFromSource",
    "Sa9": "validateImageProcessing",
    "ya9": "cleanProcessedImage",
    "ka9": "_incrementVersion",
    "_a9": "diffImageProcessing",
    "xa9": "getMajorVersion",
    "va9": "calculateImageMinorVersion",
    "ba9": "updateImagePatchOptions",
    "fa9": "handleImagePreprocessing",
    "ga9": "imageConversionComparisonPipeline",
    "ua9": "compareLooseSemanticVersions",
    "ma9": "compareImageFormatSettings",
    "Bs9": "toComparatorsPipeline",
    "Qs9": "getMaxSatisfyingVersion",
    "Is9": "minSatisfyingVersion",
    "Gs9": "minVersionHandler",
    "Zs9": "validRange",
    "Ys9": "processOutsideImagePipeline",
    "Ws9": "intersectImageProcessingPipelines",
    "Fs9": "simplifyImageProcessingRange",
    "Cs9": "outputImagePipelineSettings",
    "Ru0": "___defineFunctionName",
    "c14": "______________defineProperties",
    "p14": "definePropertiesIfNotExists",
    "SJ1": "installTerminalShiftEnterKeyBinding",
    "vi9": "updateJP2Options",
    "gi9": "configureJxlOptions",
    "th0": "___updateImageFormatBasedOnOptions",
    "Se9": "______________________________________________processImageTransformation",
    "Dh0": "___defineFunctionWithName",
    "ht9": "_______________defineProperties",
    "gt9": "definePropertiesIfNotExist",
    "mt9": "initializeImageProcessingPipeline",
    "Va9": "ANY_VERSION_COMPARISON",
    "qA4": "____defineFunctionName",
    "NA4": "associateProperties",
    "LA4": "___defineNonEnumerableProperties",
    "FX1": "___processImageTransformationFunction",
    "R14": "_____defineFunctionName",
    "T14": "_assignProperties",
    "P14": "copyObjectProperties",
    "EX1": "_______________________________________________processImageTransformation",
    "Ee9": "__createChecksumStream",
    "He9": "____validateOutputFilePath",
    "he9": "_imageTransformProcessor",
    "ge9": "________________________________________________processImageTransformation",
    "xf0": "_______________________definePropertyWithName",
    "xo9": "_defineGetters",
    "vo9": "assignPropertiesIfNotPresent",
    "_f0": "processImageTransformationResult",
    "WX1": "definePropertyWithNameAndValue",
    "KA4": "________________defineProperties",
    "DA4": "____defineNonEnumerableProperties",
    "DX1": "definePropertyWithNameAndDescription",
    "U14": "defineGetterProperties",
    "w14": "_definePropertyForObject",
    "Xa9": "findHighestValidSemver",
    "St9": "____setFunctionName",
    "yt9": "assignGetterProperties",
    "kt9": "copyPropertiesIfNotDefined",
    "yb0": "ImageTransformationWatcher",
    "xe9": "createChunkedEncodingStream",
    "ji9": "processMetadataOptions",
    "vn9": "_____compareVersions",
    "TJ1": "generateOnboardingTips",
    "kb0": "ImageWatcher",
    "ZX1": "copyPropertiesToTarget",
    "bX1": "_definePropertiesFromObject",
    "Ex0": "configureLoopAndDelay",
    "$jA": "restoreAppleTerminalSettings",
    "Mi9": "processExifDataAndStore",
    "qi9": "validateAndProcessOutputFile",
    "Yg0": "BufferedStreamWriter",
    "ts9": "createMatcherFunction",
    "Eb0": "initializeFileReading",
    "ui9": "validateInputDepthAndSet",
    "pg0": "pipeToDestinationStream",
    "Ti9": "setIccProfileAndMetadataOptions",
    "e04": "convertDateToUtcString",
    "ju0": "convertHexStringToUint8Array",
    "I04": "_________________________________________________processImageTransformation",
    "lu0": "imageTransformationUtils",
    "Ia9": "findBestMatchingElement",
    "Ya9": "findBestMatchForInputs",
    "Ue9": "imageTransformationProcess",
    "di9": "setTimeoutOptions",
    "Bn9": "processImageOperations",
    "An9": "validateAndProcessImage",
    "Ni9": "setResolveOption",
    "es9": "normalizeImagePath",
    "xn9": "__incrementVersion",
    "OjA": "streamExifData",
    "wx0": "configureCacheSettings",
    "wjA": "RenderImageWithChildren",
    "MJA": "isEnvironmentSupportedForImageTransformations",
    "Buffer": "DataBuffer",
    "Infinity": "PositiveInfinity",
    "Si9": "processImageByFormat",
    "Kr9": "processImageKeyTransformation",
    "_n9": "extractVersion",
    "cn9": "extractPrereleaseTags",
    "an9": "compareObjectInstances",
    "nh0": "updateValueInArray",
    "Yn9": "getClipboardImagePath",
    "yn9": "fetchVersionFromData",
    "Fa9": "_createRangeWithFallback",
    "Na9": "_checkIntersection",
    "Aa9": "mapValuesToArray",
    "b0A": "subscribeToImageProcessing",
    "pi9": "setBooleanOption",
    "ci9": "setOutputFormat",
    "Dr9": "processImageDeletion",
    "Su0": "convertByteArrayToHexString",
    "Jn9": "processAndValidateFilePath",
    "hb0": "resetImageTransformation",
    "sn9": "compareImageFormats",
    "on9": "updateAndSortImagesByFormat",
    "Ua9": "sharpImageProcessingFilterHandler",
    "$a9": "initializeSharpImageProcessor",
    "fn9": "createMajorFromArgs",
    "gn9": "_createMinorMatrix",
    "mn9": "createPatch",
    "qjA": "getImageProcessingErrorMessages",
    "ln9": "createAndExportCustomFunction",
    "nn9": "createAndExportFunctionWithParamsAndFlag",
    "j0A": "getTerminalPreferencesPath",
    "Ri": "processCommand",
    "OJ1": "processFilePath",
    "Cr9": "processAndCacheImageTransformation",
    "ri9": "setConcurrencyLevel",
    "Fr9": "__________________________________________________processImageTransformation",
    "Zr9": "applyImageTransformation",
    "$B4": "convertToBigDecimal",
    "ei9": "validateAndProcessBoolean",
    "ti9": "getVipsCounters",
    "xM": "getServiceTypeValue",
    "xh0": "FileStreamReader",
    "yM": "_imageProcessingFunction",
    "Hb0": "_________imageProcessor",
    "Sb0": "__________________imageProcessingPipeline",
    "bJA": "initializeImageProcessor",
    "hJA": "createImageProcessor",
    "X7": "___________________imageTransformationProcessor",
    "wh0": "__processImageTransform",
    "J2": "___________________imageProcessingPipeline",
    "Ag0": "____________________imageTransformationProcessor",
    "F7": "processAndExportImageTransformation",
    "D4": "__processImagePipeline",
    "Dm0": "_____imageTransformationPipeline",
    "bB4": "copyAndDefineProperties",
    "fB4": "initializeAndExportMetadata",
    "qm0": "httpMetadataManager",
    "uB4": "updateMetadataUtil",
    "dB4": "updateMetadataHook",
    "yA4": "_initializeModule",
    "kA4": "transformExportedNodeHttpHandler",
    "ug0": "initializeHttpResponseProcessor",
    "mg0": "_imageProcessingTransformation",
    "dg0": "transformHeadersToString",
    "xA4": "setConnectionTimeoutHandler",
    "bA4": "_setSocketKeepAlive",
    "fA4": "_handleSocketTimeout",
    "uA4": "NodeHttp2ConnectionPool",
    "cA4": "CollectorWritableStream",
    "lA4": "_isReadableStream",
    "v04": "assignPropertiesToModule",
    "LSA": "validateFloat32",
    "PX1": "expectInt32Value",
    "jX1": "expectShortInteger",
    "SX1": "validateTypedInteger8Bit",
    "_X1": "strictParseDouble",
    "xX1": "__parseSpecialFloatValue",
    "Xm0": "strictParseLongInteger",
    "H04": "_createSchemaExports",
    "z04": "metadataUpdate",
    "U04": "_____________________imageTransformationProcessor",
    "$04": "______________________imageTransformationProcessor",
    "Qm0": "ExtendedStructureSchema",
    "AQ4": "createIdentityProviderExports",
    "BQ4": "getSmithyContextFromRequest",
    "_m0": "_______________________imageTransformationProcessor",
    "QQ4": "filterAuthOptionsBySchemeIds",
    "lX1": "httpRequestUtil",
    "YQ4": "defaultErrorHandler",
    "JQ4": "defaultSuccessHandler",
    "WQ4": "normalizeIdentityProvider",
    "FQ4": "makePagedClientRequest",
    "CQ4": "fetchNextTokenFromPaginationResult",
    "KQ4": "DefaultIdentityProviderConfig",
    "HQ4": "NoAuthSignatory",
    "cm0": "checkIfIdentityNeedsRefresh",
    "UQ4": "memoizeRequestDataProvider",
    "v14": "createModuleExports",
    "Uu0": "________________________imageTransformationProcessor",
    "b14": "____processImageTransformationFunction",
    "yr9": "defineExportedModule",
    "kr9": "getHttpHandlerExtensionConfiguration",
    "_r9": "resolveHttpHandlerRuntimeConfiguration",
    "xr9": "HttpRequestField",
    "vr9": "HttpFieldContainer",
    "fr9": "HttpResponseHandler",
    "Bt9": "defineModuleExports",
    "Qt9": "_createHttpHandlerExtensionConfiguration",
    "It9": "resolveHttpHandlerRuntimeConfig",
    "Gt9": "HttpField",
    "Zt9": "FieldCollection",
    "Jt9": "HttpResponse",
    "$t9": "defineExportProperties",
    "qt9": "_getHttpHandlerExtensionConfiguration",
    "Nt9": "resolveHttpHandlerConfig",
    "Lt9": "FieldDefinition",
    "Mt9": "HttpFieldsManager",
    "Rt9": "_HttpResponse",
    "IA4": "createHttpHandlerModule",
    "GA4": "__createHttpHandlerExtensionConfiguration",
    "ZA4": "_resolveHttpHandlerConfig",
    "YA4": "_HttpField",
    "JA4": "HttpFieldCollection",
    "WA4": "HttpResponseClass",
    "X14": "defineHttpHandlerExtensionConfiguration",
    "W14": "__getHttpHandlerExtensionConfiguration",
    "F14": "__resolveHttpHandlerConfig",
    "C14": "HttpHeader",
    "V14": "HttpHeadersCollection",
    "D14": "_HttpResponseHandler",
    "Ta9": "compareVersionItems",
    "Kt9": "createModuleWithProperties",
    "Dt9": "___________________________________________________processImageTransformation",
    "QX1": "findHeaderInResponseHeaders",
    "Bh0": "serializerMiddlewareFunction",
    "$r9": "createModuleExportsObject",
    "qr9": "defineChecksumAlgorithmManager",
    "Nr9": "generateChecksumAlgorithmMap",
    "Do9": "initializeModuleExportsWithChecksum",
    "Eo9": "_____createChecksumAlgorithmManager",
    "Ho9": "generateChecksumConstructorsMap",
    "Oo9": "createExportedModule",
    "Ro9": "_createChecksumAlgorithmProvider",
    "To9": "generateChecksumAlgorithmsMapping",
    "po9": "defineExportedModuleProperties",
    "lo9": "_defineChecksumAlgorithmManager",
    "io9": "generateChecksumMapFromAlgorithms",
    "ie9": "initializeExportedModule",
    "ne9": "createChecksumAlgorithmHandlerWithProperties",
    "ae9": "generateChecksumConstructorMap",
    "oA4": "_createModuleExports",
    "tA4": "______createChecksumAlgorithmManager",
    "eA4": "_generateChecksumConstructorMap",
    "MQ4": "createClientConfigurationExport",
    "OQ4": "_______createChecksumAlgorithmManager",
    "RQ4": "resolveChecksumConstructorsByAlgorithmId",
    "R0A": "sharpLibraryVersions",
    "or9": "createLoggerMiddlewareModule",
    "Jf0": "_loggerMiddlewareFunction",
    "eh": "addPropertiesAndExport",
    "F04": "createModuleWithExports",
    "Go9": "createRecursionDetectionMiddleware",
    "Zo9": "_imageProcessingMethods",
    "cr9": "createHostHeaderModule",
    "pr9": "imageProcessingMethodsInstance",
    "xi9": "setGifOptions",
    "_i9": "configureWebpOptions",
    "tt9": "createUtf8ConversionsModule",
    "qh0": "_____processImageTransformationFunction",
    "da9": "sortImageProcessing",
    "ca9": "sortDescendingByVersion",
    "Js9": "_________________________imageTransformationProcessor",
    "Xs9": "imageTransformProcessorLoose",
    "l14": "__createModuleExports",
    "t14": "processImageTransformationUtil",
    "mk": "_createImageProcessor",
    "ut9": "createBufferConversionModule",
    "dt9": "_createBufferFromArrayBuffer",
    "ct9": "convertStringToBuffer",
    "za9": "validateVersionComparison",
    "MA4": "createQueryStringBuilder",
    "j14": "createModuleExportsWithEscapedProperties",
    "ih0": "processStream",
    "T0A": "processAndTransformImage",
    "ue9": "streamToBufferWithLimit",
    "bo9": "createModuleExportsWithContext",
    "fo9": "getSmithyContext",
    "ho9": "normalizeToPromiseProvider",
    "EA4": "createNonEnumerableProperties",
    "HA4": "convertCharacterToHexadecimal",
    "$14": "createModuleWithExport",
    "q14": "convertCharacterToHexString",
    "_t9": "createArrayBufferModule",
    "xt9": "isArrayBufferChecker",
    "Ph0": "copyDefaultProperties",
    "Je9": "createModuleExport",
    "wm0": "defineAndExportProperties",
    "SB4": "_defineModuleExports",
    "kx0": "RenderImageWithMarkers",
    "KX1": "handleContinueExpectations",
    "Be9": "processImageToBase64",
    "MB4": "imageToBase64Encoder",
    "Wr9": "startImageTransformationWatcher",
    "pt9": "processImageBase64Transformation",
    "qB4": "processBase64String",
    "ux0": "restoreITerm2Settings",
    "mx0": "setOptionAsMetaKey",
    "yg0": "serializeQueryParamsToString",
    "Eu0": "_convertObjectToQueryString",
    "hx0": "exportTerminalPreferences",
    "dx0": "disableTerminalAudioBell",
    "gx0": "exportIterm2Settings"
  },
  "partialCode": "var processImageTransformation = z((processImageOutput, registerImageProcessingMethods) => {\n  var pathModule = EA(\"node:path\");\n  var inputValidator = iT();\n  var _______imageProcessor = HJA();\n  var supportedImageFormats = new Map([[\"heic\", \"heif\"], [\"heif\", \"heif\"], [\"avif\", \"avif\"], [\"jpeg\", \"jpeg\"], [\"jpg\", \"jpeg\"], [\"jpe\", \"jpeg\"], [\"tile\", \"tile\"], [\"dz\", \"tile\"], [\"png\", \"png\"], [\"raw\", \"raw\"], [\"tiff\", \"tiff\"], [\"tif\", \"tiff\"], [\"webp\", \"webp\"], [\"gif\", \"gif\"], [\"jp2\", \"jp2\"], [\"jpx\", \"jp2\"], [\"j2k\", \"jp2\"], [\"j2c\", \"jp2\"], [\"jxl\", \"jxl\"]]);\n  var jp2FileExtensionRegex = /\\.(jp[2x]|j2[kc])$/i;\n  var generateJP2Error = () => Error(\"JP2 output requires libvips with support for OpenJPEG\");\n  var calculateBitDepth = calculateBitShiftForLog2 => 1 << 31 - Math.clz32(Math.ceil(Math.log2(calculateBitShiftForLog2)));\n  function validateAndProcessOutputFile(___outputFilePath, ___callbackFunction) {\n    let ______________________error;\n    if (!inputValidator.string(___outputFilePath)) {\n      ______________________error = Error(\"Missing output file path\");\n    } else if (inputValidator.string(this.options.input.file) && pathModule.resolve(this.options.input.file) === pathModule.resolve(___outputFilePath)) {\n      ______________________error = Error(\"Cannot use same file for input and output\");\n    } else if (jp2FileExtensionRegex.test(pathModule.extname(___outputFilePath)) && !this.constructor.format.jp2k.output.file) {\n      ______________________error = generateJP2Error();\n    }\n    if (______________________error) {\n      if (inputValidator.fn(___callbackFunction)) {\n        ___callbackFunction(______________________error);\n      } else {\n        return Promise.reject(______________________error);\n      }\n    } else {\n      this.options.fileOut = ___outputFilePath;\n      let errorInstance = Error();\n      return this._pipeline(___callbackFunction, errorInstance);\n    }\n    return this;\n  }\n  function setResolveOption(resolveOption, fallbackValue) {\n    if (inputValidator.object(resolveOption)) {\n      this._setBooleanOption(\"resolveWithObject\", resolveOption.resolveWithObject);\n    } else if (this.options.resolveWithObject) {\n      this.options.resolveWithObject = false;\n    }\n    this.options.fileOut = \"\";\n    let _errorInstance = Error();\n    return this._pipeline(inputValidator.fn(resolveOption) ? resolveOption : fallbackValue, _errorInstance);\n  }\n  function setKeepMetadataFlag() {\n    this.options.keepMetadata |= 1;\n    return this;\n  }\n  function processExifDataAndStore(processExifData) {\n    if (inputValidator.object(processExifData)) {\n      for (let [exifProperty, exifEntry] of Object.entries(processExifData)) {\n        if (inputValidator.object(exifEntry)) {\n          for (let [exifKey, exifValue] of Object.entries(exifEntry)) {\n            if (inputValidator.string(exifValue)) {\n              this.options.withExif[`exif-${exifProperty.toLowerCase()}-${exifKey}`] = exifValue;\n            } else {\n              throw inputValidator.invalidParameterError(`${exifProperty}.${exifKey}`, \"string\", exifValue);\n            }\n          }\n        } else {\n          throw inputValidator.invalidParameterError(exifProperty, \"object\", exifEntry);\n        }\n      }\n    } else {\n      throw inputValidator.invalidParameterError(\"exif\", \"object\", processExifData);\n    }\n    this.options.withExifMerge = false;\n    return this.keepExif();\n  }\n  function initializeWithExif(__imageData) {\n    this.withExif(__imageData);\n    this.options.withExifMerge = true;\n    return this;\n  }\n  function updateMetadataOptions() {\n    this.options.keepMetadata |= 8;\n    return this;\n  }\n  function setIccProfileAndMetadataOptions(iccProfile, _metadataOptions) {\n    if (inputValidator.string(iccProfile)) {\n      this.options.withIccProfile = iccProfile;\n    } else {\n      throw inputValidator.invalidParameterError(\"icc\", \"string\", iccProfile);\n    }\n    this.keepIccProfile();\n    if (inputValidator.object(_metadataOptions)) {\n      if (inputValidator.defined(_metadataOptions.attach)) {\n        if (inputValidator.bool(_metadataOptions.attach)) {\n          if (!_metadataOptions.attach) {\n            this.options.keepMetadata &= -9;\n          }\n        } else {\n          throw inputValidator.invalidParameterError(\"attach\", \"boolean\", _metadataOptions.attach);\n        }\n      }\n    }\n    return this;\n  }\n  function setKeepMetadataOption() {\n    this.options.keepMetadata = 31;\n    return this;\n  }\n  function processMetadataOptions(metadataOptions) {\n    this.keepMetadata();\n    this.withIccProfile(\"srgb\");\n    if (inputValidator.object(metadataOptions)) {\n      if (inputValidator.defined(metadataOptions.orientation)) {\n        if (inputValidator.integer(metadataOptions.orientation) && inputValidator.inRange(metadataOptions.orientation, 1, 8)) {\n          this.options.withMetadataOrientation = metadataOptions.orientation;\n        } else {\n          throw inputValidator.invalidParameterError(\"orientation\", \"integer between 1 and 8\", metadataOptions.orientation);\n        }\n      }\n      if (inputValidator.defined(metadataOptions.density)) {\n        if (inputValidator.number(metadataOptions.density) && metadataOptions.density > 0) {\n          this.options.withMetadataDensity = metadataOptions.density;\n        } else {\n          throw inputValidator.invalidParameterError(\"density\", \"positive number\", metadataOptions.density);\n        }\n      }\n      if (inputValidator.defined(metadataOptions.icc)) {\n        this.withIccProfile(metadataOptions.icc);\n      }\n      if (inputValidator.defined(metadataOptions.exif)) {\n        this.withExifMerge(metadataOptions.exif);\n      }\n    }\n    return this;\n  }\n  function processImageByFormat(_imageFormatHandler, _imageData) {\n    let Q = supportedImageFormats.get((inputValidator.object(_imageFormatHandler) && inputValidator.string(_imageFormatHandler.id) ? _imageFormatHandler.id : _imageFormatHandler).toLowerCase());\n    if (!Q) {\n      throw inputValidator.invalidParameterError(\"format\", `one of: ${[...supportedImageFormats.keys()].join(\", \")}`, _imageFormatHandler);\n    }\n    return this[Q](_imageData);\n  }\n  function configureJpegCompressionOptions(jpegOptions) {\n    if (inputValidator.object(jpegOptions)) {\n      if (inputValidator.defined(jpegOptions.quality)) {\n        if (inputValidator.integer(jpegOptions.quality) && inputValidator.inRange(jpegOptions.quality, 1, 100)) {\n          this.options.jpegQuality = jpegOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", jpegOptions.quality);\n        }\n      }\n      if (inputValidator.defined(jpegOptions.progressive)) {\n        this._setBooleanOption(\"jpegProgressive\", jpegOptions.progressive);\n      }\n      if (inputValidator.defined(jpegOptions.chromaSubsampling)) {\n        if (inputValidator.string(jpegOptions.chromaSubsampling) && inputValidator.inArray(jpegOptions.chromaSubsampling, [\"4:2:0\", \"4:4:4\"])) {\n          this.options.jpegChromaSubsampling = jpegOptions.chromaSubsampling;\n        } else {\n          throw inputValidator.invalidParameterError(\"chromaSubsampling\", \"one of: 4:2:0, 4:4:4\", jpegOptions.chromaSubsampling);\n        }\n      }\n      let isOptimizeCodingDefined = inputValidator.bool(jpegOptions.optimizeCoding) ? jpegOptions.optimizeCoding : jpegOptions.optimiseCoding;\n      if (inputValidator.defined(isOptimizeCodingDefined)) {\n        this._setBooleanOption(\"jpegOptimiseCoding\", isOptimizeCodingDefined);\n      }\n      if (inputValidator.defined(jpegOptions.mozjpeg)) {\n        if (inputValidator.bool(jpegOptions.mozjpeg)) {\n          if (jpegOptions.mozjpeg) {\n            this.options.jpegTrellisQuantisation = true;\n            this.options.jpegOvershootDeringing = true;\n            this.options.jpegOptimiseScans = true;\n            this.options.jpegProgressive = true;\n            this.options.jpegQuantisationTable = 3;\n          }\n        } else {\n          throw inputValidator.invalidParameterError(\"mozjpeg\", \"boolean\", jpegOptions.mozjpeg);\n        }\n      }\n      let isTrellisQuantizationEnabled = inputValidator.bool(jpegOptions.trellisQuantization) ? jpegOptions.trellisQuantization : jpegOptions.trellisQuantisation;\n      if (inputValidator.defined(isTrellisQuantizationEnabled)) {\n        this._setBooleanOption(\"jpegTrellisQuantisation\", isTrellisQuantizationEnabled);\n      }\n      if (inputValidator.defined(jpegOptions.overshootDeringing)) {\n        this._setBooleanOption(\"jpegOvershootDeringing\", jpegOptions.overshootDeringing);\n      }\n      let optimizeScansFlag = inputValidator.bool(jpegOptions.optimizeScans) ? jpegOptions.optimizeScans : jpegOptions.optimiseScans;\n      if (inputValidator.defined(optimizeScansFlag)) {\n        this._setBooleanOption(\"jpegOptimiseScans\", optimizeScansFlag);\n        if (optimizeScansFlag) {\n          this.options.jpegProgressive = true;\n        }\n      }\n      let quantizationTableValue = inputValidator.number(jpegOptions.quantizationTable) ? jpegOptions.quantizationTable : jpegOptions.quantisationTable;\n      if (inputValidator.defined(quantizationTableValue)) {\n        if (inputValidator.integer(quantizationTableValue) && inputValidator.inRange(quantizationTableValue, 0, 8)) {\n          this.options.jpegQuantisationTable = quantizationTableValue;\n        } else {\n          throw inputValidator.invalidParameterError(\"quantisationTable\", \"integer between 0 and 8\", quantizationTableValue);\n        }\n      }\n    }\n    return this._updateFormatOut(\"jpeg\", jpegOptions);\n  }\n  function configurePngOptions(optionsConfig) {\n    if (inputValidator.object(optionsConfig)) {\n      if (inputValidator.defined(optionsConfig.progressive)) {\n        this._setBooleanOption(\"pngProgressive\", optionsConfig.progressive);\n      }\n      if (inputValidator.defined(optionsConfig.compressionLevel)) {\n        if (inputValidator.integer(optionsConfig.compressionLevel) && inputValidator.inRange(optionsConfig.compressionLevel, 0, 9)) {\n          this.options.pngCompressionLevel = optionsConfig.compressionLevel;\n        } else {\n          throw inputValidator.invalidParameterError(\"compressionLevel\", \"integer between 0 and 9\", optionsConfig.compressionLevel);\n        }\n      }\n      if (inputValidator.defined(optionsConfig.adaptiveFiltering)) {\n        this._setBooleanOption(\"pngAdaptiveFiltering\", optionsConfig.adaptiveFiltering);\n      }\n      let colorCount = optionsConfig.colours || optionsConfig.colors;\n      if (inputValidator.defined(colorCount)) {\n        if (inputValidator.integer(colorCount) && inputValidator.inRange(colorCount, 2, 256)) {\n          this.options.pngBitdepth = calculateBitDepth(colorCount);\n        } else {\n          throw inputValidator.invalidParameterError(\"colours\", \"integer between 2 and 256\", colorCount);\n        }\n      }\n      if (inputValidator.defined(optionsConfig.palette)) {\n        this._setBooleanOption(\"pngPalette\", optionsConfig.palette);\n      } else if ([optionsConfig.quality, optionsConfig.effort, optionsConfig.colours, optionsConfig.colors, optionsConfig.dither].some(inputValidator.defined)) {\n        this._setBooleanOption(\"pngPalette\", true);\n      }\n      if (this.options.pngPalette) {\n        if (inputValidator.defined(optionsConfig.quality)) {\n          if (inputValidator.integer(optionsConfig.quality) && inputValidator.inRange(optionsConfig.quality, 0, 100)) {\n            this.options.pngQuality = optionsConfig.quality;\n          } else {\n            throw inputValidator.invalidParameterError(\"quality\", \"integer between 0 and 100\", optionsConfig.quality);\n          }\n        }\n        if (inputValidator.defined(optionsConfig.effort)) {\n          if (inputValidator.integer(optionsConfig.effort) && inputValidator.inRange(optionsConfig.effort, 1, 10)) {\n            this.options.pngEffort = optionsConfig.effort;\n          } else {\n            throw inputValidator.invalidParameterError(\"effort\", \"integer between 1 and 10\", optionsConfig.effort);\n          }\n        }\n        if (inputValidator.defined(optionsConfig.dither)) {\n          if (inputValidator.number(optionsConfig.dither) && inputValidator.inRange(optionsConfig.dither, 0, 1)) {\n            this.options.pngDither = optionsConfig.dither;\n          } else {\n            throw inputValidator.invalidParameterError(\"dither\", \"number between 0.0 and 1.0\", optionsConfig.dither);\n          }\n        }\n      }\n    }\n    return this._updateFormatOut(\"png\", optionsConfig);\n  }\n  function configureWebpOptions(webpOptions) {\n    if (inputValidator.object(webpOptions)) {\n      if (inputValidator.defined(webpOptions.quality)) {\n        if (inputValidator.integer(webpOptions.quality) && inputValidator.inRange(webpOptions.quality, 1, 100)) {\n          this.options.webpQuality = webpOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", webpOptions.quality);\n        }\n      }\n      if (inputValidator.defined(webpOptions.alphaQuality)) {\n        if (inputValidator.integer(webpOptions.alphaQuality) && inputValidator.inRange(webpOptions.alphaQuality, 0, 100)) {\n          this.options.webpAlphaQuality = webpOptions.alphaQuality;\n        } else {\n          throw inputValidator.invalidParameterError(\"alphaQuality\", \"integer between 0 and 100\", webpOptions.alphaQuality);\n        }\n      }\n      if (inputValidator.defined(webpOptions.lossless)) {\n        this._setBooleanOption(\"webpLossless\", webpOptions.lossless);\n      }\n      if (inputValidator.defined(webpOptions.nearLossless)) {\n        this._setBooleanOption(\"webpNearLossless\", webpOptions.nearLossless);\n      }\n      if (inputValidator.defined(webpOptions.smartSubsample)) {\n        this._setBooleanOption(\"webpSmartSubsample\", webpOptions.smartSubsample);\n      }\n      if (inputValidator.defined(webpOptions.preset)) {\n        if (inputValidator.string(webpOptions.preset) && inputValidator.inArray(webpOptions.preset, [\"default\", \"photo\", \"picture\", \"drawing\", \"icon\", \"text\"])) {\n          this.options.webpPreset = webpOptions.preset;\n        } else {\n          throw inputValidator.invalidParameterError(\"preset\", \"one of: default, photo, picture, drawing, icon, text\", webpOptions.preset);\n        }\n      }\n      if (inputValidator.defined(webpOptions.effort)) {\n        if (inputValidator.integer(webpOptions.effort) && inputValidator.inRange(webpOptions.effort, 0, 6)) {\n          this.options.webpEffort = webpOptions.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 0 and 6\", webpOptions.effort);\n        }\n      }\n      if (inputValidator.defined(webpOptions.minSize)) {\n        this._setBooleanOption(\"webpMinSize\", webpOptions.minSize);\n      }\n      if (inputValidator.defined(webpOptions.mixed)) {\n        this._setBooleanOption(\"webpMixed\", webpOptions.mixed);\n      }\n    }\n    configureLoopAndDelay(webpOptions, this.options);\n    return this._updateFormatOut(\"webp\", webpOptions);\n  }\n  function setGifOptions(gifOptions) {\n    if (inputValidator.object(gifOptions)) {\n      if (inputValidator.defined(gifOptions.reuse)) {\n        this._setBooleanOption(\"gifReuse\", gifOptions.reuse);\n      }\n      if (inputValidator.defined(gifOptions.progressive)) {\n        this._setBooleanOption(\"gifProgressive\", gifOptions.progressive);\n      }\n      let B = gifOptions.colours || gifOptions.colors;\n      if (inputValidator.defined(B)) {\n        if (inputValidator.integer(B) && inputValidator.inRange(B, 2, 256)) {\n          this.options.gifBitdepth = calculateBitDepth(B);\n        } else {\n          throw inputValidator.invalidParameterError(\"colours\", \"integer between 2 and 256\", B);\n        }\n      }\n      if (inputValidator.defined(gifOptions.effort)) {\n        if (inputValidator.number(gifOptions.effort) && inputValidator.inRange(gifOptions.effort, 1, 10)) {\n          this.options.gifEffort = gifOptions.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 1 and 10\", gifOptions.effort);\n        }\n      }\n      if (inputValidator.defined(gifOptions.dither)) {\n        if (inputValidator.number(gifOptions.dither) && inputValidator.inRange(gifOptions.dither, 0, 1)) {\n          this.options.gifDither = gifOptions.dither;\n        } else {\n          throw inputValidator.invalidParameterError(\"dither\", \"number between 0.0 and 1.0\", gifOptions.dither);\n        }\n      }\n      if (inputValidator.defined(gifOptions.interFrameMaxError)) {\n        if (inputValidator.number(gifOptions.interFrameMaxError) && inputValidator.inRange(gifOptions.interFrameMaxError, 0, 32)) {\n          this.options.gifInterFrameMaxError = gifOptions.interFrameMaxError;\n        } else {\n          throw inputValidator.invalidParameterError(\"interFrameMaxError\", \"number between 0.0 and 32.0\", gifOptions.interFrameMaxError);\n        }\n      }\n      if (inputValidator.defined(gifOptions.interPaletteMaxError)) {\n        if (inputValidator.number(gifOptions.interPaletteMaxError) && inputValidator.inRange(gifOptions.interPaletteMaxError, 0, 256)) {\n          this.options.gifInterPaletteMaxError = gifOptions.interPaletteMaxError;\n        } else {\n          throw inputValidator.invalidParameterError(\"interPaletteMaxError\", \"number between 0.0 and 256.0\", gifOptions.interPaletteMaxError);\n        }\n      }\n    }\n    configureLoopAndDelay(gifOptions, this.options);\n    return this._updateFormatOut(\"gif\", gifOptions);\n  }\n  function updateJP2Options(jp2Options) {\n    if (!this.constructor.format.jp2k.output.buffer) {\n      throw generateJP2Error();\n    }\n    if (inputValidator.object(jp2Options)) {\n      if (inputValidator.defined(jp2Options.quality)) {\n        if (inputValidator.integer(jp2Options.quality) && inputValidator.inRange(jp2Options.quality, 1, 100)) {\n          this.options.jp2Quality = jp2Options.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", jp2Options.quality);\n        }\n      }\n      if (inputValidator.defined(jp2Options.lossless)) {\n        if (inputValidator.bool(jp2Options.lossless)) {\n          this.options.jp2Lossless = jp2Options.lossless;\n        } else {\n          throw inputValidator.invalidParameterError(\"lossless\", \"boolean\", jp2Options.lossless);\n        }\n      }\n      if (inputValidator.defined(jp2Options.tileWidth)) {\n        if (inputValidator.integer(jp2Options.tileWidth) && inputValidator.inRange(jp2Options.tileWidth, 1, 32768)) {\n          this.options.jp2TileWidth = jp2Options.tileWidth;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileWidth\", \"integer between 1 and 32768\", jp2Options.tileWidth);\n        }\n      }\n      if (inputValidator.defined(jp2Options.tileHeight)) {\n        if (inputValidator.integer(jp2Options.tileHeight) && inputValidator.inRange(jp2Options.tileHeight, 1, 32768)) {\n          this.options.jp2TileHeight = jp2Options.tileHeight;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileHeight\", \"integer between 1 and 32768\", jp2Options.tileHeight);\n        }\n      }\n      if (inputValidator.defined(jp2Options.chromaSubsampling)) {\n        if (inputValidator.string(jp2Options.chromaSubsampling) && inputValidator.inArray(jp2Options.chromaSubsampling, [\"4:2:0\", \"4:4:4\"])) {\n          this.options.jp2ChromaSubsampling = jp2Options.chromaSubsampling;\n        } else {\n          throw inputValidator.invalidParameterError(\"chromaSubsampling\", \"one of: 4:2:0, 4:4:4\", jp2Options.chromaSubsampling);\n        }\n      }\n    }\n    return this._updateFormatOut(\"jp2\", jp2Options);\n  }\n  function configureLoopAndDelay(config, destinationObject) {\n    if (inputValidator.object(config) && inputValidator.defined(config.loop)) {\n      if (inputValidator.integer(config.loop) && inputValidator.inRange(config.loop, 0, 65535)) {\n        destinationObject.loop = config.loop;\n      } else {\n        throw inputValidator.invalidParameterError(\"loop\", \"integer between 0 and 65535\", config.loop);\n      }\n    }\n    if (inputValidator.object(config) && inputValidator.defined(config.delay)) {\n      if (inputValidator.integer(config.delay) && inputValidator.inRange(config.delay, 0, 65535)) {\n        destinationObject.delay = [config.delay];\n      } else if (Array.isArray(config.delay) && config.delay.every(inputValidator.integer) && config.delay.every(_inputValue => inputValidator.inRange(_inputValue, 0, 65535))) {\n        destinationObject.delay = config.delay;\n      } else {\n        throw inputValidator.invalidParameterError(\"delay\", \"integer or an array of integers between 0 and 65535\", config.delay);\n      }\n    }\n  }\n  function setTiffOptions(tiffOptions) {\n    if (inputValidator.object(tiffOptions)) {\n      if (inputValidator.defined(tiffOptions.quality)) {\n        if (inputValidator.integer(tiffOptions.quality) && inputValidator.inRange(tiffOptions.quality, 1, 100)) {\n          this.options.tiffQuality = tiffOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", tiffOptions.quality);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.bitdepth)) {\n        if (inputValidator.integer(tiffOptions.bitdepth) && inputValidator.inArray(tiffOptions.bitdepth, [1, 2, 4, 8])) {\n          this.options.tiffBitdepth = tiffOptions.bitdepth;\n        } else {\n          throw inputValidator.invalidParameterError(\"bitdepth\", \"1, 2, 4 or 8\", tiffOptions.bitdepth);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.tile)) {\n        this._setBooleanOption(\"tiffTile\", tiffOptions.tile);\n      }\n      if (inputValidator.defined(tiffOptions.tileWidth)) {\n        if (inputValidator.integer(tiffOptions.tileWidth) && tiffOptions.tileWidth > 0) {\n          this.options.tiffTileWidth = tiffOptions.tileWidth;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileWidth\", \"integer greater than zero\", tiffOptions.tileWidth);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.tileHeight)) {\n        if (inputValidator.integer(tiffOptions.tileHeight) && tiffOptions.tileHeight > 0) {\n          this.options.tiffTileHeight = tiffOptions.tileHeight;\n        } else {\n          throw inputValidator.invalidParameterError(\"tileHeight\", \"integer greater than zero\", tiffOptions.tileHeight);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.miniswhite)) {\n        this._setBooleanOption(\"tiffMiniswhite\", tiffOptions.miniswhite);\n      }\n      if (inputValidator.defined(tiffOptions.pyramid)) {\n        this._setBooleanOption(\"tiffPyramid\", tiffOptions.pyramid);\n      }\n      if (inputValidator.defined(tiffOptions.xres)) {\n        if (inputValidator.number(tiffOptions.xres) && tiffOptions.xres > 0) {\n          this.options.tiffXres = tiffOptions.xres;\n        } else {\n          throw inputValidator.invalidParameterError(\"xres\", \"number greater than zero\", tiffOptions.xres);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.yres)) {\n        if (inputValidator.number(tiffOptions.yres) && tiffOptions.yres > 0) {\n          this.options.tiffYres = tiffOptions.yres;\n        } else {\n          throw inputValidator.invalidParameterError(\"yres\", \"number greater than zero\", tiffOptions.yres);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.compression)) {\n        if (inputValidator.string(tiffOptions.compression) && inputValidator.inArray(tiffOptions.compression, [\"none\", \"jpeg\", \"deflate\", \"packbits\", \"ccittfax4\", \"lzw\", \"webp\", \"zstd\", \"jp2k\"])) {\n          this.options.tiffCompression = tiffOptions.compression;\n        } else {\n          throw inputValidator.invalidParameterError(\"compression\", \"one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\", tiffOptions.compression);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.predictor)) {\n        if (inputValidator.string(tiffOptions.predictor) && inputValidator.inArray(tiffOptions.predictor, [\"none\", \"horizontal\", \"float\"])) {\n          this.options.tiffPredictor = tiffOptions.predictor;\n        } else {\n          throw inputValidator.invalidParameterError(\"predictor\", \"one of: none, horizontal, float\", tiffOptions.predictor);\n        }\n      }\n      if (inputValidator.defined(tiffOptions.resolutionUnit)) {\n        if (inputValidator.string(tiffOptions.resolutionUnit) && inputValidator.inArray(tiffOptions.resolutionUnit, [\"inch\", \"cm\"])) {\n          this.options.tiffResolutionUnit = tiffOptions.resolutionUnit;\n        } else {\n          throw inputValidator.invalidParameterError(\"resolutionUnit\", \"one of: inch, cm\", tiffOptions.resolutionUnit);\n        }\n      }\n    }\n    return this._updateFormatOut(\"tiff\", tiffOptions);\n  }\n  function applyAv1Compression(videoOptions) {\n    return this.heif({\n      ...videoOptions,\n      compression: \"av1\"\n    });\n  }\n  function setHeifOptions(heifOptions) {\n    if (inputValidator.object(heifOptions)) {\n      if (inputValidator.string(heifOptions.compression) && inputValidator.inArray(heifOptions.compression, [\"av1\", \"hevc\"])) {\n        this.options.heifCompression = heifOptions.compression;\n      } else {\n        throw inputValidator.invalidParameterError(\"compression\", \"one of: av1, hevc\", heifOptions.compression);\n      }\n      if (inputValidator.defined(heifOptions.quality)) {\n        if (inputValidator.integer(heifOptions.quality) && inputValidator.inRange(heifOptions.quality, 1, 100)) {\n          this.options.heifQuality = heifOptions.quality;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", heifOptions.quality);\n        }\n      }\n      if (inputValidator.defined(heifOptions.lossless)) {\n        if (inputValidator.bool(heifOptions.lossless)) {\n          this.options.heifLossless = heifOptions.lossless;\n        } else {\n          throw inputValidator.invalidParameterError(\"lossless\", \"boolean\", heifOptions.lossless);\n        }\n      }\n      if (inputValidator.defined(heifOptions.effort)) {\n        if (inputValidator.integer(heifOptions.effort) && inputValidator.inRange(heifOptions.effort, 0, 9)) {\n          this.options.heifEffort = heifOptions.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 0 and 9\", heifOptions.effort);\n        }\n      }\n      if (inputValidator.defined(heifOptions.chromaSubsampling)) {\n        if (inputValidator.string(heifOptions.chromaSubsampling) && inputValidator.inArray(heifOptions.chromaSubsampling, [\"4:2:0\", \"4:4:4\"])) {\n          this.options.heifChromaSubsampling = heifOptions.chromaSubsampling;\n        } else {\n          throw inputValidator.invalidParameterError(\"chromaSubsampling\", \"one of: 4:2:0, 4:4:4\", heifOptions.chromaSubsampling);\n        }\n      }\n      if (inputValidator.defined(heifOptions.bitdepth)) {\n        if (inputValidator.integer(heifOptions.bitdepth) && inputValidator.inArray(heifOptions.bitdepth, [8, 10, 12])) {\n          if (heifOptions.bitdepth !== 8 && this.constructor.versions.heif) {\n            throw inputValidator.invalidParameterError(\"bitdepth when using prebuilt binaries\", 8, heifOptions.bitdepth);\n          }\n          this.options.heifBitdepth = heifOptions.bitdepth;\n        } else {\n          throw inputValidator.invalidParameterError(\"bitdepth\", \"8, 10 or 12\", heifOptions.bitdepth);\n        }\n      }\n    } else {\n      throw inputValidator.invalidParameterError(\"options\", \"Object\", heifOptions);\n    }\n    return this._updateFormatOut(\"heif\", heifOptions);\n  }\n  function configureJxlOptions(_optionsConfig) {\n    if (inputValidator.object(_optionsConfig)) {\n      if (inputValidator.defined(_optionsConfig.quality)) {\n        if (inputValidator.integer(_optionsConfig.quality) && inputValidator.inRange(_optionsConfig.quality, 1, 100)) {\n          this.options.jxlDistance = _optionsConfig.quality >= 30 ? 0.1 + (100 - _optionsConfig.quality) * 0.09 : _optionsConfig.quality * 0.017666666666666667 * _optionsConfig.quality - _optionsConfig.quality * 1.15 + 25;\n        } else {\n          throw inputValidator.invalidParameterError(\"quality\", \"integer between 1 and 100\", _optionsConfig.quality);\n        }\n      } else if (inputValidator.defined(_optionsConfig.distance)) {\n        if (inputValidator.number(_optionsConfig.distance) && inputValidator.inRange(_optionsConfig.distance, 0, 15)) {\n          this.options.jxlDistance = _optionsConfig.distance;\n        } else {\n          throw inputValidator.invalidParameterError(\"distance\", \"number between 0.0 and 15.0\", _optionsConfig.distance);\n        }\n      }\n      if (inputValidator.defined(_optionsConfig.decodingTier)) {\n        if (inputValidator.integer(_optionsConfig.decodingTier) && inputValidator.inRange(_optionsConfig.decodingTier, 0, 4)) {\n          this.options.jxlDecodingTier = _optionsConfig.decodingTier;\n        } else {\n          throw inputValidator.invalidParameterError(\"decodingTier\", \"integer between 0 and 4\", _optionsConfig.decodingTier);\n        }\n      }\n      if (inputValidator.defined(_optionsConfig.lossless)) {\n        if (inputValidator.bool(_optionsConfig.lossless)) {\n          this.options.jxlLossless = _optionsConfig.lossless;\n        } else {\n          throw inputValidator.invalidParameterError(\"lossless\", \"boolean\", _optionsConfig.lossless);\n        }\n      }\n      if (inputValidator.defined(_optionsConfig.effort)) {\n        if (inputValidator.integer(_optionsConfig.effort) && inputValidator.inRange(_optionsConfig.effort, 3, 9)) {\n          this.options.jxlEffort = _optionsConfig.effort;\n        } else {\n          throw inputValidator.invalidParameterError(\"effort\", \"integer between 3 and 9\", _optionsConfig.effort);\n        }\n      }\n    }\n    return this._updateFormatOut(\"jxl\", _optionsConfig);\n  }\n  function validateInputDepthAndSet(inputOptions) {\n    if (inputValidator.object(inputOptions)) {\n      if (inputValidator.defined(inputOptions.depth)) {\n        if (inputValidator.string(inputOptions.depth) && inputValidator.inArray(inputOptions.depth, [\"char\", \"uchar\", \"short\", \"ushort\", \"int\", \"uint\", \"float\", \"complex\", \"double\", \"dpcomplex\"])) {\n          this.options.rawDepth = inputOptions.depth;\n        } else {\n          throw inputValidator.invalidParameterError(\"depth\", \"one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex\", inputOptions.depth);\n        }\n      }\n    }\n    return this._updateFormatOut(\"raw\");\n  }\n  function validateAndSetTileOptions(tileOptions) {\n    if (inputValidator.object(tileOptions)) {\n      if (inputValidator.defined(tileOptions.size)) {\n        if (inputValidator.integer(tileOptions.size) && inputValidator.inRange(tileOptions.size, 1, 8192)) {\n          this.options.tileSize = tileOptions.size;\n        } else {\n          throw inputValidator.invalidParameterError(\"size\", \"integer between 1 and 8192\", tileOptions.size);\n        }\n      }\n      if (inputValidator.defined(tileOptions.overlap)) {\n        if (inputValidator.integer(tileOptions.overlap) && inputValidator.inRange(tileOptions.overlap, 0, 8192)) {\n          if (tileOptions.overlap > this.options.tileSize) {\n            throw inputValidator.invalidParameterError(\"overlap\", `<= size (${this.options.tileSize})`, tileOptions.overlap);\n          }\n          this.options.tileOverlap = tileOptions.overlap;\n        } else {\n          throw inputValidator.invalidParameterError(\"overlap\", \"integer between 0 and 8192\", tileOptions.overlap);\n        }\n      }\n      if (inputValidator.defined(tileOptions.container)) {\n        if (inputValidator.string(tileOptions.container) && inputValidator.inArray(tileOptions.container, [\"fs\", \"zip\"])) {\n          this.options.tileContainer = tileOptions.container;\n        } else {\n          throw inputValidator.invalidParameterError(\"container\", \"one of: fs, zip\", tileOptions.container);\n        }\n      }\n      if (inputValidator.defined(tileOptions.layout)) {\n        if (inputValidator.string(tileOptions.layout) && inputValidator.inArray(tileOptions.layout, [\"dz\", \"google\", \"iiif\", \"iiif3\", \"zoomify\"])) {\n          this.options.tileLayout = tileOptions.layout;\n        } else {\n          throw inputValidator.invalidParameterError(\"layout\", \"one of: dz, google, iiif, iiif3, zoomify\", tileOptions.layout);\n        }\n      }\n      if (inputValidator.defined(tileOptions.angle)) {\n        if (inputValidator.integer(tileOptions.angle) && !(tileOptions.angle % 90)) {\n          this.options.tileAngle = tileOptions.angle;\n        } else {\n          throw inputValidator.invalidParameterError(\"angle\", \"positive/negative multiple of 90\", tileOptions.angle);\n        }\n      }\n      this._setBackgroundColourOption(\"tileBackground\", tileOptions.background);\n      if (inputValidator.defined(tileOptions.depth)) {\n        if (inputValidator.string(tileOptions.depth) && inputValidator.inArray(tileOptions.depth, [\"onepixel\", \"onetile\", \"one\"])) {\n          this.options.tileDepth = tileOptions.depth;\n        } else {\n          throw inputValidator.invalidParameterError(\"depth\", \"one of: onepixel, onetile, one\", tileOptions.depth);\n        }\n      }\n      if (inputValidator.defined(tileOptions.skipBlanks)) {\n        if (inputValidator.integer(tileOptions.skipBlanks) && inputValidator.inRange(tileOptions.skipBlanks, -1, 65535)) {\n          this.options.tileSkipBlanks = tileOptions.skipBlanks;\n        } else {\n          throw inputValidator.invalidParameterError(\"skipBlanks\", \"integer between -1 and 255/65535\", tileOptions.skipBlanks);\n        }\n      } else if (inputValidator.defined(tileOptions.layout) && tileOptions.layout === \"google\") {\n        this.options.tileSkipBlanks = 5;\n      }\n      let tileCenterOption = inputValidator.bool(tileOptions.center) ? tileOptions.center : tileOptions.centre;\n      if (inputValidator.defined(tileCenterOption)) {\n        this._setBooleanOption(\"tileCentre\", tileCenterOption);\n      }\n      if (inputValidator.defined(tileOptions.id)) {\n        if (inputValidator.string(tileOptions.id)) {\n          this.options.tileId = tileOptions.id;\n        } else {\n          throw inputValidator.invalidParameterError(\"id\", \"string\", tileOptions.id);\n        }\n      }\n      if (inputValidator.defined(tileOptions.basename)) {\n        if (inputValidator.string(tileOptions.basename)) {\n          this.options.tileBasename = tileOptions.basename;\n        } else {\n          throw inputValidator.invalidParameterError(\"basename\", \"string\", tileOptions.basename);\n        }\n      }\n    }\n    if (inputValidator.inArray(this.options.formatOut, [\"jpeg\", \"png\", \"webp\"])) {\n      this.options.tileFormat = this.options.formatOut;\n    } else if (this.options.formatOut !== \"input\") {\n      throw inputValidator.invalidParameterError(\"format\", \"one of: jpeg, png, webp\", this.options.formatOut);\n    }\n    return this._updateFormatOut(\"dz\");\n  }\n  function setTimeoutOptions(__optionsConfig) {\n    if (!inputValidator.plainObject(__optionsConfig)) {\n      throw inputValidator.invalidParameterError(\"options\", \"object\", __optionsConfig);\n    }\n    if (inputValidator.integer(__optionsConfig.seconds) && inputValidator.inRange(__optionsConfig.seconds, 0, 3600)) {\n      this.options.timeoutSeconds = __optionsConfig.seconds;\n    } else {\n      throw inputValidator.invalidParameterError(\"seconds\", \"integer between 0 and 3600\", __optionsConfig.seconds);\n    }\n    return this;\n  }\n  function setOutputFormat(outputFormat, outputFormatter) {\n    if (!inputValidator.object(outputFormatter) || outputFormatter.force !== false) {\n      this.options.formatOut = outputFormat;\n    }\n    return this;\n  }\n  function setBooleanOption(optionKey, booleanValue) {\n    if (inputValidator.bool(booleanValue)) {\n      this.options[optionKey] = booleanValue;\n    } else {\n      throw inputValidator.invalidParameterError(optionKey, \"boolean\", booleanValue);\n    }\n  }\n  function startStream() {\n    if (!this.options.streamOut) {\n      this.options.streamOut = true;\n      let streamError = Error();\n      this._pipeline(undefined, streamError);\n    }\n  }\n  function _processImagePipeline(_callbackFunction, errorHandler) {\n    if (typeof _callbackFunction === \"function\") {\n      if (this._isStreamInput()) {\n        this.on(\"finish\", () => {\n          this._flattenBufferIn();\n          _______imageProcessor.pipeline(this.options, (_errorResponse, _____errorHandler, errorHandlerAndResponse) => {\n            if (_errorResponse) {\n              _callbackFunction(inputValidator.nativeError(_errorResponse, errorHandler));\n            } else {\n              _callbackFunction(null, _____errorHandler, errorHandlerAndResponse);\n            }\n          });\n        });\n      } else {\n        _______imageProcessor.pipeline(this.options, (inputValidationError, _input, errorHandlerOrCallback) => {\n          if (inputValidationError) {\n            _callbackFunction(inputValidator.nativeError(inputValidationError, errorHandler));\n          } else {\n            _callbackFunction(null, _input, errorHandlerOrCallback);\n          }\n        });\n      }\n      return this;\n    } else if (this.options.streamOut) {\n      if (this._isStreamInput()) {\n        this.once(\"finish\", () => {\n          this._flattenBufferIn();\n          _______imageProcessor.pipeline(this.options, (isValidInput, __inputData, logInfo) => {\n            if (isValidInput) {\n              this.emit(\"error\", inputValidator.nativeError(isValidInput, errorHandler));\n            } else {\n              this.emit(\"info\", logInfo);\n              this.push(__inputData);\n            }\n            this.push(null);\n            this.on(\"end\", () => this.emit(\"close\"));\n          });\n        });\n        if (this.streamInFinished) {\n          this.emit(\"finish\");\n        }\n      } else {\n        _______imageProcessor.pipeline(this.options, (errorOccurred, ___inputData, infoMessage) => {\n          if (errorOccurred) {\n            this.emit(\"error\", inputValidator.nativeError(errorOccurred, errorHandler));\n          } else {\n            this.emit(\"info\", infoMessage);\n            this.push(___inputData);\n          }\n          this.push(null);\n          this.on(\"end\", () => this.emit(\"close\"));\n        });\n      }\n      return this;\n    } else if (this._isStreamInput()) {\n      return new Promise((______processImage, _errorCallback) => {\n        this.once(\"finish\", () => {\n          this._flattenBufferIn();\n          _______imageProcessor.pipeline(this.options, (imageProcessingCondition, imageData, imageInfo) => {\n            if (imageProcessingCondition) {\n              _errorCallback(inputValidator.nativeError(imageProcessingCondition, errorHandler));\n            } else if (this.options.resolveWithObject) {\n              ______processImage({\n                data: imageData,\n                info: imageInfo\n              });\n            } else {\n              ______processImage(imageData);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((____callbackFunction, handleError) => {\n        _______imageProcessor.pipeline(this.options, (inputValidationResult, responseData, infoData) => {\n          if (inputValidationResult) {\n            handleError(inputValidator.nativeError(inputValidationResult, errorHandler));\n          } else if (this.options.resolveWithObject) {\n            ____callbackFunction({\n              data: responseData,\n              info: infoData\n            });\n          } else {\n            ____callbackFunction(responseData);\n          }\n        });\n      });\n    }\n  }\n  registerImageProcessingMethods.exports = function (ImageTransformer) {\n    Object.assign(ImageTransformer.prototype, {\n      toFile: validateAndProcessOutputFile,\n      toBuffer: setResolveOption,\n      keepExif: setKeepMetadataFlag,\n      withExif: processExifDataAndStore,\n      withExifMerge: initializeWithExif,\n      keepIccProfile: updateMetadataOptions,\n      withIccProfile: setIccProfileAndMetadataOptions,\n      keepMetadata: setKeepMetadataOption,\n      withMetadata: processMetadataOptions,\n      toFormat: processImageByFormat,\n      jpeg: configureJpegCompressionOptions,\n      jp2: updateJP2Options,\n      png: configurePngOptions,\n      webp: configureWebpOptions,\n      tiff: setTiffOptions,\n      avif: applyAv1Compression,\n      heif: setHeifOptions,\n      jxl: configureJxlOptions,\n      gif: setGifOptions,\n      raw: validateInputDepthAndSet,\n      tile: validateAndSetTileOptions,\n      timeout: setTimeoutOptions,\n      _updateFormatOut: setOutputFormat,\n      _setBooleanOption: setBooleanOption,\n      _read: startStream,\n      _pipeline: _processImagePipeline\n    });\n  };\n});\nvar ImageProcessingEngine = z((initializeSharpModule, _initializeSharpModule) => {\n  var EventEmitter = EA(\"node:events\");\n  var imageProcessingLibrary = iPA();\n  var parameterValidator = iT();\n  var {\n    runtimePlatformArch: getRuntimePlatformArch\n  } = FJ1();\n  var libVipsInstance = HJA();\n  var getPlatformArchitecture = getRuntimePlatformArch();\n  var libVipsVersion = libVipsInstance.libvipsVersion();\n  var imageFormatManager = libVipsInstance.format();\n  imageFormatManager.heif.output.alias = [\"avif\", \"heic\"];\n  imageFormatManager.jpeg.output.alias = [\"jpe\", \"jpg\"];\n  imageFormatManager.tiff.output.alias = [\"tif\"];\n  imageFormatManager.jp2k.output.alias = [\"j2c\", \"j2k\", \"jp2\", \"jpx\"];\n  var interpolationMethods = {\n    nearest: \"nearest\",\n    bilinear: \"bilinear\",\n    bicubic: \"bicubic\",\n    locallyBoundedBicubic: \"lbb\",\n    nohalo: \"nohalo\",\n    vertexSplitQuadraticBasisSpline: \"vsqbs\"\n  };\n  var sharpLibraryVersions = {\n    vips: libVipsVersion.semver\n  };\n  if (!libVipsVersion.isGlobal) {\n    if (!libVipsVersion.isWasm) {\n      try {\n        sharpLibraryVersions = EA(`@img/sharp-${getPlatformArchitecture}/versions`);\n      } catch (errorWhileFetchingVersion) {\n        try {\n          sharpLibraryVersions = EA(`@img/sharp-libvips-${getPlatformArchitecture}/versions`);\n        } catch (_________________error) {}\n      }\n    } else {\n      try {\n        sharpLibraryVersions = (() => {\n          throw new Error(\"Cannot require module @img/sharp-wasm32/versions\");\n        })();\n      } catch (errorCatch) {}\n    }\n  }\n  sharpLibraryVersions.sharp = XJ1().version;\n  if (sharpLibraryVersions.heif && imageFormatManager.heif) {\n    imageFormatManager.heif.input.fileSuffix = [\".avif\"];\n    imageFormatManager.heif.output.alias = [\"avif\"];\n  }\n  function configureCacheSettings(cacheParameters) {\n    if (parameterValidator.bool(cacheParameters)) {\n      if (cacheParameters) {\n        return libVipsInstance.cache(50, 20, 100);\n      } else {\n        return libVipsInstance.cache(0, 0, 0);\n      }\n    } else if (parameterValidator.object(cacheParameters)) {\n      return libVipsInstance.cache(cacheParameters.memory, cacheParameters.files, cacheParameters.items);\n    } else {\n      return libVipsInstance.cache();\n    }\n  }\n  configureCacheSettings(true);\n  function setConcurrencyLevel(concurrencyInput) {\n    return libVipsInstance.concurrency(parameterValidator.integer(concurrencyInput) ? concurrencyInput : null);\n  }\n  if (imageProcessingLibrary.familySync() === imageProcessingLibrary.GLIBC && !libVipsInstance._isUsingJemalloc()) {\n    libVipsInstance.concurrency(1);\n  } else if (imageProcessingLibrary.familySync() === imageProcessingLibrary.MUSL && libVipsInstance.concurrency() === 1024) {\n    libVipsInstance.concurrency(EA(\"node:os\").availableParallelism());\n  }\n  var eventEmitterInstance = new EventEmitter.EventEmitter();\n  function getVipsCounters() {\n    return libVipsInstance.counters();\n  }\n  function validateAndProcessBoolean(isValidBoolean) {\n    return libVipsInstance.simd(parameterValidator.bool(isValidBoolean) ? isValidBoolean : null);\n  }\n  function validateAndProcessImage(validateAndProcessImageOptions) {\n    if (parameterValidator.object(validateAndProcessImageOptions)) {\n      if (Array.isArray(validateAndProcessImageOptions.operation) && validateAndProcessImageOptions.operation.every(parameterValidator.string)) {\n        libVipsInstance.block(validateAndProcessImageOptions.operation, true);\n      } else {\n        throw parameterValidator.invalidParameterError(\"operation\", \"Array<string>\", validateAndProcessImageOptions.operation);\n      }\n    } else {\n      throw parameterValidator.invalidParameterError(\"options\", \"object\", validateAndProcessImageOptions);\n    }\n  }\n  function processImageOperations(__options) {\n    if (parameterValidator.object(__options)) {\n      if (Array.isArray(__options.operation) && __options.operation.every(parameterValidator.string)) {\n        libVipsInstance.block(__options.operation, false);\n      } else {\n        throw parameterValidator.invalidParameterError(\"operation\", \"Array<string>\", __options.operation);\n      }\n    } else {\n      throw parameterValidator.invalidParameterError(\"options\", \"object\", __options);\n    }\n  }\n  _initializeSharpModule.exports = function (configuration) {\n    configuration.cache = configureCacheSettings;\n    configuration.concurrency = setConcurrencyLevel;\n    configuration.counters = getVipsCounters;\n    configuration.simd = validateAndProcessBoolean;\n    configuration.format = imageFormatManager;\n    configuration.interpolators = interpolationMethods;\n    configuration.versions = sharpLibraryVersions;\n    configuration.queue = eventEmitterInstance;\n    configuration.block = validateAndProcessImage;\n    configuration.unblock = processImageOperations;\n  };\n});\nvar ___imageTransformationPipeline = z((processAndExportImage, exportImageProcessingFunction) => {\n  var _imageProcessingResult = j_0();\n  s_0()(_imageProcessingResult);\n  Bx0()(_imageProcessingResult);\n  Ix0()(_imageProcessingResult);\n  Yx0()(_imageProcessingResult);\n  Wx0()(_imageProcessingResult);\n  Cx0()(_imageProcessingResult);\n  processImageTransformation()(_imageProcessingResult);\n  ImageProcessingEngine()(_imageProcessingResult);\n  exportImageProcessingFunction.exports = _imageProcessingResult;\n});\nasync function processAndTransformImage(processImageTransform, _maxImageSize, defaultImageFormat) {\n  try {\n    let I = await Promise.resolve().then(() => IA(___imageTransformationPipeline(), 1));\n    let Z = (I.default || I)(processImageTransform);\n    let Y = await Z.metadata();\n    if (!Y.width || !Y.height) {\n      if (_maxImageSize > MAX_IMAGE_SIZE) {\n        return {\n          buffer: await Z.jpeg({\n            quality: 80\n          }).toBuffer(),\n          mediaType: \"jpeg\"\n        };\n      }\n    }\n    let J = Y.width || 0;\n    let X = Y.height || 0;\n    let W = Y.format ?? defaultImageFormat;\n    let F = W === \"jpg\" ? \"jpeg\" : W;\n    if (_maxImageSize <= MAX_IMAGE_SIZE && J <= maxImageDimension && X <= MAX_IMAGE_DIMENSION) {\n      return {\n        buffer: processImageTransform,\n        mediaType: F\n      };\n    }\n    if (J > maxImageDimension) {\n      X = Math.round(X * maxImageDimension / J);\n      J = maxImageDimension;\n    }\n    if (X > MAX_IMAGE_DIMENSION) {\n      J = Math.round(J * MAX_IMAGE_DIMENSION / X);\n      X = MAX_IMAGE_DIMENSION;\n    }\n    let C = await Z.resize(J, X, {\n      fit: \"inside\",\n      withoutEnlargement: true\n    }).toBuffer();\n    if (C.length > MAX_IMAGE_SIZE) {\n      return {\n        buffer: await Z.jpeg({\n          quality: 80\n        }).toBuffer(),\n        mediaType: \"jpeg\"\n      };\n    }\n    return {\n      buffer: C,\n      mediaType: F\n    };\n  } catch (I) {\n    BA(I, BY0);\n    return {\n      buffer: processImageTransform,\n      mediaType: defaultImageFormat === \"jpg\" ? \"jpeg\" : defaultImageFormat\n    };\n  }\n}\nasync function Lx0(processBase64Image) {\n  if (processBase64Image.source.type !== \"base64\") {\n    return processBase64Image;\n  }\n  let B = Buffer.from(processBase64Image.source.data, \"base64\");\n  let Q = B.length;\n  let G = processBase64Image.source.media_type?.split(\"/\")[1] || \"png\";\n  let Z = await processAndTransformImage(B, Q, G);\n  return {\n    type: \"image\",\n    source: {\n      type: \"base64\",\n      media_type: `image/${Z.mediaType}`,\n      data: Z.buffer.toString(\"base64\")\n    }\n  };\n}\nvar MAX_IMAGE_SIZE = 3932160;\nvar maxImageDimension = 2000;\nvar MAX_IMAGE_DIMENSION = 2000;\nvar initializeDjA = T(() => {\n  c1();\n});\nimport { execSync as execSyncChildProcess } from \"child_process\";\nimport { basename as extractFileExtension, extname as getExtensionFromFile, isAbsolute as isPathAbsolute } from \"path\";\nfunction getClipboardScreenshotMessage() {\n  let currentPlatform = process.platform;\n  let clipboardScreenshotMessages = {\n    darwin: \"No image found in clipboard. Use Cmd + Ctrl + Shift + 4 to copy a screenshot to clipboard.\",\n    win32: \"No image found in clipboard. Use Print Screen to copy a screenshot to clipboard.\",\n    linux: \"No image found in clipboard. Use appropriate screenshot tool to copy a screenshot to clipboard.\"\n  };\n  return clipboardScreenshotMessages[currentPlatform] || clipboardScreenshotMessages.linux;\n}\nfunction getClipboardImageHandler() {\n  let _getClipboardImageHandler = process.platform;\n  let platformSpecificClipboardImagePaths = {\n    darwin: \"/tmp/claude_cli_latest_screenshot.png\",\n    linux: \"/tmp/claude_cli_latest_screenshot.png\",\n    win32: process.env.TEMP ? `${process.env.TEMP}\\\\claude_cli_latest_screenshot.png` : \"C:\\\\Temp\\\\claude_cli_latest_screenshot.png\"\n  };\n  let screenshotPath = platformSpecificClipboardImagePaths[_getClipboardImageHandler] || platformSpecificClipboardImagePaths.linux;\n  let clipboardImageCommands = {\n    darwin: {\n      checkImage: \"osascript -e 'the clipboard as class PNGf'\",\n      saveImage: `osascript -e 'set png_data to (the clipboard as class PNGf)' -e 'set fp to open for access POSIX file \"${screenshotPath}\" with write permission' -e 'write png_data to fp' -e 'close access fp'`,\n      getPath: \"osascript -e 'get POSIX path of (the clipboard as class furl)'\",\n      deleteFile: `rm -f \"${screenshotPath}\"`\n    },\n    linux: {\n      checkImage: \"xclip -selection clipboard -t TARGETS -o | grep -E \\\"image/(png|jpeg|jpg|gif|webp)\\\"\",\n      saveImage: `xclip -selection clipboard -t image/png -o > \"${screenshotPath}\" || wl-paste --type image/png > \"${screenshotPath}\"`,\n      getPath: \"xclip -selection clipboard -t text/plain -o\",\n      deleteFile: `rm -f \"${screenshotPath}\"`\n    },\n    win32: {\n      checkImage: \"powershell -NoProfile -Command \\\"(Get-Clipboard -Format Image) -ne $null\\\"\",\n      saveImage: `powershell -NoProfile -Command \"$img = Get-Clipboard -Format Image; if ($img) { $img.Save('${screenshotPath.replace(/\\\\/g, \"\\\\\\\\\")}', [System.Drawing.Imaging.ImageFormat]::Png) }\"`,\n      getPath: \"powershell -NoProfile -Command \\\"Get-Clipboard\\\"\",\n      deleteFile: `del /f \"${screenshotPath}\"`\n    }\n  };\n  return {\n    commands: clipboardImageCommands[_getClipboardImageHandler] || clipboardImageCommands.linux,\n    screenshotPath: screenshotPath\n  };\n}\nasync function zjA() {\n  let {\n    commands: A,\n    screenshotPath: B\n  } = getClipboardImageHandler();\n  try {\n    execSyncChildProcess(A.checkImage, {\n      stdio: \"ignore\"\n    });\n    execSyncChildProcess(A.saveImage, {\n      stdio: \"ignore\"\n    });\n    let Q = NA().readFileBytesSync(B);\n    let {\n      buffer: I\n    } = await processAndTransformImage(Q, Q.length, \"png\");\n    let G = I.toString(\"base64\");\n    let Z = detectImageType(G);\n    execSyncChildProcess(A.deleteFile, {\n      stdio: \"ignore\"\n    });\n    return {\n      base64: G,\n      mediaType: Z\n    };\n  } catch {\n    return null;\n  }\n}\nfunction getClipboardImagePath() {\n  let {\n    commands: A\n  } = getClipboardImageHandler();\n  try {\n    return execSyncChildProcess(A.getPath, {\n      encoding: \"utf-8\"\n    }).trim();\n  } catch (B) {\n    BA(B, _MA);\n    return null;\n  }\n}\nfunction detectImageType(getImageMimeTypeFromBase64) {\n  try {\n    let imageBuffer = Buffer.from(getImageMimeTypeFromBase64, \"base64\");\n    if (imageBuffer.length < 4) {\n      return \"image/png\";\n    }\n    if (imageBuffer[0] === 137 && imageBuffer[1] === 80 && imageBuffer[2] === 78 && imageBuffer[3] === 71) {\n      return \"image/png\";\n    }\n    if (imageBuffer[0] === 255 && imageBuffer[1] === 216 && imageBuffer[2] === 255) {\n      return \"image/jpeg\";\n    }\n    if (imageBuffer[0] === 71 && imageBuffer[1] === 73 && imageBuffer[2] === 70) {\n      return \"image/gif\";\n    }\n    if (imageBuffer[0] === 82 && imageBuffer[1] === 73 && imageBuffer[2] === 70 && imageBuffer[3] === 70) {\n      if (imageBuffer.length >= 12 && imageBuffer[8] === 87 && imageBuffer[9] === 69 && imageBuffer[10] === 66 && imageBuffer[11] === 80) {\n        return \"image/webp\";\n      }\n    }\n    return \"image/png\";\n  } catch {\n    return \"image/png\";\n  }\n}\nfunction removeQuotesFromString(trimQuotes) {\n  if (trimQuotes.startsWith(\"\\\"\") && trimQuotes.endsWith(\"\\\"\") || trimQuotes.startsWith(\"'\") && trimQuotes.endsWith(\"'\")) {\n    return trimQuotes.slice(1, -1);\n  }\n  return trimQuotes;\n}\nfunction normalizeFilePath(normalizePathSeparator) {\n  if (process.platform === \"win32\") {\n    return normalizePathSeparator;\n  }\n  let doubleBackslashPlaceholder = \"__DOUBLE_BACKSLASH__\";\n  return normalizePathSeparator.replace(/\\\\\\\\/g, doubleBackslashPlaceholder).replace(/\\\\(.)/g, \"$1\").replace(new RegExp(doubleBackslashPlaceholder, \"g\"), \"\\\\\");\n}\nfunction processFilePath(____inputString) {\n  let B = removeQuotesFromString(____inputString.trim());\n  let Q = normalizeFilePath(B);\n  return outputFileHandler.test(Q);\n}\nfunction processAndValidateFilePath(_inputFilePath) {\n  let B = removeQuotesFromString(_inputFilePath.trim());\n  let Q = normalizeFilePath(B);\n  if (outputFileHandler.test(Q)) {\n    return Q;\n  }\n  return null;\n}\nasync function jx0(inputFilePath) {\n  let B = processAndValidateFilePath(inputFilePath);\n  if (!B) {\n    return null;\n  }\n  let Q = B;\n  let I;\n  try {\n    if (isPathAbsolute(Q)) {\n      I = NA().readFileBytesSync(Q);\n    } else {\n      let temporaryFilePath = getClipboardImagePath();\n      if (temporaryFilePath && Q === extractFileExtension(temporaryFilePath)) {\n        I = NA().readFileBytesSync(temporaryFilePath);\n      }\n    }\n  } catch (X) {\n    BA(X, AY0);\n    return null;\n  }\n  if (!I) {\n    return null;\n  }\n  let G = getExtensionFromFile(Q).slice(1).toLowerCase() || \"png\";\n  let {\n    buffer: Z\n  } = await processAndTransformImage(I, I.length, G);\n  let Y = Z.toString(\"base64\");\n  let J = detectImageType(Y);\n  return {\n    path: Q,\n    base64: Y,\n    mediaType: J\n  };\n}\nvar getErrorDescriptionForOutputFile;\nvar HIGHLIGHTED_MAX_WIDTH = 800;\nvar outputFileHandler;\nvar ________imageTransformationProcessor = T(() => {\n  m0();\n  c1();\n  initializeDjA();\n  getErrorDescriptionForOutputFile = getClipboardScreenshotMessage();\n  outputFileHandler = /\\.(png|jpe?g|gif|webp)$/i;\n});\nfunction RenderImageWithChildren({\n  children: A\n}) {\n  let {\n    marker: B\n  } = displayHandler.useContext(imageProcessingFunction);\n  return displayHandler.default.createElement(S, {\n    gap: 1\n  }, displayHandler.default.createElement(U, {\n    dimColor: true\n  }, B), displayHandler.default.createElement(S, {\n    flexDirection: \"column\"\n  }, A));\n}\nvar displayHandler;\nvar imageProcessingFunction;\nvar _________imageTransformationProcessor = T(() => {\n  nA();\n  displayHandler = IA(KA(), 1);\n  imageProcessingFunction = displayHandler.createContext({\n    marker: \"\"\n  });\n});\nfunction RenderImageWithMarkers({\n  children: A\n}) {\n  let {\n    marker: B\n  } = ReactContext.useContext(imageProcessingPipeline);\n  let validComponentCount = 0;\n  for (let G of ReactContext.default.Children.toArray(A)) {\n    if (!ReactContext.isValidElement(G) || G.type !== RenderImageWithChildren) {\n      continue;\n    }\n    validComponentCount++;\n  }\n  let I = String(validComponentCount).length;\n  return ReactContext.default.createElement(S, {\n    flexDirection: \"column\"\n  }, ReactContext.default.Children.map(A, (G, Z) => {\n    if (!ReactContext.isValidElement(G) || G.type !== RenderImageWithChildren) {\n      return G;\n    }\n    let Y = `${String(Z + 1).padStart(I)}.`;\n    let J = `${B}${Y}`;\n    return ReactContext.default.createElement(imageProcessingPipeline.Provider, {\n      value: {\n        marker: J\n      }\n    }, ReactContext.default.createElement(imageProcessingOperation.Provider, {\n      value: {\n        marker: J\n      }\n    }, G));\n  }));\n}\nvar ReactContext;\nvar imageProcessingPipeline;\nvar imageProcessingOperation;\nvar componentKey;\nvar RJ1 = T(() => {\n  nA();\n  _________imageTransformationProcessor();\n  ReactContext = IA(KA(), 1);\n  imageProcessingPipeline = ReactContext.createContext({\n    marker: \"\"\n  });\n  imageProcessingOperation = ReactContext.createContext({\n    marker: \"\"\n  });\n  RenderImageWithMarkers.Item = RenderImageWithChildren;\n  componentKey = RenderImageWithMarkers;\n});\nimport { join as resolveFilePath } from \"path\";\nfunction xx0() {\n  return generateOnboardingTips().filter(({\n    isCompletable: isCompletable,\n    isEnabled: isFeatureEnabled\n  }) => isCompletable && isFeatureEnabled).every(({\n    isComplete: isComplete\n  }) => isComplete);\n}\nfunction P0A() {\n  let A = v6();\n  if (xx0() && !A.hasCompletedProjectOnboarding) {\n    uG({\n      ...A,\n      hasCompletedProjectOnboarding: true\n    });\n  }\n}\nfunction generateOnboardingTips() {\n  let fileExistsForClaudeMD = NA().existsSync(resolveFilePath(G0(), \"CLAUDE.md\"));\n  let isFx0Active = fx0(G0());\n  let isWorkspaceTipHidden = _7(\"cc_onboarding_hide_workspace\", \"hide_workspace_tip\", false);\n  let isGithubIntegrationStepVisible = _7(\"cc_onboarding_github\", \"show_github_integration_step\", false);\n  return [{\n    key: \"workspace\",\n    text: \"Ask Claude to create a new app or clone a repository\",\n    isComplete: false,\n    isCompletable: true,\n    isEnabled: isFx0Active && !isWorkspaceTipHidden\n  }, {\n    key: \"claudemd\",\n    text: \"Run /init to create a CLAUDE.md file with instructions for Claude\",\n    isComplete: fileExistsForClaudeMD,\n    isCompletable: true,\n    isEnabled: !isFx0Active\n  }, {\n    key: \"github\",\n    text: \"Run /install-github-app to tag @claude right from your Github issues and PRs\",\n    isComplete: Boolean(L1().githubActionSetupCount),\n    isCompletable: true,\n    isEnabled: isGithubIntegrationStepVisible\n  }];\n}\nfunction incrementProjectOnboardingSeenCount() {\n  let projectOnboardingData = v6();\n  uG({\n    ...projectOnboardingData,\n    projectOnboardingSeenCount: projectOnboardingData.projectOnboardingSeenCount + 1\n  });\n}\nvar updateImageFormatBasedOnOptions;\nvar sharpImageProcessor;\nvar fileFormatMap;\nvar NJA = T(() => {\n  RJ1();\n  nA();\n  kB();\n  Z4();\n  V2();\n  m0();\n  a2();\n  f4();\n  updateImageFormatBasedOnOptions = IA(KA(), 1);\n  sharpImageProcessor = IA(KA(), 1);\n  fileFormatMap = I0(() => {\n    if (xx0() || v6().projectOnboardingSeenCount >= 4 || process.env.IS_DEMO) {\n      return false;\n    }\n    return true;\n  });\n});\nimport { homedir as defaultImageProcessor } from \"os\";\nimport { join as getPathFromHomeDirectory } from \"path\";\nfunction initializeAppleTerminalSetup(appleTerminalBackupPath) {\n  let appleTerminalSetupConfig = L1();\n  appleTerminalSetupConfig.appleTerminalSetupInProgress = true;\n  appleTerminalSetupConfig.appleTerminalBackupPath = appleTerminalBackupPath;\n  n0(appleTerminalSetupConfig);\n}\nfunction _initializeAppleTerminalSetup() {\n  let appleTerminalSetup = L1();\n  appleTerminalSetup.appleTerminalSetupInProgress = false;\n  n0(appleTerminalSetup);\n}\nfunction getAppleTerminalStatus() {\n  let appleTerminalStatus = L1();\n  return {\n    inProgress: appleTerminalStatus.appleTerminalSetupInProgress ?? false,\n    backupPath: appleTerminalStatus.appleTerminalBackupPath || null\n  };\n}\nfunction getTerminalPreferencesPath() {\n  return getPathFromHomeDirectory(defaultImageProcessor(), \"Library\", \"Preferences\", \"com.apple.Terminal.plist\");\n}\nasync function exportTerminalPreferences() {\n  let A = getTerminalPreferencesPath();\n  let B = `${A}.bak`;\n  try {\n    let {\n      code: Q\n    } = await r0(\"defaults\", [\"export\", \"com.apple.Terminal\", A]);\n    if (Q !== 0) {\n      return null;\n    }\n    if (NA().existsSync(A)) {\n      await r0(\"defaults\", [\"export\", \"com.apple.Terminal\", B]);\n      initializeAppleTerminalSetup(B);\n      return B;\n    }\n    return null;\n  } catch (Q) {\n    BA(Q instanceof Error ? Q : Error(String(Q)), pG0);\n    return null;\n  }\n}\nasync function restoreAppleTerminalSettings() {\n  let {\n    inProgress: isBackupInProgress,\n    backupPath: __backupFilePath\n  } = getAppleTerminalStatus();\n  if (!isBackupInProgress) {\n    return {\n      status: \"no_backup\"\n    };\n  }\n  if (!__backupFilePath || !NA().existsSync(__backupFilePath)) {\n    _initializeAppleTerminalSetup();\n    return {\n      status: \"no_backup\"\n    };\n  }\n  try {\n    let {\n      code: exitCode\n    } = await r0(\"defaults\", [\"import\", \"com.apple.Terminal\", __backupFilePath]);\n    if (exitCode !== 0) {\n      return {\n        status: \"failed\",\n        backupPath: __backupFilePath\n      };\n    }\n    await r0(\"killall\", [\"cfprefsd\"]);\n    _initializeAppleTerminalSetup();\n    return {\n      status: \"restored\"\n    };\n  } catch (Q) {\n    BA(Error(`Failed to restore Terminal.app settings with: ${Q}`), lG0);\n    _initializeAppleTerminalSetup();\n    return {\n      status: \"failed\",\n      backupPath: __backupFilePath\n    };\n  }\n}\nvar initializeShapelessPipeline = T(() => {\n  Q5();\n  c1();\n  kB();\n  m0();\n});\nimport { homedir as ImageProcessingModule } from \"os\";\nimport { join as errorMessages } from \"path\";\nfunction setupIterm2WithBackupPath(backupPath) {\n  let iterm2Session = L1();\n  iterm2Session.iterm2SetupInProgress = true;\n  iterm2Session.iterm2BackupPath = backupPath;\n  n0(iterm2Session);\n}\nfunction setupInProgressAndNotify() {\n  let setupNotificationForIterm2 = L1();\n  setupNotificationForIterm2.iterm2SetupInProgress = false;\n  n0(setupNotificationForIterm2);\n}\nfunction getITerm2SetupStatus() {\n  let iterm2SetupStatus = L1();\n  return {\n    inProgress: iterm2SetupStatus.iterm2SetupInProgress ?? false,\n    backupPath: iterm2SetupStatus.iterm2BackupPath || null\n  };\n}\nfunction getImageProcessingErrorMessages() {\n  return errorMessages(ImageProcessingModule(), \"Library\", \"Preferences\", \"com.googlecode.iterm2.plist\");\n}\nasync function exportIterm2Settings() {\n  let A = getImageProcessingErrorMessages();\n  let B = `${A}.bak`;\n  try {\n    await r0(\"defaults\", [\"export\", \"com.googlecode.iterm2\", A]);\n    if (NA().existsSync(A)) {\n      NA().copyFileSync(A, B);\n      setupIterm2WithBackupPath(B);\n      return B;\n    }\n    return null;\n  } catch (Q) {\n    BA(Q instanceof Error ? Q : Error(String(Q)), QY0);\n    return null;\n  }\n}\nfunction restoreITerm2Settings() {\n  let {\n    inProgress: A,\n    backupPath: B\n  } = getITerm2SetupStatus();\n  if (!A) {\n    return {\n      status: \"no_backup\"\n    };\n  }\n  if (!B || !NA().existsSync(B)) {\n    setupInProgressAndNotify();\n    return {\n      status: \"no_backup\"\n    };\n  }\n  try {\n    NA().copyFileSync(B, getImageProcessingErrorMessages());\n    setupInProgressAndNotify();\n    return {\n      status: \"restored\"\n    };\n  } catch (Q) {\n    BA(Error(`Failed to restore iTerm2 settings with: ${Q}`), IY0);\n    setupInProgressAndNotify();\n    return {\n      status: \"failed\",\n      backupPath: B\n    };\n  }\n}\nvar initializeCustomSettings = T(() => {\n  Q5();\n  c1();\n  kB();\n  m0();\n});\nimport { randomBytes as generateRandomBytes } from \"crypto\";\nimport { EOL as LineSeparator, homedir as getFolderPath, platform as processImageTransformations } from \"os\";\nimport { dirname as imageProcessor, join as outputImageFormatHandler } from \"path\";\nfunction isEnvironmentSupportedForImageTransformations() {\n  return processImageTransformations() === \"darwin\" && (O0.terminal === \"iTerm.app\" || O0.terminal === \"Apple_Terminal\") || O0.terminal === \"vscode\" || O0.terminal === \"cursor\" || O0.terminal === \"windsurf\" || O0.terminal === \"ghostty\" || O0.terminal === \"WezTerm\";\n}\nasync function kJ1(getTerminalOutput) {\n  let B = \"\";\n  switch (O0.terminal) {\n    case \"iTerm.app\":\n      B = await Mn9(getTerminalOutput);\n      break;\n    case \"Apple_Terminal\":\n      B = await On9(getTerminalOutput);\n      break;\n    case \"vscode\":\n      B = installTerminalShiftEnterKeyBinding(\"VSCode\", getTerminalOutput);\n      break;\n    case \"cursor\":\n      B = installTerminalShiftEnterKeyBinding(\"Cursor\", getTerminalOutput);\n      break;\n    case \"windsurf\":\n      B = installTerminalShiftEnterKeyBinding(\"Windsurf\", getTerminalOutput);\n      break;\n    case \"ghostty\":\n      B = await installGhosttyShiftEnterKeyBindingHandler(getTerminalOutput);\n      break;\n    case \"WezTerm\":\n      B = await installWezTermShiftEnterKeyBinding(getTerminalOutput);\n      break;\n    case null:\n      break;\n  }\n  let Q = L1();\n  if ([\"iTerm.app\", \"vscode\", \"cursor\", \"windsurf\", \"ghostty\", \"WezTerm\"].includes(O0.terminal ?? \"\")) {\n    Q.shiftEnterKeyBindingInstalled = true;\n  } else if (O0.terminal === \"Apple_Terminal\") {\n    Q.optionAsMetaKeyInstalled = true;\n  }\n  n0(Q);\n  P0A();\n  return B;\n}\nfunction isShiftEnterKeyBindingInstalled() {\n  return L1().shiftEnterKeyBindingInstalled === true;\n}\nfunction isMetaKeyOptionInstalled() {\n  return L1().optionAsMetaKeyInstalled === true;\n}\nfunction checkIfBackslashReturnUsed() {\n  return L1().hasUsedBackslashReturn === true;\n}\nfunction handleReturnKey() {\n  let _responseData = L1();\n  if (!_responseData.hasUsedBackslashReturn) {\n    n0({\n      ..._responseData,\n      hasUsedBackslashReturn: true\n    });\n  }\n}\nasync function installWezTermShiftEnterKeyBinding(installWezTermShiftEnterBinding) {\n  let wezTermConfigFilePath = outputImageFormatHandler(getFolderPath(), \".wezterm.lua\");\n  try {\n    let existingConfigContent = \"\";\n    let isExistingKeyBinding = false;\n    if (NA().existsSync(wezTermConfigFilePath)) {\n      isExistingKeyBinding = true;\n      existingConfigContent = NA().readFileSync(wezTermConfigFilePath, {\n        encoding: \"utf-8\"\n      });\n      if (existingConfigContent.includes(\"mods=\\\"SHIFT\\\"\") && existingConfigContent.includes(\"key=\\\"Enter\\\"\")) {\n        return `${OB(\"warning\", installWezTermShiftEnterBinding)(\"Found existing WezTerm Shift+Enter key binding. Remove it to continue.\")}${LineSeparator}${iA.dim(`See ${wezTermConfigFilePath}`)}${LineSeparator}`;\n      }\n      let backupFileName = generateRandomBytes(4).toString(\"hex\");\n      let _backupFileName = `${wezTermConfigFilePath}.${backupFileName}.bak`;\n      try {\n        NA().copyFileSync(wezTermConfigFilePath, _backupFileName);\n      } catch (___error) {\n        BA(___error instanceof Error ? ___error : Error(String(___error)), $G0);\n        return `${OB(\"warning\", installWezTermShiftEnterBinding)(\"Error backing up existing WezTerm config. Bailing out.\")}${LineSeparator}${iA.dim(`See ${wezTermConfigFilePath}`)}${LineSeparator}${iA.dim(`Backup path: ${_backupFileName}`)}${LineSeparator}`;\n      }\n    }\n    if (!isExistingKeyBinding) {\n      existingConfigContent = `local wezterm = require 'wezterm'\nlocal config = wezterm.config_builder()\n\nconfig.keys = {\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n}\n\nreturn config\n`;\n    } else {\n      let temporaryBackupIdentifier = existingConfigContent.match(/config\\.keys\\s*=\\s*\\{([^}]*)\\}/s);\n      if (temporaryBackupIdentifier) {\n        let backupFilePath = temporaryBackupIdentifier[1] ?? \"\";\n        let keyBindingUpdateString = backupFilePath.trim() ? `${backupFilePath.trim()},\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},` : `\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n`;\n        existingConfigContent = existingConfigContent.replace(/config\\.keys\\s*=\\s*\\{[^}]*\\}/s, `config.keys = {${keyBindingUpdateString}}`);\n      } else if (existingConfigContent.match(/return\\s+config/s)) {\n        existingConfigContent = existingConfigContent.replace(/return\\s+config/s, `config.keys = {\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n}\n\nreturn config`);\n      } else {\n        existingConfigContent += `\nconfig.keys = {\n  {key=\"Enter\", mods=\"SHIFT\", action=wezterm.action{SendString=\"\\\\x1b\\\\r\"}},\n}\n`;\n      }\n    }\n    NA().writeFileSync(wezTermConfigFilePath, existingConfigContent, {\n      encoding: \"utf-8\",\n      flush: false\n    });\n    return `${OB(\"success\", installWezTermShiftEnterBinding)(\"Installed WezTerm Shift+Enter key binding\")}${LineSeparator}${OB(\"success\", installWezTermShiftEnterBinding)(\"You may need to restart WezTerm for changes to take effect\")}${LineSeparator}${iA.dim(`See ${wezTermConfigFilePath}`)}${LineSeparator}`;\n  } catch (I) {\n    BA(I instanceof Error ? I : Error(String(I)), qG0);\n    throw Error(\"Failed to install WezTerm Shift+Enter key binding\");\n  }\n}\nasync function installGhosttyShiftEnterKeyBindingHandler(installGhosttyShiftEnterKeyBinding) {\n  let configPaths = [];\n  let xdgConfigHome = process.env.XDG_CONFIG_HOME;\n  if (xdgConfigHome) {\n    configPaths.push(outputImageFormatHandler(xdgConfigHome, \"ghostty\", \"config\"));\n  } else {\n    configPaths.push(outputImageFormatHandler(getFolderPath(), \".config\", \"ghostty\", \"config\"));\n  }\n  if (processImageTransformations() === \"darwin\") {\n    configPaths.push(outputImageFormatHandler(getFolderPath(), \"Library\", \"Application Support\", \"com.mitchellh.ghostty\", \"config\"));\n  }\n  let configPath = null;\n  let isConfigFileFound = false;\n  for (let Y of configPaths) {\n    if (NA().existsSync(Y)) {\n      configPath = Y;\n      isConfigFileFound = true;\n      break;\n    }\n  }\n  if (!configPath) {\n    configPath = configPaths[0] ?? null;\n    isConfigFileFound = false;\n  }\n  if (!configPath) {\n    throw Error(\"No valid config path found for Ghostty\");\n  }\n  try {\n    let _configFilePath = \"\";\n    if (isConfigFileFound) {\n      _configFilePath = NA().readFileSync(configPath, {\n        encoding: \"utf-8\"\n      });\n      if (_configFilePath.includes(\"shift+enter\")) {\n        return `${OB(\"warning\", installGhosttyShiftEnterKeyBinding)(\"Found existing Ghostty Shift+Enter key binding. Remove it to continue.\")}${LineSeparator}${iA.dim(`See ${configPath}`)}${LineSeparator}`;\n      }\n      let installGhosttyShiftEnterBinding = generateRandomBytes(4).toString(\"hex\");\n      let backupConfigFilePath = `${configPath}.${installGhosttyShiftEnterBinding}.bak`;\n      try {\n        NA().copyFileSync(configPath, backupConfigFilePath);\n      } catch {\n        return `${OB(\"warning\", installGhosttyShiftEnterKeyBinding)(\"Error backing up existing Ghostty config. Bailing out.\")}${LineSeparator}${iA.dim(`See ${configPath}`)}${LineSeparator}${iA.dim(`Backup path: ${backupConfigFilePath}`)}${LineSeparator}`;\n      }\n    } else {\n      let setupGhosttyConfiguration = imageProcessor(configPath);\n      if (!NA().existsSync(setupGhosttyConfiguration)) {\n        NA().mkdirSync(setupGhosttyConfiguration);\n      }\n    }\n    let configContent = _configFilePath;\n    if (_configFilePath && !_configFilePath.endsWith(`\n`)) {\n      configContent += `\n`;\n    }\n    configContent += `keybind = shift+enter=text:\\\\x1b\\\\r\n`;\n    NA().writeFileSync(configPath, configContent, {\n      encoding: \"utf-8\",\n      flush: false\n    });\n    return `${OB(\"success\", installGhosttyShiftEnterKeyBinding)(\"Installed Ghostty Shift+Enter key binding\")}${LineSeparator}${OB(\"success\", installGhosttyShiftEnterKeyBinding)(\"You may need to restart Ghostty for changes to take effect\")}${LineSeparator}${iA.dim(`See ${configPath}`)}${LineSeparator}`;\n  } catch (Y) {\n    BA(Y instanceof Error ? Y : Error(String(Y)), NG0);\n    throw Error(\"Failed to install Ghostty Shift+Enter key binding\");\n  }\n}\nasync function Mn9(installITerm2ShiftEnterKeyBinding) {\n  let B = getImageProcessingErrorMessages();\n  try {\n    if (!(await exportIterm2Settings())) {\n      throw Error(\"Failed to create backup of iTerm2 preferences, bailing out\");\n    }\n    let {\n      code: I\n    } = await r0(\"defaults\", [\"write\", \"com.googlecode.iterm2\", \"GlobalKeyMap\", \"-dict-add\", \"0xd-0x20000-0x24\", `<dict>\n        <key>Text</key>\n        <string>\\\\n</string>\n        <key>Action</key>\n        <integer>12</integer>\n        <key>Version</key>\n        <integer>1</integer>\n        <key>Keycode</key>\n        <integer>13</integer>\n        <key>Modifiers</key>\n        <integer>131072</integer>\n      </dict>`]);\n    if (I !== 0) {\n      throw Error(\"Failed to install iTerm2 Shift+Enter key binding\");\n    }\n    await r0(\"defaults\", [\"export\", \"com.googlecode.iterm2\", B]);\n    setupInProgressAndNotify();\n    return `${OB(\"success\", installITerm2ShiftEnterKeyBinding)(\"Installed iTerm2 Shift+Enter key binding\")}${LineSeparator}${iA.dim(\"See iTerm2  Preferences  Keys\")}${LineSeparator}`;\n  } catch (Q) {\n    BA(Q instanceof Error ? Q : Error(String(Q)), LG0);\n    let I = L1().iterm2BackupPath;\n    let G = false;\n    if (I && NA().existsSync(I)) {\n      try {\n        await r0(\"defaults\", [\"import\", \"com.googlecode.iterm2\", I]);\n        G = true;\n        setupInProgressAndNotify();\n      } catch (________error) {\n        BA(Error(`Failed to restore from backup: ${String(________error)}`), MG0);\n      }\n    }\n    throw Error(`Failed to install iTerm2 Shift+Enter key binding. ${G ? \"Your settings have been restored from backup.\" : I && NA().existsSync(I) ? `Restoring from backup failed, try manually with: defaults import com.googlecode.iterm2 ${I}` : \"No backup was available to restore from.\"}`);\n  }\n}\nfunction installTerminalShiftEnterKeyBinding(_installTerminalShiftEnterKeyBinding = \"VSCode\", userCallback) {\n  let applicationName = _installTerminalShiftEnterKeyBinding === \"VSCode\" ? \"Code\" : _installTerminalShiftEnterKeyBinding;\n  let outputPath = outputImageFormatHandler(getFolderPath(), processImageTransformations() === \"win32\" ? outputImageFormatHandler(\"AppData\", \"Roaming\", applicationName, \"User\") : processImageTransformations() === \"darwin\" ? outputImageFormatHandler(\"Library\", \"Application Support\", applicationName, \"User\") : outputImageFormatHandler(\".config\", applicationName, \"User\"));\n  let keybindingsJsonPath = outputImageFormatHandler(outputPath, \"keybindings.json\");\n  try {\n    let jsonContent = \"[]\";\n    let existingKeyBindings = [];\n    if (!NA().existsSync(outputPath)) {\n      NA().mkdirSync(outputPath);\n    }\n    if (NA().existsSync(keybindingsJsonPath)) {\n      jsonContent = NA().readFileSync(keybindingsJsonPath, {\n        encoding: \"utf-8\"\n      });\n      existingKeyBindings = XR0(jsonContent) ?? [];\n      let existingBindingCheck = generateRandomBytes(4).toString(\"hex\");\n      let _backupFilePath = `${keybindingsJsonPath}.${existingBindingCheck}.bak`;\n      try {\n        NA().copyFileSync(keybindingsJsonPath, _backupFilePath);\n      } catch {\n        return `${OB(\"warning\", userCallback)(`Error backing up existing ${_installTerminalShiftEnterKeyBinding} terminal keybindings. Bailing out.`)}${LineSeparator}${iA.dim(`See ${keybindingsJsonPath}`)}${LineSeparator}${iA.dim(`Backup path: ${_backupFilePath}`)}${LineSeparator}`;\n      }\n    }\n    if (existingKeyBindings.find(isShiftEnterCommandInTerminalFocus => isShiftEnterCommandInTerminalFocus.key === \"shift+enter\" && isShiftEnterCommandInTerminalFocus.command === \"workbench.action.terminal.sendSequence\" && isShiftEnterCommandInTerminalFocus.when === \"terminalFocus\")) {\n      return `${OB(\"warning\", userCallback)(`Found existing ${_installTerminalShiftEnterKeyBinding} terminal Shift+Enter key binding. Remove it to continue.`)}${LineSeparator}${iA.dim(`See ${keybindingsJsonPath}`)}${LineSeparator}`;\n    }\n    let newKeyBindingConfig = WR0(jsonContent, {\n      key: \"shift+enter\",\n      command: \"workbench.action.terminal.sendSequence\",\n      args: {\n        text: \"\u001b\\r\"\n      },\n      when: \"terminalFocus\"\n    });\n    NA().writeFileSync(keybindingsJsonPath, newKeyBindingConfig, {\n      encoding: \"utf-8\",\n      flush: false\n    });\n    return `${OB(\"success\", userCallback)(`Installed ${_installTerminalShiftEnterKeyBinding} terminal Shift+Enter key binding`)}${LineSeparator}${iA.dim(`See ${keybindingsJsonPath}`)}${LineSeparator}`;\n  } catch (Z) {\n    BA(Z instanceof Error ? Z : Error(String(Z)), OG0);\n    throw Error(`Failed to install ${_installTerminalShiftEnterKeyBinding} terminal Shift+Enter key binding`);\n  }\n}\nasync function setOptionAsMetaKey(terminalProfileName) {\n  let {\n    code: B\n  } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Add :'Window Settings':'${terminalProfileName}':useOptionAsMetaKey bool true`, getTerminalPreferencesPath()]);\n  if (B !== 0) {\n    let {\n      code: Q\n    } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Set :'Window Settings':'${terminalProfileName}':useOptionAsMetaKey true`, getTerminalPreferencesPath()]);\n    if (Q !== 0) {\n      BA(Error(`Failed to enable Option as Meta key for Terminal.app profile: ${terminalProfileName}`), RG0);\n      return false;\n    }\n  }\n  return true;\n}\nasync function disableTerminalAudioBell(profileName) {\n  let {\n    code: B\n  } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Add :'Window Settings':'${profileName}':Bell bool false`, getTerminalPreferencesPath()]);\n  if (B !== 0) {\n    let {\n      code: Q\n    } = await r0(\"/usr/libexec/PlistBuddy\", [\"-c\", `Set :'Window Settings':'${profileName}':Bell false`, getTerminalPreferencesPath()]);\n    if (Q !== 0) {\n      BA(Error(`Failed to disable audio bell for Terminal.app profile: ${profileName}`), TG0);\n      return false;\n    }\n  }\n  return true;\n}\nasync function On9(configureTerminalAppSettings) {\n  try {\n    if (!(await exportTerminalPreferences())) {\n      throw Error(\"Failed to create backup of Terminal.app preferences, bailing out\");\n    }\n    let {\n      stdout: Q,\n      code: I\n    } = await r0(\"defaults\", [\"read\", \"com.apple.Terminal\", \"Default Window Settings\"]);\n    if (I !== 0 || !Q.trim()) {\n      throw Error(\"Failed to read default Terminal.app profile\");\n    }\n    let {\n      stdout: G,\n      code: Z\n    } = await r0(\"defaults\", [\"read\", \"com.apple.Terminal\", \"Startup Window Settings\"]);\n    if (Z !== 0 || !G.trim()) {\n      throw Error(\"Failed to read startup Terminal.app profile\");\n    }\n    let Y = false;\n    let J = Q.trim();\n    let X = await setOptionAsMetaKey(J);\n    let W = await disableTerminalAudioBell(J);\n    if (X || W) {\n      Y = true;\n    }\n    let F = G.trim();\n    if (F !== J) {\n      let isProfileConfigured = await setOptionAsMetaKey(F);\n      let isOptionAsMetaEnabled = await disableTerminalAudioBell(F);\n      if (isProfileConfigured || isOptionAsMetaEnabled) {\n        Y = true;\n      }\n    }\n    if (!Y) {\n      throw Error(\"Failed to enable Option as Meta key or disable audio bell for any Terminal.app profile\");\n    }\n    await r0(\"killall\", [\"cfprefsd\"]);\n    _initializeAppleTerminalSetup();\n    return `${OB(\"success\", configureTerminalAppSettings)(\"Configured Terminal.app settings:\")}${LineSeparator}${OB(\"success\", configureTerminalAppSettings)(\"- Enabled \\\"Use Option as Meta key\\\"\")}${LineSeparator}${OB(\"success\", configureTerminalAppSettings)(\"- Switched to visual bell\")}${LineSeparator}${iA.dim(\"Option+Enter will now enter a newline.\")}${LineSeparator}${iA.dim(\"You must restart Terminal.app for changes to take effect.\", configureTerminalAppSettings)}${LineSeparator}`;\n  } catch (B) {\n    BA(B instanceof Error ? B : Error(String(B)), PG0);\n    let Q = await restoreAppleTerminalSettings();\n    let I = \"Failed to enable Option as Meta key for Terminal.app.\";\n    if (Q.status === \"restored\") {\n      throw Error(`${I} Your settings have been restored from backup.`);\n    } else if (Q.status === \"failed\") {\n      throw Error(`${I} Restoring from backup failed, try manually with: defaults import com.apple.Terminal ${Q.backupPath}`);\n    } else {\n      throw Error(`${I} No backup was available to restore from.`);\n    }\n  }\n}\nvar validateOutputFilePath;\nvar character;\nvar y0A = T(() => {\n  f2();\n  NJA();\n  initializeShapelessPipeline();\n  kB();\n  C6();\n  Q5();\n  m0();\n  initializeCustomSettings();\n  wC();\n  c1();\n  nA();\n  E5();\n  validateOutputFilePath = {\n    type: \"local-jsx\",\n    name: \"terminal-setup\",\n    userFacingName() {\n      return \"terminal-setup\";\n    },\n    description: O0.terminal === \"Apple_Terminal\" ? \"Enable Option+Enter key binding for newlines and visual bell\" : \"Install Shift+Enter key binding for newlines\",\n    isEnabled: () => true,\n    isHidden: false,\n    async call(handleTerminalSetup, __callbackFunction) {\n      if (!isEnvironmentSupportedForImageTransformations()) {\n        let currentTerminal = O0.terminal || \"your current terminal\";\n        let getOperatingSystem = EB();\n        let supportedTerminalsInfo = \"\";\n        if (getOperatingSystem === \"macos\") {\n          supportedTerminalsInfo = `    macOS: iTerm2, Apple Terminal\n`;\n        } else if (getOperatingSystem === \"windows\") {\n          supportedTerminalsInfo = `    Windows: Windows Terminal\n`;\n        }\n        let terminalSetupErrorMessage = `Terminal setup cannot be run from ${currentTerminal}.\n\nThis command configures a convenient Shift+Enter shortcut for multi-line prompts.\n${iA.dim(\"Note: You can already use backslash (\\\\) + return to add newlines.\")}\n\nTo set up the shortcut (optional):\n1. Exit tmux/screen temporarily\n2. Run /terminal-setup directly in one of these terminals:\n${supportedTerminalsInfo}    IDE: VSCode, Cursor, Windsurf\n    Other: Ghostty, WezTerm\n3. Return to tmux/screen - settings will persist`;\n        handleTerminalSetup(terminalSetupErrorMessage);\n        return null;\n      }\n      let fetchTheme = await kJ1(__callbackFunction.options.theme);\n      handleTerminalSetup(fetchTheme);\n      return null;\n    }\n  };\n  character = validateOutputFilePath;\n});\nimport { join as processImageInput } from \"path\";\nfunction countNewlines(countLineBreaks) {\n  return (countLineBreaks.match(/\\r\\n|\\r|\\n/g) || []).length;\n}\nfunction formatPastedText(pastedTextFormatter, linesOffset) {\n  if (linesOffset === 0) {\n    return `[Pasted text #${pastedTextFormatter}]`;\n  }\n  return `[Pasted text #${pastedTextFormatter} +${linesOffset} lines]`;\n}\nfunction generateImageTag(imageIndex) {\n  return `[Image #${imageIndex}]`;\n}\nfunction extractReferencesFromText(extractTextMatches) {\n  let referencePattern = /\\[(Pasted text|Image|\\.\\.\\.Truncated text) #(\\d+)(?: \\+\\d+ lines)?(\\.)*\\]/g;\n  return [...extractTextMatches.matchAll(referencePattern)].map(_inputArray => ({\n    id: parseInt(_inputArray[2] || \"0\"),\n    match: _inputArray[0]\n  })).filter(isValidId => isValidId.id > 0);\n}\nfunction parseJsonString(jsonString) {\n  return JSON.parse(jsonString);\n}\nasync function* streamExifData() {\n  for (let Q = setExifData.length - 1; Q >= 0; Q--) {\n    yield setExifData[Q];\n  }\n  let A = processImageInput(mB(), \"history.jsonl\");\n  if (!NA().existsSync(A)) {\n    return;\n  }\n  for await (let Q of C90(A)) {\n    try {\n      yield parseJsonString(Q);\n    } catch (___________error) {\n      g(`Failed to parse history line: ${___________error}`);\n    }\n  }\n}\nasync function* xJ1() {\n  let A = GQ();\n  let imageCount = 0;\n  for await (let Q of streamExifData()) {\n    if (Q.project === A) {\n      yield Q;\n      imageCount++;\n      if (imageCount >= _imageProcessingPipeline) {\n        break;\n      }\n    }\n  }\n}\nasync function tx0(processImageTransaction) {\n  if (transformImageFormats || setExifData.length === 0) {\n    return;\n  }\n  if (processImageTransaction > 5) {\n    return;\n  }\n  transformImageFormats = true;\n  let B;\n  try {\n    let Q = processImageInput(mB(), \"history.jsonl\");\n    let I = NA();\n    if (!I.existsSync(Q)) {\n      I.writeFileSync(Q, \"\", {\n        encoding: \"utf8\",\n        flush: true,\n        mode: 384\n      });\n    }\n    B = await processImage.lock(Q, {\n      stale: 10000,\n      retries: {\n        retries: 3,\n        minTimeout: 50\n      }\n    });\n    let G = setExifData.map(jsonStringRepresentation => `${JSON.stringify(jsonStringRepresentation)}\n`);\n    setExifData = [];\n    I.appendFileSync(Q, G.join(\"\"), {\n      mode: 384\n    });\n  } catch (Q) {\n    g(`Failed to write prompt history: ${Q}`);\n  } finally {\n    transformImageFormats = false;\n    if (B) {\n      await B();\n    }\n    await new Promise(retryTimeout => setTimeout(retryTimeout, 1000));\n    if (setExifData.length > 0) {\n      tx0(processImageTransaction + 1);\n    }\n  }\n}\nasync function jn9(processInput) {\n  let B = typeof processInput === \"string\" ? {\n    display: processInput,\n    pastedContents: {}\n  } : processInput;\n  let Q = {};\n  if (B.pastedContents) {\n    for (let [contentIndex, pastedContent] of Object.entries(B.pastedContents)) {\n      if (pastedContent.type !== \"image\" && pastedContent.content.length <= _processImage) {\n        Q[Number(contentIndex)] = pastedContent;\n      }\n    }\n  }\n  let I = {\n    ...B,\n    pastedContents: Q,\n    timestamp: Date.now(),\n    project: GQ(),\n    sessionId: L0()\n  };\n  setExifData.push(I);\n  tx0(0);\n}\nfunction gk(_______inputData) {\n  jn9(_______inputData);\n}\nvar processImage;\nvar _imageProcessingPipeline = 100;\nvar _processImage = 1024;\nvar setExifData;\nvar transformImageFormats = false;\nvar imageProcessingHandler = T(() => {\n  vB();\n  m0();\n  i0();\n  C0();\n  processImage = IA(xYA(), 1);\n  setExifData = [];\n});\nvar _imageProcessor = z((getVersionFromData, getVersionFromQuery) => {\n  var _getVersionFromData = qi();\n  var fetchVersionFromData = (A, B) => {\n    let Q = _getVersionFromData(A, B);\n    if (Q) {\n      return Q.version;\n    } else {\n      return null;\n    }\n  };\n  getVersionFromQuery.exports = fetchVersionFromData;\n});\nvar ImageProcessingPipeline = z((getVersionFromInput, getVersion) => {\n  var _getVersion = qi();\n  var extractVersion = (A, B) => {\n    let Q = _getVersion(A.trim().replace(/^[=v]+/, \"\"), B);\n    if (Q) {\n      return Q.version;\n    } else {\n      return null;\n    }\n  };\n  getVersion.exports = extractVersion;\n});\nvar processorFunction = z((incrementVersion, exportVersionIncrementer) => {\n  var VersionManager = oV();\n  var __incrementVersion = (A, B, Q, I, G) => {\n    if (typeof Q === \"string\") {\n      G = I;\n      I = Q;\n      Q = undefined;\n    }\n    try {\n      return new VersionManager(A instanceof VersionManager ? A.version : A, Q).inc(B, I, G).version;\n    } catch (Z) {\n      return null;\n    }\n  };\n  exportVersionIncrementer.exports = __incrementVersion;\n});\nvar __imageProcessingPipeline = z((compareVersionPragmatics, versionComparisonFunction) => {\n  var _createVersionComparisonFunction = qi();\n  var _____compareVersions = (compareVersionDifferences, ______compareVersions) => {\n    let createVersionComparisonFunctionA = _createVersionComparisonFunction(compareVersionDifferences, null, true);\n    let versionComparisonFunctionB = _createVersionComparisonFunction(______compareVersions, null, true);\n    let comparisonResult = createVersionComparisonFunctionA.compare(versionComparisonFunctionB);\n    if (comparisonResult === 0) {\n      return null;\n    }\n    let isFirstVersionGreater = comparisonResult > 0;\n    let selectedVersionComparisonFunction = isFirstVersionGreater ? createVersionComparisonFunctionA : versionComparisonFunctionB;\n    let previousVersionComparator = isFirstVersionGreater ? versionComparisonFunctionB : createVersionComparisonFunctionA;\n    let isPrereleaseVersion = !!selectedVersionComparisonFunction.prerelease.length;\n    if (!!previousVersionComparator.prerelease.length && !isPrereleaseVersion) {\n      if (!previousVersionComparator.patch && !previousVersionComparator.minor) {\n        return \"major\";\n      }\n      if (previousVersionComparator.compareMain(selectedVersionComparisonFunction) === 0) {\n        if (previousVersionComparator.minor && !previousVersionComparator.patch) {\n          return \"minor\";\n        }\n        return \"patch\";\n      }\n    }\n    let prereleasePrefix = isPrereleaseVersion ? \"pre\" : \"\";\n    if (createVersionComparisonFunctionA.major !== versionComparisonFunctionB.major) {\n      return prereleasePrefix + \"major\";\n    }\n    if (createVersionComparisonFunctionA.minor !== versionComparisonFunctionB.minor) {\n      return prereleasePrefix + \"minor\";\n    }\n    if (createVersionComparisonFunctionA.patch !== versionComparisonFunctionB.patch) {\n      return prereleasePrefix + \"patch\";\n    }\n    return \"prerelease\";\n  };\n  versionComparisonFunction.exports = _____compareVersions;\n});\nvar __processImage = z((createMajorInstance, createMajorFromInputs) => {\n  var _createMajorInstance = oV();\n  var createMajorFromArgs = (A, B) => new _createMajorInstance(A, B).major;\n  createMajorFromInputs.exports = createMajorFromArgs;\n});\nvar ___imageProcessingPipeline = z((createMinorMatrix, createMinorFunction) => {\n  var createMinorInstance = oV();\n  var _createMinorMatrix = (A, B) => new createMinorInstance(A, B).minor;\n  createMinorFunction.exports = _createMinorMatrix;\n});\nvar updateImageOutputOptions = z((createPatchFunction, _createPatchFunction) => {\n  var createPatchInstance = oV();\n  var createPatch = (A, B) => new createPatchInstance(A, B).patch;\n  _createPatchFunction.exports = createPatch;\n});\nvar handleImageFormatConversion = z((getPrereleaseParts, getPrereleaseVersions) => {\n  var _getPrereleaseVersions = qi();\n  var extractPrereleaseTags = (A, B) => {\n    let Q = _getPrereleaseVersions(A, B);\n    if (Q && Q.prerelease.length) {\n      return Q.prerelease;\n    } else {\n      return null;\n    }\n  };\n  getPrereleaseVersions.exports = extractPrereleaseTags;\n});\nvar imageConversionPipeline = z((requestFunction, exportFunction) => {\n  var createCustomFunction = d$();\n  var createAndExportCustomFunction = (A, B, Q) => createCustomFunction(B, A, Q);\n  exportFunction.exports = createAndExportCustomFunction;\n});\nvar ____imageProcessingPipeline = z((createIn9Function, exportedFunction) => {\n  var createAndExportFunctionWithParams = d$();\n  var createAndExportFunctionWithParamsAndFlag = (A, B) => createAndExportFunctionWithParams(A, B, true);\n  exportedFunction.exports = createAndExportFunctionWithParamsAndFlag;\n});\nvar updateImageFormatSettings = z((compareInstances, _compareInstances) => {\n  var ObjectComparator = oV();\n  var compareObjectInstances = (A, B, Q) => {\n    let I = new ObjectComparator(A, Q);\n    let G = new ObjectComparator(B, Q);\n    return I.compare(G) || I.compareBuild(G);\n  };\n  _compareInstances.exports = compareObjectInstances;\n});\nvar ___processImageTransformations = z((sortImageSettingsByFormat, sortImagesByFormat) => {\n  var compareImageFormats = updateImageFormatSettings();\n  var rn9 = (A, B) => A.sort((Q, I) => compareImageFormats(Q, I, B));\n  sortImagesByFormat.exports = rn9;\n});\nvar ______________________________________processImageTransformation = z((_sortImagesByFormat, __sortImagesByFormat) => {\n  var updateAndSortImagesByFormat = updateImageFormatSettings();\n  var tn9 = (A, B) => A.sort((Q, I) => updateAndSortImagesByFormat(I, Q, B));\n  __sortImagesByFormat.exports = tn9;\n});\nvar _____imageProcessingPipeline = z((createAndMapValues, createAndExportArrayMapper) => {\n  var _createAndMapValues = c$();\n  var mapValuesToArray = (A, B) => new _createAndMapValues(A, B).set.map(Q => Q.map(____inputValue => ____inputValue.value).join(\" \").trim().split(\" \"));\n  createAndExportArrayMapper.exports = mapValuesToArray;\n});\nvar _imageProcessingHandler = z((findBestMatch, exportHighestPriorityMatch) => {\n  var findMatchingElement = oV();\n  var createTestInstance = c$();\n  var findBestMatchingElement = (_findBestMatchingElement, testInstanceConstructor, testCriteria) => {\n    let currentBestMatch = null;\n    let elementMatcher = null;\n    let testInstance = null;\n    try {\n      testInstance = new createTestInstance(testInstanceConstructor, testCriteria);\n    } catch (Y) {\n      return null;\n    }\n    _findBestMatchingElement.forEach(Y => {\n      if (testInstance.test(Y)) {\n        if (!currentBestMatch || elementMatcher.compare(Y) === -1) {\n          currentBestMatch = Y;\n          elementMatcher = new findMatchingElement(currentBestMatch, testCriteria);\n        }\n      }\n    });\n    return currentBestMatch;\n  };\n  exportHighestPriorityMatch.exports = findBestMatchingElement;\n});\nvar enhancedImageProcessingPipeline = z((_findBestMatch, findBestMatchingValue) => {\n  var createComparisonObject = oV();\n  var createTestObject = c$();\n  var findBestMatchForInputs = (__findBestMatch, testParameters, _testCriteria) => {\n    let _currentBestMatch = null;\n    let comparisonObject = null;\n    let testObject = null;\n    try {\n      testObject = new createTestObject(testParameters, _testCriteria);\n    } catch (Y) {\n      return null;\n    }\n    __findBestMatch.forEach(Y => {\n      if (testObject.test(Y)) {\n        if (!_currentBestMatch || comparisonObject.compare(Y) === 1) {\n          _currentBestMatch = Y;\n          comparisonObject = new createComparisonObject(_currentBestMatch, _testCriteria);\n        }\n      }\n    });\n    return _currentBestMatch;\n  };\n  findBestMatchingValue.exports = findBestMatchForInputs;\n});\nvar convertImageFormat = z((validateVersion, validateSemver) => {\n  var SemverValidator = oV();\n  var _validateSemverRange = c$();\n  var ___compareVersions = VJA();\n  var findHighestValidSemver = (validateAndFindHighestValidVersion, semverRangeValidator) => {\n    validateAndFindHighestValidVersion = new _validateSemverRange(validateAndFindHighestValidVersion, semverRangeValidator);\n    let highestValidVersion = new SemverValidator(\"0.0.0\");\n    if (validateAndFindHighestValidVersion.test(highestValidVersion)) {\n      return highestValidVersion;\n    }\n    highestValidVersion = new SemverValidator(\"0.0.0-0\");\n    if (validateAndFindHighestValidVersion.test(highestValidVersion)) {\n      return highestValidVersion;\n    }\n    highestValidVersion = null;\n    for (let currentSetIndex = 0; currentSetIndex < validateAndFindHighestValidVersion.set.length; ++currentSetIndex) {\n      let currentVersionSet = validateAndFindHighestValidVersion.set[currentSetIndex];\n      let highestSemverValidator = null;\n      currentVersionSet.forEach(semverValidationOperation => {\n        let semverValidator = new SemverValidator(semverValidationOperation.semver.version);\n        switch (semverValidationOperation.operator) {\n          case \">\":\n            if (semverValidator.prerelease.length === 0) {\n              semverValidator.patch++;\n            } else {\n              semverValidator.prerelease.push(0);\n            }\n            semverValidator.raw = semverValidator.format();\n          case \"\":\n          case \">=\":\n            if (!highestSemverValidator || ___compareVersions(semverValidator, highestSemverValidator)) {\n              highestSemverValidator = semverValidator;\n            }\n            break;\n          case \"<\":\n          case \"<=\":\n            break;\n          default:\n            throw Error(`Unexpected operation: ${semverValidationOperation.operator}`);\n        }\n      });\n      if (highestSemverValidator && (!highestValidVersion || ___compareVersions(highestValidVersion, highestSemverValidator))) {\n        highestValidVersion = highestSemverValidator;\n      }\n    }\n    if (highestValidVersion && validateAndFindHighestValidVersion.test(highestValidVersion)) {\n      return highestValidVersion;\n    }\n    return null;\n  };\n  validateSemver.exports = findHighestValidSemver;\n});\nvar processImagePipeline = z((createRangeWithFallback, createRangeFunction) => {\n  var createRangeInstance = c$();\n  var _createRangeWithFallback = (A, B) => {\n    try {\n      return new createRangeInstance(A, B).range || \"*\";\n    } catch (Q) {\n      return null;\n    }\n  };\n  createRangeFunction.exports = _createRangeWithFallback;\n});\nvar initializeSharpImageProcessing = z((validateVersionConstraints, validateSemverRange) => {\n  var __compareVersions = oV();\n  var createVersionComparisonFunction = DJA();\n  var {\n    ANY: ANY_VERSION_COMPARISON\n  } = createVersionComparisonFunction;\n  var VersionRangeValidator = c$();\n  var evaluateSemverConstraints = q0A();\n  var comparisonOperatorHandler = VJA();\n  var evaluateVersionConstraints = ePA();\n  var _validateVersionConstraints = AjA();\n  var validateVersionRange = CJA();\n  var validateVersionComparison = (A, B, Q, I) => {\n    A = new __compareVersions(A, I);\n    B = new VersionRangeValidator(B, I);\n    let G;\n    let Z;\n    let Y;\n    let J;\n    let X;\n    switch (Q) {\n      case \">\":\n        G = comparisonOperatorHandler;\n        Z = _validateVersionConstraints;\n        Y = evaluateVersionConstraints;\n        J = \">\";\n        X = \">=\";\n        break;\n      case \"<\":\n        G = evaluateVersionConstraints;\n        Z = validateVersionRange;\n        Y = comparisonOperatorHandler;\n        J = \"<\";\n        X = \"<=\";\n        break;\n      default:\n        throw TypeError(\"Must provide a hilo val of \\\"<\\\" or \\\">\\\"\");\n    }\n    if (evaluateSemverConstraints(A, B, I)) {\n      return false;\n    }\n    for (let W = 0; W < B.set.length; ++W) {\n      let currentVersion = B.set[W];\n      let currentVersionCandidate = null;\n      let latestVersion = null;\n      currentVersion.forEach(versionInfo => {\n        if (versionInfo.semver === ANY_VERSION_COMPARISON) {\n          versionInfo = new createVersionComparisonFunction(\">=0.0.0\");\n        }\n        currentVersionCandidate = currentVersionCandidate || versionInfo;\n        latestVersion = latestVersion || versionInfo;\n        if (G(versionInfo.semver, currentVersionCandidate.semver, I)) {\n          currentVersionCandidate = versionInfo;\n        } else if (Y(versionInfo.semver, latestVersion.semver, I)) {\n          latestVersion = versionInfo;\n        }\n      });\n      if (currentVersionCandidate.operator === J || currentVersionCandidate.operator === X) {\n        return false;\n      }\n      if ((!latestVersion.operator || latestVersion.operator === J) && Z(A, latestVersion.semver)) {\n        return false;\n      } else if (latestVersion.operator === X && Y(A, latestVersion.semver)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  validateSemverRange.exports = validateVersionComparison;\n});\nvar imageTransformProcessor = z((sharpImageProcessingFilter, exportSharpImageProcessing) => {\n  var sharpImageProcessingFilterHandler = initializeSharpImageProcessing();\n  var wa9 = (A, B, Q) => sharpImageProcessingFilterHandler(A, B, \">\", Q);\n  exportSharpImageProcessing.exports = wa9;\n});\nvar __________imageTransformationProcessor = z((sharpImageProcessingHandler, _sharpImageProcessing) => {\n  var initializeSharpImageProcessor = initializeSharpImageProcessing();\n  var qa9 = (A, B, Q) => initializeSharpImageProcessor(A, B, \"<\", Q);\n  _sharpImageProcessing.exports = qa9;\n});\nvar ______imageProcessingPipeline = z((checkIntersects, checkIntersection) => {\n  var IntersectionChecker = c$();\n  var _checkIntersection = (A, B, Q) => {\n    A = new IntersectionChecker(A, Q);\n    B = new IntersectionChecker(B, Q);\n    return A.intersects(B, Q);\n  };\n  checkIntersection.exports = _checkIntersection;\n});\nvar outputFilePath = z((createConditionalRanges, createExportedSortingFunction) => {\n  var isConditionMet = q0A();\n  var generateRangePairs = d$();\n  createExportedSortingFunction.exports = (generateRangeString, generateFilterOutput, findRangesBasedOnCriteria) => {\n    let resultsArray = [];\n    let currentGroup = null;\n    let currentElement = null;\n    let sortedArray = generateRangeString.sort((findAndGenerateRangePairs, criteriaBasedRangeGenerator) => generateRangePairs(findAndGenerateRangePairs, criteriaBasedRangeGenerator, findRangesBasedOnCriteria));\n    for (let currentSortedElement of sortedArray) {\n      if (isConditionMet(currentSortedElement, generateFilterOutput, findRangesBasedOnCriteria)) {\n        currentElement = currentSortedElement;\n        if (!currentGroup) {\n          currentGroup = currentSortedElement;\n        }\n      } else {\n        if (currentElement) {\n          resultsArray.push([currentGroup, currentElement]);\n        }\n        currentElement = null;\n        currentGroup = null;\n      }\n    }\n    if (currentGroup) {\n      resultsArray.push([currentGroup, null]);\n    }\n    let formattedRanges = [];\n    for (let [rangeStart, endRange] of resultsArray) {\n      if (rangeStart === endRange) {\n        formattedRanges.push(rangeStart);\n      } else if (!endRange && rangeStart === sortedArray[0]) {\n        formattedRanges.push(\"*\");\n      } else if (!endRange) {\n        formattedRanges.push(`>=${rangeStart}`);\n      } else if (rangeStart === sortedArray[0]) {\n        formattedRanges.push(`<=${endRange}`);\n      } else {\n        formattedRanges.push(`${rangeStart} - ${endRange}`);\n      }\n    }\n    let generateConditionString = formattedRanges.join(\" || \");\n    let formattedOutput = typeof generateFilterOutput.raw === \"string\" ? generateFilterOutput.raw : String(generateFilterOutput);\n    if (generateConditionString.length < formattedOutput.length) {\n      return generateConditionString;\n    } else {\n      return generateFilterOutput;\n    }\n  };\n});\nvar outputImageProcessingFunction = z((compareVersionSets, exportVersionComparisonFunction) => {\n  var VersionSetComparator = c$();\n  var createVersionValidator = DJA();\n  var {\n    ANY: ANY_VERSION\n  } = createVersionValidator;\n  var compareVersionConstraints = q0A();\n  var compareSemver = d$();\n  var Oa9 = (A, B, Q = {}) => {\n    if (A === B) {\n      return true;\n    }\n    A = new VersionSetComparator(A, Q);\n    B = new VersionSetComparator(B, Q);\n    let I = false;\n    A: for (let G of A.set) {\n      for (let _item of B.set) {\n        let resultFromTa9 = compareVersionItems(G, _item, Q);\n        I = I || resultFromTa9 !== null;\n        if (resultFromTa9) {\n          continue A;\n        }\n      }\n      if (I) {\n        return false;\n      }\n    }\n    return true;\n  };\n  var prereleaseValidator = [new createVersionValidator(\">=0.0.0-0\")];\n  var defaultVersionConstraints = [new createVersionValidator(\">=0.0.0\")];\n  var compareVersionItems = (A, B, Q) => {\n    if (A === B) {\n      return true;\n    }\n    if (A.length === 1 && A[0].semver === ANY_VERSION) {\n      if (B.length === 1 && B[0].semver === ANY_VERSION) {\n        return true;\n      } else if (Q.includePrerelease) {\n        A = prereleaseValidator;\n      } else {\n        A = defaultVersionConstraints;\n      }\n    }\n    if (B.length === 1 && B[0].semver === ANY_VERSION) {\n      if (Q.includePrerelease) {\n        return true;\n      } else {\n        B = defaultVersionConstraints;\n      }\n    }\n    let I = new Set();\n    let G;\n    let Z;\n    for (let K of A) {\n      if (K.operator === \">\" || K.operator === \">=\") {\n        G = ____compareVersions(G, K, Q);\n      } else if (K.operator === \"<\" || K.operator === \"<=\") {\n        Z = compareSemverConstraints(Z, K, Q);\n      } else {\n        I.add(K.semver);\n      }\n    }\n    if (I.size > 1) {\n      return null;\n    }\n    let Y;\n    if (G && Z) {\n      Y = compareSemver(G.semver, Z.semver, Q);\n      if (Y > 0) {\n        return null;\n      } else if (Y === 0 && (G.operator !== \">=\" || Z.operator !== \"<=\")) {\n        return null;\n      }\n    }\n    for (let K of I) {\n      if (G && !compareVersionConstraints(K, String(G), Q)) {\n        return null;\n      }\n      if (Z && !compareVersionConstraints(K, String(Z), Q)) {\n        return null;\n      }\n      for (let versionConstraint of B) {\n        if (!compareVersionConstraints(K, String(versionConstraint), Q)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    let J;\n    let X;\n    let W;\n    let F;\n    let C = Z && !Q.includePrerelease && Z.semver.prerelease.length ? Z.semver : false;\n    let V = G && !Q.includePrerelease && G.semver.prerelease.length ? G.semver : false;\n    if (C && C.prerelease.length === 1 && Z.operator === \"<\" && C.prerelease[0] === 0) {\n      C = false;\n    }\n    for (let K of B) {\n      F = F || K.operator === \">\" || K.operator === \">=\";\n      W = W || K.operator === \"<\" || K.operator === \"<=\";\n      if (G) {\n        if (V) {\n          if (K.semver.prerelease && K.semver.prerelease.length && K.semver.major === V.major && K.semver.minor === V.minor && K.semver.patch === V.patch) {\n            V = false;\n          }\n        }\n        if (K.operator === \">\" || K.operator === \">=\") {\n          J = ____compareVersions(G, K, Q);\n          if (J === K && J !== G) {\n            return false;\n          }\n        } else if (G.operator === \">=\" && !compareVersionConstraints(G.semver, String(K), Q)) {\n          return false;\n        }\n      }\n      if (Z) {\n        if (C) {\n          if (K.semver.prerelease && K.semver.prerelease.length && K.semver.major === C.major && K.semver.minor === C.minor && K.semver.patch === C.patch) {\n            C = false;\n          }\n        }\n        if (K.operator === \"<\" || K.operator === \"<=\") {\n          X = compareSemverConstraints(Z, K, Q);\n          if (X === K && X !== Z) {\n            return false;\n          }\n        } else if (Z.operator === \"<=\" && !compareVersionConstraints(Z.semver, String(K), Q)) {\n          return false;\n        }\n      }\n      if (!K.operator && (Z || G) && Y !== 0) {\n        return false;\n      }\n    }\n    if (G && W && !Z && Y !== 0) {\n      return false;\n    }\n    if (Z && F && !G && Y !== 0) {\n      return false;\n    }\n    if (V || C) {\n      return false;\n    }\n    return true;\n  };\n  var ____compareVersions = (A, B, Q) => {\n    if (!A) {\n      return B;\n    }\n    let I = compareSemver(A.semver, B.semver, Q);\n    if (I > 0) {\n      return A;\n    } else if (I < 0) {\n      return B;\n    } else if (B.operator === \">\" && A.operator === \">=\") {\n      return B;\n    } else {\n      return A;\n    }\n  };\n  var compareSemverConstraints = (A, B, Q) => {\n    if (!A) {\n      return B;\n    }\n    let I = compareSemver(A.semver, B.semver, Q);\n    if (I < 0) {\n      return A;\n    } else if (I > 0) {\n      return B;\n    } else if (B.operator === \"<\" && A.operator === \"<=\") {\n      return B;\n    } else {\n      return A;\n    }\n  };\n  exportVersionComparisonFunction.exports = Oa9;\n});\nvar _imageProcessingFunction = z((_imageProcessingModule, imageProcessingExports) => {\n  var ___imageProcessingHandler = w0A();\n  var semverConstants = FJA();\n  var SemanticVersion = oV();\n  var imageIdentifierUtils = AJ1();\n  var parseSemver = qi();\n  var validateImageProcessing = _imageProcessor();\n  var cleanProcessedImage = ImageProcessingPipeline();\n  var _incrementVersion = processorFunction();\n  var diffImageProcessing = __imageProcessingPipeline();\n  var getMajorVersion = __processImage();\n  var calculateImageMinorVersion = ___imageProcessingPipeline();\n  var updateImagePatchOptions = updateImageOutputOptions();\n  var handleImagePreprocessing = handleImageFormatConversion();\n  var compareVersions = d$();\n  var imageConversionComparisonPipeline = imageConversionPipeline();\n  var compareLooseSemanticVersions = ____imageProcessingPipeline();\n  var compareImageFormatSettings = updateImageFormatSettings();\n  var sortImageProcessing = ___processImageTransformations();\n  var sortDescendingByVersion = ______________________________________processImageTransformation();\n  var getGreaterThan = VJA();\n  var lessThanVersion = ePA();\n  var compareSemanticVersions = QJ1();\n  var isVersionEqual = IJ1();\n  var isGreaterThanOrEqualTo = CJA();\n  var lessThanOrEqualTo = AjA();\n  var _compareVersions = GJ1();\n  var coerceVersion = BJ1();\n  var ComparatorFunction = DJA();\n  var RangeHandler = c$();\n  var satisfiesVersion = q0A();\n  var toComparatorsPipeline = _____imageProcessingPipeline();\n  var getMaxSatisfyingVersion = _imageProcessingHandler();\n  var minSatisfyingVersion = enhancedImageProcessingPipeline();\n  var minVersionHandler = convertImageFormat();\n  var validRange = processImagePipeline();\n  var processOutsideImagePipeline = initializeSharpImageProcessing();\n  var _________________________imageTransformationProcessor = imageTransformProcessor();\n  var imageTransformProcessorLoose = __________imageTransformationProcessor();\n  var intersectImageProcessingPipelines = ______imageProcessingPipeline();\n  var simplifyImageProcessingRange = outputFilePath();\n  var outputImagePipelineSettings = outputImageProcessingFunction();\n  imageProcessingExports.exports = {\n    parse: parseSemver,\n    valid: validateImageProcessing,\n    clean: cleanProcessedImage,\n    inc: _incrementVersion,\n    diff: diffImageProcessing,\n    major: getMajorVersion,\n    minor: calculateImageMinorVersion,\n    patch: updateImagePatchOptions,\n    prerelease: handleImagePreprocessing,\n    compare: compareVersions,\n    rcompare: imageConversionComparisonPipeline,\n    compareLoose: compareLooseSemanticVersions,\n    compareBuild: compareImageFormatSettings,\n    sort: sortImageProcessing,\n    rsort: sortDescendingByVersion,\n    gt: getGreaterThan,\n    lt: lessThanVersion,\n    eq: compareSemanticVersions,\n    neq: isVersionEqual,\n    gte: isGreaterThanOrEqualTo,\n    lte: lessThanOrEqualTo,\n    cmp: _compareVersions,\n    coerce: coerceVersion,\n    Comparator: ComparatorFunction,\n    Range: RangeHandler,\n    satisfies: satisfiesVersion,\n    toComparators: toComparatorsPipeline,\n    maxSatisfying: getMaxSatisfyingVersion,\n    minSatisfying: minSatisfyingVersion,\n    minVersion: minVersionHandler,\n    validRange: validRange,\n    outside: processOutsideImagePipeline,\n    gtr: _________________________imageTransformationProcessor,\n    ltr: imageTransformProcessorLoose,\n    intersects: intersectImageProcessingPipelines,\n    simplifyRange: simplifyImageProcessingRange,\n    subset: outputImagePipelineSettings,\n    SemVer: SemanticVersion,\n    re: ___imageProcessingHandler.re,\n    src: ___imageProcessingHandler.src,\n    tokens: ___imageProcessingHandler.t,\n    SEMVER_SPEC_VERSION: semverConstants.SEMVER_SPEC_VERSION,\n    RELEASE_TYPES: semverConstants.RELEASE_TYPES,\n    compareIdentifiers: imageIdentifierUtils.compareIdentifiers,\n    rcompareIdentifiers: imageIdentifierUtils.rcompareIdentifiers\n  };\n});\nvar processImageAndGenerateOutput;\nvar processImageEnhancements;\nvar ImageHandler;\nvar setExifMergeOptions;\nvar lh = T(() => {\n  E5();\n  processImageAndGenerateOutput = IA(_imageProcessingFunction(), 1);\n  processImageEnhancements = EB() !== \"windows\" || (Ai() ? processImageAndGenerateOutput.default.satisfies(process.versions.bun, \">=1.2.23\") : processImageAndGenerateOutput.default.satisfies(process.versions.node, \">=22.17.0 <23.0.0 || >=24.2.0\"));\n  if (!processImageEnhancements) {\n    ImageHandler = {\n      displayText: \"alt+m\",\n      check: (isMetaKeyPressed, isMetaKeyPress) => isMetaKeyPress.meta && (isMetaKeyPressed === \"m\" || isMetaKeyPressed === \"M\")\n    };\n  } else {\n    ImageHandler = {\n      displayText: \"shift+tab\",\n      check: (isTabAndShiftActive, keyPressed) => keyPressed.tab && keyPressed.shift\n    };\n  }\n  if (EB() === \"windows\") {\n    setExifMergeOptions = {\n      displayText: \"alt+v\",\n      check: (isVersionCheck, isValidMetaForVersion) => isValidMetaForVersion.meta && (isVersionCheck === \"v\" || isVersionCheck === \"V\")\n    };\n  } else {\n    setExifMergeOptions = {\n      displayText: \"ctrl+v\",\n      check: (isPasteCommand, isControlVPressed) => isControlVPressed.ctrl && (isPasteCommand === \"v\" || isPasteCommand === \"V\")\n    };\n  }\n});\nfunction formatStringBasedOnType(commandModifier, commandType) {\n  switch (commandType) {\n    case \"bash\":\n      return `!${commandModifier}`;\n    case \"memorySelect\":\n      return `#${commandModifier}`;\n    case \"background\":\n      return `&${commandModifier}`;\n    default:\n      return commandModifier;\n  }\n}\nfunction getCommandType(commandPrefix) {\n  if (commandPrefix.startsWith(\"!\")) {\n    return \"bash\";\n  }\n  if (commandPrefix.startsWith(\"#\")) {\n    return \"memory\";\n  }\n  commandPrefix.startsWith(\"&\");\n  return \"prompt\";\n}\nfunction processCommand(command) {\n  if (getCommandType(command) === \"prompt\") {\n    return command;\n  }\n  return command.slice(1);\n}\nfunction isSpecialCharacter(_isSpecialCharacter) {\n  return _isSpecialCharacter === \"!\" || _isSpecialCharacter === \"#\" || false;\n}\nfunction filterOutHookProgress(_filterOutHookProgress) {\n  return _filterOutHookProgress.filter(isNotHookProgress => isNotHookProgress.data?.type !== \"hook_progress\");\n}\nvar handleImageProcessing = () => ({\n  mode: \"default\",\n  additionalWorkingDirectories: new Map(),\n  alwaysAllowRules: {},\n  alwaysDenyRules: {},\n  alwaysAskRules: {},\n  isBypassPermissionsModeAvailable: false\n});\nimport { stat as imageProcessingModule, lstat as _______imageProcessingPipeline, readdir as imageProcessingOptions, realpath as _ImageProcessingPipeline } from \"node:fs/promises\";\nimport { Readable as __imageProcessor } from \"node:stream\";\nimport { resolve as __imageProcessingHandler, relative as initializeImageProcessingModule, join as processImageOps, sep as processImageInWorkflow } from \"node:path\";\nfunction initializeFileReading(rootDirectory, fileReadOptions = {}) {\n  let _entryType = fileReadOptions.entryType || fileReadOptions.type;\n  if (_entryType === \"both\") {\n    _entryType = handleImageOutput.FILE_DIR_TYPE;\n  }\n  if (_entryType) {\n    fileReadOptions.type = _entryType;\n  }\n  if (!rootDirectory) {\n    throw Error(\"readdirp: root argument is required. Usage: readdirp(root, options)\");\n  } else if (typeof rootDirectory !== \"string\") {\n    throw TypeError(\"readdirp: root argument must be a string. Usage: readdirp(root, options)\");\n  } else if (_entryType && !initializeAndLoadImageProcessing.includes(_entryType)) {\n    throw Error(`readdirp: Invalid type passed. Use one of ${initializeAndLoadImageProcessing.join(\", \")}`);\n  }\n  fileReadOptions.root = rootDirectory;\n  return new databaseConnection(fileReadOptions);\n}\nvar handleImageOutput;\nvar maxImageSize;\nvar ________imageProcessingPipeline = \"READDIRP_RECURSIVE_ERROR\";\nvar jpegOutputFileExtensionRegex;\nvar initializeAndLoadImageProcessing;\nvar processImageConversion;\nvar NodePipeline;\nvar ____imageTransformationPipeline = A => jpegOutputFileExtensionRegex.has(A.code);\nvar _________imageProcessingPipeline;\nvar __ImageProcessingPipeline = __isActive => true;\nvar ___________imageTransformationProcessor = getImageProcessingFunction => {\n  if (getImageProcessingFunction === undefined) {\n    return __ImageProcessingPipeline;\n  }\n  if (typeof getImageProcessingFunction === \"function\") {\n    return getImageProcessingFunction;\n  }\n  if (typeof getImageProcessingFunction === \"string\") {\n    let trimmedBaseNames = getImageProcessingFunction.trim();\n    return basenameMatchesB => basenameMatchesB.basename === trimmedBaseNames;\n  }\n  if (Array.isArray(getImageProcessingFunction)) {\n    let _trimmedBaseNames = getImageProcessingFunction.map(stringWithWhitespaceTrimmed => stringWithWhitespaceTrimmed.trim());\n    return isBaseNameInCollection => _trimmedBaseNames.some(_isBaseNameInCollection => isBaseNameInCollection.basename === _isBaseNameInCollection);\n  }\n  return __ImageProcessingPipeline;\n};\nvar databaseConnection;\nvar _________imageProcessor = T(() => {\n  handleImageOutput = {\n    FILE_TYPE: \"files\",\n    DIR_TYPE: \"directories\",\n    FILE_DIR_TYPE: \"files_directories\",\n    EVERYTHING_TYPE: \"all\"\n  };\n  maxImageSize = {\n    root: \".\",\n    fileFilter: isActive => true,\n    directoryFilter: _isActive => true,\n    type: handleImageOutput.FILE_TYPE,\n    lstat: false,\n    depth: 2147483648,\n    alwaysStat: false,\n    highWaterMark: 4096\n  };\n  Object.freeze(maxImageSize);\n  jpegOutputFileExtensionRegex = new Set([\"ENOENT\", \"EPERM\", \"EACCES\", \"ELOOP\", ________imageProcessingPipeline]);\n  initializeAndLoadImageProcessing = [handleImageOutput.DIR_TYPE, handleImageOutput.EVERYTHING_TYPE, handleImageOutput.FILE_DIR_TYPE, handleImageOutput.FILE_TYPE];\n  processImageConversion = new Set([handleImageOutput.DIR_TYPE, handleImageOutput.EVERYTHING_TYPE, handleImageOutput.FILE_DIR_TYPE]);\n  NodePipeline = new Set([handleImageOutput.EVERYTHING_TYPE, handleImageOutput.FILE_DIR_TYPE, handleImageOutput.FILE_TYPE]);\n  _________imageProcessingPipeline = process.platform === \"win32\";\n  databaseConnection = class _ImageProcessor extends __imageProcessor {\n    constructor(_options = {}) {\n      super({\n        objectMode: true,\n        autoDestroy: true,\n        highWaterMark: _options.highWaterMark\n      });\n      let B = {\n        ...maxImageSize,\n        ..._options\n      };\n      let {\n        root: Q,\n        type: I\n      } = B;\n      this._fileFilter = ___________imageTransformationProcessor(B.fileFilter);\n      this._directoryFilter = ___________imageTransformationProcessor(B.directoryFilter);\n      let G = B.lstat ? _______imageProcessingPipeline : imageProcessingModule;\n      if (_________imageProcessingPipeline) {\n        this._stat = generateBigInt => G(generateBigInt, {\n          bigint: true\n        });\n      } else {\n        this._stat = G;\n      }\n      this._maxDepth = B.depth ?? maxImageSize.depth;\n      this._wantsDir = I ? processImageConversion.has(I) : false;\n      this._wantsFile = I ? NodePipeline.has(I) : false;\n      this._wantsEverything = I === handleImageOutput.EVERYTHING_TYPE;\n      this._root = __imageProcessingHandler(Q);\n      this._isDirent = !B.alwaysStat;\n      this._statsProp = this._isDirent ? \"dirent\" : \"stats\";\n      this._rdOptions = {\n        encoding: \"utf8\",\n        withFileTypes: this._isDirent\n      };\n      this.parents = [this._exploreDir(Q, 1)];\n      this.reading = false;\n      this.parent = undefined;\n    }\n    async _read(remainingItemsCount) {\n      if (this.reading) {\n        return;\n      }\n      this.reading = true;\n      try {\n        while (!this.destroyed && remainingItemsCount > 0) {\n          let parentDirectory = this.parent;\n          let fileList = parentDirectory && parentDirectory.files;\n          if (fileList && fileList.length > 0) {\n            let {\n              path: currentFilePath,\n              depth: directoryDepth\n            } = parentDirectory;\n            let formattedEntries = fileList.splice(0, remainingItemsCount).map(formatEntry => this._formatEntry(formatEntry, currentFilePath));\n            let _formattedEntries = await Promise.all(formattedEntries);\n            for (let formattedEntry of _formattedEntries) {\n              if (!formattedEntry) {\n                continue;\n              }\n              if (this.destroyed) {\n                return;\n              }\n              let entryType = await this._getEntryType(formattedEntry);\n              if (entryType === \"directory\" && this._directoryFilter(formattedEntry)) {\n                if (directoryDepth <= this._maxDepth) {\n                  this.parents.push(this._exploreDir(formattedEntry.fullPath, directoryDepth + 1));\n                }\n                if (this._wantsDir) {\n                  this.push(formattedEntry);\n                  remainingItemsCount--;\n                }\n              } else if ((entryType === \"file\" || this._includeAsFile(formattedEntry)) && this._fileFilter(formattedEntry)) {\n                if (this._wantsFile) {\n                  this.push(formattedEntry);\n                  remainingItemsCount--;\n                }\n              }\n            }\n          } else {\n            let filePath = this.parents.pop();\n            if (!filePath) {\n              this.push(null);\n              break;\n            }\n            this.parent = await filePath;\n            if (this.destroyed) {\n              return;\n            }\n          }\n        }\n      } catch (______________error) {\n        this.destroy(______________error);\n      } finally {\n        this.reading = false;\n      }\n    }\n    async _exploreDir(A, B) {\n      let Q;\n      try {\n        Q = await imageProcessingOptions(A, this._rdOptions);\n      } catch (_____________error) {\n        this._onError(_____________error);\n      }\n      return {\n        files: Q,\n        depth: B,\n        path: A\n      };\n    }\n    async _formatEntry(A, B) {\n      let Q;\n      let I = this._isDirent ? A.name : A;\n      try {\n        let processedImage = __imageProcessingHandler(processImageOps(B, I));\n        Q = {\n          path: initializeImageProcessingModule(this._root, processedImage),\n          fullPath: processedImage,\n          basename: I\n        };\n        Q[this._statsProp] = this._isDirent ? A : await this._stat(processedImage);\n      } catch (____________error) {\n        this._onError(____________error);\n        return;\n      }\n      return Q;\n    }\n    _onError(A) {\n      if (____imageTransformationPipeline(A) && !this.destroyed) {\n        this.emit(\"warn\", A);\n      } else {\n        this.destroy(A);\n      }\n    }\n    async _getEntryType(A) {\n      if (!A && this._statsProp in A) {\n        return \"\";\n      }\n      let B = A[this._statsProp];\n      if (B.isFile()) {\n        return \"file\";\n      }\n      if (B.isDirectory()) {\n        return \"directory\";\n      }\n      if (B && B.isSymbolicLink()) {\n        let symbolicLinkPath = A.fullPath;\n        try {\n          let imageProcessingResult = await _ImageProcessingPipeline(symbolicLinkPath);\n          let processedImageEntry = await _______imageProcessingPipeline(imageProcessingResult);\n          if (processedImageEntry.isFile()) {\n            return \"file\";\n          }\n          if (processedImageEntry.isDirectory()) {\n            let lengthOfSymlinkTarget = imageProcessingResult.length;\n            if (symbolicLinkPath.startsWith(imageProcessingResult) && symbolicLinkPath.substr(lengthOfSymlinkTarget, 1) === processImageInWorkflow) {\n              let circularSymlinkError = Error(`Circular symlink detected: \"${symbolicLinkPath}\" points to \"${imageProcessingResult}\"`);\n              circularSymlinkError.code = ________imageProcessingPipeline;\n              return this._onError(circularSymlinkError);\n            }\n            return \"directory\";\n          }\n        } catch (__________error) {\n          this._onError(__________error);\n          return \"\";\n        }\n      }\n    }\n    _includeAsFile(A) {\n      let B = A && A[this._statsProp];\n      return B && this._wantsEverything && !B.isDirectory();\n    }\n  };\n});\nimport { watchFile as __________imageProcessingPipeline, unwatchFile as processAudioFile, watch as ImageProcessor } from \"fs\";\nimport { open as _processImageInput, stat as imageProcessingService, lstat as ___processImage, realpath as updateOutputFilePath } from \"fs/promises\";\nimport * as imageFormatHandler from \"path\";\nimport { type as ___imageProcessor } from \"os\";\nfunction Ub0(inputImagePath, imagePersistenceConfig, _____callbackFunction, __errorCallback, imageTransformationCallback) {\n  let Z = (Y, J) => {\n    _____callbackFunction(inputImagePath);\n    imageTransformationCallback(Y, J, {\n      watchedPath: inputImagePath\n    });\n    if (J && inputImagePath !== J) {\n      imageProcessingWorkflow(imageFormatHandler.resolve(inputImagePath, J), _imageTransformationProcessor, imageFormatHandler.join(inputImagePath, J));\n    }\n  };\n  try {\n    return ImageProcessor(inputImagePath, {\n      persistent: imagePersistenceConfig.persistent\n    }, Z);\n  } catch (Y) {\n    __errorCallback(Y);\n    return;\n  }\n}\nclass nJ1 {\n  constructor(A) {\n    this.fsw = A;\n    this._boundHandleError = errorHandlingFunction => A._handleError(errorHandlingFunction);\n  }\n  _watchWithNodeFs(A, B) {\n    let Q = this.fsw.options;\n    let I = imageFormatHandler.dirname(A);\n    let G = imageFormatHandler.basename(A);\n    this.fsw._getWatchedDir(I).add(G);\n    let Y = imageFormatHandler.resolve(A);\n    let J = {\n      persistent: Q.persistent\n    };\n    if (!B) {\n      B = imagePipeline;\n    }\n    let X;\n    if (Q.usePolling) {\n      let isIntervalBinaryDifferent = Q.interval !== Q.binaryInterval;\n      J.interval = isIntervalBinaryDifferent && processImageOutputHandler(G) ? Q.binaryInterval : Q.interval;\n      X = __processImageTransformationHandler(A, Y, J, {\n        listener: B,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      X = us9(A, Y, J, {\n        listener: B,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n    return X;\n  }\n  _handleFile(A, B, Q) {\n    if (this.fsw.closed) {\n      return;\n    }\n    let I = imageFormatHandler.dirname(A);\n    let G = imageFormatHandler.basename(A);\n    let Z = this.fsw._getWatchedDir(I);\n    let Y = B;\n    if (Z.has(G)) {\n      return;\n    }\n    let __handleImageProcessing = async (imageFileHandle, imageMetadata) => {\n      if (!this.fsw._throttle(imageTransformationProcessor, A, 5)) {\n        return;\n      }\n      if (!imageMetadata || imageMetadata.mtimeMs === 0) {\n        try {\n          let processedImageMetadata = await imageProcessingService(A);\n          if (this.fsw.closed) {\n            return;\n          }\n          let {\n            atimeMs: lastAccessTimeMs,\n            mtimeMs: mtimeMsUpdated\n          } = processedImageMetadata;\n          if (!lastAccessTimeMs || lastAccessTimeMs <= mtimeMsUpdated || mtimeMsUpdated !== Y.mtimeMs) {\n            this.fsw._emit(____________imageProcessingPipeline.CHANGE, A, processedImageMetadata);\n          }\n          if ((_processImageTransformation || __processImageTransformation || updateImageOutputFormat) && Y.ino !== processedImageMetadata.ino) {\n            this.fsw._closeFile(imageFileHandle);\n            Y = processedImageMetadata;\n            let imageWatcher = this._watchWithNodeFs(A, __handleImageProcessing);\n            if (imageWatcher) {\n              this.fsw._addPathCloser(imageFileHandle, imageWatcher);\n            }\n          } else {\n            Y = processedImageMetadata;\n          }\n        } catch (exceptionHandler) {\n          this.fsw._remove(I, G);\n        }\n      } else if (Z.has(G)) {\n        let {\n          atimeMs: __lastAccessTimeMs,\n          mtimeMs: modifiedTimeMs\n        } = imageMetadata;\n        if (!__lastAccessTimeMs || __lastAccessTimeMs <= modifiedTimeMs || modifiedTimeMs !== Y.mtimeMs) {\n          this.fsw._emit(____________imageProcessingPipeline.CHANGE, A, imageMetadata);\n        }\n        Y = imageMetadata;\n      }\n    };\n    let X = this._watchWithNodeFs(A, __handleImageProcessing);\n    if ((!Q || !this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(A)) {\n      if (!this.fsw._throttle(____________imageProcessingPipeline.ADD, A, 0)) {\n        return;\n      }\n      this.fsw._emit(____________imageProcessingPipeline.ADD, A, B);\n    }\n    return X;\n  }\n  async _handleSymlink(A, B, Q, I) {\n    if (this.fsw.closed) {\n      return;\n    }\n    let G = A.fullPath;\n    let Z = this.fsw._getWatchedDir(B);\n    if (!this.fsw.options.followSymlinks) {\n      this.fsw._incrReadyCount();\n      let updatedFilePath;\n      try {\n        updatedFilePath = await updateOutputFilePath(Q);\n      } catch (_________error) {\n        this.fsw._emitReady();\n        return true;\n      }\n      if (this.fsw.closed) {\n        return;\n      }\n      if (Z.has(I)) {\n        if (this.fsw._symlinkPaths.get(G) !== updatedFilePath) {\n          this.fsw._symlinkPaths.set(G, updatedFilePath);\n          this.fsw._emit(____________imageProcessingPipeline.CHANGE, Q, A.stats);\n        }\n      } else {\n        Z.add(I);\n        this.fsw._symlinkPaths.set(G, updatedFilePath);\n        this.fsw._emit(____________imageProcessingPipeline.ADD, Q, A.stats);\n      }\n      this.fsw._emitReady();\n      return true;\n    }\n    if (this.fsw._symlinkPaths.has(G)) {\n      return true;\n    }\n    this.fsw._symlinkPaths.set(G, true);\n  }\n  _handleRead(A, B, Q, currentPath, G, Z, Y) {\n    A = imageFormatHandler.join(A, \"\");\n    Y = this.fsw._throttle(\"readdir\", A, 1000);\n    if (!Y) {\n      return;\n    }\n    let J = this.fsw._getWatchedDir(Q.path);\n    let X = new Set();\n    let ________imageProcessor = this.fsw._readdirp(A, {\n      fileFilter: filterPath => Q.filterPath(filterPath),\n      directoryFilter: filterDirectory => Q.filterDir(filterDirectory)\n    });\n    if (!________imageProcessor) {\n      return;\n    }\n    ________imageProcessor.on(____imageProcessor, async handleFileEvent => {\n      if (this.fsw.closed) {\n        ________imageProcessor = undefined;\n        return;\n      }\n      let __filePath = handleFileEvent.path;\n      let imageFilePath = imageFormatHandler.join(A, __filePath);\n      X.add(__filePath);\n      if (handleFileEvent.stats.isSymbolicLink() && (await this._handleSymlink(handleFileEvent, A, imageFilePath, __filePath))) {\n        return;\n      }\n      if (this.fsw.closed) {\n        ________imageProcessor = undefined;\n        return;\n      }\n      if (__filePath === currentPath || !currentPath && !J.has(__filePath)) {\n        this.fsw._incrReadyCount();\n        imageFilePath = imageFormatHandler.join(G, imageFormatHandler.relative(G, imageFilePath));\n        this._addToNodeFs(imageFilePath, B, Q, Z + 1);\n      }\n    }).on(____________imageProcessingPipeline.ERROR, this._boundHandleError);\n    return new Promise((____processImage, _____processImage) => {\n      if (!________imageProcessor) {\n        return _____processImage();\n      }\n      ________imageProcessor.once(sharpImageProcessing, () => {\n        if (this.fsw.closed) {\n          ________imageProcessor = undefined;\n          return;\n        }\n        let isYClear = Y ? Y.clear() : false;\n        ____processImage(undefined);\n        J.getChildren().filter(isValidKey => {\n          return isValidKey !== A && !X.has(isValidKey);\n        }).forEach(_________callbackFunction => {\n          this.fsw._remove(A, _________callbackFunction);\n        });\n        ________imageProcessor = undefined;\n        if (isYClear) {\n          this._handleRead(A, false, Q, currentPath, G, Z, Y);\n        }\n      });\n    });\n  }\n  async _handleDir(A, B, Q, I, isDirectoryProcessed, Z, Y) {\n    let J = this.fsw._getWatchedDir(imageFormatHandler.dirname(A));\n    let X = J.has(imageFormatHandler.basename(A));\n    if ((!Q || !this.fsw.options.ignoreInitial) && !isDirectoryProcessed && !X) {\n      this.fsw._emit(____________imageProcessingPipeline.ADD_DIR, A, B);\n    }\n    J.add(imageFormatHandler.basename(A));\n    this.fsw._getWatchedDir(A);\n    let W;\n    let F;\n    let C = this.fsw.options.depth;\n    if ((C == null || I <= C) && !this.fsw._symlinkPaths.has(Y)) {\n      if (!isDirectoryProcessed) {\n        await this._handleRead(A, Q, Z, isDirectoryProcessed, A, I, W);\n        if (this.fsw.closed) {\n          return;\n        }\n      }\n      F = this._watchWithNodeFs(A, (___filePath, fileMetadata) => {\n        if (fileMetadata && fileMetadata.mtimeMs === 0) {\n          return;\n        }\n        this._handleRead(___filePath, false, Z, isDirectoryProcessed, A, I, W);\n      });\n    }\n    return F;\n  }\n  async _addToNodeFs(A, B, Q, I, G) {\n    let Z = this.fsw._emitReady;\n    if (this.fsw._isIgnored(A) || this.fsw.closed) {\n      Z();\n      return false;\n    }\n    let Y = this.fsw._getWatchHelpers(A);\n    if (Q) {\n      Y.filterPath = _filterPath => Q.filterPath(_filterPath);\n      Y.filterDir = directoryFilter => Q.filterDir(directoryFilter);\n    }\n    try {\n      let imageValidationResult = await validateImageOutputOptions[Y.statMethod](Y.watchPath);\n      if (this.fsw.closed) {\n        return;\n      }\n      if (this.fsw._isIgnored(Y.watchPath, imageValidationResult)) {\n        Z();\n        return false;\n      }\n      let shouldFollowSymlinks = this.fsw.options.followSymlinks;\n      let outputResult;\n      if (imageValidationResult.isDirectory()) {\n        let resolvedImageFormat = imageFormatHandler.resolve(A);\n        let _outputFilePath = shouldFollowSymlinks ? await updateOutputFilePath(A) : A;\n        if (this.fsw.closed) {\n          return;\n        }\n        outputResult = await this._handleDir(Y.watchPath, imageValidationResult, B, I, G, Y, _outputFilePath);\n        if (this.fsw.closed) {\n          return;\n        }\n        if (resolvedImageFormat !== _outputFilePath && _outputFilePath !== undefined) {\n          this.fsw._symlinkPaths.set(resolvedImageFormat, _outputFilePath);\n        }\n      } else if (imageValidationResult.isSymbolicLink()) {\n        let resolveImageFormat = shouldFollowSymlinks ? await updateOutputFilePath(A) : A;\n        if (this.fsw.closed) {\n          return;\n        }\n        let __outputFilePath = imageFormatHandler.dirname(Y.watchPath);\n        this.fsw._getWatchedDir(__outputFilePath).add(Y.watchPath);\n        this.fsw._emit(____________imageProcessingPipeline.ADD, Y.watchPath, imageValidationResult);\n        outputResult = await this._handleDir(__outputFilePath, imageValidationResult, B, I, A, Y, resolveImageFormat);\n        if (this.fsw.closed) {\n          return;\n        }\n        if (resolveImageFormat !== undefined) {\n          this.fsw._symlinkPaths.set(imageFormatHandler.resolve(A), resolveImageFormat);\n        }\n      } else {\n        outputResult = this._handleFile(Y.watchPath, imageValidationResult, B);\n      }\n      Z();\n      if (outputResult) {\n        this.fsw._addPathCloser(A, outputResult);\n      }\n      return false;\n    } catch (_______error) {\n      if (this.fsw._handleError(_______error)) {\n        Z();\n        return A;\n      }\n    }\n  }\n}\nvar ____imageProcessor = \"data\";\nvar sharpImageProcessing = \"end\";\nvar _imageProcessingOptions = \"close\";\nvar imagePipeline = () => {};\nvar ImageTransformProcessor;\nvar _validateOutputFilePath;\nvar _processImageTransformation;\nvar __processImageTransformation;\nvar updateImageOutputFormat;\nvar ___processImageTransformation;\nvar ___________imageProcessingPipeline;\nvar ____________imageProcessingPipeline;\nvar imageTransformationProcessor = \"watch\";\nvar validateImageOutputOptions;\nvar _imageTransformationProcessor = \"listeners\";\nvar ____processImageTransformation = \"errHandlers\";\nvar _____imageProcessor = \"rawEmitters\";\nvar _____processImageTransformation;\nvar __validateOutputFilePath;\nvar processImageOutputHandler = A => __validateOutputFilePath.has(imageFormatHandler.extname(A).slice(1).toLowerCase());\nvar initializeImageProcessing = (processSetOrValue, ____________callbackFunction) => {\n  if (processSetOrValue instanceof Set) {\n    processSetOrValue.forEach(____________callbackFunction);\n  } else {\n    ____________callbackFunction(processSetOrValue);\n  }\n};\nvar ______processImageTransformation = (updateSetWithValue, updateSetForKey, elementToAdd) => {\n  let itemSet = updateSetWithValue[updateSetForKey];\n  if (!(itemSet instanceof Set)) {\n    updateSetWithValue[updateSetForKey] = itemSet = new Set([itemSet]);\n  }\n  itemSet.add(elementToAdd);\n};\nvar _______processImageTransformation = clearOrDeleteProperty => clearOrDeletePropertyByKey => {\n  let propertyValue = clearOrDeleteProperty[clearOrDeletePropertyByKey];\n  if (propertyValue instanceof Set) {\n    propertyValue.clear();\n  } else {\n    delete clearOrDeleteProperty[clearOrDeletePropertyByKey];\n  }\n};\nvar imageTransformationPipeline = (removeItemFromSetOrDeleteKey, removeItemFromCollection, itemToDelete) => {\n  let itemOrSet = removeItemFromSetOrDeleteKey[removeItemFromCollection];\n  if (itemOrSet instanceof Set) {\n    itemOrSet.delete(itemToDelete);\n  } else if (itemOrSet === itemToDelete) {\n    delete removeItemFromSetOrDeleteKey[removeItemFromCollection];\n  }\n};\nvar ________processImageTransformation = isSetEmptyOrFalsy => isSetEmptyOrFalsy instanceof Set ? isSetEmptyOrFalsy.size === 0 : !isSetEmptyOrFalsy;\nvar _processImageTransformations;\nvar imageProcessingWorkflow = (A, B, Q, I, G) => {\n  let Z = _processImageTransformations.get(A);\n  if (!Z) {\n    return;\n  }\n  initializeImageProcessing(Z[B], Y => {\n    Y(Q, I, G);\n  });\n};\nvar us9 = (A, B, Q, I) => {\n  let {\n    listener: G,\n    errHandler: Z,\n    rawEmitter: Y\n  } = I;\n  let J = _processImageTransformations.get(B);\n  let X;\n  if (!Q.persistent) {\n    X = Ub0(A, Q, G, Z, Y);\n    if (!X) {\n      return;\n    }\n    return X.close.bind(X);\n  }\n  if (J) {\n    ______processImageTransformation(J, _imageTransformationProcessor, G);\n    ______processImageTransformation(J, ____processImageTransformation, Z);\n    ______processImageTransformation(J, _____imageProcessor, Y);\n  } else {\n    X = Ub0(A, Q, imageProcessingWorkflow.bind(null, B, _imageTransformationProcessor), Z, imageProcessingWorkflow.bind(null, B, _____imageProcessor));\n    if (!X) {\n      return;\n    }\n    X.on(____________imageProcessingPipeline.ERROR, async ____________________________________processImageTransformation => {\n      let _____________________________________processImageTransformation = imageProcessingWorkflow.bind(null, B, ____processImageTransformation);\n      if (J) {\n        J.watcherUnusable = true;\n      }\n      if (_validateOutputFilePath && ____________________________________processImageTransformation.code === \"EPERM\") {\n        try {\n          await (await _processImageInput(A, \"r\")).close();\n          _____________________________________processImageTransformation(____________________________________processImageTransformation);\n        } catch (__________________error) {}\n      } else {\n        _____________________________________processImageTransformation(____________________________________processImageTransformation);\n      }\n    });\n    J = {\n      listeners: G,\n      errHandlers: Z,\n      rawEmitters: Y,\n      watcher: X\n    };\n    _processImageTransformations.set(B, J);\n  }\n  return () => {\n    imageTransformationPipeline(J, _imageTransformationProcessor, G);\n    imageTransformationPipeline(J, ____processImageTransformation, Z);\n    imageTransformationPipeline(J, _____imageProcessor, Y);\n    if (________processImageTransformation(J.listeners)) {\n      J.watcher.close();\n      _processImageTransformations.delete(B);\n      _____processImageTransformation.forEach(_______processImageTransformation(J));\n      J.watcher = undefined;\n      Object.freeze(J);\n    }\n  };\n};\nvar _imageTransformationPipeline;\nvar __processImageTransformationHandler = (_____imageProcessingHandler, _imageSource, imageTransformationOptions, imageTransformationData) => {\n  let {\n    listener: imageTransformationListeners,\n    rawEmitter: rawAudioEmitter\n  } = imageTransformationData;\n  let _imageTransformationData = _imageTransformationPipeline.get(_imageSource);\n  let ___options = _imageTransformationData && _imageTransformationData.options;\n  if (___options && (___options.persistent < imageTransformationOptions.persistent || ___options.interval > imageTransformationOptions.interval)) {\n    processAudioFile(_imageSource);\n    _imageTransformationData = undefined;\n  }\n  if (_imageTransformationData) {\n    ______processImageTransformation(_imageTransformationData, _imageTransformationProcessor, imageTransformationListeners);\n    ______processImageTransformation(_imageTransformationData, _____imageProcessor, rawAudioEmitter);\n  } else {\n    _imageTransformationData = {\n      listeners: imageTransformationListeners,\n      rawEmitters: rawAudioEmitter,\n      options: imageTransformationOptions,\n      watcher: __________imageProcessingPipeline(_imageSource, imageTransformationOptions, (currentImage, previousImage) => {\n        initializeImageProcessing(_imageTransformationData.rawEmitters, dispatchImageChangeEvent => {\n          dispatchImageChangeEvent(____________imageProcessingPipeline.CHANGE, _imageSource, {\n            curr: currentImage,\n            prev: previousImage\n          });\n        });\n        let currentImageModificationTime = currentImage.mtimeMs;\n        if (currentImage.size !== previousImage.size || currentImageModificationTime > previousImage.mtimeMs || currentImageModificationTime === 0) {\n          initializeImageProcessing(_imageTransformationData.listeners, _______processImage => _______processImage(_____imageProcessingHandler, currentImage));\n        }\n      })\n    };\n    _imageTransformationPipeline.set(_imageSource, _imageTransformationData);\n  }\n  return () => {\n    imageTransformationPipeline(_imageTransformationData, _imageTransformationProcessor, imageTransformationListeners);\n    imageTransformationPipeline(_imageTransformationData, _____imageProcessor, rawAudioEmitter);\n    if (________processImageTransformation(_imageTransformationData.listeners)) {\n      _imageTransformationPipeline.delete(_imageSource);\n      processAudioFile(_imageSource);\n      _imageTransformationData.options = _imageTransformationData.watcher = undefined;\n      Object.freeze(_imageTransformationData);\n    }\n  };\n};\nvar _______________________________________processImageTransformation = T(() => {\n  ImageTransformProcessor = process.platform;\n  _validateOutputFilePath = ImageTransformProcessor === \"win32\";\n  _processImageTransformation = ImageTransformProcessor === \"darwin\";\n  __processImageTransformation = ImageTransformProcessor === \"linux\";\n  updateImageOutputFormat = ImageTransformProcessor === \"freebsd\";\n  ___processImageTransformation = ___imageProcessor() === \"OS400\";\n  ___________imageProcessingPipeline = {\n    ALL: \"all\",\n    READY: \"ready\",\n    ADD: \"add\",\n    CHANGE: \"change\",\n    ADD_DIR: \"addDir\",\n    UNLINK: \"unlink\",\n    UNLINK_DIR: \"unlinkDir\",\n    RAW: \"raw\",\n    ERROR: \"error\"\n  };\n  ____________imageProcessingPipeline = ___________imageProcessingPipeline;\n  validateImageOutputOptions = {\n    lstat: ___processImage,\n    stat: imageProcessingService\n  };\n  _____processImageTransformation = [_imageTransformationProcessor, ____processImageTransformation, _____imageProcessor];\n  __validateOutputFilePath = new Set([\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"afdesign\", \"afphoto\", \"afpub\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"]);\n  _processImageTransformations = new Map();\n  _imageTransformationPipeline = new Map();\n});\nimport { stat as _____________imageProcessingPipeline } from \"fs\";\nimport { stat as _________processImageTransformation, readdir as processImageTransformationHandler } from \"fs/promises\";\nimport { EventEmitter as __________processImageTransformation } from \"events\";\nimport * as _updateImageFormatBasedOnOptions from \"path\";\nfunction ensureArray(wrapInArray) {\n  if (Array.isArray(wrapInArray)) {\n    return wrapInArray;\n  } else {\n    return [wrapInArray];\n  }\n}\nfunction createMatcherFunction(createMatcher) {\n  if (typeof createMatcher === \"function\") {\n    return createMatcher;\n  }\n  if (typeof createMatcher === \"string\") {\n    return _createMatcher => createMatcher === _createMatcher;\n  }\n  if (createMatcher instanceof RegExp) {\n    return ___inputValue => createMatcher.test(___inputValue);\n  }\n  if (typeof createMatcher === \"object\" && createMatcher !== null) {\n    return matchedPath => {\n      if (createMatcher.path === matchedPath) {\n        return true;\n      }\n      if (createMatcher.recursive) {\n        let resolvedPath = _updateImageFormatBasedOnOptions.relative(createMatcher.path, matchedPath);\n        if (!resolvedPath) {\n          return false;\n        }\n        return !resolvedPath.startsWith(\"..\") && !_updateImageFormatBasedOnOptions.isAbsolute(resolvedPath);\n      }\n      return false;\n    };\n  }\n  return () => false;\n}\nfunction normalizeImagePath(updateImagePath) {\n  if (typeof updateImagePath !== \"string\") {\n    throw Error(\"string expected\");\n  }\n  updateImagePath = _updateImageFormatBasedOnOptions.normalize(updateImagePath);\n  updateImagePath = updateImagePath.replace(/\\\\/g, \"/\");\n  let isPathStartWithDoubleSlash = false;\n  if (updateImagePath.startsWith(\"//\")) {\n    isPathStartWithDoubleSlash = true;\n  }\n  let doubleSlashRegex = /\\/\\//;\n  while (updateImagePath.match(doubleSlashRegex)) {\n    updateImagePath = updateImagePath.replace(doubleSlashRegex, \"/\");\n  }\n  if (isPathStartWithDoubleSlash) {\n    updateImagePath = \"/\" + updateImagePath;\n  }\n  return updateImagePath;\n}\nfunction Ob0(predicateFunction, ______callbackFunction, _______callbackFunction) {\n  let I = normalizeImagePath(______callbackFunction);\n  for (let G = 0; G < predicateFunction.length; G++) {\n    let currentPredicate = predicateFunction[G];\n    if (currentPredicate(I, _______callbackFunction)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction Ar9(inputArray, matchFunction) {\n  if (inputArray == null) {\n    throw TypeError(\"anymatch: specify first argument\");\n  }\n  let I = ensureArray(inputArray).map(G => createMatcherFunction(G));\n  if (matchFunction == null) {\n    return (_processData, __________callbackFunction) => {\n      return Ob0(I, _processData, __________callbackFunction);\n    };\n  }\n  return Ob0(I, matchFunction);\n}\nclass ImageTransformationWatcher {\n  constructor(A, B) {\n    this.path = A;\n    this._removeWatcher = B;\n    this.items = new Set();\n  }\n  add(A) {\n    let {\n      items: B\n    } = this;\n    if (!B) {\n      return;\n    }\n    if (A !== ____________processImageTransformation && A !== __imageTransformationProcessor) {\n      B.add(A);\n    }\n  }\n  async remove(imageToRemove) {\n    let {\n      items: imageCollection\n    } = this;\n    if (!imageCollection) {\n      return;\n    }\n    imageCollection.delete(imageToRemove);\n    if (imageCollection.size > 0) {\n      return;\n    }\n    let ___imagePath = this.path;\n    try {\n      await processImageTransformationHandler(___imagePath);\n    } catch (______error) {\n      if (this._removeWatcher) {\n        this._removeWatcher(_updateImageFormatBasedOnOptions.dirname(___imagePath), _updateImageFormatBasedOnOptions.basename(___imagePath));\n      }\n    }\n  }\n  has(A) {\n    let {\n      items: B\n    } = this;\n    if (!B) {\n      return;\n    }\n    return B.has(A);\n  }\n  getChildren() {\n    let {\n      items: A\n    } = this;\n    if (!A) {\n      return [];\n    }\n    return [...A.values()];\n  }\n  dispose() {\n    this.items.clear();\n    this.path = \"\";\n    this._removeWatcher = imagePipeline;\n    this.items = _______________processImageTransformation;\n    Object.freeze(this);\n  }\n}\nclass ImageWatcher {\n  constructor(__imagePath, _shouldFollowSymlinks, ______imageProcessingHandler) {\n    this.fsw = ______imageProcessingHandler;\n    let originalImagePath = __imagePath;\n    this.path = __imagePath = __imagePath.replace(imageFileProcessor, \"\");\n    this.watchPath = originalImagePath;\n    this.fullWatchPath = _updateImageFormatBasedOnOptions.resolve(originalImagePath);\n    this.dirParts = [];\n    this.dirParts.forEach(removeLastElementIfMoreThanOne => {\n      if (removeLastElementIfMoreThanOne.length > 1) {\n        removeLastElementIfMoreThanOne.pop();\n      }\n    });\n    this.followSymlinks = _shouldFollowSymlinks;\n    this.statMethod = _shouldFollowSymlinks ? ________________processImageTransformation : _________________processImageTransformation;\n  }\n  entryPath(A) {\n    return _updateImageFormatBasedOnOptions.join(this.watchPath, _updateImageFormatBasedOnOptions.relative(this.watchPath, A.fullPath));\n  }\n  filterPath(A) {\n    let {\n      stats: B\n    } = A;\n    if (B && B.isSymbolicLink()) {\n      return this.filterDir(A);\n    }\n    let Q = this.entryPath(A);\n    return this.fsw._isntIgnored(Q, B) && this.fsw._hasReadPermissions(B);\n  }\n  filterDir(A) {\n    return this.fsw._isntIgnored(this.entryPath(A), A.stats);\n  }\n}\nfunction applyImageTransformation(_imageTransformation, B = {}) {\n  let Q = new __________________processImageTransformation(B);\n  Q.add(_imageTransformation);\n  return Q;\n}\nvar ___________processImageTransformation = \"/\";\nvar isJPEG2000Format = \"//\";\nvar ____________processImageTransformation = \".\";\nvar __imageTransformationProcessor = \"..\";\nvar _____________processImageTransformation = \"string\";\nvar validateImageOutputSettings;\nvar __imageTransformationPipeline;\nvar ______________imageProcessingPipeline;\nvar imageFileProcessor;\nvar ______________processImageTransformation = isValidObject => typeof isValidObject === \"object\" && isValidObject !== null && !(isValidObject instanceof RegExp);\nvar Rb0 = A => {\n  let B = ensureArray(A).flat();\n  if (!B.every(Q => typeof Q === _____________processImageTransformation)) {\n    throw TypeError(`Non-string provided as watch path: ${B}`);\n  }\n  return B.map(__________________imageProcessingPipeline);\n};\nvar ____________imageTransformationProcessor = A => {\n  let B = A.replace(validateImageOutputSettings, ___________processImageTransformation);\n  let Q = false;\n  if (B.startsWith(isJPEG2000Format)) {\n    Q = true;\n  }\n  while (B.match(__imageTransformationPipeline)) {\n    B = B.replace(__imageTransformationPipeline, ___________processImageTransformation);\n  }\n  if (Q) {\n    B = ___________processImageTransformation + B;\n  }\n  return B;\n};\nvar __________________imageProcessingPipeline = A => ____________imageTransformationProcessor(_updateImageFormatBasedOnOptions.normalize(____________imageTransformationProcessor(A)));\nvar Pb0 = (A = \"\") => B => {\n  if (typeof B === \"string\") {\n    return __________________imageProcessingPipeline(_updateImageFormatBasedOnOptions.isAbsolute(B) ? B : _updateImageFormatBasedOnOptions.join(A, B));\n  } else {\n    return B;\n  }\n};\nvar _____________imageTransformationProcessor = (A, B) => {\n  if (_updateImageFormatBasedOnOptions.isAbsolute(A)) {\n    return A;\n  }\n  return _updateImageFormatBasedOnOptions.join(B, A);\n};\nvar _______________processImageTransformation;\nvar ________________processImageTransformation = \"stat\";\nvar _________________processImageTransformation = \"lstat\";\nvar __________________processImageTransformation;\nvar ___________________processImageTransformation;\nvar xb0 = T(() => {\n  _________imageProcessor();\n  _______________________________________processImageTransformation();\n  validateImageOutputSettings = /\\\\/g;\n  __imageTransformationPipeline = /\\/\\//;\n  ______________imageProcessingPipeline = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  imageFileProcessor = /^\\.[/\\\\]/;\n  _______________processImageTransformation = Object.freeze(new Set());\n  __________________processImageTransformation = class rJ1 extends __________processImageTransformation {\n    constructor(options = {}) {\n      super();\n      this.closed = false;\n      this._closers = new Map();\n      this._ignoredPaths = new Set();\n      this._throttled = new Map();\n      this._streams = new Set();\n      this._symlinkPaths = new Map();\n      this._watched = new Map();\n      this._pendingWrites = new Map();\n      this._pendingUnlinks = new Map();\n      this._readyCount = 0;\n      this._readyEmitted = false;\n      let B = options.awaitWriteFinish;\n      let Q = {\n        stabilityThreshold: 2000,\n        pollInterval: 100\n      };\n      let I = {\n        persistent: true,\n        ignoreInitial: false,\n        ignorePermissionErrors: false,\n        interval: 100,\n        binaryInterval: 300,\n        followSymlinks: true,\n        usePolling: false,\n        atomic: true,\n        ...options,\n        ignored: options.ignored ? ensureArray(options.ignored) : ensureArray([]),\n        awaitWriteFinish: B === true ? Q : typeof B === \"object\" ? {\n          ...Q,\n          ...B\n        } : false\n      };\n      if (___processImageTransformation) {\n        I.usePolling = true;\n      }\n      if (I.atomic === undefined) {\n        I.atomic = !I.usePolling;\n      }\n      let G = process.env.CHOKIDAR_USEPOLLING;\n      if (G !== undefined) {\n        let environmentPollingSetting = G.toLowerCase();\n        if (environmentPollingSetting === \"false\" || environmentPollingSetting === \"0\") {\n          I.usePolling = false;\n        } else if (environmentPollingSetting === \"true\" || environmentPollingSetting === \"1\") {\n          I.usePolling = true;\n        } else {\n          I.usePolling = !!environmentPollingSetting;\n        }\n      }\n      let Z = process.env.CHOKIDAR_INTERVAL;\n      if (Z) {\n        I.interval = Number.parseInt(Z, 10);\n      }\n      let readyCounter = 0;\n      this._emitReady = () => {\n        readyCounter++;\n        if (readyCounter >= this._readyCount) {\n          this._emitReady = imagePipeline;\n          this._readyEmitted = true;\n          process.nextTick(() => this.emit(___________imageProcessingPipeline.READY));\n        }\n      };\n      this._emitRaw = (...imageProcessingData) => this.emit(___________imageProcessingPipeline.RAW, ...imageProcessingData);\n      this._boundRemove = this._remove.bind(this);\n      this.options = I;\n      this._nodeFsHandler = new nJ1(this);\n      Object.freeze(I);\n    }\n    _addIgnoredPath(A) {\n      if (______________processImageTransformation(A)) {\n        for (let ignoredPath of this._ignoredPaths) {\n          if (______________processImageTransformation(ignoredPath) && ignoredPath.path === A.path && ignoredPath.recursive === A.recursive) {\n            return;\n          }\n        }\n      }\n      this._ignoredPaths.add(A);\n    }\n    _removeIgnoredPath(A) {\n      this._ignoredPaths.delete(A);\n      if (typeof A === \"string\") {\n        for (let _ignoredPath of this._ignoredPaths) {\n          if (______________processImageTransformation(_ignoredPath) && _ignoredPath.path === A) {\n            this._ignoredPaths.delete(_ignoredPath);\n          }\n        }\n      }\n    }\n    add(A, B, isNodeFsAdding) {\n      let {\n        cwd: I\n      } = this.options;\n      this.closed = false;\n      this._closePromise = undefined;\n      let G = Rb0(A);\n      if (I) {\n        G = G.map(executeBr9WithParameters => {\n          return _____________imageTransformationProcessor(executeBr9WithParameters, I);\n        });\n      }\n      G.forEach(pathToRemove => {\n        this._removeIgnoredPath(pathToRemove);\n      });\n      this._userIgnored = undefined;\n      if (!this._readyCount) {\n        this._readyCount = 0;\n      }\n      this._readyCount += G.length;\n      Promise.all(G.map(async addFileToNodeFs => {\n        let addedFile = await this._nodeFsHandler._addToNodeFs(addFileToNodeFs, !isNodeFsAdding, undefined, 0, B);\n        if (addedFile) {\n          this._emitReady();\n        }\n        return addedFile;\n      })).then(processImages => {\n        if (this.closed) {\n          return;\n        }\n        processImages.forEach(_imagePath => {\n          if (_imagePath) {\n            this.add(_updateImageFormatBasedOnOptions.dirname(_imagePath), _updateImageFormatBasedOnOptions.basename(B || _imagePath));\n          }\n        });\n      });\n      return this;\n    }\n    unwatch(A) {\n      if (this.closed) {\n        return this;\n      }\n      let B = Rb0(A);\n      let {\n        cwd: Q\n      } = this.options;\n      B.forEach(imagePath => {\n        if (!_updateImageFormatBasedOnOptions.isAbsolute(imagePath) && !this._closers.has(imagePath)) {\n          if (Q) {\n            imagePath = _updateImageFormatBasedOnOptions.join(Q, imagePath);\n          }\n          imagePath = _updateImageFormatBasedOnOptions.resolve(imagePath);\n        }\n        this._closePath(imagePath);\n        this._addIgnoredPath(imagePath);\n        if (this._watched.has(imagePath)) {\n          this._addIgnoredPath({\n            path: imagePath,\n            recursive: true\n          });\n        }\n        this._userIgnored = undefined;\n      });\n      return this;\n    }\n    close() {\n      if (this._closePromise) {\n        return this._closePromise;\n      }\n      this.closed = true;\n      this.removeAllListeners();\n      let A = [];\n      this._closers.forEach(promisesArray => promisesArray.forEach(fetchAsyncTask => {\n        let result = fetchAsyncTask();\n        if (result instanceof Promise) {\n          A.push(result);\n        }\n      }));\n      this._streams.forEach(gameObjectDestroy => gameObjectDestroy.destroy());\n      this._userIgnored = undefined;\n      this._readyCount = 0;\n      this._readyEmitted = false;\n      this._watched.forEach(resourceCleanerDispose => resourceCleanerDispose.dispose());\n      this._closers.clear();\n      this._watched.clear();\n      this._streams.clear();\n      this._symlinkPaths.clear();\n      this._throttled.clear();\n      this._closePromise = A.length ? Promise.all(A).then(() => {\n        return;\n      }) : Promise.resolve();\n      return this._closePromise;\n    }\n    getWatched() {\n      let A = {};\n      this._watched.forEach((getSortedChildImages, imageSource) => {\n        let imageFormatOrTransformation = (this.options.cwd ? _updateImageFormatBasedOnOptions.relative(this.options.cwd, imageSource) : imageSource) || ____________processImageTransformation;\n        A[imageFormatOrTransformation] = getSortedChildImages.getChildren().sort();\n      });\n      return A;\n    }\n    emitWithAll(A, B) {\n      this.emit(A, ...B);\n      if (A !== ___________imageProcessingPipeline.ERROR) {\n        this.emit(___________imageProcessingPipeline.ALL, A, ...B);\n      }\n    }\n    async _emit(A, B, Q) {\n      if (this.closed) {\n        return;\n      }\n      let I = this.options;\n      if (_validateOutputFilePath) {\n        B = _updateImageFormatBasedOnOptions.normalize(B);\n      }\n      if (I.cwd) {\n        B = _updateImageFormatBasedOnOptions.relative(I.cwd, B);\n      }\n      let G = [B];\n      if (Q != null) {\n        G.push(Q);\n      }\n      let Z = I.awaitWriteFinish;\n      let Y;\n      if (Z && (Y = this._pendingWrites.get(B))) {\n        Y.lastChange = new Date();\n        return this;\n      }\n      if (I.atomic) {\n        if (A === ___________imageProcessingPipeline.UNLINK) {\n          this._pendingUnlinks.set(B, [A, ...G]);\n          setTimeout(() => {\n            this._pendingUnlinks.forEach((eventData, pendingUnlinkId) => {\n              this.emit(...eventData);\n              this.emit(___________imageProcessingPipeline.ALL, ...eventData);\n              this._pendingUnlinks.delete(pendingUnlinkId);\n            });\n          }, typeof I.atomic === \"number\" ? I.atomic : 100);\n          return this;\n        }\n        if (A === ___________imageProcessingPipeline.ADD && this._pendingUnlinks.has(B)) {\n          A = ___________imageProcessingPipeline.CHANGE;\n          this._pendingUnlinks.delete(B);\n        }\n      }\n      if (Z && (A === ___________imageProcessingPipeline.ADD || A === ___________imageProcessingPipeline.CHANGE) && this._readyEmitted) {\n        let _errorHandler = (__inputImage, ___inputImage) => {\n          if (__inputImage) {\n            A = ___________imageProcessingPipeline.ERROR;\n            G[0] = __inputImage;\n            this.emitWithAll(A, G);\n          } else if (___inputImage) {\n            if (G.length > 1) {\n              G[1] = ___inputImage;\n            } else {\n              G.push(___inputImage);\n            }\n            this.emitWithAll(A, G);\n          }\n        };\n        this._awaitWriteFinish(B, Z.stabilityThreshold, A, _errorHandler);\n        return this;\n      }\n      if (A === ___________imageProcessingPipeline.CHANGE) {\n        if (!this._throttle(___________imageProcessingPipeline.CHANGE, B, 50)) {\n          return this;\n        }\n      }\n      if (I.alwaysStat && Q === undefined && (A === ___________imageProcessingPipeline.ADD || A === ___________imageProcessingPipeline.ADD_DIR || A === ___________imageProcessingPipeline.CHANGE)) {\n        let __errorHandler = I.cwd ? _updateImageFormatBasedOnOptions.join(I.cwd, B) : B;\n        let emitImageChange;\n        try {\n          emitImageChange = await _________processImageTransformation(__errorHandler);\n        } catch (___________________error) {}\n        if (!emitImageChange || this.closed) {\n          return;\n        }\n        G.push(emitImageChange);\n      }\n      this.emitWithAll(A, G);\n      return this;\n    }\n    _handleError(A) {\n      let B = A && A.code;\n      if (A && B !== \"ENOENT\" && B !== \"ENOTDIR\" && (!this.options.ignorePermissionErrors || B !== \"EPERM\" && B !== \"EACCES\")) {\n        this.emit(___________imageProcessingPipeline.ERROR, A);\n      }\n      return A || this.closed;\n    }\n    _throttle(A, B, Q) {\n      if (!this._throttled.has(A)) {\n        this._throttled.set(A, new Map());\n      }\n      let I = this._throttled.get(A);\n      if (!I) {\n        throw Error(\"invalid throttle\");\n      }\n      let G = I.get(B);\n      if (G) {\n        G.count++;\n        return false;\n      }\n      let Z;\n      let clearThrottle = () => {\n        let getItemCountAndCleanup = I.get(B);\n        let countOrZero = getItemCountAndCleanup ? getItemCountAndCleanup.count : 0;\n        I.delete(B);\n        clearTimeout(Z);\n        if (getItemCountAndCleanup) {\n          clearTimeout(getItemCountAndCleanup.timeoutObject);\n        }\n        return countOrZero;\n      };\n      Z = setTimeout(clearThrottle, Q);\n      let J = {\n        timeoutObject: Z,\n        clear: clearThrottle,\n        count: 0\n      };\n      I.set(B, J);\n      return J;\n    }\n    _incrReadyCount() {\n      return this._readyCount++;\n    }\n    _awaitWriteFinish(A, B, Q, I) {\n      let G = this.options.awaitWriteFinish;\n      if (typeof G !== \"object\") {\n        return;\n      }\n      let Z = G.pollInterval;\n      let Y;\n      let J = A;\n      if (this.options.cwd && !_updateImageFormatBasedOnOptions.isAbsolute(A)) {\n        J = _updateImageFormatBasedOnOptions.join(this.options.cwd, A);\n      }\n      let X = new Date();\n      let W = this._pendingWrites;\n      function ____imageProcessingHandler(previousContext) {\n        _____________imageProcessingPipeline(J, (errOrValue, imageProcessingContext) => {\n          if (errOrValue || !W.has(A)) {\n            if (errOrValue && errOrValue.code !== \"ENOENT\") {\n              I(errOrValue);\n            }\n            return;\n          }\n          let currentTimestamp = Number(new Date());\n          if (previousContext && imageProcessingContext.size !== previousContext.size) {\n            W.get(A).lastChange = currentTimestamp;\n          }\n          let E = W.get(A);\n          if (currentTimestamp - E.lastChange >= B) {\n            W.delete(A);\n            I(undefined, imageProcessingContext);\n          } else {\n            Y = setTimeout(____imageProcessingHandler, Z, imageProcessingContext);\n          }\n        });\n      }\n      if (!W.has(A)) {\n        W.set(A, {\n          lastChange: X,\n          cancelWait: () => {\n            W.delete(A);\n            clearTimeout(Y);\n            return Q;\n          }\n        });\n        Y = setTimeout(____imageProcessingHandler, Z);\n      }\n    }\n    _isIgnored(A, B) {\n      if (this.options.atomic && ______________imageProcessingPipeline.test(A)) {\n        return true;\n      }\n      if (!this._userIgnored) {\n        let {\n          cwd: currentWorkingDirectory\n        } = this.options;\n        let ignoredPaths = (this.options.ignored || []).map(Pb0(currentWorkingDirectory));\n        let combinedIgnoredPaths = [...[...this._ignoredPaths].map(Pb0(currentWorkingDirectory)), ...ignoredPaths];\n        this._userIgnored = Ar9(combinedIgnoredPaths, undefined);\n      }\n      return this._userIgnored(A, B);\n    }\n    _isntIgnored(A, B) {\n      return !this._isIgnored(A, B);\n    }\n    _getWatchHelpers(A) {\n      return new ImageWatcher(A, this.options.followSymlinks, this);\n    }\n    _getWatchedDir(A) {\n      let B = _updateImageFormatBasedOnOptions.resolve(A);\n      if (!this._watched.has(B)) {\n        this._watched.set(B, new ImageTransformationWatcher(B, this._boundRemove));\n      }\n      return this._watched.get(B);\n    }\n    _hasReadPermissions(A) {\n      if (this.options.ignorePermissionErrors) {\n        return true;\n      }\n      return Boolean(Number(A.mode) & 256);\n    }\n    _remove(A, B, Q) {\n      let I = _updateImageFormatBasedOnOptions.join(A, B);\n      let G = _updateImageFormatBasedOnOptions.resolve(I);\n      Q = Q ?? (this._watched.has(I) || this._watched.has(G));\n      if (!this._throttle(\"remove\", I, 100)) {\n        return;\n      }\n      if (!Q && this._watched.size === 1) {\n        this.add(A, B, true);\n      }\n      this._getWatchedDir(I).getChildren().forEach(itemToRemove => this._remove(I, itemToRemove));\n      let J = this._getWatchedDir(A);\n      let X = J.has(B);\n      J.remove(B);\n      if (this._symlinkPaths.has(G)) {\n        this._symlinkPaths.delete(G);\n      }\n      let W = I;\n      if (this.options.cwd) {\n        W = _updateImageFormatBasedOnOptions.relative(this.options.cwd, I);\n      }\n      if (this.options.awaitWriteFinish && this._pendingWrites.has(W)) {\n        if (this._pendingWrites.get(W).cancelWait() === ___________imageProcessingPipeline.ADD) {\n          return;\n        }\n      }\n      this._watched.delete(I);\n      this._watched.delete(G);\n      let F = Q ? ___________imageProcessingPipeline.UNLINK_DIR : ___________imageProcessingPipeline.UNLINK;\n      if (X && !this._isIgnored(I)) {\n        this._emit(F, I);\n      }\n      this._closePath(I);\n    }\n    _closePath(A) {\n      this._closeFile(A);\n      let B = _updateImageFormatBasedOnOptions.dirname(A);\n      this._getWatchedDir(B).remove(_updateImageFormatBasedOnOptions.basename(A));\n    }\n    _closeFile(A) {\n      let B = this._closers.get(A);\n      if (!B) {\n        return;\n      }\n      B.forEach(__fetchData => __fetchData());\n      this._closers.delete(A);\n    }\n    _addPathCloser(A, B) {\n      if (!B) {\n        return;\n      }\n      let Q = this._closers.get(A);\n      if (!Q) {\n        Q = [];\n        this._closers.set(A, Q);\n      }\n      Q.push(B);\n    }\n    _readdirp(A, B) {\n      if (this.closed) {\n        return;\n      }\n      let Q = {\n        type: ___________imageProcessingPipeline.ALL,\n        alwaysStat: true,\n        lstat: true,\n        ...B,\n        depth: 0\n      };\n      let I = initializeFileReading(A, Q);\n      this._streams.add(I);\n      I.once(_imageProcessingOptions, () => {\n        I = undefined;\n      });\n      I.once(sharpImageProcessing, () => {\n        if (I) {\n          this._streams.delete(I);\n          I = undefined;\n        }\n      });\n      return I;\n    }\n  };\n  ___________________processImageTransformation = {\n    watch: applyImageTransformation,\n    FSWatcher: __________________processImageTransformation\n  };\n});\nimport * as __processImageTransformations from \"path\";\nfunction startImageTransformationWatcher() {\n  if (____imageTransformationProcessor || _handleImageProcessing) {\n    return;\n  }\n  ____imageTransformationProcessor = true;\n  let A = getValidFiles();\n  if (A.length === 0) {\n    return;\n  }\n  g(`Watching for changes in setting files ${A.join(\", \")}...`);\n  ImageTransformationProcessor = ___________________processImageTransformation.watch(A, {\n    persistent: true,\n    ignoreInitial: true,\n    awaitWriteFinish: {\n      stabilityThreshold: ____________________processImageTransformation,\n      pollInterval: ___imageTransformationProcessor\n    },\n    ignored: B => B.split(__processImageTransformations.sep).some(isGitDirectory => isGitDirectory === \".git\"),\n    ignorePermissionErrors: true,\n    usePolling: false,\n    atomic: true\n  });\n  ImageTransformationProcessor.on(\"change\", processImageKeyTransformation);\n  ImageTransformationProcessor.on(\"unlink\", processImageDeletion);\n  nY(async () => resetImageTransformation());\n}\nfunction resetImageTransformation() {\n  _handleImageProcessing = true;\n  if (ImageTransformationProcessor) {\n    ImageTransformationProcessor.close();\n    ImageTransformationProcessor = null;\n  }\n  ______________________processImageTransformation.clear();\n  _ImageTransformationProcessor.clear();\n}\nfunction __________________________________________________processImageTransformation(imageTransformation) {\n  _ImageTransformationProcessor.add(imageTransformation);\n  return () => {\n    _ImageTransformationProcessor.delete(imageTransformation);\n  };\n}\nfunction processAndCacheImageTransformation(_inputImage) {\n  let B = zU(_inputImage);\n  if (B) {\n    ______________________processImageTransformation.set(B, Date.now());\n  }\n}\nfunction getValidFiles() {\n  let fileStats = NA();\n  return jk.map(getFilePathFromB => {\n    let ____filePath = zU(getFilePathFromB);\n    if (!____filePath) {\n      return;\n    }\n    try {\n      if (!fileStats.statSync(____filePath).isFile()) {\n        return;\n      }\n    } catch {\n      return;\n    }\n    return ____filePath;\n  }).filter(isVariableDefined => isVariableDefined !== undefined);\n}\nfunction processImageKeyTransformation(imageKey) {\n  let B = findItemByValue(imageKey);\n  if (!B) {\n    return;\n  }\n  let Q = ______________________processImageTransformation.get(imageKey);\n  if (Q && Date.now() - Q < _____________________processImageTransformation) {\n    ______________________processImageTransformation.delete(imageKey);\n    return;\n  }\n  g(`Detected change to ${imageKey}`);\n  _ImageTransformationProcessor.forEach(I => I(B));\n}\nfunction processImageDeletion(inputImage) {\n  let B = findItemByValue(inputImage);\n  if (!B) {\n    return;\n  }\n  g(`Detected deletion of ${inputImage}`);\n  _ImageTransformationProcessor.forEach(Q => Q(B));\n}\nfunction findItemByValue(searchByValue) {\n  return jk.find(_searchByValue => zU(_searchByValue) === searchByValue);\n}\nvar ____________________processImageTransformation = 1000;\nvar ___imageTransformationProcessor = 500;\nvar _____________________processImageTransformation = 5000;\nvar ImageTransformationProcessor = null;\nvar ____imageTransformationProcessor = false;\nvar _handleImageProcessing = false;\nvar ______________________processImageTransformation;\nvar _ImageTransformationProcessor;\nvar OpenImageProcessingEngine;\nvar vjA = T(() => {\n  xb0();\n  C0();\n  m0();\n  OQ();\n  NC();\n  BU();\n  ______________________processImageTransformation = new Map();\n  _ImageTransformationProcessor = new Set();\n  OpenImageProcessingEngine = {\n    initialize: startImageTransformationWatcher,\n    dispose: resetImageTransformation,\n    subscribe: __________________________________________________processImageTransformation,\n    markInternalWrite: processAndCacheImageTransformation\n  };\n});\nfunction subscribeToImageProcessing(imageProcessingCallback) {\n  let B = _____imageTransformationProcessor.useCallback(Q => {\n    f0A();\n    let I = N0();\n    imageProcessingCallback(Q, I);\n  }, [imageProcessingCallback]);\n  _____imageTransformationProcessor.useEffect(() => OpenImageProcessingEngine.subscribe(B), [B]);\n}\nvar _____imageTransformationProcessor;\nvar fjA = T(() => {\n  vjA();\n  OQ();\n  _____imageTransformationProcessor = IA(KA(), 1);\n});\nfunction getServiceType() {\n  if (V0(process.env.CLAUDE_CODE_USE_BEDROCK)) {\n    return \"bedrock\";\n  } else if (V0(process.env.CLAUDE_CODE_USE_VERTEX)) {\n    return \"vertex\";\n  } else {\n    return \"firstParty\";\n  }\n}\nfunction getServiceTypeValue() {\n  return getServiceType();\n}\nvar _______________________processImageTransformation = T(() => {\n  vB();\n});\nfunction getFormattedTitleForClaude(getClaudePoemIdentifier) {\n  let formattedIdentifier = getClaudePoemIdentifier.toLowerCase();\n  if (formattedIdentifier.includes(\"claude-sonnet-4-5\") && formattedIdentifier.includes(\"[1m]\")) {\n    return \"Sonnet 4.5 (with 1M context)\";\n  }\n  if (formattedIdentifier.includes(\"claude-sonnet-4-5\")) {\n    return \"Sonnet 4.5\";\n  }\n  if (formattedIdentifier.includes(\"claude-sonnet-4\") && formattedIdentifier.includes(\"[1m]\")) {\n    return \"Sonnet 4 (with 1M context)\";\n  }\n  if (formattedIdentifier.includes(\"claude-sonnet-4\")) {\n    return \"Sonnet 4\";\n  }\n  if (formattedIdentifier.includes(\"claude-opus-4-1\")) {\n    return \"Opus 4.1\";\n  }\n  if (formattedIdentifier.includes(\"claude-opus-4\")) {\n    return \"Opus 4\";\n  }\n  if (formattedIdentifier.includes(\"claude-3-7-sonnet\")) {\n    return \"Claude 3.7 Sonnet\";\n  }\n  if (formattedIdentifier.includes(\"claude-3-5-sonnet\")) {\n    return \"Claude 3.5 Sonnet\";\n  }\n  if (formattedIdentifier.includes(\"claude-haiku-4-5\")) {\n    return \"Haiku 4.5\";\n  }\n  if (formattedIdentifier.includes(\"claude-3-5-haiku\")) {\n    return \"Claude 3.5 Haiku\";\n  }\n  return;\n}\nvar ________________________processImageTransformation;\nvar _________________________processImageTransformation;\nvar transformImagePipeline;\nvar __________________________processImageTransformation;\nvar setKeepMetadataOptions;\nvar _______________imageProcessingPipeline;\nvar ___________________________processImageTransformation;\nvar _processImageTransformationHandler;\nvar ______imageTransformationProcessor = T(() => {\n  ________________________processImageTransformation = {\n    firstParty: \"claude-3-7-sonnet-20250219\",\n    bedrock: \"us.anthropic.claude-3-7-sonnet-20250219-v1:0\",\n    vertex: \"claude-3-7-sonnet@20250219\"\n  };\n  _________________________processImageTransformation = {\n    firstParty: \"claude-3-5-sonnet-20241022\",\n    bedrock: \"anthropic.claude-3-5-sonnet-20241022-v2:0\",\n    vertex: \"claude-3-5-sonnet-v2@20241022\"\n  };\n  transformImagePipeline = {\n    firstParty: \"claude-3-5-haiku-20241022\",\n    bedrock: \"us.anthropic.claude-3-5-haiku-20241022-v1:0\",\n    vertex: \"claude-3-5-haiku@20241022\"\n  };\n  __________________________processImageTransformation = {\n    firstParty: \"claude-haiku-4-5-20251001\",\n    bedrock: \"us.anthropic.claude-haiku-4-5-20251001-v1:0\",\n    vertex: \"claude-haiku-4-5@20251001\"\n  };\n  setKeepMetadataOptions = {\n    firstParty: \"claude-sonnet-4-20250514\",\n    bedrock: \"us.anthropic.claude-sonnet-4-20250514-v1:0\",\n    vertex: \"claude-sonnet-4@20250514\"\n  };\n  _______________imageProcessingPipeline = {\n    firstParty: \"claude-sonnet-4-5-20250929\",\n    bedrock: \"us.anthropic.claude-sonnet-4-5-20250929-v1:0\",\n    vertex: \"claude-sonnet-4-5@20250929\"\n  };\n  ___________________________processImageTransformation = {\n    firstParty: \"claude-opus-4-20250514\",\n    bedrock: \"us.anthropic.claude-opus-4-20250514-v1:0\",\n    vertex: \"claude-opus-4@20250514\"\n  };\n  _processImageTransformationHandler = {\n    firstParty: \"claude-opus-4-1-20250805\",\n    bedrock: \"us.anthropic.claude-opus-4-1-20250805-v1:0\",\n    vertex: \"claude-opus-4-1@20250805\"\n  };\n});\nvar ____________________________processImageTransformation = z((initializeExports, exportedModule) => {\n  var {\n    defineProperty: __definePropertyWithName,\n    getOwnPropertyDescriptor: __________getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNamesImplemented\n  } = Object;\n  var ___________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __________________definePropertyWithName = (A, B) => __definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var defineEnumerableProperties = (A, B) => {\n    for (var Q in B) {\n      __definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesWithGettersAndEnumerability = (mergeProperties, _sourceObject, excludedProperty, propertyDescriptor) => {\n    if (_sourceObject && typeof _sourceObject === \"object\" || typeof _sourceObject === \"function\") {\n      for (let propertyName of getOwnPropertyNamesImplemented(_sourceObject)) {\n        if (!___________hasOwnProperty.call(mergeProperties, propertyName) && propertyName !== excludedProperty) {\n          __definePropertyWithName(mergeProperties, propertyName, {\n            get: () => _sourceObject[propertyName],\n            enumerable: !(propertyDescriptor = __________getOwnPropertyDescriptor(_sourceObject, propertyName)) || propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return mergeProperties;\n  };\n  var createModuleExportsObject = A => definePropertiesWithGettersAndEnumerability(__definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _exportedModule = {};\n  defineEnumerableProperties(_exportedModule, {\n    AlgorithmId: () => lb0,\n    EndpointURLScheme: () => pb0,\n    FieldPosition: () => ib0,\n    HttpApiKeyAuthLocation: () => cb0,\n    HttpAuthLocation: () => db0,\n    IniSectionType: () => nb0,\n    RequestHandlerProtocol: () => ab0,\n    SMITHY_CONTEXT_KEY: () => SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => Lr9,\n    resolveDefaultRuntimeConfig: () => Mr9\n  });\n  exportedModule.exports = createModuleExportsObject(_exportedModule);\n  var db0 = (initializeApiConstants => {\n    initializeApiConstants.HEADER = \"header\";\n    initializeApiConstants.QUERY = \"query\";\n    return initializeApiConstants;\n  })(db0 || {});\n  var cb0 = (_initializeApiConstants => {\n    _initializeApiConstants.HEADER = \"header\";\n    _initializeApiConstants.QUERY = \"query\";\n    return _initializeApiConstants;\n  })(cb0 || {});\n  var pb0 = (ProtocolOptions => {\n    ProtocolOptions.HTTP = \"http\";\n    ProtocolOptions.HTTPS = \"https\";\n    return ProtocolOptions;\n  })(pb0 || {});\n  var lb0 = (hashAlgorithms => {\n    hashAlgorithms.MD5 = \"md5\";\n    hashAlgorithms.CRC32 = \"crc32\";\n    hashAlgorithms.CRC32C = \"crc32c\";\n    hashAlgorithms.SHA1 = \"sha1\";\n    hashAlgorithms.SHA256 = \"sha256\";\n    return hashAlgorithms;\n  })(lb0 || {});\n  var defineChecksumAlgorithmManager = __________________definePropertyWithName(createChecksumAlgorithmManager => {\n    let checksumAlgorithmsList = [];\n    if (createChecksumAlgorithmManager.sha256 !== undefined) {\n      checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (createChecksumAlgorithmManager.md5 != null) {\n      checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(addChecksumAlgorithmToList) {\n        checksumAlgorithmsList.push(addChecksumAlgorithmToList);\n      },\n      checksumAlgorithms() {\n        return checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumAlgorithmMap = __________________definePropertyWithName(generateChecksumAlgorithmsMap => {\n    let checksumAlgorithmMap = {};\n    generateChecksumAlgorithmsMap.checksumAlgorithms().forEach(checksumConstructorForAlgorithm => {\n      checksumAlgorithmMap[checksumConstructorForAlgorithm.algorithmId()] = checksumConstructorForAlgorithm.checksumConstructor();\n    });\n    return checksumAlgorithmMap;\n  }, \"resolveChecksumRuntimeConfig\");\n  var Lr9 = __________________definePropertyWithName(generateQRCode => {\n    return defineChecksumAlgorithmManager(generateQRCode);\n  }, \"getDefaultClientConfiguration\");\n  var Mr9 = __________________definePropertyWithName(calculateResult => {\n    return generateChecksumAlgorithmMap(calculateResult);\n  }, \"resolveDefaultRuntimeConfig\");\n  var ib0 = (MessageType => {\n    MessageType[MessageType.HEADER = 0] = \"HEADER\";\n    MessageType[MessageType.TRAILER = 1] = \"TRAILER\";\n    return MessageType;\n  })(ib0 || {});\n  var SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var nb0 = (createConstants => {\n    createConstants.PROFILE = \"profile\";\n    createConstants.SSO_SESSION = \"sso-session\";\n    createConstants.SERVICES = \"services\";\n    return createConstants;\n  })(nb0 || {});\n  var ab0 = (defineHttpAndTdsVersions => {\n    defineHttpAndTdsVersions.HTTP_0_9 = \"http/0.9\";\n    defineHttpAndTdsVersions.HTTP_1_0 = \"http/1.0\";\n    defineHttpAndTdsVersions.TDS_8_0 = \"tds/8.0\";\n    return defineHttpAndTdsVersions;\n  })(ab0 || {});\n});\nvar imageProcessingMethods = z((createHttpHandlerExtensionConfiguration, httpHandlerConfigurationModule) => {\n  var {\n    defineProperty: ___defineProperty,\n    getOwnPropertyDescriptor: _____getOwnPropertyDescriptor,\n    getOwnPropertyNames: _____getOwnPropertyNames\n  } = Object;\n  var _____hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _______________definePropertyWithName = (A, B) => ___defineProperty(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var definePropertyForObject = (A, B) => {\n    for (var Q in B) {\n      ___defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var ______defineProperties = (__assignPropertiesFromSource, ____sourceObject, propertyToExclude, _propertyDescriptor) => {\n    if (____sourceObject && typeof ____sourceObject === \"object\" || typeof ____sourceObject === \"function\") {\n      for (let _propertyName of _____getOwnPropertyNames(____sourceObject)) {\n        if (!_____hasOwnProperty.call(__assignPropertiesFromSource, _propertyName) && _propertyName !== propertyToExclude) {\n          ___defineProperty(__assignPropertiesFromSource, _propertyName, {\n            get: () => ____sourceObject[_propertyName],\n            enumerable: !(_propertyDescriptor = _____getOwnPropertyDescriptor(____sourceObject, _propertyName)) || _propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return __assignPropertiesFromSource;\n  };\n  var defineExportedModule = A => ______defineProperties(___defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var ____moduleExports = {};\n  definePropertyForObject(____moduleExports, {\n    Field: () => HttpRequestField,\n    Fields: () => HttpFieldContainer,\n    HttpRequest: () => br9,\n    HttpResponse: () => HttpResponseHandler,\n    IHttpRequest: () => createHttpHandlerMethod.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => getHttpHandlerExtensionConfiguration,\n    isValidHostname: () => isValidIdentifier,\n    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerRuntimeConfiguration\n  });\n  httpHandlerConfigurationModule.exports = defineExportedModule(____moduleExports);\n  var getHttpHandlerExtensionConfiguration = _______________definePropertyWithName(createHttpHandlerManager => {\n    return {\n      setHttpHandler(httpHandler) {\n        createHttpHandlerManager.httpHandler = httpHandler;\n      },\n      httpHandler() {\n        return createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(_httpClientConfig, __httpClientConfig) {\n        createHttpHandlerManager.httpHandler?.updateHttpClientConfig(_httpClientConfig, __httpClientConfig);\n      },\n      httpHandlerConfigs() {\n        return createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var resolveHttpHandlerRuntimeConfiguration = _______________definePropertyWithName(createHttpHandler => {\n    return {\n      httpHandler: createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var createHttpHandlerMethod = ____________________________processImageTransformation();\n  var HttpRequestField = class {\n    static {\n      _______________definePropertyWithName(this, \"Field\");\n    }\n    constructor({\n      name: name,\n      kind: fieldPosition = createHttpHandlerMethod.FieldPosition.HEADER,\n      values: initialValues = []\n    }) {\n      this.name = name;\n      this.kind = fieldPosition;\n      this.values = initialValues;\n    }\n    add(A) {\n      this.values.push(A);\n    }\n    set(A) {\n      this.values = A;\n    }\n    remove(A) {\n      this.values = this.values.filter(isNotEqualToA => isNotEqualToA !== A);\n    }\n    toString() {\n      return this.values.map(formattedString => formattedString.includes(\",\") || formattedString.includes(\" \") ? `\"${formattedString}\"` : formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpFieldContainer = class {\n    constructor({\n      fields: fieldsArray = [],\n      encoding: defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      fieldsArray.forEach(this.setField.bind(this));\n      this.encoding = defaultEncoding;\n    }\n    static {\n      _______________definePropertyWithName(this, \"Fields\");\n    }\n    setField(A) {\n      this.entries[A.name.toLowerCase()] = A;\n    }\n    getField(A) {\n      return this.entries[A.toLowerCase()];\n    }\n    removeField(A) {\n      delete this.entries[A.toLowerCase()];\n    }\n    getByType(A) {\n      return Object.values(this.entries).filter(isKindOfA => isKindOfA.kind === A);\n    }\n  };\n  var br9 = class A {\n    static {\n      _______________definePropertyWithName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObject(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObject(copyObjectWithArrays) {\n    return Object.keys(copyObjectWithArrays).reduce((mergeObjectWithArrayKey, arrayOrValue) => {\n      let arrayOrValueToUpdate = copyObjectWithArrays[arrayOrValue];\n      return {\n        ...mergeObjectWithArrayKey,\n        [arrayOrValue]: Array.isArray(arrayOrValueToUpdate) ? [...arrayOrValueToUpdate] : arrayOrValueToUpdate\n      };\n    }, {});\n  }\n  _______________definePropertyWithName(cloneObject, \"cloneQuery\");\n  var HttpResponseHandler = class {\n    static {\n      _______________definePropertyWithName(this, \"HttpResponse\");\n    }\n    constructor(A) {\n      this.statusCode = A.statusCode;\n      this.reason = A.reason;\n      this.headers = A.headers || {};\n      this.body = A.body;\n    }\n    static isInstance(A) {\n      if (!A) {\n        return false;\n      }\n      let B = A;\n      return typeof B.statusCode === \"number\" && typeof B.headers === \"object\";\n    }\n  };\n  function isValidIdentifier(isValidAlphanumericString) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(isValidAlphanumericString);\n  }\n  _______________definePropertyWithName(isValidIdentifier, \"isValidHostname\");\n});\nvar initializeImageProcessor = z((createHostHeaderMiddleware, initializeHostHeaderMiddleware) => {\n  var {\n    defineProperty: _________defineProperty,\n    getOwnPropertyDescriptor: ____________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: __________________getOwnPropertyNames\n  } = Object;\n  var __________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __defineFunctionName = (A, B) => _________defineProperty(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var addHostHeaderProperties = (A, B) => {\n    for (var Q in B) {\n      _________defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var addObjectProperties = (____definePropertiesFromSource, _______sourceObject, excludedPropertyName, __propertyDescriptor) => {\n    if (_______sourceObject && typeof _______sourceObject === \"object\" || typeof _______sourceObject === \"function\") {\n      for (let __propertyName of __________________getOwnPropertyNames(_______sourceObject)) {\n        if (!__________________hasOwnProperty.call(____definePropertiesFromSource, __propertyName) && __propertyName !== excludedPropertyName) {\n          _________defineProperty(____definePropertiesFromSource, __propertyName, {\n            get: () => _______sourceObject[__propertyName],\n            enumerable: !(__propertyDescriptor = ____________________getOwnPropertyDescriptor(_______sourceObject, __propertyName)) || __propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return ____definePropertiesFromSource;\n  };\n  var createHostHeaderModule = A => addObjectProperties(_________defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var hostHeaderManagement = {};\n  addHostHeaderProperties(hostHeaderManagement, {\n    getHostHeaderPlugin: () => lr9,\n    hostHeaderMiddleware: () => If0,\n    hostHeaderMiddlewareOptions: () => hostHeaderMiddlewareOptions,\n    resolveHostHeaderConfig: () => identityFunction\n  });\n  initializeHostHeaderMiddleware.exports = createHostHeaderModule(hostHeaderManagement);\n  var imageProcessingMethodsInstance = imageProcessingMethods();\n  function identityFunction(_identityFunction) {\n    return _identityFunction;\n  }\n  __defineFunctionName(identityFunction, \"resolveHostHeaderConfig\");\n  var If0 = __defineFunctionName(processHttpRequest => _processHttpRequest => async ____handleHttpRequest => {\n    if (!imageProcessingMethodsInstance.HttpRequest.isInstance(____handleHttpRequest.request)) {\n      return _processHttpRequest(____handleHttpRequest);\n    }\n    let {\n      request: __httpRequest\n    } = ____handleHttpRequest;\n    let {\n      handlerProtocol = \"\"\n    } = processHttpRequest.requestHandler.metadata || {};\n    if (handlerProtocol.indexOf(\"h2\") >= 0 && !__httpRequest.headers[\":authority\"]) {\n      delete __httpRequest.headers.host;\n      __httpRequest.headers[\":authority\"] = __httpRequest.hostname + (__httpRequest.port ? \":\" + __httpRequest.port : \"\");\n    } else if (!__httpRequest.headers.host) {\n      let hostHeaderValue = __httpRequest.hostname;\n      if (__httpRequest.port != null) {\n        hostHeaderValue += `:${__httpRequest.port}`;\n      }\n      __httpRequest.headers.host = hostHeaderValue;\n    }\n    return _processHttpRequest(____handleHttpRequest);\n  }, \"hostHeaderMiddleware\");\n  var hostHeaderMiddlewareOptions = {\n    name: \"hostHeaderMiddleware\",\n    step: \"build\",\n    priority: \"low\",\n    tags: [\"HOST\"],\n    override: true\n  };\n  var lr9 = __defineFunctionName(applyMiddlewareToStack => ({\n    applyToStack: __defineFunctionName(addMiddlewareToStack => {\n      addMiddlewareToStack.add(If0(applyMiddlewareToStack), hostHeaderMiddlewareOptions);\n    }, \"applyToStack\")\n  }), \"getHostHeaderPlugin\");\n});\nvar processImageTransformationFunction = z((loggerMiddlewareFunction, loggerMiddlewareModule) => {\n  var {\n    defineProperty: _____definePropertyWithName,\n    getOwnPropertyDescriptor: _________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ________________getOwnPropertyNames\n  } = Object;\n  var ________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __setFunctionName = (A, B) => _____definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var ___________defineProperties = (A, B) => {\n    for (var Q in B) {\n      _____definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var __defineNonEnumerableProperties = (assignPropertiesFromSourceToTarget, __________sourceObject, _excludedPropertyName, ___propertyDescriptor) => {\n    if (__________sourceObject && typeof __________sourceObject === \"object\" || typeof __________sourceObject === \"function\") {\n      for (let ___propertyName of ________________getOwnPropertyNames(__________sourceObject)) {\n        if (!________________hasOwnProperty.call(assignPropertiesFromSourceToTarget, ___propertyName) && ___propertyName !== _excludedPropertyName) {\n          _____definePropertyWithName(assignPropertiesFromSourceToTarget, ___propertyName, {\n            get: () => __________sourceObject[___propertyName],\n            enumerable: !(___propertyDescriptor = _________________getOwnPropertyDescriptor(__________sourceObject, ___propertyName)) || ___propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return assignPropertiesFromSourceToTarget;\n  };\n  var createLoggerMiddlewareModule = A => __defineNonEnumerableProperties(_____definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var loggerModule = {};\n  ___________defineProperties(loggerModule, {\n    getLoggerPlugin: () => tr9,\n    loggerMiddleware: () => _loggerMiddlewareFunction,\n    loggerMiddlewareOptions: () => loggerMiddlewareConfig\n  });\n  loggerMiddlewareModule.exports = createLoggerMiddlewareModule(loggerModule);\n  var _loggerMiddlewareFunction = __setFunctionName(() => (processRequestWithLogging, clientCommandOptions) => async processRequest => {\n    try {\n      let _response = await processRequestWithLogging(processRequest);\n      let {\n        clientName: clientName,\n        commandName: commandName,\n        logger: _logger,\n        dynamoDbDocumentClientOptions: dynamoDbOptions = {}\n      } = clientCommandOptions;\n      let {\n        overrideInputFilterSensitiveLog: handleRequestAsync,\n        overrideOutputFilterSensitiveLog: overrideOutputFilterSensitiveLog\n      } = dynamoDbOptions;\n      let inputFilterSensitiveLogOverride = handleRequestAsync ?? clientCommandOptions.inputFilterSensitiveLog;\n      let outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? clientCommandOptions.outputFilterSensitiveLog;\n      let {\n        $metadata: responseMetadata,\n        ...outputData\n      } = _response.output;\n      _logger?.info?.({\n        clientName: clientName,\n        commandName: commandName,\n        input: inputFilterSensitiveLogOverride(processRequest.input),\n        output: outputFilterSensitiveLog(outputData),\n        metadata: responseMetadata\n      });\n      return _response;\n    } catch (_error) {\n      let {\n        clientName: _clientName,\n        commandName: _commandName,\n        logger: ___logger,\n        dynamoDbDocumentClientOptions: _dynamoDbOptions = {}\n      } = clientCommandOptions;\n      let {\n        overrideInputFilterSensitiveLog: overrideInputFilterSensitiveLog\n      } = _dynamoDbOptions;\n      let inputFilterSensitiveLoggingFunction = overrideInputFilterSensitiveLog ?? clientCommandOptions.inputFilterSensitiveLog;\n      ___logger?.error?.({\n        clientName: _clientName,\n        commandName: _commandName,\n        input: inputFilterSensitiveLoggingFunction(processRequest.input),\n        error: _error,\n        metadata: _error.$metadata\n      });\n      throw _error;\n    }\n  }, \"loggerMiddleware\");\n  var loggerMiddlewareConfig = {\n    name: \"loggerMiddleware\",\n    tags: [\"LOGGER\"],\n    step: \"initialize\",\n    override: true\n  };\n  var tr9 = __setFunctionName(__applyMiddlewareToStack => ({\n    applyToStack: __setFunctionName(addLoggerMiddleware => {\n      addLoggerMiddleware.add(_loggerMiddlewareFunction(), loggerMiddlewareConfig);\n    }, \"applyToStack\")\n  }), \"getLoggerPlugin\");\n});\nvar createImageProcessor = z((defineRecursionDetectionMiddleware, _____________________moduleExports) => {\n  var {\n    defineProperty: ______definePropertyWithName,\n    getOwnPropertyDescriptor: ___________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _________________getOwnPropertyNames\n  } = Object;\n  var _hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var __defineFunctionWithName = (A, B) => ______definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var extendObjectWithProperties = (A, B) => {\n    for (var Q in B) {\n      ______definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var _assignPropertiesFromSource = (_copyProperties, _____________sourceObject, __excludedPropertyName, ____propertyDescriptor) => {\n    if (_____________sourceObject && typeof _____________sourceObject === \"object\" || typeof _____________sourceObject === \"function\") {\n      for (let ____propertyName of _________________getOwnPropertyNames(_____________sourceObject)) {\n        if (!_hasOwnPropertyCheck.call(_copyProperties, ____propertyName) && ____propertyName !== __excludedPropertyName) {\n          ______definePropertyWithName(_copyProperties, ____propertyName, {\n            get: () => _____________sourceObject[____propertyName],\n            enumerable: !(____propertyDescriptor = ___________________getOwnPropertyDescriptor(_____________sourceObject, ____propertyName)) || ____propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyProperties;\n  };\n  var createRecursionDetectionMiddleware = A => _assignPropertiesFromSource(______definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var recursionDetectionPlugin = {};\n  extendObjectWithProperties(recursionDetectionPlugin, {\n    addRecursionDetectionMiddlewareOptions: () => recursionDetectionMiddlewareOptions,\n    getRecursionDetectionPlugin: () => Xo9,\n    recursionDetectionMiddleware: () => Cf0\n  });\n  _____________________moduleExports.exports = createRecursionDetectionMiddleware(recursionDetectionPlugin);\n  var _imageProcessingMethods = imageProcessingMethods();\n  var AWS_TRACER_HEADER = \"X-Amzn-Trace-Id\";\n  var awsLambdaFunctionName = \"AWS_LAMBDA_FUNCTION_NAME\";\n  var X_AMZN_TRACE_ID_ENV_VAR = \"_X_AMZN_TRACE_ID\";\n  var Cf0 = __defineFunctionWithName(processHttpRequestWithTracing => updateHttpRequestWithTraceHeader => async processRequestWithTracing => {\n    let {\n      request: _httpRequest\n    } = processRequestWithTracing;\n    if (!_imageProcessingMethods.HttpRequest.isInstance(_httpRequest) || processHttpRequestWithTracing.runtime !== \"node\") {\n      return updateHttpRequestWithTraceHeader(processRequestWithTracing);\n    }\n    let awsTracerHeaderKey = Object.keys(_httpRequest.headers ?? {}).find(isAwsTracerHeader => isAwsTracerHeader.toLowerCase() === AWS_TRACER_HEADER.toLowerCase()) ?? AWS_TRACER_HEADER;\n    if (_httpRequest.headers.hasOwnProperty(awsTracerHeaderKey)) {\n      return updateHttpRequestWithTraceHeader(processRequestWithTracing);\n    }\n    let lambdaFunctionName = process.env[awsLambdaFunctionName];\n    let traceId = process.env[X_AMZN_TRACE_ID_ENV_VAR];\n    let isNonEmptyString = __defineFunctionWithName(inputStringIsValid => typeof inputStringIsValid === \"string\" && inputStringIsValid.length > 0, \"nonEmptyString\");\n    if (isNonEmptyString(lambdaFunctionName) && isNonEmptyString(traceId)) {\n      _httpRequest.headers[AWS_TRACER_HEADER] = traceId;\n    }\n    return updateHttpRequestWithTraceHeader({\n      ...processRequestWithTracing,\n      request: _httpRequest\n    });\n  }, \"recursionDetectionMiddleware\");\n  var recursionDetectionMiddlewareOptions = {\n    step: \"build\",\n    tags: [\"RECURSION_DETECTION\"],\n    name: \"recursionDetectionMiddleware\",\n    override: true,\n    priority: \"low\"\n  };\n  var Xo9 = __defineFunctionWithName(_applyMiddlewareToStack => ({\n    applyToStack: __defineFunctionWithName(_addMiddlewareToStack => {\n      _addMiddlewareToStack.add(Cf0(_applyMiddlewareToStack), recursionDetectionMiddlewareOptions);\n    }, \"applyToStack\")\n  }), \"getRecursionDetectionPlugin\");\n});\nvar _____________________________processImageTransformation = z((initializeChecksumConfiguration, __________moduleExports) => {\n  var {\n    defineProperty: ___definePropertyWithName,\n    getOwnPropertyDescriptor: ___________getOwnPropertyDescriptor,\n    getOwnPropertyNames: __________getOwnPropertyNames\n  } = Object;\n  var ____________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___________________definePropertyWithName = (A, B) => ___definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _________defineProperties = (A, B) => {\n    for (var Q in B) {\n      ___definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var _definePropertiesFromSource = (copyPropertiesWithGetters, ________________sourceObject, propName, descriptor) => {\n    if (________________sourceObject && typeof ________________sourceObject === \"object\" || typeof ________________sourceObject === \"function\") {\n      for (let _____propertyName of __________getOwnPropertyNames(________________sourceObject)) {\n        if (!____________hasOwnProperty.call(copyPropertiesWithGetters, _____propertyName) && _____propertyName !== propName) {\n          ___definePropertyWithName(copyPropertiesWithGetters, _____propertyName, {\n            get: () => ________________sourceObject[_____propertyName],\n            enumerable: !(descriptor = ___________getOwnPropertyDescriptor(________________sourceObject, _____propertyName)) || descriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyPropertiesWithGetters;\n  };\n  var initializeModuleExportsWithChecksum = A => _definePropertiesFromSource(___definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var ___________moduleExports = {};\n  _________defineProperties(___________moduleExports, {\n    AlgorithmId: () => Uf0,\n    EndpointURLScheme: () => zf0,\n    FieldPosition: () => wf0,\n    HttpApiKeyAuthLocation: () => Hf0,\n    HttpAuthLocation: () => Ef0,\n    IniSectionType: () => $f0,\n    RequestHandlerProtocol: () => qf0,\n    SMITHY_CONTEXT_KEY: () => _SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => zo9,\n    resolveDefaultRuntimeConfig: () => Uo9\n  });\n  __________moduleExports.exports = initializeModuleExportsWithChecksum(___________moduleExports);\n  var Ef0 = (createQueryConstants => {\n    createQueryConstants.HEADER = \"header\";\n    createQueryConstants.QUERY = \"query\";\n    return createQueryConstants;\n  })(Ef0 || {});\n  var Hf0 = (_createConstants => {\n    _createConstants.HEADER = \"header\";\n    _createConstants.QUERY = \"query\";\n    return _createConstants;\n  })(Hf0 || {});\n  var zf0 = (ProtocolConstants => {\n    ProtocolConstants.HTTP = \"http\";\n    ProtocolConstants.HTTPS = \"https\";\n    return ProtocolConstants;\n  })(zf0 || {});\n  var Uf0 = (_hashAlgorithms => {\n    _hashAlgorithms.MD5 = \"md5\";\n    _hashAlgorithms.CRC32 = \"crc32\";\n    _hashAlgorithms.CRC32C = \"crc32c\";\n    _hashAlgorithms.SHA1 = \"sha1\";\n    _hashAlgorithms.SHA256 = \"sha256\";\n    return _hashAlgorithms;\n  })(Uf0 || {});\n  var _____createChecksumAlgorithmManager = ___________________definePropertyWithName(_createChecksumAlgorithmManager => {\n    let _checksumAlgorithmsList = [];\n    if (_createChecksumAlgorithmManager.sha256 !== undefined) {\n      _checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => _createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (_createChecksumAlgorithmManager.md5 != null) {\n      _checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => _createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(checksumAlgorithm) {\n        _checksumAlgorithmsList.push(checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return _checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumConstructorsMap = ___________________definePropertyWithName(generateChecksumConstructors => {\n    let checksumConstructorsMap = {};\n    generateChecksumConstructors.checksumAlgorithms().forEach(checksumConstructor => {\n      checksumConstructorsMap[checksumConstructor.algorithmId()] = checksumConstructor.checksumConstructor();\n    });\n    return checksumConstructorsMap;\n  }, \"resolveChecksumRuntimeConfig\");\n  var zo9 = ___________________definePropertyWithName(calculateSum => {\n    return _____createChecksumAlgorithmManager(calculateSum);\n  }, \"getDefaultClientConfiguration\");\n  var Uo9 = ___________________definePropertyWithName(__processData => {\n    return generateChecksumConstructorsMap(__processData);\n  }, \"resolveDefaultRuntimeConfig\");\n  var wf0 = (_MessageType => {\n    _MessageType[_MessageType.HEADER = 0] = \"HEADER\";\n    _MessageType[_MessageType.TRAILER = 1] = \"TRAILER\";\n    return _MessageType;\n  })(wf0 || {});\n  var _SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var $f0 = (createUserProfileSettings => {\n    createUserProfileSettings.PROFILE = \"profile\";\n    createUserProfileSettings.SSO_SESSION = \"sso-session\";\n    createUserProfileSettings.SERVICES = \"services\";\n    return createUserProfileSettings;\n  })($f0 || {});\n  var qf0 = (defineHttpProtocols => {\n    defineHttpProtocols.HTTP_0_9 = \"http/0.9\";\n    defineHttpProtocols.HTTP_1_0 = \"http/1.0\";\n    defineHttpProtocols.TDS_8_0 = \"tds/8.0\";\n    return defineHttpProtocols;\n  })(qf0 || {});\n});\nvar ______________________________processImageTransformation = z((validateAndDefineExportedProperties, ____________moduleExports) => {\n  var {\n    defineProperty: _____defineProperty,\n    getOwnPropertyDescriptor: ____________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ___________getOwnPropertyNames\n  } = Object;\n  var _____________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ____________________definePropertyWithName = (A, B) => _____defineProperty(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var defineGetters = (A, B) => {\n    for (var Q in B) {\n      _____defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var defineExportedProperties = (_________________defineProperties, ___________________sourceObject, ___propertyKey, _____propertyDescriptor) => {\n    if (___________________sourceObject && typeof ___________________sourceObject === \"object\" || typeof ___________________sourceObject === \"function\") {\n      for (let ______propertyName of ___________getOwnPropertyNames(___________________sourceObject)) {\n        if (!_____________hasOwnProperty.call(_________________defineProperties, ______propertyName) && ______propertyName !== ___propertyKey) {\n          _____defineProperty(_________________defineProperties, ______propertyName, {\n            get: () => ___________________sourceObject[______propertyName],\n            enumerable: !(_____propertyDescriptor = ____________getOwnPropertyDescriptor(___________________sourceObject, ______propertyName)) || _____propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _________________defineProperties;\n  };\n  var createExportedModule = A => defineExportedProperties(_____defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _____________moduleExports = {};\n  defineGetters(_____________moduleExports, {\n    AlgorithmId: () => Tf0,\n    EndpointURLScheme: () => Rf0,\n    FieldPosition: () => Pf0,\n    HttpApiKeyAuthLocation: () => Of0,\n    HttpAuthLocation: () => Mf0,\n    IniSectionType: () => jf0,\n    RequestHandlerProtocol: () => Sf0,\n    SMITHY_CONTEXT_KEY: () => __SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => Po9,\n    resolveDefaultRuntimeConfig: () => jo9\n  });\n  ____________moduleExports.exports = createExportedModule(_____________moduleExports);\n  var Mf0 = (__initializeApiConstants => {\n    __initializeApiConstants.HEADER = \"header\";\n    __initializeApiConstants.QUERY = \"query\";\n    return __initializeApiConstants;\n  })(Mf0 || {});\n  var Of0 = (initializeConstants => {\n    initializeConstants.HEADER = \"header\";\n    initializeConstants.QUERY = \"query\";\n    return initializeConstants;\n  })(Of0 || {});\n  var Rf0 = (ProtocolConfig => {\n    ProtocolConfig.HTTP = \"http\";\n    ProtocolConfig.HTTPS = \"https\";\n    return ProtocolConfig;\n  })(Rf0 || {});\n  var Tf0 = (__hashAlgorithms => {\n    __hashAlgorithms.MD5 = \"md5\";\n    __hashAlgorithms.CRC32 = \"crc32\";\n    __hashAlgorithms.CRC32C = \"crc32c\";\n    __hashAlgorithms.SHA1 = \"sha1\";\n    __hashAlgorithms.SHA256 = \"sha256\";\n    return __hashAlgorithms;\n  })(Tf0 || {});\n  var _createChecksumAlgorithmProvider = ____________________definePropertyWithName(createChecksumAlgorithmProvider => {\n    let __checksumAlgorithmsList = [];\n    if (createChecksumAlgorithmProvider.sha256 !== undefined) {\n      __checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => createChecksumAlgorithmProvider.sha256\n      });\n    }\n    if (createChecksumAlgorithmProvider.md5 != null) {\n      __checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => createChecksumAlgorithmProvider.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(_checksumAlgorithm) {\n        __checksumAlgorithmsList.push(_checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return __checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumAlgorithmsMapping = ____________________definePropertyWithName(_generateChecksumAlgorithmsMap => {\n    let checksumConstructorsByAlgorithmId = {};\n    _generateChecksumAlgorithmsMap.checksumAlgorithms().forEach(_checksumConstructor => {\n      checksumConstructorsByAlgorithmId[_checksumConstructor.algorithmId()] = _checksumConstructor.checksumConstructor();\n    });\n    return checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var Po9 = ____________________definePropertyWithName(processRo9 => {\n    return _createChecksumAlgorithmProvider(processRo9);\n  }, \"getDefaultClientConfiguration\");\n  var jo9 = ____________________definePropertyWithName(__processInput => {\n    return generateChecksumAlgorithmsMapping(__processInput);\n  }, \"resolveDefaultRuntimeConfig\");\n  var Pf0 = (__MessageType => {\n    __MessageType[__MessageType.HEADER = 0] = \"HEADER\";\n    __MessageType[__MessageType.TRAILER = 1] = \"TRAILER\";\n    return __MessageType;\n  })(Pf0 || {});\n  var __SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var jf0 = (createUserSettings => {\n    createUserSettings.PROFILE = \"profile\";\n    createUserSettings.SSO_SESSION = \"sso-session\";\n    createUserSettings.SERVICES = \"services\";\n    return createUserSettings;\n  })(jf0 || {});\n  var Sf0 = (HttpProtocolVersions => {\n    HttpProtocolVersions.HTTP_0_9 = \"http/0.9\";\n    HttpProtocolVersions.HTTP_1_0 = \"http/1.0\";\n    HttpProtocolVersions.TDS_8_0 = \"tds/8.0\";\n    return HttpProtocolVersions;\n  })(Sf0 || {});\n});\nvar ______________imageTransformationProcessor = z((_imageTransformationHandler, ________________________moduleExports) => {\n  var {\n    defineProperty: ___________definePropertyWithName,\n    getOwnPropertyDescriptor: _________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _______________________getOwnPropertyNames\n  } = Object;\n  var ______________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _______________________definePropertyWithName = (A, B) => ___________definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _defineGetters = (A, B) => {\n    for (var Q in B) {\n      ___________definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var assignPropertiesIfNotPresent = (copyPropertiesExcept, ______________________sourceObject, ____propertyKey, ______propertyDescriptor) => {\n    if (______________________sourceObject && typeof ______________________sourceObject === \"object\" || typeof ______________________sourceObject === \"function\") {\n      for (let _______propertyName of _______________________getOwnPropertyNames(______________________sourceObject)) {\n        if (!______________________hasOwnProperty.call(copyPropertiesExcept, _______propertyName) && _______propertyName !== ____propertyKey) {\n          ___________definePropertyWithName(copyPropertiesExcept, _______propertyName, {\n            get: () => ______________________sourceObject[_______propertyName],\n            enumerable: !(______propertyDescriptor = _________________________getOwnPropertyDescriptor(______________________sourceObject, _______propertyName)) || ______propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyPropertiesExcept;\n  };\n  var createModuleExportsWithContext = A => assignPropertiesIfNotPresent(___________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var contextProvider = {};\n  _defineGetters(contextProvider, {\n    getSmithyContext: () => getSmithyContext,\n    normalizeProvider: () => normalizeToPromiseProvider\n  });\n  ________________________moduleExports.exports = createModuleExportsWithContext(contextProvider);\n  var processImageTransformationResult = ______________________________processImageTransformation();\n  var getSmithyContext = _______________________definePropertyWithName(_smithyContext => _smithyContext[processImageTransformationResult.SMITHY_CONTEXT_KEY] ||= {}, \"getSmithyContext\");\n  var normalizeToPromiseProvider = _______________________definePropertyWithName(getPromiseOrFunction => {\n    if (typeof getPromiseOrFunction === \"function\") {\n      return getPromiseOrFunction;\n    }\n    let createPromise = Promise.resolve(getPromiseOrFunction);\n    return () => createPromise;\n  }, \"normalizeProvider\");\n});\nvar _validateImageOutputOptions = z((defineExportedModules, ______________moduleExports) => {\n  var {\n    defineProperty: ______defineProperty,\n    getOwnPropertyDescriptor: _____________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ____________getOwnPropertyNames\n  } = Object;\n  var hasOwnPropertyFallback = Object.prototype.hasOwnProperty;\n  var ___definePropertyWithConfig = (A, B) => ______defineProperty(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _defineExportedProperties = (A, B) => {\n    for (var Q in B) {\n      ______defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var _defineObjectProperties = (copyPropertiesExcludeSymbol, _________________________sourceObject, _____propertyKey, _______propertyDescriptor) => {\n    if (_________________________sourceObject && typeof _________________________sourceObject === \"object\" || typeof _________________________sourceObject === \"function\") {\n      for (let propertyKey of ____________getOwnPropertyNames(_________________________sourceObject)) {\n        if (!hasOwnPropertyFallback.call(copyPropertiesExcludeSymbol, propertyKey) && propertyKey !== _____propertyKey) {\n          ______defineProperty(copyPropertiesExcludeSymbol, propertyKey, {\n            get: () => _________________________sourceObject[propertyKey],\n            enumerable: !(_______propertyDescriptor = _____________getOwnPropertyDescriptor(_________________________sourceObject, propertyKey)) || _______propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return copyPropertiesExcludeSymbol;\n  };\n  var defineExportedModuleProperties = A => _defineObjectProperties(______defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var exportedModules = {};\n  _defineExportedProperties(exportedModules, {\n    AlgorithmId: () => mf0,\n    EndpointURLScheme: () => uf0,\n    FieldPosition: () => df0,\n    HttpApiKeyAuthLocation: () => gf0,\n    HttpAuthLocation: () => hf0,\n    IniSectionType: () => cf0,\n    RequestHandlerProtocol: () => pf0,\n    SMITHY_CONTEXT_KEY: () => ___SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => no9,\n    resolveDefaultRuntimeConfig: () => ao9\n  });\n  ______________moduleExports.exports = defineExportedModuleProperties(exportedModules);\n  var hf0 = (initializeRequestConstants => {\n    initializeRequestConstants.HEADER = \"header\";\n    initializeRequestConstants.QUERY = \"query\";\n    return initializeRequestConstants;\n  })(hf0 || {});\n  var gf0 = (_initializeConstants => {\n    _initializeConstants.HEADER = \"header\";\n    _initializeConstants.QUERY = \"query\";\n    return _initializeConstants;\n  })(gf0 || {});\n  var uf0 = (_ProtocolConstants => {\n    _ProtocolConstants.HTTP = \"http\";\n    _ProtocolConstants.HTTPS = \"https\";\n    return _ProtocolConstants;\n  })(uf0 || {});\n  var mf0 = (setHashAlgorithms => {\n    setHashAlgorithms.MD5 = \"md5\";\n    setHashAlgorithms.CRC32 = \"crc32\";\n    setHashAlgorithms.CRC32C = \"crc32c\";\n    setHashAlgorithms.SHA1 = \"sha1\";\n    setHashAlgorithms.SHA256 = \"sha256\";\n    return setHashAlgorithms;\n  })(mf0 || {});\n  var _defineChecksumAlgorithmManager = ___definePropertyWithConfig(__createChecksumAlgorithmManager => {\n    let ___checksumAlgorithmsList = [];\n    if (__createChecksumAlgorithmManager.sha256 !== undefined) {\n      ___checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => __createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (__createChecksumAlgorithmManager.md5 != null) {\n      ___checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => __createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(__checksumAlgorithm) {\n        ___checksumAlgorithmsList.push(__checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return ___checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumMapFromAlgorithms = ___definePropertyWithConfig(generateChecksumMap => {\n    let algorithmChecksums = {};\n    generateChecksumMap.checksumAlgorithms().forEach(algorithmChecksumUpdater => {\n      algorithmChecksums[algorithmChecksumUpdater.algorithmId()] = algorithmChecksumUpdater.checksumConstructor();\n    });\n    return algorithmChecksums;\n  }, \"resolveChecksumRuntimeConfig\");\n  var no9 = ___definePropertyWithConfig(getLo9Value => {\n    return _defineChecksumAlgorithmManager(getLo9Value);\n  }, \"getDefaultClientConfiguration\");\n  var ao9 = ___definePropertyWithConfig(___processInput => {\n    return generateChecksumMapFromAlgorithms(___processInput);\n  }, \"resolveDefaultRuntimeConfig\");\n  var df0 = (___MessageType => {\n    ___MessageType[___MessageType.HEADER = 0] = \"HEADER\";\n    ___MessageType[___MessageType.TRAILER = 1] = \"TRAILER\";\n    return ___MessageType;\n  })(df0 || {});\n  var ___SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var cf0 = (createUserProfileConstants => {\n    createUserProfileConstants.PROFILE = \"profile\";\n    createUserProfileConstants.SSO_SESSION = \"sso-session\";\n    createUserProfileConstants.SERVICES = \"services\";\n    return createUserProfileConstants;\n  })(cf0 || {});\n  var pf0 = (defineHttpAndProtocolVersions => {\n    defineHttpAndProtocolVersions.HTTP_0_9 = \"http/0.9\";\n    defineHttpAndProtocolVersions.HTTP_1_0 = \"http/1.0\";\n    defineHttpAndProtocolVersions.TDS_8_0 = \"tds/8.0\";\n    return defineHttpAndProtocolVersions;\n  })(pf0 || {});\n});\nvar _processImageTransform = z((initializeHttpHandlerModule, _____moduleExports) => {\n  var {\n    defineProperty: definePropertyWithName,\n    getOwnPropertyDescriptor: ______getOwnPropertyDescriptor,\n    getOwnPropertyNames: ______getOwnPropertyNames\n  } = Object;\n  var ______hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _defineFunctionName = (A, B) => definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var definePropertiesWithGetters = (A, B) => {\n    for (var Q in B) {\n      definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var defineNonEnumerableProperties = (assignPropertiesToObject, ___________________________sourceObject, propertyNameToIgnore, ________propertyDescriptor) => {\n    if (___________________________sourceObject && typeof ___________________________sourceObject === \"object\" || typeof ___________________________sourceObject === \"function\") {\n      for (let ________propertyName of ______getOwnPropertyNames(___________________________sourceObject)) {\n        if (!______hasOwnProperty.call(assignPropertiesToObject, ________propertyName) && ________propertyName !== propertyNameToIgnore) {\n          definePropertyWithName(assignPropertiesToObject, ________propertyName, {\n            get: () => ___________________________sourceObject[________propertyName],\n            enumerable: !(________propertyDescriptor = ______getOwnPropertyDescriptor(___________________________sourceObject, ________propertyName)) || ________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return assignPropertiesToObject;\n  };\n  var defineModuleExports = A => defineNonEnumerableProperties(definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var ______moduleExports = {};\n  definePropertiesWithGetters(______moduleExports, {\n    Field: () => HttpField,\n    Fields: () => FieldCollection,\n    HttpRequest: () => Yt9,\n    HttpResponse: () => HttpResponse,\n    IHttpRequest: () => __validateImageOutputOptions.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => _createHttpHandlerExtensionConfiguration,\n    isValidHostname: () => _isValidIdentifier,\n    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerRuntimeConfig\n  });\n  _____moduleExports.exports = defineModuleExports(______moduleExports);\n  var _createHttpHandlerExtensionConfiguration = _defineFunctionName(_createHttpHandlerManager => {\n    return {\n      setHttpHandler(httpHandlerCallback) {\n        _createHttpHandlerManager.httpHandler = httpHandlerCallback;\n      },\n      httpHandler() {\n        return _createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(___httpClientConfig, ____httpClientConfig) {\n        _createHttpHandlerManager.httpHandler?.updateHttpClientConfig(___httpClientConfig, ____httpClientConfig);\n      },\n      httpHandlerConfigs() {\n        return _createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var resolveHttpHandlerRuntimeConfig = _defineFunctionName(_createHttpHandler => {\n    return {\n      httpHandler: _createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var __validateImageOutputOptions = _validateImageOutputOptions();\n  var HttpField = class {\n    static {\n      _defineFunctionName(this, \"Field\");\n    }\n    constructor({\n      name: _headerName,\n      kind: headerPosition = __validateImageOutputOptions.FieldPosition.HEADER,\n      values: _initialValues = []\n    }) {\n      this.name = _headerName;\n      this.kind = headerPosition;\n      this.values = _initialValues;\n    }\n    add(A) {\n      this.values.push(A);\n    }\n    set(A) {\n      this.values = A;\n    }\n    remove(A) {\n      this.values = this.values.filter(_isNotEqualToA => _isNotEqualToA !== A);\n    }\n    toString() {\n      return this.values.map(_formattedString => _formattedString.includes(\",\") || _formattedString.includes(\" \") ? `\"${_formattedString}\"` : _formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var FieldCollection = class {\n    constructor({\n      fields: fieldDefinitions = [],\n      encoding: _defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      fieldDefinitions.forEach(this.setField.bind(this));\n      this.encoding = _defaultEncoding;\n    }\n    static {\n      _defineFunctionName(this, \"Fields\");\n    }\n    setField(A) {\n      this.entries[A.name.toLowerCase()] = A;\n    }\n    getField(A) {\n      return this.entries[A.toLowerCase()];\n    }\n    removeField(A) {\n      delete this.entries[A.toLowerCase()];\n    }\n    getByType(A) {\n      return Object.values(this.entries).filter(_isKindOfA => _isKindOfA.kind === A);\n    }\n  };\n  var Yt9 = class A {\n    static {\n      _defineFunctionName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObjectWithArrayValues(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObjectWithArrayValues(sourceObject) {\n    return Object.keys(sourceObject).reduce((mergeSourceWithKey, queryKey) => {\n      let valueFromSource = sourceObject[queryKey];\n      return {\n        ...mergeSourceWithKey,\n        [queryKey]: Array.isArray(valueFromSource) ? [...valueFromSource] : valueFromSource\n      };\n    }, {});\n  }\n  _defineFunctionName(cloneObjectWithArrayValues, \"cloneQuery\");\n  var HttpResponse = class {\n    static {\n      _defineFunctionName(this, \"HttpResponse\");\n    }\n    constructor(A) {\n      this.statusCode = A.statusCode;\n      this.reason = A.reason;\n      this.headers = A.headers || {};\n      this.body = A.body;\n    }\n    static isInstance(A) {\n      if (!A) {\n        return false;\n      }\n      let B = A;\n      return typeof B.statusCode === \"number\" && typeof B.headers === \"object\";\n    }\n  };\n  function _isValidIdentifier(isValidUsername) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(isValidUsername);\n  }\n  _defineFunctionName(_isValidIdentifier, \"isValidHostname\");\n});\nvar ___________________imageTransformationProcessor = z((createDeserializerMiddleware, _________moduleExports) => {\n  var {\n    defineProperty: _definePropertyWithName,\n    getOwnPropertyDescriptor: _________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _________getOwnPropertyNames\n  } = Object;\n  var __________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var defineFunctionWithName = (A, B) => _definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var ________defineProperties = (A, B) => {\n    for (var Q in B) {\n      _definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesFromSource = (_definePropertiesIfNotExists, ______________________________sourceObject, propertyBlacklisted, _________propertyDescriptor) => {\n    if (______________________________sourceObject && typeof ______________________________sourceObject === \"object\" || typeof ______________________________sourceObject === \"function\") {\n      for (let _________propertyName of _________getOwnPropertyNames(______________________________sourceObject)) {\n        if (!__________hasOwnProperty.call(_definePropertiesIfNotExists, _________propertyName) && _________propertyName !== propertyBlacklisted) {\n          _definePropertyWithName(_definePropertiesIfNotExists, _________propertyName, {\n            get: () => ______________________________sourceObject[_________propertyName],\n            enumerable: !(_________propertyDescriptor = _________getOwnPropertyDescriptor(______________________________sourceObject, _________propertyName)) || _________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _definePropertiesIfNotExists;\n  };\n  var createModuleWithProperties = A => definePropertiesFromSource(_definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var serializerAndDeserializerSetup = {};\n  ________defineProperties(serializerAndDeserializerSetup, {\n    deserializerMiddleware: () => Ah0,\n    deserializerMiddlewareOption: () => deserializerMiddlewareOptions,\n    getSerdePlugin: () => Gh0,\n    serializerMiddleware: () => serializerMiddlewareFunction,\n    serializerMiddlewareOption: () => _serializerMiddlewareOptions\n  });\n  _________moduleExports.exports = createModuleWithProperties(serializerAndDeserializerSetup);\n  var ___________________________________________________processImageTransformation = _processImageTransform();\n  var Ah0 = defineFunctionWithName((handleApiResponse, processResponse) => (apiRequestHandler, loggerObject) => async handleApiRequest => {\n    let {\n      response: apiResponse\n    } = await apiRequestHandler(handleApiRequest);\n    try {\n      let processedResponse = await processResponse(apiResponse, handleApiResponse);\n      return {\n        response: apiResponse,\n        output: processedResponse\n      };\n    } catch (errorObject) {\n      Object.defineProperty(errorObject, \"$response\", {\n        value: apiResponse\n      });\n      if (!(\"$metadata\" in errorObject)) {\n        try {\n          errorObject.message += `\n  Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;\n        } catch (__error) {\n          if (!loggerObject.logger || loggerObject.logger?.constructor?.name === \"NoOpLogger\") {\n            console.warn(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          } else {\n            loggerObject.logger?.warn?.(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          }\n        }\n        if (typeof errorObject.$responseBodyText !== \"undefined\") {\n          if (errorObject.$response) {\n            errorObject.$response.body = errorObject.$responseBodyText;\n          }\n        }\n        try {\n          if (___________________________________________________processImageTransformation.HttpResponse.isInstance(apiResponse)) {\n            let {\n              headers: errorHandling = {}\n            } = apiResponse;\n            let responseHeadersArray = Object.entries(errorHandling);\n            errorObject.$metadata = {\n              httpStatusCode: apiResponse.statusCode,\n              requestId: findHeaderInResponseHeaders(/^x-[\\w-]+-request-?id$/, responseHeadersArray),\n              extendedRequestId: findHeaderInResponseHeaders(/^x-[\\w-]+-id-2$/, responseHeadersArray),\n              cfId: findHeaderInResponseHeaders(/^x-[\\w-]+-cf-id$/, responseHeadersArray)\n            };\n          }\n        } catch (____________________error) {}\n      }\n      throw errorObject;\n    }\n  }, \"deserializerMiddleware\");\n  var findHeaderInResponseHeaders = defineFunctionWithName((findMatchingValue, _findMatchingElement) => {\n    return (_findMatchingElement.find(([matchAgainstFindValue]) => {\n      return matchAgainstFindValue.match(findMatchingValue);\n    }) || [undefined, undefined])[1];\n  }, \"findHeader\");\n  var serializerMiddlewareFunction = defineFunctionWithName((createRequestHandler, processInputAndEndpoint) => (_processRequest, endpoint) => async __processRequest => {\n    let endpointProvider = createRequestHandler;\n    let _getEndpointUrl = endpoint.endpointV2?.url && endpointProvider.urlParser ? async () => endpointProvider.urlParser(endpoint.endpointV2.url) : endpointProvider.endpoint;\n    if (!_getEndpointUrl) {\n      throw Error(\"No valid endpoint provider available.\");\n    }\n    let fetchDataWithEndpoint = await processInputAndEndpoint(__processRequest.input, {\n      ...createRequestHandler,\n      endpoint: _getEndpointUrl\n    });\n    return _processRequest({\n      ...__processRequest,\n      request: fetchDataWithEndpoint\n    });\n  }, \"serializerMiddleware\");\n  var deserializerMiddlewareOptions = {\n    name: \"deserializerMiddleware\",\n    step: \"deserialize\",\n    tags: [\"DESERIALIZER\"],\n    override: true\n  };\n  var _serializerMiddlewareOptions = {\n    name: \"serializerMiddleware\",\n    step: \"serialize\",\n    tags: [\"SERIALIZER\"],\n    override: true\n  };\n  function Gh0(____inputData, dataProcessingFunction, queueProcessor) {\n    return {\n      applyToStack: I => {\n        I.add(Ah0(____inputData, queueProcessor), deserializerMiddlewareOptions);\n        I.add(serializerMiddlewareFunction(____inputData, dataProcessingFunction), _serializerMiddlewareOptions);\n      }\n    };\n  }\n  defineFunctionWithName(Gh0, \"getSerdePlugin\");\n});\nvar updateMetadata = z((configureHttpHandler, httpHandlerExtensionConfig) => {\n  var {\n    defineProperty: ____defineProperty,\n    getOwnPropertyDescriptor: _______getOwnPropertyDescriptor,\n    getOwnPropertyNames: _______getOwnPropertyNames\n  } = Object;\n  var _______hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ________________definePropertyWithName = (A, B) => ____defineProperty(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var assignProperties = (A, B) => {\n    for (var Q in B) {\n      ____defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesFromObject = (_copyPropertiesWithGetters, _________________________________sourceObject, __________________________________sourceObject, __________propertyDescriptor) => {\n    if (_________________________________sourceObject && typeof _________________________________sourceObject === \"object\" || typeof _________________________________sourceObject === \"function\") {\n      for (let __________propertyName of _______getOwnPropertyNames(_________________________________sourceObject)) {\n        if (!_______hasOwnProperty.call(_copyPropertiesWithGetters, __________propertyName) && __________propertyName !== __________________________________sourceObject) {\n          ____defineProperty(_copyPropertiesWithGetters, __________propertyName, {\n            get: () => _________________________________sourceObject[__________propertyName],\n            enumerable: !(__________propertyDescriptor = _______getOwnPropertyDescriptor(_________________________________sourceObject, __________propertyName)) || __________propertyDescriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyPropertiesWithGetters;\n  };\n  var defineExportProperties = A => definePropertiesFromObject(____defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var httpHandlerExtensions = {};\n  assignProperties(httpHandlerExtensions, {\n    Field: () => FieldDefinition,\n    Fields: () => HttpFieldsManager,\n    HttpRequest: () => Ot9,\n    HttpResponse: () => _HttpResponse,\n    IHttpRequest: () => __________________imageTransformationProcessor.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => _getHttpHandlerExtensionConfiguration,\n    isValidHostname: () => _isValidUsername,\n    resolveHttpHandlerRuntimeConfig: () => resolveHttpHandlerConfig\n  });\n  httpHandlerExtensionConfig.exports = defineExportProperties(httpHandlerExtensions);\n  var _getHttpHandlerExtensionConfiguration = ________________definePropertyWithName(__createHttpHandlerManager => {\n    return {\n      setHttpHandler(_httpHandler) {\n        __createHttpHandlerManager.httpHandler = _httpHandler;\n      },\n      httpHandler() {\n        return __createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(_____httpClientConfig, httpClientConfigOptions) {\n        __createHttpHandlerManager.httpHandler?.updateHttpClientConfig(_____httpClientConfig, httpClientConfigOptions);\n      },\n      httpHandlerConfigs() {\n        return __createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var resolveHttpHandlerConfig = ________________definePropertyWithName(__createHttpHandler => {\n    return {\n      httpHandler: __createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var __________________imageTransformationProcessor = _____________________________processImageTransformation();\n  var FieldDefinition = class {\n    static {\n      ________________definePropertyWithName(this, \"Field\");\n    }\n    constructor({\n      name: _name,\n      kind: fieldPositionType = __________________imageTransformationProcessor.FieldPosition.HEADER,\n      values: __initialValues = []\n    }) {\n      this.name = _name;\n      this.kind = fieldPositionType;\n      this.values = __initialValues;\n    }\n    add(A) {\n      this.values.push(A);\n    }\n    set(A) {\n      this.values = A;\n    }\n    remove(A) {\n      this.values = this.values.filter(isDifferentFromA => isDifferentFromA !== A);\n    }\n    toString() {\n      return this.values.map(__formattedString => __formattedString.includes(\",\") || __formattedString.includes(\" \") ? `\"${__formattedString}\"` : __formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpFieldsManager = class {\n    constructor({\n      fields: fieldList = [],\n      encoding: __defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      fieldList.forEach(this.setField.bind(this));\n      this.encoding = __defaultEncoding;\n    }\n    static {\n      ________________definePropertyWithName(this, \"Fields\");\n    }\n    setField(A) {\n      this.entries[A.name.toLowerCase()] = A;\n    }\n    getField(A) {\n      return this.entries[A.toLowerCase()];\n    }\n    removeField(A) {\n      delete this.entries[A.toLowerCase()];\n    }\n    getByType(A) {\n      return Object.values(this.entries).filter(__isKindOfA => __isKindOfA.kind === A);\n    }\n  };\n  var Ot9 = class A {\n    static {\n      ________________definePropertyWithName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = _cloneObjectWithArrayValues(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function _cloneObjectWithArrayValues(inputObject) {\n    return Object.keys(inputObject).reduce((mergeInputWithExisting, _____key) => {\n      let ______inputValue = inputObject[_____key];\n      return {\n        ...mergeInputWithExisting,\n        [_____key]: Array.isArray(______inputValue) ? [...______inputValue] : ______inputValue\n      };\n    }, {});\n  }\n  ________________definePropertyWithName(_cloneObjectWithArrayValues, \"cloneQuery\");\n  var _HttpResponse = class {\n    static {\n      ________________definePropertyWithName(this, \"HttpResponse\");\n    }\n    constructor(A) {\n      this.statusCode = A.statusCode;\n      this.reason = A.reason;\n      this.headers = A.headers || {};\n      this.body = A.body;\n    }\n    static isInstance(A) {\n      if (!A) {\n        return false;\n      }\n      let B = A;\n      return typeof B.statusCode === \"number\" && typeof B.headers === \"object\";\n    }\n  };\n  function _isValidUsername(_____inputString) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(_____inputString);\n  }\n  ________________definePropertyWithName(_isValidUsername, \"isValidHostname\");\n});\nvar ________________imageProcessingPipeline = z((validateArrayBuffer, defineArrayBufferChecker) => {\n  var {\n    defineProperty: ______________definePropertyWithName,\n    getOwnPropertyDescriptor: ___________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: __________________________getOwnPropertyNames\n  } = Object;\n  var ________________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ____setFunctionName = (A, B) => ______________definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var assignGetterProperties = (A, B) => {\n    for (var Q in B) {\n      ______________definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesIfNotDefined = (_copyPropertiesFromSourceToTarget, _____________________________________sourceObject, ___excludedPropertyName, _descriptor) => {\n    if (_____________________________________sourceObject && typeof _____________________________________sourceObject === \"object\" || typeof _____________________________________sourceObject === \"function\") {\n      for (let ___________propertyName of __________________________getOwnPropertyNames(_____________________________________sourceObject)) {\n        if (!________________________hasOwnProperty.call(_copyPropertiesFromSourceToTarget, ___________propertyName) && ___________propertyName !== ___excludedPropertyName) {\n          ______________definePropertyWithName(_copyPropertiesFromSourceToTarget, ___________propertyName, {\n            get: () => _____________________________________sourceObject[___________propertyName],\n            enumerable: !(_descriptor = ___________________________getOwnPropertyDescriptor(_____________________________________sourceObject, ___________propertyName)) || _descriptor.enumerable\n          });\n        }\n      }\n    }\n    return _copyPropertiesFromSourceToTarget;\n  };\n  var createArrayBufferModule = A => copyPropertiesIfNotDefined(______________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var arrayBufferUtils = {};\n  assignGetterProperties(arrayBufferUtils, {\n    isArrayBuffer: () => isArrayBufferChecker\n  });\n  defineArrayBufferChecker.exports = createArrayBufferModule(arrayBufferUtils);\n  var isArrayBufferChecker = ____setFunctionName(inputIsArrayBuffer => typeof ArrayBuffer === \"function\" && inputIsArrayBuffer instanceof ArrayBuffer || Object.prototype.toString.call(inputIsArrayBuffer) === \"[object ArrayBuffer]\", \"isArrayBuffer\");\n});\nvar ________________________________________processImageTransformation = z((_________________imageProcessingPipeline, initializeBufferConversion) => {\n  var {\n    defineProperty: _________definePropertyWithName,\n    getOwnPropertyDescriptor: ______________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ____________________getOwnPropertyNames\n  } = Object;\n  var ____________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___defineFunctionWithName = (A, B) => _________definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _______________defineProperties = (A, B) => {\n    for (var Q in B) {\n      _________definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesIfNotExist = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ____________propertyName of ____________________getOwnPropertyNames(B)) {\n        if (!____________________hasOwnProperty.call(A, ____________propertyName) && ____________propertyName !== Q) {\n          _________definePropertyWithName(A, ____________propertyName, {\n            get: () => B[____________propertyName],\n            enumerable: !(I = ______________________getOwnPropertyDescriptor(B, ____________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createBufferConversionModule = A => definePropertiesIfNotExist(_________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var bufferConversionHandlers = {};\n  _______________defineProperties(bufferConversionHandlers, {\n    fromArrayBuffer: () => _createBufferFromArrayBuffer,\n    fromString: () => convertStringToBuffer\n  });\n  initializeBufferConversion.exports = createBufferConversionModule(bufferConversionHandlers);\n  var initializeImageProcessingPipeline = ________________imageProcessingPipeline();\n  var bufferLibrary = EA(\"buffer\");\n  var _createBufferFromArrayBuffer = ___defineFunctionWithName((createBufferFromArrayBuffer, arrayBufferOffset = 0, byteArraySliceLength = createBufferFromArrayBuffer.byteLength - arrayBufferOffset) => {\n    if (!(0, initializeImageProcessingPipeline.isArrayBuffer)(createBufferFromArrayBuffer)) {\n      throw TypeError(`The \"input\" argument must be ArrayBuffer. Received type ${typeof createBufferFromArrayBuffer} (${createBufferFromArrayBuffer})`);\n    }\n    return bufferLibrary.Buffer.from(createBufferFromArrayBuffer, arrayBufferOffset, byteArraySliceLength);\n  }, \"fromArrayBuffer\");\n  var convertStringToBuffer = ___defineFunctionWithName((inputStringToBuffer, encoding) => {\n    if (typeof inputStringToBuffer !== \"string\") {\n      throw TypeError(`The \"input\" argument must be of type string. Received type ${typeof inputStringToBuffer} (${inputStringToBuffer})`);\n    }\n    if (encoding) {\n      return bufferLibrary.Buffer.from(inputStringToBuffer, encoding);\n    } else {\n      return bufferLibrary.Buffer.from(inputStringToBuffer);\n    }\n  }, \"fromString\");\n});\nvar __processImageTransform = z(base64Decoder => {\n  Object.defineProperty(base64Decoder, \"__esModule\", {\n    value: true\n  });\n  base64Decoder.fromBase64 = undefined;\n  var processImageBase64Transformation = ________________________________________processImageTransformation();\n  var base64ValidationRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n  var it9 = A => {\n    if (A.length * 3 % 4 !== 0) {\n      throw TypeError(\"Incorrect padding on base64 string.\");\n    }\n    if (!base64ValidationRegex.exec(A)) {\n      throw TypeError(\"Invalid base64 string.\");\n    }\n    let B = (0, processImageBase64Transformation.fromString)(A, \"base64\");\n    return new Uint8Array(B.buffer, B.byteOffset, B.byteLength);\n  };\n  base64Decoder.fromBase64 = it9;\n});\nvar ___________________imageProcessingPipeline = z((utf8ConversionFunctions, utf8Utilities) => {\n  var {\n    defineProperty: _______definePropertyWithName,\n    getOwnPropertyDescriptor: _____________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _getObjectOwnPropertyNames\n  } = Object;\n  var ___________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var definePropertyWithNameForExport = (A, B) => _______definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _____________defineProperties = (A, B) => {\n    for (var Q in B) {\n      _______definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var ___definePropertiesFromSource = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _____________propertyName of _getObjectOwnPropertyNames(B)) {\n        if (!___________________hasOwnProperty.call(A, _____________propertyName) && _____________propertyName !== Q) {\n          _______definePropertyWithName(A, _____________propertyName, {\n            get: () => B[_____________propertyName],\n            enumerable: !(I = _____________________getOwnPropertyDescriptor(B, _____________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createUtf8ConversionsModule = A => ___definePropertiesFromSource(_______definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var utf8Conversions = {};\n  _____________defineProperties(utf8Conversions, {\n    fromUtf8: () => Nh0,\n    toUint8Array: () => et9,\n    toUtf8: () => Ae9\n  });\n  utf8Utilities.exports = createUtf8ConversionsModule(utf8Conversions);\n  var _____processImageTransformationFunction = ________________________________________processImageTransformation();\n  var Nh0 = definePropertyWithNameForExport(convertStringToUint8Array => {\n    let stringToUint8Array = (0, _____processImageTransformationFunction.fromString)(convertStringToUint8Array, \"utf8\");\n    return new Uint8Array(stringToUint8Array.buffer, stringToUint8Array.byteOffset, stringToUint8Array.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n  }, \"fromUtf8\");\n  var et9 = definePropertyWithNameForExport(convertToUint8Array => {\n    if (typeof convertToUint8Array === \"string\") {\n      return Nh0(convertToUint8Array);\n    }\n    if (ArrayBuffer.isView(convertToUint8Array)) {\n      return new Uint8Array(convertToUint8Array.buffer, convertToUint8Array.byteOffset, convertToUint8Array.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n    }\n    return new Uint8Array(convertToUint8Array);\n  }, \"toUint8Array\");\n  var Ae9 = definePropertyWithNameForExport(convertToUtf8 => {\n    if (typeof convertToUtf8 === \"string\") {\n      return convertToUtf8;\n    }\n    if (typeof convertToUtf8 !== \"object\" || typeof convertToUtf8.byteOffset !== \"number\" || typeof convertToUtf8.byteLength !== \"number\") {\n      throw Error(\"@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.\");\n    }\n    return (0, _____processImageTransformationFunction.fromArrayBuffer)(convertToUtf8.buffer, convertToUtf8.byteOffset, convertToUtf8.byteLength).toString(\"utf8\");\n  }, \"toUtf8\");\n});\nvar Rh0 = z(Base64Encoder => {\n  Object.defineProperty(Base64Encoder, \"__esModule\", {\n    value: true\n  });\n  Base64Encoder.toBase64 = undefined;\n  var processImageToBase64 = ________________________________________processImageTransformation();\n  var Qe9 = ___________________imageProcessingPipeline();\n  var Ie9 = A => {\n    let B;\n    if (typeof A === \"string\") {\n      B = (0, Qe9.fromUtf8)(A);\n    } else {\n      B = A;\n    }\n    if (typeof B !== \"object\" || typeof B.byteOffset !== \"number\" || typeof B.byteLength !== \"number\") {\n      throw Error(\"@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.\");\n    }\n    return (0, processImageToBase64.fromArrayBuffer)(B.buffer, B.byteOffset, B.byteLength).toString(\"base64\");\n  };\n  Base64Encoder.toBase64 = Ie9;\n});\nvar h0A = z((defineAndExportModule, moduleExporter) => {\n  var {\n    defineProperty: __________defineProperty,\n    getOwnPropertyDescriptor: ____________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ___________________________getOwnPropertyNames\n  } = Object;\n  var _________________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var copyPropertiesToTarget = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ______________propertyName of ___________________________getOwnPropertyNames(B)) {\n        if (!_________________________hasOwnProperty.call(A, ______________propertyName) && ______________propertyName !== Q) {\n          __________defineProperty(A, ______________propertyName, {\n            get: () => B[______________propertyName],\n            enumerable: !(I = ____________________________getOwnPropertyDescriptor(B, ______________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var copyDefaultProperties = (A, B, Q) => {\n    copyPropertiesToTarget(A, B, \"default\");\n    return Q && copyPropertiesToTarget(Q, B, \"default\");\n  };\n  var createModuleExport = A => copyPropertiesToTarget(__________defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var __________________________moduleExports = {};\n  moduleExporter.exports = createModuleExport(__________________________moduleExports);\n  copyDefaultProperties(__________________________moduleExports, __processImageTransform(), moduleExporter.exports);\n  copyDefaultProperties(__________________________moduleExports, Rh0(), moduleExporter.exports);\n});\nvar JX1 = z(ChecksumStreamModule => {\n  Object.defineProperty(ChecksumStreamModule, \"__esModule\", {\n    value: true\n  });\n  ChecksumStreamModule.ChecksumStream = undefined;\n  var Xe9 = h0A();\n  var createChecksumStream = EA(\"stream\");\n  class jh0 extends createChecksumStream.Duplex {\n    constructor({\n      expectedChecksum: expectedChecksumValue,\n      checksum: computedChecksum,\n      source: _inputStream,\n      checksumSourceLocation: checksumSourceLocation,\n      base64Encoder: base64EncoderFunction\n    }) {\n      super();\n      if (typeof _inputStream.pipe === \"function\") {\n        this.source = _inputStream;\n      } else {\n        throw Error(`@smithy/util-stream: unsupported source type ${_inputStream?.constructor?.name ?? _inputStream} in ChecksumStream.`);\n      }\n      this.base64Encoder = base64EncoderFunction ?? Xe9.toBase64;\n      this.expectedChecksum = expectedChecksumValue;\n      this.checksum = computedChecksum;\n      this.checksumSourceLocation = checksumSourceLocation;\n      this.source.pipe(this);\n    }\n    _read(A) {}\n    _write(A, B, Q) {\n      try {\n        this.checksum.update(A);\n        this.push(A);\n      } catch (_______________error) {\n        return Q(_______________error);\n      }\n      return Q();\n    }\n    async _final(A) {\n      try {\n        let _computedChecksum = await this.checksum.digest();\n        let encodedChecksum = this.base64Encoder(_computedChecksum);\n        if (this.expectedChecksum !== encodedChecksum) {\n          return A(Error(`Checksum mismatch: expected \"${this.expectedChecksum}\" but received \"${encodedChecksum}\" in response header \"${this.checksumSourceLocation}\".`));\n        }\n      } catch (________________error) {\n        return A(________________error);\n      }\n      this.push(null);\n      return A();\n    }\n  }\n  ChecksumStreamModule.ChecksumStream = jh0;\n});\nvar processImageTransformatio = z(streamAndBlobUtils => {\n  Object.defineProperty(streamAndBlobUtils, \"__esModule\", {\n    value: true\n  });\n  streamAndBlobUtils.isBlob = streamAndBlobUtils.isReadableStream = undefined;\n  var isReadableStream = isInstanceOfReadableStream => {\n    return typeof ReadableStream === \"function\" && (isInstanceOfReadableStream?.constructor?.name === ReadableStream.name || isInstanceOfReadableStream instanceof ReadableStream);\n  };\n  streamAndBlobUtils.isReadableStream = isReadableStream;\n  var isBlob = _isBlob => {\n    return typeof Blob === \"function\" && (_isBlob?.constructor?.name === Blob.name || _isBlob instanceof Blob);\n  };\n  streamAndBlobUtils.isBlob = isBlob;\n});\nvar ___validateOutputFilePath = z(ChecksumStream => {\n  Object.defineProperty(ChecksumStream, \"__esModule\", {\n    value: true\n  });\n  ChecksumStream.ChecksumStream = undefined;\n  var StreamReader = typeof ReadableStream === \"function\" ? ReadableStream : function () {};\n  class FileStreamReader extends StreamReader {}\n  ChecksumStream.ChecksumStream = FileStreamReader;\n});\nvar uh0 = z(_createChecksumStream => {\n  Object.defineProperty(_createChecksumStream, \"__esModule\", {\n    value: true\n  });\n  _createChecksumStream.createChecksumStream = undefined;\n  var De9 = h0A();\n  var __createChecksumStream = processImageTransformatio();\n  var ____validateOutputFilePath = ___validateOutputFilePath();\n  var ze9 = ({\n    expectedChecksum: A,\n    checksum: B,\n    source: Q,\n    checksumSourceLocation: I,\n    base64Encoder: G\n  }) => {\n    if (!(0, __createChecksumStream.isReadableStream)(Q)) {\n      throw Error(`@smithy/util-stream: unsupported source type ${Q?.constructor?.name ?? Q} in ChecksumStream.`);\n    }\n    let J = G ?? De9.toBase64;\n    if (typeof TransformStream !== \"function\") {\n      throw Error(\"@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.\");\n    }\n    let X = new TransformStream({\n      start() {},\n      async transform(F, C) {\n        B.update(F);\n        C.enqueue(F);\n      },\n      async flush(F) {\n        let C = await B.digest();\n        let V = J(C);\n        if (A !== V) {\n          let checksumError = Error(`Checksum mismatch: expected \"${A}\" but received \"${V}\" in response header \"${I}\".`);\n          F.error(checksumError);\n        } else {\n          F.terminate();\n        }\n      }\n    });\n    Q.pipeThrough(X);\n    let W = X.readable;\n    Object.setPrototypeOf(W, ____validateOutputFilePath.ChecksumStream.prototype);\n    return W;\n  };\n  _createChecksumStream.createChecksumStream = ze9;\n});\nvar dh0 = z(___________________________moduleExports => {\n  Object.defineProperty(___________________________moduleExports, \"__esModule\", {\n    value: true\n  });\n  ___________________________moduleExports.createChecksumStream = qe9;\n  var imageTransformationProcess = processImageTransformatio();\n  var we9 = JX1();\n  var $e9 = uh0();\n  function qe9(input) {\n    if (typeof ReadableStream === \"function\" && (0, imageTransformationProcess.isReadableStream)(input.source)) {\n      return (0, $e9.createChecksumStream)(input);\n    }\n    return new we9.ChecksumStream(input);\n  }\n});\nvar __updateImageFormatBasedOnOptions = z(ByteArrayModule => {\n  Object.defineProperty(ByteArrayModule, \"__esModule\", {\n    value: true\n  });\n  ByteArrayModule.ByteArrayCollector = undefined;\n  class ByteArrayCollector {\n    constructor(_allocatedByteArray) {\n      this.allocByteArray = _allocatedByteArray;\n      this.byteLength = 0;\n      this.byteArrays = [];\n    }\n    push(pushByteArray) {\n      this.byteArrays.push(pushByteArray);\n      this.byteLength += pushByteArray.byteLength;\n    }\n    flush() {\n      if (this.byteArrays.length === 1) {\n        let byteArrayToReturn = this.byteArrays[0];\n        this.reset();\n        return byteArrayToReturn;\n      }\n      let allocatedByteArray = this.allocByteArray(this.byteLength);\n      let byteArrayOffset = 0;\n      for (let byteArrayIndex = 0; byteArrayIndex < this.byteArrays.length; ++byteArrayIndex) {\n        let currentByteArray = this.byteArrays[byteArrayIndex];\n        allocatedByteArray.set(currentByteArray, byteArrayOffset);\n        byteArrayOffset += currentByteArray.byteLength;\n      }\n      this.reset();\n      return allocatedByteArray;\n    }\n    reset() {\n      this.byteArrays = [];\n      this.byteLength = 0;\n    }\n  }\n  ByteArrayModule.ByteArrayCollector = ByteArrayCollector;\n});\nvar _________________________________________processImageTransformation = z(ReadableBufferedStream => {\n  Object.defineProperty(ReadableBufferedStream, \"__esModule\", {\n    value: true\n  });\n  ReadableBufferedStream.createBufferedReadable = undefined;\n  ReadableBufferedStream.createBufferedReadableStream = processStream;\n  ReadableBufferedStream.merge = updateValueInArray;\n  ReadableBufferedStream.flush = flushStreamByIndex;\n  ReadableBufferedStream.sizeOf = getArrayByteLength;\n  ReadableBufferedStream.modeOf = getBufferType;\n  var updateImageFormat = __updateImageFormatBasedOnOptions();\n  function processStream(processStreamChunks, minChunkSize, logger) {\n    let I = processStreamChunks.getReader();\n    let hasBufferedChunks = false;\n    let Z = 0;\n    let Y = [\"\", new updateImageFormat.ByteArrayCollector(W => new Uint8Array(W))];\n    let J = -1;\n    let X = async W => {\n      let {\n        value: F,\n        done: C\n      } = await I.read();\n      let V = F;\n      if (C) {\n        if (J !== -1) {\n          let processChunk = flushStreamByIndex(Y, J);\n          if (getArrayByteLength(processChunk) > 0) {\n            W.enqueue(processChunk);\n          }\n        }\n        W.close();\n      } else {\n        let K = getBufferType(V, false);\n        if (J !== K) {\n          if (J >= 0) {\n            W.enqueue(flushStreamByIndex(Y, J));\n          }\n          J = K;\n        }\n        if (J === -1) {\n          W.enqueue(V);\n          return;\n        }\n        let D = getArrayByteLength(V);\n        Z += D;\n        let E = getArrayByteLength(Y[J]);\n        if (D >= minChunkSize && E === 0) {\n          W.enqueue(V);\n        } else {\n          let _processChunk = updateValueInArray(Y, J, V);\n          if (!hasBufferedChunks && Z > minChunkSize * 2) {\n            hasBufferedChunks = true;\n            if (logger !== null && logger !== undefined) {\n              logger.warn(`@smithy/util-stream - stream chunk size ${D} is below threshold of ${minChunkSize}, automatically buffering.`);\n            }\n          }\n          if (_processChunk >= minChunkSize) {\n            W.enqueue(flushStreamByIndex(Y, J));\n          } else {\n            await X(W);\n          }\n        }\n      }\n    };\n    return new ReadableStream({\n      pull: X\n    });\n  }\n  ReadableBufferedStream.createBufferedReadable = processStream;\n  function updateValueInArray(updateArrayWithValue, actionType, valueToAdd) {\n    switch (actionType) {\n      case 0:\n        updateArrayWithValue[0] += valueToAdd;\n        return getArrayByteLength(updateArrayWithValue[0]);\n      case 1:\n      case 2:\n        updateArrayWithValue[actionType].push(valueToAdd);\n        return getArrayByteLength(updateArrayWithValue[actionType]);\n    }\n  }\n  function flushStreamByIndex(streamOrItem, indexOrOperation) {\n    switch (indexOrOperation) {\n      case 0:\n        let firstStreamItem = streamOrItem[0];\n        streamOrItem[0] = \"\";\n        return firstStreamItem;\n      case 1:\n      case 2:\n        return streamOrItem[indexOrOperation].flush();\n    }\n    throw Error(`@smithy/util-stream - invalid index ${indexOrOperation} given to flush()`);\n  }\n  function getArrayByteLength(getArrayOrStringLength) {\n    return getArrayOrStringLength?.byteLength ?? getArrayOrStringLength?.length ?? 0;\n  }\n  function getBufferType(dataTypeChecker, isBufferSupported = true) {\n    if (isBufferSupported && typeof Buffer !== \"undefined\" && dataTypeChecker instanceof Buffer) {\n      return 2;\n    }\n    if (dataTypeChecker instanceof Uint8Array) {\n      return 1;\n    }\n    if (typeof dataTypeChecker === \"string\") {\n      return 0;\n    }\n    return -1;\n  }\n});\nvar ____________________imageTransformationProcessor = z(streamUtils => {\n  Object.defineProperty(streamUtils, \"__esModule\", {\n    value: true\n  });\n  streamUtils.createBufferedReadable = ye9;\n  var streamModule = EA(\"node:stream\");\n  var ___updateImageFormatBasedOnOptions = __updateImageFormatBasedOnOptions();\n  var _createImageProcessor = _________________________________________processImageTransformation();\n  var ______________________________________________processImageTransformation = processImageTransformatio();\n  function ye9(inputStream, thresholdSize, warningLogger) {\n    if ((0, ______________________________________________processImageTransformation.isReadableStream)(inputStream)) {\n      return (0, _createImageProcessor.createBufferedReadableStream)(inputStream, thresholdSize, warningLogger);\n    }\n    let I = new streamModule.Readable({\n      read() {}\n    });\n    let isWarningLogged = false;\n    let Z = 0;\n    let Y = [\"\", new ___updateImageFormatBasedOnOptions.ByteArrayCollector(X => new Uint8Array(X)), new ___updateImageFormatBasedOnOptions.ByteArrayCollector(X => Buffer.from(new Uint8Array(X)))];\n    let J = -1;\n    inputStream.on(\"data\", X => {\n      let W = (0, _createImageProcessor.modeOf)(X, true);\n      if (J !== W) {\n        if (J >= 0) {\n          I.push((0, _createImageProcessor.flush)(Y, J));\n        }\n        J = W;\n      }\n      if (J === -1) {\n        I.push(X);\n        return;\n      }\n      let F = (0, _createImageProcessor.sizeOf)(X);\n      Z += F;\n      let C = (0, _createImageProcessor.sizeOf)(Y[J]);\n      if (F >= thresholdSize && C === 0) {\n        I.push(X);\n      } else {\n        let mergedSize = (0, _createImageProcessor.merge)(Y, J, X);\n        if (!isWarningLogged && Z > thresholdSize * 2) {\n          isWarningLogged = true;\n          if (warningLogger !== null && warningLogger !== undefined) {\n            warningLogger.warn(`@smithy/util-stream - stream chunk size ${F} is below threshold of ${thresholdSize}, automatically buffering.`);\n          }\n        }\n        if (mergedSize >= thresholdSize) {\n          I.push((0, _createImageProcessor.flush)(Y, J));\n        }\n      }\n    });\n    inputStream.on(\"end\", () => {\n      if (J !== -1) {\n        let _flushedData = (0, _createImageProcessor.flush)(Y, J);\n        if ((0, _createImageProcessor.sizeOf)(_flushedData) > 0) {\n          I.push(_flushedData);\n        }\n      }\n      I.push(null);\n    });\n    return I;\n  }\n});\nvar ______imageProcessor = z(awsChunkedEncodingStream => {\n  Object.defineProperty(awsChunkedEncodingStream, \"__esModule\", {\n    value: true\n  });\n  awsChunkedEncodingStream.getAwsChunkedEncodingStream = undefined;\n  var createAwsChunkedEncodingStream = EA(\"stream\");\n  var createChunkedEncodingStream = (processStreamWithChecksum, streamProcessingOptions) => {\n    let {\n      base64Encoder: base64Encoder,\n      bodyLengthChecker: calculateBodyLength,\n      checksumAlgorithmFn: checksumCalculationFunction,\n      checksumLocationName: checksumLocationKey,\n      streamHasher: streamHasherFunc\n    } = streamProcessingOptions;\n    let isEncodingEnabled = base64Encoder !== undefined && checksumCalculationFunction !== undefined && checksumLocationKey !== undefined && streamHasherFunc !== undefined;\n    let __computedChecksum = isEncodingEnabled ? streamHasherFunc(checksumCalculationFunction, processStreamWithChecksum) : undefined;\n    let chunkedEncodingStream = new createAwsChunkedEncodingStream.Readable({\n      read: () => {}\n    });\n    processStreamWithChecksum.on(\"data\", F => {\n      let C = calculateBodyLength(F) || 0;\n      chunkedEncodingStream.push(`${C.toString(16)}\\r\n`);\n      chunkedEncodingStream.push(F);\n      chunkedEncodingStream.push(`\\r\n`);\n    });\n    processStreamWithChecksum.on(\"end\", async () => {\n      chunkedEncodingStream.push(`0\\r\n`);\n      if (isEncodingEnabled) {\n        let fetchDataAndLog = base64Encoder(await __computedChecksum);\n        chunkedEncodingStream.push(`${checksumLocationKey}:${fetchDataAndLog}\\r\n`);\n        chunkedEncodingStream.push(`\\r\n`);\n      }\n      chunkedEncodingStream.push(null);\n    });\n    return chunkedEncodingStream;\n  };\n  awsChunkedEncodingStream.getAwsChunkedEncodingStream = createChunkedEncodingStream;\n});\nvar _______________________________processImageTransformation = z(streamReaderModule => {\n  Object.defineProperty(streamReaderModule, \"__esModule\", {\n    value: true\n  });\n  streamReaderModule.headStream = readDataChunks;\n  async function readDataChunks(readDataIntoBuffer, byteLimit) {\n    let totalBytesRead = 0;\n    let dataChunks = [];\n    let streamReader = readDataIntoBuffer.getReader();\n    let isReadingComplete = false;\n    while (!isReadingComplete) {\n      let {\n        done: isDone,\n        value: chunk\n      } = await streamReader.read();\n      if (chunk) {\n        dataChunks.push(chunk);\n        totalBytesRead += chunk?.byteLength ?? 0;\n      }\n      if (totalBytesRead >= byteLimit) {\n        break;\n      }\n      isReadingComplete = isDone;\n    }\n    streamReader.releaseLock();\n    let bufferArray = new Uint8Array(Math.min(byteLimit, totalBytesRead));\n    let writePointer = 0;\n    for (let dataChunk of dataChunks) {\n      if (dataChunk.byteLength > bufferArray.byteLength - writePointer) {\n        bufferArray.set(dataChunk.subarray(0, bufferArray.byteLength - writePointer), writePointer);\n        break;\n      } else {\n        bufferArray.set(dataChunk, writePointer);\n      }\n      writePointer += dataChunk.length;\n    }\n    return bufferArray;\n  }\n});\nvar _______________imageTransformationProcessor = z(imageStreamHandler => {\n  Object.defineProperty(imageStreamHandler, \"__esModule\", {\n    value: true\n  });\n  imageStreamHandler.headStream = undefined;\n  var StreamWritable = EA(\"stream\");\n  var _imageTransformProcessor = _______________________________processImageTransformation();\n  var ________________________________________________processImageTransformation = processImageTransformatio();\n  var streamToBufferWithLimit = (A, B) => {\n    if ((0, ________________________________________________processImageTransformation.isReadableStream)(A)) {\n      return (0, _imageTransformProcessor.headStream)(A, B);\n    }\n    return new Promise((Q, I) => {\n      let G = new BufferedStreamWriter();\n      G.limit = B;\n      A.pipe(G);\n      A.on(\"error\", currentState => {\n        G.end();\n        I(currentState);\n      });\n      G.on(\"error\", I);\n      G.on(\"finish\", function () {\n        let combinedBuffer = new Uint8Array(Buffer.concat(this.buffers));\n        Q(combinedBuffer);\n      });\n    });\n  };\n  imageStreamHandler.headStream = streamToBufferWithLimit;\n  class BufferedStreamWriter extends StreamWritable.Writable {\n    constructor() {\n      super(...arguments);\n      this.buffers = [];\n      this.limit = Infinity;\n      this.bytesBuffered = 0;\n    }\n    _write(writeBufferedData, _____________callbackFunction, __callback) {\n      this.buffers.push(writeBufferedData);\n      this.bytesBuffered += writeBufferedData.byteLength ?? 0;\n      if (this.bytesBuffered >= this.limit) {\n        let bytesOverLimit = this.bytesBuffered - this.limit;\n        let lastBufferedChunk = this.buffers[this.buffers.length - 1];\n        this.buffers[this.buffers.length - 1] = lastBufferedChunk.subarray(0, lastBufferedChunk.byteLength - bytesOverLimit);\n        this.emit(\"finish\");\n      }\n      __callback();\n    }\n  }\n});\nvar ________________________________processImageTransformation = z((initializeApiConfigurations, _______________moduleExports) => {\n  var {\n    defineProperty: ____definePropertyWithName,\n    getOwnPropertyDescriptor: ______________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _____________getOwnPropertyNames\n  } = Object;\n  var hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var _____________________definePropertyWithName = (A, B) => ____definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var definePropertiesFrom = (A, B) => {\n    for (var Q in B) {\n      ____definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var copyProperties = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _______________propertyName of _____________getOwnPropertyNames(B)) {\n        if (!hasOwnPropertyCheck.call(A, _______________propertyName) && _______________propertyName !== Q) {\n          ____definePropertyWithName(A, _______________propertyName, {\n            get: () => B[_______________propertyName],\n            enumerable: !(I = ______________getOwnPropertyDescriptor(B, _______________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var initializeExportedModule = A => copyProperties(____definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var __exportedModule = {};\n  definePropertiesFrom(__exportedModule, {\n    AlgorithmId: () => Dg0,\n    EndpointURLScheme: () => Kg0,\n    FieldPosition: () => Eg0,\n    HttpApiKeyAuthLocation: () => Vg0,\n    HttpAuthLocation: () => Cg0,\n    IniSectionType: () => Hg0,\n    RequestHandlerProtocol: () => zg0,\n    SMITHY_CONTEXT_KEY: () => SMITHY_CONTEXT_IDENTIFIER,\n    getDefaultClientConfiguration: () => se9,\n    resolveDefaultRuntimeConfig: () => re9\n  });\n  _______________moduleExports.exports = initializeExportedModule(__exportedModule);\n  var Cg0 = (createQueryHeaderConstants => {\n    createQueryHeaderConstants.HEADER = \"header\";\n    createQueryHeaderConstants.QUERY = \"query\";\n    return createQueryHeaderConstants;\n  })(Cg0 || {});\n  var Vg0 = (___initializeApiConstants => {\n    ___initializeApiConstants.HEADER = \"header\";\n    ___initializeApiConstants.QUERY = \"query\";\n    return ___initializeApiConstants;\n  })(Vg0 || {});\n  var Kg0 = (_ProtocolConfig => {\n    _ProtocolConfig.HTTP = \"http\";\n    _ProtocolConfig.HTTPS = \"https\";\n    return _ProtocolConfig;\n  })(Kg0 || {});\n  var Dg0 = (_setHashAlgorithms => {\n    _setHashAlgorithms.MD5 = \"md5\";\n    _setHashAlgorithms.CRC32 = \"crc32\";\n    _setHashAlgorithms.CRC32C = \"crc32c\";\n    _setHashAlgorithms.SHA1 = \"sha1\";\n    _setHashAlgorithms.SHA256 = \"sha256\";\n    return _setHashAlgorithms;\n  })(Dg0 || {});\n  var createChecksumAlgorithmHandlerWithProperties = _____________________definePropertyWithName(createChecksumAlgorithmHandler => {\n    let ____checksumAlgorithmsList = [];\n    if (createChecksumAlgorithmHandler.sha256 !== undefined) {\n      ____checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => createChecksumAlgorithmHandler.sha256\n      });\n    }\n    if (createChecksumAlgorithmHandler.md5 != null) {\n      ____checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => createChecksumAlgorithmHandler.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(addChecksumAlgorithm) {\n        ____checksumAlgorithmsList.push(addChecksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return ____checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var generateChecksumConstructorMap = _____________________definePropertyWithName(_generateChecksumMap => {\n    let _checksumConstructorsByAlgorithmId = {};\n    _generateChecksumMap.checksumAlgorithms().forEach(checksumConstructorByAlgorithmId => {\n      _checksumConstructorsByAlgorithmId[checksumConstructorByAlgorithmId.algorithmId()] = checksumConstructorByAlgorithmId.checksumConstructor();\n    });\n    return _checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var se9 = _____________________definePropertyWithName(____processInput => {\n    return createChecksumAlgorithmHandlerWithProperties(____processInput);\n  }, \"getDefaultClientConfiguration\");\n  var re9 = _____________________definePropertyWithName(___processData => {\n    return generateChecksumConstructorMap(___processData);\n  }, \"resolveDefaultRuntimeConfig\");\n  var Eg0 = (StatusTypes => {\n    StatusTypes[StatusTypes.HEADER = 0] = \"HEADER\";\n    StatusTypes[StatusTypes.TRAILER = 1] = \"TRAILER\";\n    return StatusTypes;\n  })(Eg0 || {});\n  var SMITHY_CONTEXT_IDENTIFIER = \"__smithy_context\";\n  var Hg0 = (defineConstants => {\n    defineConstants.PROFILE = \"profile\";\n    defineConstants.SSO_SESSION = \"sso-session\";\n    defineConstants.SERVICES = \"services\";\n    return defineConstants;\n  })(Hg0 || {});\n  var zg0 = (HTTPVersion => {\n    HTTPVersion.HTTP_0_9 = \"http/0.9\";\n    HTTPVersion.HTTP_1_0 = \"http/1.0\";\n    HTTPVersion.TDS_8_0 = \"tds/8.0\";\n    return HTTPVersion;\n  })(zg0 || {});\n});\nvar __________________________________________processImageTransformation = z((setupHttpHandlerExtensionConfiguration, _______moduleExports) => {\n  var {\n    defineProperty: _definePropertyWithConfig,\n    getOwnPropertyDescriptor: ________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ________getOwnPropertyNames\n  } = Object;\n  var ________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __definePropertyWithConfig = (A, B) => _definePropertyWithConfig(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _______defineProperties = (A, B) => {\n    for (var Q in B) {\n      _definePropertyWithConfig(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var copyOwnProperties = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ________________propertyName of ________getOwnPropertyNames(B)) {\n        if (!________hasOwnProperty.call(A, ________________propertyName) && ________________propertyName !== Q) {\n          _definePropertyWithConfig(A, ________________propertyName, {\n            get: () => B[________________propertyName],\n            enumerable: !(I = ________getOwnPropertyDescriptor(B, ________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createHttpHandlerModule = A => copyOwnProperties(_definePropertyWithConfig({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _httpHandlerExports = {};\n  _______defineProperties(_httpHandlerExports, {\n    Field: () => _HttpField,\n    Fields: () => HttpFieldCollection,\n    HttpRequest: () => XA4,\n    HttpResponse: () => HttpResponseClass,\n    IHttpRequest: () => createHttpRequestInstance.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => __createHttpHandlerExtensionConfiguration,\n    isValidHostname: () => __isValidIdentifier,\n    resolveHttpHandlerRuntimeConfig: () => _resolveHttpHandlerConfig\n  });\n  _______moduleExports.exports = createHttpHandlerModule(_httpHandlerExports);\n  var __createHttpHandlerExtensionConfiguration = __definePropertyWithConfig(___createHttpHandlerManager => {\n    return {\n      setHttpHandler(__httpHandler) {\n        ___createHttpHandlerManager.httpHandler = __httpHandler;\n      },\n      httpHandler() {\n        return ___createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(______httpClientConfig, clientConfig) {\n        ___createHttpHandlerManager.httpHandler?.updateHttpClientConfig(______httpClientConfig, clientConfig);\n      },\n      httpHandlerConfigs() {\n        return ___createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var _resolveHttpHandlerConfig = __definePropertyWithConfig(___createHttpHandler => {\n    return {\n      httpHandler: ___createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var createHttpRequestInstance = ________________________________processImageTransformation();\n  var _HttpField = class {\n    static {\n      __definePropertyWithConfig(this, \"Field\");\n    }\n    constructor({\n      name: __headerName,\n      kind: _fieldPosition = createHttpRequestInstance.FieldPosition.HEADER,\n      values: ___initialValues = []\n    }) {\n      this.name = __headerName;\n      this.kind = _fieldPosition;\n      this.values = ___initialValues;\n    }\n    add(A) {\n      this.values.push(A);\n    }\n    set(A) {\n      this.values = A;\n    }\n    remove(A) {\n      this.values = this.values.filter(_isDifferentFromA => _isDifferentFromA !== A);\n    }\n    toString() {\n      return this.values.map(___formattedString => ___formattedString.includes(\",\") || ___formattedString.includes(\" \") ? `\"${___formattedString}\"` : ___formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpFieldCollection = class {\n    constructor({\n      fields: inputFields = [],\n      encoding: ___defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      inputFields.forEach(this.setField.bind(this));\n      this.encoding = ___defaultEncoding;\n    }\n    static {\n      __definePropertyWithConfig(this, \"Fields\");\n    }\n    setField(A) {\n      this.entries[A.name.toLowerCase()] = A;\n    }\n    getField(A) {\n      return this.entries[A.toLowerCase()];\n    }\n    removeField(A) {\n      delete this.entries[A.toLowerCase()];\n    }\n    getByType(A) {\n      return Object.values(this.entries).filter(isKindOfTypeA => isKindOfTypeA.kind === A);\n    }\n  };\n  var XA4 = class A {\n    static {\n      __definePropertyWithConfig(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObjectWithArrays(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObjectWithArrays(createShallowCopy) {\n    return Object.keys(createShallowCopy).reduce((combineWithShallowCopy, ______key) => {\n      let shallowCopyOfQ = createShallowCopy[______key];\n      return {\n        ...combineWithShallowCopy,\n        [______key]: Array.isArray(shallowCopyOfQ) ? [...shallowCopyOfQ] : shallowCopyOfQ\n      };\n    }, {});\n  }\n  __definePropertyWithConfig(cloneObjectWithArrays, \"cloneQuery\");\n  var HttpResponseClass = class {\n    static {\n      __definePropertyWithConfig(this, \"HttpResponse\");\n    }\n    constructor(A) {\n      this.statusCode = A.statusCode;\n      this.reason = A.reason;\n      this.headers = A.headers || {};\n      this.body = A.body;\n    }\n    static isInstance(A) {\n      if (!A) {\n        return false;\n      }\n      let B = A;\n      return typeof B.statusCode === \"number\" && typeof B.headers === \"object\";\n    }\n  };\n  function __isValidIdentifier(___isValidIdentifier) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(___isValidIdentifier);\n  }\n  __definePropertyWithConfig(__isValidIdentifier, \"isValidHostname\");\n});\nvar _processImageTransformationFunction = z((exportModule, _________________________moduleExports) => {\n  var {\n    defineProperty: ____________definePropertyWithName,\n    getOwnPropertyDescriptor: getOwnPropertyDescriptorInsteadFA4,\n    getOwnPropertyNames: ________________________getOwnPropertyNames\n  } = Object;\n  var _______________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var definePropertyWithNameAndValue = (A, B) => ____________definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var ________________defineProperties = (A, B) => {\n    for (var Q in B) {\n      ____________definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var ____defineNonEnumerableProperties = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _________________propertyName of ________________________getOwnPropertyNames(B)) {\n        if (!_______________________hasOwnProperty.call(A, _________________propertyName) && _________________propertyName !== Q) {\n          ____________definePropertyWithName(A, _________________propertyName, {\n            get: () => B[_________________propertyName],\n            enumerable: !(I = getOwnPropertyDescriptorInsteadFA4(B, _________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createNonEnumerableProperties = A => ____defineNonEnumerableProperties(____________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var exportedUriUtils = {};\n  ________________defineProperties(exportedUriUtils, {\n    escapeUri: () => Tg0,\n    escapeUriPath: () => zA4\n  });\n  _________________________moduleExports.exports = createNonEnumerableProperties(exportedUriUtils);\n  var Tg0 = definePropertyWithNameAndValue(urlEncodeAndTransform => encodeURIComponent(urlEncodeAndTransform).replace(/[!'()*]/g, convertCharacterToHexadecimal), \"escapeUri\");\n  var convertCharacterToHexadecimal = definePropertyWithNameAndValue(getHexadecimalRepresentation => `%${getHexadecimalRepresentation.charCodeAt(0).toString(16).toUpperCase()}`, \"hexEncode\");\n  var zA4 = definePropertyWithNameAndValue(splitAndTransformPath => splitAndTransformPath.split(\"/\").map(Tg0).join(\"/\"), \"escapeUriPath\");\n});\nvar imageProcessingTransformation = z((buildQueryStringModule, _buildQueryStringModule) => {\n  var {\n    defineProperty: __________definePropertyWithName,\n    getOwnPropertyDescriptor: _______________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _____________________getOwnPropertyNames\n  } = Object;\n  var _____________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ____defineFunctionName = (A, B) => __________definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var associateProperties = (A, B) => {\n    for (var Q in B) {\n      __________definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var ___defineNonEnumerableProperties = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _propertyKey of _____________________getOwnPropertyNames(B)) {\n        if (!_____________________hasOwnProperty.call(A, _propertyKey) && _propertyKey !== Q) {\n          __________definePropertyWithName(A, _propertyKey, {\n            get: () => B[_propertyKey],\n            enumerable: !(I = _______________________getOwnPropertyDescriptor(B, _propertyKey)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createQueryStringBuilder = A => ___defineNonEnumerableProperties(__________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var queryStringBuilder = {};\n  associateProperties(queryStringBuilder, {\n    buildQueryString: () => serializeQueryParamsToString\n  });\n  _buildQueryStringModule.exports = createQueryStringBuilder(queryStringBuilder);\n  var ___processImageTransformationFunction = _processImageTransformationFunction();\n  function serializeQueryParamsToString(serializeQueryParams) {\n    let B = [];\n    for (let Q of Object.keys(serializeQueryParams).sort()) {\n      let queryParamValue = serializeQueryParams[Q];\n      Q = (0, ___processImageTransformationFunction.escapeUri)(Q);\n      if (Array.isArray(queryParamValue)) {\n        for (let ________index = 0, queryParamCount = queryParamValue.length; ________index < queryParamCount; ________index++) {\n          B.push(`${Q}=${(0, ___processImageTransformationFunction.escapeUri)(queryParamValue[________index])}`);\n        }\n      } else {\n        let ___index = Q;\n        if (queryParamValue || typeof queryParamValue === \"string\") {\n          ___index += `=${(0, ___processImageTransformationFunction.escapeUri)(queryParamValue)}`;\n        }\n        B.push(___index);\n      }\n    }\n    return B.join(\"&\");\n  }\n  ____defineFunctionName(serializeQueryParamsToString, \"buildQueryString\");\n});\nvar processAndExportImageTransformation = z((handleHttpRequest, nodeHttpHandler) => {\n  var {\n    create: createObject,\n    defineProperty: definePropertyWithDescriptor,\n    getOwnPropertyDescriptor: getOwnPropertyDescriptorFromObject,\n    getOwnPropertyNames: _getOwnPropertyNames,\n    getPrototypeOf: getPrototypeOfObject\n  } = Object;\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var setFunctionName = (A, B) => definePropertyWithDescriptor(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _defineProperties = (A, B) => {\n    for (var Q in B) {\n      definePropertyWithDescriptor(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesFromSource = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let __________________propertyName of _getOwnPropertyNames(B)) {\n        if (!_hasOwnProperty.call(A, __________________propertyName) && __________________propertyName !== Q) {\n          definePropertyWithDescriptor(A, __________________propertyName, {\n            get: () => B[__________________propertyName],\n            enumerable: !(I = getOwnPropertyDescriptorFromObject(B, __________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var _initializeModule = (A, B, Q) => {\n    if (A != null) {\n      Q = createObject(getPrototypeOfObject(A));\n    } else {\n      Q = {};\n    }\n    return copyPropertiesFromSource(B || !A || !A.__esModule ? definePropertyWithDescriptor(Q, \"default\", {\n      value: A,\n      enumerable: true\n    }) : Q, A);\n  };\n  var transformExportedNodeHttpHandler = A => copyPropertiesFromSource(definePropertyWithDescriptor({}, \"__esModule\", {\n    value: true\n  }), A);\n  var nodeHttpHandlerExports = {};\n  _defineProperties(nodeHttpHandlerExports, {\n    DEFAULT_REQUEST_TIMEOUT: () => __defaultRequestTimeout,\n    NodeHttp2Handler: () => dA4,\n    NodeHttpHandler: () => hA4,\n    streamCollector: () => pA4\n  });\n  nodeHttpHandler.exports = transformExportedNodeHttpHandler(nodeHttpHandlerExports);\n  var initializeHttpResponseProcessor = __________________________________________processImageTransformation();\n  var _imageProcessingTransformation = imageProcessingTransformation();\n  var httpAgent = EA(\"http\");\n  var HttpsAgentInstance = EA(\"https\");\n  var commonNetworkErrors = [\"ECONNRESET\", \"EPIPE\", \"ETIMEDOUT\"];\n  var transformHeadersToString = setFunctionName(convertObjectValuesToString => {\n    let processedData = {};\n    for (let _key of Object.keys(convertObjectValuesToString)) {\n      let __value = convertObjectValuesToString[_key];\n      processedData[_key] = Array.isArray(__value) ? __value.join(\",\") : __value;\n    }\n    return processedData;\n  }, \"getTransformedHeaders\");\n  var timeoutHandler = {\n    setTimeout: (executeAfterDelay, delayExecution) => setTimeout(executeAfterDelay, delayExecution),\n    clearTimeout: timeoutId => clearTimeout(timeoutId)\n  };\n  var DEFAULT_REQUEST_TIMEOUT = 1000;\n  var setConnectionTimeoutHandler = setFunctionName((handleSocketConnectionTimeout, handleSocketTimeout, timeoutDuration = 0) => {\n    if (!timeoutDuration) {\n      return -1;\n    }\n    let registerSocketTimeout = setFunctionName(initiateSocketConnectionTimeout => {\n      let socketConnectionTimeoutHandle = timeoutHandler.setTimeout(() => {\n        handleSocketConnectionTimeout.destroy();\n        handleSocketTimeout(Object.assign(Error(`Socket timed out without establishing a connection within ${timeoutDuration} ms`), {\n          name: \"TimeoutError\"\n        }));\n      }, timeoutDuration - initiateSocketConnectionTimeout);\n      let handleSocketConnection = setFunctionName(connectionHandler => {\n        if (connectionHandler?.connecting) {\n          connectionHandler.on(\"connect\", () => {\n            timeoutHandler.clearTimeout(socketConnectionTimeoutHandle);\n          });\n        } else {\n          timeoutHandler.clearTimeout(socketConnectionTimeoutHandle);\n        }\n      }, \"doWithSocket\");\n      if (handleSocketConnectionTimeout.socket) {\n        handleSocketConnection(handleSocketConnectionTimeout.socket);\n      } else {\n        handleSocketConnectionTimeout.on(\"socket\", handleSocketConnection);\n      }\n    }, \"registerTimeout\");\n    if (timeoutDuration < 2000) {\n      registerSocketTimeout(0);\n      return 0;\n    }\n    return timeoutHandler.setTimeout(registerSocketTimeout.bind(null, DEFAULT_REQUEST_TIMEOUT), DEFAULT_REQUEST_TIMEOUT);\n  }, \"setConnectionTimeout\");\n  var DEFAULT_SOCKET_TIMEOUT = 3000;\n  var _setSocketKeepAlive = setFunctionName((setSocketKeepAlive, {\n    keepAlive: shouldKeepSocketAlive,\n    keepAliveMsecs: keepAliveTimeout\n  }, socketTimeout = DEFAULT_SOCKET_TIMEOUT) => {\n    if (shouldKeepSocketAlive !== true) {\n      return -1;\n    }\n    let registerKeepAliveListener = setFunctionName(() => {\n      if (setSocketKeepAlive.socket) {\n        setSocketKeepAlive.socket.setKeepAlive(shouldKeepSocketAlive, keepAliveTimeout || 0);\n      } else {\n        setSocketKeepAlive.on(\"socket\", socketManager => {\n          socketManager.setKeepAlive(shouldKeepSocketAlive, keepAliveTimeout || 0);\n        });\n      }\n    }, \"registerListener\");\n    if (socketTimeout === 0) {\n      registerKeepAliveListener();\n      return 0;\n    }\n    return timeoutHandler.setTimeout(registerKeepAliveListener, socketTimeout);\n  }, \"setSocketKeepAlive\");\n  var defaultRequestTimeout = 3000;\n  var _handleSocketTimeout = setFunctionName((handleConnectionTimeout, handleTimeoutError, requestTimeout = __defaultRequestTimeout) => {\n    let registerTimeout = setFunctionName(setupConnectionTimeoutHandler => {\n      let remainingTimeout = requestTimeout - setupConnectionTimeoutHandler;\n      let onTimeoutCallback = setFunctionName(() => {\n        handleConnectionTimeout.destroy();\n        handleTimeoutError(Object.assign(Error(`Connection timed out after ${requestTimeout} ms`), {\n          name: \"TimeoutError\"\n        }));\n      }, \"onTimeout\");\n      if (handleConnectionTimeout.socket) {\n        handleConnectionTimeout.socket.setTimeout(remainingTimeout, onTimeoutCallback);\n        handleConnectionTimeout.on(\"close\", () => handleConnectionTimeout.socket?.removeListener(\"timeout\", onTimeoutCallback));\n      } else {\n        handleConnectionTimeout.setTimeout(remainingTimeout, onTimeoutCallback);\n      }\n    }, \"registerTimeout\");\n    if (requestTimeout > 0 && requestTimeout < 6000) {\n      registerTimeout(0);\n      return 0;\n    }\n    return timeoutHandler.setTimeout(registerTimeout.bind(null, requestTimeout === 0 ? 0 : defaultRequestTimeout), defaultRequestTimeout);\n  }, \"setSocketTimeout\");\n  var createStreamModule = EA(\"stream\");\n  var _defaultRequestTimeout = 6000;\n  async function handleContinueExpectations(handleRequestWithContinueExpectation, request, Q = _defaultRequestTimeout) {\n    let I = request.headers ?? {};\n    let G = I.Expect || I.expect;\n    let Z = -1;\n    let Y = true;\n    if (G === \"100-continue\") {\n      Y = await Promise.race([new Promise(scheduleTimeout => {\n        Z = Number(timeoutHandler.setTimeout(() => scheduleTimeout(true), Math.max(_defaultRequestTimeout, Q)));\n      }), new Promise(handleContinueExpectationResponse => {\n        handleRequestWithContinueExpectation.on(\"continue\", () => {\n          timeoutHandler.clearTimeout(Z);\n          handleContinueExpectationResponse(true);\n        });\n        handleRequestWithContinueExpectation.on(\"response\", () => {\n          timeoutHandler.clearTimeout(Z);\n          handleContinueExpectationResponse(false);\n        });\n        handleRequestWithContinueExpectation.on(\"error\", () => {\n          timeoutHandler.clearTimeout(Z);\n          handleContinueExpectationResponse(false);\n        });\n      })]);\n    }\n    if (Y) {\n      pipeToDestinationStream(handleRequestWithContinueExpectation, request.body);\n    }\n  }\n  setFunctionName(handleContinueExpectations, \"writeRequestBody\");\n  function pipeToDestinationStream(destinationStream, _inputData) {\n    if (_inputData instanceof createStreamModule.Readable) {\n      _inputData.pipe(destinationStream);\n      return;\n    }\n    if (_inputData) {\n      if (Buffer.isBuffer(_inputData) || typeof _inputData === \"string\") {\n        destinationStream.end(_inputData);\n        return;\n      }\n      let inputDataObject = _inputData;\n      if (typeof inputDataObject === \"object\" && inputDataObject.buffer && typeof inputDataObject.byteOffset === \"number\" && typeof inputDataObject.byteLength === \"number\") {\n        destinationStream.end(Buffer.from(inputDataObject.buffer, inputDataObject.byteOffset, inputDataObject.byteLength));\n        return;\n      }\n      destinationStream.end(Buffer.from(_inputData));\n      return;\n    }\n    destinationStream.end();\n  }\n  setFunctionName(pipeToDestinationStream, \"writeBody\");\n  var __defaultRequestTimeout = 0;\n  var hA4 = class A {\n    constructor(defaultConfigOrHandler) {\n      this.socketWarningTimestamp = 0;\n      this.metadata = {\n        handlerProtocol: \"http/1.1\"\n      };\n      this.configProvider = new Promise((callbackHandler, ___errorHandler) => {\n        if (typeof defaultConfigOrHandler === \"function\") {\n          defaultConfigOrHandler().then(defaultConfigHandler => {\n            callbackHandler(this.resolveDefaultConfig(defaultConfigHandler));\n          }).catch(___errorHandler);\n        } else {\n          callbackHandler(this.resolveDefaultConfig(defaultConfigOrHandler));\n        }\n      });\n    }\n    static {\n      setFunctionName(this, \"NodeHttpHandler\");\n    }\n    static create(B) {\n      if (typeof B?.handle === \"function\") {\n        return B;\n      }\n      return new A(B);\n    }\n    static checkSocketUsage(B, Q, __logger = console) {\n      let {\n        sockets: G,\n        requests: Z,\n        maxSockets: Y\n      } = B;\n      if (typeof Y !== \"number\" || Y === Infinity) {\n        return Q;\n      }\n      let J = 15000;\n      if (Date.now() - J < Q) {\n        return Q;\n      }\n      if (G && Z) {\n        for (let __index in G) {\n          let socketUsageCount = G[__index]?.length ?? 0;\n          let additionalRequestsQueued = Z[__index]?.length ?? 0;\n          if (socketUsageCount >= Y && additionalRequestsQueued >= Y * 2) {\n            __logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketUsageCount} and ${additionalRequestsQueued} additional requests are enqueued.\nSee https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html\nor increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);\n            return Date.now();\n          }\n        }\n      }\n      return Q;\n    }\n    resolveDefaultConfig(B) {\n      let {\n        requestTimeout: Q,\n        connectionTimeout: I,\n        socketTimeout: G,\n        socketAcquisitionWarningTimeout: Z,\n        httpAgent: Y,\n        httpsAgent: J\n      } = B || {};\n      let X = true;\n      let W = 50;\n      return {\n        connectionTimeout: I,\n        requestTimeout: Q ?? G,\n        socketAcquisitionWarningTimeout: Z,\n        httpAgent: (() => {\n          if (Y instanceof httpAgent.Agent || typeof Y?.destroy === \"function\") {\n            return Y;\n          }\n          return new httpAgent.Agent({\n            keepAlive: true,\n            maxSockets: 50,\n            ...Y\n          });\n        })(),\n        httpsAgent: (() => {\n          if (J instanceof HttpsAgentInstance.Agent || typeof J?.destroy === \"function\") {\n            return J;\n          }\n          return new HttpsAgentInstance.Agent({\n            keepAlive: true,\n            maxSockets: 50,\n            ...J\n          });\n        })(),\n        logger: console\n      };\n    }\n    destroy() {\n      this.config?.httpAgent?.destroy();\n      this.config?.httpsAgent?.destroy();\n    }\n    async handle(B, {\n      abortSignal: _abortSignal\n    } = {}) {\n      if (!this.config) {\n        this.config = await this.configProvider;\n      }\n      return new Promise((handleSuccess, onRequestFailure) => {\n        let requestPromise = undefined;\n        let timeoutHandlers = [];\n        let handleResponse = setFunctionName(async handleRequestResponse => {\n          await requestPromise;\n          timeoutHandlers.forEach(timeoutHandler.clearTimeout);\n          handleSuccess(handleRequestResponse);\n        }, \"resolve\");\n        let promiseRejectHandler = setFunctionName(async handleRequestFailure => {\n          await requestPromise;\n          timeoutHandlers.forEach(timeoutHandler.clearTimeout);\n          onRequestFailure(handleRequestFailure);\n        }, \"reject\");\n        if (!this.config) {\n          throw Error(\"Node HTTP request handler config is not resolved\");\n        }\n        if (_abortSignal?.aborted) {\n          let requestCallback = Error(\"Request aborted\");\n          requestCallback.name = \"AbortError\";\n          promiseRejectHandler(requestCallback);\n          return;\n        }\n        let isHttpsRequest = B.protocol === \"https:\";\n        let agent = isHttpsRequest ? this.config.httpsAgent : this.config.httpAgent;\n        timeoutHandlers.push(timeoutHandler.setTimeout(() => {\n          this.socketWarningTimestamp = A.checkSocketUsage(agent, this.socketWarningTimestamp, this.config.logger);\n        }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));\n        let queryString = (0, _imageProcessingTransformation.buildQueryString)(B.query || {});\n        let credentials = undefined;\n        if (B.username != null || B.password != null) {\n          let requestAbortedError = B.username ?? \"\";\n          let promiseHandler = B.password ?? \"\";\n          credentials = `${requestAbortedError}:${promiseHandler}`;\n        }\n        let requestPath = B.path;\n        if (queryString) {\n          requestPath += `?${queryString}`;\n        }\n        if (B.fragment) {\n          requestPath += `#${B.fragment}`;\n        }\n        let _hostname = B.hostname ?? \"\";\n        if (_hostname[0] === \"[\" && _hostname.endsWith(\"]\")) {\n          _hostname = B.hostname.slice(1, -1);\n        } else {\n          _hostname = B.hostname;\n        }\n        let requestOptions = {\n          headers: B.headers,\n          host: _hostname,\n          method: B.method,\n          path: requestPath,\n          port: B.port,\n          agent: agent,\n          auth: credentials\n        };\n        let httpRequest = (isHttpsRequest ? HttpsAgentInstance.request : httpAgent.request)(requestOptions, __httpResponse => {\n          let ___httpResponse = new initializeHttpResponseProcessor.HttpResponse({\n            statusCode: __httpResponse.statusCode || -1,\n            reason: __httpResponse.statusMessage,\n            headers: transformHeadersToString(__httpResponse.headers),\n            body: __httpResponse\n          });\n          handleResponse({\n            response: ___httpResponse\n          });\n        });\n        httpRequest.on(\"error\", errorResponse => {\n          if (commonNetworkErrors.includes(errorResponse.code)) {\n            promiseRejectHandler(Object.assign(errorResponse, {\n              name: \"TimeoutError\"\n            }));\n          } else {\n            promiseRejectHandler(errorResponse);\n          }\n        });\n        if (_abortSignal) {\n          let errorCallback = setFunctionName(() => {\n            httpRequest.destroy();\n            let _abortError = Error(\"Request aborted\");\n            _abortError.name = \"AbortError\";\n            promiseRejectHandler(_abortError);\n          }, \"onAbort\");\n          if (typeof _abortSignal.addEventListener === \"function\") {\n            let handleRequest = _abortSignal;\n            handleRequest.addEventListener(\"abort\", errorCallback, {\n              once: true\n            });\n            httpRequest.once(\"close\", () => handleRequest.removeEventListener(\"abort\", errorCallback));\n          } else {\n            _abortSignal.onabort = errorCallback;\n          }\n        }\n        timeoutHandlers.push(setConnectionTimeoutHandler(httpRequest, promiseRejectHandler, this.config.connectionTimeout));\n        timeoutHandlers.push(_handleSocketTimeout(httpRequest, promiseRejectHandler, this.config.requestTimeout));\n        let _agent = requestOptions.agent;\n        if (typeof _agent === \"object\" && \"keepAlive\" in _agent) {\n          timeoutHandlers.push(_setSocketKeepAlive(httpRequest, {\n            keepAlive: _agent.keepAlive,\n            keepAliveMsecs: _agent.keepAliveMsecs\n          }));\n        }\n        requestPromise = handleContinueExpectations(httpRequest, B, this.config.requestTimeout).catch(requestFailureHandler => {\n          timeoutHandlers.forEach(timeoutHandler.clearTimeout);\n          return onRequestFailure(requestFailureHandler);\n        });\n      });\n    }\n    updateHttpClientConfig(B, Q) {\n      this.config = undefined;\n      this.configProvider = this.configProvider.then(mergeWithNewProperty => {\n        return {\n          ...mergeWithNewProperty,\n          [B]: Q\n        };\n      });\n    }\n    httpHandlerConfigs() {\n      return this.config ?? {};\n    }\n  };\n  var Http2Protocol = EA(\"http2\");\n  var gA4 = _initializeModule(EA(\"http2\"));\n  var NodeHttp2ConnectionPool = class {\n    constructor(A) {\n      this.sessions = [];\n      this.sessions = A ?? [];\n    }\n    static {\n      setFunctionName(this, \"NodeHttp2ConnectionPool\");\n    }\n    poll() {\n      if (this.sessions.length > 0) {\n        return this.sessions.shift();\n      }\n    }\n    offerLast(A) {\n      this.sessions.push(A);\n    }\n    contains(A) {\n      return this.sessions.includes(A);\n    }\n    remove(A) {\n      this.sessions = this.sessions.filter(isBDifferentFromA => isBDifferentFromA !== A);\n    }\n    [Symbol.iterator]() {\n      return this.sessions[Symbol.iterator]();\n    }\n    destroy(A) {\n      for (let session of this.sessions) {\n        if (session === A) {\n          if (!session.destroyed) {\n            session.destroy();\n          }\n        }\n      }\n    }\n  };\n  var mA4 = class {\n    constructor(A) {\n      this.sessionCache = new Map();\n      this.config = A;\n      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {\n        throw RangeError(\"maxConcurrency must be greater than zero.\");\n      }\n    }\n    static {\n      setFunctionName(this, \"NodeHttp2ConnectionManager\");\n    }\n    lease(A, B) {\n      let Q = this.getUrlString(A);\n      let I = this.sessionCache.get(Q);\n      if (I) {\n        let response = I.poll();\n        if (response && !this.config.disableConcurrency) {\n          return response;\n        }\n      }\n      let G = gA4.default.connect(Q);\n      if (this.config.maxConcurrency) {\n        G.settings({\n          maxConcurrentStreams: this.config.maxConcurrency\n        }, isErrorCondition => {\n          if (isErrorCondition) {\n            throw Error(\"Fail to set maxConcurrentStreams to \" + this.config.maxConcurrency + \"when creating new session for \" + A.destination.toString());\n          }\n        });\n      }\n      G.unref();\n      let Z = setFunctionName(() => {\n        G.destroy();\n        this.deleteSession(Q, G);\n      }, \"destroySessionCb\");\n      G.on(\"goaway\", Z);\n      G.on(\"error\", Z);\n      G.on(\"frameError\", Z);\n      G.on(\"close\", () => this.deleteSession(Q, G));\n      if (B.requestTimeout) {\n        G.setTimeout(B.requestTimeout, Z);\n      }\n      let Y = this.sessionCache.get(Q) || new NodeHttp2ConnectionPool();\n      Y.offerLast(G);\n      this.sessionCache.set(Q, Y);\n      return G;\n    }\n    deleteSession(A, B) {\n      let Q = this.sessionCache.get(A);\n      if (!Q) {\n        return;\n      }\n      if (!Q.contains(B)) {\n        return;\n      }\n      Q.remove(B);\n      this.sessionCache.set(A, Q);\n    }\n    release(A, B) {\n      let Q = this.getUrlString(A);\n      this.sessionCache.get(Q)?.offerLast(B);\n    }\n    destroy() {\n      for (let [sessionKey, sessionItems] of this.sessionCache) {\n        for (let sessionItem of sessionItems) {\n          if (!sessionItem.destroyed) {\n            sessionItem.destroy();\n          }\n          sessionItems.remove(sessionItem);\n        }\n        this.sessionCache.delete(sessionKey);\n      }\n    }\n    setMaxConcurrentStreams(A) {\n      if (A && A <= 0) {\n        throw RangeError(\"maxConcurrentStreams must be greater than zero.\");\n      }\n      this.config.maxConcurrency = A;\n    }\n    setDisableConcurrentStreams(A) {\n      this.config.disableConcurrency = A;\n    }\n    getUrlString(A) {\n      return A.destination.toString();\n    }\n  };\n  var dA4 = class A {\n    constructor(getData) {\n      this.metadata = {\n        handlerProtocol: \"h2\"\n      };\n      this.connectionManager = new mA4({});\n      this.configProvider = new Promise((callbackWithDefaultData, ____errorHandler) => {\n        if (typeof getData === \"function\") {\n          getData().then(defaultDataCallback => {\n            callbackWithDefaultData(defaultDataCallback || {});\n          }).catch(____errorHandler);\n        } else {\n          callbackWithDefaultData(getData || {});\n        }\n      });\n    }\n    static {\n      setFunctionName(this, \"NodeHttp2Handler\");\n    }\n    static create(B) {\n      if (typeof B?.handle === \"function\") {\n        return B;\n      }\n      return new A(B);\n    }\n    destroy() {\n      this.connectionManager.destroy();\n    }\n    async handle(B, {\n      abortSignal: abortSignal\n    } = {}) {\n      if (!this.config) {\n        this.config = await this.configProvider;\n        this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);\n        if (this.config.maxConcurrentStreams) {\n          this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);\n        }\n      }\n      let {\n        requestTimeout: I,\n        disableConcurrentStreams: G\n      } = this.config;\n      return new Promise((_handleHttpRequest, handleRejection) => {\n        let isRequestAborted = false;\n        let httpRequestPromise = undefined;\n        let resolvePromise = setFunctionName(async httpRequestData => {\n          await httpRequestPromise;\n          _handleHttpRequest(httpRequestData);\n        }, \"resolve\");\n        let handleReject = setFunctionName(async requestPayload => {\n          await httpRequestPromise;\n          handleRejection(requestPayload);\n        }, \"reject\");\n        if (abortSignal?.aborted) {\n          isRequestAborted = true;\n          let callbackFunction = Error(\"Request aborted\");\n          callbackFunction.name = \"AbortError\";\n          handleReject(callbackFunction);\n          return;\n        }\n        let {\n          hostname: hostname,\n          method: httpMethod,\n          port: portNumber,\n          protocol: protocolScheme,\n          query: queryParams\n        } = B;\n        let authCredentials = \"\";\n        if (B.username != null || B.password != null) {\n          let callback = B.username ?? \"\";\n          let password = B.password ?? \"\";\n          authCredentials = `${callback}:${password}@`;\n        }\n        let requestUrl = `${protocolScheme}//${authCredentials}${hostname}${portNumber ? `:${portNumber}` : \"\"}`;\n        let connectionRequest = {\n          destination: new URL(requestUrl)\n        };\n        let connectionLease = this.connectionManager.lease(connectionRequest, {\n          requestTimeout: this.config?.sessionTimeout,\n          disableConcurrentStreams: G || false\n        });\n        let handleRequestError = setFunctionName(_____error => {\n          if (G) {\n            this.destroySession(connectionLease);\n          }\n          isRequestAborted = true;\n          handleReject(_____error);\n        }, \"rejectWithDestroy\");\n        let buildQueryString = (0, _imageProcessingTransformation.buildQueryString)(queryParams || {});\n        let P = B.path;\n        if (buildQueryString) {\n          P += `?${buildQueryString}`;\n        }\n        if (B.fragment) {\n          P += `#${B.fragment}`;\n        }\n        let k = connectionLease.request({\n          ...B.headers,\n          [Http2Protocol.constants.HTTP2_HEADER_PATH]: P,\n          [Http2Protocol.constants.HTTP2_HEADER_METHOD]: httpMethod\n        });\n        connectionLease.ref();\n        k.on(\"response\", httpResponseStatus => {\n          let _httpResponse = new initializeHttpResponseProcessor.HttpResponse({\n            statusCode: httpResponseStatus[\":status\"] || -1,\n            headers: transformHeadersToString(httpResponseStatus),\n            body: k\n          });\n          isRequestAborted = true;\n          resolvePromise({\n            response: _httpResponse\n          });\n          if (G) {\n            connectionLease.close();\n            this.connectionManager.deleteSession(requestUrl, connectionLease);\n          }\n        });\n        if (I) {\n          k.setTimeout(I, () => {\n            k.close();\n            let timeoutError = Error(`Stream timed out because of no activity for ${I} ms`);\n            timeoutError.name = \"TimeoutError\";\n            handleRequestError(timeoutError);\n          });\n        }\n        if (abortSignal) {\n          let _callback = setFunctionName(() => {\n            k.close();\n            let abortedRequestError = Error(\"Request aborted\");\n            abortedRequestError.name = \"AbortError\";\n            handleRequestError(abortedRequestError);\n          }, \"onAbort\");\n          if (typeof abortSignal.addEventListener === \"function\") {\n            let _password = abortSignal;\n            _password.addEventListener(\"abort\", _callback, {\n              once: true\n            });\n            k.once(\"close\", () => _password.removeEventListener(\"abort\", _callback));\n          } else {\n            abortSignal.onabort = _callback;\n          }\n        }\n        k.on(\"frameError\", (frameTypeId, errorCode, frameId) => {\n          handleRequestError(Error(`Frame type id ${frameTypeId} in stream id ${frameId} has failed with code ${errorCode}.`));\n        });\n        k.on(\"error\", handleRequestError);\n        k.on(\"aborted\", () => {\n          handleRequestError(Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${k.rstCode}.`));\n        });\n        k.on(\"close\", () => {\n          connectionLease.unref();\n          if (G) {\n            connectionLease.destroy();\n          }\n          if (!isRequestAborted) {\n            handleRequestError(Error(\"Unexpected error: http2 request did not get a response\"));\n          }\n        });\n        httpRequestPromise = handleContinueExpectations(k, B, I);\n      });\n    }\n    updateHttpClientConfig(B, Q) {\n      this.config = undefined;\n      this.configProvider = this.configProvider.then(updateObjectWithNewKey => {\n        return {\n          ...updateObjectWithNewKey,\n          [B]: Q\n        };\n      });\n    }\n    httpHandlerConfigs() {\n      return this.config ?? {};\n    }\n    destroySession(B) {\n      if (!B.destroyed) {\n        B.destroy();\n      }\n    }\n  };\n  var CollectorWritableStream = class extends createStreamModule.Writable {\n    constructor() {\n      super(...arguments);\n      this.bufferedBytes = [];\n    }\n    static {\n      setFunctionName(this, \"Collector\");\n    }\n    _write(A, B, Q) {\n      this.bufferedBytes.push(A);\n      Q();\n    }\n  };\n  var pA4 = setFunctionName(processStreamData => {\n    if (_isReadableStream(processStreamData)) {\n      return readStreamToUint8Array(processStreamData);\n    }\n    return new Promise((processBufferedData, _handleError) => {\n      let streamProcessor = new CollectorWritableStream();\n      processStreamData.pipe(streamProcessor);\n      processStreamData.on(\"error\", handleStreamEnd => {\n        streamProcessor.end();\n        _handleError(handleStreamEnd);\n      });\n      streamProcessor.on(\"error\", _handleError);\n      streamProcessor.on(\"finish\", function () {\n        let bufferedBytesArray = new Uint8Array(Buffer.concat(this.bufferedBytes));\n        processBufferedData(bufferedBytesArray);\n      });\n    });\n  }, \"streamCollector\");\n  var _isReadableStream = setFunctionName(isReadableStreamInstance => typeof ReadableStream === \"function\" && isReadableStreamInstance instanceof ReadableStream, \"isReadableStreamInstance\");\n  async function readStreamToUint8Array(readStreamToByteArray) {\n    let chunksArray = [];\n    let readableStreamReader = readStreamToByteArray.getReader();\n    let isStreamDone = false;\n    let _totalBytesRead = 0;\n    while (!isStreamDone) {\n      let {\n        done: _isDone,\n        value: readAllChunks\n      } = await readableStreamReader.read();\n      if (readAllChunks) {\n        chunksArray.push(readAllChunks);\n        _totalBytesRead += readAllChunks.length;\n      }\n      isStreamDone = _isDone;\n    }\n    let uint8Array = new Uint8Array(_totalBytesRead);\n    let currentIndex = 0;\n    for (let _chunk of chunksArray) {\n      uint8Array.set(_chunk, currentIndex);\n      currentIndex += _chunk.length;\n    }\n    return uint8Array;\n  }\n  setFunctionName(readStreamToUint8Array, \"collectReadableStream\");\n});\nvar _________________________________processImageTransformation = z((initializeModuleExports, ________________moduleExports) => {\n  var {\n    defineProperty: _______defineProperty,\n    getOwnPropertyDescriptor: _______________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ______________getOwnPropertyNames\n  } = Object;\n  var ______________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _defineFunctionWithName = (A, B) => _______defineProperty(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var definePropertyGetters = (A, B) => {\n    for (var Q in B) {\n      _______defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var __definePropertiesFromSource = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ___________________propertyName of ______________getOwnPropertyNames(B)) {\n        if (!______________hasOwnProperty.call(A, ___________________propertyName) && ___________________propertyName !== Q) {\n          _______defineProperty(A, ___________________propertyName, {\n            get: () => B[___________________propertyName],\n            enumerable: !(I = _______________getOwnPropertyDescriptor(B, ___________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var _createModuleExports = A => __definePropertiesFromSource(_______defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _________________moduleExports = {};\n  definePropertyGetters(_________________moduleExports, {\n    AlgorithmId: () => tg0,\n    EndpointURLScheme: () => og0,\n    FieldPosition: () => eg0,\n    HttpApiKeyAuthLocation: () => rg0,\n    HttpAuthLocation: () => sg0,\n    IniSectionType: () => Au0,\n    RequestHandlerProtocol: () => Bu0,\n    SMITHY_CONTEXT_KEY: () => ____SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => A14,\n    resolveDefaultRuntimeConfig: () => B14\n  });\n  ________________moduleExports.exports = _createModuleExports(_________________moduleExports);\n  var sg0 = (_defineConstants => {\n    _defineConstants.HEADER = \"header\";\n    _defineConstants.QUERY = \"query\";\n    return _defineConstants;\n  })(sg0 || {});\n  var rg0 = (createQueryHeader => {\n    createQueryHeader.HEADER = \"header\";\n    createQueryHeader.QUERY = \"query\";\n    return createQueryHeader;\n  })(rg0 || {});\n  var og0 = (protocols => {\n    protocols.HTTP = \"http\";\n    protocols.HTTPS = \"https\";\n    return protocols;\n  })(og0 || {});\n  var tg0 = (hashAlgorithmConstants => {\n    hashAlgorithmConstants.MD5 = \"md5\";\n    hashAlgorithmConstants.CRC32 = \"crc32\";\n    hashAlgorithmConstants.CRC32C = \"crc32c\";\n    hashAlgorithmConstants.SHA1 = \"sha1\";\n    hashAlgorithmConstants.SHA256 = \"sha256\";\n    return hashAlgorithmConstants;\n  })(tg0 || {});\n  var ______createChecksumAlgorithmManager = _defineFunctionWithName(___createChecksumAlgorithmManager => {\n    let _____checksumAlgorithmsList = [];\n    if (___createChecksumAlgorithmManager.sha256 !== undefined) {\n      _____checksumAlgorithmsList.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => ___createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (___createChecksumAlgorithmManager.md5 != null) {\n      _____checksumAlgorithmsList.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => ___createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(___checksumAlgorithm) {\n        _____checksumAlgorithmsList.push(___checksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return _____checksumAlgorithmsList;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var _generateChecksumConstructorMap = _defineFunctionWithName(__generateChecksumMap => {\n    let __checksumConstructorsByAlgorithmId = {};\n    __generateChecksumMap.checksumAlgorithms().forEach(__checksumConstructor => {\n      __checksumConstructorsByAlgorithmId[__checksumConstructor.algorithmId()] = __checksumConstructor.checksumConstructor();\n    });\n    return __checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var A14 = _defineFunctionWithName(calculateTax => {\n    return ______createChecksumAlgorithmManager(calculateTax);\n  }, \"getDefaultClientConfiguration\");\n  var B14 = _defineFunctionWithName(getProcessedValue => {\n    return _generateChecksumConstructorMap(getProcessedValue);\n  }, \"resolveDefaultRuntimeConfig\");\n  var eg0 = (MessageTypes => {\n    MessageTypes[MessageTypes.HEADER = 0] = \"HEADER\";\n    MessageTypes[MessageTypes.TRAILER = 1] = \"TRAILER\";\n    return MessageTypes;\n  })(eg0 || {});\n  var ____SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var Au0 = (setUserProfileConstants => {\n    setUserProfileConstants.PROFILE = \"profile\";\n    setUserProfileConstants.SSO_SESSION = \"sso-session\";\n    setUserProfileConstants.SERVICES = \"services\";\n    return setUserProfileConstants;\n  })(Au0 || {});\n  var Bu0 = (defineProtocolVersions => {\n    defineProtocolVersions.HTTP_0_9 = \"http/0.9\";\n    defineProtocolVersions.HTTP_1_0 = \"http/1.0\";\n    defineProtocolVersions.TDS_8_0 = \"tds/8.0\";\n    return defineProtocolVersions;\n  })(Bu0 || {});\n});\nvar ________________imageTransformationProcessor = z((httpHandlerExtensionConfigFactory, ________moduleExports) => {\n  var {\n    defineProperty: definePropertyWithMetadata,\n    getOwnPropertyDescriptor: getPropertyDescriptor,\n    getOwnPropertyNames: getObjectPropertyNames\n  } = Object;\n  var _________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _________________definePropertyWithName = (A, B) => definePropertyWithMetadata(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _definePropertiesWithGetters = (A, B) => {\n    for (var Q in B) {\n      definePropertyWithMetadata(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var _defineNonEnumerableProperties = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ____________________propertyName of getObjectPropertyNames(B)) {\n        if (!_________hasOwnProperty.call(A, ____________________propertyName) && ____________________propertyName !== Q) {\n          definePropertyWithMetadata(A, ____________________propertyName, {\n            get: () => B[____________________propertyName],\n            enumerable: !(I = getPropertyDescriptor(B, ____________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var defineHttpHandlerExtensionConfiguration = A => _defineNonEnumerableProperties(definePropertyWithMetadata({}, \"__esModule\", {\n    value: true\n  }), A);\n  var httpHandlerConfiguration = {};\n  _definePropertiesWithGetters(httpHandlerConfiguration, {\n    Field: () => HttpHeader,\n    Fields: () => HttpHeadersCollection,\n    HttpRequest: () => K14,\n    HttpResponse: () => _HttpResponseHandler,\n    IHttpRequest: () => ____________________________________________processImageTransformation.HttpRequest,\n    getHttpHandlerExtensionConfiguration: () => __getHttpHandlerExtensionConfiguration,\n    isValidHostname: () => __isValidUsername,\n    resolveHttpHandlerRuntimeConfig: () => __resolveHttpHandlerConfig\n  });\n  ________moduleExports.exports = defineHttpHandlerExtensionConfiguration(httpHandlerConfiguration);\n  var __getHttpHandlerExtensionConfiguration = _________________definePropertyWithName(____createHttpHandlerManager => {\n    return {\n      setHttpHandler(___httpHandler) {\n        ____createHttpHandlerManager.httpHandler = ___httpHandler;\n      },\n      httpHandler() {\n        return ____createHttpHandlerManager.httpHandler;\n      },\n      updateHttpClientConfig(_______httpClientConfig, ________httpClientConfig) {\n        ____createHttpHandlerManager.httpHandler?.updateHttpClientConfig(_______httpClientConfig, ________httpClientConfig);\n      },\n      httpHandlerConfigs() {\n        return ____createHttpHandlerManager.httpHandler.httpHandlerConfigs();\n      }\n    };\n  }, \"getHttpHandlerExtensionConfiguration\");\n  var __resolveHttpHandlerConfig = _________________definePropertyWithName(____createHttpHandler => {\n    return {\n      httpHandler: ____createHttpHandler.httpHandler()\n    };\n  }, \"resolveHttpHandlerRuntimeConfig\");\n  var ____________________________________________processImageTransformation = _________________________________processImageTransformation();\n  var HttpHeader = class {\n    static {\n      _________________definePropertyWithName(this, \"Field\");\n    }\n    constructor({\n      name: ___headerName,\n      kind: __fieldPosition = ____________________________________________processImageTransformation.FieldPosition.HEADER,\n      values: defaultValues = []\n    }) {\n      this.name = ___headerName;\n      this.kind = __fieldPosition;\n      this.values = defaultValues;\n    }\n    add(A) {\n      this.values.push(A);\n    }\n    set(A) {\n      this.values = A;\n    }\n    remove(A) {\n      this.values = this.values.filter(isBNotEqualToA => isBNotEqualToA !== A);\n    }\n    toString() {\n      return this.values.map(____formattedString => ____formattedString.includes(\",\") || ____formattedString.includes(\" \") ? `\"${____formattedString}\"` : ____formattedString).join(\", \");\n    }\n    get() {\n      return this.values;\n    }\n  };\n  var HttpHeadersCollection = class {\n    constructor({\n      fields: _fieldsArray = [],\n      encoding: ____defaultEncoding = \"utf-8\"\n    }) {\n      this.entries = {};\n      _fieldsArray.forEach(this.setField.bind(this));\n      this.encoding = ____defaultEncoding;\n    }\n    static {\n      _________________definePropertyWithName(this, \"Fields\");\n    }\n    setField(A) {\n      this.entries[A.name.toLowerCase()] = A;\n    }\n    getField(A) {\n      return this.entries[A.toLowerCase()];\n    }\n    removeField(A) {\n      delete this.entries[A.toLowerCase()];\n    }\n    getByType(A) {\n      return Object.values(this.entries).filter(___isKindOfA => ___isKindOfA.kind === A);\n    }\n  };\n  var K14 = class A {\n    static {\n      _________________definePropertyWithName(this, \"HttpRequest\");\n    }\n    constructor(B) {\n      this.method = B.method || \"GET\";\n      this.hostname = B.hostname || \"localhost\";\n      this.port = B.port;\n      this.query = B.query || {};\n      this.headers = B.headers || {};\n      this.body = B.body;\n      this.protocol = B.protocol ? B.protocol.slice(-1) !== \":\" ? `${B.protocol}:` : B.protocol : \"https:\";\n      this.path = B.path ? B.path.charAt(0) !== \"/\" ? `/${B.path}` : B.path : \"/\";\n      this.username = B.username;\n      this.password = B.password;\n      this.fragment = B.fragment;\n    }\n    static clone(B) {\n      let Q = new A({\n        ...B,\n        headers: {\n          ...B.headers\n        }\n      });\n      if (Q.query) {\n        Q.query = cloneObjectProperties(Q.query);\n      }\n      return Q;\n    }\n    static isInstance(B) {\n      if (!B) {\n        return false;\n      }\n      let Q = B;\n      return \"method\" in Q && \"protocol\" in Q && \"hostname\" in Q && \"path\" in Q && typeof Q.query === \"object\" && typeof Q.headers === \"object\";\n    }\n    clone() {\n      return A.clone(this);\n    }\n  };\n  function cloneObjectProperties(copyObjectWithArrayValues) {\n    return Object.keys(copyObjectWithArrayValues).reduce((mergeAndCopyArrayValues, arrayValueKey) => {\n      let arrayCopy = copyObjectWithArrayValues[arrayValueKey];\n      return {\n        ...mergeAndCopyArrayValues,\n        [arrayValueKey]: Array.isArray(arrayCopy) ? [...arrayCopy] : arrayCopy\n      };\n    }, {});\n  }\n  _________________definePropertyWithName(cloneObjectProperties, \"cloneQuery\");\n  var _HttpResponseHandler = class {\n    static {\n      _________________definePropertyWithName(this, \"HttpResponse\");\n    }\n    constructor(A) {\n      this.statusCode = A.statusCode;\n      this.reason = A.reason;\n      this.headers = A.headers || {};\n      this.body = A.body;\n    }\n    static isInstance(A) {\n      if (!A) {\n        return false;\n      }\n      let B = A;\n      return typeof B.statusCode === \"number\" && typeof B.headers === \"object\";\n    }\n  };\n  function __isValidUsername(___isValidUsername) {\n    return /^[a-z0-9][a-z0-9\\.\\-]*[a-z0-9]$/.test(___isValidUsername);\n  }\n  _________________definePropertyWithName(__isValidUsername, \"isValidHostname\");\n});\nvar __________________________________processImageTransformation = z((defineEscapeUriFunctions, _initializeExports) => {\n  var {\n    defineProperty: _____________definePropertyWithName,\n    getOwnPropertyDescriptor: __________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _________________________getOwnPropertyNames\n  } = Object;\n  var ____hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var definePropertyWithNameAndDescription = (A, B) => _____________definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var defineGetterProperties = (A, B) => {\n    for (var Q in B) {\n      _____________definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var _definePropertyForObject = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _____________________propertyName of _________________________getOwnPropertyNames(B)) {\n        if (!____hasOwnPropertyCheck.call(A, _____________________propertyName) && _____________________propertyName !== Q) {\n          _____________definePropertyWithName(A, _____________________propertyName, {\n            get: () => B[_____________________propertyName],\n            enumerable: !(I = __________________________getOwnPropertyDescriptor(B, _____________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createModuleWithExport = A => _definePropertyForObject(_____________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var uriEncoderModule = {};\n  defineGetterProperties(uriEncoderModule, {\n    escapeUri: () => Cu0,\n    escapeUriPath: () => N14\n  });\n  _initializeExports.exports = createModuleWithExport(uriEncoderModule);\n  var Cu0 = definePropertyWithNameAndDescription(encodedURIComponent => encodeURIComponent(encodedURIComponent).replace(/[!'()*]/g, convertCharacterToHexString), \"escapeUri\");\n  var convertCharacterToHexString = definePropertyWithNameAndDescription(convertCharToHexString => `%${convertCharToHexString.charCodeAt(0).toString(16).toUpperCase()}`, \"hexEncode\");\n  var N14 = definePropertyWithNameAndDescription(_splitAndTransformPath => _splitAndTransformPath.split(\"/\").map(Cu0).join(\"/\"), \"escapeUriPath\");\n});\nvar __processImageTransformationFunction = z((transformImageAndBuildQueryString, processAndExportModule) => {\n  var {\n    defineProperty: definePropertyDescriptor,\n    getOwnPropertyDescriptor: ________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: ______________________getOwnPropertyNames\n  } = Object;\n  var ___hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var _____defineFunctionName = (A, B) => definePropertyDescriptor(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _assignProperties = (A, B) => {\n    for (var Q in B) {\n      definePropertyDescriptor(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var copyObjectProperties = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let __propertyKey of ______________________getOwnPropertyNames(B)) {\n        if (!___hasOwnPropertyCheck.call(A, __propertyKey) && __propertyKey !== Q) {\n          definePropertyDescriptor(A, __propertyKey, {\n            get: () => B[__propertyKey],\n            enumerable: !(I = ________________________getOwnPropertyDescriptor(B, __propertyKey)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createModuleExportsWithEscapedProperties = A => copyObjectProperties(definePropertyDescriptor({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _______________________moduleExports = {};\n  _assignProperties(_______________________moduleExports, {\n    buildQueryString: () => _convertObjectToQueryString\n  });\n  processAndExportModule.exports = createModuleExportsWithEscapedProperties(_______________________moduleExports);\n  var _______________________________________________processImageTransformation = __________________________________processImageTransformation();\n  function _convertObjectToQueryString(convertObjectToQueryString) {\n    let B = [];\n    for (let Q of Object.keys(convertObjectToQueryString).sort()) {\n      let value = convertObjectToQueryString[Q];\n      Q = (0, _______________________________________________processImageTransformation.escapeUri)(Q);\n      if (Array.isArray(value)) {\n        for (let _________index = 0, valueLength = value.length; _________index < valueLength; _________index++) {\n          B.push(`${Q}=${(0, _______________________________________________processImageTransformation.escapeUri)(value[_________index])}`);\n        }\n      } else {\n        let ____index = Q;\n        if (value || typeof value === \"string\") {\n          ____index += `=${(0, _______________________________________________processImageTransformation.escapeUri)(value)}`;\n        }\n        B.push(____index);\n      }\n    }\n    return B.join(\"&\");\n  }\n  _____defineFunctionName(_convertObjectToQueryString, \"buildQueryString\");\n});\nvar Ou0 = z((httpRequestHandler, ModuleExports) => {\n  var {\n    defineProperty: definePropertyWithSetter,\n    getOwnPropertyDescriptor: ____getOwnPropertyDescriptor,\n    getOwnPropertyNames: ____getOwnPropertyNames\n  } = Object;\n  var ____hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _setFunctionName = (A, B) => definePropertyWithSetter(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var _____defineProperties = (A, B) => {\n    for (var Q in B) {\n      definePropertyWithSetter(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var assignPropertiesFromSource = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ______________________propertyName of ____getOwnPropertyNames(B)) {\n        if (!____hasOwnProperty.call(A, ______________________propertyName) && ______________________propertyName !== Q) {\n          definePropertyWithSetter(A, ______________________propertyName, {\n            get: () => B[______________________propertyName],\n            enumerable: !(I = ____getOwnPropertyDescriptor(B, ______________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createModuleExports = A => assignPropertiesFromSource(definePropertyWithSetter({}, \"__esModule\", {\n    value: true\n  }), A);\n  var httpHandlerExports = {};\n  _____defineProperties(httpHandlerExports, {\n    FetchHttpHandler: () => f14,\n    keepAliveSupport: () => httpKeepAliveSupport,\n    streamCollector: () => g14\n  });\n  ModuleExports.exports = createModuleExports(httpHandlerExports);\n  var ________________________imageTransformationProcessor = ________________imageTransformationProcessor();\n  var ____processImageTransformationFunction = __processImageTransformationFunction();\n  function createRequest(urlOrRequestOptions, requestInitOptions) {\n    return new Request(urlOrRequestOptions, requestInitOptions);\n  }\n  _setFunctionName(createRequest, \"createRequest\");\n  function createTimeoutPromise(__timeoutDuration = 0) {\n    return new Promise((_handleTimeoutError, ___handleError) => {\n      if (__timeoutDuration) {\n        setTimeout(() => {\n          let _timeoutError = Error(`Request did not complete within ${__timeoutDuration} ms`);\n          _timeoutError.name = \"TimeoutError\";\n          ___handleError(_timeoutError);\n        }, __timeoutDuration);\n      }\n    });\n  }\n  _setFunctionName(createTimeoutPromise, \"requestTimeout\");\n  var httpKeepAliveSupport = {\n    supported: undefined\n  };\n  var f14 = class A {\n    static {\n      _setFunctionName(this, \"FetchHttpHandler\");\n    }\n    static create(B) {\n      if (typeof B?.handle === \"function\") {\n        return B;\n      }\n      return new A(B);\n    }\n    constructor(B) {\n      if (typeof B === \"function\") {\n        this.configProvider = B().then(optionsObject => optionsObject || {});\n      } else {\n        this.config = B ?? {};\n        this.configProvider = Promise.resolve(this.config);\n      }\n      if (httpKeepAliveSupport.supported === undefined) {\n        httpKeepAliveSupport.supported = Boolean(typeof Request !== \"undefined\" && \"keepalive\" in createRequest(\"https://[::1]\"));\n      }\n    }\n    destroy() {}\n    async handle(B, {\n      abortSignal: __abortSignal\n    } = {}) {\n      if (!this.config) {\n        this.config = await this.configProvider;\n      }\n      let I = this.config.requestTimeout;\n      let G = this.config.keepAlive === true;\n      let Z = this.config.credentials;\n      if (__abortSignal?.aborted) {\n        let abortError = Error(\"Request aborted\");\n        abortError.name = \"AbortError\";\n        return Promise.reject(abortError);\n      }\n      let Y = B.path;\n      let J = (0, ____processImageTransformationFunction.buildQueryString)(B.query || {});\n      if (J) {\n        Y += `?${J}`;\n      }\n      if (B.fragment) {\n        Y += `#${B.fragment}`;\n      }\n      let X = \"\";\n      if (B.username != null || B.password != null) {\n        let errorAbort = B.username ?? \"\";\n        let __password = B.password ?? \"\";\n        X = `${errorAbort}:${__password}@`;\n      }\n      let {\n        port: W,\n        method: F\n      } = B;\n      let C = `${B.protocol}//${X}${B.hostname}${W ? `:${W}` : \"\"}${Y}`;\n      let V = F === \"GET\" || F === \"HEAD\" ? undefined : B.body;\n      let K = {\n        body: V,\n        headers: new Headers(B.headers),\n        method: F,\n        credentials: Z\n      };\n      if (this.config?.cache) {\n        K.cache = this.config.cache;\n      }\n      if (V) {\n        K.duplex = \"half\";\n      }\n      if (typeof AbortController !== \"undefined\") {\n        K.signal = __abortSignal;\n      }\n      if (httpKeepAliveSupport.supported) {\n        K.keepalive = G;\n      }\n      if (typeof this.config.requestInit === \"function\") {\n        Object.assign(K, this.config.requestInit(B));\n      }\n      let D = _setFunctionName(() => {}, \"removeSignalEventListener\");\n      let E = createRequest(C, K);\n      let H = [fetch(E).then(httpResponseHandler => {\n        let responseHeaders = httpResponseHandler.headers;\n        let headersMap = {};\n        for (let headerEntry of responseHeaders.entries()) {\n          headersMap[headerEntry[0]] = headerEntry[1];\n        }\n        if (httpResponseHandler.body == null) {\n          return httpResponseHandler.blob().then(httpResponseBody => ({\n            response: new ________________________imageTransformationProcessor.HttpResponse({\n              headers: headersMap,\n              reason: httpResponseHandler.statusText,\n              statusCode: httpResponseHandler.status,\n              body: httpResponseBody\n            })\n          }));\n        }\n        return {\n          response: new ________________________imageTransformationProcessor.HttpResponse({\n            headers: headersMap,\n            reason: httpResponseHandler.statusText,\n            statusCode: httpResponseHandler.status,\n            body: httpResponseHandler.body\n          })\n        };\n      }), createTimeoutPromise(I)];\n      if (__abortSignal) {\n        H.push(new Promise((onAbortSignalReceived, handleAbortError) => {\n          let handleAbortSignal = _setFunctionName(() => {\n            let __abortError = Error(\"Request aborted\");\n            __abortError.name = \"AbortError\";\n            handleAbortError(__abortError);\n          }, \"onAbort\");\n          if (typeof __abortSignal.addEventListener === \"function\") {\n            let abortErrorCreator = __abortSignal;\n            abortErrorCreator.addEventListener(\"abort\", handleAbortSignal, {\n              once: true\n            });\n            D = _setFunctionName(() => abortErrorCreator.removeEventListener(\"abort\", handleAbortSignal), \"removeSignalEventListener\");\n          } else {\n            __abortSignal.onabort = handleAbortSignal;\n          }\n        }));\n      }\n      return Promise.race(H).finally(D);\n    }\n    updateHttpClientConfig(B, Q) {\n      this.config = undefined;\n      this.configProvider = this.configProvider.then(indexMapping => {\n        indexMapping[B] = Q;\n        return indexMapping;\n      });\n    }\n    httpHandlerConfigs() {\n      return this.config ?? {};\n    }\n  };\n  var h14 = h0A();\n  var g14 = _setFunctionName(async convertBlobToUint8Array => {\n    if (typeof Blob === \"function\" && convertBlobToUint8Array instanceof Blob || convertBlobToUint8Array.constructor?.name === \"Blob\") {\n      if (Blob.prototype.arrayBuffer !== undefined) {\n        return new Uint8Array(await convertBlobToUint8Array.arrayBuffer());\n      }\n      return qu0(convertBlobToUint8Array);\n    }\n    return _readStreamToUint8Array(convertBlobToUint8Array);\n  }, \"streamCollector\");\n  async function qu0(fileInput) {\n    let B = await readFileAsDataURL(fileInput);\n    let Q = (0, h14.fromBase64)(B);\n    return new Uint8Array(Q);\n  }\n  _setFunctionName(qu0, \"collectBlob\");\n  async function _readStreamToUint8Array(__readStreamToUint8Array) {\n    let _chunksArray = [];\n    let _readableStreamReader = __readStreamToUint8Array.getReader();\n    let __isStreamDone = false;\n    let __totalBytesRead = 0;\n    while (!__isStreamDone) {\n      let {\n        done: __isDone,\n        value: readStreamIntoUint8Array\n      } = await _readableStreamReader.read();\n      if (readStreamIntoUint8Array) {\n        _chunksArray.push(readStreamIntoUint8Array);\n        __totalBytesRead += readStreamIntoUint8Array.length;\n      }\n      __isStreamDone = __isDone;\n    }\n    let combinedUint8Array = new Uint8Array(__totalBytesRead);\n    let currentOffset = 0;\n    for (let __chunk of _chunksArray) {\n      combinedUint8Array.set(__chunk, currentOffset);\n      currentOffset += __chunk.length;\n    }\n    return combinedUint8Array;\n  }\n  _setFunctionName(_readStreamToUint8Array, \"collectStream\");\n  function readFileAsDataURL(_readFileAsDataURL) {\n    return new Promise((handleFileRead, ___errorCallback) => {\n      let fileReader = new FileReader();\n      fileReader.onloadend = () => {\n        if (fileReader.readyState !== 2) {\n          return ___errorCallback(Error(\"Reader aborted too early\"));\n        }\n        let resultData = fileReader.result ?? \"\";\n        let commaIndex = resultData.indexOf(\",\");\n        let substringStartIndex = commaIndex > -1 ? commaIndex + 1 : resultData.length;\n        handleFileRead(resultData.substring(substringStartIndex));\n      };\n      fileReader.onabort = () => ___errorCallback(Error(\"Read aborted\"));\n      fileReader.onerror = () => ___errorCallback(fileReader.error);\n      fileReader.readAsDataURL(_readFileAsDataURL);\n    });\n  }\n  _setFunctionName(readFileAsDataURL, \"readToBase64\");\n});\nvar imageTransformationHandler = z((hexadecimalConverter, ______________________moduleExports) => {\n  var {\n    defineProperty: ________definePropertyWithName,\n    getOwnPropertyDescriptor: getObjectPropertyDescriptor,\n    getOwnPropertyNames: ___________________getOwnPropertyNames\n  } = Object;\n  var __hasOwnPropertyCheck = Object.prototype.hasOwnProperty;\n  var ___defineFunctionName = (A, B) => ________definePropertyWithName(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var ______________defineProperties = (A, B) => {\n    for (var Q in B) {\n      ________definePropertyWithName(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesIfNotExists = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _______________________propertyName of ___________________getOwnPropertyNames(B)) {\n        if (!__hasOwnPropertyCheck.call(A, _______________________propertyName) && _______________________propertyName !== Q) {\n          ________definePropertyWithName(A, _______________________propertyName, {\n            get: () => B[_______________________propertyName],\n            enumerable: !(I = getObjectPropertyDescriptor(B, _______________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var __createModuleExports = A => definePropertiesIfNotExists(________definePropertyWithName({}, \"__esModule\", {\n    value: true\n  }), A);\n  var hexConversionModule = {};\n  ______________defineProperties(hexConversionModule, {\n    fromHex: () => convertHexStringToUint8Array,\n    toHex: () => convertByteArrayToHexString\n  });\n  ______________________moduleExports.exports = __createModuleExports(hexConversionModule);\n  var hexValueMap = {};\n  var hexCharacterToDecimalMap = {};\n  for (let decimalToHexMappingIndex = 0; decimalToHexMappingIndex < 256; decimalToHexMappingIndex++) {\n    let hexValue = decimalToHexMappingIndex.toString(16).toLowerCase();\n    if (hexValue.length === 1) {\n      hexValue = `0${hexValue}`;\n    }\n    hexValueMap[decimalToHexMappingIndex] = hexValue;\n    hexCharacterToDecimalMap[hexValue] = decimalToHexMappingIndex;\n  }\n  function convertHexStringToUint8Array(hexStringToUint8Array) {\n    if (hexStringToUint8Array.length % 2 !== 0) {\n      throw Error(\"Hex encoded strings must have an even number length\");\n    }\n    let _uint8Array = new Uint8Array(hexStringToUint8Array.length / 2);\n    for (let Q = 0; Q < hexStringToUint8Array.length; Q += 2) {\n      let hexPair = hexStringToUint8Array.slice(Q, Q + 2).toLowerCase();\n      if (hexPair in hexCharacterToDecimalMap) {\n        _uint8Array[Q / 2] = hexCharacterToDecimalMap[hexPair];\n      } else {\n        throw Error(`Cannot decode unrecognized sequence ${hexPair} as hexadecimal`);\n      }\n    }\n    return _uint8Array;\n  }\n  ___defineFunctionName(convertHexStringToUint8Array, \"fromHex\");\n  function convertByteArrayToHexString(byteArrayToHexString) {\n    let B = \"\";\n    for (let Q = 0; Q < byteArrayToHexString.byteLength; Q++) {\n      B += hexValueMap[byteArrayToHexString[Q]];\n    }\n    return B;\n  }\n  ___defineFunctionName(convertByteArrayToHexString, \"toHex\");\n});\nvar fu0 = z(streamTransformationMixin => {\n  Object.defineProperty(streamTransformationMixin, \"__esModule\", {\n    value: true\n  });\n  streamTransformationMixin.sdkStreamMixin = undefined;\n  var i14 = Ou0();\n  var n14 = h0A();\n  var __imageTransformationHandler = imageTransformationHandler();\n  var s14 = ___________________imageProcessingPipeline();\n  var _____________________________________________processImageTransformation = processImageTransformatio();\n  var streamTransformationErrorMessage = \"The stream has already been transformed.\";\n  var r14 = A => {\n    if (!isBlobInstance(A) && !(0, _____________________________________________processImageTransformation.isReadableStream)(A)) {\n      let Y = A?.__proto__?.constructor?.name || A;\n      throw Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${Y}`);\n    }\n    let I = false;\n    let G = async () => {\n      if (I) {\n        throw Error(streamTransformationErrorMessage);\n      }\n      I = true;\n      return await (0, i14.streamCollector)(A);\n    };\n    let Z = Y => {\n      if (typeof Y.stream !== \"function\") {\n        throw Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);\n      }\n      return Y.stream();\n    };\n    return Object.assign(A, {\n      transformToByteArray: G,\n      transformToString: async Y => {\n        let J = await G();\n        if (Y === \"base64\") {\n          return (0, n14.toBase64)(J);\n        } else if (Y === \"hex\") {\n          return (0, __imageTransformationHandler.toHex)(J);\n        } else if (Y === undefined || Y === \"utf8\" || Y === \"utf-8\") {\n          return (0, s14.toUtf8)(J);\n        } else if (typeof TextDecoder === \"function\") {\n          return new TextDecoder(Y).decode(J);\n        } else {\n          throw Error(\"TextDecoder is not available, please make sure polyfill is provided.\");\n        }\n      },\n      transformToWebStream: () => {\n        if (I) {\n          throw Error(streamTransformationErrorMessage);\n        }\n        I = true;\n        if (isBlobInstance(A)) {\n          return Z(A);\n        } else if ((0, _____________________________________________processImageTransformation.isReadableStream)(A)) {\n          return A;\n        } else {\n          throw Error(`Cannot transform payload to web stream, got ${A}`);\n        }\n      }\n    });\n  };\n  streamTransformationMixin.sdkStreamMixin = r14;\n  var isBlobInstance = _isBlobInstance => typeof Blob === \"function\" && _isBlobInstance instanceof Blob;\n});\nvar mu0 = z(_streamTransformationMixin => {\n  Object.defineProperty(_streamTransformationMixin, \"__esModule\", {\n    value: true\n  });\n  _streamTransformationMixin.sdkStreamMixin = undefined;\n  var o14 = processAndExportImageTransformation();\n  var processImageTransformationUtil = ________________________________________processImageTransformation();\n  var StreamMixin = EA(\"stream\");\n  var e14 = fu0();\n  var errorMessageStreamTransformed = \"The stream has already been transformed.\";\n  var A04 = A => {\n    if (!(A instanceof StreamMixin.Readable)) {\n      try {\n        return (0, e14.sdkStreamMixin)(A);\n      } catch (____error) {\n        let constructorName = A?.__proto__?.constructor?.name || A;\n        throw Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${constructorName}`);\n      }\n    }\n    let I = false;\n    let G = async () => {\n      if (I) {\n        throw Error(errorMessageStreamTransformed);\n      }\n      I = true;\n      return await (0, o14.streamCollector)(A);\n    };\n    return Object.assign(A, {\n      transformToByteArray: G,\n      transformToString: async Z => {\n        let Y = await G();\n        if (Z === undefined || Buffer.isEncoding(Z)) {\n          return (0, processImageTransformationUtil.fromArrayBuffer)(Y.buffer, Y.byteOffset, Y.byteLength).toString(Z);\n        } else {\n          return new TextDecoder(Z).decode(Y);\n        }\n      },\n      transformToWebStream: () => {\n        if (I) {\n          throw Error(errorMessageStreamTransformed);\n        }\n        if (A.readableFlowing !== null) {\n          throw Error(\"The stream has been consumed by other callbacks.\");\n        }\n        if (typeof StreamMixin.Readable.toWeb !== \"function\") {\n          throw Error(\"Readable.toWeb() is not supported. Please ensure a polyfill is available.\");\n        }\n        I = true;\n        return StreamMixin.Readable.toWeb(A);\n      }\n    });\n  };\n  _streamTransformationMixin.sdkStreamMixin = A04;\n});\nvar ___________________________________processImageTransformation = z(___streamUtils => {\n  Object.defineProperty(___streamUtils, \"__esModule\", {\n    value: true\n  });\n  ___streamUtils.splitStream = streamTeeProcessor;\n  async function streamTeeProcessor(streamSource) {\n    if (typeof streamSource.stream === \"function\") {\n      streamSource = streamSource.stream();\n    }\n    return streamSource.tee();\n  }\n});\nvar _________________imageTransformationProcessor = z(_streamUtils => {\n  Object.defineProperty(_streamUtils, \"__esModule\", {\n    value: true\n  });\n  _streamUtils.splitStream = G04;\n  var __streamUtils = EA(\"stream\");\n  var _________________________________________________processImageTransformation = ___________________________________processImageTransformation();\n  var imageTransformationUtils = processImageTransformatio();\n  async function G04(__inputStream) {\n    if ((0, imageTransformationUtils.isReadableStream)(__inputStream) || (0, imageTransformationUtils.isBlob)(__inputStream)) {\n      return (0, _________________________________________________processImageTransformation.splitStream)(__inputStream);\n    }\n    let B = new __streamUtils.PassThrough();\n    let Q = new __streamUtils.PassThrough();\n    __inputStream.pipe(B);\n    __inputStream.pipe(Q);\n    return [B, Q];\n  }\n});\nvar Ag = z((_initializeModuleExports, ___________________moduleExports) => {\n  var {\n    defineProperty: ________defineProperty,\n    getOwnPropertyDescriptor: __________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNamesEnhanced\n  } = Object;\n  var _________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___setFunctionName = (A, B) => ________defineProperty(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var ____________defineProperties = (A, B) => {\n    for (var Q in B) {\n      ________defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var addPropertiesFromObject = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ________________________propertyName of getOwnPropertyNamesEnhanced(B)) {\n        if (!_________________hasOwnProperty.call(A, ________________________propertyName) && ________________________propertyName !== Q) {\n          ________defineProperty(A, ________________________propertyName, {\n            get: () => B[________________________propertyName],\n            enumerable: !(I = __________________getOwnPropertyDescriptor(B, ________________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var addPropertiesAndExport = (A, B, Q) => {\n    addPropertiesFromObject(A, B, \"default\");\n    return Q && addPropertiesFromObject(Q, B, \"default\");\n  };\n  var createModuleWithExports = A => addPropertiesFromObject(________defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var ____________________moduleExports = {};\n  ____________defineProperties(____________________moduleExports, {\n    Uint8ArrayBlobAdapter: () => $X1\n  });\n  ___________________moduleExports.exports = createModuleWithExports(____________________moduleExports);\n  var au0 = h0A();\n  var su0 = ___________________imageProcessingPipeline();\n  function ru0(_____inputData, B = \"utf-8\") {\n    if (B === \"base64\") {\n      return (0, au0.toBase64)(_____inputData);\n    }\n    return (0, su0.toUtf8)(_____inputData);\n  }\n  ___setFunctionName(ru0, \"transformToString\");\n  function ou0(___inputString, encodingType) {\n    if (encodingType === \"base64\") {\n      return $X1.mutate((0, au0.fromBase64)(___inputString));\n    }\n    return $X1.mutate((0, su0.fromUtf8)(___inputString));\n  }\n  ___setFunctionName(ou0, \"transformFromString\");\n  var $X1 = class A extends Uint8Array {\n    static {\n      ___setFunctionName(this, \"Uint8ArrayBlobAdapter\");\n    }\n    static fromString(__inputString, encodingFormat = \"utf-8\") {\n      switch (typeof __inputString) {\n        case \"string\":\n          return ou0(__inputString, encodingFormat);\n        default:\n          throw Error(`Unsupported conversion from ${typeof __inputString} to Uint8ArrayBlobAdapter.`);\n      }\n    }\n    static mutate(B) {\n      Object.setPrototypeOf(B, A.prototype);\n      return B;\n    }\n    transformToString(_encodingFormat = \"utf-8\") {\n      return ru0(this, _encodingFormat);\n    }\n  };\n  addPropertiesAndExport(____________________moduleExports, JX1(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, dh0(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, ____________________imageTransformationProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, ______imageProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, _______________imageTransformationProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, mu0(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, _________________imageTransformationProcessor(), ___________________moduleExports.exports);\n  addPropertiesAndExport(____________________moduleExports, processImageTransformatio(), ___________________moduleExports.exports);\n});\nvar __processImagePipeline = z((createSchemaExports, importSchema) => {\n  var {\n    defineProperty: __defineProperty,\n    getOwnPropertyDescriptor: __getOwnPropertyDescriptor,\n    getOwnPropertyNames: __getOwnPropertyNames\n  } = Object;\n  var ___hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ___defineProperties = (A, B) => {\n    for (var Q in B) {\n      __defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var definePropertiesForObject = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _________________________propertyName of __getOwnPropertyNames(B)) {\n        if (!___hasOwnProperty.call(A, _________________________propertyName) && _________________________propertyName !== Q) {\n          __defineProperty(A, _________________________propertyName, {\n            get: () => B[_________________________propertyName],\n            enumerable: !(I = __getOwnPropertyDescriptor(B, _________________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var _createSchemaExports = A => definePropertiesForObject(__defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var schemaExports = {};\n  ___defineProperties(schemaExports, {\n    ErrorSchema: () => ExtendedStructureSchema,\n    ListSchema: () => ListSchemaDefinition,\n    MapSchema: () => MapSchemaDefinition,\n    NormalizedSchema: () => j04,\n    OperationSchema: () => OperationSchema,\n    SCHEMA: () => SchemaTypeRegistry,\n    Schema: () => SchemaDefinition,\n    SimpleSchema: () => ReactiveSchema,\n    StructureSchema: () => StructureSchema,\n    TypeRegistry: () => Si,\n    deref: () => invokeOrReturnValue,\n    deserializerMiddlewareOption: () => deserializerMiddlewareOption,\n    error: () => T04,\n    getSchemaSerdePlugin: () => N04,\n    list: () => L04,\n    map: () => M04,\n    op: () => O04,\n    serializerMiddlewareOption: () => serializerMiddlewareOptions,\n    sim: () => P04,\n    struct: () => R04\n  });\n  importSchema.exports = _createSchemaExports(schemaExports);\n  var invokeOrReturnValue = executeOrReturnValue => {\n    if (typeof executeOrReturnValue === \"function\") {\n      return executeOrReturnValue();\n    }\n    return executeOrReturnValue;\n  };\n  var metadataUpdate = updateMetadata();\n  var _____________________imageTransformationProcessor = ______________imageTransformationProcessor();\n  var w04 = A => (B, Q) => async handleOperationResponse => {\n    let {\n      response: httpResponse\n    } = await B(handleOperationResponse);\n    let {\n      operationSchema: operationSchema\n    } = (0, _____________________imageTransformationProcessor.getSmithyContext)(Q);\n    try {\n      let deserializedOutput = await A.protocol.deserializeResponse(operationSchema, {\n        ...A,\n        ...Q\n      }, httpResponse);\n      return {\n        response: httpResponse,\n        output: deserializedOutput\n      };\n    } catch (deserializationError) {\n      Object.defineProperty(deserializationError, \"$response\", {\n        value: httpResponse\n      });\n      if (!(\"$metadata\" in deserializationError)) {\n        try {\n          deserializationError.message += `\n  Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;\n        } catch (_deserializationError) {\n          if (!Q.logger || Q.logger?.constructor?.name === \"NoOpLogger\") {\n            console.warn(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          } else {\n            Q.logger?.warn?.(\"Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.\");\n          }\n        }\n        if (typeof deserializationError.$responseBodyText !== \"undefined\") {\n          if (deserializationError.$response) {\n            deserializationError.$response.body = deserializationError.$responseBodyText;\n          }\n        }\n        try {\n          if (metadataUpdate.HttpResponse.isInstance(httpResponse)) {\n            let {\n              headers: error = {}\n            } = httpResponse;\n            let _responseHeadersArray = Object.entries(error);\n            deserializationError.$metadata = {\n              httpStatusCode: httpResponse.statusCode,\n              requestId: extractRequestIdFromHeaders(/^x-[\\w-]+-request-?id$/, _responseHeadersArray),\n              extendedRequestId: extractRequestIdFromHeaders(/^x-[\\w-]+-id-2$/, _responseHeadersArray),\n              cfId: extractRequestIdFromHeaders(/^x-[\\w-]+-cf-id$/, _responseHeadersArray)\n            };\n          }\n        } catch (_____________________error) {}\n      }\n      throw deserializationError;\n    }\n  };\n  var extractRequestIdFromHeaders = (stringMatcher, findMatchingString) => {\n    return (findMatchingString.find(([______inputString]) => {\n      return ______inputString.match(stringMatcher);\n    }) || [undefined, undefined])[1];\n  };\n  var ______________________imageTransformationProcessor = ______________imageTransformationProcessor();\n  var q04 = A => (B, Q) => async _handleRequest => {\n    let {\n      operationSchema: _operationSchema\n    } = (0, ______________________imageTransformationProcessor.getSmithyContext)(Q);\n    let getEndpointUrl = Q.endpointV2?.url && A.urlParser ? async () => A.urlParser(Q.endpointV2.url) : A.endpoint;\n    let serializedRequest = await A.protocol.serializeRequest(_operationSchema, _handleRequest.input, {\n      ...A,\n      ...Q,\n      endpoint: getEndpointUrl\n    });\n    return B({\n      ..._handleRequest,\n      request: serializedRequest\n    });\n  };\n  var deserializerMiddlewareOption = {\n    name: \"deserializerMiddleware\",\n    step: \"deserialize\",\n    tags: [\"DESERIALIZER\"],\n    override: true\n  };\n  var serializerMiddlewareOptions = {\n    name: \"serializerMiddleware\",\n    step: \"serialize\",\n    tags: [\"SERIALIZER\"],\n    override: true\n  };\n  function N04(data) {\n    return {\n      applyToStack: B => {\n        B.add(q04(data), serializerMiddlewareOptions);\n        B.add(w04(data), deserializerMiddlewareOption);\n        data.protocol.setSerdeContext(data);\n      }\n    };\n  }\n  var Si = class A {\n    constructor(B, schemaMap = new Map()) {\n      this.namespace = B;\n      this.schemas = schemaMap;\n    }\n    static {\n      this.registries = new Map();\n    }\n    static for(B) {\n      if (!A.registries.has(B)) {\n        A.registries.set(B, new A(B));\n      }\n      return A.registries.get(B);\n    }\n    register(B, Q) {\n      let I = this.normalizeShapeId(B);\n      A.for(this.getNamespace(B)).schemas.set(I, Q);\n    }\n    getSchema(B) {\n      let Q = this.normalizeShapeId(B);\n      if (!this.schemas.has(Q)) {\n        throw Error(`@smithy/core/schema - schema not found for ${Q}`);\n      }\n      return this.schemas.get(Q);\n    }\n    getBaseException() {\n      for (let [schemaEntry, serviceExceptionSchema] of this.schemas.entries()) {\n        if (schemaEntry.startsWith(\"smithy.ts.sdk.synthetic.\") && schemaEntry.endsWith(\"ServiceException\")) {\n          return serviceExceptionSchema;\n        }\n      }\n      return;\n    }\n    find(B) {\n      return [...this.schemas.values()].find(B);\n    }\n    destroy() {\n      A.registries.delete(this.namespace);\n      this.schemas.clear();\n    }\n    normalizeShapeId(B) {\n      if (B.includes(\"#\")) {\n        return B;\n      }\n      return this.namespace + \"#\" + B;\n    }\n    getNamespace(B) {\n      return this.normalizeShapeId(B).split(\"#\")[0];\n    }\n  };\n  var SchemaDefinition = class {\n    constructor(__name, traits) {\n      this.name = __name;\n      this.traits = traits;\n    }\n  };\n  var ListSchemaDefinition = class extends SchemaDefinition {\n    constructor(A, B, Q) {\n      super(A, B);\n      this.name = A;\n      this.traits = B;\n      this.valueSchema = Q;\n    }\n  };\n  function L04(createAndRegisterMX1Instance, _dataHandler, Q = {}, initializationFunction) {\n    let G = new ListSchemaDefinition(createAndRegisterMX1Instance + \"#\" + _dataHandler, Q, typeof initializationFunction === \"function\" ? initializationFunction() : initializationFunction);\n    Si.for(createAndRegisterMX1Instance).register(_dataHandler, G);\n    return G;\n  }\n  var MapSchemaDefinition = class extends SchemaDefinition {\n    constructor(A, B, Q, I) {\n      super(A, B);\n      this.name = A;\n      this.traits = B;\n      this.keySchema = Q;\n      this.valueSchema = I;\n    }\n  };\n  function M04(createAndRegisterInstance, resourceIdentifier, Q = {}, identifier, callbackOrValue) {\n    let Z = new MapSchemaDefinition(createAndRegisterInstance + \"#\" + resourceIdentifier, Q, identifier, typeof callbackOrValue === \"function\" ? callbackOrValue() : callbackOrValue);\n    Si.for(createAndRegisterInstance).register(resourceIdentifier, Z);\n    return Z;\n  }\n  var OperationSchema = class extends SchemaDefinition {\n    constructor(A, B, Q, I) {\n      super(A, B);\n      this.name = A;\n      this.traits = B;\n      this.input = Q;\n      this.output = I;\n    }\n  };\n  function O04(_createRegisteredObject, ResourceManager, Q = {}, inputParameter, createBm0Instance) {\n    let Z = new OperationSchema(_createRegisteredObject + \"#\" + ResourceManager, Q, inputParameter, createBm0Instance);\n    Si.for(_createRegisteredObject).register(ResourceManager, Z);\n    return Z;\n  }\n  var StructureSchema = class extends SchemaDefinition {\n    constructor(A, B, Q, I) {\n      super(A, B);\n      this.name = A;\n      this.traits = B;\n      this.memberNames = Q;\n      this.memberList = I;\n      this.members = {};\n      for (let __memberIndex = 0; __memberIndex < Q.length; ++__memberIndex) {\n        this.members[Q[__memberIndex]] = Array.isArray(I[__memberIndex]) ? I[__memberIndex] : [I[__memberIndex], 0];\n      }\n    }\n  };\n  function R04(______inputData, userIdentifier, notificationService, _identifier, createNSAObject) {\n    let Z = new StructureSchema(______inputData + \"#\" + userIdentifier, notificationService, _identifier, createNSAObject);\n    Si.for(______inputData).register(userIdentifier, Z);\n    return Z;\n  }\n  var ExtendedStructureSchema = class extends StructureSchema {\n    constructor(A, B, Q, I, G) {\n      super(A, B, Q, I);\n      this.name = A;\n      this.traits = B;\n      this.memberNames = Q;\n      this.memberList = I;\n      this.ctor = G;\n    }\n  };\n  function T04(_createAndRegisterInstance, resourceName, Q = {}, ______index, createRegisteredObject, dataProcessor) {\n    let Y = new ExtendedStructureSchema(_createAndRegisterInstance + \"#\" + resourceName, Q, ______index, createRegisteredObject, dataProcessor);\n    Si.for(_createAndRegisterInstance).register(resourceName, Y);\n    return Y;\n  }\n  var SchemaTypeRegistry = {\n    BLOB: 21,\n    STREAMING_BLOB: 42,\n    BOOLEAN: 2,\n    STRING: 0,\n    NUMERIC: 1,\n    BIG_INTEGER: 17,\n    BIG_DECIMAL: 19,\n    DOCUMENT: 15,\n    TIMESTAMP_DEFAULT: 4,\n    TIMESTAMP_DATE_TIME: 5,\n    TIMESTAMP_HTTP_DATE: 6,\n    TIMESTAMP_EPOCH_SECONDS: 7,\n    LIST_MODIFIER: 64,\n    MAP_MODIFIER: 128\n  };\n  var ReactiveSchema = class extends SchemaDefinition {\n    constructor(A, B, Q) {\n      super(A, Q);\n      this.name = A;\n      this.schemaRef = B;\n      this.traits = Q;\n    }\n  };\n  function P04(createNewRX1Instance, inputParameterB, createReactiveInstance, instanceIdentifier) {\n    let G = new ReactiveSchema(createNewRX1Instance + \"#\" + inputParameterB, createReactiveInstance, instanceIdentifier);\n    Si.for(createNewRX1Instance).register(inputParameterB, G);\n    return G;\n  }\n  var j04 = class A {\n    constructor(B, Q) {\n      this.ref = B;\n      this.memberName = Q;\n      let I = [];\n      let G = B;\n      let Z = B;\n      this._isMemberSchema = false;\n      while (Array.isArray(G)) {\n        I.push(G[1]);\n        G = G[0];\n        Z = invokeOrReturnValue(G);\n        this._isMemberSchema = true;\n      }\n      if (I.length > 0) {\n        this.memberTraits = {};\n        for (let _____index = I.length - 1; _____index >= 0; --_____index) {\n          let trait = I[_____index];\n          Object.assign(this.memberTraits, A.translateTraits(trait));\n        }\n      } else {\n        this.memberTraits = 0;\n      }\n      if (Z instanceof A) {\n        this.name = Z.name;\n        this.traits = Z.traits;\n        this._isMemberSchema = Z._isMemberSchema;\n        this.schema = Z.schema;\n        this.memberTraits = Object.assign({}, Z.getMemberTraits(), this.getMemberTraits());\n        this.normalizedTraits = undefined;\n        this.ref = Z.ref;\n        this.memberName = Q ?? Z.memberName;\n        return;\n      }\n      this.schema = invokeOrReturnValue(Z);\n      if (this.schema && typeof this.schema === \"object\") {\n        this.traits = this.schema?.traits ?? {};\n      } else {\n        this.traits = 0;\n      }\n      this.name = (typeof this.schema === \"object\" ? this.schema?.name : undefined) ?? this.memberName ?? this.getSchemaName();\n      if (this._isMemberSchema && !Q) {\n        throw Error(`@smithy/core/schema - NormalizedSchema member schema ${this.getName(true)} must initialize with memberName argument.`);\n      }\n    }\n    static of(B, Q) {\n      if (B instanceof A) {\n        return B;\n      }\n      return new A(B, Q);\n    }\n    static translateTraits(B) {\n      if (typeof B === \"object\") {\n        return B;\n      }\n      B = B | 0;\n      let Q = {};\n      if ((B & 1) === 1) {\n        Q.httpLabel = 1;\n      }\n      if ((B >> 1 & 1) === 1) {\n        Q.idempotent = 1;\n      }\n      if ((B >> 2 & 1) === 1) {\n        Q.idempotencyToken = 1;\n      }\n      if ((B >> 3 & 1) === 1) {\n        Q.sensitive = 1;\n      }\n      if ((B >> 4 & 1) === 1) {\n        Q.httpPayload = 1;\n      }\n      if ((B >> 5 & 1) === 1) {\n        Q.httpResponseCode = 1;\n      }\n      if ((B >> 6 & 1) === 1) {\n        Q.httpQueryParams = 1;\n      }\n      return Q;\n    }\n    static memberFrom(B, Q) {\n      if (B instanceof A) {\n        B.memberName = Q;\n        B._isMemberSchema = true;\n        return B;\n      }\n      return new A(B, Q);\n    }\n    getSchema() {\n      if (this.schema instanceof A) {\n        return this.schema = this.schema.getSchema();\n      }\n      if (this.schema instanceof ReactiveSchema) {\n        return invokeOrReturnValue(this.schema.schemaRef);\n      }\n      return invokeOrReturnValue(this.schema);\n    }\n    getName(isNameHashtagExcluded = false) {\n      if (!isNameHashtagExcluded) {\n        if (this.name && this.name.includes(\"#\")) {\n          return this.name.split(\"#\")[1];\n        }\n      }\n      return this.name || undefined;\n    }\n    getMemberName() {\n      if (!this.isMemberSchema()) {\n        throw Error(`@smithy/core/schema - cannot get member name on non-member schema: ${this.getName(true)}`);\n      }\n      return this.memberName;\n    }\n    isMemberSchema() {\n      return this._isMemberSchema;\n    }\n    isUnitSchema() {\n      return this.getSchema() === \"unit\";\n    }\n    isListSchema() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        return B >= SchemaTypeRegistry.LIST_MODIFIER && B < SchemaTypeRegistry.MAP_MODIFIER;\n      }\n      return B instanceof ListSchemaDefinition;\n    }\n    isMapSchema() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        return B >= SchemaTypeRegistry.MAP_MODIFIER && B <= 255;\n      }\n      return B instanceof MapSchemaDefinition;\n    }\n    isDocumentSchema() {\n      return this.getSchema() === SchemaTypeRegistry.DOCUMENT;\n    }\n    isStructSchema() {\n      let B = this.getSchema();\n      return B !== null && typeof B === \"object\" && \"members\" in B || B instanceof StructureSchema;\n    }\n    isBlobSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BLOB || this.getSchema() === SchemaTypeRegistry.STREAMING_BLOB;\n    }\n    isTimestampSchema() {\n      let B = this.getSchema();\n      return typeof B === \"number\" && B >= SchemaTypeRegistry.TIMESTAMP_DEFAULT && B <= SchemaTypeRegistry.TIMESTAMP_EPOCH_SECONDS;\n    }\n    isStringSchema() {\n      return this.getSchema() === SchemaTypeRegistry.STRING;\n    }\n    isBooleanSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BOOLEAN;\n    }\n    isNumericSchema() {\n      return this.getSchema() === SchemaTypeRegistry.NUMERIC;\n    }\n    isBigIntegerSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BIG_INTEGER;\n    }\n    isBigDecimalSchema() {\n      return this.getSchema() === SchemaTypeRegistry.BIG_DECIMAL;\n    }\n    isStreaming() {\n      if (this.getMergedTraits().streaming) {\n        return true;\n      }\n      return this.getSchema() === SchemaTypeRegistry.STREAMING_BLOB;\n    }\n    getMergedTraits() {\n      if (this.normalizedTraits) {\n        return this.normalizedTraits;\n      }\n      this.normalizedTraits = {\n        ...this.getOwnTraits(),\n        ...this.getMemberTraits()\n      };\n      return this.normalizedTraits;\n    }\n    getMemberTraits() {\n      return A.translateTraits(this.memberTraits);\n    }\n    getOwnTraits() {\n      return A.translateTraits(this.traits);\n    }\n    getKeySchema() {\n      if (this.isDocumentSchema()) {\n        return A.memberFrom([SchemaTypeRegistry.DOCUMENT, 0], \"key\");\n      }\n      if (!this.isMapSchema()) {\n        throw Error(`@smithy/core/schema - cannot get key schema for non-map schema: ${this.getName(true)}`);\n      }\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        return A.memberFrom([B & 63, 0], \"key\");\n      }\n      return A.memberFrom([B.keySchema, 0], \"key\");\n    }\n    getValueSchema() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        if (this.isMapSchema()) {\n          return A.memberFrom([B & 63, 0], \"value\");\n        } else if (this.isListSchema()) {\n          return A.memberFrom([B & 63, 0], \"member\");\n        }\n      }\n      if (B && typeof B === \"object\") {\n        if (this.isStructSchema()) {\n          throw Error(`cannot call getValueSchema() with StructureSchema ${this.getName(true)}`);\n        }\n        let schemaDefinition = B;\n        if (\"valueSchema\" in schemaDefinition) {\n          if (this.isMapSchema()) {\n            return A.memberFrom([schemaDefinition.valueSchema, 0], \"value\");\n          } else if (this.isListSchema()) {\n            return A.memberFrom([schemaDefinition.valueSchema, 0], \"member\");\n          }\n        }\n      }\n      if (this.isDocumentSchema()) {\n        return A.memberFrom([SchemaTypeRegistry.DOCUMENT, 0], \"value\");\n      }\n      throw Error(`@smithy/core/schema - the schema ${this.getName(true)} does not have a value member.`);\n    }\n    getMemberSchema(B) {\n      if (this.isStructSchema()) {\n        let _schemaDefinition = this.getSchema();\n        if (!(B in _schemaDefinition.members)) {\n          throw Error(`@smithy/core/schema - the schema ${this.getName(true)} does not have a member with name=${B}.`);\n        }\n        return A.memberFrom(_schemaDefinition.members[B], B);\n      }\n      if (this.isDocumentSchema()) {\n        return A.memberFrom([SchemaTypeRegistry.DOCUMENT, 0], B);\n      }\n      throw Error(`@smithy/core/schema - the schema ${this.getName(true)} does not have members.`);\n    }\n    getMemberSchemas() {\n      let {\n        schema: B\n      } = this;\n      let Q = B;\n      if (!Q || typeof Q !== \"object\") {\n        return {};\n      }\n      if (\"members\" in Q) {\n        let __memberSchemas = {};\n        for (let _memberName of Q.memberNames) {\n          __memberSchemas[_memberName] = this.getMemberSchema(_memberName);\n        }\n        return __memberSchemas;\n      }\n      return {};\n    }\n    *structIterator() {\n      if (this.isUnitSchema()) {\n        return;\n      }\n      if (!this.isStructSchema()) {\n        throw Error(\"@smithy/core/schema - cannot acquire structIterator on non-struct schema.\");\n      }\n      let B = this.getSchema();\n      for (let memberIndex = 0; memberIndex < B.memberNames.length; ++memberIndex) {\n        yield [B.memberNames[memberIndex], A.memberFrom([B.memberList[memberIndex], 0], B.memberNames[memberIndex])];\n      }\n    }\n    getSchemaName() {\n      let B = this.getSchema();\n      if (typeof B === \"number\") {\n        let modifierMask = B & 63;\n        let schemaModifier = B & 192;\n        let schemaType = Object.entries(SchemaTypeRegistry).find(([, isModifierMaskEqual]) => {\n          return isModifierMaskEqual === modifierMask;\n        })?.[0] ?? \"Unknown\";\n        switch (schemaModifier) {\n          case SchemaTypeRegistry.MAP_MODIFIER:\n            return `${schemaType}Map`;\n          case SchemaTypeRegistry.LIST_MODIFIER:\n            return `${schemaType}List`;\n          case 0:\n            return schemaType;\n        }\n      }\n      return \"Unknown\";\n    }\n  };\n});\nvar K6 = z((initializeModule, __moduleExports) => {\n  var {\n    defineProperty: _defineProperty,\n    getOwnPropertyDescriptor: _getOwnPropertyDescriptor,\n    getOwnPropertyNames: getObjectOwnPropertyNames\n  } = Object;\n  var __hasOwnProperty = Object.prototype.hasOwnProperty;\n  var __defineProperties = (A, B) => {\n    for (var Q in B) {\n      _defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var assignPropertiesIfNew = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let __________________________propertyName of getObjectOwnPropertyNames(B)) {\n        if (!__hasOwnProperty.call(A, __________________________propertyName) && __________________________propertyName !== Q) {\n          _defineProperty(A, __________________________propertyName, {\n            get: () => B[__________________________propertyName],\n            enumerable: !(I = _getOwnPropertyDescriptor(B, __________________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var assignPropertiesToModule = A => assignPropertiesIfNew(_defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var ___moduleExports = {};\n  __defineProperties(___moduleExports, {\n    LazyJsonString: () => createStringWithJSONMethods,\n    NumericValue: () => NumericValue,\n    copyDocumentWithTransform: () => mJA,\n    dateToUtcString: () => convertDateToUtcString,\n    expectBoolean: () => convertToBooleanValue,\n    expectByte: () => validateTypedInteger8Bit,\n    expectFloat32: () => validateFloat32,\n    expectInt: () => validateIntegerInput,\n    expectInt32: () => expectInt32Value,\n    expectLong: () => validateIntegerValue,\n    expectNonNull: () => expectNonNullValue,\n    expectNumber: () => convertToNumber,\n    expectObject: () => expectObject,\n    expectShort: () => expectShortInteger,\n    expectString: () => expectStringValue,\n    expectUnion: () => expectUnionValue,\n    handleFloat: () => n04,\n    limitedParseDouble: () => __parseSpecialFloatValue,\n    limitedParseFloat: () => a04,\n    limitedParseFloat32: () => s04,\n    logger: () => consoleLogger,\n    nv: () => convertToBigDecimal,\n    parseBoolean: () => parseBooleanString,\n    parseEpochTimestamp: () => XB4,\n    parseRfc3339DateTime: () => BB4,\n    parseRfc3339DateTimeWithOffset: () => IB4,\n    parseRfc7231DateTime: () => JB4,\n    quoteHeader: () => wrapStringInQuotesIfNeeded,\n    splitEvery: () => splitIntoChunksByDelimiter,\n    splitHeader: () => splitCSV,\n    strictParseByte: () => Wm0,\n    strictParseDouble: () => strictParseDouble,\n    strictParseFloat: () => l04,\n    strictParseFloat32: () => Ym0,\n    strictParseInt: () => r04,\n    strictParseInt32: () => o04,\n    strictParseLong: () => strictParseLongInteger,\n    strictParseShort: () => m0A\n  });\n  __moduleExports.exports = assignPropertiesToModule(___moduleExports);\n  var b04 = __processImagePipeline();\n  var mJA = (A, B, Q = ___________index => ___________index) => {\n    let I = b04.NormalizedSchema.of(B);\n    switch (typeof A) {\n      case \"undefined\":\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n      case \"bigint\":\n      case \"symbol\":\n        return Q(A, I);\n      case \"function\":\n      case \"object\":\n        if (A === null) {\n          return Q(null, I);\n        }\n        if (Array.isArray(A)) {\n          let element = Array(A.length);\n          let arrayIndex = 0;\n          for (let ____item of A) {\n            element[arrayIndex++] = mJA(____item, I.getValueSchema(), Q);\n          }\n          return Q(element, I);\n        }\n        if (\"byteLength\" in A) {\n          let transformedArray = new Uint8Array(A.byteLength);\n          transformedArray.set(A, 0);\n          return Q(transformedArray, I);\n        }\n        if (A instanceof Date) {\n          return Q(A, I);\n        }\n        let G = {};\n        if (I.isMapSchema()) {\n          for (let __key of Object.keys(A)) {\n            G[__key] = mJA(A[__key], I.getValueSchema(), Q);\n          }\n        } else if (I.isStructSchema()) {\n          for (let [itemKey, itemValue] of I.structIterator()) {\n            G[itemKey] = mJA(A[itemKey], itemValue, Q);\n          }\n        } else if (I.isDocumentSchema()) {\n          for (let ___key of Object.keys(A)) {\n            G[___key] = mJA(A[___key], I.getValueSchema(), Q);\n          }\n        }\n        return Q(G, I);\n      default:\n        return Q(A, I);\n    }\n  };\n  var parseBooleanString = parseBooleanValue => {\n    switch (parseBooleanValue) {\n      case \"true\":\n        return true;\n      case \"false\":\n        return false;\n      default:\n        throw Error(`Unable to parse boolean value \"${parseBooleanValue}\"`);\n    }\n  };\n  var convertToBooleanValue = convertToBoolean => {\n    if (convertToBoolean === null || convertToBoolean === undefined) {\n      return;\n    }\n    if (typeof convertToBoolean === \"number\") {\n      if (convertToBoolean === 0 || convertToBoolean === 1) {\n        consoleLogger.warn(generateStackTrace(`Expected boolean, got ${typeof convertToBoolean}: ${convertToBoolean}`));\n      }\n      if (convertToBoolean === 0) {\n        return false;\n      }\n      if (convertToBoolean === 1) {\n        return true;\n      }\n    }\n    if (typeof convertToBoolean === \"string\") {\n      let normalizedString = convertToBoolean.toLowerCase();\n      if (normalizedString === \"false\" || normalizedString === \"true\") {\n        consoleLogger.warn(generateStackTrace(`Expected boolean, got ${typeof convertToBoolean}: ${convertToBoolean}`));\n      }\n      if (normalizedString === \"false\") {\n        return false;\n      }\n      if (normalizedString === \"true\") {\n        return true;\n      }\n    }\n    if (typeof convertToBoolean === \"boolean\") {\n      return convertToBoolean;\n    }\n    throw TypeError(`Expected boolean, got ${typeof convertToBoolean}: ${convertToBoolean}`);\n  };\n  var convertToNumber = _convertToNumber => {\n    if (_convertToNumber === null || _convertToNumber === undefined) {\n      return;\n    }\n    if (typeof _convertToNumber === \"string\") {\n      let parsedNumber = parseFloat(_convertToNumber);\n      if (!Number.isNaN(parsedNumber)) {\n        if (String(parsedNumber) !== String(_convertToNumber)) {\n          consoleLogger.warn(generateStackTrace(`Expected number but observed string: ${_convertToNumber}`));\n        }\n        return parsedNumber;\n      }\n    }\n    if (typeof _convertToNumber === \"number\") {\n      return _convertToNumber;\n    }\n    throw TypeError(`Expected number, got ${typeof _convertToNumber}: ${_convertToNumber}`);\n  };\n  var MAX_32_BIT_FLOAT = Math.ceil(3.4028234663852886e+38);\n  var validateFloat32 = A => {\n    let B = convertToNumber(A);\n    if (B !== undefined && !Number.isNaN(B) && B !== Infinity && B !== -Infinity) {\n      if (Math.abs(B) > MAX_32_BIT_FLOAT) {\n        throw TypeError(`Expected 32-bit float, got ${A}`);\n      }\n    }\n    return B;\n  };\n  var validateIntegerValue = validateInteger => {\n    if (validateInteger === null || validateInteger === undefined) {\n      return;\n    }\n    if (Number.isInteger(validateInteger) && !Number.isNaN(validateInteger)) {\n      return validateInteger;\n    }\n    throw TypeError(`Expected integer, got ${typeof validateInteger}: ${validateInteger}`);\n  };\n  var validateIntegerInput = validateIntegerValue;\n  var expectInt32Value = A => validateTypedInteger(A, 32);\n  var expectShortInteger = A => validateTypedInteger(A, 16);\n  var validateTypedInteger8Bit = A => validateTypedInteger(A, 8);\n  var validateTypedInteger = (A, B) => {\n    let Q = validateIntegerValue(A);\n    if (Q !== undefined && convertToTypedInteger(Q, B) !== Q) {\n      throw TypeError(`Expected ${B}-bit integer, got ${A}`);\n    }\n    return Q;\n  };\n  var convertToTypedInteger = (convertNumberToTypedArray, bitDepth) => {\n    switch (bitDepth) {\n      case 32:\n        return Int32Array.of(convertNumberToTypedArray)[0];\n      case 16:\n        return Int16Array.of(convertNumberToTypedArray)[0];\n      case 8:\n        return Int8Array.of(convertNumberToTypedArray)[0];\n    }\n  };\n  var expectNonNullValue = (__validateInput, valueOrThrow) => {\n    if (__validateInput === null || __validateInput === undefined) {\n      if (valueOrThrow) {\n        throw TypeError(`Expected a non-null value for ${valueOrThrow}`);\n      }\n      throw TypeError(\"Expected a non-null value\");\n    }\n    return __validateInput;\n  };\n  var expectObject = validateInput => {\n    if (validateInput === null || validateInput === undefined) {\n      return;\n    }\n    if (typeof validateInput === \"object\" && !Array.isArray(validateInput)) {\n      return validateInput;\n    }\n    let dataTypeDescription = Array.isArray(validateInput) ? \"array\" : typeof validateInput;\n    throw TypeError(`Expected object, got ${dataTypeDescription}: ${validateInput}`);\n  };\n  var expectStringValue = processInputValue => {\n    if (processInputValue === null || processInputValue === undefined) {\n      return;\n    }\n    if (typeof processInputValue === \"string\") {\n      return processInputValue;\n    }\n    if ([\"boolean\", \"number\", \"bigint\"].includes(typeof processInputValue)) {\n      consoleLogger.warn(generateStackTrace(`Expected string, got ${typeof processInputValue}: ${processInputValue}`));\n      return String(processInputValue);\n    }\n    throw TypeError(`Expected string, got ${typeof processInputValue}: ${processInputValue}`);\n  };\n  var expectUnionValue = validateAndExtractNonNullMember => {\n    if (validateAndExtractNonNullMember === null || validateAndExtractNonNullMember === undefined) {\n      return;\n    }\n    let validatedObject = expectObject(validateAndExtractNonNullMember);\n    let nonNullKeys = Object.entries(validatedObject).filter(([, __inputValue]) => __inputValue != null).map(([_____inputValue]) => _____inputValue);\n    if (nonNullKeys.length === 0) {\n      throw TypeError(\"Unions must have exactly one non-null member. None were found.\");\n    }\n    if (nonNullKeys.length > 1) {\n      throw TypeError(`Unions must have exactly one non-null member. Keys ${nonNullKeys} were not null.`);\n    }\n    return validatedObject;\n  };\n  var strictParseDouble = A => {\n    if (typeof A == \"string\") {\n      return convertToNumber(parseNumericString(A));\n    }\n    return convertToNumber(A);\n  };\n  var l04 = strictParseDouble;\n  var Ym0 = A => {\n    if (typeof A == \"string\") {\n      return validateFloat32(parseNumericString(A));\n    }\n    return validateFloat32(A);\n  };\n  var numericRegexPattern = /(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)|(-?Infinity)|(NaN)/g;\n  var parseNumericString = A => {\n    let B = A.match(numericRegexPattern);\n    if (B === null || B[0].length !== A.length) {\n      throw TypeError(\"Expected real number, got implicit NaN\");\n    }\n    return parseFloat(A);\n  };\n  var __parseSpecialFloatValue = A => {\n    if (typeof A == \"string\") {\n      return parseSpecialFloatValue(A);\n    }\n    return convertToNumber(A);\n  };\n  var n04 = __parseSpecialFloatValue;\n  var a04 = __parseSpecialFloatValue;\n  var s04 = A => {\n    if (typeof A == \"string\") {\n      return parseSpecialFloatValue(A);\n    }\n    return validateFloat32(A);\n  };\n  var parseSpecialFloatValue = _parseSpecialFloatValue => {\n    switch (_parseSpecialFloatValue) {\n      case \"NaN\":\n        return NaN;\n      case \"Infinity\":\n        return Infinity;\n      case \"-Infinity\":\n        return -Infinity;\n      default:\n        throw Error(`Unable to parse float value: ${_parseSpecialFloatValue}`);\n    }\n  };\n  var strictParseLongInteger = A => {\n    if (typeof A === \"string\") {\n      return validateIntegerValue(parseNumericString(A));\n    }\n    return validateIntegerValue(A);\n  };\n  var r04 = strictParseLongInteger;\n  var o04 = A => {\n    if (typeof A === \"string\") {\n      return expectInt32Value(parseNumericString(A));\n    }\n    return expectInt32Value(A);\n  };\n  var m0A = A => {\n    if (typeof A === \"string\") {\n      return expectShortInteger(parseNumericString(A));\n    }\n    return expectShortInteger(A);\n  };\n  var Wm0 = A => {\n    if (typeof A === \"string\") {\n      return validateTypedInteger8Bit(parseNumericString(A));\n    }\n    return validateTypedInteger8Bit(A);\n  };\n  var generateStackTrace = getErrorStackTrace => {\n    return String(TypeError(getErrorStackTrace).stack || getErrorStackTrace).split(`\n`).slice(0, 5).filter(isNotStackTraceWarning => !isNotStackTraceWarning.includes(\"stackTraceWarning\")).join(`\n`);\n  };\n  var consoleLogger = {\n    warn: console.warn\n  };\n  var weekDaysShort = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n  var monthsArray = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  function convertDateToUtcString(dateToUtcString) {\n    let year = dateToUtcString.getUTCFullYear();\n    let monthIndex = dateToUtcString.getUTCMonth();\n    let dayOfWeek = dateToUtcString.getUTCDay();\n    let utcDate = dateToUtcString.getUTCDate();\n    let utchan = dateToUtcString.getUTCHours();\n    let utcMinutes = dateToUtcString.getUTCMinutes();\n    let seconds = dateToUtcString.getUTCSeconds();\n    let formattedDate = utcDate < 10 ? `0${utcDate}` : `${utcDate}`;\n    let formattedHours = utchan < 10 ? `0${utchan}` : `${utchan}`;\n    let formattedMinutes = utcMinutes < 10 ? `0${utcMinutes}` : `${utcMinutes}`;\n    let formattedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;\n    return `${weekDaysShort[dayOfWeek]}, ${formattedDate} ${monthsArray[monthIndex]} ${year} ${formattedHours}:${formattedMinutes}:${formattedSeconds} GMT`;\n  }\n  var RFC3339DateTimePattern = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?[zZ]$/);\n  var BB4 = A => {\n    if (A === null || A === undefined) {\n      return;\n    }\n    if (typeof A !== \"string\") {\n      throw TypeError(\"RFC-3339 date-times must be expressed as strings\");\n    }\n    let B = RFC3339DateTimePattern.exec(A);\n    if (!B) {\n      throw TypeError(\"Invalid RFC-3339 date-time value\");\n    }\n    let [Q, I, G, Z, Y, J, X, W] = B;\n    let F = m0A(removeLeadingZeros(I));\n    let C = AP(G, \"month\", 1, 12);\n    let V = AP(Z, \"day\", 1, 31);\n    return dJA(F, C, V, {\n      hours: Y,\n      minutes: J,\n      seconds: X,\n      fractionalMilliseconds: W\n    });\n  };\n  var rfc3339DateTimeRegex = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\d{2}\\:\\d{2})|[zZ])$/);\n  var IB4 = A => {\n    if (A === null || A === undefined) {\n      return;\n    }\n    if (typeof A !== \"string\") {\n      throw TypeError(\"RFC-3339 date-times must be expressed as strings\");\n    }\n    let B = rfc3339DateTimeRegex.exec(A);\n    if (!B) {\n      throw TypeError(\"Invalid RFC-3339 date-time value\");\n    }\n    let [Q, I, G, Z, Y, J, X, W, F] = B;\n    let C = m0A(removeLeadingZeros(I));\n    let V = AP(G, \"month\", 1, 12);\n    let K = AP(Z, \"day\", 1, 31);\n    let D = dJA(C, V, K, {\n      hours: Y,\n      minutes: J,\n      seconds: X,\n      fractionalMilliseconds: W\n    });\n    if (F.toUpperCase() != \"Z\") {\n      D.setTime(D.getTime() - parseTimezoneOffset(F));\n    }\n    return D;\n  };\n  var RFC7231DateTimeRegex = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\n  var rfcWeekdayDateTimeFormat = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\n  var rfc7231DateTimeRegex = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\n  var JB4 = A => {\n    if (A === null || A === undefined) {\n      return;\n    }\n    if (typeof A !== \"string\") {\n      throw TypeError(\"RFC-7231 date-times must be expressed as strings\");\n    }\n    let B = RFC7231DateTimeRegex.exec(A);\n    if (B) {\n      let [Q, I, G, Z, Y, J, X, W] = B;\n      return dJA(m0A(removeLeadingZeros(Z)), convertMonthToIndex(G), AP(I, \"day\", 1, 31), {\n        hours: Y,\n        minutes: J,\n        seconds: X,\n        fractionalMilliseconds: W\n      });\n    }\n    B = rfcWeekdayDateTimeFormat.exec(A);\n    if (B) {\n      let [Q, I, G, Z, Y, J, X, W] = B;\n      return adjustDateForHistoricalLimit(dJA(WB4(Z), convertMonthToIndex(G), AP(I, \"day\", 1, 31), {\n        hours: Y,\n        minutes: J,\n        seconds: X,\n        fractionalMilliseconds: W\n      }));\n    }\n    B = rfc7231DateTimeRegex.exec(A);\n    if (B) {\n      let [Q, I, G, Z, Y, J, X, W] = B;\n      return dJA(m0A(removeLeadingZeros(W)), convertMonthToIndex(I), AP(G.trimLeft(), \"day\", 1, 31), {\n        hours: Z,\n        minutes: Y,\n        seconds: J,\n        fractionalMilliseconds: X\n      });\n    }\n    throw TypeError(\"Invalid RFC-7231 date-time value\");\n  };\n  var XB4 = A => {\n    if (A === null || A === undefined) {\n      return;\n    }\n    let B;\n    if (typeof A === \"number\") {\n      B = A;\n    } else if (typeof A === \"string\") {\n      B = strictParseDouble(A);\n    } else if (typeof A === \"object\" && A.tag === 1) {\n      B = A.value;\n    } else {\n      throw TypeError(\"Epoch timestamps must be expressed as floating point numbers or their string representation\");\n    }\n    if (Number.isNaN(B) || B === Infinity || B === -Infinity) {\n      throw TypeError(\"Epoch timestamps must be valid, non-Infinite, non-NaN numerics\");\n    }\n    return new Date(Math.round(B * 1000));\n  };\n  var dJA = (A, B, Q, I) => {\n    let G = B - 1;\n    validateDayInMonth(A, G, Q);\n    return new Date(Date.UTC(A, G, Q, AP(I.hours, \"hour\", 0, 23), AP(I.minutes, \"minute\", 0, 59), AP(I.seconds, \"seconds\", 0, 60), EB4(I.fractionalMilliseconds)));\n  };\n  var WB4 = A => {\n    let B = new Date().getUTCFullYear();\n    let Q = Math.floor(B / 100) * 100 + m0A(removeLeadingZeros(A));\n    if (Q < B) {\n      return Q + 100;\n    }\n    return Q;\n  };\n  var MAX_DATE_DIFF_MILLIS = 1576800000000;\n  var adjustDateForHistoricalLimit = A => {\n    if (A.getTime() - new Date().getTime() > MAX_DATE_DIFF_MILLIS) {\n      return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));\n    }\n    return A;\n  };\n  var convertMonthToIndex = A => {\n    let B = monthsArray.indexOf(A);\n    if (B < 0) {\n      throw TypeError(`Invalid month: ${A}`);\n    }\n    return B + 1;\n  };\n  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  var validateDayInMonth = (A, B, Q) => {\n    let I = daysInMonth[B];\n    if (B === 1 && isLeapYear(A)) {\n      I = 29;\n    }\n    if (Q > I) {\n      throw TypeError(`Invalid day for ${monthsArray[B]} in ${A}: ${Q}`);\n    }\n  };\n  var isLeapYear = _isLeapYear => {\n    return _isLeapYear % 4 === 0 && (_isLeapYear % 100 !== 0 || _isLeapYear % 400 === 0);\n  };\n  var AP = (A, B, Q, I) => {\n    let G = Wm0(removeLeadingZeros(A));\n    if (G < Q || G > I) {\n      throw TypeError(`${B} must be between ${Q} and ${I}, inclusive`);\n    }\n    return G;\n  };\n  var EB4 = A => {\n    if (A === null || A === undefined) {\n      return 0;\n    }\n    return Ym0(\"0.\" + A) * 1000;\n  };\n  var parseTimezoneOffset = parseTimeOffset => {\n    let offsetDirection = parseTimeOffset[0];\n    let offsetDirectionMultiplier = 1;\n    if (offsetDirection == \"+\") {\n      offsetDirectionMultiplier = 1;\n    } else if (offsetDirection == \"-\") {\n      offsetDirectionMultiplier = -1;\n    } else {\n      throw TypeError(`Offset direction, ${offsetDirection}, must be \"+\" or \"-\"`);\n    }\n    let offsetMinutes = Number(parseTimeOffset.substring(1, 3));\n    let calculateMillisecondsFromOffset = Number(parseTimeOffset.substring(4, 6));\n    return offsetDirectionMultiplier * (offsetMinutes * 60 + calculateMillisecondsFromOffset) * 60 * 1000;\n  };\n  var removeLeadingZeros = _removeLeadingZeros => {\n    let leadingZeroCount = 0;\n    while (leadingZeroCount < _removeLeadingZeros.length - 1 && _removeLeadingZeros.charAt(leadingZeroCount) === \"0\") {\n      leadingZeroCount++;\n    }\n    if (leadingZeroCount === 0) {\n      return _removeLeadingZeros;\n    }\n    return _removeLeadingZeros.slice(leadingZeroCount);\n  };\n  function createStringWithJSONMethods(_inputString) {\n    return Object.assign(new String(_inputString), {\n      deserializeJSON() {\n        return JSON.parse(String(_inputString));\n      },\n      toString() {\n        return String(_inputString);\n      },\n      toJSON() {\n        return String(_inputString);\n      }\n    });\n  }\n  createStringWithJSONMethods.from = deserializeInput => {\n    if (deserializeInput && typeof deserializeInput === \"object\" && (deserializeInput instanceof createStringWithJSONMethods || \"deserializeJSON\" in deserializeInput)) {\n      return deserializeInput;\n    } else if (typeof deserializeInput === \"string\" || Object.getPrototypeOf(deserializeInput) === String.prototype) {\n      return createStringWithJSONMethods(String(deserializeInput));\n    }\n    return createStringWithJSONMethods(JSON.stringify(deserializeInput));\n  };\n  createStringWithJSONMethods.fromObject = createStringWithJSONMethods.from;\n  function wrapStringInQuotesIfNeeded(formatStringForJSON) {\n    if (formatStringForJSON.includes(\",\") || formatStringForJSON.includes(\"\\\"\")) {\n      formatStringForJSON = `\"${formatStringForJSON.replace(/\"/g, \"\\\\\\\"\")}\"`;\n    }\n    return formatStringForJSON;\n  }\n  function splitIntoChunksByDelimiter(splitStringByDelimiterEveryN, delimiter, numberOfDelimiters) {\n    if (numberOfDelimiters <= 0 || !Number.isInteger(numberOfDelimiters)) {\n      throw Error(\"Invalid number of delimiters (\" + numberOfDelimiters + \") for splitEvery.\");\n    }\n    let splitStringByDelimiter = splitStringByDelimiterEveryN.split(delimiter);\n    if (numberOfDelimiters === 1) {\n      return splitStringByDelimiter;\n    }\n    let chunkedStrings = [];\n    let currentChunk = \"\";\n    for (let ______________index = 0; ______________index < splitStringByDelimiter.length; ______________index++) {\n      if (currentChunk === \"\") {\n        currentChunk = splitStringByDelimiter[______________index];\n      } else {\n        currentChunk += delimiter + splitStringByDelimiter[______________index];\n      }\n      if ((______________index + 1) % numberOfDelimiters === 0) {\n        chunkedStrings.push(currentChunk);\n        currentChunk = \"\";\n      }\n    }\n    if (currentChunk !== \"\") {\n      chunkedStrings.push(currentChunk);\n    }\n    return chunkedStrings;\n  }\n  var splitCSV = parseCSV => {\n    let inputStringLength = parseCSV.length;\n    let parsedElements = [];\n    let isInsideQuotes = false;\n    let previousCharacter = undefined;\n    let startIndex = 0;\n    for (let ____________index = 0; ____________index < inputStringLength; ++____________index) {\n      let currentCharacter = parseCSV[____________index];\n      switch (currentCharacter) {\n        case \"\\\"\":\n          if (previousCharacter !== \"\\\\\") {\n            isInsideQuotes = !isInsideQuotes;\n          }\n          break;\n        case \",\":\n          if (!isInsideQuotes) {\n            parsedElements.push(parseCSV.slice(startIndex, ____________index));\n            startIndex = ____________index + 1;\n          }\n          break;\n        default:\n      }\n      previousCharacter = currentCharacter;\n    }\n    parsedElements.push(parseCSV.slice(startIndex));\n    return parsedElements.map(sanitizeInput => {\n      sanitizeInput = sanitizeInput.trim();\n      let trimmedLength = sanitizeInput.length;\n      if (trimmedLength < 2) {\n        return sanitizeInput;\n      }\n      if (sanitizeInput[0] === \"\\\"\" && sanitizeInput[trimmedLength - 1] === \"\\\"\") {\n        sanitizeInput = sanitizeInput.slice(1, trimmedLength - 1);\n      }\n      return sanitizeInput.replace(/\\\\\"/g, \"\\\"\");\n    });\n  };\n  var NumericValue = class {\n    constructor(numericString, numericValueType) {\n      this.string = numericString;\n      this.type = numericValueType;\n      let decimalPointCount = 0;\n      for (let index = 0; index < numericString.length; ++index) {\n        let charCode = numericString.charCodeAt(index);\n        if (index === 0 && charCode === 45) {\n          continue;\n        }\n        if (charCode === 46) {\n          if (decimalPointCount) {\n            throw Error(\"@smithy/core/serde - NumericValue must contain at most one decimal point.\");\n          }\n          decimalPointCount = 1;\n          continue;\n        }\n        if (charCode < 48 || charCode > 57) {\n          throw Error(\"@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point \\\".\\\", and an optional negation prefix \\\"-\\\".\");\n        }\n      }\n    }\n    toString() {\n      return this.string;\n    }\n    [Symbol.hasInstance](isNumericValueInstance) {\n      if (!isNumericValueInstance || typeof isNumericValueInstance !== \"object\") {\n        return false;\n      }\n      let numericValueObject = isNumericValueInstance;\n      if (typeof numericValueObject.string === \"string\" && typeof numericValueObject.type === \"string\" && numericValueObject.constructor?.name === \"NumericValue\") {\n        return true;\n      }\n      return false;\n    }\n  };\n  function convertToBigDecimal(inputValue) {\n    return new NumericValue(String(inputValue), \"bigDecimal\");\n  }\n});\nvar _____imageTransformationPipeline = z(Base64Converter => {\n  Object.defineProperty(Base64Converter, \"__esModule\", {\n    value: true\n  });\n  Base64Converter.fromBase64 = undefined;\n  var processBase64String = ________________________________________processImageTransformation();\n  var _base64ValidationRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n  var LB4 = A => {\n    if (A.length * 3 % 4 !== 0) {\n      throw TypeError(\"Incorrect padding on base64 string.\");\n    }\n    if (!_base64ValidationRegex.exec(A)) {\n      throw TypeError(\"Invalid base64 string.\");\n    }\n    let B = (0, processBase64String.fromString)(A, \"base64\");\n    return new Uint8Array(B.buffer, B.byteOffset, B.byteLength);\n  };\n  Base64Converter.fromBase64 = LB4;\n});\nvar zm0 = z(_Base64Encoder => {\n  Object.defineProperty(_Base64Encoder, \"__esModule\", {\n    value: true\n  });\n  _Base64Encoder.toBase64 = undefined;\n  var imageToBase64Encoder = ________________________________________processImageTransformation();\n  var OB4 = ___________________imageProcessingPipeline();\n  var RB4 = A => {\n    let B;\n    if (typeof A === \"string\") {\n      B = (0, OB4.fromUtf8)(A);\n    } else {\n      B = A;\n    }\n    if (typeof B !== \"object\" || typeof B.byteOffset !== \"number\" || typeof B.byteLength !== \"number\") {\n      throw Error(\"@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.\");\n    }\n    return (0, imageToBase64Encoder.fromArrayBuffer)(B.buffer, B.byteOffset, B.byteLength).toString(\"base64\");\n  };\n  _Base64Encoder.toBase64 = RB4;\n});\nvar hX1 = z((defineObjectProperties, exportsModule) => {\n  var {\n    defineProperty: ___________defineProperty,\n    getOwnPropertyDescriptor: _____________________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNamesWithOwnerCheck\n  } = Object;\n  var __________________________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var _definePropertiesFromObject = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ___________________________propertyName of getOwnPropertyNamesWithOwnerCheck(B)) {\n        if (!__________________________hasOwnProperty.call(A, ___________________________propertyName) && ___________________________propertyName !== Q) {\n          ___________defineProperty(A, ___________________________propertyName, {\n            get: () => B[___________________________propertyName],\n            enumerable: !(I = _____________________________getOwnPropertyDescriptor(B, ___________________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var defineAndExportProperties = (A, B, Q) => {\n    _definePropertiesFromObject(A, B, \"default\");\n    return Q && _definePropertiesFromObject(Q, B, \"default\");\n  };\n  var _defineModuleExports = A => _definePropertiesFromObject(___________defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _exportModule = {};\n  exportsModule.exports = _defineModuleExports(_exportModule);\n  defineAndExportProperties(_exportModule, _____imageTransformationPipeline(), exportsModule.exports);\n  defineAndExportProperties(_exportModule, zm0(), exportsModule.exports);\n});\nvar b6 = z((initializeImportsAndSetup, moduleExports) => {\n  var {\n    defineProperty: defineProperty,\n    getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n    getOwnPropertyNames: getOwnPropertyNames\n  } = Object;\n  var objectHasOwnProperty = Object.prototype.hasOwnProperty;\n  var defineProperties = (A, B) => {\n    for (var Q in B) {\n      defineProperty(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesFromSourceToTarget = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ____________________________propertyName of getOwnPropertyNames(B)) {\n        if (!objectHasOwnProperty.call(A, ____________________________propertyName) && ____________________________propertyName !== Q) {\n          defineProperty(A, ____________________________propertyName, {\n            get: () => B[____________________________propertyName],\n            enumerable: !(I = getOwnPropertyDescriptor(B, ____________________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var copyAndDefineProperties = A => copyPropertiesFromSourceToTarget(defineProperty({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _moduleExports = {};\n  defineProperties(_moduleExports, {\n    FromStringShapeDeserializer: () => jm0,\n    HttpBindingProtocol: () => gB4,\n    HttpInterceptingShapeDeserializer: () => iB4,\n    HttpInterceptingShapeSerializer: () => aB4,\n    RequestBuilder: () => Pm0,\n    RpcProtocol: () => mB4,\n    ToStringShapeSerializer: () => Sm0,\n    collectBody: () => l0A,\n    determineTimestampFormat: () => cX1,\n    extendedEncodeURIComponent: () => encodeUriComponentWithSpecialChars,\n    requestBuilder: () => cB4,\n    resolvedPath: () => replaceHttpLabelInPath\n  });\n  moduleExports.exports = copyAndDefineProperties(_moduleExports);\n  var gX1 = Ag();\n  var l0A = async (A = new Uint8Array(), B) => {\n    if (A instanceof Uint8Array) {\n      return gX1.Uint8ArrayBlobAdapter.mutate(A);\n    }\n    if (!A) {\n      return gX1.Uint8ArrayBlobAdapter.mutate(new Uint8Array());\n    }\n    let Q = B.streamCollector(A);\n    return gX1.Uint8ArrayBlobAdapter.mutate(await Q);\n  };\n  function encodeUriComponentWithSpecialChars(encodeUriComponentWithEscape) {\n    return encodeURIComponent(encodeUriComponentWithEscape).replace(/[!'()*]/g, function (characterToHexString) {\n      return \"%\" + characterToHexString.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n  var iJA = __processImagePipeline();\n  var initializeAndExportMetadata = updateMetadata();\n  var RSA = __processImagePipeline();\n  var $m0 = K6();\n  var httpMetadataManager = updateMetadata();\n  var hB4 = Ag();\n  var Rm0 = class {\n    constructor(A) {\n      this.options = A;\n    }\n    getRequestType() {\n      return httpMetadataManager.HttpRequest;\n    }\n    getResponseType() {\n      return httpMetadataManager.HttpResponse;\n    }\n    setSerdeContext(A) {\n      this.serdeContext = A;\n      this.serializer.setSerdeContext(A);\n      this.deserializer.setSerdeContext(A);\n      if (this.getPayloadCodec()) {\n        this.getPayloadCodec().setSerdeContext(A);\n      }\n    }\n    updateServiceEndpoint(A, B) {\n      if (\"url\" in B) {\n        A.protocol = B.url.protocol;\n        A.hostname = B.url.hostname;\n        A.port = B.url.port ? Number(B.url.port) : undefined;\n        A.path = B.url.pathname;\n        A.fragment = B.url.hash || undefined;\n        A.username = B.url.username || undefined;\n        A.password = B.url.password || undefined;\n        for (let [queryParamKey, _value] of B.url.searchParams.entries()) {\n          if (!A.query) {\n            A.query = {};\n          }\n          A.query[queryParamKey] = _value;\n        }\n        return A;\n      } else {\n        A.protocol = B.protocol;\n        A.hostname = B.hostname;\n        A.port = B.port ? Number(B.port) : undefined;\n        A.path = B.path;\n        A.query = {\n          ...B.query\n        };\n        return A;\n      }\n    }\n    setHostPrefix(A, B, Q) {\n      let I = RSA.NormalizedSchema.of(B);\n      let G = RSA.NormalizedSchema.of(B.input);\n      if (I.getMergedTraits().endpoint) {\n        let endpointTemplate = I.getMergedTraits().endpoint?.[0];\n        if (typeof endpointTemplate === \"string\") {\n          let hostLabelEntries = [...G.structIterator()].filter(([, getMergedTraitsHostLabel]) => getMergedTraitsHostLabel.getMergedTraits().hostLabel);\n          for (let [hostLabelKey] of hostLabelEntries) {\n            let hostLabelValue = Q[hostLabelKey];\n            if (typeof hostLabelValue !== \"string\") {\n              throw Error(`@smithy/core/schema - ${hostLabelKey} in input must be a string as hostLabel.`);\n            }\n            endpointTemplate = endpointTemplate.replace(`{${hostLabelKey}}`, hostLabelValue);\n          }\n          A.hostname = endpointTemplate + A.hostname;\n        }\n      }\n    }\n    deserializeMetadata(A) {\n      return {\n        httpStatusCode: A.statusCode,\n        requestId: A.headers[\"x-amzn-requestid\"] ?? A.headers[\"x-amzn-request-id\"] ?? A.headers[\"x-amz-request-id\"],\n        extendedRequestId: A.headers[\"x-amz-id-2\"],\n        cfId: A.headers[\"x-amz-cf-id\"]\n      };\n    }\n    async deserializeHttpMessage(A, B, Q, I, G) {\n      let Z;\n      if (I instanceof Set) {\n        Z = G;\n      } else {\n        Z = I;\n      }\n      let Y = this.deserializer;\n      let J = RSA.NormalizedSchema.of(A);\n      let X = [];\n      for (let [memberName, member] of J.structIterator()) {\n        let memberTraits = member.getMemberTraits();\n        if (memberTraits.httpPayload) {\n          if (member.isStreaming()) {\n            if (member.isStructSchema()) {\n              let serdeContext = this.serdeContext;\n              if (!serdeContext.eventStreamMarshaller) {\n                throw Error(\"@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.\");\n              }\n              let memberSchemas = member.getMemberSchemas();\n              Z[memberName] = serdeContext.eventStreamMarshaller.deserialize(Q.body, async processMemberSchema => {\n                let firstNonSpecialKey = Object.keys(processMemberSchema).find(isNotType => {\n                  return isNotType !== \"__type\";\n                }) ?? \"\";\n                if (firstNonSpecialKey in memberSchemas) {\n                  let schemaKey = memberSchemas[firstNonSpecialKey];\n                  return {\n                    [firstNonSpecialKey]: await Y.read(schemaKey, processMemberSchema[firstNonSpecialKey].body)\n                  };\n                } else {\n                  return {\n                    $unknown: processMemberSchema\n                  };\n                }\n              });\n            } else {\n              Z[memberName] = (0, hB4.sdkStreamMixin)(Q.body);\n            }\n          } else if (Q.body) {\n            let httpHeaderValue = await l0A(Q.body, B);\n            if (httpHeaderValue.byteLength > 0) {\n              Z[memberName] = await Y.read(member, httpHeaderValue);\n            }\n          }\n        } else if (memberTraits.httpHeader) {\n          let httpHeaderKey = String(memberTraits.httpHeader).toLowerCase();\n          let _httpHeaderValue = Q.headers[httpHeaderKey];\n          if (_httpHeaderValue != null) {\n            if (member.isListSchema()) {\n              let _serdeContext = member.getValueSchema();\n              let _memberSchemas;\n              if (_serdeContext.isTimestampSchema() && _serdeContext.getSchema() === RSA.SCHEMA.TIMESTAMP_DEFAULT) {\n                _memberSchemas = (0, $m0.splitEvery)(_httpHeaderValue, \",\", 2);\n              } else {\n                _memberSchemas = (0, $m0.splitHeader)(_httpHeaderValue);\n              }\n              let httpPayloadDeserializer = [];\n              for (let __memberSchema of _memberSchemas) {\n                httpPayloadDeserializer.push(await Y.read([_serdeContext, {\n                  httpHeader: httpHeaderKey\n                }], __memberSchema.trim()));\n              }\n              Z[memberName] = httpPayloadDeserializer;\n            } else {\n              Z[memberName] = await Y.read(member, _httpHeaderValue);\n            }\n          }\n        } else if (memberTraits.httpPrefixHeaders !== undefined) {\n          Z[memberName] = {};\n          for (let [headerName, __httpHeaderValue] of Object.entries(Q.headers)) {\n            if (headerName.startsWith(memberTraits.httpPrefixHeaders)) {\n              Z[memberName][headerName.slice(memberTraits.httpPrefixHeaders.length)] = await Y.read([member.getValueSchema(), {\n                httpHeader: headerName\n              }], __httpHeaderValue);\n            }\n          }\n        } else if (memberTraits.httpResponseCode) {\n          Z[memberName] = Q.statusCode;\n        } else {\n          X.push(memberName);\n        }\n      }\n      return X;\n    }\n  };\n  var gB4 = class extends Rm0 {\n    async serializeRequest(A, B, Q) {\n      let I = this.serializer;\n      let G = {};\n      let Z = {};\n      let Y = await Q.endpoint();\n      let J = iJA.NormalizedSchema.of(A?.input);\n      let X = J.getSchema();\n      let W = false;\n      let F;\n      let C = new initializeAndExportMetadata.HttpRequest({\n        protocol: \"\",\n        hostname: \"\",\n        port: undefined,\n        path: \"\",\n        fragment: undefined,\n        query: G,\n        headers: Z,\n        body: undefined\n      });\n      if (Y) {\n        this.updateServiceEndpoint(C, Y);\n        this.setHostPrefix(C, A, B);\n        let translatedTraits = iJA.NormalizedSchema.translateTraits(A.traits);\n        if (translatedTraits.http) {\n          C.method = translatedTraits.http[0];\n          let [memberSchema, httpTraits] = translatedTraits.http[1].split(\"?\");\n          if (C.path == \"/\") {\n            C.path = memberSchema;\n          } else {\n            C.path += memberSchema;\n          }\n          let httpRequestBody = new URLSearchParams(httpTraits ?? \"\");\n          Object.assign(G, Object.fromEntries(httpRequestBody));\n        }\n      }\n      let V = {\n        ...B\n      };\n      for (let key of Object.keys(V)) {\n        let _memberSchema = J.getMemberSchema(key);\n        if (_memberSchema === undefined) {\n          continue;\n        }\n        let mergedTraits = _memberSchema.getMergedTraits();\n        let memberValue = V[key];\n        if (mergedTraits.httpPayload) {\n          if (_memberSchema.isStreaming()) {\n            if (_memberSchema.isStructSchema()) {\n              throw Error(\"serialization of event streams is not yet implemented\");\n            } else {\n              F = memberValue;\n            }\n          } else {\n            I.write(_memberSchema, memberValue);\n            F = I.flush();\n          }\n        } else if (mergedTraits.httpLabel) {\n          I.write(_memberSchema, memberValue);\n          let resultFromFlush = I.flush();\n          if (C.path.includes(`{${key}+}`)) {\n            C.path = C.path.replace(`{${key}+}`, resultFromFlush.split(\"/\").map(encodeUriComponentWithSpecialChars).join(\"/\"));\n          } else if (C.path.includes(`{${key}}`)) {\n            C.path = C.path.replace(`{${key}}`, encodeUriComponentWithSpecialChars(resultFromFlush));\n          }\n          delete V[key];\n        } else if (mergedTraits.httpHeader) {\n          I.write(_memberSchema, memberValue);\n          Z[mergedTraits.httpHeader.toLowerCase()] = String(I.flush());\n          delete V[key];\n        } else if (typeof mergedTraits.httpPrefixHeaders === \"string\") {\n          for (let [memberValueKey, ___httpHeaderValue] of Object.entries(memberValue)) {\n            let httpHeaderWithPrefix = mergedTraits.httpPrefixHeaders + memberValueKey;\n            I.write([_memberSchema.getValueSchema(), {\n              httpHeader: httpHeaderWithPrefix\n            }], ___httpHeaderValue);\n            Z[httpHeaderWithPrefix.toLowerCase()] = I.flush();\n          }\n          delete V[key];\n        } else if (mergedTraits.httpQuery || mergedTraits.httpQueryParams) {\n          this.serializeQuery(_memberSchema, memberValue, G);\n          delete V[key];\n        } else {\n          W = true;\n        }\n      }\n      if (W && B) {\n        I.write(X, V);\n        F = I.flush();\n      }\n      C.headers = Z;\n      C.query = G;\n      C.body = F;\n      return C;\n    }\n    serializeQuery(A, B, Q) {\n      let I = this.serializer;\n      let G = A.getMergedTraits();\n      if (G.httpQueryParams) {\n        for (let [httpQueryKey, httpResponseData] of Object.entries(B)) {\n          if (!(httpQueryKey in Q)) {\n            this.serializeQuery(iJA.NormalizedSchema.of([A.getValueSchema(), {\n              ...G,\n              httpQuery: httpQueryKey,\n              httpQueryParams: undefined\n            }]), httpResponseData, Q);\n          }\n        }\n        return;\n      }\n      if (A.isListSchema()) {\n        let httpQueryParamKey = !!A.getMergedTraits().sparse;\n        let httpQueryParamsValue = [];\n        for (let item of B) {\n          I.write([A.getValueSchema(), G], item);\n          let flushedData = I.flush();\n          if (httpQueryParamKey || flushedData !== undefined) {\n            httpQueryParamsValue.push(flushedData);\n          }\n        }\n        Q[G.httpQuery] = httpQueryParamsValue;\n      } else {\n        I.write([A, G], B);\n        Q[G.httpQuery] = I.flush();\n      }\n    }\n    async deserializeResponse(A, B, Q) {\n      let I = this.deserializer;\n      let G = iJA.NormalizedSchema.of(A.output);\n      let Z = {};\n      if (Q.statusCode >= 300) {\n        let responseBody = await l0A(Q.body, B);\n        if (responseBody.byteLength > 0) {\n          Object.assign(Z, await I.read(iJA.SCHEMA.DOCUMENT, responseBody));\n        }\n        await this.handleError(A, B, Q, Z, this.deserializeMetadata(Q));\n        throw Error(\"@smithy/core/protocols - HTTP Protocol error handler failed to throw.\");\n      }\n      for (let header in Q.headers) {\n        let _headerValue = Q.headers[header];\n        delete Q.headers[header];\n        Q.headers[header.toLowerCase()] = _headerValue;\n      }\n      let Y = await this.deserializeHttpMessage(G, B, Q, Z);\n      if (Y.length) {\n        let responseBodyBuffer = await l0A(Q.body, B);\n        if (responseBodyBuffer.byteLength > 0) {\n          let headerValue = await I.read(G, responseBodyBuffer);\n          for (let ____key of Y) {\n            Z[____key] = headerValue[____key];\n          }\n        }\n      }\n      return {\n        $metadata: this.deserializeMetadata(Q),\n        ...Z\n      };\n    }\n  };\n  var uX1 = __processImagePipeline();\n  var updateMetadataUtil = updateMetadata();\n  var mB4 = class extends Rm0 {\n    async serializeRequest(A, B, Q) {\n      let I = this.serializer;\n      let G = {};\n      let Z = {};\n      let Y = await Q.endpoint();\n      let X = uX1.NormalizedSchema.of(A?.input).getSchema();\n      let W;\n      let F = new updateMetadataUtil.HttpRequest({\n        protocol: \"\",\n        hostname: \"\",\n        port: undefined,\n        path: \"/\",\n        fragment: undefined,\n        query: G,\n        headers: Z,\n        body: undefined\n      });\n      if (Y) {\n        this.updateServiceEndpoint(F, Y);\n        this.setHostPrefix(F, A, B);\n      }\n      let C = {\n        ...B\n      };\n      if (B) {\n        I.write(X, C);\n        W = I.flush();\n      }\n      F.headers = Z;\n      F.query = G;\n      F.body = W;\n      F.method = \"POST\";\n      return F;\n    }\n    async deserializeResponse(A, B, Q) {\n      let I = this.deserializer;\n      let G = uX1.NormalizedSchema.of(A.output);\n      let Z = {};\n      if (Q.statusCode >= 300) {\n        let _responseBody = await l0A(Q.body, B);\n        if (_responseBody.byteLength > 0) {\n          Object.assign(Z, await I.read(uX1.SCHEMA.DOCUMENT, _responseBody));\n        }\n        await this.handleError(A, B, Q, Z, this.deserializeMetadata(Q));\n        throw Error(\"@smithy/core/protocols - RPC Protocol error handler failed to throw.\");\n      }\n      for (let headerKey in Q.headers) {\n        let __headerValue = Q.headers[headerKey];\n        delete Q.headers[headerKey];\n        Q.headers[headerKey.toLowerCase()] = __headerValue;\n      }\n      let Y = await l0A(Q.body, B);\n      if (Y.byteLength > 0) {\n        Object.assign(Z, await I.read(G, Y));\n      }\n      return {\n        $metadata: this.deserializeMetadata(Q),\n        ...Z\n      };\n    }\n  };\n  var updateMetadataHook = updateMetadata();\n  var replaceHttpLabelInPath = (processHttpLabel, _________inputValue, inputLabelKey, getInputValue, patternToReplace, shouldEncodeUriComponent) => {\n    if (_________inputValue != null && _________inputValue[inputLabelKey] !== undefined) {\n      let inputHttpLabelValue = getInputValue();\n      if (inputHttpLabelValue.length <= 0) {\n        throw Error(\"Empty value provided for input HTTP label: \" + inputLabelKey + \".\");\n      }\n      processHttpLabel = processHttpLabel.replace(patternToReplace, shouldEncodeUriComponent ? inputHttpLabelValue.split(\"/\").map(_encodeUriComponentWithSpecialChars => encodeUriComponentWithSpecialChars(_encodeUriComponentWithSpecialChars)).join(\"/\") : encodeUriComponentWithSpecialChars(inputHttpLabelValue));\n    } else {\n      throw Error(\"No value provided for input HTTP label: \" + inputLabelKey + \".\");\n    }\n    return processHttpLabel;\n  };\n  function cB4(createPm0, createNewPmObject) {\n    return new Pm0(createPm0, createNewPmObject);\n  }\n  var Pm0 = class {\n    constructor(A, B) {\n      this.input = A;\n      this.context = B;\n      this.query = {};\n      this.method = \"\";\n      this.headers = {};\n      this.path = \"\";\n      this.body = null;\n      this.hostname = \"\";\n      this.resolvePathStack = [];\n    }\n    async build() {\n      let {\n        hostname: A,\n        protocol: B = \"https\",\n        port: Q,\n        path: I\n      } = await this.context.endpoint();\n      this.path = I;\n      for (let ________callbackFunction of this.resolvePathStack) {\n        ________callbackFunction(this.path);\n      }\n      return new updateMetadataHook.HttpRequest({\n        protocol: B,\n        hostname: this.hostname || A,\n        port: Q,\n        method: this.method,\n        path: this.path,\n        query: this.query,\n        body: this.body,\n        headers: this.headers\n      });\n    }\n    hn(A) {\n      this.hostname = A;\n      return this;\n    }\n    bp(A) {\n      this.resolvePathStack.push(basePath => {\n        this.path = `${basePath?.endsWith(\"/\") ? basePath.slice(0, -1) : basePath || \"\"}${A}`;\n      });\n      return this;\n    }\n    p(A, B, Q, I) {\n      this.resolvePathStack.push(generatePath => {\n        this.path = replaceHttpLabelInPath(generatePath, this.input, A, B, Q, I);\n      });\n      return this;\n    }\n    h(A) {\n      this.headers = A;\n      return this;\n    }\n    q(A) {\n      this.query = A;\n      return this;\n    }\n    b(A) {\n      this.body = A;\n      return this;\n    }\n    m(A) {\n      this.method = A;\n      return this;\n    }\n  };\n  var TSA = __processImagePipeline();\n  var p0A = K6();\n  var Nm0 = hX1();\n  var pB4 = ___________________imageProcessingPipeline();\n  var nJA = __processImagePipeline();\n  function cX1(schemaValidator, timestampOptions) {\n    if (timestampOptions.timestampFormat.useTrait) {\n      if (schemaValidator.isTimestampSchema() && (schemaValidator.getSchema() === nJA.SCHEMA.TIMESTAMP_DATE_TIME || schemaValidator.getSchema() === nJA.SCHEMA.TIMESTAMP_HTTP_DATE || schemaValidator.getSchema() === nJA.SCHEMA.TIMESTAMP_EPOCH_SECONDS)) {\n        return schemaValidator.getSchema();\n      }\n    }\n    let {\n      httpLabel: Q,\n      httpPrefixHeaders: I,\n      httpHeader: G,\n      httpQuery: Z\n    } = schemaValidator.getMergedTraits();\n    return (timestampOptions.httpBindings ? typeof I === \"string\" || Boolean(G) ? nJA.SCHEMA.TIMESTAMP_HTTP_DATE : Boolean(Z) || Boolean(Q) ? nJA.SCHEMA.TIMESTAMP_DATE_TIME : undefined : undefined) ?? timestampOptions.timestampFormat.default;\n  }\n  var jm0 = class {\n    constructor(A) {\n      this.settings = A;\n    }\n    setSerdeContext(A) {\n      this.serdeContext = A;\n    }\n    read(A, B) {\n      let Q = TSA.NormalizedSchema.of(A);\n      if (Q.isListSchema()) {\n        return (0, p0A.splitHeader)(B).map(valueSchema => this.read(Q.getValueSchema(), valueSchema));\n      }\n      if (Q.isBlobSchema()) {\n        return (this.serdeContext?.base64Decoder ?? Nm0.fromBase64)(B);\n      }\n      if (Q.isTimestampSchema()) {\n        switch (cX1(Q, this.settings)) {\n          case TSA.SCHEMA.TIMESTAMP_DATE_TIME:\n            return (0, p0A.parseRfc3339DateTimeWithOffset)(B);\n          case TSA.SCHEMA.TIMESTAMP_HTTP_DATE:\n            return (0, p0A.parseRfc7231DateTime)(B);\n          case TSA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n            return (0, p0A.parseEpochTimestamp)(B);\n          default:\n            console.warn(\"Missing timestamp format, parsing value with Date constructor:\", B);\n            return new Date(B);\n        }\n      }\n      if (Q.isStringSchema()) {\n        let _mediaType = Q.getMergedTraits().mediaType;\n        let parsedValue = B;\n        if (_mediaType) {\n          if (Q.getMergedTraits().httpHeader) {\n            parsedValue = this.base64ToUtf8(parsedValue);\n          }\n          if (_mediaType === \"application/json\" || _mediaType.endsWith(\"+json\")) {\n            parsedValue = p0A.LazyJsonString.from(parsedValue);\n          }\n          return parsedValue;\n        }\n      }\n      switch (true) {\n        case Q.isNumericSchema():\n          return Number(B);\n        case Q.isBigIntegerSchema():\n          return BigInt(B);\n        case Q.isBigDecimalSchema():\n          return new p0A.NumericValue(B, \"bigDecimal\");\n        case Q.isBooleanSchema():\n          return String(B).toLowerCase() === \"true\";\n      }\n      return B;\n    }\n    base64ToUtf8(A) {\n      return (this.serdeContext?.utf8Encoder ?? pB4.toUtf8)((this.serdeContext?.base64Decoder ?? Nm0.fromBase64)(A));\n    }\n  };\n  var lB4 = __processImagePipeline();\n  var Lm0 = ___________________imageProcessingPipeline();\n  var iB4 = class {\n    constructor(A, B) {\n      this.codecDeserializer = A;\n      this.stringDeserializer = new jm0(B);\n    }\n    setSerdeContext(A) {\n      this.stringDeserializer.setSerdeContext(A);\n      this.codecDeserializer.setSerdeContext(A);\n      this.serdeContext = A;\n    }\n    read(A, inputData) {\n      let Q = lB4.NormalizedSchema.of(A);\n      let I = Q.getMergedTraits();\n      let G = this.serdeContext?.utf8Encoder ?? Lm0.toUtf8;\n      if (I.httpHeader || I.httpResponseCode) {\n        return this.stringDeserializer.read(Q, G(inputData));\n      }\n      if (I.httpPayload) {\n        if (Q.isBlobSchema()) {\n          let utf8Decoder = this.serdeContext?.utf8Decoder ?? Lm0.fromUtf8;\n          if (typeof inputData === \"string\") {\n            return utf8Decoder(inputData);\n          }\n          return inputData;\n        } else if (Q.isStringSchema()) {\n          if (\"byteLength\" in inputData) {\n            return G(inputData);\n          }\n          return inputData;\n        }\n      }\n      return this.codecDeserializer.read(Q, inputData);\n    }\n  };\n  var nB4 = __processImagePipeline();\n  var PSA = __processImagePipeline();\n  var mX1 = K6();\n  var Mm0 = hX1();\n  var Sm0 = class {\n    constructor(A) {\n      this.settings = A;\n      this.stringBuffer = \"\";\n      this.serdeContext = undefined;\n    }\n    setSerdeContext(A) {\n      this.serdeContext = A;\n    }\n    write(A, B) {\n      let Q = PSA.NormalizedSchema.of(A);\n      switch (typeof B) {\n        case \"object\":\n          if (B === null) {\n            this.stringBuffer = \"null\";\n            return;\n          }\n          if (Q.isTimestampSchema()) {\n            if (!(B instanceof Date)) {\n              throw Error(`@smithy/core/protocols - received non-Date value ${B} when schema expected Date in ${Q.getName(true)}`);\n            }\n            switch (cX1(Q, this.settings)) {\n              case PSA.SCHEMA.TIMESTAMP_DATE_TIME:\n                this.stringBuffer = B.toISOString().replace(\".000Z\", \"Z\");\n                break;\n              case PSA.SCHEMA.TIMESTAMP_HTTP_DATE:\n                this.stringBuffer = (0, mX1.dateToUtcString)(B);\n                break;\n              case PSA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:\n                this.stringBuffer = String(B.getTime() / 1000);\n                break;\n              default:\n                console.warn(\"Missing timestamp format, using epoch seconds\", B);\n                this.stringBuffer = String(B.getTime() / 1000);\n            }\n            return;\n          }\n          if (Q.isBlobSchema() && \"byteLength\" in B) {\n            this.stringBuffer = (this.serdeContext?.base64Encoder ?? Mm0.toBase64)(B);\n            return;\n          }\n          if (Q.isListSchema() && Array.isArray(B)) {\n            let concatenatedResults = \"\";\n            for (let resultItem of B) {\n              this.write([Q.getValueSchema(), Q.getMergedTraits()], resultItem);\n              let flushedResult = this.flush();\n              let _formattedOutput = Q.getValueSchema().isTimestampSchema() ? flushedResult : (0, mX1.quoteHeader)(flushedResult);\n              if (concatenatedResults !== \"\") {\n                concatenatedResults += \", \";\n              }\n              concatenatedResults += _formattedOutput;\n            }\n            this.stringBuffer = concatenatedResults;\n            return;\n          }\n          this.stringBuffer = JSON.stringify(B, null, 2);\n          break;\n        case \"string\":\n          let mediaType = Q.getMergedTraits().mediaType;\n          let inputString = B;\n          if (mediaType) {\n            if (mediaType === \"application/json\" || mediaType.endsWith(\"+json\")) {\n              inputString = mX1.LazyJsonString.from(inputString);\n            }\n            if (Q.getMergedTraits().httpHeader) {\n              this.stringBuffer = (this.serdeContext?.base64Encoder ?? Mm0.toBase64)(inputString.toString());\n              return;\n            }\n          }\n          this.stringBuffer = B;\n          break;\n        default:\n          this.stringBuffer = String(B);\n      }\n    }\n    flush() {\n      let A = this.stringBuffer;\n      this.stringBuffer = \"\";\n      return A;\n    }\n  };\n  var aB4 = class {\n    constructor(A, B, serializerInstance = new Sm0(B)) {\n      this.codecSerializer = A;\n      this.stringSerializer = serializerInstance;\n    }\n    setSerdeContext(A) {\n      this.codecSerializer.setSerdeContext(A);\n      this.stringSerializer.setSerdeContext(A);\n    }\n    write(A, B) {\n      let Q = nB4.NormalizedSchema.of(A);\n      let I = Q.getMergedTraits();\n      if (I.httpHeader || I.httpLabel || I.httpQuery) {\n        this.stringSerializer.write(Q, B);\n        this.buffer = this.stringSerializer.flush();\n        return;\n      }\n      return this.codecSerializer.write(Q, B);\n    }\n    flush() {\n      if (this.buffer !== undefined) {\n        let bufferContent = this.buffer;\n        this.buffer = undefined;\n        return bufferContent;\n      }\n      return this.codecSerializer.flush();\n    }\n  };\n});\nvar yQ = z((createHttpRequestSigningMiddleware, identityProviderExports) => {\n  var {\n    defineProperty: definePropertyWithConfig,\n    getOwnPropertyDescriptor: ___getOwnPropertyDescriptor,\n    getOwnPropertyNames: ___getOwnPropertyNames\n  } = Object;\n  var _objectHasOwnProperty = Object.prototype.hasOwnProperty;\n  var defineFunctionName = (A, B) => definePropertyWithConfig(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var ____defineProperties = (A, B) => {\n    for (var Q in B) {\n      definePropertyWithConfig(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var copyPropertiesNonEnumerably = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let _____________________________propertyName of ___getOwnPropertyNames(B)) {\n        if (!_objectHasOwnProperty.call(A, _____________________________propertyName) && _____________________________propertyName !== Q) {\n          definePropertyWithConfig(A, _____________________________propertyName, {\n            get: () => B[_____________________________propertyName],\n            enumerable: !(I = ___getOwnPropertyDescriptor(B, _____________________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createIdentityProviderExports = A => copyPropertiesNonEnumerably(definePropertyWithConfig({}, \"__esModule\", {\n    value: true\n  }), A);\n  var _identityProviderExports = {};\n  ____defineProperties(_identityProviderExports, {\n    DefaultIdentityProviderConfig: () => DefaultIdentityProviderConfig,\n    EXPIRATION_MS: () => DEFAULT_IDENTITY_EXPIRATION_MS,\n    HttpApiKeyAuthSigner: () => DQ4,\n    HttpBearerAuthSigner: () => EQ4,\n    NoAuthSigner: () => NoAuthSignatory,\n    createIsIdentityExpiredFunction: () => mm0,\n    createPaginator: () => gm0,\n    doesIdentityRequireRefresh: () => checkIfIdentityNeedsRefresh,\n    getHttpAuthSchemeEndpointRuleSetPlugin: () => IQ4,\n    getHttpAuthSchemePlugin: () => ZQ4,\n    getHttpSigningPlugin: () => XQ4,\n    getSmithyContext: () => getSmithyContextFromRequest,\n    httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => httpAuthSchemeEndpointRuleSetMiddlewareOptions,\n    httpAuthSchemeMiddleware: () => pX1,\n    httpAuthSchemeMiddlewareOptions: () => bm0,\n    httpSigningMiddleware: () => fm0,\n    httpSigningMiddlewareOptions: () => httpSigningMiddlewareOptions,\n    isIdentityExpired: () => zQ4,\n    memoizeIdentityProvider: () => memoizeRequestDataProvider,\n    normalizeProvider: () => normalizeIdentityProvider,\n    requestBuilder: () => VQ4.requestBuilder,\n    setFeature: () => setSmithyFeature\n  });\n  identityProviderExports.exports = createIdentityProviderExports(_identityProviderExports);\n  var ___________________________________________processImageTransformation = _____________________________processImageTransformation();\n  var getSmithyContextFromRequest = defineFunctionName(__smithyContext => __smithyContext[___________________________________________processImageTransformation.SMITHY_CONTEXT_KEY] ||= {}, \"getSmithyContext\");\n  var _______________________imageTransformationProcessor = ______________imageTransformationProcessor();\n  var filterAuthOptionsBySchemeIds = defineFunctionName((filterAndMergeItems, filterBySchemeIds) => {\n    if (!filterBySchemeIds || filterBySchemeIds.length === 0) {\n      return filterAndMergeItems;\n    }\n    let filteredSchemes = [];\n    for (let schemeId of filterBySchemeIds) {\n      for (let ___item of filterAndMergeItems) {\n        if (___item.schemeId.split(\"#\")[1] === schemeId) {\n          filteredSchemes.push(___item);\n        }\n      }\n    }\n    for (let __item of filterAndMergeItems) {\n      if (!filteredSchemes.find(({\n        schemeId: schemeIdCheck\n      }) => schemeIdCheck === __item.schemeId)) {\n        filteredSchemes.push(__item);\n      }\n    }\n    return filteredSchemes;\n  }, \"resolveAuthOptions\");\n  function createSchemeMap(_createSchemeMap) {\n    let schemeMap = new Map();\n    for (let schemeEntry of _createSchemeMap) {\n      schemeMap.set(schemeEntry.schemeId, schemeEntry);\n    }\n    return schemeMap;\n  }\n  defineFunctionName(createSchemeMap, \"convertHttpAuthSchemesToMap\");\n  var pX1 = defineFunctionName((httpAuthSchemeSelectionHandler, httpAuthSchemeProvider) => (processAuthorization, httpRequestContext) => async processHttpAuthScheme => {\n    let httpAuthScheme = httpAuthSchemeSelectionHandler.httpAuthSchemeProvider(await httpAuthSchemeProvider.httpAuthSchemeParametersProvider(httpAuthSchemeSelectionHandler, httpRequestContext, processHttpAuthScheme.input));\n    let authSchemePreferences = httpAuthSchemeSelectionHandler.authSchemePreference ? await httpAuthSchemeSelectionHandler.authSchemePreference() : [];\n    let authSchemeDetails = filterAuthOptionsBySchemeIds(httpAuthScheme, authSchemePreferences);\n    let selectedHttpAuthScheme = createSchemeMap(httpAuthSchemeSelectionHandler.httpAuthSchemes);\n    let smithyContext = (0, _______________________imageTransformationProcessor.getSmithyContext)(httpRequestContext);\n    let _errorMessages = [];\n    for (let authSchemeDetail of authSchemeDetails) {\n      let _httpAuthScheme = selectedHttpAuthScheme.get(authSchemeDetail.schemeId);\n      if (!_httpAuthScheme) {\n        _errorMessages.push(`HttpAuthScheme \\`${authSchemeDetail.schemeId}\\` was not enabled for this service.`);\n        continue;\n      }\n      let identityProvider = _httpAuthScheme.identityProvider(await httpAuthSchemeProvider.identityProviderConfigProvider(httpAuthSchemeSelectionHandler));\n      if (!identityProvider) {\n        _errorMessages.push(`HttpAuthScheme \\`${authSchemeDetail.schemeId}\\` did not have an IdentityProvider configured.`);\n        continue;\n      }\n      let {\n        identityProperties = {},\n        signingProperties: _signingProperties = {}\n      } = authSchemeDetail.propertiesExtractor?.(httpAuthSchemeSelectionHandler, httpRequestContext) || {};\n      authSchemeDetail.identityProperties = Object.assign(authSchemeDetail.identityProperties || {}, identityProperties);\n      authSchemeDetail.signingProperties = Object.assign(authSchemeDetail.signingProperties || {}, _signingProperties);\n      smithyContext.selectedHttpAuthScheme = {\n        httpAuthOption: authSchemeDetail,\n        identity: await identityProvider(authSchemeDetail.identityProperties),\n        signer: _httpAuthScheme.signer\n      };\n      break;\n    }\n    if (!smithyContext.selectedHttpAuthScheme) {\n      throw Error(_errorMessages.join(`\n`));\n    }\n    return processAuthorization(processHttpAuthScheme);\n  }, \"httpAuthSchemeMiddleware\");\n  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n    step: \"serialize\",\n    tags: [\"HTTP_AUTH_SCHEME\"],\n    name: \"httpAuthSchemeMiddleware\",\n    override: true,\n    relation: \"before\",\n    toMiddleware: \"endpointV2Middleware\"\n  };\n  var IQ4 = defineFunctionName((httpClientConfig, {\n    httpAuthSchemeParametersProvider: httpAuthSchemeParamsProvider,\n    identityProviderConfigProvider: identityProviderConfigProvider\n  }) => ({\n    applyToStack: httpClientConfigurator => {\n      httpClientConfigurator.addRelativeTo(pX1(httpClientConfig, {\n        httpAuthSchemeParametersProvider: httpAuthSchemeParamsProvider,\n        identityProviderConfigProvider: identityProviderConfigProvider\n      }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);\n    }\n  }), \"getHttpAuthSchemeEndpointRuleSetPlugin\");\n  var GQ4 = ___________________imageTransformationProcessor();\n  var bm0 = {\n    step: \"serialize\",\n    tags: [\"HTTP_AUTH_SCHEME\"],\n    name: \"httpAuthSchemeMiddleware\",\n    override: true,\n    relation: \"before\",\n    toMiddleware: GQ4.serializerMiddlewareOption.name\n  };\n  var ZQ4 = defineFunctionName((createAuthHandler, {\n    httpAuthSchemeParametersProvider: _httpAuthSchemeParamsProvider,\n    identityProviderConfigProvider: identityProviderConfig\n  }) => ({\n    applyToStack: addAuthHandlerToProvider => {\n      addAuthHandlerToProvider.addRelativeTo(pX1(createAuthHandler, {\n        httpAuthSchemeParametersProvider: _httpAuthSchemeParamsProvider,\n        identityProviderConfigProvider: identityProviderConfig\n      }), bm0);\n    }\n  }), \"getHttpAuthSchemePlugin\");\n  var httpRequestUtil = updateMetadata();\n  var defaultErrorHandler = defineFunctionName(__handleError => throwError => {\n    throw throwError;\n  }, \"defaultErrorHandler\");\n  var defaultSuccessHandler = defineFunctionName((____processData, ___________callbackFunction) => {}, \"defaultSuccessHandler\");\n  var fm0 = defineFunctionName(signHttpRequest => (__handleHttpRequest, httpAuthContext) => async ___handleHttpRequest => {\n    if (!httpRequestUtil.HttpRequest.isInstance(___handleHttpRequest.request)) {\n      return __handleHttpRequest(___handleHttpRequest);\n    }\n    let _selectedHttpAuthScheme = (0, _______________________imageTransformationProcessor.getSmithyContext)(httpAuthContext).selectedHttpAuthScheme;\n    if (!_selectedHttpAuthScheme) {\n      throw Error(\"No HttpAuthScheme was selected: unable to sign request\");\n    }\n    let {\n      httpAuthOption: {\n        signingProperties = {}\n      },\n      identity: userIdentity,\n      signer: signerFunction\n    } = _selectedHttpAuthScheme;\n    let signedHttpResponse = await __handleHttpRequest({\n      ...___handleHttpRequest,\n      request: await signerFunction.sign(___handleHttpRequest.request, userIdentity, signingProperties)\n    }).catch((signerFunction.errorHandler || defaultErrorHandler)(signingProperties));\n    (signerFunction.successHandler || defaultSuccessHandler)(signedHttpResponse.response, signingProperties);\n    return signedHttpResponse;\n  }, \"httpSigningMiddleware\");\n  var httpSigningMiddlewareOptions = {\n    step: \"finalizeRequest\",\n    tags: [\"HTTP_SIGNING\"],\n    name: \"httpSigningMiddleware\",\n    aliases: [\"apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n    override: true,\n    relation: \"after\",\n    toMiddleware: \"retryMiddleware\"\n  };\n  var XQ4 = defineFunctionName(createMiddlewareApplicator => ({\n    applyToStack: addMiddlewareToHttp => {\n      addMiddlewareToHttp.addRelativeTo(fm0(createMiddlewareApplicator), httpSigningMiddlewareOptions);\n    }\n  }), \"getHttpSigningPlugin\");\n  var normalizeIdentityProvider = defineFunctionName(resolveValueOrFunction => {\n    if (typeof resolveValueOrFunction === \"function\") {\n      return resolveValueOrFunction;\n    }\n    let resolveValue = Promise.resolve(resolveValueOrFunction);\n    return () => resolveValue;\n  }, \"normalizeProvider\");\n  var makePagedClientRequest = defineFunctionName(async (createAndSendObject, messageSender, _dataProcessor, inputProcessor = placeholder => placeholder, ...additionalArgs) => {\n    let transformInput = new createAndSendObject(_dataProcessor);\n    transformInput = inputProcessor(transformInput) ?? transformInput;\n    return await messageSender.send(transformInput, ...additionalArgs);\n  }, \"makePagedClientRequest\");\n  function gm0(clientType, fetchPaginatedData, paginationToken, tokenModifier, paginationTokenKey) {\n    return defineFunctionName(async function* (asyncGeneratorFunction, sourceData, ...X) {\n      let W = sourceData;\n      let fetchNextToken = asyncGeneratorFunction.startingToken ?? W[paginationToken];\n      let C = true;\n      let V;\n      while (C) {\n        W[paginationToken] = fetchNextToken;\n        if (paginationTokenKey) {\n          W[paginationTokenKey] = W[paginationTokenKey] ?? asyncGeneratorFunction.pageSize;\n        }\n        if (asyncGeneratorFunction.client instanceof clientType) {\n          V = await makePagedClientRequest(fetchPaginatedData, asyncGeneratorFunction.client, sourceData, asyncGeneratorFunction.withCommand, ...X);\n        } else {\n          throw Error(`Invalid client, expected instance of ${clientType.name}`);\n        }\n        yield V;\n        let previousToken = fetchNextToken;\n        fetchNextToken = fetchNextTokenFromPaginationResult(V, tokenModifier);\n        C = !!fetchNextToken && (!asyncGeneratorFunction.stopOnSameToken || fetchNextToken !== previousToken);\n      }\n      return;\n    }, \"paginateOperation\");\n  }\n  defineFunctionName(gm0, \"createPaginator\");\n  var fetchNextTokenFromPaginationResult = defineFunctionName((getNestedProperty, _getNestedProperty) => {\n    let __getNestedProperty = getNestedProperty;\n    let propertyPath = _getNestedProperty.split(\".\");\n    for (let currentProperty of propertyPath) {\n      if (!__getNestedProperty || typeof __getNestedProperty !== \"object\") {\n        return;\n      }\n      __getNestedProperty = __getNestedProperty[currentProperty];\n    }\n    return __getNestedProperty;\n  }, \"get\");\n  var VQ4 = b6();\n  function setSmithyFeature(contextualizeFeature, featureKey, featureValue) {\n    if (!contextualizeFeature.__smithy_context) {\n      contextualizeFeature.__smithy_context = {\n        features: {}\n      };\n    } else if (!contextualizeFeature.__smithy_context.features) {\n      contextualizeFeature.__smithy_context.features = {};\n    }\n    contextualizeFeature.__smithy_context.features[featureKey] = featureValue;\n  }\n  defineFunctionName(setSmithyFeature, \"setFeature\");\n  var DefaultIdentityProviderConfig = class {\n    constructor(A) {\n      this.authSchemes = new Map();\n      for (let [authSchemeKey, authSchemeValue] of Object.entries(A)) {\n        if (authSchemeValue !== undefined) {\n          this.authSchemes.set(authSchemeKey, authSchemeValue);\n        }\n      }\n    }\n    static {\n      defineFunctionName(this, \"DefaultIdentityProviderConfig\");\n    }\n    getIdentityProvider(A) {\n      return this.authSchemes.get(A);\n    }\n  };\n  var DQ4 = class {\n    static {\n      defineFunctionName(this, \"HttpApiKeyAuthSigner\");\n    }\n    async sign(A, B, Q) {\n      if (!Q) {\n        throw Error(\"request could not be signed with `apiKey` since the `name` and `in` signer properties are missing\");\n      }\n      if (!Q.name) {\n        throw Error(\"request could not be signed with `apiKey` since the `name` signer property is missing\");\n      }\n      if (!Q.in) {\n        throw Error(\"request could not be signed with `apiKey` since the `in` signer property is missing\");\n      }\n      if (!B.apiKey) {\n        throw Error(\"request could not be signed with `apiKey` since the `apiKey` is not defined\");\n      }\n      let I = httpRequestUtil.HttpRequest.clone(A);\n      if (Q.in === ___________________________________________processImageTransformation.HttpApiKeyAuthLocation.QUERY) {\n        I.query[Q.name] = B.apiKey;\n      } else if (Q.in === ___________________________________________processImageTransformation.HttpApiKeyAuthLocation.HEADER) {\n        I.headers[Q.name] = Q.scheme ? `${Q.scheme} ${B.apiKey}` : B.apiKey;\n      } else {\n        throw Error(\"request can only be signed with `apiKey` locations `query` or `header`, but found: `\" + Q.in + \"`\");\n      }\n      return I;\n    }\n  };\n  var EQ4 = class {\n    static {\n      defineFunctionName(this, \"HttpBearerAuthSigner\");\n    }\n    async sign(A, B, Q) {\n      let I = httpRequestUtil.HttpRequest.clone(A);\n      if (!B.token) {\n        throw Error(\"request could not be signed with `token` since the `token` is not defined\");\n      }\n      I.headers.Authorization = `Bearer ${B.token}`;\n      return I;\n    }\n  };\n  var NoAuthSignatory = class {\n    static {\n      defineFunctionName(this, \"NoAuthSigner\");\n    }\n    async sign(A, B, Q) {\n      return A;\n    }\n  };\n  var mm0 = defineFunctionName(expirationCheck => isTokenExpired => checkIfIdentityNeedsRefresh(isTokenExpired) && isTokenExpired.expiration.getTime() - Date.now() < expirationCheck, \"createIsIdentityExpiredFunction\");\n  var DEFAULT_IDENTITY_EXPIRATION_MS = 300000;\n  var zQ4 = mm0(DEFAULT_IDENTITY_EXPIRATION_MS);\n  var checkIfIdentityNeedsRefresh = defineFunctionName(expirationExists => expirationExists.expiration !== undefined, \"doesIdentityRequireRefresh\");\n  var memoizeRequestDataProvider = defineFunctionName((processData, responseValidator, isQualified) => {\n    if (processData === undefined) {\n      return;\n    }\n    let valueProvider = typeof processData !== \"function\" ? async () => Promise.resolve(processData) : processData;\n    let resolvedValue;\n    let cachedPromise;\n    let isDataAvailable;\n    let isProcessingResponse = false;\n    let coalesceProviderFunction = defineFunctionName(async fetchAndCacheValue => {\n      if (!cachedPromise) {\n        cachedPromise = valueProvider(fetchAndCacheValue);\n      }\n      try {\n        resolvedValue = await cachedPromise;\n        isDataAvailable = true;\n        isProcessingResponse = false;\n      } finally {\n        cachedPromise = undefined;\n      }\n      return resolvedValue;\n    }, \"coalesceProvider\");\n    if (responseValidator === undefined) {\n      return async _fetchData => {\n        if (!isDataAvailable || _fetchData?.forceRefresh) {\n          resolvedValue = await coalesceProviderFunction(_fetchData);\n        }\n        return resolvedValue;\n      };\n    }\n    return async handleDataRequest => {\n      if (!isDataAvailable || handleDataRequest?.forceRefresh) {\n        resolvedValue = await coalesceProviderFunction(handleDataRequest);\n      }\n      if (isProcessingResponse) {\n        return resolvedValue;\n      }\n      if (!isQualified(resolvedValue)) {\n        isProcessingResponse = true;\n        return resolvedValue;\n      }\n      if (responseValidator(resolvedValue)) {\n        await coalesceProviderFunction(handleDataRequest);\n        return resolvedValue;\n      }\n      return resolvedValue;\n    };\n  }, \"memoizeIdentityProvider\");\n});\nvar _______imageTransformationProcessor = z((defineAndExportClientConfiguration, __________________moduleExports) => {\n  var {\n    defineProperty: _definePropertyWithDescriptor,\n    getOwnPropertyDescriptor: ________________getOwnPropertyDescriptor,\n    getOwnPropertyNames: _______________getOwnPropertyNames\n  } = Object;\n  var _______________hasOwnProperty = Object.prototype.hasOwnProperty;\n  var ______________________definePropertyWithName = (A, B) => _definePropertyWithDescriptor(A, \"name\", {\n    value: B,\n    configurable: true\n  });\n  var __________defineProperties = (A, B) => {\n    for (var Q in B) {\n      _definePropertyWithDescriptor(A, Q, {\n        get: B[Q],\n        enumerable: true\n      });\n    }\n  };\n  var _copyPropertiesFromSource = (A, B, Q, I) => {\n    if (B && typeof B === \"object\" || typeof B === \"function\") {\n      for (let ______________________________propertyName of _______________getOwnPropertyNames(B)) {\n        if (!_______________hasOwnProperty.call(A, ______________________________propertyName) && ______________________________propertyName !== Q) {\n          _definePropertyWithDescriptor(A, ______________________________propertyName, {\n            get: () => B[______________________________propertyName],\n            enumerable: !(I = ________________getOwnPropertyDescriptor(B, ______________________________propertyName)) || I.enumerable\n          });\n        }\n      }\n    }\n    return A;\n  };\n  var createClientConfigurationExport = A => _copyPropertiesFromSource(_definePropertyWithDescriptor({}, \"__esModule\", {\n    value: true\n  }), A);\n  var clientConfigurationExports = {};\n  __________defineProperties(clientConfigurationExports, {\n    AlgorithmId: () => sm0,\n    EndpointURLScheme: () => am0,\n    FieldPosition: () => rm0,\n    HttpApiKeyAuthLocation: () => nm0,\n    HttpAuthLocation: () => im0,\n    IniSectionType: () => om0,\n    RequestHandlerProtocol: () => tm0,\n    SMITHY_CONTEXT_KEY: () => _____SMITHY_CONTEXT_KEY,\n    getDefaultClientConfiguration: () => TQ4,\n    resolveDefaultRuntimeConfig: () => PQ4\n  });\n  __________________moduleExports.exports = createClientConfigurationExport(clientConfigurationExports);\n  var im0 = (setUpApiConstants => {\n    setUpApiConstants.HEADER = \"header\";\n    setUpApiConstants.QUERY = \"query\";\n    return setUpApiConstants;\n  })(im0 || {});\n  var nm0 = (____initializeApiConstants => {\n    ____initializeApiConstants.HEADER = \"header\";\n    ____initializeApiConstants.QUERY = \"query\";\n    return ____initializeApiConstants;\n  })(nm0 || {});\n  var am0 = (_protocols => {\n    _protocols.HTTP = \"http\";\n    _protocols.HTTPS = \"https\";\n    return _protocols;\n  })(am0 || {});\n  var sm0 = (HashAlgorithms => {\n    HashAlgorithms.MD5 = \"md5\";\n    HashAlgorithms.CRC32 = \"crc32\";\n    HashAlgorithms.CRC32C = \"crc32c\";\n    HashAlgorithms.SHA1 = \"sha1\";\n    HashAlgorithms.SHA256 = \"sha256\";\n    return HashAlgorithms;\n  })(sm0 || {});\n  var _______createChecksumAlgorithmManager = ______________________definePropertyWithName(____createChecksumAlgorithmManager => {\n    let checksumAlgorithms = [];\n    if (____createChecksumAlgorithmManager.sha256 !== undefined) {\n      checksumAlgorithms.push({\n        algorithmId: () => \"sha256\",\n        checksumConstructor: () => ____createChecksumAlgorithmManager.sha256\n      });\n    }\n    if (____createChecksumAlgorithmManager.md5 != null) {\n      checksumAlgorithms.push({\n        algorithmId: () => \"md5\",\n        checksumConstructor: () => ____createChecksumAlgorithmManager.md5\n      });\n    }\n    return {\n      addChecksumAlgorithm(_addChecksumAlgorithm) {\n        checksumAlgorithms.push(_addChecksumAlgorithm);\n      },\n      checksumAlgorithms() {\n        return checksumAlgorithms;\n      }\n    };\n  }, \"getChecksumConfiguration\");\n  var resolveChecksumConstructorsByAlgorithmId = ______________________definePropertyWithName(_generateChecksumConstructors => {\n    let ___checksumConstructorsByAlgorithmId = {};\n    _generateChecksumConstructors.checksumAlgorithms().forEach(_checksumConstructorForAlgorithm => {\n      ___checksumConstructorsByAlgorithmId[_checksumConstructorForAlgorithm.algorithmId()] = _checksumConstructorForAlgorithm.checksumConstructor();\n    });\n    return ___checksumConstructorsByAlgorithmId;\n  }, \"resolveChecksumRuntimeConfig\");\n  var TQ4 = ______________________definePropertyWithName(_____processInput => {\n    return _______createChecksumAlgorithmManager(_____processInput);\n  }, \"getDefaultClientConfiguration\");\n  var PQ4 = ______________________definePropertyWithName(performRQ4Calculation => {\n    return resolveChecksumConstructorsByAlgorithmId(performRQ4Calculation);\n  }, \"resolveDefaultRuntimeConfig\");\n  var rm0 = (_MessageTypes => {\n    _MessageTypes[_MessageTypes.HEADER = 0] = \"HEADER\";\n    _MessageTypes[_MessageTypes.TRAILER = 1] = \"TRAILER\";\n    return _MessageTypes;\n  })(rm0 || {});\n  var _____SMITHY_CONTEXT_KEY = \"__smithy_context\";\n  var om0 = (setupConstants => {\n    setupConstants.PROFILE = \"profile\";\n    setupConstants.SSO_SESSION = \"sso-session\";\n    setupConstants.SERVICES = \"services\";\n    return setupConstants;\n  })(om0 || {});\n  var tm0 = (initializeHttpVersionConstants => {\n    initializeHttpVersionConstants.HTTP_0_9 = \"http/0.9\";\n    initializeHttpVersionConstants.HTTP_1_0 = \"http/1.0\";\n    initializeHttpVersionConstants.TDS_8_0 = \"tds/8.0\";\n    return initializeHttpVersionConstants;\n  })(tm0 || {});\n});",
  "originalFile": "test-samples/claude.js",
  "originalProvider": "openai",
  "originalModel": "gpt-4o-mini",
  "originalArgs": {
    "provider": "openai",
    "outputDir": "output/claude-2025-11-16T19:49:17",
    "baseURL": "https://api.openai.com/v1",
    "contextSize": "100000",
    "maxConcurrent": "25",
    "minBatchSize": "3",
    "maxBatchSize": "100",
    "dependencyMode": "balanced",
    "perf": true,
    "maxMemory": "4096",
    "validate": true,
    "chunkSize": "300000",
    "chunking": true,
    "debugChunks": false,
    "turbo": true,
    "refine": true
  }
}