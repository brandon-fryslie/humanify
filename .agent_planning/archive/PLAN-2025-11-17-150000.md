# IMPLEMENTATION PLAN: Global Progress Tracking with Iteration Display

**Generated**: 2025-11-17 15:00:00
**Source STATUS**: STATUS-2025-11-17-115400.md
**Spec Reference**: PROJECT_SPEC.md, CLAUDE.md
**Target**: Address user requirements #5, #6, #7 from PROJECT_SPEC.md

---

## EXECUTIVE SUMMARY

### Current State (from STATUS-2025-11-17-115400.md)

**What Works**:
- Basic progress tracking exists (`src/progress.ts`, `showPercentage()`)
- Per-batch progress bars in `unminify.ts` using cli-progress
- Refinement chaining works correctly (Pass 2 uses Pass 1 output)

**Critical Gaps**:
- ❌ No upfront work estimation before API calls start
- ❌ No global progress tracking across all files/chunks/iterations
- ❌ No iteration display (Pass 1 vs Pass 2+)
- ⚠️ Progress bars overlap and flicker (user complaint #5)
- ❌ No color coding to draw attention to important info

### User Requirements (from PROJECT_SPEC.md)

1. **Upfront Estimation**: "Calculate this for the entire codebase BEFORE sending ANY requests to the OpenAI API"
2. **Iteration Display**: "Iteration: n" with color coding (1=yellow, 2+=blue)
3. **Global Progress**: "Global progress bar that gives us our overall % progress taking into account ALL batches for all iterations"
4. **Per-Batch Progress**: "Keep the per-batch progress bar but improve it so it's not overlapping"
5. **Color Coding**: "Use color to draw attention to important information"

### Total Gap

**Estimated Effort**: 10-14 hours (2-3 work sessions)
**Complexity**: Medium (no architectural changes, mostly display/tracking logic)
**Dependencies**: None (can start immediately after test fixes)
**Risk**: Low (isolated changes, easy to test incrementally)

---

## PHASE 1: WORK ESTIMATION MODULE

**Effort**: 3-4 hours
**Priority**: P0 (Critical - foundation for all other phases)
**Status**: Not Started

### Description

Create a module that analyzes the input file and estimates total work BEFORE any API calls are made. This involves:
1. Running webcrack to discover extracted files
2. Parsing ASTs to count identifiers in each file
3. Estimating batch counts based on dependency graph (turbo mode) or sequential processing
4. Calculating total API calls across all iterations

**Spec Reference**: CLAUDE.md "Core Processing Pipeline" • PROJECT_SPEC.md line 19-21
**Status Reference**: STATUS-2025-11-17-115400.md section "BUG #3: Missing Global Progress"

### Implementation Tasks

#### Task 1.1: Create `src/estimate-work.ts` module

Create new file with interfaces:

```typescript
export interface WorkEstimate {
  // File-level metrics
  totalFiles: number;
  fileEstimates: FileEstimate[];

  // Identifier-level metrics
  totalIdentifiers: number;

  // Batch-level metrics (depends on turbo mode)
  totalBatches: number;
  estimatedBatchSizes: number[];

  // API call estimation
  estimatedAPICalls: number;  // Sum of all identifiers across all passes

  // Iteration estimation
  iterations: number;  // 1 or 2 (if refine=true)
}

export interface FileEstimate {
  path: string;
  size: number;
  identifierCount: number;
  estimatedBatches: number;
  willBeChunked: boolean;
  estimatedChunks?: number;
}
```

#### Task 1.2: Implement `estimateWork()` function

**Function signature**:
```typescript
export async function estimateWork(
  filename: string,
  options: {
    turbo?: boolean;
    refine?: boolean;
    chunkSize?: number;
    enableChunking?: boolean;
    dependencyMode?: "strict" | "balanced" | "relaxed";
  }
): Promise<WorkEstimate>
```

**Algorithm**:
1. Read input file
2. Run webcrack (same as production flow)
3. For each extracted file:
   - Parse AST using `@babel/parser`
   - Count binding identifiers using `@babel/traverse`
   - Check if file needs chunking (size > chunkSize)
   - If chunking: estimate chunks using `splitFile()` logic
4. If turbo mode:
   - Build dependency graph for each file
   - Count batches from graph
5. Calculate total batches across all files
6. Multiply by iterations (1 or 2)

**Dependencies**:
- `@babel/parser` (already in package.json)
- `@babel/traverse` (already in package.json)
- `src/plugins/webcrack.js` (reuse)
- `src/file-splitter.ts` (reuse)
- `src/plugins/local-llm-rename/dependency-graph.ts` (reuse for turbo estimation)

#### Task 1.3: Add CLI flag `--estimate-only`

Update `src/commands/openai.ts`, `gemini.ts`, `local.ts`:

```typescript
.option("--estimate-only", "Calculate work estimate and exit without processing")
```

When flag is set:
1. Call `estimateWork()`
2. Print formatted summary
3. Exit without calling `unminify()`

#### Task 1.4: Unit tests for `estimate-work.ts`

**Test file**: `src/estimate-work.test.ts`

Tests:
- ✓ Counts identifiers correctly for simple code
- ✓ Detects files that need chunking
- ✓ Estimates batches correctly in turbo mode
- ✓ Multiplies by iterations when refine=true
- ✓ Handles empty files gracefully

### Acceptance Criteria

- [ ] `estimateWork()` runs before any API calls
- [ ] Returns accurate identifier counts (within 5% of actual)
- [ ] Detects chunking correctly (matches production logic)
- [ ] Estimates batches within 10% of actual (turbo mode)
- [ ] Multiplies correctly for refinement iterations
- [ ] Takes <5 seconds for files up to 10MB
- [ ] Unit tests pass
- [ ] `--estimate-only` flag works for all providers

### Technical Notes

**Performance**: Webcrack can be slow for large files. Consider caching results if user runs multiple passes on same input.

**Accuracy**: Batch estimation in turbo mode requires building full dependency graph, which is expensive. Consider using heuristic (e.g., `identifierCount / 10`) for speed, with flag `--accurate-estimate` for precise calculation.

**Chunking**: Use same threshold as production (`chunkSize` option). Call `splitFile()` with dry-run mode to get chunk count without actually splitting.

---

## PHASE 2: GLOBAL PROGRESS TRACKER

**Effort**: 4-5 hours
**Priority**: P0 (Critical - core requirement)
**Status**: Not Started
**Dependencies**: Phase 1 (requires WorkEstimate)

### Description

Create a global progress tracking system that shows overall completion across all files, chunks, and iterations. This replaces the per-file percentage with a global view.

**Spec Reference**: CLAUDE.md "Progress Tracking" • PROJECT_SPEC.md line 27-29
**Status Reference**: STATUS-2025-11-17-115400.md section "Progress Tracking: User feedback INCOMPLETE"

### Implementation Tasks

#### Task 2.1: Create `src/global-progress.ts` module

```typescript
export interface GlobalProgressState {
  // Iteration tracking
  currentIteration: number;  // 1 or 2
  totalIterations: number;   // 1 or 2

  // Work tracking
  totalWork: number;        // From WorkEstimate.estimatedAPICalls
  completedWork: number;    // Incremented as identifiers are processed

  // Batch tracking (for display)
  currentBatch: number;
  totalBatches: number;

  // File tracking
  currentFile: string;
  currentFileIndex: number;
  totalFiles: number;
}

export class GlobalProgressTracker {
  private state: GlobalProgressState;
  private startTime: number;

  constructor(workEstimate: WorkEstimate) {
    // Initialize from WorkEstimate
  }

  // Called when starting a new iteration
  startIteration(iteration: number): void;

  // Called when starting a new file
  startFile(filepath: string, fileIndex: number): void;

  // Called when starting a new batch
  startBatch(batchIndex: number): void;

  // Called as identifiers are processed
  updateProgress(completedIdentifiers: number): void;

  // Get current percentage (0-1)
  getPercentage(): number;

  // Get formatted stats for display
  getStats(): string;
}
```

#### Task 2.2: Integrate with `unminify.ts`

**Changes to `src/unminify.ts`**:

1. Add `globalProgress` parameter:
   ```typescript
   export async function unminify(
     filename: string,
     outputDir: string,
     plugins: ((code: string) => Promise<string | VisitResult>)[],
     options: UnminifyOptions,
     globalProgress?: GlobalProgressTracker  // NEW
   )
   ```

2. Update file loop to call `globalProgress.startFile()`:
   ```typescript
   for (let i = 0; i < extractedFiles.length; i++) {
     globalProgress?.startFile(extractedFiles[i].path, i + 1);
     // ... existing code
   }
   ```

3. Pass `globalProgress` to plugins via `onProgress` callback:
   ```typescript
   const pluginResult = await plugins[j](currentCode, (percentage) => {
     globalProgress?.updateProgress(percentage);
   });
   ```

#### Task 2.3: Integrate with `visit-all-identifiers.ts`

**Changes to `src/plugins/local-llm-rename/visit-all-identifiers.ts`**:

The `onProgress` callback already exists (line 67). Update usage:

1. In sequential mode (line 221):
   ```typescript
   onProgress?.(visited.size / numRenamesExpected);
   ```
   This already works - no changes needed.

2. In turbo mode (line 391):
   ```typescript
   onProgress?.((processedCount + completed) / numRenamesExpected);
   ```
   This already works - no changes needed.

**Conclusion**: No changes needed to `visit-all-identifiers.ts`. The existing `onProgress` callback propagates correctly.

#### Task 2.4: Update commands to use GlobalProgressTracker

**Changes to `src/commands/openai.ts`, `gemini.ts`, `local.ts`**:

1. Before Pass 1, create WorkEstimate:
   ```typescript
   const workEstimate = await estimateWork(filename, {
     turbo: opts.turbo,
     refine: opts.refine,
     chunkSize: parseInt(opts.chunkSize, 10),
     enableChunking: opts.chunking !== false,
     dependencyMode
   });

   const globalProgress = new GlobalProgressTracker(workEstimate);
   ```

2. Pass to `unminify()` calls:
   ```typescript
   await unminify(filename, opts.outputDir, plugins, options, globalProgress);
   ```

3. Between passes, update iteration:
   ```typescript
   if (opts.refine) {
     globalProgress.startIteration(2);
     await unminify(pass1OutputFile, opts.outputDir, plugins, options, globalProgress);
   }
   ```

#### Task 2.5: Unit tests

**Test file**: `src/global-progress.test.ts`

Tests:
- ✓ Initializes correctly from WorkEstimate
- ✓ Tracks progress correctly across files
- ✓ Handles iteration transitions
- ✓ Calculates percentage correctly
- ✓ Handles edge cases (empty files, zero identifiers)

### Acceptance Criteria

- [ ] GlobalProgressTracker initializes from WorkEstimate
- [ ] Progress updates as identifiers are processed
- [ ] Percentage calculation is accurate (matches actual/total)
- [ ] Iteration transitions work correctly
- [ ] Works with chunking enabled
- [ ] Works in both turbo and sequential modes
- [ ] Unit tests pass

### Technical Notes

**Thread Safety**: JavaScript is single-threaded, but async operations can interleave. Use atomic updates for `completedWork` counter.

**Accuracy**: Progress will be approximate during chunking (we estimate chunks upfront but actual count may differ slightly). Document this as expected behavior.

---

## PHASE 3: ENHANCED DISPLAY WITH COLOR CODING

**Effort**: 3-4 hours
**Priority**: P0 (Critical - user-facing requirement)
**Status**: Not Started
**Dependencies**: Phase 2 (requires GlobalProgressTracker)

### Description

Replace the overlapping, flickering progress output with a clean, structured display using cli-progress MultiBar and chalk for color coding.

**Spec Reference**: PROJECT_SPEC.md lines 14-16, 23-33
**Status Reference**: STATUS-2025-11-17-115400.md section "Progress Tracking: User feedback INCOMPLETE"

### Implementation Tasks

#### Task 3.1: Create `src/display-manager.ts` module

```typescript
import * as cliProgress from "cli-progress";
import chalk from "chalk";
import { GlobalProgressTracker } from "./global-progress.js";

export class DisplayManager {
  private multiBar: cliProgress.MultiBar;
  private iterationLine: string = "";
  private globalBar: cliProgress.SingleBar;
  private batchBar: cliProgress.SingleBar;
  private statusLine: string = "";

  constructor(private globalProgress: GlobalProgressTracker) {
    this.multiBar = new cliProgress.MultiBar({
      clearOnComplete: false,
      hideCursor: true,
      format: ' {bar} | {percentage}% | {info}',
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
    });

    this.globalBar = this.multiBar.create(100, 0, { info: 'Global Progress' });
    this.batchBar = this.multiBar.create(100, 0, { info: 'Current Batch' });
  }

  // Update iteration display (called at start of each iteration)
  updateIteration(iteration: number): void {
    const color = iteration === 1 ? chalk.yellow : chalk.blueBright;
    this.iterationLine = color(`Iteration: ${iteration}`);
    this.render();
  }

  // Update global progress bar
  updateGlobal(percentage: number): void {
    this.globalBar.update(Math.round(percentage * 100), {
      info: chalk.green(`Global Progress (${Math.round(percentage * 100)}%)`)
    });
  }

  // Update batch progress bar
  updateBatch(batchNum: number, totalBatches: number, percentage: number): void {
    this.batchBar.update(Math.round(percentage * 100), {
      info: `Batch ${batchNum}/${totalBatches}`
    });
  }

  // Update status line (file being processed, etc.)
  updateStatus(status: string): void {
    this.statusLine = status;
    this.render();
  }

  // Clear and re-render entire display
  private render(): void {
    console.log(this.iterationLine);
    // MultiBar handles its own rendering
  }

  // Stop and cleanup
  stop(): void {
    this.multiBar.stop();
  }

  // Print summary after batch completion
  printBatchSummary(stats: {
    identifiersProcessed: number;
    tokensProcessed: number;
    cacheHits: number;
    elapsedSeconds: number;
  }): void {
    console.log(chalk.gray("\n─────────────────────────────────────"));
    console.log(chalk.bold("Batch Complete"));
    console.log(chalk.gray(`  Identifiers: ${stats.identifiersProcessed}`));
    console.log(chalk.gray(`  Tokens: ${stats.tokensProcessed.toLocaleString()}`));
    console.log(chalk.gray(`  Cache Hits: ${stats.cacheHits}`));
    console.log(chalk.gray(`  Elapsed: ${stats.elapsedSeconds.toFixed(1)}s`));
    console.log(chalk.gray("─────────────────────────────────────\n"));
  }
}
```

#### Task 3.2: Add `chalk` dependency

```bash
npm install chalk
npm install --save-dev @types/chalk
```

**Note**: Check if chalk is already in package.json. If so, just verify version is compatible (v5+).

#### Task 3.3: Integrate DisplayManager with `unminify.ts`

**Changes to `src/unminify.ts`**:

1. Add `displayManager` parameter:
   ```typescript
   export async function unminify(
     filename: string,
     outputDir: string,
     plugins: ((code: string) => Promise<string | VisitResult>)[],
     options: UnminifyOptions,
     globalProgress?: GlobalProgressTracker,
     displayManager?: DisplayManager  // NEW
   )
   ```

2. Replace console.log calls with displayManager updates:
   ```typescript
   displayManager?.updateStatus(`Processing file ${i+1}/${extractedFiles.length}`);
   ```

3. Remove existing progress bar code (lines 143-165, 230-250):
   - Delete `progressBar` variables
   - Delete `timerInterval` logic
   - Keep plugin execution, but remove spinner

4. Add batch summary after each batch completes:
   ```typescript
   displayManager?.printBatchSummary({
     identifiersProcessed: renames.size,
     tokensProcessed: totalTokens,
     cacheHits: cacheHits,
     elapsedSeconds: (Date.now() - batchStart) / 1000
   });
   ```

#### Task 3.4: Update commands to use DisplayManager

**Changes to `src/commands/openai.ts`, `gemini.ts`, `local.ts`**:

1. Create DisplayManager after GlobalProgressTracker:
   ```typescript
   const globalProgress = new GlobalProgressTracker(workEstimate);
   const displayManager = new DisplayManager(globalProgress);
   ```

2. Update iteration display:
   ```typescript
   displayManager.updateIteration(1);
   await unminify(filename, opts.outputDir, plugins, options, globalProgress, displayManager);

   if (opts.refine) {
     displayManager.updateIteration(2);
     globalProgress.startIteration(2);
     await unminify(pass1OutputFile, opts.outputDir, plugins, options, globalProgress, displayManager);
   }

   displayManager.stop();
   ```

#### Task 3.5: Integration tests

**Test file**: `src/display-manager.e2etest.ts`

Tests:
- ✓ Iteration display changes color (manual verification)
- ✓ Progress bars don't overlap
- ✓ Batch summary prints correctly
- ✓ Works with small files (<100 identifiers)
- ✓ Works with large files (>1000 identifiers)

### Acceptance Criteria

- [ ] Iteration header always visible with correct color (yellow for 1, blue for 2+)
- [ ] Global progress bar shows overall percentage (0-100%)
- [ ] Batch progress bar shows current batch percentage
- [ ] No overlapping or flickering
- [ ] Batch summary prints after each batch
- [ ] Status line shows current file being processed
- [ ] Colors draw attention to important info
- [ ] Works in both TTY and non-TTY environments

### Technical Notes

**TTY Detection**: cli-progress requires TTY. Add fallback for non-TTY:
```typescript
if (!process.stdout.isTTY) {
  // Fall back to simple text output
  console.log(`Iteration: ${iteration}`);
  console.log(`Global Progress: ${percentage}%`);
}
```

**Line Reservation**: cli-progress MultiBar reserves lines automatically. No need for manual cursor management.

**Color Support**: Use `chalk.level` to detect color support. Gracefully degrade if colors not supported.

---

## PHASE 4: INTEGRATION AND POLISH

**Effort**: 2-3 hours
**Priority**: P1 (High - quality and verification)
**Status**: Not Started
**Dependencies**: Phases 1-3 (all previous phases)

### Description

Integrate all pieces together, add comprehensive testing, and polish the user experience.

**Spec Reference**: CLAUDE.md "Test Patterns"
**Status Reference**: STATUS-2025-11-17-115400.md section "Test Suite Status"

### Implementation Tasks

#### Task 4.1: End-to-end integration test

**Test file**: `src/global-progress.e2etest.ts`

Test flow:
1. Run `estimateWork()` on sample file
2. Create GlobalProgressTracker
3. Create DisplayManager
4. Run full `unminify()` pipeline
5. Verify progress reaches 100%
6. Verify iteration display correct

#### Task 4.2: Add metrics collection

Update `displayManager.printBatchSummary()` to include:
- Average tokens per identifier
- Cache hit rate (%)
- Estimated time remaining (based on elapsed / percentage)

#### Task 4.3: Documentation updates

**Files to update**:
- `CLAUDE.md`: Add section on progress tracking architecture
- `README.md`: Add screenshots/examples of new display
- `src/commands/openai.ts`: Update help text to mention upfront estimation

#### Task 4.4: Performance verification

Run with large files (babylon.js, tensorflow.js) and verify:
- Estimation takes <10 seconds
- Progress percentage is accurate (within 5% at any point)
- Display doesn't slow down processing

#### Task 4.5: Backwards compatibility check

Verify that:
- Old CLI flags still work
- `--verbose` mode coexists with new display
- Non-TTY environments work correctly
- Tests pass (unit + e2e + llm)

### Acceptance Criteria

- [ ] All unit tests pass (estimate-work, global-progress, display-manager)
- [ ] E2E test passes with real OpenAI API calls
- [ ] Progress reaches exactly 100% at completion
- [ ] Documentation updated
- [ ] Performance verified on large files
- [ ] Backwards compatibility verified
- [ ] No regressions in existing features

### Technical Notes

**Estimation Accuracy**: The estimation will never be 100% accurate (chunking is dynamic, API calls may fail and retry). Document acceptable error margin (±5%).

**Cache Hits**: When cache is warm, progress may jump quickly. This is expected behavior.

---

## DEPENDENCY GRAPH

```
Phase 1 (Work Estimation)
    ↓
Phase 2 (Global Progress Tracker) ─────┐
    ↓                                  │
Phase 3 (Display Manager)              │
    ↓                                  │
Phase 4 (Integration & Polish) ←───────┘
```

**Critical Path**: Phase 1 → Phase 2 → Phase 3 → Phase 4 (all sequential)

**Parallel Opportunities**: None (each phase builds on previous)

---

## RECOMMENDED SPRINT PLANNING

### Sprint 1 (4-6 hours): Foundation

**Goal**: Upfront work estimation working

Tasks:
- Phase 1.1: Create `estimate-work.ts` module
- Phase 1.2: Implement `estimateWork()` function
- Phase 1.3: Add `--estimate-only` CLI flag
- Phase 1.4: Unit tests

**Deliverable**: `--estimate-only` flag works, prints accurate estimate

### Sprint 2 (4-6 hours): Tracking

**Goal**: Global progress tracking integrated

Tasks:
- Phase 2.1: Create `global-progress.ts` module
- Phase 2.2: Integrate with `unminify.ts`
- Phase 2.3: Verify `visit-all-identifiers.ts` propagation
- Phase 2.4: Update commands
- Phase 2.5: Unit tests

**Deliverable**: Progress updates correctly, percentage accurate

### Sprint 3 (3-5 hours): Display

**Goal**: Clean, non-overlapping display with color

Tasks:
- Phase 3.1: Create `display-manager.ts` module
- Phase 3.2: Add chalk dependency
- Phase 3.3: Integrate with `unminify.ts`
- Phase 3.4: Update commands
- Phase 3.5: Integration tests

**Deliverable**: User sees iteration header, global bar, batch bar, no flickering

### Sprint 4 (2-3 hours): Polish

**Goal**: Production-ready

Tasks:
- Phase 4.1: E2E integration test
- Phase 4.2: Add metrics collection
- Phase 4.3: Documentation updates
- Phase 4.4: Performance verification
- Phase 4.5: Backwards compatibility check

**Deliverable**: Feature complete, documented, tested

---

## RISK ASSESSMENT

### High-Risk Items

**None identified**. All tasks are well-scoped and isolated.

### Medium-Risk Items

1. **Estimation Accuracy** (Phase 1.2)
   - **Risk**: Upfront estimation may not match actual work (especially with chunking)
   - **Mitigation**: Document expected accuracy (±5%), test with variety of file sizes
   - **Fallback**: Use conservative estimate (overestimate batches)

2. **Progress Callback Propagation** (Phase 2.3)
   - **Risk**: `onProgress` callback may not work in all plugin paths (chunking, turbo mode)
   - **Mitigation**: Test all code paths (normal, chunked, turbo, turbo+chunked)
   - **Fallback**: Add progress updates at chunk/batch boundaries if callback fails

3. **Display Performance** (Phase 3.3)
   - **Risk**: Frequent display updates may slow down processing
   - **Mitigation**: Throttle updates to max 10/second
   - **Fallback**: Disable display in `--verbose` mode

### Low-Risk Items

4. **Color Support** (Phase 3.1)
   - **Risk**: Colors may not work on all terminals
   - **Mitigation**: Use chalk's auto-detection, graceful degradation

5. **Non-TTY Environments** (Phase 3.5)
   - **Risk**: Progress bars don't work in CI/logs
   - **Mitigation**: Detect TTY, fall back to text output

---

## BLOCKERS AND QUESTIONS

### Blockers

**None**. Can start immediately after:
1. Test fixes (BUG #1 from STATUS report) - see separate plan
2. User approval of this plan

### Questions for User

1. **Estimation Performance**: Is 5-10 seconds upfront estimation acceptable for 10MB+ files? Or should we use faster heuristics (less accurate)?

2. **Refinement Iterations**: Should we support >2 iterations (e.g., `--refine=3`)? Or limit to 2?

3. **Progress Persistence**: Should progress state be saved to disk (for resume)? Or in-memory only?

4. **Metrics Priority**: Which stats are most important in batch summary?
   - Identifiers processed
   - Tokens used (cost estimation)
   - Cache hit rate
   - Time remaining
   - API calls made

---

## SUCCESS METRICS

### Functional Requirements

- [ ] Upfront estimation completes before first API call
- [ ] Global progress bar starts at 0%, ends at 100%
- [ ] Iteration display shows correct number with correct color
- [ ] Batch progress bar visible and non-overlapping
- [ ] Batch summary prints after each batch
- [ ] No flickering or overlapping text

### Quality Requirements

- [ ] Progress percentage accurate within 5% at any time
- [ ] Estimation takes <10 seconds for files up to 10MB
- [ ] Display updates don't slow processing (overhead <1%)
- [ ] All tests pass (unit + e2e)
- [ ] Works in TTY and non-TTY environments
- [ ] Backwards compatible with existing flags

### User Experience Requirements

- [ ] User sees total work before processing starts
- [ ] User always knows: current iteration, global progress, current batch progress
- [ ] Important info (iteration, errors) stands out via color
- [ ] Display is readable (no overlaps, clean layout)

---

## APPENDIX: FILE CHANGES SUMMARY

### New Files (6 total)

1. `src/estimate-work.ts` - Work estimation module
2. `src/estimate-work.test.ts` - Unit tests for estimation
3. `src/global-progress.ts` - Global progress tracker
4. `src/global-progress.test.ts` - Unit tests for tracker
5. `src/display-manager.ts` - Display management
6. `src/global-progress.e2etest.ts` - E2E integration test

### Modified Files (4-7 total)

1. `src/unminify.ts` - Add globalProgress and displayManager parameters
2. `src/commands/openai.ts` - Integrate estimation, progress, display
3. `src/commands/gemini.ts` - Integrate estimation, progress, display
4. `src/commands/local.ts` - Integrate estimation, progress, display
5. `package.json` - Add chalk dependency (if not present)
6. `CLAUDE.md` - Document progress tracking architecture (optional)
7. `README.md` - Add usage examples and screenshots (optional)

### Unmodified Files

- `src/plugins/local-llm-rename/visit-all-identifiers.ts` - Already has `onProgress` callback
- `src/progress.ts` - Keep for download progress (separate concern)
- All test files (except new ones)

---

**Plan Status**: READY FOR IMPLEMENTATION
**Estimated Timeline**: 10-14 hours (2-3 work sessions)
**Next Step**: Get user approval, then begin Phase 1
