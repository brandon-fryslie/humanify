# Implementation Plan: HumanifyJS Critical Bug Fixes

**Generated**: 2025-11-17 02:25:00
**Source STATUS**: STATUS-2025-11-17-021529.md
**Spec Version**: CLAUDE.md (last modified: 2025-11-16)

---

## Executive Summary

This plan addresses two critical, production-blocking bugs in HumanifyJS identified by the project-evaluator:

1. **Bug #1 (brandon-fryslie_humanify-7dp)**: Checkpoint deletion timing issue causing potential data loss
2. **Bug #2 (brandon-fryslie_humanify-e7c)**: Refinement feature broken for multi-file bundles due to hardcoded filename

Both bugs are **VERIFIED AND ACCURATE** per STATUS report. Fixes are architecturally sound, well-scoped, and can be implemented without major refactoring.

### Timeline
- **Bug #1**: 15-21 hours (2-3 days)
- **Bug #2**: 12-17 hours (1.5-2 days)
- **Total**: 27-38 hours (3.5-5 days)

### Risk Level
- **Low**: Both fixes are well-understood, isolated changes
- **Rollback**: Simple revert to original behavior if issues arise
- **Testing**: Comprehensive test suite provided for both bugs

---

## Bug #1: Fix Checkpoint Deletion Timing

### Problem Statement

**Location**: `src/plugins/local-llm-rename/visit-all-identifiers.ts:151-152`

**Issue**: Checkpoints are deleted BEFORE the final output file is written to disk. This creates a race condition where any failure in downstream processing (prettier, file I/O, etc.) results in complete loss of all renaming work.

**Evidence from STATUS Report (lines 27-138)**:
- Current flow: AST transform → delete checkpoint → prettier → write file
- Correct flow: AST transform → prettier → write file → delete checkpoint
- Real-world likelihood: HIGH (large files stress prettier, cloud-synced filesystems have I/O failures)

### Implementation Phases

#### Phase 1a: Modify Plugin Interface Return Type (1-2 hours)
- **Goal**: Allow plugins to return either `string` (backward compat) or `{code: string, checkpointId?: string | null}`
- **Files**: `src/unminify.ts` (line 21)
- **Change**: Update plugin type signature to support both return types

#### Phase 1b: Update visitAllIdentifiers Return Type (2-3 hours)
- **Goal**: Return checkpoint ID along with code
- **Files**: `src/plugins/local-llm-rename/visit-all-identifiers.ts` (lines 151-155)
- **Changes**:
  - Remove `deleteCheckpoint()` call at line 152
  - Return `{code: stringified.code, checkpointId: originalCheckpointId}` instead of just code

#### Phase 1c: Update All Rename Plugins (3-4 hours)
- **Goal**: Extract and forward checkpointId from visitAllIdentifiers
- **Files**:
  - `src/plugins/openai/openai-rename.ts` (lines 187-196)
  - `src/plugins/gemini-rename.ts` (lines 106-131)
  - `src/plugins/local-llm-rename/local-llm-rename.ts` (lines 22-43)
- **Changes**: Handle both string and object returns, forward checkpointId

#### Phase 1d: Update unminify.ts to Delete Checkpoints After Write (3-4 hours)
- **Goal**: Collect checkpoint IDs during plugin execution, delete AFTER successful write
- **Files**: `src/unminify.ts` (lines 60, 152-156, 229-233, 263)
- **Changes**:
  - Track checkpoint IDs in array
  - Extract checkpoint ID from plugin results (both chunked and non-chunked paths)
  - Delete checkpoints AFTER `fs.writeFile` succeeds
  - Clear array between files

#### Phase 1e: Error Handling & Edge Cases (2-3 hours)
- **Goal**: Handle write failures gracefully, ensure checkpoints persist
- **Files**: `src/unminify.ts` (lines 259-266)
- **Changes**: Wrap file write in try-catch, preserve checkpoints on failure, log recovery instructions

### Testing Strategy

1. **Unit Tests** (`src/checkpoint-deletion-timing.test.ts`):
   - Verify visitAllIdentifiers returns object with checkpointId
   - Checkpoint ID matches input code hash

2. **E2E Tests** (`src/checkpoint-deletion-timing.e2etest.ts`):
   - Test checkpoint persists if write fails
   - Test checkpoint deleted after successful completion
   - Verify resume functionality works

3. **Manual Tests**:
   - Kill process mid-run → verify checkpoint exists
   - Simulate write failure → verify checkpoint preserved
   - Normal completion → verify checkpoint deleted

4. **Regression Tests**:
   - Run existing checkpoint tests: `npm run test:e2e`
   - Verify `src/checkpoint-subcommands.e2etest.ts` and `src/checkpoint-runtime.e2etest.ts` pass

### Acceptance Criteria

- [ ] visitAllIdentifiers returns `{code, checkpointId}` not just code
- [ ] All three rename plugins updated (openai, gemini, local)
- [ ] unminify.ts deletes checkpoint AFTER fs.writeFile succeeds
- [ ] If file write fails, checkpoint remains for recovery
- [ ] Existing checkpoint tests still pass
- [ ] New test: checkpoint persists if write fails
- [ ] Manual test: kill process after AST transform, verify checkpoint exists

### Files to Modify

1. `src/plugins/local-llm-rename/visit-all-identifiers.ts` (line 151-155)
2. `src/plugins/openai/openai-rename.ts` (line 187-196)
3. `src/plugins/gemini-rename.ts` (line 106-131)
4. `src/plugins/local-llm-rename/local-llm-rename.ts` (line 22-43)
5. `src/unminify.ts` (lines 21, 60, 152-156, 229-233, 263)

---

## Bug #2: Fix Refinement Hardcoded Filename

### Problem Statement

**Location**: `src/commands/openai.ts:249`

**Issue**: Refinement pass assumes output file is named `deobfuscated.js`, but webcrack creates files with varied names like `index.js`, `bundle.json`, `node_modules/1/index.js`, etc. This causes refinement to either fail (file not found) or process the wrong file.

**Evidence from STATUS Report (lines 141-313)**:
- Current: Pass 2 tries to process hardcoded "deobfuscated.js"
- Expected: Pass 2 discovers actual files from Pass 1, processes each separately
- Impact: Refinement completely broken for bundled files (exactly when it's most valuable)

### Implementation Phases

#### Phase 2a: Discover Actual Output Files (2-3 hours)
- **Goal**: Replace hardcoded filename with dynamic file discovery
- **Files**: `src/commands/openai.ts` (lines 244-276)
- **Changes**:
  - Read actual files from output directory
  - Filter for .js files (exclude bundle.json)
  - Iterate over each file separately
  - Log which files are being refined
  - Handle nested directories (node_modules/N/index.js)

#### Phase 2b: Add skipWebcrack Option (2-3 hours)
- **Goal**: Prevent refinement from re-running webcrack on already-processed files
- **Files**: `src/unminify.ts` (lines 12-16, 48-54)
- **Changes**:
  - Add `skipWebcrack?: boolean` to UnminifyOptions interface
  - Conditionally skip webcrack when flag is set
  - Use input file directly as extracted file

#### Phase 2c: Apply Fix to Gemini Command (1-2 hours)
- **Goal**: Check if gemini.ts has --refine flag and apply same fix
- **Files**: `src/commands/gemini.ts`
- **Action**: Verify no --refine flag exists (per STATUS line 318-323), document as not implemented

#### Phase 2d: Verify Local Command (1 hour)
- **Goal**: Check if local.ts has --refine flag
- **Files**: `src/commands/local.ts`
- **Action**: Verify no --refine flag exists (per STATUS line 320), document as not implemented

#### Phase 2e: Fix Validation for Multi-File Bundles (2-3 hours)
- **Goal**: Update validation to check all output files, not just one
- **Files**: `src/commands/openai.ts` (lines 301-320)
- **Changes**:
  - Discover all .js files in output directory
  - Validate each file separately
  - Show per-file validation status
  - Fail if any file is invalid

### Testing Strategy

1. **E2E Tests** (`src/refinement-multifile.e2etest.ts`):
   - Test multi-file bundle → all files refined
   - Test single file → refinement works
   - Verify webcrack NOT run on pass 2
   - Verify all files processed

2. **Manual Tests**:
   ```bash
   # Real bundle with refinement
   just download-tensorflow
   ./dist/index.mjs unminify test-samples/tensorflow.min.js --provider openai --refine --turbo
   ls -la output/test-refine/  # Should see multiple refined files

   # Single file with refinement
   ./dist/index.mjs unminify fixtures/example.min.js --provider openai --refine

   # Verify webcrack NOT run on pass 2
   ./dist/index.mjs unminify test-samples/tensorflow.min.js --provider openai --refine --verbose 2>&1 | grep -i webcrack
   # Expected: "Running webcrack" once, "Skipping webcrack" N times
   ```

3. **Regression Tests**:
   - Run existing tests: `npm test`
   - Verify no regressions in non-refinement mode
   - Check validation works for single files

### Acceptance Criteria

- [ ] No hardcoded "deobfuscated.js" filename
- [ ] Discovers all .js files in output directory
- [ ] Handles nested directories (node_modules/N/index.js)
- [ ] Each file from pass 1 processed separately in pass 2
- [ ] Webcrack does NOT run again on already-processed files
- [ ] Validation checks all files, not just one
- [ ] New E2E test: Bundle with 3 files → verify all 3 refined
- [ ] Manual test: Run --refine with real bundle, verify all output files processed

### Files to Modify

1. `src/commands/openai.ts` (lines 244-276, 301-320)
2. `src/unminify.ts` (lines 12-16, 48-54)
3. `src/commands/gemini.ts` (verification only, no changes expected)
4. `src/commands/local.ts` (verification only, no changes expected)

---

## Dependency Graph

```
Bug #1 Phases:
1a → 1b → 1c → 1d → 1e

Bug #2 Phases:
2a → 2b
2c (parallel to 2a/2b)
2d (parallel to 2a/2b)
2e → depends on 2a/2b

Independent: Bug #1 and Bug #2 can be worked in parallel
Recommended: Fix Bug #1 first (data safety is more critical)
```

---

## Risk Assessment

### Bug #1 Risks
- **Low**: Well-scoped change, clear boundaries
- **Mitigation**: Backward compatibility maintained, comprehensive tests
- **Rollback**: Simple revert to original behavior

### Bug #2 Risks
- **Medium**: Affects file discovery and processing flow
- **Mitigation**: Handle edge cases (empty dirs, nested dirs, no files)
- **Rollback**: Revert to hardcoded filename (refinement broken but no crashes)

### Overall Risk
- **Low-Medium**: Both bugs have clear fixes, good test coverage
- **Confidence**: High (STATUS report validated issues through code inspection and flow analysis)

---

## Success Metrics

### Bug #1 Success
- Checkpoint survives write failures
- Resume functionality works correctly
- All existing checkpoint tests pass
- New tests for write failure scenarios pass

### Bug #2 Success
- Refinement works with multi-file bundles
- Refinement works with single files
- Webcrack not re-run on pass 2
- Validation checks all files

### Overall Success
- No data loss scenarios
- Refinement feature functional for all use cases
- No performance regressions
- Clean, maintainable code with good error handling

---

## Recommended Execution Order

1. **Week 1, Days 1-3**: Bug #1 (Checkpoint Deletion Timing)
   - Day 1: Phases 1a, 1b (interface and visitAllIdentifiers)
   - Day 2: Phases 1c, 1d (plugins and unminify.ts)
   - Day 3: Phase 1e + testing

2. **Week 1, Days 4-5**: Bug #2 (Refinement Hardcoded Filename)
   - Day 4: Phases 2a, 2b (file discovery and skipWebcrack)
   - Day 5: Phases 2c, 2d, 2e + testing

3. **Week 2, Day 1**: Final validation
   - Run full test suite
   - Manual testing with real bundles
   - Update STATUS report to "FIXED"

---

## Notes

- Both bugs existed because tests were missing for the affected scenarios
- Bug #1 is more critical (data safety) but simpler to fix
- Bug #2 affects user-facing features but has clear workaround (don't use --refine)
- Fixes maintain backward compatibility
- No breaking changes to public APIs
- Clear rollback path if issues arise

---

## References

- **STATUS Report**: `.agent_planning/STATUS-2025-11-17-021529.md`
- **Spec Document**: `CLAUDE.md`
- **Issue Tracker**:
  - Bug #1: `brandon-fryslie_humanify-7dp`
  - Bug #2: `brandon-fryslie_humanify-e7c`
- **Beads Database**: `.beads/beads.db`

---

**End of Implementation Plan**
