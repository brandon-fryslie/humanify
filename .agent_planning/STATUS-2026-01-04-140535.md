# Status Report - 2026-01-04-140535

## Executive Summary
Overall: 40% complete | Critical issues: 8 | Tests reliable: N/A (no tests exist)

**Assessment**: The webapp v2 design document describes a complete architectural overhaul from modal-heavy to panel-based workbench. Current implementation (~6,025 LOC) is a functional React + Express dashboard with SSE for real-time updates, but it shares minimal architectural commonality with the v2 vision. This is fundamentally a **rebuild, not a refactor**.

**Recommendation**: CONTINUE - Design is well-specified, current implementation provides useful reference material, but plan for ground-up reconstruction of UI architecture.

---

## Runtime Assessment

**Attempted**: Manual inspection of codebase structure and comparison to design document.

**Result**: No runtime execution performed. This is an architectural evaluation of design vs. implementation gap.

**Evidence**:
- Design doc: `/Users/bmf/code/brandon-fryslie_humanify/docs/plans/2026-01-04-webapp-v2-design.md`
- Current implementation: `/Users/bmf/code/brandon-fryslie_humanify/src/turbo-v2/webapp/` (6,025 LOC across 24 files)

---

## Architecture Gap Analysis

### Current Implementation (v1)

**Architecture**: Traditional React SPA with modal-heavy UX

| Component | Technology | Purpose |
|-----------|-----------|---------|
| Frontend | React 18 + Material-UI + Vite | Modal-based UI |
| Backend | Express + SSE | Real-time updates |
| Data | JSON file storage (.humanify-experiments/) | Experiments, presets, runs |
| State | React hooks (useState) | Local component state |
| Communication | REST API + SSE (Server-Sent Events) | Polling + streaming |

**UI Pattern**: Modals for all interactions
- `ExperimentForm` (modal)
- `ExperimentDetail` (modal)
- `CompareView` (modal)
- `PresetManager` (modal)
- `IdentifierContextDialog` (modal)

**Data Flow**: Polling-based with SSE augmentation
```
App.tsx (root state)
  â”œâ”€> ExperimentList (grid view)
  â”œâ”€> ExperimentForm (modal)
  â”œâ”€> ExperimentDetail (modal)
  â”‚     â””â”€> useExperimentProgress (SSE hook)
  â”œâ”€> CompareView (modal)
  â””â”€> PresetManager (modal)
```

### V2 Design Vision

**Architecture**: Panel-based workbench with WebSocket real-time

| Component | Design Requirement | Gap from Current |
|-----------|-------------------|------------------|
| Layout | 4-zone panel system (Left/Main/Right/Bottom) | **Complete rebuild** - no panel system exists |
| Panels | Independent, draggable, duplicatable | **Complete rebuild** - modals are not panels |
| Navigation | Command palette (Cmd+P) with action chaining | **Net new** - no command palette |
| Communication | WebSocket for real-time updates | **Replace SSE** - need bidirectional |
| Views | Experiment Tree (hierarchical) + Grid (table) | **Partial** - grid exists, tree is new |
| Inspector | Context-sensitive right sidebar | **Net new** - no inspector concept |
| Tabs | All zones support tabs, multiple panels open | **Complete rebuild** - single modal stack |

---

## Gap Assessment by Design Priority

### Priority 1: Experiment Tree (Left Sidebar)

**Current State**: âŒ Does not exist
- `ExperimentList.tsx` is a flat DataGrid (table view), not hierarchical
- No "By Status / By Preset / By Sample" grouping
- No collapsible categories
- No tree navigation

**Reuse Potential**: 10%
- Filtering logic (`statusFilter`, `presetFilter`) can inform tree grouping
- Column definitions show what metadata is important

**Implementation Scope**: **HIGH** (net new component)
- Need recursive tree data structure
- Collapsible categories with counts
- Context menu integration
- Keyboard navigation

---

### Priority 2: Experiment Grid (Main)

**Current State**: âœ… Mostly exists
- `ExperimentList.tsx` is already a DataGrid with sorting/filtering
- Has: search, status filter, mode filter, preset filter
- Has: sortable columns, pagination, checkbox selection

**Reuse Potential**: 70%
- Component can be adapted to panel architecture
- Column definitions are good
- Filtering logic is solid

**Implementation Scope**: **LOW** (refactor to panel)
- Remove modal triggers, emit events instead
- Integrate with command palette
- Add panel header/toolbar

---

### Priority 3: Experiment Detail (Main, Tabbed)

**Current State**: âš ï¸ Partial - modal implementation exists
- `ExperimentDetail.tsx` is a comprehensive modal (445 LOC)
- Has: Config display, Runs table, Passes breakdown
- Has: Real-time updates via `useExperimentProgress`
- **Missing**: Multiple tabs open simultaneously (modal = single instance)

**Reuse Potential**: 50%
- Content/layout can be preserved
- Real-time logic is good (though needs WebSocket migration)
- Run/pass display logic is solid

**Implementation Scope**: **MEDIUM** (convert modal â†’ tabbed panel)
- Extract content from Dialog wrapper
- Support multiple instances (tabs)
- Integrate with panel system
- Migrate SSE â†’ WebSocket

---

### Priority 4: Metrics Dashboard (Main)

**Current State**: âŒ Does not exist
- No visualization/charting component
- No aggregate metrics across experiments

**Reuse Potential**: 0%
- Backend has raw data (runs, tokens, costs)
- Need charting library (recharts, chart.js, visx)

**Implementation Scope**: **HIGH** (net new + charting)

---

### Priority 5: Preset Editor (Main)

**Current State**: âš ï¸ Partial - basic CRUD modal
- `PresetManager.tsx` (390 LOC) allows viewing/creating presets
- Shows built-in vs custom presets
- **Missing**: Visual pass pipeline editor (drag-drop, reorder)

**Reuse Potential**: 30%
- CRUD API calls can be reused
- Basic form structure exists

**Implementation Scope**: **MEDIUM** (rebuild with visual editor)
- Drag-drop pass ordering
- Inline pass configuration
- Visual pipeline display

---

### Priority 6: Inspector (Right Sidebar)

**Current State**: âŒ Does not exist
- No context-sensitive detail view
- `IdentifierContextDialog.tsx` is closest analog (modal for identifier details)

**Reuse Potential**: 20%
- Identifier detail rendering logic can inform inspector content
- API hooks for fetching context exist

**Implementation Scope**: **HIGH** (net new component)
- Context-aware display (experiment/run/pass/identifier)
- Auto-updates on selection change
- Compact sidebar layout

---

### Priority 7: Data Management (Main)

**Current State**: âŒ Does not exist
- No admin panel
- Storage management is filesystem-only

**Reuse Potential**: 0%
**Implementation Scope**: **MEDIUM** (straightforward admin panel)

---

### Priority 8: Log Viewer (Bottom, Tabbed)

**Current State**: âš ï¸ Partial - logs embedded in detail modal
- `ExperimentDetail.tsx` shows `consoleLogs` in accordion
- No filtering, search, or multi-log tabs

**Reuse Potential**: 20%
- Log display logic exists
- API for fetching logs exists

**Implementation Scope**: **MEDIUM** (extract + enhance)
- Dedicated log viewer component
- Level filtering (DEBUG/INFO/WARN/ERROR)
- Text search
- Auto-scroll
- WebSocket streaming

---

### Priority 9: Command Palette

**Current State**: âŒ Does not exist
- No command palette infrastructure
- All actions via buttons/menus

**Reuse Potential**: 0%
**Implementation Scope**: **HIGH** (net new feature)
- Fuzzy search
- Action â†’ submenu chaining (Quicksilver-style)
- Keyboard shortcuts (Cmd+P, Tab, Enter, Esc)
- Action registry

---

### Priority 10: Panel Management System

**Current State**: âŒ Does not exist
- No layout engine
- No panel state management
- No drag-drop

**Reuse Potential**: 0%
**Implementation Scope**: **VERY HIGH** (core infrastructure)

Recommended libraries:
- `react-grid-layout` or `golden-layout` for panel system
- `cmdk` for command palette
- `react-dnd` for drag-drop (if needed)

---

## What Can Be Reused?

### âœ… High Reuse (70-90%)

1. **Type System** (`shared/types.ts` - 364 LOC)
   - Excellent foundation: `ExperimentConfig`, `Run`, `PassDetail`, `IdentifierDetail`
   - Comprehensive API types
   - Already supports Runs as first-class entities
   - **Action**: Keep with minor additions for panel state

2. **Backend Storage** (`server/storage.ts`)
   - JSON file storage works fine for prototype
   - CRUD operations are solid
   - **Action**: Keep as-is, maybe add panel state persistence

3. **Backend API Routes** (`server/api/*`)
   - REST endpoints are well-structured
   - Can add WebSocket alongside existing routes
   - **Action**: Extend, don't replace

4. **Experiment Grid Logic** (`ExperimentList.tsx`)
   - Filtering, sorting, pagination logic is good
   - **Action**: Extract from modal context, integrate into panel

### âš ï¸ Medium Reuse (30-50%)

5. **Experiment Detail Content** (`ExperimentDetail.tsx`)
   - Run/pass display is useful
   - **Action**: Extract content from Dialog wrapper, make tabbed

6. **Real-time Progress Hook** (`useExperimentProgress.ts`)
   - Good abstraction for progress tracking
   - **Action**: Migrate from SSE to WebSocket, keep hook interface

7. **API Client** (`client/api.ts`)
   - Request functions are useful
   - **Action**: Extend with WebSocket management

### âŒ Low/No Reuse (0-20%)

8. **App.tsx** (root component)
   - Modal-based state management won't work for panels
   - **Action**: Complete rewrite with panel layout engine

9. **All Modal Components**
   - Modals are antithetical to panel-based design
   - **Action**: Extract content, discard modal wrappers

10. **SSE Infrastructure** (`server/api/progress.ts`)
    - Server-Sent Events are unidirectional
    - **Action**: Replace with WebSocket for bidirectional communication

---

## Implementation Red Flags

### ðŸš© Missing Critical Infrastructure

| Missing Component | Design Requirement | Impact |
|-------------------|-------------------|--------|
| Panel layout engine | 4-zone system with tabs | **BLOCKING** - core architecture |
| Command palette | Cmd+P action chaining | **BLOCKING** - primary navigation |
| WebSocket server | Real-time bidirectional | **BLOCKING** - live updates |
| State persistence | Remember open panels/tabs | **HIGH** - UX degradation without |
| Keyboard shortcuts | Cmd+N, Cmd+W, Cmd+\, etc. | **HIGH** - keyboard-first design |

### ðŸš© Architectural Mismatches

| Current Pattern | V2 Requirement | Migration Path |
|-----------------|----------------|----------------|
| Modal-heavy | Panel-based | **REBUILD** - fundamentally incompatible |
| Single-instance views | Multiple tabs per panel | **REBUILD** - state management overhaul |
| Polling + SSE | WebSocket | **REPLACE** - add WS server |
| Button-driven | Command palette-driven | **AUGMENT** - keep buttons, add palette |
| Global state in App.tsx | Independent panel state | **REFACTOR** - distributed state |

### ðŸš© Testing Gap

- **NO TESTS EXIST** for current webapp
- No unit tests, no integration tests, no E2E tests
- Makes refactoring risky
- **Recommendation**: Write tests for v2 from day 1

---

## Ambiguities Found

| Area | Question Not Answered | How Implementation Might Guess | Impact |
|------|----------------------|--------------------------------|--------|
| Panel State Persistence | What exactly persists across sessions? | Might store full layout state, causing version conflicts | User experience degrades on updates |
| WebSocket Reconnection | Retry strategy? Backoff? Max retries? | Might use simple retry-forever | Could cause server load spikes |
| Command Palette Scope | Which actions are available? Contextual? | Might hardcode all actions globally | Misses context-sensitive opportunities |
| Multiple Tabs Lifecycle | When do tabs auto-close? Memory limits? | Might never close tabs automatically | Memory leak potential |
| Experiment Tree Grouping | Default grouping on load? User preference? | Might hardcode "By Status" | User preference not honored |
| Panel Drag-Drop | Can panels move between zones? | Might restrict panels to specific zones | Limits flexibility unnecessarily |
| Keyboard Shortcuts | Full shortcut map? Conflicts with browser? | Might clash with browser shortcuts (Cmd+W) | User frustration |

**Recommendation**: Address these in design doc or implementation plan before coding.

---

## Implementation Assessment

### What Works Well âœ…

1. **Type safety**: Comprehensive TypeScript types
2. **Data model**: Experiment/Run separation is clean
3. **Backend APIs**: RESTful, well-structured
4. **Grid component**: Solid filtering/sorting
5. **Real-time updates**: SSE hook is clean abstraction
6. **Storage**: Simple JSON files work for prototype

### What Needs Replacement âŒ

1. **Entire UI architecture**: Modals â†’ Panels
2. **Root app structure**: App.tsx is modal orchestrator
3. **Communication layer**: SSE â†’ WebSocket
4. **Navigation paradigm**: Buttons â†’ Command palette
5. **State management**: Centralized â†’ Distributed

### What Needs Enhancement âš ï¸

1. **Experiment detail**: Modal â†’ Tabbed panel
2. **Log viewer**: Embedded â†’ Dedicated panel
3. **Preset editor**: Basic form â†’ Visual pipeline
4. **Progress tracking**: SSE-based â†’ WebSocket-based

---

## Dependency Analysis

### Critical Path Dependencies

```
1. Panel Layout Engine (BLOCKING ALL)
   â”œâ”€> 2. State Management (panel positions, tabs)
   â”‚     â”œâ”€> 3a. Experiment Tree Panel
   â”‚     â”œâ”€> 3b. Experiment Grid Panel
   â”‚     â”œâ”€> 3c. Experiment Detail Panel (tabbed)
   â”‚     â”œâ”€> 3d. Inspector Panel
   â”‚     â””â”€> 3e. Log Viewer Panel
   â”œâ”€> 4. Command Palette (navigation)
   â””â”€> 5. WebSocket Server (real-time)
        â””â”€> 6. WebSocket Client Hook (replaces SSE)
```

### Independent Work Streams (can parallelize after foundation)

- Metrics Dashboard (uses existing data, any panel)
- Preset Editor enhancements (uses existing CRUD)
- Data Management panel (admin functions)
- Identifier Trace panel (future capability)

---

## Recommended Implementation Order

### Phase 1: Foundation (BLOCKING - 2-3 weeks)

**Goal**: Get basic panel system working with one panel

1. **Choose panel layout library**
   - Evaluate: react-grid-layout, golden-layout, react-mosaic
   - Decision criteria: TypeScript support, tabs, drag-drop, persistence
   - **Deliverable**: Proof-of-concept 4-zone layout

2. **Implement panel management**
   - Panel registration system
   - Tab management within zones
   - State persistence (localStorage)
   - **Deliverable**: Can open/close/move a dummy panel

3. **Migrate one panel (Experiment Grid)**
   - Extract `ExperimentList` content from modal context
   - Wrap in panel container
   - Integrate with new layout
   - **Deliverable**: Working grid in Main zone

4. **Add WebSocket server**
   - Replace SSE in `server/api/progress.ts`
   - Implement bidirectional progress streaming
   - **Deliverable**: WebSocket endpoint working

**Gate**: Can open Experiment Grid in Main zone, move it to other zones, persist layout on refresh.

---

### Phase 2: Core Panels (3-4 weeks)

**Goal**: Primary workflows functional

5. **Experiment Tree panel**
   - Hierarchical grouping (By Status, By Preset, By Sample)
   - Collapsible categories
   - Single-click â†’ Inspector, Double-click â†’ Detail tab
   - **Deliverable**: Working tree in Left zone

6. **Experiment Detail tabbed panel**
   - Extract content from `ExperimentDetail.tsx`
   - Support multiple tabs (one per experiment)
   - Migrate to WebSocket for real-time
   - **Deliverable**: Can open multiple experiment tabs in Main

7. **Inspector panel**
   - Context-sensitive display (experiment/run/pass)
   - Auto-updates on selection change
   - **Deliverable**: Inspector shows selected item details

8. **Log Viewer panel**
   - Extract from detail modal
   - Add filtering (level, pass, text search)
   - WebSocket streaming
   - **Deliverable**: Logs stream in Bottom zone

**Gate**: Can navigate tree â†’ open detail â†’ view logs â†’ inspect run, all in panel UI.

---

### Phase 3: Enhanced Navigation (2-3 weeks)

**Goal**: Keyboard-first workflows

9. **Command palette**
   - Choose library (`cmdk` recommended)
   - Implement action registry
   - Action â†’ submenu chaining
   - **Deliverable**: Cmd+P opens palette, can run experiments

10. **Keyboard shortcuts**
    - Global shortcuts (Cmd+P, Cmd+N, Cmd+W, Cmd+\, Cmd+J)
    - Context shortcuts (Enter to run, Delete to delete)
    - **Deliverable**: All major actions keyboard-accessible

11. **Context menus**
    - Right-click on tree items
    - Right-click in zones (add/close panels)
    - **Deliverable**: Mouse users have backup to keyboard

**Gate**: Can complete all workflows via keyboard alone.

---

### Phase 4: Advanced Features (2-3 weeks)

**Goal**: Complete design spec

12. **Metrics Dashboard**
    - Choose charting library
    - Aggregate metrics queries
    - Visualizations (score over time, cost by preset, top performers)
    - **Deliverable**: Dashboard panel in Main

13. **Preset Editor enhancements**
    - Visual pass pipeline
    - Drag-drop pass ordering
    - Inline config editing
    - **Deliverable**: Visual preset editor

14. **Data Management panel**
    - Storage stats
    - Clear experiments (completed/failed/all)
    - Export/import
    - **Deliverable**: Admin panel

**Gate**: All Priority 1-7 panels implemented and functional.

---

### Phase 5: Polish & Testing (1-2 weeks)

15. **State persistence refinement**
    - Upgrade-safe persistence (version schema)
    - Panel position reset on version change
    - **Deliverable**: Smooth version upgrades

16. **Testing infrastructure**
    - Unit tests (hooks, utilities)
    - Integration tests (panel interactions)
    - E2E tests (full workflows)
    - **Deliverable**: >70% coverage

17. **Performance optimization**
    - Large experiment list virtualization
    - Log streaming buffer limits
    - WebSocket message throttling
    - **Deliverable**: No lag with 1000+ experiments

**Gate**: All tests passing, no performance issues, state persists correctly.

---

## Risk Assessment

### HIGH RISK ðŸ”´

1. **Panel library choice**: Wrong choice = painful migration later
   - **Mitigation**: Spend 2-3 days on PoC evaluation
   - **Validate**: Tabs, drag-drop, TypeScript, active maintenance

2. **State management complexity**: Panels + tabs + persistence = lots of state
   - **Mitigation**: Use battle-tested state library (Zustand, Jotai, or context)
   - **Validate**: Can serialize/deserialize all panel state

3. **WebSocket scaling**: Many clients, long-lived connections
   - **Mitigation**: Connection pooling, heartbeat, auto-reconnect
   - **Validate**: Load test with 10+ concurrent experiments

### MEDIUM RISK ðŸŸ¡

4. **Command palette UX**: Chaining is non-obvious if done poorly
   - **Mitigation**: Copy Raycast/Spotlight patterns exactly
   - **Validate**: User testing with keyboard-first users

5. **Multiple tabs memory usage**: Unconstrained tabs = memory leak
   - **Mitigation**: Tab limit (10-20), LRU eviction, explicit close
   - **Validate**: Memory profiling with 100+ tabs

6. **Keyboard shortcut conflicts**: Browser vs app shortcuts
   - **Mitigation**: Use Cmd/Ctrl modifiers, document conflicts
   - **Validate**: Test on Mac/Linux/Windows

### LOW RISK ðŸŸ¢

7. **Backend compatibility**: Existing APIs should mostly work
   - **Mitigation**: Incremental WebSocket addition, keep REST
   - **Validate**: Both SSE and WS work during migration

8. **Type safety**: TypeScript reduces surprises
   - **Mitigation**: Already using TS, keep strict mode
   - **Validate**: No `any` types in panel system

---

## Beads Issue Status

| Category | Count | Examples |
|----------|-------|----------|
| Ready (unblocked) | 0 | - |
| In Progress | 0 | - |
| Blocked | 0 | - |
| Stale (14+ days) | 0 | - |

**Alignment Check**:
- No beads issues exist for webapp v2 project yet
- Recommendation: Create epic for webapp v2 with subtasks per phase

---

## Recommendations

### 1. Treat This as a Rebuild, Not a Refactor

**Rationale**: Modal-based and panel-based architectures are fundamentally incompatible. Attempting incremental migration will create a "worst of both worlds" hybrid.

**Action**:
- Start new `webapp-v2/` directory alongside existing `webapp/`
- Port reusable code (types, API, storage) incrementally
- Keep `webapp/` functional during development
- Switch over when v2 reaches feature parity

### 2. Prioritize Panel System Before Any Features

**Rationale**: Every feature depends on panel infrastructure. Building features before the foundation = throwaway work.

**Action**:
- Spend 2-3 days evaluating panel libraries (react-grid-layout, golden-layout, etc.)
- Build hello-world 4-zone layout with one dummy panel
- Validate: drag-drop, tabs, persistence
- **Gate decision**: Don't proceed until panel system is proven

### 3. WebSocket Before Real-Time Features

**Rationale**: SSE is unidirectional, insufficient for command-driven interactions (future: cancel run, pause).

**Action**:
- Add WebSocket server endpoint alongside existing SSE
- Migrate progress tracking first (low risk, high value)
- Keep SSE during migration for backwards compat
- Remove SSE once WS is stable

### 4. Command Palette Can Wait (but plan for it)

**Rationale**: Buttons can be primary navigation in early phases. Command palette is high-value but not blocking.

**Action**:
- Defer command palette to Phase 3 (after panels work)
- Design button UX to be command-palette-compatible (emit events, don't call directly)
- Use `cmdk` library (battle-tested, Raycast uses it)

### 5. Write Tests from Day 1

**Rationale**: Current webapp has 0 tests. Rebuilding without tests = same mistake again.

**Action**:
- Set up Vitest + React Testing Library
- Test panel management (open/close/move)
- Test each panel component in isolation
- E2E with Playwright for full workflows
- **Target**: >70% coverage before launch

### 6. Incremental Delivery via Feature Flags

**Rationale**: Long rebuild = risk of "big bang" deployment failure.

**Action**:
- Add `--webapp-version v1|v2` flag
- Run both webapps in parallel during development
- Gradual migration: power users test v2, fallback to v1
- Smooth transition when v2 stable

---

## What Could Not Be Verified

| Item | Why | User Can Check |
|------|-----|----------------|
| Current webapp functionality | No runtime execution requested | Start webapp: `cd src/turbo-v2/webapp && npm run dev` â†’ verify modals work |
| Panel library compatibility | Requires prototyping | Build PoC with react-grid-layout + golden-layout, test tabs/drag-drop |
| WebSocket performance | Requires load testing | Simulate 10 concurrent experiments, measure connection stability |
| State persistence edge cases | Requires version upgrade simulation | Store panel state, change schema, verify graceful degradation |
| Command palette UX | Requires user testing | Build prototype, test with keyboard-first users |

**All architectural analysis completed via code inspection and design document review.**

---

## Workflow Recommendation

- [ ] **CONTINUE** - Issues are clear, implementation can proceed with phased approach

**Next Steps**:
1. Review this evaluation with stakeholders
2. Address ambiguities in design doc (panel persistence, WS reconnection, keyboard shortcuts)
3. Create beads epic for webapp v2 with 5 phases as subtasks
4. Start Phase 1: Panel library evaluation + PoC (2-3 days)
5. Gate decision: Validate panel system before proceeding to Phase 2

**Estimated Timeline**: 10-15 weeks to feature parity with current webapp + v2 enhancements

**Critical Success Factors**:
- Panel library choice (spend time on evaluation)
- WebSocket stability (load testing required)
- State management (avoid centralized bottleneck)
- Testing discipline (write tests first)
