# Turbo V2 Implementation Roadmap
**Generated**: 2025-12-30
**Source**: FINAL_PROJECT_SPEC.md
**Total Sprints**: 12
**Estimated Duration**: 8-12 weeks

---

## Overview

This roadmap breaks down the Turbo V2 implementation into 12 sprints, each with 2-3 deliverables. Sprints are sequenced based on dependencies - each sprint builds on the previous.

### Phase → Sprint Mapping

| Phase | Sprints | Description |
|-------|---------|-------------|
| Phase 0 | 1 | Validation Infrastructure (complete baseline measurements) |
| Phase 1 | 2-4 | Foundation: Ledger, Vault, Core Components |
| Phase 2 | 5-6 | Multi-Pass & Context Flow |
| Phase 3 | 7-8 | Checkpointing & Resume |
| Phase 4 | 9 | UI & Observability |
| Phase 5 | 10 | CLI Integration |
| Phase 6 | 11-12 | Advanced Strategies |

### Success Gates

| Gate | Sprint | Criteria |
|------|--------|----------|
| **Gate 1** | 8 | Resume mid-pass without losing any identifier progress |
| **Gate 2** | 4 | Vault hit-rate is 100% on retry of crashed run |
| **Gate 3** | 6 | Semantic score within 5% of sequential on medium-chart |
| **Gate 4** | 6 | 5000 identifiers in < 10 minutes |

---

## Sprint 1: Phase 0 Completion - Hypothesis Validation
**Phase**: 0 (Validation Infrastructure)
**Blocking**: All subsequent sprints
**Risk**: HIGH - If hypothesis fails, architecture needs rethink

### Sprint Goal
Validate the core hypothesis that multi-pass parallel processing can achieve ≥95% of sequential quality.

### Deliverables

#### D1.1: Run Semantic Scoring on All Baselines
**Description**: Execute the semantic scoring script on sequential and 1-pass parallel baselines.

**Acceptance Criteria**:
- [ ] Sequential semantic scores generated for tiny-qs, small-axios, medium-chart
- [ ] 1-pass parallel semantic scores generated for tiny-qs, small-axios
- [ ] All scores stored in `output-{mode}/semantic-score.json` files
- [ ] Scores include: overall score (0-100), confidence, sample size, model used

**Technical Notes**:
- Uses existing `scripts/score-semantic.ts`
- Requires OpenAI API key (GPT-4o as judge)
- Estimated API cost: ~$10
- API time: 4-6 hours (mostly latency)

#### D1.2: Analyze Results and Make Go/No-Go Decision
**Description**: Evaluate semantic scores against hypothesis thresholds.

**Acceptance Criteria**:
- [ ] Sequential baseline scores documented (expect 80-90%)
- [ ] 1-pass parallel scores documented (expect 60-70%)
- [ ] Go/No-Go decision made based on criteria:
  - GO if 1-pass ≥ 60% of sequential
  - NO-GO if 1-pass < 50% of sequential
- [ ] Results documented in `VALIDATION-RESULTS.md`

**Technical Notes**:
- If NO-GO: Requires architecture rethink (streaming, anchor-first hybrid)
- If GO: Proceed to Sprint 2

#### D1.3: Update Spec with Empirical Data
**Description**: Replace hypothesis assumptions with measured values.

**Acceptance Criteria**:
- [ ] FINAL_PROJECT_SPEC.md lines 156-166 updated with actual measurements
- [ ] All `~` prefixes removed from quality numbers
- [ ] Validation results section added to spec
- [ ] Hypothesis status changed from "assumed" to "validated"

### Dependencies
- OpenAI API key configured
- Baseline runs complete (already done)

### Risks
- **Hypothesis failure (30%)**: If 1-pass < 50%, architecture needs rethink
- **Low sequential scores**: If sequential < 70%, test samples may be insufficient

---

## Sprint 2: Foundation - Vault Implementation
**Phase**: 1 (Foundation)
**Blocking**: Sprint 3-12 (all LLM operations need caching)

### Sprint Goal
Implement the Vault (request-level cache) to ensure zero wasted API spend on retries.

### Deliverables

#### D2.1: Implement Vault Core
**Description**: Content-addressed cache for LLM request/response pairs.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/vault/vault.ts` implements VaultInterface
- [ ] Cache key: `hash(model + prompt + options)` using SHA-256
- [ ] Storage: `.humanify-cache/vault/{hash}.json`
- [ ] Operations: `get(key)`, `set(key, response)`, `has(key)`
- [ ] Atomic writes via temp-file + rename pattern

**Technical Notes**:
```typescript
interface VaultInterface {
  get(key: string): Promise<VaultEntry | null>;
  set(key: string, entry: VaultEntry): Promise<void>;
  has(key: string): Promise<boolean>;
  computeKey(model: string, prompt: string, options: object): string;
}

interface VaultEntry {
  request: { model: string; prompt: string; options: object };
  response: { content: string; tokens: TokenUsage; timestamp: string };
  hash: string;
}
```

#### D2.2: Implement Vault Integration with LLM Gateway
**Description**: LLM Gateway checks vault before making API calls.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/llm-gateway.ts` implements caching logic
- [ ] Cache miss: Call LLM, store in vault, return response
- [ ] Cache hit: Return cached response without API call
- [ ] Metrics tracked: hits, misses, hit rate percentage

**Technical Notes**:
- LLM Gateway wraps existing openai-rename.ts patterns
- Must not break existing functionality

#### D2.3: Vault Unit Tests
**Description**: Comprehensive tests for vault operations.

**Acceptance Criteria**:
- [ ] Test: Cache miss → API call → cache store
- [ ] Test: Cache hit → no API call → cached response
- [ ] Test: 100% hit rate on retry after crash
- [ ] Test: Atomic writes survive process kill
- [ ] Test: Hash collisions are impossible (SHA-256)

### Dependencies
- Sprint 1 complete (hypothesis validated)

### Risks
- **Disk space growth**: Add vault size monitoring (defer eviction to Sprint 11)

---

## Sprint 3: Foundation - Ledger Implementation
**Phase**: 1 (Foundation)
**Blocking**: Sprint 7-8 (checkpointing requires ledger)

### Sprint Goal
Implement the Ledger (append-only event log) as the source of truth for all state changes.

### Deliverables

#### D3.1: Implement Ledger Core
**Description**: Append-only event log with crash recovery.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/ledger/ledger.ts` implements LedgerInterface
- [ ] Storage: `{jobDir}/events.jsonl`
- [ ] Events: JOB_STARTED, PASS_STARTED, BATCH_STARTED, IDENTIFIER_RENAMED, BATCH_COMPLETED, PASS_COMPLETED, SNAPSHOT_CREATED, JOB_COMPLETED
- [ ] Append operation: Write + fsync for durability
- [ ] Recovery: Discard partial lines on load

**Technical Notes**:
```typescript
interface LedgerInterface {
  append(event: LedgerEvent): Promise<void>;
  replay(): AsyncIterable<LedgerEvent>;
  getState(): Promise<LedgerState>;
}

type LedgerEvent =
  | { type: 'JOB_STARTED'; jobId: string; config: JobConfig; timestamp: string }
  | { type: 'IDENTIFIER_RENAMED'; id: string; oldName: string; newName: string; confidence: number }
  | // ... other events
```

#### D3.2: Implement Event Types and Schemas
**Description**: Define all event types with TypeScript interfaces.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/ledger/events.ts` defines all 8 event types
- [ ] Each event has timestamp, type discriminator, and payload
- [ ] JSON schema validation for event parsing
- [ ] Event versioning strategy documented (for future migrations)

#### D3.3: Ledger Unit Tests
**Description**: Tests for append, replay, and crash recovery.

**Acceptance Criteria**:
- [ ] Test: Append events and replay in order
- [ ] Test: Partial line at EOF is discarded
- [ ] Test: State reconstructed correctly from replay
- [ ] Test: 10,000 events replay in < 1 second
- [ ] Test: Concurrent appends are serialized correctly

### Dependencies
- Sprint 2 complete (vault available for LLM caching)

### Risks
- **I/O performance**: May need buffered writes for high-volume events

---

## Sprint 4: Foundation - Core Orchestration
**Phase**: 1 (Foundation)
**Blocking**: Sprint 5-6 (multi-pass needs orchestrator)
**Gate**: Gate 2 (Vault 100% hit rate)

### Sprint Goal
Build the single-pass parallel orchestrator that coordinates identifier processing.

### Deliverables

#### D4.1: Implement Analyzer (IdentifierCollector + ContextExtractor)
**Description**: Parse code once, extract all identifiers with context.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/analyzer/analyzer.ts` implements AnalyzerInterface
- [ ] Parses JavaScript/TypeScript via Babel
- [ ] Extracts: identifier name, binding type, scope, references, importance score
- [ ] Context extraction: surrounding code window (configurable size)
- [ ] Output: `analysis.json` with all identifier metadata

**Technical Notes**:
```typescript
interface Identifier {
  id: string;              // Stable ID = binding + location
  name: string;            // Current name
  bindingType: 'var' | 'function' | 'class' | 'parameter' | 'import';
  scopeId: string;         // Parent scope identifier
  references: number;      // Reference count for importance
  context: string;         // Surrounding code snippet
}
```

#### D4.2: Implement Single-Pass Parallel Orchestrator
**Description**: Process all identifiers in parallel with rate limiting.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/orchestrator/pass-engine.ts` implements PassEngineInterface
- [ ] Parallel execution with configurable concurrency (default: 50)
- [ ] Rate limiting to avoid API throttling
- [ ] Progress tracking: identifiers processed, remaining, errors
- [ ] Uses Vault for caching, Ledger for event logging

**Technical Notes**:
- Reuses patterns from existing `parallel-utils.ts`
- Each identifier processed independently in parallel mode

#### D4.3: Implement Transformer (AST Rename Applicator)
**Description**: Apply rename map to AST and emit transformed code.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/transformer/transformer.ts` implements TransformerInterface
- [ ] Uses Babel's `scope.rename()` for safe renaming
- [ ] Handles naming collisions (prefix with `_`)
- [ ] Validates: `renamed_in_code == len(rename_map)`
- [ ] Emits snapshots to `snapshots/after-pass-N.js`

### Dependencies
- Sprint 2 (Vault) and Sprint 3 (Ledger) complete

### Risks
- **AST mutation bugs**: Extensive testing required
- **Lost renames**: Invariant checking critical (spec section 9)

---

## Sprint 5: Multi-Pass - N-Pass Orchestration
**Phase**: 2 (Multi-Pass & Context Flow)
**Blocking**: Sprint 6 (refinement needs N-pass support)

### Sprint Goal
Extend orchestrator to support multiple passes with snapshot handoff.

### Deliverables

#### D5.1: Implement N-Pass Orchestration
**Description**: Run N passes sequentially, each reading previous pass's output.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/orchestrator/multi-pass.ts` implements MultiPassInterface
- [ ] Each pass reads from `snapshots/after-pass-(N-1).js`
- [ ] Each pass writes to `snapshots/after-pass-N.js`
- [ ] Pass configuration: processor type, mode, concurrency
- [ ] Pre-computes total work: `totalIdentifiers * numPasses`

**Technical Notes**:
```typescript
interface PassConfig {
  processor: 'rename' | 'refine' | 'analyze' | 'transform';
  mode: 'parallel' | 'streaming' | 'sequential';
  concurrency: number;
  filter?: 'anchors' | 'low-confidence' | 'all';
  model?: string;
}
```

#### D5.2: Implement Glossary Injection
**Description**: Pass N prompts include Pass N-1 rename results as context.

**Acceptance Criteria**:
- [ ] Prompt template includes glossary section
- [ ] Glossary: mapping of identifiers renamed in previous pass
- [ ] Glossary size limited to prevent prompt bloat (max 100 entries)
- [ ] Priority: Include most-referenced identifiers first

**Technical Notes**:
```
Glossary from previous pass:
- a → config
- b → handler
- c → processData
...

Given this context, suggest a name for: {identifier}
```

#### D5.3: Multi-Pass Integration Tests
**Description**: End-to-end tests for 2-pass and 3-pass pipelines.

**Acceptance Criteria**:
- [ ] Test: 2-pass on tiny-qs produces valid output
- [ ] Test: Pass 2 sees all Pass 1 renames in glossary
- [ ] Test: Semantic score improves from pass 1 to pass 2
- [ ] Test: 3-pass reaches stability (>80% unchanged in pass 3)

### Dependencies
- Sprint 4 (single-pass orchestrator) complete

### Risks
- **Glossary bloat**: Limit size, prioritize by importance

---

## Sprint 6: Multi-Pass - Quality Validation
**Phase**: 2 (Multi-Pass & Context Flow)
**Gate**: Gate 3 (≥95% sequential quality), Gate 4 (5000 ids < 10 min)

### Sprint Goal
Validate that 2-pass parallel achieves target quality and speed.

### Deliverables

#### D6.1: Implement AnchorDetector (Importance Scoring)
**Description**: Identify high-importance identifiers for priority processing.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/analyzer/anchor-detector.ts` implements AnchorDetectorInterface
- [ ] Importance score: weighted combination of references, exports, scope size
- [ ] Threshold configurable (default: top 10-20% by score)
- [ ] Anchor list used for sequential processing in hybrid strategies

**Technical Notes**:
```typescript
interface AnchorDetector {
  detectAnchors(identifiers: Identifier[]): Identifier[];
  computeImportance(id: Identifier): number;
}

// Importance = 0.5 * log(references) + 0.3 * (isExport ? 1 : 0) + 0.2 * (scopeSize / maxScope)
```

#### D6.2: Run Quality Benchmarks
**Description**: Measure 2-pass parallel quality against sequential baseline.

**Acceptance Criteria**:
- [ ] 2-pass parallel semantic score measured on tiny-qs, small-axios, medium-chart
- [ ] Score ≥ 95% of sequential baseline (Gate 3)
- [ ] Time < 10 minutes for 5000 identifiers (Gate 4)
- [ ] Results documented with confidence intervals

**Technical Notes**:
- Run multiple trials (3-5) for statistical significance
- Track tokens consumed for cost analysis

#### D6.3: Quality Regression Detection
**Description**: Detect and handle cases where refinement makes things worse.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/quality/regression-detector.ts` implements RegressionDetectorInterface
- [ ] Regression defined: confidence[N] < confidence[N-1] * 0.9
- [ ] Policy: `keep-best` (default) or `keep-latest`
- [ ] Per-identifier history tracked across passes
- [ ] Warning emitted if regression rate > 10%

### Dependencies
- Sprint 5 (N-pass orchestration) complete

### Risks
- **Quality target miss**: May need additional passes or prompt tuning

---

## Sprint 7: Checkpointing - Mid-Pass Resume
**Phase**: 3 (Checkpointing & Resume)
**Blocking**: Sprint 8 (full resume needs mid-pass support)

### Sprint Goal
Implement mid-pass checkpointing to survive crashes without losing progress.

### Deliverables

#### D7.1: Implement Checkpoint Manager
**Description**: Periodic checkpoint writes during long-running passes.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/checkpoint/checkpoint-manager.ts` implements CheckpointManagerInterface
- [ ] Triggers: Every N identifiers (default: 100), every M seconds (default: 60)
- [ ] Checkpoint contains: completed IDs, pending queue, partial rename map, stats
- [ ] Storage: `passes/pass-NNN-progress.json`
- [ ] Atomic writes via temp-file + rename

**Technical Notes**:
```typescript
interface Checkpoint {
  passNumber: number;
  completedIds: string[];
  pendingIds: string[];
  renameMap: Record<string, string>;
  stats: { tokens: number; duration: number; errors: number };
  snapshotHash: string;
  timestamp: string;
}
```

#### D7.2: Implement Snapshot Manager
**Description**: Atomic snapshot writes with validation.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/checkpoint/snapshot-manager.ts` implements SnapshotManagerInterface
- [ ] Atomic writes: temp file → rename
- [ ] Validation: parse output to ensure valid JavaScript
- [ ] Hash computation for integrity checking
- [ ] Diff verification: changes match expected rename count

#### D7.3: Checkpoint Unit Tests
**Description**: Tests for checkpoint save/restore.

**Acceptance Criteria**:
- [ ] Test: Checkpoint saved after N identifiers
- [ ] Test: Checkpoint restored on resume
- [ ] Test: Partial progress not lost on crash
- [ ] Test: Atomic write survives process kill mid-write

### Dependencies
- Sprint 4 (orchestrator) complete

### Risks
- **I/O overhead**: Checkpointing adds latency; tune frequency

---

## Sprint 8: Checkpointing - Full Resume
**Phase**: 3 (Checkpointing & Resume)
**Gate**: Gate 1 (Resume mid-pass without losing progress)

### Sprint Goal
Implement full resume logic with config-diff handling and replay.

### Deliverables

#### D8.1: Implement Resume Logic
**Description**: Detect existing checkpoint and resume processing.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/checkpoint/resume-handler.ts` implements ResumeHandlerInterface
- [ ] Detection: Match by input hash
- [ ] Resume: Load snapshot, restore queue, continue from checkpoint
- [ ] Config diff: Prompt user for action (continue / replay from pass K / restart)
- [ ] Force flag: `--fresh` ignores existing checkpoint

**Technical Notes**:
```typescript
interface ResumeDecision {
  action: 'resume' | 'replay' | 'restart' | 'prompt-user';
  fromPass?: number;
  reason: string;
}
```

#### D8.2: Implement Replay Harness
**Description**: Deterministically regenerate state from ledger + snapshots.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/checkpoint/replay-harness.ts` implements ReplayHarnessInterface
- [ ] Given snapshot K and ledger events K+1..N, regenerate state N
- [ ] Useful for debugging and verification
- [ ] Can replay to any point in job history

#### D8.3: Graceful Shutdown Handler
**Description**: Save checkpoint on SIGINT/SIGTERM.

**Acceptance Criteria**:
- [ ] Process handlers for SIGINT, SIGTERM
- [ ] On signal: Save current progress, log message, exit cleanly
- [ ] Message: "Safe to exit. Resume with same command."
- [ ] No data loss on Ctrl+C

### Dependencies
- Sprint 7 (mid-pass checkpointing) complete

### Risks
- **Edge cases**: Many resume scenarios to test

---

## Sprint 9: UI & Observability
**Phase**: 4 (UI & Observability)

### Sprint Goal
Implement fixed-layout progress UI with global progress tracking.

### Deliverables

#### D9.1: Implement Progress Renderer
**Description**: Fixed-line colored progress display.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/ui/progress-renderer.ts` implements ProgressRendererInterface
- [ ] Fixed-width lines (no flicker, no overlap)
- [ ] Shows: global progress, pass progress, batch progress
- [ ] Color coding: iteration 1 (yellow), iteration 2+ (blue), errors (red)
- [ ] ETA calculation based on throughput

**Technical Notes**:
```
[turbo-v2] job-abc123 | input.js (5002 identifiers)

Iteration 1/1 | Global 45% [████████░░░░░░░░] ETA 12m
Pass 2/3 rename:parallel:50 | Batch 4/12 65% [██████░░░░]
Tokens: 123k | Errors: 0 | Checkpoint: 60s/100 ids
```

#### D9.2: Implement Pass Summaries
**Description**: Summary output after each pass completes.

**Acceptance Criteria**:
- [ ] Summary shows: identifiers processed/renamed/unchanged
- [ ] Token usage: prompt tokens, completion tokens, total
- [ ] Timing: duration, average ms/identifier
- [ ] Errors: count and types
- [ ] Snapshot path

#### D9.3: Implement Metrics Collection
**Description**: Track and export metrics for observability.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/metrics/metrics-collector.ts` implements MetricsCollectorInterface
- [ ] Metrics: timing, tokens, errors, hit rates
- [ ] Export to `logs/metrics.jsonl`
- [ ] Console output optionally disabled (--quiet)

### Dependencies
- Sprint 4 (orchestrator) complete

### Risks
- **Terminal compatibility**: Test on various terminals

---

## Sprint 10: CLI Integration
**Phase**: 5 (CLI Integration)

### Sprint Goal
Integrate turbo-v2 with existing CLI and add new commands.

### Deliverables

#### D10.1: Implement --turbo-v2 Flag
**Description**: Add turbo-v2 mode to unminify command.

**Acceptance Criteria**:
- [ ] `humanify unminify input.js --turbo-v2` uses new engine
- [ ] Default: 2-pass parallel pipeline
- [ ] Options: `--passes N`, `--pass "config"`, `--preset NAME`
- [ ] Backwards compatible: No `--turbo-v2` = existing behavior

**Technical Notes**:
- Integrate with existing Commander.js CLI
- Reuse existing file I/O patterns

#### D10.2: Implement Pass Argument Parsing
**Description**: Parse --pass arguments into PassConfig objects.

**Acceptance Criteria**:
- [ ] Syntax: `processor:mode:concurrency[:filter][:options]`
- [ ] Examples: `rename:parallel:50`, `refine:sequential:1:low-confidence`
- [ ] Multiple --pass flags supported
- [ ] Validation: Error on invalid syntax

#### D10.3: Implement Checkpoint Commands
**Description**: CLI commands for checkpoint management.

**Acceptance Criteria**:
- [ ] `humanify checkpoints list` - List all checkpoints
- [ ] `humanify checkpoints show JOB_ID` - Show checkpoint details
- [ ] `humanify checkpoints clear [--older-than 7d]` - Clear checkpoints
- [ ] `humanify checkpoints resume JOB_ID` - Resume specific job

### Dependencies
- Sprint 8 (resume logic) complete

### Risks
- **Breaking changes**: Ensure backward compatibility

---

## Sprint 11: Advanced Strategies - Presets
**Phase**: 6 (Advanced Strategies)

### Sprint Goal
Implement pipeline presets for common use cases.

### Deliverables

#### D11.1: Implement Preset System
**Description**: Named pipeline configurations for common use cases.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/presets/presets.ts` defines preset configurations
- [ ] Presets: `fast`, `balanced`, `quality`, `anchor`
- [ ] CLI: `--preset fast` expands to appropriate --pass flags
- [ ] Custom presets via config file (optional, defer to Sprint 12)

**Technical Notes**:
```typescript
const PRESETS: Record<string, PassConfig[]> = {
  fast: [
    { processor: 'rename', mode: 'parallel', concurrency: 50 },
    { processor: 'rename', mode: 'parallel', concurrency: 50 },
  ],
  balanced: [
    { processor: 'rename', mode: 'parallel', concurrency: 50 },
    { processor: 'refine', mode: 'parallel', concurrency: 50 },
  ],
  // ...
};
```

#### D11.2: Implement Vault Eviction
**Description**: Prevent unbounded vault growth.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/vault/eviction.ts` implements EvictionInterface
- [ ] LRU eviction when size exceeds threshold (default: 1GB)
- [ ] CLI option: `--vault-max-size N`
- [ ] Stats: vault size, entry count, eviction count

#### D11.3: Preset Documentation
**Description**: Document all presets with use case guidance.

**Acceptance Criteria**:
- [ ] Each preset documented in FINAL_PROJECT_SPEC.md
- [ ] Use case guidance: when to use each preset
- [ ] Performance expectations: quality/speed/cost tradeoffs
- [ ] Examples in CLI --help output

### Dependencies
- Sprint 10 (CLI integration) complete

### Risks
- **Preset tuning**: May need adjustment based on real-world usage

---

## Sprint 12: Advanced Strategies - Specialized Processors
**Phase**: 6 (Advanced Strategies)

### Sprint Goal
Implement advanced processors for specialized use cases.

### Deliverables

#### D12.1: Implement Anchor-First Hybrid Pipeline
**Description**: Sequential anchors, parallel bulk.

**Acceptance Criteria**:
- [ ] `anchor` preset implemented
- [ ] Pass 1: Detect anchors (top 10-20% by importance)
- [ ] Pass 2: Rename anchors sequentially (best context)
- [ ] Pass 3: Rename rest in parallel (with anchor glossary)
- [ ] Quality improvement measured vs 2-pass parallel

**Technical Notes**:
```
Pass 1: analyze (detect top 10-20% by importance)
Pass 2: rename:sequential (anchors only)
Pass 3: rename:parallel:50 (rest, with anchor glossary)
Pass 4: refine:parallel:50 (optional cleanup)
```

#### D12.2: Implement Conflict Detection
**Description**: Detect naming conflicts and inconsistencies.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/processors/conflict-detector.ts` implements ConflictDetectorInterface
- [ ] Detects: Same identifier renamed differently in different scopes
- [ ] Detects: Similar names for unrelated identifiers
- [ ] Flags conflicts for review or automatic resolution

#### D12.3: Implement Consistency Enforcement
**Description**: Apply naming consistency rules post-processing.

**Acceptance Criteria**:
- [ ] `src/turbo-v2/processors/consistency-enforcer.ts` implements ConsistencyEnforcerInterface
- [ ] Rules: Naming conventions (camelCase), prefix/suffix patterns
- [ ] Applies rules without LLM calls
- [ ] Configurable ruleset

### Dependencies
- Sprint 6 (AnchorDetector) complete

### Risks
- **Diminishing returns**: Advanced strategies may not justify complexity

---

## Summary

### Sprint Timeline

| Sprint | Phase | Focus | Key Deliverables | Gates |
|--------|-------|-------|------------------|-------|
| 1 | 0 | Validation | Hypothesis validation | - |
| 2 | 1 | Foundation | Vault implementation | - |
| 3 | 1 | Foundation | Ledger implementation | - |
| 4 | 1 | Foundation | Orchestrator, Transformer | Gate 2 |
| 5 | 2 | Multi-Pass | N-pass, Glossary | - |
| 6 | 2 | Multi-Pass | Quality validation | Gates 3, 4 |
| 7 | 3 | Checkpointing | Mid-pass checkpoints | - |
| 8 | 3 | Checkpointing | Full resume | Gate 1 |
| 9 | 4 | UI | Progress renderer | - |
| 10 | 5 | CLI | CLI integration | - |
| 11 | 6 | Advanced | Presets, Eviction | - |
| 12 | 6 | Advanced | Specialized processors | - |

### Critical Path

```
Sprint 1 (Validation)
    ↓
Sprint 2 (Vault) → Sprint 3 (Ledger)
    ↓                    ↓
Sprint 4 (Orchestrator) ←─┘
    ↓
Sprint 5 (N-Pass) → Sprint 6 (Quality) [Gates 3, 4]
    ↓
Sprint 7 (Mid-Pass) → Sprint 8 (Resume) [Gate 1]
    ↓
Sprint 9 (UI) → Sprint 10 (CLI) → Sprint 11-12 (Advanced)
```

### Risk Summary

| Risk | Sprint | Probability | Impact | Mitigation |
|------|--------|-------------|--------|------------|
| Hypothesis failure | 1 | 30% | Critical | Validate before implementation |
| Quality target miss | 6 | 20% | High | Additional passes, prompt tuning |
| Resume edge cases | 8 | 40% | Medium | Extensive testing |
| Performance issues | 6 | 30% | Medium | Profiling, optimization |

---

*This roadmap is a living document. Update as implementation progresses.*
