# Sprint Plan: Dynamic Mode Discovery for Scoring Infrastructure

**Generated**: 2025-12-31-002756
**Source**: STATUS-2025-12-31-002419.md
**Topic**: Scoring Infrastructure Refactor - Support 5-10+ Turbo Variations

---

## Executive Summary

**Current State**: Scoring infrastructure is well-structured but hardcoded for 4 modes (sequential, turbo, turbo-refine, turbo-v2). Adding new turbo-v2 preset variations requires manual updates to 3+ files.

**Goal**: Enable automatic discovery of 5-10+ turbo-v2 preset variations without updating scripts, recipes, or documentation.

**Solution**: Dynamic mode discovery via directory scanning, leveraging existing fallback logic (output.js → deobfuscated.js). This is the simplest approach that solves the immediate problem.

**Sprint Scope**: 2 deliverables focused on the highest-impact changes:
1. Dynamic mode discovery in scoring scripts
2. Central mode registry for documentation and extensibility

**Estimated Effort**: 4-5 hours total
**Risk Level**: Low (backward compatible, no architectural changes)

---

## Total Gap Analysis

### Architecture Components ✅
- Core scoring infrastructure exists and works
- Parallel batch scoring operational
- LLM-as-judge scoring functional
- Test samples well-structured

### Missing Capabilities
1. **Dynamic Mode Discovery** — Scripts hardcode mode lists (3 locations)
2. **Mode Registry** — No central source of truth for mode configuration
3. **Preset Integration** — turbo-v2 presets not mapped to output directories

### Existing Workarounds ✅
- Output filename fallback (output.js → deobfuscated.js) already implemented
- Generic justfile recipe (`just score <sample> <mode>`) already exists
- Scoring logic is mode-agnostic (works with any output directory)

---

## Prioritized Backlog

---

## [P0] Dynamic Mode Discovery

**Status**: Not Started
**Effort**: Small (1-2 hours)
**Dependencies**: None
**Spec Reference**: STATUS-2025-12-31-002419.md §3.1 (Change 1: Mode Discovery via Output Directories)

### Description

Replace hardcoded mode lists in scoring scripts with dynamic directory scanning. This eliminates the need to update scripts when adding new turbo-v2 preset variations.

**Current Problem**:
- `run-semantic-scoring-all.sh` line 64: `for mode in sequential turbo turbo-refine turbo-v2; do`
- `score-sample.sh` line 15: Documentation lists 4 hardcoded modes
- Adding new mode requires editing 3+ files

**Solution**:
Discover modes by scanning `test-samples/canonical/{sample}/output-*` directories:
```bash
# Replace hardcoded list with directory scan
for mode in $(ls -1 "test-samples/canonical/tiny-qs" | grep '^output-' | sed 's/^output-//'); do
```

**Why It Works**:
- Existing fallback logic handles both `output.js` (V2) and `deobfuscated.js` (V1)
- Scripts already skip missing output directories gracefully
- All samples have consistent mode coverage (validated assumption)
- Zero maintenance — adding mode is just creating output directory

### Acceptance Criteria

- [ ] `run-semantic-scoring-all.sh` discovers modes dynamically via directory scan
- [ ] Script runs successfully with existing 4 modes (sequential, turbo, turbo-refine, turbo-v2)
- [ ] Script automatically discovers new modes when output directories are added
- [ ] No hardcoded mode list in scoring scripts (except documentation examples)
- [ ] Backward compatibility: existing workflows and justfile recipes unchanged
- [ ] Script handles missing mode directories gracefully (logs skip message, continues)
- [ ] Unit test: Verify mode discovery with mock directory structure

### Technical Notes

**Files to Modify**:
1. `scripts/run-semantic-scoring-all.sh` (line 64) — Replace hardcoded loop
2. `scripts/score-sample.sh` (line 15) — Update documentation to say "auto-discovered"

**Implementation Pattern**:
```bash
# Discover modes from any sample (use first found)
SAMPLE_FOR_DISCOVERY="tiny-qs"
DISCOVERED_MODES=$(ls -1 "test-samples/canonical/$SAMPLE_FOR_DISCOVERY" 2>/dev/null | grep '^output-' | sed 's/^output-//' || echo "")

if [ -z "$DISCOVERED_MODES" ]; then
  echo "ERROR: No output directories found in test-samples/canonical/$SAMPLE_FOR_DISCOVERY"
  exit 1
fi

for mode in $DISCOVERED_MODES; do
  # existing scoring logic
done
```

**Edge Cases**:
- Sample has no output directories: Fail with clear error
- Samples have different modes: Current assumption (all match) holds, document in STATUS
- Invalid directory name: Grep pattern filters to `output-*`, safe

**Testing**:
1. Run with existing 4 modes → verify same output as before
2. Create `test-samples/canonical/tiny-qs/output-turbo-v2-balanced/` → verify auto-discovery
3. Delete one mode from one sample → verify graceful skip

---

## [P1] Mode Configuration Registry

**Status**: Not Started
**Effort**: Medium (3-4 hours)
**Dependencies**: None (independent of P0, but complements it)
**Spec Reference**: STATUS-2025-12-31-002419.md §3.2 (Change 2: Mode Configuration Registry)

### Description

Create a central configuration file that maps mode names to execution commands, descriptions, and defaults. This provides a single source of truth for mode metadata and enables programmatic mode discovery.

**Current Problem**:
- Mode configuration scattered across scripts, justfile, and presets.ts
- No way to programmatically query: "What modes exist? How do I run mode X?"
- Future turbo-v2 presets require manual recipe creation

**Solution**:
Create `scripts/mode-registry.json` with mode definitions:
- 4 existing modes (sequential, turbo, turbo-refine, turbo-v2)
- 4 new turbo-v2 preset modes (balanced, quality, anchor, thorough)

Add helper scripts:
- `scripts/list-modes.sh` — List all modes with descriptions
- `scripts/run-mode.sh <sample> <mode>` — Generic mode runner from registry

### Acceptance Criteria

- [ ] `scripts/mode-registry.json` exists with 8 mode definitions (4 current + 4 turbo-v2 presets)
- [ ] Each mode entry includes: command template, description, default parameters
- [ ] `scripts/list-modes.sh` outputs all modes with descriptions and pass counts
- [ ] `scripts/run-mode.sh <sample> <mode>` executes mode from registry (with parameter substitution)
- [ ] Registry validates on load (schema check, no duplicate mode names)
- [ ] Mode naming convention: `turbo-v2-{preset}` for new presets (e.g., `turbo-v2-balanced`)
- [ ] Documentation: Add `scripts/README.md` explaining registry usage and mode addition workflow
- [ ] Unit test: Validate registry JSON schema and command template syntax

### Technical Notes

**Registry Schema**:
```json
{
  "modes": {
    "sequential": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking -o {{output}} {{input}}",
      "description": "Sequential baseline (no turbo)",
      "defaults": {},
      "passes": 1
    },
    "turbo-v2-balanced": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo-v2 --preset balanced -o {{output}} {{input}}",
      "description": "V2 with balanced preset (rename + refine)",
      "defaults": { "preset": "balanced" },
      "passes": 2
    }
  }
}
```

**Template Variables**:
- `{{input}}` — Path to minified.js
- `{{output}}` — Path to output directory (output.js)
- `{{concurrency}}` — Concurrency level (default from mode.defaults)
- `{{preset}}` — Preset name for turbo-v2

**Helper Script Behavior**:
- `list-modes.sh` — Pretty-print table (mode, description, passes, concurrency)
- `run-mode.sh` — Load registry, substitute variables, execute command

**Integration Points**:
- Scoring scripts (P0) use directory scanning (independent)
- Justfile can optionally reference registry for documentation
- Future enhancement: Auto-generate justfile recipes from registry (deferred to P3)

**Mode Naming Convention** (resolves STATUS Ambiguity #1):
- Use `turbo-v2-{preset}` for all turbo-v2 preset variations
- Rationale: Clear hierarchy, grep-friendly, avoids collisions
- Examples: `turbo-v2-balanced`, `turbo-v2-quality`, `turbo-v2-anchor`, `turbo-v2-thorough`

**Registry Ownership** (resolves STATUS Ambiguity #2):
- Manual registry (Option A from STATUS)
- Rationale: Explicit, version-controlled, can document non-preset modes
- Trade-off: Manual sync with presets.ts (acceptable for 8 modes)

**Testing**:
1. Validate JSON schema
2. Test command template substitution
3. Run `list-modes.sh` → verify output format
4. Run `run-mode.sh tiny-qs turbo-v2-balanced` → verify execution

---

## [P2] Justfile Integration (Optional)

**Status**: Deferred
**Effort**: Medium (2-3 hours)
**Dependencies**: P1 (Mode Registry)
**Spec Reference**: STATUS-2025-12-31-002419.md §4.3 (Phase 3: Justfile Integration)

### Description

Generate justfile scoring recipes from mode registry to maintain tab-completion convenience while supporting 8+ modes.

**Current State**: 15 hardcoded scoring recipes × 4 modes = 60 recipes total

**Proposed**: Generate recipes from `mode-registry.json`

**Decision** (resolves STATUS Ambiguity #3):
- **Defer to future sprint**
- Rationale: P0 + P1 solve the core problem (5-10 modes without script edits)
- Generic recipe `just score <sample> <mode>` already works
- Tab-completion is nice-to-have, not critical for 8 modes

### Acceptance Criteria

- [ ] DEFERRED — Not in this sprint scope

### Technical Notes

If implemented in future sprint:
- Generate `justfile.generated` from registry
- Include in main `justfile` with `include justfile.generated`
- Regenerate via `npm run generate-justfile` (pre-commit hook)

---

## Dependency Graph

```
P0: Dynamic Mode Discovery
  ├─ No dependencies
  └─ Enables: Auto-discovery of new modes

P1: Mode Registry
  ├─ No dependencies (independent)
  └─ Enables: Programmatic mode queries, future automation

P2: Justfile Integration (DEFERRED)
  ├─ Depends on: P1 (Mode Registry)
  └─ Enables: Auto-generated recipes
```

**Critical Path**: P0 → Test → P1 → Test

---

## Sprint Scope Summary

### In Scope (This Sprint)
1. **P0: Dynamic Mode Discovery** — Replace hardcoded mode lists (1-2 hours)
2. **P1: Mode Registry** — Central configuration with 8 modes (3-4 hours)

**Total Effort**: 4-6 hours
**Deliverables**: 2 (highest impact)

### Deferred (Future Sprints)
- P2: Justfile recipe generation
- Auto-sync registry with presets.ts
- Advanced mode parameterization (e.g., per-mode concurrency)

### Out of Scope
- Changes to core scoring logic (`score-semantic.ts`)
- Changes to turbo-v2 implementation
- Changes to sample directory structure
- Backward-incompatible changes to justfile

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Mode naming collision | Low | Medium | Enforce `turbo-v2-*` prefix for presets |
| Missing mode directory | Medium | Low | Already handled by fallback logic (score-sample.sh:38) |
| Output filename mismatch | Low | Low | Already handled by fallback (score-sample.sh:24-27) |
| Registry/presets.ts drift | Medium | Medium | Document sync process, add validation test |
| Samples have different modes | Low | Medium | Validate assumption, document in STATUS |

**Overall Risk**: Low — All changes are isolated, backward compatible, with existing safeguards.

---

## Recommended Sprint Execution

### Day 1: Dynamic Mode Discovery (2 hours)
1. Implement directory scanning in `run-semantic-scoring-all.sh`
2. Update documentation in `score-sample.sh`
3. Test with existing 4 modes
4. Test with mock new mode (create empty output directory)

### Day 2: Mode Registry (3-4 hours)
1. Create `scripts/mode-registry.json` with 8 modes
2. Implement `scripts/list-modes.sh`
3. Implement `scripts/run-mode.sh`
4. Add validation script (`scripts/validate-registry.sh`)
5. Document mode addition workflow in `scripts/README.md`
6. Test all 8 modes via registry

### Day 3: Integration Testing (1 hour)
1. Run full scoring suite with discovery + registry
2. Validate backward compatibility (existing workflows unchanged)
3. Create `output-turbo-v2-balanced/` for one sample → verify auto-discovery
4. Update `.agent_planning/scoring-refactor/STATUS-*.md` with results

---

## Success Metrics

### Functional Requirements
- [ ] Adding new mode requires ZERO script edits (only output directory creation)
- [ ] All 8 modes discoverable and executable
- [ ] Existing workflows unchanged

### Quality Metrics
- [ ] 100% backward compatibility (existing tests pass)
- [ ] Zero manual mode list maintenance
- [ ] Clear documentation for adding new modes

### Performance
- [ ] No performance regression in scoring scripts
- [ ] Mode discovery adds <100ms to script startup

---

## Blockers and Questions

**None identified**. All dependencies exist, STATUS is authoritative, implementation path is clear.

**Ambiguity Resolutions**:
- Mode naming: `turbo-v2-{preset}` (STATUS Question 1)
- Registry ownership: Manual registry (STATUS Question 2)
- Justfile generation: Deferred (STATUS Question 3)

---

## Next Steps After Sprint

1. Run full scoring suite on all 8 modes (including 4 new turbo-v2 presets)
2. Compare quality metrics (sequential baseline vs. turbo-v2-balanced/quality/anchor/thorough)
3. Update `VALIDATION-RESULTS.md` with multi-preset comparison
4. Decide if justfile generation (P2) is worth the complexity
5. Document findings in STATUS for future sprints

---

## Appendix: File Modifications

### Modified Files
1. `scripts/run-semantic-scoring-all.sh` — Dynamic mode discovery (line 64)
2. `scripts/score-sample.sh` — Documentation update (line 15)

### New Files
1. `scripts/mode-registry.json` — Mode configuration
2. `scripts/list-modes.sh` — Mode listing helper
3. `scripts/run-mode.sh` — Generic mode runner
4. `scripts/validate-registry.sh` — Registry schema validation
5. `scripts/README.md` — Mode addition workflow documentation

### Untouched (Backward Compatibility)
- `scripts/score-semantic.ts` — Core scoring logic
- `justfile` — Existing recipes work as-is
- Test samples directory structure
- Turbo-v2 implementation (`src/turbo-v2/`)

---

**Total Work Items**: 2 (P0, P1)
**Total Effort**: 4-6 hours
**Risk Level**: Low
**Backward Compatible**: Yes
**Ready for Implementation**: Yes ✅
