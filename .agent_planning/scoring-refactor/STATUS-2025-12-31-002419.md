# Status Report - 2025-12-31-002419
Scope: project/full (Scoring Infrastructure Refactor)
Confidence: FRESH

## Executive Summary
Overall: 90% discoverable | Critical gaps: 2 | Architecture: Clear
The scoring infrastructure is well-structured but hardcoded for 4 modes. Refactoring to support 5-10+ turbo-v2 variations (presets) is straightforward with 2 key changes: dynamic mode discovery and mode configuration registry.

## What Exists and Works

### Core Scoring Infrastructure ✅

**Files**:
- `scripts/score-semantic.ts` - Core LLM-as-judge scoring (GPT-4o)
- `scripts/score-sample.sh` - Single sample+mode wrapper
- `scripts/run-semantic-scoring-all.sh` - Parallel batch scoring

**Current Modes** (hardcoded):
1. `sequential` - No turbo, baseline quality
2. `turbo` - V1 turbo with dependency graph
3. `turbo-refine` - V1 turbo + 2nd refinement pass
4. `turbo-v2` - V2 multi-pass orchestrator (NEW)

**Test Samples**:
- `tiny-qs` - 150 identifiers, 356 lines
- `small-axios` - 800 identifiers, 3K lines
- `medium-chart` - 5000 identifiers, 11K lines

**Output Structure**:
```
test-samples/canonical/{sample}/
  minified.js              # Input
  original.js              # Ground truth
  output-{mode}/
    output.js              # V2 output (NEW naming)
    deobfuscated.js        # V1 output (LEGACY naming)
    semantic-score.json    # LLM scoring results
```

**Scoring Flow**:
1. Extract identifiers from original and unminified code (Babel AST)
2. Sample to max 200 identifiers if needed (deterministic)
3. Call GPT-4o with LLM-as-judge prompt
4. Return score (0-100), explanation, tokens, cost

**Justfile Recipes** (276 lines):
- 15 scoring recipes: `score-{sample}-{mode}` (e.g., `score-tiny-qs-turbo`)
- Generic recipes: `score <sample> <mode>`, `score-all`
- 18 run recipes: `run-{sample}-{mode}` for processing samples

**Evidence**: All files exist, 11 semantic-score.json files found, scripts execute successfully.

---

## What's Missing for Dynamic Mode Support

### Critical Gap 1: Hardcoded Mode Lists

**Location**: `scripts/run-semantic-scoring-all.sh:64`
```bash
for mode in sequential turbo turbo-refine turbo-v2; do
```

**Problem**: Adding a new mode (e.g., `turbo-v2-balanced`, `turbo-v2-quality`) requires editing 3 files:
- `run-semantic-scoring-all.sh` (mode list)
- `justfile` (scoring recipes)
- `score-sample.sh` (documentation)

**Impact**: Manual, error-prone updates for each new variation.

---

### Critical Gap 2: No Mode Configuration Registry

**Current State**: Mode configuration scattered across:
- `scripts/run-turbo-v2.sh` - knows about presets
- `src/turbo-v2/cli/presets.ts` - defines presets (fast, balanced, quality, anchor, thorough)
- `justfile` - hardcoded mode names

**Problem**: No single source of truth for:
- What modes exist?
- How to run each mode?
- What presets map to what modes?

**Example Confusion**:
- Preset `fast` → mode `turbo-v2` (default)
- Preset `balanced` → mode `turbo-v2-balanced`? (DOESN'T EXIST)
- Preset `quality` → mode `turbo-v2-quality`? (DOESN'T EXIST)

**Impact**: No way to discover modes programmatically.

---

## What Needs to Change

### Change 1: Mode Discovery via Output Directories

**Approach**: Discover modes dynamically by scanning output directories instead of hardcoding lists.

**Implementation**:
```bash
# In run-semantic-scoring-all.sh (line 64)
# OLD:
for mode in sequential turbo turbo-refine turbo-v2; do

# NEW:
for mode in $(ls -1 "test-samples/canonical/tiny-qs" | grep '^output-' | sed 's/^output-//'); do
```

**Benefits**:
- Zero maintenance - adding new mode is just creating `output-{mode}/` directory
- Works for any number of modes (5, 10, 50)
- Self-documenting - mode exists if output exists

**Risks**:
- Assumes all samples have same modes (current assumption holds)
- Fails gracefully if mode directory missing (already handled in `score-sample.sh:38`)

---

### Change 2: Mode Configuration Registry

**Approach**: Create a central configuration file that maps modes to execution commands.

**New File**: `scripts/mode-registry.json`
```json
{
  "modes": {
    "sequential": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking -o {{output}} {{input}}",
      "description": "Sequential baseline (no turbo)"
    },
    "turbo": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo --max-concurrent {{concurrency}} -o {{output}} {{input}}",
      "description": "V1 turbo with dependency graph",
      "defaults": { "concurrency": 10 }
    },
    "turbo-refine": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo --refine --max-concurrent {{concurrency}} -o {{output}} {{input}}",
      "description": "V1 turbo + refinement",
      "defaults": { "concurrency": 10 }
    },
    "turbo-v2": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo-v2 --preset {{preset}} -o {{output}} {{input}}",
      "description": "V2 multi-pass orchestrator",
      "defaults": { "preset": "fast" }
    },
    "turbo-v2-balanced": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo-v2 --preset balanced -o {{output}} {{input}}",
      "description": "V2 with balanced preset (rename + refine)"
    },
    "turbo-v2-quality": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo-v2 --preset quality -o {{output}} {{input}}",
      "description": "V2 with quality preset (5 passes)"
    },
    "turbo-v2-anchor": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo-v2 --preset anchor -o {{output}} {{input}}",
      "description": "V2 with anchor-first hybrid"
    },
    "turbo-v2-thorough": {
      "command": "node dist/index.mjs unminify --provider openai --no-chunking --turbo-v2 --preset thorough -o {{output}} {{input}}",
      "description": "V2 with thorough preset (3 passes)"
    }
  }
}
```

**Usage**:
- `scripts/list-modes.sh` - List all available modes
- `scripts/run-mode.sh <sample> <mode>` - Run any mode from registry
- `just run-all-modes <sample>` - Run all modes on sample

**Benefits**:
- Single source of truth for mode configuration
- Easy to add new preset variations
- Self-documenting via descriptions
- Supports parameterized commands

**Optional Enhancement**: Generate justfile recipes from registry (avoid duplication).

---

### Change 3: Output Filename Normalization

**Problem**: V1 outputs `deobfuscated.js`, V2 outputs `output.js`.

**Current Workaround** (`score-sample.sh:24-27`):
```bash
UNMINIFIED="$OUTPUT_DIR/output.js"
if [ ! -f "$UNMINIFIED" ]; then
  UNMINIFIED="$OUTPUT_DIR/deobfuscated.js"
fi
```

**Options**:
1. **Keep workaround** (RECOMMENDED) - Already works, no breaking changes
2. **Standardize on `output.js`** - Rename V1 output (breaking change)
3. **Symlink legacy name** - Create `output.js → deobfuscated.js` in V1 modes

**Recommendation**: Keep current workaround. It's 4 lines, handles both cases, no migration needed.

---

## Implementation Recommendations

### Phase 1: Mode Discovery (Low Risk)
- [x] Mode list hardcoded in 3 places
- [ ] Replace with `ls -1 ... | grep '^output-'` pattern
- [ ] Test with existing 4 modes
- [ ] Verify `score-all` works with dynamic discovery

**Estimated Effort**: 1 hour
**Risk**: Low (discovery matches current behavior)

---

### Phase 2: Mode Registry (Medium Risk)
- [ ] Create `scripts/mode-registry.json`
- [ ] Populate with 8 modes (4 existing + 4 new turbo-v2 presets)
- [ ] Create `scripts/list-modes.sh` helper
- [ ] Create `scripts/run-mode.sh <sample> <mode>` generic runner
- [ ] Add `just list-modes` recipe
- [ ] Add `just run-all-modes <sample>` recipe

**Estimated Effort**: 3 hours
**Risk**: Medium (new infrastructure, existing scripts still work)

---

### Phase 3: Justfile Integration (Optional)
- [ ] Generate justfile scoring recipes from registry
- [ ] Replace hardcoded recipes with generated ones
- [ ] Keep backward compatibility (same recipe names)

**Estimated Effort**: 2 hours
**Risk**: Low (justfile can include generated file)

**Deferred**: Not strictly necessary - mode discovery + registry solve the core problem.

---

## Dependencies and Risks

### Dependencies ✅
- **None** - All changes are isolated to scripts/ directory
- No changes to core scoring logic (`score-semantic.ts`)
- No changes to turbo-v2 implementation
- No changes to sample structure

### Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Missing mode directories | Scoring fails for that mode | Already handled: `score-sample.sh:38` checks file existence |
| Output filename mismatch | Can't find output file | Already handled: `score-sample.sh:24-27` checks both names |
| Mode naming collisions | Registry conflicts | Validate registry on load, enforce kebab-case |
| Existing scripts break | CI failures | Keep existing scripts as-is, add new ones |

### Backward Compatibility ✅
- Existing scripts continue to work
- Justfile recipes unchanged (optional phase 3)
- Sample directory structure unchanged
- Scoring format unchanged

---

## Ambiguities Found

### Question 1: Mode Naming Convention
**Context**: How should turbo-v2 preset variations be named as modes?
**Options**:
- Option A: `turbo-v2-{preset}` (e.g., `turbo-v2-balanced`, `turbo-v2-quality`)
  - **Pro**: Clear hierarchy, preset name obvious
  - **Pro**: Grep-friendly (`turbo-v2-*`)
  - **Con**: Longer names
- Option B: `{preset}` (e.g., `balanced`, `quality`)
  - **Pro**: Shorter, cleaner
  - **Con**: Loses context (is this V1 or V2?)
  - **Con**: Potential collision with future V1 modes
- Option C: `v2-{preset}` (e.g., `v2-balanced`, `v2-quality`)
  - **Pro**: Shorter than A, clearer than B
  - **Con**: Less descriptive

**Current assumption**: Option A (`turbo-v2-{preset}`) for clarity.
**Impact of wrong choice**: Inconsistent naming, harder to filter/group modes.

---

### Question 2: Mode Registry Ownership
**Context**: Who maintains the mode registry - developers or scripts?
**Options**:
- Option A: **Manual registry** (`mode-registry.json`)
  - **Pro**: Explicit, version-controlled, reviewable
  - **Pro**: Can document each mode
  - **Con**: Manual sync with presets.ts
- Option B: **Auto-generate from presets.ts**
  - **Pro**: Single source of truth (presets.ts)
  - **Pro**: No sync issues
  - **Con**: Loses flexibility (can't document non-preset modes like `sequential`)
- Option C: **Hybrid** - generate turbo-v2 modes, manual for others
  - **Pro**: Best of both
  - **Con**: Complexity

**Current assumption**: Option A (manual registry) for simplicity and flexibility.
**Impact of wrong choice**: Maintenance burden (A) vs. loss of documentation (B).

---

### Question 3: Should We Generate Justfile Recipes?
**Context**: 15 hardcoded scoring recipes vs. 8+ new modes.
**Options**:
- Option A: **Keep hardcoded recipes**
  - **Pro**: No change, works today
  - **Con**: 15 recipes × 8 modes = 120 recipes (unwieldy)
- Option B: **Generate from registry**
  - **Pro**: Scales to any number of modes
  - **Pro**: Single source of truth
  - **Con**: Justfile includes generated file (unconventional)
- Option C: **Generic recipes only**
  - **Pro**: Simple (`just score <sample> <mode>`)
  - **Con**: Loses tab-completion convenience

**Current assumption**: Option C (generic recipes) - simpler, scales well, good UX.
**Impact of wrong choice**: Developer friction if recipes are awkward to use.

---

## Recommendations

### 1. Immediate (Phase 1)
**Implement dynamic mode discovery** in `run-semantic-scoring-all.sh`:
- Replace hardcoded mode list with directory scan
- Test with existing 4 modes
- Verify backward compatibility

**Why**: Low risk, immediate value, enables adding modes without script edits.

---

### 2. Short-term (Phase 2)
**Create mode registry**:
- Add `scripts/mode-registry.json` with 8 modes (4 current + 4 turbo-v2 presets)
- Add `scripts/list-modes.sh` helper
- Add `just list-modes` recipe

**Why**: Central configuration, enables programmatic mode discovery, supports future automation.

---

### 3. Optional (Phase 3)
**Evaluate justfile generation**:
- After validating registry, decide if generated recipes add value
- If yes: implement `scripts/generate-justfile-recipes.sh`
- If no: keep generic recipes (`just score <sample> <mode>`)

**Why**: Justfile generation is a nice-to-have, not critical for 5-10 modes.

---

## Verdict

- [x] **CONTINUE** - Issues are clear, implementer can proceed

**Rationale**:
1. Core infrastructure exists and works
2. Changes are isolated, low-risk, backward-compatible
3. Clear implementation path (3 phases, 6 hours total)
4. Ambiguities are minor (naming conventions, not requirements)
5. No external dependencies or architectural changes needed

**Next Steps**:
1. Implement Phase 1 (mode discovery)
2. Create mode registry with 8 initial modes
3. Test scoring workflow with new turbo-v2 presets
4. Document mode addition workflow for future developers
