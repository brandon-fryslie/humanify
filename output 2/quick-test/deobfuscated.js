/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
(function (e, t) {
  if (typeof exports == "object" && typeof module != "undefined") {
    t(exports);
  } else if (typeof define == "function" && define.amd) {
    define(["exports"], t);
  } else {
    t((e = typeof globalThis != "undefined" ? globalThis : e || self).tf = e.tf || {});
  }
})(this, function (e) {
  "use strict";

  function t(e, t) {
    t.forEach(function (t) {
      if (t && typeof t != "string" && !Array.isArray(t)) {
        Object.keys(t).forEach(function (n) {
          if (n !== "default" && !(n in e)) {
            var r = Object.getOwnPropertyDescriptor(t, n);
            Object.defineProperty(e, n, r.get ? r : {
              enumerable: true,
              get: function () {
                return t[n];
              }
            });
          }
        });
      }
    });
    return e;
  }
  var n = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function r(e) {
    if (e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")) {
      return e.default;
    } else {
      return e;
    }
  }
  function a(e) {
    var t;
    var n;
    function r(t, n) {
      try {
        var o = e[t](n);
        var s = o.value;
        var u = s instanceof i;
        Promise.resolve(u ? s.v : s).then(function (n) {
          if (u) {
            var i = t === "return" ? "return" : "next";
            if (!s.k || n.done) {
              return r(i, n);
            }
            n = e[i](n).value;
          }
          a(o.done ? "return" : "normal", n);
        }, function (e) {
          r("throw", e);
        });
      } catch (e) {
        a("throw", e);
      }
    }
    function a(e, a) {
      switch (e) {
        case "return":
          t.resolve({
            value: a,
            done: true
          });
          break;
        case "throw":
          t.reject(a);
          break;
        default:
          t.resolve({
            value: a,
            done: false
          });
      }
      if (t = t.next) {
        r(t.key, t.arg);
      } else {
        n = null;
      }
    }
    this._invoke = function (e, a) {
      return new Promise(function (i, o) {
        var s = {
          key: e,
          arg: a,
          resolve: i,
          reject: o,
          next: null
        };
        if (n) {
          n = n.next = s;
        } else {
          t = n = s;
          r(e, a);
        }
      });
    };
    if (typeof e.return != "function") {
      this.return = undefined;
    }
  }
  function i(e, t) {
    this.v = e;
    this.k = t;
  }
  function o() {
    o = function () {
      return e;
    };
    var e = {};
    var t = Object.prototype;
    var n = t.hasOwnProperty;
    var r = Object.defineProperty || function (e, t, n) {
      e[t] = n.value;
    };
    var a = typeof Symbol == "function" ? Symbol : {};
    var i = a.iterator || "@@iterator";
    var s = a.asyncIterator || "@@asyncIterator";
    var u = a.toStringTag || "@@toStringTag";
    function c(e, t, n) {
      Object.defineProperty(e, t, {
        value: n,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return e[t];
    }
    try {
      c({}, "");
    } catch (e) {
      c = function (e, t, n) {
        return e[t] = n;
      };
    }
    function l(e, t, n, a) {
      var i = t && t.prototype instanceof f ? t : f;
      var o = Object.create(i.prototype);
      var s = new T(a || []);
      r(o, "_invoke", {
        value: w(e, n, s)
      });
      return o;
    }
    function h(e, t, n) {
      try {
        return {
          type: "normal",
          arg: e.call(t, n)
        };
      } catch (e) {
        return {
          type: "throw",
          arg: e
        };
      }
    }
    e.wrap = l;
    var p = {};
    function f() {}
    function d() {}
    function v() {}
    var m = {};
    c(m, i, function () {
      return this;
    });
    var g = Object.getPrototypeOf;
    var y = g && g(g(E([])));
    if (y && y !== t && n.call(y, i)) {
      m = y;
    }
    var b = v.prototype = f.prototype = Object.create(m);
    function x(e) {
      ["next", "throw", "return"].forEach(function (t) {
        c(e, t, function (e) {
          return this._invoke(t, e);
        });
      });
    }
    function k(e, t) {
      function a(r, i, o, s) {
        var u = h(e[r], e, i);
        if (u.type !== "throw") {
          var c = u.arg;
          var l = c.value;
          if (l && typeof l == "object" && n.call(l, "__await")) {
            return t.resolve(l.__await).then(function (e) {
              a("next", e, o, s);
            }, function (e) {
              a("throw", e, o, s);
            });
          } else {
            return t.resolve(l).then(function (e) {
              c.value = e;
              o(c);
            }, function (e) {
              return a("throw", e, o, s);
            });
          }
        }
        s(u.arg);
      }
      var i;
      r(this, "_invoke", {
        value: function (e, n) {
          function r() {
            return new t(function (t, r) {
              a(e, n, t, r);
            });
          }
          return i = i ? i.then(r, r) : r();
        }
      });
    }
    function w(e, t, n) {
      var r = "suspendedStart";
      return function (a, i) {
        if (r === "executing") {
          throw new Error("Generator is already running");
        }
        if (r === "completed") {
          if (a === "throw") {
            throw i;
          }
          return C();
        }
        n.method = a;
        n.arg = i;
        while (true) {
          var o = n.delegate;
          if (o) {
            var s = I(o, n);
            if (s) {
              if (s === p) {
                continue;
              }
              return s;
            }
          }
          if (n.method === "next") {
            n.sent = n._sent = n.arg;
          } else if (n.method === "throw") {
            if (r === "suspendedStart") {
              r = "completed";
              throw n.arg;
            }
            n.dispatchException(n.arg);
          } else if (n.method === "return") {
            n.abrupt("return", n.arg);
          }
          r = "executing";
          var u = h(e, t, n);
          if (u.type === "normal") {
            r = n.done ? "completed" : "suspendedYield";
            if (u.arg === p) {
              continue;
            }
            return {
              value: u.arg,
              done: n.done
            };
          }
          if (u.type === "throw") {
            r = "completed";
            n.method = "throw";
            n.arg = u.arg;
          }
        }
      };
    }
    function I(e, t) {
      var n = t.method;
      var r = e.iterator[n];
      if (r === undefined) {
        t.delegate = null;
        if (n !== "throw" || !e.iterator.return || !(t.method = "return", t.arg = undefined, I(e, t), t.method === "throw")) {
          if (n !== "return") {
            t.method = "throw";
            t.arg = new TypeError("The iterator does not provide a '" + n + "' method");
          }
        }
        return p;
      }
      var a = h(r, e.iterator, t.arg);
      if (a.type === "throw") {
        t.method = "throw";
        t.arg = a.arg;
        t.delegate = null;
        return p;
      }
      var i = a.arg;
      if (i) {
        if (i.done) {
          t[e.resultName] = i.value;
          t.next = e.nextLoc;
          if (t.method !== "return") {
            t.method = "next";
            t.arg = undefined;
          }
          t.delegate = null;
          return p;
        } else {
          return i;
        }
      } else {
        t.method = "throw";
        t.arg = new TypeError("iterator result is not an object");
        t.delegate = null;
        return p;
      }
    }
    function N(e) {
      var t = {
        tryLoc: e[0]
      };
      if (1 in e) {
        t.catchLoc = e[1];
      }
      if (2 in e) {
        t.finallyLoc = e[2];
        t.afterLoc = e[3];
      }
      this.tryEntries.push(t);
    }
    function S(e) {
      var t = e.completion || {};
      t.type = "normal";
      delete t.arg;
      e.completion = t;
    }
    function T(e) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      e.forEach(N, this);
      this.reset(true);
    }
    function E(e) {
      if (e) {
        var t = e[i];
        if (t) {
          return t.call(e);
        }
        if (typeof e.next == "function") {
          return e;
        }
        if (!isNaN(e.length)) {
          var r = -1;
          var a = function t() {
            while (++r < e.length) {
              if (n.call(e, r)) {
                t.value = e[r];
                t.done = false;
                return t;
              }
            }
            t.value = undefined;
            t.done = true;
            return t;
          };
          return a.next = a;
        }
      }
      return {
        next: C
      };
    }
    function C() {
      return {
        value: undefined,
        done: true
      };
    }
    d.prototype = v;
    r(b, "constructor", {
      value: v,
      configurable: true
    });
    r(v, "constructor", {
      value: d,
      configurable: true
    });
    d.displayName = c(v, u, "GeneratorFunction");
    e.isGeneratorFunction = function (e) {
      var t = typeof e == "function" && e.constructor;
      return !!t && (t === d || (t.displayName || t.name) === "GeneratorFunction");
    };
    e.mark = function (e) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(e, v);
      } else {
        e.__proto__ = v;
        c(e, u, "GeneratorFunction");
      }
      e.prototype = Object.create(b);
      return e;
    };
    e.awrap = function (e) {
      return {
        __await: e
      };
    };
    x(k.prototype);
    c(k.prototype, s, function () {
      return this;
    });
    e.AsyncIterator = k;
    e.async = function (t, n, r, a, i = Promise) {
      var o = new k(l(t, n, r, a), i);
      if (e.isGeneratorFunction(n)) {
        return o;
      } else {
        return o.next().then(function (e) {
          if (e.done) {
            return e.value;
          } else {
            return o.next();
          }
        });
      }
    };
    x(b);
    c(b, u, "Generator");
    c(b, i, function () {
      return this;
    });
    c(b, "toString", function () {
      return "[object Generator]";
    });
    e.keys = function (e) {
      var t = Object(e);
      var n = [];
      for (var r in t) {
        n.push(r);
      }
      n.reverse();
      return function e() {
        while (n.length) {
          var r = n.pop();
          if (r in t) {
            e.value = r;
            e.done = false;
            return e;
          }
        }
        e.done = true;
        return e;
      };
    };
    e.values = E;
    T.prototype = {
      constructor: T,
      reset: function (e) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined;
        this.tryEntries.forEach(S);
        if (!e) {
          for (var t in this) {
            if (t.charAt(0) === "t" && n.call(this, t) && !isNaN(+t.slice(1))) {
              this[t] = undefined;
            }
          }
        }
      },
      stop: function () {
        this.done = true;
        var e = this.tryEntries[0].completion;
        if (e.type === "throw") {
          throw e.arg;
        }
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) {
          throw e;
        }
        var t = this;
        function r(n, r) {
          o.type = "throw";
          o.arg = e;
          t.next = n;
          if (r) {
            t.method = "next";
            t.arg = undefined;
          }
          return !!r;
        }
        for (var a = this.tryEntries.length - 1; a >= 0; --a) {
          var i = this.tryEntries[a];
          var o = i.completion;
          if (i.tryLoc === "root") {
            return r("end");
          }
          if (i.tryLoc <= this.prev) {
            var s = n.call(i, "catchLoc");
            var u = n.call(i, "finallyLoc");
            if (s && u) {
              if (this.prev < i.catchLoc) {
                return r(i.catchLoc, true);
              }
              if (this.prev < i.finallyLoc) {
                return r(i.finallyLoc);
              }
            } else if (s) {
              if (this.prev < i.catchLoc) {
                return r(i.catchLoc, true);
              }
            } else {
              if (!u) {
                throw new Error("try statement without catch or finally");
              }
              if (this.prev < i.finallyLoc) {
                return r(i.finallyLoc);
              }
            }
          }
        }
      },
      abrupt: function (e, t) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var a = this.tryEntries[r];
          if (a.tryLoc <= this.prev && n.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
            var i = a;
            break;
          }
        }
        if (i && (e === "break" || e === "continue") && i.tryLoc <= t && t <= i.finallyLoc) {
          i = null;
        }
        var o = i ? i.completion : {};
        o.type = e;
        o.arg = t;
        if (i) {
          this.method = "next";
          this.next = i.finallyLoc;
          return p;
        } else {
          return this.complete(o);
        }
      },
      complete: function (e, t) {
        if (e.type === "throw") {
          throw e.arg;
        }
        if (e.type === "break" || e.type === "continue") {
          this.next = e.arg;
        } else if (e.type === "return") {
          this.rval = this.arg = e.arg;
          this.method = "return";
          this.next = "end";
        } else if (e.type === "normal" && t) {
          this.next = t;
        }
        return p;
      },
      finish: function (e) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
          var n = this.tryEntries[t];
          if (n.finallyLoc === e) {
            this.complete(n.completion, n.afterLoc);
            S(n);
            return p;
          }
        }
      },
      catch: function (e) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
          var n = this.tryEntries[t];
          if (n.tryLoc === e) {
            var r = n.completion;
            if (r.type === "throw") {
              var a = r.arg;
              S(n);
            }
            return a;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (e, t, n) {
        this.delegate = {
          iterator: E(e),
          resultName: t,
          nextLoc: n
        };
        if (this.method === "next") {
          this.arg = undefined;
        }
        return p;
      }
    };
    return e;
  }
  function s(e) {
    s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) {
      return typeof e;
    } : function (e) {
      if (e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype) {
        return "symbol";
      } else {
        return typeof e;
      }
    };
    return s(e);
  }
  function u(e, t, n, r, a, i, o) {
    try {
      var s = e[i](o);
      var u = s.value;
    } catch (e) {
      n(e);
      return;
    }
    if (s.done) {
      t(u);
    } else {
      Promise.resolve(u).then(r, a);
    }
  }
  function c(e) {
    return function () {
      var t = this;
      var n = arguments;
      return new Promise(function (r, a) {
        var i = e.apply(t, n);
        function o(e) {
          u(i, r, a, o, s, "next", e);
        }
        function s(e) {
          u(i, r, a, o, s, "throw", e);
        }
        o(undefined);
      });
    };
  }
  function l(e, t) {
    if (!(e instanceof t)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function h(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || false;
      r.configurable = true;
      if ("value" in r) {
        r.writable = true;
      }
      Object.defineProperty(e, F(r.key), r);
    }
  }
  function p(e, t, n) {
    if (t) {
      h(e.prototype, t);
    }
    if (n) {
      h(e, n);
    }
    Object.defineProperty(e, "prototype", {
      writable: false
    });
    return e;
  }
  function f(e, t, n) {
    if ((t = F(t)) in e) {
      Object.defineProperty(e, t, {
        value: n,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      e[t] = n;
    }
    return e;
  }
  function d(e, t) {
    if (typeof t != "function" && t !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(e, "prototype", {
      writable: false
    });
    if (t) {
      m(e, t);
    }
  }
  function v(e) {
    v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {
      return e.__proto__ || Object.getPrototypeOf(e);
    };
    return v(e);
  }
  function m(e, t) {
    m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
      e.__proto__ = t;
      return e;
    };
    return m(e, t);
  }
  function g() {
    if (typeof Reflect == "undefined" || !Reflect.construct) {
      return false;
    }
    if (Reflect.construct.sham) {
      return false;
    }
    if (typeof Proxy == "function") {
      return true;
    }
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function y(e, t, n) {
    y = g() ? Reflect.construct.bind() : function (e, t, n) {
      var r = [null];
      r.push.apply(r, t);
      var a = new (Function.bind.apply(e, r))();
      if (n) {
        m(a, n.prototype);
      }
      return a;
    };
    return y.apply(null, arguments);
  }
  function b(e) {
    var t = typeof Map == "function" ? new Map() : undefined;
    b = function (e) {
      if (e === null || (n = e, Function.toString.call(n).indexOf("[native code]") === -1)) {
        return e;
      }
      var n;
      if (typeof e != "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (t !== undefined) {
        if (t.has(e)) {
          return t.get(e);
        }
        t.set(e, r);
      }
      function r() {
        return y(e, arguments, v(this).constructor);
      }
      r.prototype = Object.create(e.prototype, {
        constructor: {
          value: r,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return m(r, e);
    };
    return b(e);
  }
  function x(e) {
    if (e === undefined) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return e;
  }
  function k(e, t) {
    if (t && (typeof t == "object" || typeof t == "function")) {
      return t;
    }
    if (t !== undefined) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return x(e);
  }
  function w(e) {
    var t = g();
    return function () {
      var n;
      var r = v(e);
      if (t) {
        var a = v(this).constructor;
        n = Reflect.construct(r, arguments, a);
      } else {
        n = r.apply(this, arguments);
      }
      return k(this, n);
    };
  }
  function I(e, t) {
    while (!Object.prototype.hasOwnProperty.call(e, t) && (e = v(e)) !== null);
    return e;
  }
  function N() {
    N = typeof Reflect != "undefined" && Reflect.get ? Reflect.get.bind() : function (e, t, n) {
      var r = I(e, t);
      if (r) {
        var a = Object.getOwnPropertyDescriptor(r, t);
        if (a.get) {
          return a.get.call(arguments.length < 3 ? e : n);
        } else {
          return a.value;
        }
      }
    };
    return N.apply(this, arguments);
  }
  function S(e, t) {
    return E(e) || function (e, t) {
      var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
      if (n != null) {
        var r;
        var a;
        var i;
        var o;
        var s = [];
        var u = true;
        var c = false;
        try {
          i = (n = n.call(e)).next;
          if (t === 0) {
            if (Object(n) !== n) {
              return;
            }
            u = false;
          } else {
            for (; !(u = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); u = true);
          }
        } catch (e) {
          c = true;
          a = e;
        } finally {
          try {
            if (!u && n.return != null && (o = n.return(), Object(o) !== o)) {
              return;
            }
          } finally {
            if (c) {
              throw a;
            }
          }
        }
        return s;
      }
    }(e, t) || A(e, t) || _();
  }
  function T(e) {
    return function (e) {
      if (Array.isArray(e)) {
        return R(e);
      }
    }(e) || C(e) || A(e) || function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function E(e) {
    if (Array.isArray(e)) {
      return e;
    }
  }
  function C(e) {
    if (typeof Symbol != "undefined" && e[Symbol.iterator] != null || e["@@iterator"] != null) {
      return Array.from(e);
    }
  }
  function A(e, t) {
    if (e) {
      if (typeof e == "string") {
        return R(e, t);
      }
      var n = Object.prototype.toString.call(e).slice(8, -1);
      if (n === "Object" && e.constructor) {
        n = e.constructor.name;
      }
      if (n === "Map" || n === "Set") {
        return Array.from(e);
      } else if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return R(e, t);
      } else {
        return undefined;
      }
    }
  }
  function R(e, t) {
    if (t == null || t > e.length) {
      t = e.length;
    }
    for (var n = 0, r = new Array(t); n < t; n++) {
      r[n] = e[n];
    }
    return r;
  }
  function _() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function O(e, t) {
    var n = typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
      if (Array.isArray(e) || (n = A(e)) || t && e && typeof e.length == "number") {
        if (n) {
          e = n;
        }
        var r = 0;
        function a() {}
        return {
          s: a,
          n: function () {
            if (r >= e.length) {
              return {
                done: true
              };
            } else {
              return {
                done: false,
                value: e[r++]
              };
            }
          },
          e: function (e) {
            throw e;
          },
          f: a
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var i;
    var o = true;
    var s = false;
    return {
      s: function () {
        n = n.call(e);
      },
      n: function () {
        var e = n.next();
        o = e.done;
        return e;
      },
      e: function (e) {
        s = true;
        i = e;
      },
      f: function () {
        try {
          if (!o && n.return != null) {
            n.return();
          }
        } finally {
          if (s) {
            throw i;
          }
        }
      }
    };
  }
  function F(e) {
    var t = function (e, t) {
      if (typeof e != "object" || e === null) {
        return e;
      }
      var n = e[Symbol.toPrimitive];
      if (n !== undefined) {
        var r = n.call(e, t || "default");
        if (typeof r != "object") {
          return r;
        }
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (t === "string" ? String : Number)(e);
    }(e, "string");
    if (typeof t == "symbol") {
      return t;
    } else {
      return String(t);
    }
  }
  a.prototype[typeof Symbol == "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () {
    return this;
  };
  a.prototype.next = function (e) {
    return this._invoke("next", e);
  };
  a.prototype.throw = function (e) {
    return this._invoke("throw", e);
  };
  a.prototype.return = function (e) {
    return this._invoke("return", e);
  };
  var D;
  var M;
  function L(e) {
    return e && e.Math == Math && e;
  }
  var z = L((typeof globalThis == "undefined" ? "undefined" : s(globalThis)) == "object" && globalThis) || L((typeof window == "undefined" ? "undefined" : s(window)) == "object" && window) || L((typeof self == "undefined" ? "undefined" : s(self)) == "object" && self) || L(s(n) == "object" && n) || function () {
    return this;
  }() || Function("return this")();
  var P = {};
  function B(e) {
    try {
      return !!e();
    } catch (e) {
      return true;
    }
  }
  var W = !B(function () {
    return Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      }
    })[1] != 7;
  });
  var U = !B(function () {
    var e = function () {}.bind();
    return typeof e != "function" || e.hasOwnProperty("prototype");
  });
  var V = U;
  var G = Function.prototype.call;
  var j = V ? G.bind(G) : function () {
    return G.apply(G, arguments);
  };
  var H = {};
  var q = {}.propertyIsEnumerable;
  var K = Object.getOwnPropertyDescriptor;
  var X = K && !q.call({
    1: 2
  }, 1);
  H.f = X ? function (e) {
    var t = K(this, e);
    return !!t && t.enumerable;
  } : q;
  function Y(e, t) {
    return {
      enumerable: !(e & 1),
      configurable: !(e & 2),
      writable: !(e & 4),
      value: t
    };
  }
  var J = U;
  var Z = Function.prototype;
  var Q = Z.call;
  var $ = J && Z.bind.bind(Q, Q);
  var ee = J ? $ : function (e) {
    return function () {
      return Q.apply(e, arguments);
    };
  };
  var te = ee;
  var ne = te({}.toString);
  var re = te("".slice);
  function ae(e) {
    return re(ne(e), 8, -1);
  }
  var ie = B;
  var oe = ae;
  var se = Object;
  var ue = ee("".split);
  var ce = ie(function () {
    return !se("z").propertyIsEnumerable(0);
  }) ? function (e) {
    if (oe(e) == "String") {
      return ue(e, "");
    } else {
      return se(e);
    }
  } : se;
  function le(e) {
    return e == null;
  }
  var he = le;
  var pe = TypeError;
  function fe(e) {
    if (he(e)) {
      throw pe("Can't call method on " + e);
    }
    return e;
  }
  var de = ce;
  var ve = fe;
  function me(e) {
    return de(ve(e));
  }
  var ge = (typeof document == "undefined" ? "undefined" : s(document)) == "object" && document.all;
  var ye = {
    all: ge,
    IS_HTMLDDA: ge === undefined && ge !== undefined
  };
  var be = ye.all;
  var xe = ye.IS_HTMLDDA ? function (e) {
    return typeof e == "function" || e === be;
  } : function (e) {
    return typeof e == "function";
  };
  var ke = xe;
  var we = ye.all;
  var Ie = ye.IS_HTMLDDA ? function (e) {
    if (s(e) == "object") {
      return e !== null;
    } else {
      return ke(e) || e === we;
    }
  } : function (e) {
    if (s(e) == "object") {
      return e !== null;
    } else {
      return ke(e);
    }
  };
  var Ne = z;
  var Se = xe;
  function Te(e) {
    if (Se(e)) {
      return e;
    } else {
      return undefined;
    }
  }
  function Ee(e, t) {
    if (arguments.length < 2) {
      return Te(Ne[e]);
    } else {
      return Ne[e] && Ne[e][t];
    }
  }
  var Ce = ee({}.isPrototypeOf);
  var Ae = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  var Re = z;
  var _e = Ae;
  var Oe = Re.process;
  var Fe = Re.Deno;
  var De = Oe && Oe.versions || Fe && Fe.version;
  var Me = De && De.v8;
  if (Me) {
    M = (D = Me.split("."))[0] > 0 && D[0] < 4 ? 1 : +(D[0] + D[1]);
  }
  if (!M && _e && (!(D = _e.match(/Edge\/(\d+)/)) || D[1] >= 74) && (D = _e.match(/Chrome\/(\d+)/))) {
    M = +D[1];
  }
  var Le = M;
  var ze = Le;
  var Pe = B;
  var Be = !!Object.getOwnPropertySymbols && !Pe(function () {
    var e = Symbol();
    return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && ze && ze < 41;
  });
  var We = Be && !Symbol.sham && s(Symbol.iterator) == "symbol";
  var Ue = Ee;
  var Ve = xe;
  var Ge = Ce;
  var je = Object;
  var He = We ? function (e) {
    return s(e) == "symbol";
  } : function (e) {
    var t = Ue("Symbol");
    return Ve(t) && Ge(t.prototype, je(e));
  };
  var qe = String;
  function Ke(e) {
    try {
      return qe(e);
    } catch (e) {
      return "Object";
    }
  }
  var Xe = xe;
  var Ye = Ke;
  var Je = TypeError;
  function Ze(e) {
    if (Xe(e)) {
      return e;
    }
    throw Je(Ye(e) + " is not a function");
  }
  var Qe = Ze;
  var $e = le;
  function et(e, t) {
    var n = e[t];
    if ($e(n)) {
      return undefined;
    } else {
      return Qe(n);
    }
  }
  var tt = j;
  var nt = xe;
  var rt = Ie;
  var at = TypeError;
  function it(e, t) {
    var n;
    var r;
    if (t === "string" && nt(n = e.toString) && !rt(r = tt(n, e))) {
      return r;
    }
    if (nt(n = e.valueOf) && !rt(r = tt(n, e))) {
      return r;
    }
    if (t !== "string" && nt(n = e.toString) && !rt(r = tt(n, e))) {
      return r;
    }
    throw at("Can't convert object to primitive value");
  }
  var ot = {
    exports: {}
  };
  var st = false;
  var ut = z;
  var ct = Object.defineProperty;
  function lt(e, t) {
    try {
      ct(ut, e, {
        value: t,
        configurable: true,
        writable: true
      });
    } catch (n) {
      ut[e] = t;
    }
    return t;
  }
  var ht = lt;
  var pt = "__core-js_shared__";
  var ft = z[pt] || ht(pt, {});
  ot.exports;
  var dt = ft;
  (ot.exports = function (e, t) {
    return dt[e] ||= t !== undefined ? t : {};
  })("versions", []).push({
    version: "3.29.1",
    mode: "global",
    copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.29.1/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  var vt = ot.exports;
  var mt = fe;
  var gt = Object;
  function yt(e) {
    return gt(mt(e));
  }
  var bt = yt;
  var xt = ee({}.hasOwnProperty);
  var kt = Object.hasOwn || function (e, t) {
    return xt(bt(e), t);
  };
  var wt = ee;
  var It = 0;
  var Nt = Math.random();
  var St = wt(1 .toString);
  function Tt(e) {
    return "Symbol(" + (e === undefined ? "" : e) + ")_" + St(++It + Nt, 36);
  }
  var Et = vt;
  var Ct = kt;
  var At = Tt;
  var Rt = Be;
  var _t = We;
  var Ot = z.Symbol;
  var Ft = Et("wks");
  var Dt = _t ? Ot.for || Ot : Ot && Ot.withoutSetter || At;
  function Mt(e) {
    if (!Ct(Ft, e)) {
      Ft[e] = Rt && Ct(Ot, e) ? Ot[e] : Dt("Symbol." + e);
    }
    return Ft[e];
  }
  var Lt = j;
  var zt = Ie;
  var Pt = He;
  var Bt = et;
  var Wt = it;
  var Ut = TypeError;
  var Vt = Mt("toPrimitive");
  function Gt(e, t) {
    if (!zt(e) || Pt(e)) {
      return e;
    }
    var n;
    var r = Bt(e, Vt);
    if (r) {
      if (t === undefined) {
        t = "default";
      }
      n = Lt(r, e, t);
      if (!zt(n) || Pt(n)) {
        return n;
      }
      throw Ut("Can't convert object to primitive value");
    }
    if (t === undefined) {
      t = "number";
    }
    return Wt(e, t);
  }
  var jt = Gt;
  var Ht = He;
  function qt(e) {
    var t = jt(e, "string");
    if (Ht(t)) {
      return t;
    } else {
      return t + "";
    }
  }
  var Kt = Ie;
  var Xt = z.document;
  var Yt = Kt(Xt) && Kt(Xt.createElement);
  function Jt(e) {
    if (Yt) {
      return Xt.createElement(e);
    } else {
      return {};
    }
  }
  var Zt = Jt;
  var Qt = !W && !B(function () {
    return Object.defineProperty(Zt("div"), "a", {
      get: function () {
        return 7;
      }
    }).a != 7;
  });
  var $t = W;
  var en = j;
  var tn = H;
  var nn = Y;
  var rn = me;
  var an = qt;
  var on = kt;
  var sn = Qt;
  var un = Object.getOwnPropertyDescriptor;
  P.f = $t ? un : function (e, t) {
    e = rn(e);
    t = an(t);
    if (sn) {
      try {
        return un(e, t);
      } catch (e) {}
    }
    if (on(e, t)) {
      return nn(!en(tn.f, e, t), e[t]);
    }
  };
  var cn = {};
  var ln = W && B(function () {
    return Object.defineProperty(function () {}, "prototype", {
      value: 42,
      writable: false
    }).prototype != 42;
  });
  var hn = Ie;
  var pn = String;
  var fn = TypeError;
  function dn(e) {
    if (hn(e)) {
      return e;
    }
    throw fn(pn(e) + " is not an object");
  }
  var vn = W;
  var mn = Qt;
  var gn = ln;
  var yn = dn;
  var bn = qt;
  var xn = TypeError;
  var kn = Object.defineProperty;
  var wn = Object.getOwnPropertyDescriptor;
  var In = "enumerable";
  var Nn = "configurable";
  var Sn = "writable";
  cn.f = vn ? gn ? function (e, t, n) {
    yn(e);
    t = bn(t);
    yn(n);
    if (typeof e == "function" && t === "prototype" && "value" in n && Sn in n && !n.writable) {
      var r = wn(e, t);
      if (r && r.writable) {
        e[t] = n.value;
        n = {
          configurable: Nn in n ? n.configurable : r.configurable,
          enumerable: In in n ? n.enumerable : r.enumerable,
          writable: false
        };
      }
    }
    return kn(e, t, n);
  } : kn : function (e, t, n) {
    yn(e);
    t = bn(t);
    yn(n);
    if (mn) {
      try {
        return kn(e, t, n);
      } catch (e) {}
    }
    if ("get" in n || "set" in n) {
      throw xn("Accessors not supported");
    }
    if ("value" in n) {
      e[t] = n.value;
    }
    return e;
  };
  var Tn = cn;
  var En = Y;
  var Cn = W ? function (e, t, n) {
    return Tn.f(e, t, En(1, n));
  } : function (e, t, n) {
    e[t] = n;
    return e;
  };
  var An = {
    exports: {}
  };
  var Rn = W;
  var _n = kt;
  var On = Function.prototype;
  var Fn = Rn && Object.getOwnPropertyDescriptor;
  var Dn = _n(On, "name");
  var Mn = {
    EXISTS: Dn,
    PROPER: Dn && function () {}.name === "something",
    CONFIGURABLE: Dn && (!Rn || Rn && Fn(On, "name").configurable)
  };
  var Ln = xe;
  var zn = ft;
  var Pn = ee(Function.toString);
  if (!Ln(zn.inspectSource)) {
    zn.inspectSource = function (e) {
      return Pn(e);
    };
  }
  var Bn;
  var Wn;
  var Un;
  var Vn = zn.inspectSource;
  var Gn = xe;
  var jn = z.WeakMap;
  var Hn = Gn(jn) && /native code/.test(String(jn));
  var qn = Tt;
  var Kn = vt("keys");
  function Xn(e) {
    return Kn[e] ||= qn(e);
  }
  var Yn = {};
  var Jn = Hn;
  var Zn = z;
  var Qn = Ie;
  var $n = Cn;
  var er = kt;
  var tr = ft;
  var nr = Xn;
  var rr = Yn;
  var ar = "Object already initialized";
  var ir = Zn.TypeError;
  var or = Zn.WeakMap;
  if (Jn || tr.state) {
    var sr = tr.state ||= new or();
    sr.get = sr.get;
    sr.has = sr.has;
    sr.set = sr.set;
    Bn = function (e, t) {
      if (sr.has(e)) {
        throw ir(ar);
      }
      t.facade = e;
      sr.set(e, t);
      return t;
    };
    Wn = function (e) {
      return sr.get(e) || {};
    };
    Un = function (e) {
      return sr.has(e);
    };
  } else {
    var ur = nr("state");
    rr[ur] = true;
    Bn = function (e, t) {
      if (er(e, ur)) {
        throw ir(ar);
      }
      t.facade = e;
      $n(e, ur, t);
      return t;
    };
    Wn = function (e) {
      if (er(e, ur)) {
        return e[ur];
      } else {
        return {};
      }
    };
    Un = function (e) {
      return er(e, ur);
    };
  }
  var cr = {
    set: Bn,
    get: Wn,
    has: Un,
    enforce: function (e) {
      if (Un(e)) {
        return Wn(e);
      } else {
        return Bn(e, {});
      }
    },
    getterFor: function (e) {
      return function (t) {
        var n;
        if (!Qn(t) || (n = Wn(t)).type !== e) {
          throw ir("Incompatible receiver, " + e + " required");
        }
        return n;
      };
    }
  };
  An.exports;
  var lr = ee;
  var hr = B;
  var pr = xe;
  var fr = kt;
  var dr = W;
  var vr = Mn.CONFIGURABLE;
  var mr = Vn;
  var gr = cr.enforce;
  var yr = cr.get;
  var br = String;
  var xr = Object.defineProperty;
  var kr = lr("".slice);
  var wr = lr("".replace);
  var Ir = lr([].join);
  var Nr = dr && !hr(function () {
    return xr(function () {}, "length", {
      value: 8
    }).length !== 8;
  });
  var Sr = String(String).split("String");
  var Tr = An.exports = function (e, t, n) {
    if (kr(br(t), 0, 7) === "Symbol(") {
      t = "[" + wr(br(t), /^Symbol\(([^)]*)\)/, "$1") + "]";
    }
    if (n && n.getter) {
      t = "get " + t;
    }
    if (n && n.setter) {
      t = "set " + t;
    }
    if (!fr(e, "name") || vr && e.name !== t) {
      if (dr) {
        xr(e, "name", {
          value: t,
          configurable: true
        });
      } else {
        e.name = t;
      }
    }
    if (Nr && n && fr(n, "arity") && e.length !== n.arity) {
      xr(e, "length", {
        value: n.arity
      });
    }
    try {
      if (n && fr(n, "constructor") && n.constructor) {
        if (dr) {
          xr(e, "prototype", {
            writable: false
          });
        }
      } else {
        e.prototype &&= undefined;
      }
    } catch (e) {}
    var r = gr(e);
    if (!fr(r, "source")) {
      r.source = Ir(Sr, typeof t == "string" ? t : "");
    }
    return e;
  };
  Function.prototype.toString = Tr(function () {
    return pr(this) && yr(this).source || mr(this);
  }, "toString");
  var Er = An.exports;
  var Cr = xe;
  var Ar = cn;
  var Rr = Er;
  var _r = lt;
  function Or(e, t, n, r) {
    r ||= {};
    var a = r.enumerable;
    var i = r.name !== undefined ? r.name : t;
    if (Cr(n)) {
      Rr(n, i, r);
    }
    if (r.global) {
      if (a) {
        e[t] = n;
      } else {
        _r(t, n);
      }
    } else {
      try {
        if (r.unsafe) {
          if (e[t]) {
            a = true;
          }
        } else {
          delete e[t];
        }
      } catch (e) {}
      if (a) {
        e[t] = n;
      } else {
        Ar.f(e, t, {
          value: n,
          enumerable: false,
          configurable: !r.nonConfigurable,
          writable: !r.nonWritable
        });
      }
    }
    return e;
  }
  var Fr = {};
  var Dr = Math.ceil;
  var Mr = Math.floor;
  var Lr = Math.trunc || function (e) {
    var t = +e;
    return (t > 0 ? Mr : Dr)(t);
  };
  var zr = Lr;
  function Pr(e) {
    var t = +e;
    if (t != t || t === 0) {
      return 0;
    } else {
      return zr(t);
    }
  }
  var Br = Pr;
  var Wr = Math.max;
  var Ur = Math.min;
  function Vr(e, t) {
    var n = Br(e);
    if (n < 0) {
      return Wr(n + t, 0);
    } else {
      return Ur(n, t);
    }
  }
  var Gr = Pr;
  var jr = Math.min;
  function Hr(e) {
    if (e > 0) {
      return jr(Gr(e), 9007199254740991);
    } else {
      return 0;
    }
  }
  var qr = Hr;
  function Kr(e) {
    return qr(e.length);
  }
  var Xr = me;
  var Yr = Vr;
  var Jr = Kr;
  function Zr(e) {
    return function (t, n, r) {
      var a;
      var i = Xr(t);
      var o = Jr(i);
      var s = Yr(r, o);
      if (e && n != n) {
        while (o > s) {
          if ((a = i[s++]) != a) {
            return true;
          }
        }
      } else {
        for (; o > s; s++) {
          if ((e || s in i) && i[s] === n) {
            return e || s || 0;
          }
        }
      }
      return !e && -1;
    };
  }
  var Qr = {
    includes: Zr(true),
    indexOf: Zr(false)
  };
  var $r = kt;
  var ea = me;
  var ta = Qr.indexOf;
  var na = Yn;
  var ra = ee([].push);
  function aa(e, t) {
    var n;
    var r = ea(e);
    var a = 0;
    var i = [];
    for (n in r) {
      if (!$r(na, n) && $r(r, n)) {
        ra(i, n);
      }
    }
    while (t.length > a) {
      if ($r(r, n = t[a++])) {
        if (!~ta(i, n)) {
          ra(i, n);
        }
      }
    }
    return i;
  }
  var ia = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
  var oa = aa;
  var sa = ia.concat("length", "prototype");
  Fr.f = Object.getOwnPropertyNames || function (e) {
    return oa(e, sa);
  };
  var ua = {
    f: Object.getOwnPropertySymbols
  };
  var ca = Ee;
  var la = Fr;
  var ha = ua;
  var pa = dn;
  var fa = ee([].concat);
  var da = ca("Reflect", "ownKeys") || function (e) {
    var t = la.f(pa(e));
    var n = ha.f;
    if (n) {
      return fa(t, n(e));
    } else {
      return t;
    }
  };
  var va = kt;
  var ma = da;
  var ga = P;
  var ya = cn;
  function ba(e, t, n) {
    for (var r = ma(t), a = ya.f, i = ga.f, o = 0; o < r.length; o++) {
      var s = r[o];
      if (!va(e, s) && (!n || !va(n, s))) {
        a(e, s, i(t, s));
      }
    }
  }
  var xa = B;
  var ka = xe;
  var wa = /#|\.prototype\./;
  function Ia(e, t) {
    var n = Sa[Na(e)];
    return n == Ea || n != Ta && (ka(t) ? xa(t) : !!t);
  }
  var Na = Ia.normalize = function (e) {
    return String(e).replace(wa, ".").toLowerCase();
  };
  var Sa = Ia.data = {};
  var Ta = Ia.NATIVE = "N";
  var Ea = Ia.POLYFILL = "P";
  var Ca = Ia;
  var Aa = z;
  var Ra = P.f;
  var _a = Cn;
  var Oa = Or;
  var Fa = lt;
  var Da = ba;
  var Ma = Ca;
  function La(e, t) {
    var n;
    var r;
    var a;
    var i;
    var o;
    var u = e.target;
    var c = e.global;
    var l = e.stat;
    if (n = c ? Aa : l ? Aa[u] || Fa(u, {}) : (Aa[u] || {}).prototype) {
      for (r in t) {
        i = t[r];
        a = e.dontCallGetSet ? (o = Ra(n, r)) && o.value : n[r];
        if (!Ma(c ? r : u + (l ? "." : "#") + r, e.forced) && a !== undefined) {
          if (s(i) == s(a)) {
            continue;
          }
          Da(i, a);
        }
        if (e.sham || a && a.sham) {
          _a(i, "sham", true);
        }
        Oa(n, r, i, e);
      }
    }
  }
  var za = {
    [Mt("toStringTag")]: "z"
  };
  var Pa;
  var Ba = String(za) === "[object z]";
  var Wa = Ba;
  var Ua = xe;
  var Va = ae;
  var Ga = Mt("toStringTag");
  var ja = Object;
  var Ha = Va(function () {
    return arguments;
  }()) == "Arguments";
  var qa = Wa ? Va : function (e) {
    var t;
    var n;
    var r;
    if (e === undefined) {
      return "Undefined";
    } else if (e === null) {
      return "Null";
    } else if (typeof (n = function (e, t) {
      try {
        return e[t];
      } catch (e) {}
    }(t = ja(e), Ga)) == "string") {
      return n;
    } else if (Ha) {
      return Va(t);
    } else if ((r = Va(t)) == "Object" && Ua(t.callee)) {
      return "Arguments";
    } else {
      return r;
    }
  };
  var Ka = qa;
  var Xa = String;
  function Ya(e) {
    if (Ka(e) === "Symbol") {
      throw TypeError("Cannot convert a Symbol value to a string");
    }
    return Xa(e);
  }
  var Ja = {};
  var Za = aa;
  var Qa = ia;
  var $a = Object.keys || function (e) {
    return Za(e, Qa);
  };
  var ei = W;
  var ti = ln;
  var ni = cn;
  var ri = dn;
  var ai = me;
  var ii = $a;
  Ja.f = ei && !ti ? Object.defineProperties : function (e, t) {
    ri(e);
    var n;
    var r = ai(t);
    var a = ii(t);
    for (var i = a.length, o = 0; i > o;) {
      ni.f(e, n = a[o++], r[n]);
    }
    return e;
  };
  var oi = Ee("document", "documentElement");
  var si = dn;
  var ui = Ja;
  var ci = ia;
  var li = Yn;
  var hi = oi;
  var pi = Jt;
  var fi = Xn("IE_PROTO");
  function di() {}
  function vi(e) {
    return "<script>" + e + "</script>";
  }
  function mi(e) {
    e.write(vi(""));
    e.close();
    var t = e.parentWindow.Object;
    e = null;
    return t;
  }
  function gi() {
    try {
      Pa = new ActiveXObject("htmlfile");
    } catch (e) {}
    var e;
    var t;
    gi = typeof document != "undefined" ? document.domain && Pa ? mi(Pa) : ((t = pi("iframe")).style.display = "none", hi.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(vi("document.F=Object")), e.close(), e.F) : mi(Pa);
    for (var n = ci.length; n--;) {
      delete gi.prototype[ci[n]];
    }
    return gi();
  }
  li[fi] = true;
  var yi = Object.create || function (e, t) {
    var n;
    if (e !== null) {
      di.prototype = si(e);
      n = new di();
      di.prototype = null;
      n[fi] = e;
    } else {
      n = gi();
    }
    if (t === undefined) {
      return n;
    } else {
      return ui.f(n, t);
    }
  };
  var bi = {};
  var xi = qt;
  var ki = cn;
  var wi = Y;
  function Ii(e, t, n) {
    var r = xi(t);
    if (r in e) {
      ki.f(e, r, wi(0, n));
    } else {
      e[r] = n;
    }
  }
  var Ni = Vr;
  var Si = Kr;
  var Ti = Ii;
  var Ei = Array;
  var Ci = Math.max;
  function Ai(e, t, n) {
    var r = Si(e);
    for (var a = Ni(t, r), i = Ni(n === undefined ? r : n, r), o = Ei(Ci(i - a, 0)), s = 0; a < i; a++, s++) {
      Ti(o, s, e[a]);
    }
    o.length = s;
    return o;
  }
  var Ri = ae;
  var _i = me;
  var Oi = Fr.f;
  var Fi = Ai;
  var Di = (typeof window == "undefined" ? "undefined" : s(window)) == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  bi.f = function (e) {
    if (Di && Ri(e) == "Window") {
      return function (e) {
        try {
          return Oi(e);
        } catch (e) {
          return Fi(Di);
        }
      }(e);
    } else {
      return Oi(_i(e));
    }
  };
  var Mi = Er;
  var Li = cn;
  function zi(e, t, n) {
    if (n.get) {
      Mi(n.get, t, {
        getter: true
      });
    }
    if (n.set) {
      Mi(n.set, t, {
        setter: true
      });
    }
    return Li.f(e, t, n);
  }
  var Pi = {};
  var Bi = Mt;
  Pi.f = Bi;
  var Wi = z;
  var Ui = Wi;
  var Vi = kt;
  var Gi = Pi;
  var ji = cn.f;
  function Hi(e) {
    var t = Ui.Symbol ||= {};
    if (!Vi(t, e)) {
      ji(t, e, {
        value: Gi.f(e)
      });
    }
  }
  var qi = j;
  var Ki = Ee;
  var Xi = Mt;
  var Yi = Or;
  function Ji() {
    var e = Ki("Symbol");
    var t = e && e.prototype;
    var n = t && t.valueOf;
    var r = Xi("toPrimitive");
    if (t && !t[r]) {
      Yi(t, r, function (e) {
        return qi(n, this);
      }, {
        arity: 1
      });
    }
  }
  var Zi = cn.f;
  var Qi = kt;
  var $i = Mt("toStringTag");
  function eo(e, t, n) {
    if (e && !n) {
      e = e.prototype;
    }
    if (e && !Qi(e, $i)) {
      Zi(e, $i, {
        configurable: true,
        value: t
      });
    }
  }
  var to = ae;
  var no = ee;
  function ro(e) {
    if (to(e) === "Function") {
      return no(e);
    }
  }
  var ao = Ze;
  var io = U;
  var oo = ro(ro.bind);
  function so(e, t) {
    ao(e);
    if (t === undefined) {
      return e;
    } else if (io) {
      return oo(e, t);
    } else {
      return function () {
        return e.apply(t, arguments);
      };
    }
  }
  var uo = ae;
  var co = Array.isArray || function (e) {
    return uo(e) == "Array";
  };
  var lo = ee;
  var ho = B;
  var po = xe;
  var fo = qa;
  var vo = Vn;
  function mo() {}
  var go = [];
  var yo = Ee("Reflect", "construct");
  var bo = /^\s*(?:class|function)\b/;
  var xo = lo(bo.exec);
  var ko = !bo.exec(mo);
  function wo(e) {
    if (!po(e)) {
      return false;
    }
    try {
      yo(mo, go, e);
      return true;
    } catch (e) {
      return false;
    }
  }
  function Io(e) {
    if (!po(e)) {
      return false;
    }
    switch (fo(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return ko || !!xo(bo, vo(e));
    } catch (e) {
      return true;
    }
  }
  Io.sham = true;
  var No = !yo || ho(function () {
    var e;
    return wo(wo.call) || !wo(Object) || !wo(function () {
      e = true;
    }) || e;
  }) ? Io : wo;
  var So = co;
  var To = No;
  var Eo = Ie;
  var Co = Mt("species");
  var Ao = Array;
  function Ro(e) {
    var t;
    if (So(e)) {
      t = e.constructor;
      if (To(t) && (t === Ao || So(t.prototype)) || Eo(t) && (t = t[Co]) === null) {
        t = undefined;
      }
    }
    if (t === undefined) {
      return Ao;
    } else {
      return t;
    }
  }
  var _o = Ro;
  function Oo(e, t) {
    return new (_o(e))(t === 0 ? 0 : t);
  }
  var Fo = so;
  var Do = ce;
  var Mo = yt;
  var Lo = Kr;
  var zo = Oo;
  var Po = ee([].push);
  function Bo(e) {
    var t = e == 1;
    var n = e == 2;
    var r = e == 3;
    var a = e == 4;
    var i = e == 6;
    var o = e == 7;
    var s = e == 5 || i;
    return function (u, c, l, h) {
      var p;
      var f;
      var d = Mo(u);
      var v = Do(d);
      var m = Fo(c, l);
      for (var g = Lo(v), y = 0, b = h || zo, x = t ? b(u, g) : n || o ? b(u, 0) : undefined; g > y; y++) {
        if ((s || y in v) && (f = m(p = v[y], y, d), e)) {
          if (t) {
            x[y] = f;
          } else if (f) {
            switch (e) {
              case 3:
                return true;
              case 5:
                return p;
              case 6:
                return y;
              case 2:
                Po(x, p);
            }
          } else {
            switch (e) {
              case 4:
                return false;
              case 7:
                Po(x, p);
            }
          }
        }
      }
      if (i) {
        return -1;
      } else if (r || a) {
        return a;
      } else {
        return x;
      }
    };
  }
  var Wo = {
    forEach: Bo(0),
    map: Bo(1),
    filter: Bo(2),
    some: Bo(3),
    every: Bo(4),
    find: Bo(5),
    findIndex: Bo(6),
    filterReject: Bo(7)
  };
  var Uo = La;
  var Vo = z;
  var Go = j;
  var jo = ee;
  var Ho = W;
  var qo = Be;
  var Ko = B;
  var Xo = kt;
  var Yo = Ce;
  var Jo = dn;
  var Zo = me;
  var Qo = qt;
  var $o = Ya;
  var es = Y;
  var ts = yi;
  var ns = $a;
  var rs = Fr;
  var as = bi;
  var is = ua;
  var os = P;
  var ss = cn;
  var us = Ja;
  var cs = H;
  var ls = Or;
  var hs = zi;
  var ps = vt;
  var fs = Yn;
  var ds = Tt;
  var vs = Mt;
  var ms = Pi;
  var gs = Hi;
  var ys = Ji;
  var bs = eo;
  var xs = cr;
  var ks = Wo.forEach;
  var ws = Xn("hidden");
  var Is = "Symbol";
  var Ns = xs.set;
  var Ss = xs.getterFor(Is);
  var Ts = Object.prototype;
  var Es = Vo.Symbol;
  var Cs = Es && Es.prototype;
  var As = Vo.TypeError;
  var Rs = Vo.QObject;
  var _s = os.f;
  var Os = ss.f;
  var Fs = as.f;
  var Ds = cs.f;
  var Ms = jo([].push);
  var Ls = ps("symbols");
  var zs = ps("op-symbols");
  var Ps = ps("wks");
  var Bs = !Rs || !Rs.prototype || !Rs.prototype.findChild;
  var Ws = Ho && Ko(function () {
    return ts(Os({}, "a", {
      get: function () {
        return Os(this, "a", {
          value: 7
        }).a;
      }
    })).a != 7;
  }) ? function (e, t, n) {
    var r = _s(Ts, t);
    if (r) {
      delete Ts[t];
    }
    Os(e, t, n);
    if (r && e !== Ts) {
      Os(Ts, t, r);
    }
  } : Os;
  function Us(e, t) {
    var n = Ls[e] = ts(Cs);
    Ns(n, {
      type: Is,
      tag: e,
      description: t
    });
    if (!Ho) {
      n.description = t;
    }
    return n;
  }
  function Vs(e, t, n) {
    if (e === Ts) {
      Vs(zs, t, n);
    }
    Jo(e);
    var r = Qo(t);
    Jo(n);
    if (Xo(Ls, r)) {
      if (n.enumerable) {
        if (Xo(e, ws) && e[ws][r]) {
          e[ws][r] = false;
        }
        n = ts(n, {
          enumerable: es(0, false)
        });
      } else {
        if (!Xo(e, ws)) {
          Os(e, ws, es(1, {}));
        }
        e[ws][r] = true;
      }
      return Ws(e, r, n);
    } else {
      return Os(e, r, n);
    }
  }
  function Gs(e, t) {
    Jo(e);
    var n = Zo(t);
    var r = ns(n).concat(Ks(n));
    ks(r, function (t) {
      if (!Ho || !!Go(js, n, t)) {
        Vs(e, t, n[t]);
      }
    });
    return e;
  }
  function js(e) {
    var t = Qo(e);
    var n = Go(Ds, this, t);
    return (this !== Ts || !Xo(Ls, t) || !!Xo(zs, t)) && (!n && !!Xo(this, t) && !!Xo(Ls, t) && (!Xo(this, ws) || !this[ws][t]) || n);
  }
  function Hs(e, t) {
    var n = Zo(e);
    var r = Qo(t);
    if (n !== Ts || !Xo(Ls, r) || Xo(zs, r)) {
      var a = _s(n, r);
      if (!!a && !!Xo(Ls, r) && (!Xo(n, ws) || !n[ws][r])) {
        a.enumerable = true;
      }
      return a;
    }
  }
  function qs(e) {
    var t = Fs(Zo(e));
    var n = [];
    ks(t, function (e) {
      if (!Xo(Ls, e) && !Xo(fs, e)) {
        Ms(n, e);
      }
    });
    return n;
  }
  function Ks(e) {
    var t = e === Ts;
    var n = Fs(t ? zs : Zo(e));
    var r = [];
    ks(n, function (e) {
      if (!!Xo(Ls, e) && (!t || !!Xo(Ts, e))) {
        Ms(r, Ls[e]);
      }
    });
    return r;
  }
  if (!qo) {
    Es = function () {
      if (Yo(Cs, this)) {
        throw As("Symbol is not a constructor");
      }
      var e = arguments.length && arguments[0] !== undefined ? $o(arguments[0]) : undefined;
      var t = ds(e);
      var n = function e(n) {
        if (this === Ts) {
          Go(e, zs, n);
        }
        if (Xo(this, ws) && Xo(this[ws], t)) {
          this[ws][t] = false;
        }
        Ws(this, t, es(1, n));
      };
      if (Ho && Bs) {
        Ws(Ts, t, {
          configurable: true,
          set: n
        });
      }
      return Us(t, e);
    };
    ls(Cs = Es.prototype, "toString", function () {
      return Ss(this).tag;
    });
    ls(Es, "withoutSetter", function (e) {
      return Us(ds(e), e);
    });
    cs.f = js;
    ss.f = Vs;
    us.f = Gs;
    os.f = Hs;
    rs.f = as.f = qs;
    is.f = Ks;
    ms.f = function (e) {
      return Us(vs(e), e);
    };
    if (Ho) {
      hs(Cs, "description", {
        configurable: true,
        get: function () {
          return Ss(this).description;
        }
      });
      ls(Ts, "propertyIsEnumerable", js, {
        unsafe: true
      });
    }
  }
  Uo({
    global: true,
    constructor: true,
    wrap: true,
    forced: !qo,
    sham: !qo
  }, {
    Symbol: Es
  });
  ks(ns(Ps), function (e) {
    gs(e);
  });
  Uo({
    target: Is,
    stat: true,
    forced: !qo
  }, {
    useSetter: function () {
      Bs = true;
    },
    useSimple: function () {
      Bs = false;
    }
  });
  Uo({
    target: "Object",
    stat: true,
    forced: !qo,
    sham: !Ho
  }, {
    create: function (e, t) {
      if (t === undefined) {
        return ts(e);
      } else {
        return Gs(ts(e), t);
      }
    },
    defineProperty: Vs,
    defineProperties: Gs,
    getOwnPropertyDescriptor: Hs
  });
  Uo({
    target: "Object",
    stat: true,
    forced: !qo
  }, {
    getOwnPropertyNames: qs
  });
  ys();
  bs(Es, Is);
  fs[ws] = true;
  var Xs = Be && !!Symbol.for && !!Symbol.keyFor;
  var Ys = La;
  var Js = Ee;
  var Zs = kt;
  var Qs = Ya;
  var $s = vt;
  var eu = Xs;
  var tu = $s("string-to-symbol-registry");
  var nu = $s("symbol-to-string-registry");
  Ys({
    target: "Symbol",
    stat: true,
    forced: !eu
  }, {
    for: function (e) {
      var t = Qs(e);
      if (Zs(tu, t)) {
        return tu[t];
      }
      var n = Js("Symbol")(t);
      tu[t] = n;
      nu[n] = t;
      return n;
    }
  });
  var ru = La;
  var au = kt;
  var iu = He;
  var ou = Ke;
  var su = Xs;
  var uu = vt("symbol-to-string-registry");
  ru({
    target: "Symbol",
    stat: true,
    forced: !su
  }, {
    keyFor: function (e) {
      if (!iu(e)) {
        throw TypeError(ou(e) + " is not a symbol");
      }
      if (au(uu, e)) {
        return uu[e];
      }
    }
  });
  var cu = U;
  var lu = Function.prototype;
  var hu = lu.apply;
  var pu = lu.call;
  var fu = (typeof Reflect == "undefined" ? "undefined" : s(Reflect)) == "object" && Reflect.apply || (cu ? pu.bind(hu) : function () {
    return pu.apply(hu, arguments);
  });
  var du = ee([].slice);
  var vu = co;
  var mu = xe;
  var gu = ae;
  var yu = Ya;
  var bu = ee([].push);
  function xu(e) {
    if (mu(e)) {
      return e;
    }
    if (vu(e)) {
      for (var t = e.length, n = [], r = 0; r < t; r++) {
        var a = e[r];
        if (typeof a == "string") {
          bu(n, a);
        } else if (typeof a == "number" || gu(a) == "Number" || gu(a) == "String") {
          bu(n, yu(a));
        }
      }
      var i = n.length;
      var o = true;
      return function (e, t) {
        if (o) {
          o = false;
          return t;
        }
        if (vu(this)) {
          return t;
        }
        for (var r = 0; r < i; r++) {
          if (n[r] === e) {
            return t;
          }
        }
      };
    }
  }
  var ku = La;
  var wu = Ee;
  var Iu = fu;
  var Nu = j;
  var Su = ee;
  var Tu = B;
  var Eu = xe;
  var Cu = He;
  var Au = du;
  var Ru = xu;
  var _u = Be;
  var Ou = String;
  var Fu = wu("JSON", "stringify");
  var Du = Su(/./.exec);
  var Mu = Su("".charAt);
  var Lu = Su("".charCodeAt);
  var zu = Su("".replace);
  var Pu = Su(1 .toString);
  var Bu = /[\uD800-\uDFFF]/g;
  var Wu = /^[\uD800-\uDBFF]$/;
  var Uu = /^[\uDC00-\uDFFF]$/;
  var Vu = !_u || Tu(function () {
    var e = wu("Symbol")();
    return Fu([e]) != "[null]" || Fu({
      a: e
    }) != "{}" || Fu(Object(e)) != "{}";
  });
  var Gu = Tu(function () {
    return Fu("\uDF06\uD834") !== "\"\\udf06\\ud834\"" || Fu("\uDEAD") !== "\"\\udead\"";
  });
  function ju(e, t) {
    var n = Au(arguments);
    var r = Ru(t);
    if (Eu(r) || e !== undefined && !Cu(e)) {
      n[1] = function (e, t) {
        if (Eu(r)) {
          t = Nu(r, this, Ou(e), t);
        }
        if (!Cu(t)) {
          return t;
        }
      };
      return Iu(Fu, null, n);
    }
  }
  function Hu(e, t, n) {
    var r = Mu(n, t - 1);
    var a = Mu(n, t + 1);
    if (Du(Wu, e) && !Du(Uu, a) || Du(Uu, e) && !Du(Wu, r)) {
      return "\\u" + Pu(Lu(e, 0), 16);
    } else {
      return e;
    }
  }
  if (Fu) {
    ku({
      target: "JSON",
      stat: true,
      arity: 3,
      forced: Vu || Gu
    }, {
      stringify: function (e, t, n) {
        var r = Au(arguments);
        var a = Iu(Vu ? ju : Fu, null, r);
        if (Gu && typeof a == "string") {
          return zu(a, Bu, Hu);
        } else {
          return a;
        }
      }
    });
  }
  var qu = ua;
  var Ku = yt;
  La({
    target: "Object",
    stat: true,
    forced: !Be || B(function () {
      qu.f(1);
    })
  }, {
    getOwnPropertySymbols: function (e) {
      var t = qu.f;
      if (t) {
        return t(Ku(e));
      } else {
        return [];
      }
    }
  });
  var Xu = La;
  var Yu = W;
  var Ju = ee;
  var Zu = kt;
  var Qu = xe;
  var $u = Ce;
  var ec = Ya;
  var tc = zi;
  var nc = ba;
  var rc = z.Symbol;
  var ac = rc && rc.prototype;
  if (Yu && Qu(rc) && (!("description" in ac) || rc().description !== undefined)) {
    var ic = {};
    function oc() {
      var e = arguments.length < 1 || arguments[0] === undefined ? undefined : ec(arguments[0]);
      var t = $u(ac, this) ? new rc(e) : e === undefined ? rc() : rc(e);
      if (e === "") {
        ic[t] = true;
      }
      return t;
    }
    nc(oc, rc);
    oc.prototype = ac;
    ac.constructor = oc;
    var sc = String(rc("test")) == "Symbol(test)";
    var uc = Ju(ac.valueOf);
    var cc = Ju(ac.toString);
    var lc = /^Symbol\((.*)\)[^)]+$/;
    var hc = Ju("".replace);
    var pc = Ju("".slice);
    tc(ac, "description", {
      configurable: true,
      get: function () {
        var e = uc(this);
        if (Zu(ic, e)) {
          return "";
        }
        var t = cc(e);
        var n = sc ? pc(t, 7, -1) : hc(t, lc, "$1");
        if (n === "") {
          return undefined;
        } else {
          return n;
        }
      }
    });
    Xu({
      global: true,
      constructor: true,
      forced: true
    }, {
      Symbol: oc
    });
  }
  Hi("asyncIterator");
  Hi("hasInstance");
  Hi("isConcatSpreadable");
  Hi("iterator");
  Hi("match");
  Hi("matchAll");
  Hi("replace");
  Hi("search");
  Hi("species");
  Hi("split");
  var fc = Ji;
  Hi("toPrimitive");
  fc();
  var dc = Ee;
  var vc = eo;
  Hi("toStringTag");
  vc(dc("Symbol"), "Symbol");
  Hi("unscopables");
  var mc = ee;
  var gc = Ze;
  function yc(e, t, n) {
    try {
      return mc(gc(Object.getOwnPropertyDescriptor(e, t)[n]));
    } catch (e) {}
  }
  var bc = xe;
  var xc = String;
  var kc = TypeError;
  function wc(e) {
    if (s(e) == "object" || bc(e)) {
      return e;
    }
    throw kc("Can't set " + xc(e) + " as a prototype");
  }
  var Ic = yc;
  var Nc = dn;
  var Sc = wc;
  var Tc = Object.setPrototypeOf || ("__proto__" in {} ? function () {
    var e;
    var t = false;
    var n = {};
    try {
      (e = Ic(Object.prototype, "__proto__", "set"))(n, []);
      t = n instanceof Array;
    } catch (e) {}
    return function (n, r) {
      Nc(n);
      Sc(r);
      if (t) {
        e(n, r);
      } else {
        n.__proto__ = r;
      }
      return n;
    };
  }() : undefined);
  var Ec = cn.f;
  function Cc(e, t, n) {
    if (!(n in e)) {
      Ec(e, n, {
        configurable: true,
        get: function () {
          return t[n];
        },
        set: function (e) {
          t[n] = e;
        }
      });
    }
  }
  var Ac = xe;
  var Rc = Ie;
  var _c = Tc;
  function Oc(e, t, n) {
    var r;
    var a;
    if (_c && Ac(r = t.constructor) && r !== n && Rc(a = r.prototype) && a !== n.prototype) {
      _c(e, a);
    }
    return e;
  }
  var Fc = Ya;
  function Dc(e, t) {
    if (e === undefined) {
      if (arguments.length < 2) {
        return "";
      } else {
        return t;
      }
    } else {
      return Fc(e);
    }
  }
  var Mc = Ie;
  var Lc = Cn;
  function zc(e, t) {
    if (Mc(t) && "cause" in t) {
      Lc(e, "cause", t.cause);
    }
  }
  var Pc = Error;
  var Bc = ee("".replace);
  var Wc = String(Pc("zxcasd").stack);
  var Uc = /\n\s*at [^:]*:[^\n]*/;
  var Vc = Uc.test(Wc);
  function Gc(e, t) {
    if (Vc && typeof e == "string" && !Pc.prepareStackTrace) {
      while (t--) {
        e = Bc(e, Uc, "");
      }
    }
    return e;
  }
  var jc = Y;
  var Hc = !B(function () {
    var e = Error("a");
    return !("stack" in e) || (Object.defineProperty(e, "stack", jc(1, 7)), e.stack !== 7);
  });
  var qc = Cn;
  var Kc = Gc;
  var Xc = Hc;
  var Yc = Error.captureStackTrace;
  function Jc(e, t, n, r) {
    if (Xc) {
      if (Yc) {
        Yc(e, t);
      } else {
        qc(e, "stack", Kc(n, r));
      }
    }
  }
  var Zc = Ee;
  var Qc = kt;
  var $c = Cn;
  var el = Ce;
  var tl = Tc;
  var nl = ba;
  var rl = Cc;
  var al = Oc;
  var il = Dc;
  var ol = zc;
  var sl = Jc;
  var ul = W;
  function cl(e, t, n, r) {
    var a = "stackTraceLimit";
    var i = r ? 2 : 1;
    var o = e.split(".");
    var s = o[o.length - 1];
    var u = Zc.apply(null, o);
    if (u) {
      var c = u.prototype;
      if (Qc(c, "cause")) {
        delete c.cause;
      }
      if (!n) {
        return u;
      }
      var l = Zc("Error");
      var h = t(function (e, t) {
        var n = il(r ? t : e, undefined);
        var a = r ? new u(e) : new u();
        if (n !== undefined) {
          $c(a, "message", n);
        }
        sl(a, h, a.stack, 2);
        if (this && el(c, this)) {
          al(a, this, h);
        }
        if (arguments.length > i) {
          ol(a, arguments[i]);
        }
        return a;
      });
      h.prototype = c;
      if (s !== "Error") {
        if (tl) {
          tl(h, l);
        } else {
          nl(h, l, {
            name: true
          });
        }
      } else if (ul && a in u) {
        rl(h, u, a);
        rl(h, u, "prepareStackTrace");
      }
      nl(h, u);
      try {
        if (c.name !== s) {
          $c(c, "name", s);
        }
        c.constructor = h;
      } catch (e) {}
      return h;
    }
  }
  var ll = La;
  var hl = fu;
  var pl = cl;
  var fl = "WebAssembly";
  var dl = z.WebAssembly;
  var vl = Error("e", {
    cause: 7
  }).cause !== 7;
  function ml(e, t) {
    var n = {};
    n[e] = pl(e, t, vl);
    ll({
      global: true,
      constructor: true,
      arity: 1,
      forced: vl
    }, n);
  }
  function gl(e, t) {
    if (dl && dl[e]) {
      var n = {};
      n[e] = pl("WebAssembly." + e, t, vl);
      ll({
        target: fl,
        stat: true,
        constructor: true,
        arity: 1,
        forced: vl
      }, n);
    }
  }
  ml("Error", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  ml("EvalError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  ml("RangeError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  ml("ReferenceError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  ml("SyntaxError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  ml("TypeError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  ml("URIError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  gl("CompileError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  gl("LinkError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  gl("RuntimeError", function (e) {
    return function (t) {
      return hl(e, this, arguments);
    };
  });
  var yl = W;
  var bl = B;
  var xl = dn;
  var kl = yi;
  var wl = Dc;
  var Il = Error.prototype.toString;
  var Nl = bl(function () {
    if (yl) {
      var e = kl(Object.defineProperty({}, "name", {
        get: function () {
          return this === e;
        }
      }));
      if (Il.call(e) !== "true") {
        return true;
      }
    }
    return Il.call({
      message: 1,
      name: 2
    }) !== "2: 1" || Il.call({}) !== "Error";
  }) ? function () {
    var e = xl(this);
    var t = wl(e.name, "Error");
    var n = wl(e.message);
    if (t) {
      if (n) {
        return t + ": " + n;
      } else {
        return t;
      }
    } else {
      return n;
    }
  } : Il;
  var Sl = Or;
  var Tl = Nl;
  var El = Error.prototype;
  if (El.toString !== Tl) {
    Sl(El, "toString", Tl);
  }
  var Cl = !B(function () {
    function e() {}
    e.prototype.constructor = null;
    return Object.getPrototypeOf(new e()) !== e.prototype;
  });
  var Al = kt;
  var Rl = xe;
  var _l = yt;
  var Ol = Cl;
  var Fl = Xn("IE_PROTO");
  var Dl = Object;
  var Ml = Dl.prototype;
  var Ll = Ol ? Dl.getPrototypeOf : function (e) {
    var t = _l(e);
    if (Al(t, Fl)) {
      return t[Fl];
    }
    var n = t.constructor;
    if (Rl(n) && t instanceof n) {
      return n.prototype;
    } else if (t instanceof Dl) {
      return Ml;
    } else {
      return null;
    }
  };
  var zl = {};
  var Pl = zl;
  var Bl = Mt("iterator");
  var Wl = Array.prototype;
  function Ul(e) {
    return e !== undefined && (Pl.Array === e || Wl[Bl] === e);
  }
  var Vl = qa;
  var Gl = et;
  var jl = le;
  var Hl = zl;
  var ql = Mt("iterator");
  function Kl(e) {
    if (!jl(e)) {
      return Gl(e, ql) || Gl(e, "@@iterator") || Hl[Vl(e)];
    }
  }
  var Xl = j;
  var Yl = Ze;
  var Jl = dn;
  var Zl = Ke;
  var Ql = Kl;
  var $l = TypeError;
  function eh(e, t) {
    var n = arguments.length < 2 ? Ql(e) : t;
    if (Yl(n)) {
      return Jl(Xl(n, e));
    }
    throw $l(Zl(e) + " is not iterable");
  }
  var th = j;
  var nh = dn;
  var rh = et;
  function ah(e, t, n) {
    var r;
    var a;
    nh(e);
    try {
      if (!(r = rh(e, "return"))) {
        if (t === "throw") {
          throw n;
        }
        return n;
      }
      r = th(r, e);
    } catch (e) {
      a = true;
      r = e;
    }
    if (t === "throw") {
      throw n;
    }
    if (a) {
      throw r;
    }
    nh(r);
    return n;
  }
  var ih = so;
  var oh = j;
  var sh = dn;
  var uh = Ke;
  var ch = Ul;
  var lh = Kr;
  var hh = Ce;
  var ph = eh;
  var fh = Kl;
  var dh = ah;
  var vh = TypeError;
  function mh(e, t) {
    this.stopped = e;
    this.result = t;
  }
  var gh = mh.prototype;
  function yh(e, t, n) {
    var r;
    var a;
    var i;
    var o;
    var u;
    var c;
    var l;
    var h = n && n.that;
    var p = !!n && !!n.AS_ENTRIES;
    var f = !!n && !!n.IS_RECORD;
    var d = !!n && !!n.IS_ITERATOR;
    var v = !!n && !!n.INTERRUPTED;
    var m = ih(t, h);
    function g(e) {
      if (r) {
        dh(r, "normal", e);
      }
      return new mh(true, e);
    }
    function y(e) {
      if (p) {
        sh(e);
        if (v) {
          return m(e[0], e[1], g);
        } else {
          return m(e[0], e[1]);
        }
      } else if (v) {
        return m(e, g);
      } else {
        return m(e);
      }
    }
    if (f) {
      r = e.iterator;
    } else if (d) {
      r = e;
    } else {
      if (!(a = fh(e))) {
        throw vh(uh(e) + " is not iterable");
      }
      if (ch(a)) {
        i = 0;
        o = lh(e);
        for (; o > i; i++) {
          if ((u = y(e[i])) && hh(gh, u)) {
            return u;
          }
        }
        return new mh(false);
      }
      r = ph(e, a);
    }
    for (c = f ? e.next : r.next; !(l = oh(c, r)).done;) {
      try {
        u = y(l.value);
      } catch (e) {
        dh(r, "throw", e);
      }
      if (s(u) == "object" && u && hh(gh, u)) {
        return u;
      }
    }
    return new mh(false);
  }
  var bh = La;
  var xh = Ce;
  var kh = Ll;
  var wh = Tc;
  var Ih = ba;
  var Nh = yi;
  var Sh = Cn;
  var Th = Y;
  var Eh = zc;
  var Ch = Jc;
  var Ah = yh;
  var Rh = Dc;
  var _h = Mt("toStringTag");
  var Oh = Error;
  var Fh = [].push;
  function Dh(e, t) {
    var n;
    var r = xh(Mh, this);
    if (wh) {
      n = wh(Oh(), r ? kh(this) : Mh);
    } else {
      n = r ? this : Nh(Mh);
      Sh(n, _h, "Error");
    }
    if (t !== undefined) {
      Sh(n, "message", Rh(t));
    }
    Ch(n, Dh, n.stack, 1);
    if (arguments.length > 2) {
      Eh(n, arguments[2]);
    }
    var a = [];
    Ah(e, Fh, {
      that: a
    });
    Sh(n, "errors", a);
    return n;
  }
  if (wh) {
    wh(Dh, Oh);
  } else {
    Ih(Dh, Oh, {
      name: true
    });
  }
  var Mh = Dh.prototype = Nh(Oh.prototype, {
    constructor: Th(1, Dh),
    message: Th(1, ""),
    name: Th(1, "AggregateError")
  });
  bh({
    global: true,
    constructor: true,
    arity: 2
  }, {
    AggregateError: Dh
  });
  var Lh = La;
  var zh = fu;
  var Ph = B;
  var Bh = cl;
  var Wh = "AggregateError";
  var Uh = Ee(Wh);
  var Vh = !Ph(function () {
    return Uh([1]).errors[0] !== 1;
  }) && Ph(function () {
    return Uh([1], Wh, {
      cause: 7
    }).cause !== 7;
  });
  Lh({
    global: true,
    constructor: true,
    arity: 2,
    forced: Vh
  }, {
    AggregateError: Bh(Wh, function (e) {
      return function (t, n) {
        return zh(e, this, arguments);
      };
    }, Vh, true)
  });
  var Gh = Mt;
  var jh = yi;
  var Hh = cn.f;
  var qh = Gh("unscopables");
  var Kh = Array.prototype;
  if (Kh[qh] == null) {
    Hh(Kh, qh, {
      configurable: true,
      value: jh(null)
    });
  }
  function Xh(e) {
    Kh[qh][e] = true;
  }
  var Yh = yt;
  var Jh = Kr;
  var Zh = Pr;
  var Qh = Xh;
  La({
    target: "Array",
    proto: true
  }, {
    at: function (e) {
      var t = Yh(this);
      var n = Jh(t);
      var r = Zh(e);
      var a = r >= 0 ? r : n + r;
      if (a < 0 || a >= n) {
        return undefined;
      } else {
        return t[a];
      }
    }
  });
  Qh("at");
  var $h = TypeError;
  function ep(e) {
    if (e > 9007199254740991) {
      throw $h("Maximum allowed index exceeded");
    }
    return e;
  }
  var tp = B;
  var np = Le;
  var rp = Mt("species");
  function ap(e) {
    return np >= 51 || !tp(function () {
      var t = [];
      (t.constructor = {})[rp] = function () {
        return {
          foo: 1
        };
      };
      return t[e](Boolean).foo !== 1;
    });
  }
  var ip = La;
  var op = B;
  var sp = co;
  var up = Ie;
  var cp = yt;
  var lp = Kr;
  var hp = ep;
  var pp = Ii;
  var fp = Oo;
  var dp = ap;
  var vp = Le;
  var mp = Mt("isConcatSpreadable");
  var gp = vp >= 51 || !op(function () {
    var e = [];
    e[mp] = false;
    return e.concat()[0] !== e;
  });
  function yp(e) {
    if (!up(e)) {
      return false;
    }
    var t = e[mp];
    if (t !== undefined) {
      return !!t;
    } else {
      return sp(e);
    }
  }
  ip({
    target: "Array",
    proto: true,
    arity: 1,
    forced: !gp || !dp("concat")
  }, {
    concat: function (e) {
      var t;
      var n;
      var r;
      var a;
      var i;
      var o = cp(this);
      var s = fp(o, 0);
      var u = 0;
      t = -1;
      r = arguments.length;
      for (; t < r; t++) {
        if (yp(i = t === -1 ? o : arguments[t])) {
          a = lp(i);
          hp(u + a);
          n = 0;
          for (; n < a; n++, u++) {
            if (n in i) {
              pp(s, u, i[n]);
            }
          }
        } else {
          hp(u + 1);
          pp(s, u++, i);
        }
      }
      s.length = u;
      return s;
    }
  });
  var bp = Ke;
  var xp = TypeError;
  function kp(e, t) {
    if (!delete e[t]) {
      throw xp("Cannot delete property " + bp(t) + " of " + bp(e));
    }
  }
  var wp = yt;
  var Ip = Vr;
  var Np = Kr;
  var Sp = kp;
  var Tp = Math.min;
  var Ep = [].copyWithin || function (e, t) {
    var n = wp(this);
    var r = Np(n);
    var a = Ip(e, r);
    var i = Ip(t, r);
    var o = arguments.length > 2 ? arguments[2] : undefined;
    var s = Tp((o === undefined ? r : Ip(o, r)) - i, r - a);
    var u = 1;
    for (i < a && a < i + s && (u = -1, i += s - 1, a += s - 1); s-- > 0;) {
      if (i in n) {
        n[a] = n[i];
      } else {
        Sp(n, a);
      }
      a += u;
      i += u;
    }
    return n;
  };
  var Cp = Xh;
  La({
    target: "Array",
    proto: true
  }, {
    copyWithin: Ep
  });
  Cp("copyWithin");
  var Ap = B;
  function Rp(e, t) {
    var n = [][e];
    return !!n && Ap(function () {
      n.call(null, t || function () {
        return 1;
      }, 1);
    });
  }
  var _p = Wo.every;
  La({
    target: "Array",
    proto: true,
    forced: !Rp("every")
  }, {
    every: function (e) {
      return _p(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var Op = yt;
  var Fp = Vr;
  var Dp = Kr;
  function Mp(e) {
    var t = Op(this);
    var n = Dp(t);
    var r = arguments.length;
    for (var a = Fp(r > 1 ? arguments[1] : undefined, n), i = r > 2 ? arguments[2] : undefined, o = i === undefined ? n : Fp(i, n); o > a;) {
      t[a++] = e;
    }
    return t;
  }
  var Lp = Xh;
  La({
    target: "Array",
    proto: true
  }, {
    fill: Mp
  });
  Lp("fill");
  var zp = Wo.filter;
  La({
    target: "Array",
    proto: true,
    forced: !ap("filter")
  }, {
    filter: function (e) {
      return zp(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var Pp = La;
  var Bp = Wo.find;
  var Wp = Xh;
  var Up = "find";
  var Vp = true;
  if (Up in []) {
    Array(1).find(function () {
      Vp = false;
    });
  }
  Pp({
    target: "Array",
    proto: true,
    forced: Vp
  }, {
    find: function (e) {
      return Bp(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  Wp(Up);
  var Gp = La;
  var jp = Wo.findIndex;
  var Hp = Xh;
  var qp = "findIndex";
  var Kp = true;
  if (qp in []) {
    Array(1).findIndex(function () {
      Kp = false;
    });
  }
  Gp({
    target: "Array",
    proto: true,
    forced: Kp
  }, {
    findIndex: function (e) {
      return jp(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  Hp(qp);
  var Xp = so;
  var Yp = ce;
  var Jp = yt;
  var Zp = Kr;
  function Qp(e) {
    var t = e == 1;
    return function (n, r, a) {
      var i;
      var o = Jp(n);
      var s = Yp(o);
      var u = Xp(r, a);
      for (var c = Zp(s); c-- > 0;) {
        if (u(i = s[c], c, o)) {
          switch (e) {
            case 0:
              return i;
            case 1:
              return c;
          }
        }
      }
      if (t) {
        return -1;
      } else {
        return undefined;
      }
    };
  }
  var $p = {
    findLast: Qp(0),
    findLastIndex: Qp(1)
  };
  var ef = $p.findLast;
  var tf = Xh;
  La({
    target: "Array",
    proto: true
  }, {
    findLast: function (e) {
      return ef(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  tf("findLast");
  var nf = $p.findLastIndex;
  var rf = Xh;
  La({
    target: "Array",
    proto: true
  }, {
    findLastIndex: function (e) {
      return nf(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  rf("findLastIndex");
  var af = co;
  var of = Kr;
  var sf = ep;
  var uf = so;
  var cf = function e(t, n, r, a, i, o, s, u) {
    for (var c, l = i, h = 0, p = !!s && uf(s, u); h < a;) {
      if (h in r) {
        c = p ? p(r[h], h, n) : r[h];
        if (o > 0 && af(c)) {
          l = e(t, n, c, of(c), l, o - 1) - 1;
        } else {
          sf(l + 1);
          t[l] = c;
        }
        l++;
      }
      h++;
    }
    return l;
  };
  var lf = cf;
  var hf = yt;
  var pf = Kr;
  var ff = Pr;
  var df = Oo;
  La({
    target: "Array",
    proto: true
  }, {
    flat: function () {
      var e = arguments.length ? arguments[0] : undefined;
      var t = hf(this);
      var n = pf(t);
      var r = df(t, 0);
      r.length = lf(r, t, t, n, 0, e === undefined ? 1 : ff(e));
      return r;
    }
  });
  var vf = cf;
  var mf = Ze;
  var gf = yt;
  var yf = Kr;
  var bf = Oo;
  La({
    target: "Array",
    proto: true
  }, {
    flatMap: function (e) {
      var t;
      var n = gf(this);
      var r = yf(n);
      mf(e);
      (t = bf(n, 0)).length = vf(t, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : undefined);
      return t;
    }
  });
  var xf = Wo.forEach;
  var kf = Rp("forEach") ? [].forEach : function (e) {
    return xf(this, e, arguments.length > 1 ? arguments[1] : undefined);
  };
  La({
    target: "Array",
    proto: true,
    forced: [].forEach != kf
  }, {
    forEach: kf
  });
  var wf = dn;
  var If = ah;
  function Nf(e, t, n, r) {
    try {
      if (r) {
        return t(wf(n)[0], n[1]);
      } else {
        return t(n);
      }
    } catch (t) {
      If(e, "throw", t);
    }
  }
  var Sf = so;
  var Tf = j;
  var Ef = yt;
  var Cf = Nf;
  var Af = Ul;
  var Rf = No;
  var _f = Kr;
  var Of = Ii;
  var Ff = eh;
  var Df = Kl;
  var Mf = Array;
  function Lf(e) {
    var t = Ef(e);
    var n = Rf(this);
    var r = arguments.length;
    var a = r > 1 ? arguments[1] : undefined;
    var i = a !== undefined;
    if (i) {
      a = Sf(a, r > 2 ? arguments[2] : undefined);
    }
    var o;
    var s;
    var u;
    var c;
    var l;
    var h;
    var p = Df(t);
    var f = 0;
    if (!p || this === Mf && Af(p)) {
      o = _f(t);
      s = n ? new this(o) : Mf(o);
      for (; o > f; f++) {
        h = i ? a(t[f], f) : t[f];
        Of(s, f, h);
      }
    } else {
      l = (c = Ff(t, p)).next;
      s = n ? new this() : [];
      for (; !(u = Tf(l, c)).done; f++) {
        h = i ? Cf(c, a, [u.value, f], true) : u.value;
        Of(s, f, h);
      }
    }
    s.length = f;
    return s;
  }
  var zf = Mt("iterator");
  var Pf = false;
  try {
    var Bf = 0;
    var Wf = {
      next: function () {
        return {
          done: !!Bf++
        };
      },
      return: function () {
        Pf = true;
      }
    };
    Wf[zf] = function () {
      return this;
    };
    Array.from(Wf, function () {
      throw 2;
    });
  } catch (e) {}
  function Uf(e, t) {
    if (!t && !Pf) {
      return false;
    }
    var n = false;
    try {
      var r = {
        [zf]: function () {
          return {
            next: function () {
              return {
                done: n = true
              };
            }
          };
        }
      };
      e(r);
    } catch (e) {}
    return n;
  }
  var Vf = Lf;
  La({
    target: "Array",
    stat: true,
    forced: !Uf(function (e) {
      Array.from(e);
    })
  }, {
    from: Vf
  });
  var Gf = Qr.includes;
  var jf = Xh;
  La({
    target: "Array",
    proto: true,
    forced: B(function () {
      return !Array(1).includes();
    })
  }, {
    includes: function (e) {
      return Gf(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  jf("includes");
  var Hf = La;
  var qf = Qr.indexOf;
  var Kf = Rp;
  var Xf = ro([].indexOf);
  var Yf = !!Xf && 1 / Xf([1], 1, -0) < 0;
  Hf({
    target: "Array",
    proto: true,
    forced: Yf || !Kf("indexOf")
  }, {
    indexOf: function (e, t) {
      if (Yf) {
        return Xf(this, e, t) || 0;
      } else {
        return qf(this, e, t);
      }
    }
  });
  La({
    target: "Array",
    stat: true
  }, {
    isArray: co
  });
  var Jf;
  var Zf;
  var Qf;
  var $f = B;
  var ed = xe;
  var td = Ie;
  var nd = Ll;
  var rd = Or;
  var ad = Mt("iterator");
  var id = false;
  if ([].keys) {
    if ("next" in (Qf = [].keys())) {
      if ((Zf = nd(nd(Qf))) !== Object.prototype) {
        Jf = Zf;
      }
    } else {
      id = true;
    }
  }
  var od = !td(Jf) || $f(function () {
    var e = {};
    return Jf[ad].call(e) !== e;
  });
  if (od) {
    Jf = {};
  }
  if (!ed(Jf[ad])) {
    rd(Jf, ad, function () {
      return this;
    });
  }
  var sd = {
    IteratorPrototype: Jf,
    BUGGY_SAFARI_ITERATORS: id
  };
  var ud = sd.IteratorPrototype;
  var cd = yi;
  var ld = Y;
  var hd = eo;
  var pd = zl;
  function fd() {
    return this;
  }
  function dd(e, t, n, r) {
    var a = t + " Iterator";
    e.prototype = cd(ud, {
      next: ld(+!r, n)
    });
    hd(e, a, false, true);
    pd[a] = fd;
    return e;
  }
  var vd = La;
  var md = j;
  var gd = xe;
  var yd = dd;
  var bd = Ll;
  var xd = Tc;
  var kd = eo;
  var wd = Cn;
  var Id = Or;
  var Nd = zl;
  var Sd = Mn.PROPER;
  var Td = Mn.CONFIGURABLE;
  var Ed = sd.IteratorPrototype;
  var Cd = sd.BUGGY_SAFARI_ITERATORS;
  var Ad = Mt("iterator");
  var Rd = "keys";
  var _d = "values";
  var Od = "entries";
  function Fd() {
    return this;
  }
  function Dd(e, t, n, r, a, i, o) {
    yd(n, t, r);
    var s;
    var u;
    var c;
    function l(e) {
      if (e === a && v) {
        return v;
      }
      if (!Cd && e in f) {
        return f[e];
      }
      switch (e) {
        case Rd:
        case _d:
        case Od:
          return function () {
            return new n(this, e);
          };
      }
      return function () {
        return new n(this);
      };
    }
    var h = t + " Iterator";
    var p = false;
    var f = e.prototype;
    var d = f[Ad] || f["@@iterator"] || a && f[a];
    var v = !Cd && d || l(a);
    var m = t == "Array" && f.entries || d;
    if (m && (s = bd(m.call(new e()))) !== Object.prototype && s.next) {
      if (bd(s) !== Ed) {
        if (xd) {
          xd(s, Ed);
        } else if (!gd(s[Ad])) {
          Id(s, Ad, Fd);
        }
      }
      kd(s, h, true, true);
    }
    if (Sd && a == _d && d && d.name !== _d) {
      if (Td) {
        wd(f, "name", _d);
      } else {
        p = true;
        v = function () {
          return md(d, this);
        };
      }
    }
    if (a) {
      u = {
        values: l(_d),
        keys: i ? v : l(Rd),
        entries: l(Od)
      };
      if (o) {
        for (c in u) {
          if (Cd || p || !(c in f)) {
            Id(f, c, u[c]);
          }
        }
      } else {
        vd({
          target: t,
          proto: true,
          forced: Cd || p
        }, u);
      }
    }
    if (f[Ad] !== v) {
      Id(f, Ad, v, {
        name: a
      });
    }
    Nd[t] = v;
    return u;
  }
  function Md(e, t) {
    return {
      value: e,
      done: t
    };
  }
  var Ld = me;
  var zd = Xh;
  var Pd = zl;
  var Bd = cr;
  var Wd = cn.f;
  var Ud = Dd;
  var Vd = Md;
  var Gd = W;
  var jd = "Array Iterator";
  var Hd = Bd.set;
  var qd = Bd.getterFor(jd);
  var Kd = Ud(Array, "Array", function (e, t) {
    Hd(this, {
      type: jd,
      target: Ld(e),
      index: 0,
      kind: t
    });
  }, function () {
    var e = qd(this);
    var t = e.target;
    var n = e.kind;
    var r = e.index++;
    if (!t || r >= t.length) {
      e.target = undefined;
      return Vd(undefined, true);
    } else {
      return Vd(n == "keys" ? r : n == "values" ? t[r] : [r, t[r]], false);
    }
  }, "values");
  var Xd = Pd.Arguments = Pd.Array;
  zd("keys");
  zd("values");
  zd("entries");
  if (Gd && Xd.name !== "values") {
    try {
      Wd(Xd, "name", {
        value: "values"
      });
    } catch (e) {}
  }
  var Yd = La;
  var Jd = ce;
  var Zd = me;
  var Qd = Rp;
  var $d = ee([].join);
  Yd({
    target: "Array",
    proto: true,
    forced: Jd != Object || !Qd("join", ",")
  }, {
    join: function (e) {
      return $d(Zd(this), e === undefined ? "," : e);
    }
  });
  var ev = fu;
  var tv = me;
  var nv = Pr;
  var rv = Kr;
  var av = Rp;
  var iv = Math.min;
  var ov = [].lastIndexOf;
  var sv = !!ov && 1 / [1].lastIndexOf(1, -0) < 0;
  var uv = av("lastIndexOf");
  var cv = sv || !uv ? function (e) {
    if (sv) {
      return ev(ov, this, arguments) || 0;
    }
    var t = tv(this);
    var n = rv(t);
    var r = n - 1;
    if (arguments.length > 1) {
      r = iv(r, nv(arguments[1]));
    }
    if (r < 0) {
      r = n + r;
    }
    for (; r >= 0; r--) {
      if (r in t && t[r] === e) {
        return r || 0;
      }
    }
    return -1;
  } : ov;
  La({
    target: "Array",
    proto: true,
    forced: cv !== [].lastIndexOf
  }, {
    lastIndexOf: cv
  });
  var lv = Wo.map;
  La({
    target: "Array",
    proto: true,
    forced: !ap("map")
  }, {
    map: function (e) {
      return lv(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var hv = No;
  var pv = Ii;
  var fv = Array;
  La({
    target: "Array",
    stat: true,
    forced: B(function () {
      function e() {}
      return !(fv.of.call(e) instanceof e);
    })
  }, {
    of: function () {
      for (var e = 0, t = arguments.length, n = new (hv(this) ? this : fv)(t); t > e;) {
        pv(n, e, arguments[e++]);
      }
      n.length = t;
      return n;
    }
  });
  var dv = W;
  var vv = co;
  var mv = TypeError;
  var gv = Object.getOwnPropertyDescriptor;
  var yv = dv && !function () {
    if (this !== undefined) {
      return true;
    }
    try {
      Object.defineProperty([], "length", {
        writable: false
      }).length = 1;
    } catch (e) {
      return e instanceof TypeError;
    }
  }() ? function (e, t) {
    if (vv(e) && !gv(e, "length").writable) {
      throw mv("Cannot set read only .length");
    }
    return e.length = t;
  } : function (e, t) {
    return e.length = t;
  };
  var bv = yt;
  var xv = Kr;
  var kv = yv;
  var wv = ep;
  La({
    target: "Array",
    proto: true,
    arity: 1,
    forced: B(function () {
      return [].push.call({
        length: 4294967296
      }, 1) !== 4294967297;
    }) || !function () {
      try {
        Object.defineProperty([], "length", {
          writable: false
        }).push();
      } catch (e) {
        return e instanceof TypeError;
      }
    }()
  }, {
    push: function (e) {
      var t = bv(this);
      var n = xv(t);
      var r = arguments.length;
      wv(n + r);
      for (var a = 0; a < r; a++) {
        t[n] = arguments[a];
        n++;
      }
      kv(t, n);
      return n;
    }
  });
  var Iv = Ze;
  var Nv = yt;
  var Sv = ce;
  var Tv = Kr;
  var Ev = TypeError;
  function Cv(e) {
    return function (t, n, r, a) {
      Iv(n);
      var i = Nv(t);
      var o = Sv(i);
      var s = Tv(i);
      var u = e ? s - 1 : 0;
      var c = e ? -1 : 1;
      if (r < 2) {
        while (true) {
          if (u in o) {
            a = o[u];
            u += c;
            break;
          }
          u += c;
          if (e ? u < 0 : s <= u) {
            throw Ev("Reduce of empty array with no initial value");
          }
        }
      }
      for (; e ? u >= 0 : s > u; u += c) {
        if (u in o) {
          a = n(a, o[u], u, i);
        }
      }
      return a;
    };
  }
  var Av = {
    left: Cv(false),
    right: Cv(true)
  };
  var Rv = typeof process != "undefined" && ae(process) == "process";
  var _v = Av.left;
  La({
    target: "Array",
    proto: true,
    forced: !Rv && Le > 79 && Le < 83 || !Rp("reduce")
  }, {
    reduce: function (e) {
      var t = arguments.length;
      return _v(this, e, t, t > 1 ? arguments[1] : undefined);
    }
  });
  var Ov = Av.right;
  La({
    target: "Array",
    proto: true,
    forced: !Rv && Le > 79 && Le < 83 || !Rp("reduceRight")
  }, {
    reduceRight: function (e) {
      return Ov(this, e, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var Fv = La;
  var Dv = co;
  var Mv = ee([].reverse);
  var Lv = [1, 2];
  Fv({
    target: "Array",
    proto: true,
    forced: String(Lv) === String(Lv.reverse())
  }, {
    reverse: function () {
      if (Dv(this)) {
        this.length = this.length;
      }
      return Mv(this);
    }
  });
  var zv = La;
  var Pv = co;
  var Bv = No;
  var Wv = Ie;
  var Uv = Vr;
  var Vv = Kr;
  var Gv = me;
  var jv = Ii;
  var Hv = Mt;
  var qv = du;
  var Kv = ap("slice");
  var Xv = Hv("species");
  var Yv = Array;
  var Jv = Math.max;
  zv({
    target: "Array",
    proto: true,
    forced: !Kv
  }, {
    slice: function (e, t) {
      var n;
      var r;
      var a;
      var i = Gv(this);
      var o = Vv(i);
      var s = Uv(e, o);
      var u = Uv(t === undefined ? o : t, o);
      if (Pv(i) && (n = i.constructor, (Bv(n) && (n === Yv || Pv(n.prototype)) || Wv(n) && (n = n[Xv]) === null) && (n = undefined), n === Yv || n === undefined)) {
        return qv(i, s, u);
      }
      r = new (n === undefined ? Yv : n)(Jv(u - s, 0));
      a = 0;
      for (; s < u; s++, a++) {
        if (s in i) {
          jv(r, a, i[s]);
        }
      }
      r.length = a;
      return r;
    }
  });
  var Zv = Wo.some;
  La({
    target: "Array",
    proto: true,
    forced: !Rp("some")
  }, {
    some: function (e) {
      return Zv(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var Qv = Ai;
  var $v = Math.floor;
  function em(e, t) {
    var n;
    var r;
    for (var a = e.length, i = 1; i < a;) {
      r = i;
      n = e[i];
      while (r && t(e[r - 1], n) > 0) {
        e[r] = e[--r];
      }
      if (r !== i++) {
        e[r] = n;
      }
    }
    return e;
  }
  function tm(e, t, n, r) {
    for (var a = t.length, i = n.length, o = 0, s = 0; o < a || s < i;) {
      e[o + s] = o < a && s < i ? r(t[o], n[s]) <= 0 ? t[o++] : n[s++] : o < a ? t[o++] : n[s++];
    }
    return e;
  }
  var nm = function e(t, n) {
    var r = t.length;
    var a = $v(r / 2);
    if (r < 8) {
      return em(t, n);
    } else {
      return tm(t, e(Qv(t, 0, a), n), e(Qv(t, a), n), n);
    }
  };
  var rm = Ae.match(/firefox\/(\d+)/i);
  var am = !!rm && +rm[1];
  var im = /MSIE|Trident/.test(Ae);
  var om = Ae.match(/AppleWebKit\/(\d+)\./);
  var sm = !!om && +om[1];
  var um = La;
  var cm = ee;
  var lm = Ze;
  var hm = yt;
  var pm = Kr;
  var fm = kp;
  var dm = Ya;
  var vm = B;
  var mm = nm;
  var gm = Rp;
  var ym = am;
  var bm = im;
  var xm = Le;
  var km = sm;
  var wm = [];
  var Im = cm(wm.sort);
  var Nm = cm(wm.push);
  var Sm = vm(function () {
    wm.sort(undefined);
  });
  var Tm = vm(function () {
    wm.sort(null);
  });
  var Em = gm("sort");
  var Cm = !vm(function () {
    if (xm) {
      return xm < 70;
    }
    if (!ym || !(ym > 3)) {
      if (bm) {
        return true;
      }
      if (km) {
        return km < 603;
      }
      var e;
      var t;
      var n;
      var r;
      var a = "";
      for (e = 65; e < 76; e++) {
        t = String.fromCharCode(e);
        switch (e) {
          case 66:
          case 69:
          case 70:
          case 72:
            n = 3;
            break;
          case 68:
          case 71:
            n = 4;
            break;
          default:
            n = 2;
        }
        for (r = 0; r < 47; r++) {
          wm.push({
            k: t + r,
            v: n
          });
        }
      }
      wm.sort(function (e, t) {
        return t.v - e.v;
      });
      r = 0;
      for (; r < wm.length; r++) {
        t = wm[r].k.charAt(0);
        if (a.charAt(a.length - 1) !== t) {
          a += t;
        }
      }
      return a !== "DGBEFHACIJK";
    }
  });
  um({
    target: "Array",
    proto: true,
    forced: Sm || !Tm || !Em || !Cm
  }, {
    sort: function (e) {
      if (e !== undefined) {
        lm(e);
      }
      var t = hm(this);
      if (Cm) {
        if (e === undefined) {
          return Im(t);
        } else {
          return Im(t, e);
        }
      }
      var n;
      var r;
      var a = [];
      var i = pm(t);
      for (r = 0; r < i; r++) {
        if (r in t) {
          Nm(a, t[r]);
        }
      }
      mm(a, function (e) {
        return function (t, n) {
          if (n === undefined) {
            return -1;
          } else if (t === undefined) {
            return 1;
          } else if (e !== undefined) {
            return +e(t, n) || 0;
          } else if (dm(t) > dm(n)) {
            return 1;
          } else {
            return -1;
          }
        };
      }(e));
      n = pm(a);
      r = 0;
      while (r < n) {
        t[r] = a[r++];
      }
      while (r < i) {
        fm(t, r++);
      }
      return t;
    }
  });
  var Am = Ee;
  var Rm = zi;
  var _m = W;
  var Om = Mt("species");
  function Fm(e) {
    var t = Am(e);
    if (_m && t && !t[Om]) {
      Rm(t, Om, {
        configurable: true,
        get: function () {
          return this;
        }
      });
    }
  }
  Fm("Array");
  var Dm = La;
  var Mm = yt;
  var Lm = Vr;
  var zm = Pr;
  var Pm = Kr;
  var Bm = yv;
  var Wm = ep;
  var Um = Oo;
  var Vm = Ii;
  var Gm = kp;
  var jm = ap("splice");
  var Hm = Math.max;
  var qm = Math.min;
  Dm({
    target: "Array",
    proto: true,
    forced: !jm
  }, {
    splice: function (e, t) {
      var n;
      var r;
      var a;
      var i;
      var o;
      var s;
      var u = Mm(this);
      var c = Pm(u);
      var l = Lm(e, c);
      var h = arguments.length;
      if (h === 0) {
        n = r = 0;
      } else if (h === 1) {
        n = 0;
        r = c - l;
      } else {
        n = h - 2;
        r = qm(Hm(zm(t), 0), c - l);
      }
      Wm(c + n - r);
      a = Um(u, r);
      i = 0;
      for (; i < r; i++) {
        if ((o = l + i) in u) {
          Vm(a, i, u[o]);
        }
      }
      a.length = r;
      if (n < r) {
        for (i = l; i < c - r; i++) {
          s = i + n;
          if ((o = i + r) in u) {
            u[s] = u[o];
          } else {
            Gm(u, s);
          }
        }
        for (i = c; i > c - r + n; i--) {
          Gm(u, i - 1);
        }
      } else if (n > r) {
        for (i = c - r; i > l; i--) {
          s = i + n - 1;
          if ((o = i + r - 1) in u) {
            u[s] = u[o];
          } else {
            Gm(u, s);
          }
        }
      }
      for (i = 0; i < n; i++) {
        u[i + l] = arguments[i + 2];
      }
      Bm(u, c - r + n);
      return a;
    }
  });
  var Km = Kr;
  function Xm(e, t) {
    for (var n = Km(e), r = new t(n), a = 0; a < n; a++) {
      r[a] = e[n - a - 1];
    }
    return r;
  }
  var Ym = Xm;
  var Jm = me;
  var Zm = Xh;
  var Qm = Array;
  La({
    target: "Array",
    proto: true
  }, {
    toReversed: function () {
      return Ym(Jm(this), Qm);
    }
  });
  Zm("toReversed");
  var $m = Kr;
  function eg(e, t) {
    for (var n = 0, r = $m(t), a = new e(r); r > n;) {
      a[n] = t[n++];
    }
    return a;
  }
  var tg = z;
  function ng(e) {
    return tg[e].prototype;
  }
  var rg = La;
  var ag = Ze;
  var ig = me;
  var og = eg;
  var sg = Xh;
  var ug = Array;
  var cg = ee(ng("Array").sort);
  rg({
    target: "Array",
    proto: true
  }, {
    toSorted: function (e) {
      if (e !== undefined) {
        ag(e);
      }
      var t = ig(this);
      var n = og(ug, t);
      return cg(n, e);
    }
  });
  sg("toSorted");
  var lg = La;
  var hg = Xh;
  var pg = ep;
  var fg = Kr;
  var dg = Vr;
  var vg = me;
  var mg = Pr;
  var gg = Array;
  var yg = Math.max;
  var bg = Math.min;
  lg({
    target: "Array",
    proto: true
  }, {
    toSpliced: function (e, t) {
      var n;
      var r;
      var a;
      var i;
      var o = vg(this);
      var s = fg(o);
      var u = dg(e, s);
      var c = arguments.length;
      var l = 0;
      if (c === 0) {
        n = r = 0;
      } else if (c === 1) {
        n = 0;
        r = s - u;
      } else {
        n = c - 2;
        r = bg(yg(mg(t), 0), s - u);
      }
      a = pg(s + n - r);
      i = gg(a);
      for (; l < u; l++) {
        i[l] = o[l];
      }
      for (; l < u + n; l++) {
        i[l] = arguments[l - u + 2];
      }
      for (; l < a; l++) {
        i[l] = o[l + r - n];
      }
      return i;
    }
  });
  hg("toSpliced");
  Xh("flat");
  Xh("flatMap");
  var xg = yt;
  var kg = Kr;
  var wg = yv;
  var Ig = kp;
  var Ng = ep;
  La({
    target: "Array",
    proto: true,
    arity: 1,
    forced: [].unshift(0) !== 1 || !function () {
      try {
        Object.defineProperty([], "length", {
          writable: false
        }).unshift();
      } catch (e) {
        return e instanceof TypeError;
      }
    }()
  }, {
    unshift: function (e) {
      var t = xg(this);
      var n = kg(t);
      var r = arguments.length;
      if (r) {
        Ng(n + r);
        for (var a = n; a--;) {
          var i = a + r;
          if (a in t) {
            t[i] = t[a];
          } else {
            Ig(t, i);
          }
        }
        for (var o = 0; o < r; o++) {
          t[o] = arguments[o];
        }
      }
      return wg(t, n + r);
    }
  });
  var Sg = Kr;
  var Tg = Pr;
  var Eg = RangeError;
  function Cg(e, t, n, r) {
    var a = Sg(e);
    var i = Tg(n);
    var o = i < 0 ? a + i : i;
    if (o >= a || o < 0) {
      throw Eg("Incorrect index");
    }
    var s = new t(a);
    for (var u = 0; u < a; u++) {
      s[u] = u === o ? r : e[u];
    }
    return s;
  }
  var Ag = Cg;
  var Rg = me;
  var _g = Array;
  La({
    target: "Array",
    proto: true
  }, {
    with: function (e, t) {
      return Ag(Rg(this), _g, e, t);
    }
  });
  var Og = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
  var Fg = Or;
  function Dg(e, t, n) {
    for (var r in t) {
      Fg(e, r, t[r], n);
    }
    return e;
  }
  var Mg = Ce;
  var Lg = TypeError;
  function zg(e, t) {
    if (Mg(t, e)) {
      return e;
    }
    throw Lg("Incorrect invocation");
  }
  var Pg = Pr;
  var Bg = Hr;
  var Wg = RangeError;
  function Ug(e) {
    if (e === undefined) {
      return 0;
    }
    var t = Pg(e);
    var n = Bg(t);
    if (t !== n) {
      throw Wg("Wrong length or index");
    }
    return n;
  }
  var Vg = Array;
  var Gg = Math.abs;
  var jg = Math.pow;
  var Hg = Math.floor;
  var qg = Math.log;
  var Kg = Math.LN2;
  var Xg = {
    pack: function (e, t, n) {
      var r;
      var a;
      var i;
      var o = Vg(n);
      var s = n * 8 - t - 1;
      var u = (1 << s) - 1;
      var c = u >> 1;
      var l = t === 23 ? jg(2, -24) - jg(2, -77) : 0;
      var h = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      var p = 0;
      for ((e = Gg(e)) != e || e === Infinity ? (a = e != e ? 1 : 0, r = u) : (r = Hg(qg(e) / Kg), e * (i = jg(2, -r)) < 1 && (r--, i *= 2), (e += r + c >= 1 ? l / i : l * jg(2, 1 - c)) * i >= 2 && (r++, i /= 2), r + c >= u ? (a = 0, r = u) : r + c >= 1 ? (a = (e * i - 1) * jg(2, t), r += c) : (a = e * jg(2, c - 1) * jg(2, t), r = 0)); t >= 8;) {
        o[p++] = a & 255;
        a /= 256;
        t -= 8;
      }
      r = r << t | a;
      s += t;
      while (s > 0) {
        o[p++] = r & 255;
        r /= 256;
        s -= 8;
      }
      o[--p] |= h * 128;
      return o;
    },
    unpack: function (e, t) {
      var n;
      var r = e.length;
      var a = r * 8 - t - 1;
      var i = (1 << a) - 1;
      var o = i >> 1;
      var s = a - 7;
      var u = r - 1;
      var c = e[u--];
      var l = c & 127;
      for (c >>= 7; s > 0;) {
        l = l * 256 + e[u--];
        s -= 8;
      }
      n = l & (1 << -s) - 1;
      l >>= -s;
      s += t;
      while (s > 0) {
        n = n * 256 + e[u--];
        s -= 8;
      }
      if (l === 0) {
        l = 1 - o;
      } else {
        if (l === i) {
          if (n) {
            return NaN;
          } else if (c) {
            return -Infinity;
          } else {
            return Infinity;
          }
        }
        n += jg(2, t);
        l -= o;
      }
      return (c ? -1 : 1) * n * jg(2, l - t);
    }
  };
  var Yg = z;
  var Jg = ee;
  var Zg = W;
  var Qg = Og;
  var $g = Mn;
  var ey = Cn;
  var ty = zi;
  var ny = Dg;
  var ry = B;
  var ay = zg;
  var iy = Pr;
  var oy = Hr;
  var sy = Ug;
  var uy = Xg;
  var cy = Ll;
  var ly = Tc;
  var hy = Fr.f;
  var py = Mp;
  var fy = Ai;
  var dy = eo;
  var vy = cr;
  var my = $g.PROPER;
  var gy = $g.CONFIGURABLE;
  var yy = "ArrayBuffer";
  var by = "DataView";
  var xy = "Wrong index";
  var ky = vy.getterFor(yy);
  var wy = vy.getterFor(by);
  var Iy = vy.set;
  var Ny = Yg.ArrayBuffer;
  var Sy = Ny;
  var Ty = Sy && Sy.prototype;
  var Ey = Yg.DataView;
  var Cy = Ey && Ey.prototype;
  var Ay = Object.prototype;
  var Ry = Yg.Array;
  var _y = Yg.RangeError;
  var Oy = Jg(py);
  var Fy = Jg([].reverse);
  var Dy = uy.pack;
  var My = uy.unpack;
  function Ly(e) {
    return [e & 255];
  }
  function zy(e) {
    return [e & 255, e >> 8 & 255];
  }
  function Py(e) {
    return [e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255];
  }
  function By(e) {
    return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0];
  }
  function Wy(e) {
    return Dy(e, 23, 4);
  }
  function Uy(e) {
    return Dy(e, 52, 8);
  }
  function Vy(e, t, n) {
    ty(e.prototype, t, {
      configurable: true,
      get: function () {
        return n(this)[t];
      }
    });
  }
  function Gy(e, t, n, r) {
    var a = sy(n);
    var i = wy(e);
    if (a + t > i.byteLength) {
      throw _y(xy);
    }
    var o = i.bytes;
    var s = a + i.byteOffset;
    var u = fy(o, s, s + t);
    if (r) {
      return u;
    } else {
      return Fy(u);
    }
  }
  function jy(e, t, n, r, a, i) {
    var o = sy(n);
    var s = wy(e);
    if (o + t > s.byteLength) {
      throw _y(xy);
    }
    var u = s.bytes;
    var c = o + s.byteOffset;
    var l = r(+a);
    for (var h = 0; h < t; h++) {
      u[c + h] = l[i ? h : t - h - 1];
    }
  }
  if (Qg) {
    var Hy = my && Ny.name !== yy;
    if (ry(function () {
      Ny(1);
    }) && ry(function () {
      new Ny(-1);
    }) && !ry(function () {
      new Ny();
      new Ny(1.5);
      new Ny(NaN);
      return Ny.length != 1 || Hy && !gy;
    })) {
      if (Hy && gy) {
        ey(Ny, "name", yy);
      }
    } else {
      (Sy = function (e) {
        ay(this, Ty);
        return new Ny(sy(e));
      }).prototype = Ty;
      var qy;
      for (var Ky = hy(Ny), Xy = 0; Ky.length > Xy;) {
        if (!((qy = Ky[Xy++]) in Sy)) {
          ey(Sy, qy, Ny[qy]);
        }
      }
      Ty.constructor = Sy;
    }
    if (ly && cy(Cy) !== Ay) {
      ly(Cy, Ay);
    }
    var Yy = new Ey(new Sy(2));
    var Jy = Jg(Cy.setInt8);
    Yy.setInt8(0, 2147483648);
    Yy.setInt8(1, 2147483649);
    if (!!Yy.getInt8(0) || !Yy.getInt8(1)) {
      ny(Cy, {
        setInt8: function (e, t) {
          Jy(this, e, t << 24 >> 24);
        },
        setUint8: function (e, t) {
          Jy(this, e, t << 24 >> 24);
        }
      }, {
        unsafe: true
      });
    }
  } else {
    Ty = (Sy = function (e) {
      ay(this, Ty);
      var t = sy(e);
      Iy(this, {
        type: yy,
        bytes: Oy(Ry(t), 0),
        byteLength: t
      });
      if (!Zg) {
        this.byteLength = t;
        this.detached = false;
      }
    }).prototype;
    Ey = function (e, t, n) {
      ay(this, Cy);
      ay(e, Ty);
      var r = ky(e);
      var a = r.byteLength;
      var i = iy(t);
      if (i < 0 || i > a) {
        throw _y("Wrong offset");
      }
      if (i + (n = n === undefined ? a - i : oy(n)) > a) {
        throw _y("Wrong length");
      }
      Iy(this, {
        type: by,
        buffer: e,
        byteLength: n,
        byteOffset: i,
        bytes: r.bytes
      });
      if (!Zg) {
        this.buffer = e;
        this.byteLength = n;
        this.byteOffset = i;
      }
    };
    Cy = Ey.prototype;
    if (Zg) {
      Vy(Sy, "byteLength", ky);
      Vy(Ey, "buffer", wy);
      Vy(Ey, "byteLength", wy);
      Vy(Ey, "byteOffset", wy);
    }
    ny(Cy, {
      getInt8: function (e) {
        return Gy(this, 1, e)[0] << 24 >> 24;
      },
      getUint8: function (e) {
        return Gy(this, 1, e)[0];
      },
      getInt16: function (e) {
        var t = Gy(this, 2, e, arguments.length > 1 ? arguments[1] : undefined);
        return (t[1] << 8 | t[0]) << 16 >> 16;
      },
      getUint16: function (e) {
        var t = Gy(this, 2, e, arguments.length > 1 ? arguments[1] : undefined);
        return t[1] << 8 | t[0];
      },
      getInt32: function (e) {
        return By(Gy(this, 4, e, arguments.length > 1 ? arguments[1] : undefined));
      },
      getUint32: function (e) {
        return By(Gy(this, 4, e, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
      },
      getFloat32: function (e) {
        return My(Gy(this, 4, e, arguments.length > 1 ? arguments[1] : undefined), 23);
      },
      getFloat64: function (e) {
        return My(Gy(this, 8, e, arguments.length > 1 ? arguments[1] : undefined), 52);
      },
      setInt8: function (e, t) {
        jy(this, 1, e, Ly, t);
      },
      setUint8: function (e, t) {
        jy(this, 1, e, Ly, t);
      },
      setInt16: function (e, t) {
        jy(this, 2, e, zy, t, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint16: function (e, t) {
        jy(this, 2, e, zy, t, arguments.length > 2 ? arguments[2] : undefined);
      },
      setInt32: function (e, t) {
        jy(this, 4, e, Py, t, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint32: function (e, t) {
        jy(this, 4, e, Py, t, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat32: function (e, t) {
        jy(this, 4, e, Wy, t, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat64: function (e, t) {
        jy(this, 8, e, Uy, t, arguments.length > 2 ? arguments[2] : undefined);
      }
    });
  }
  dy(Sy, yy);
  dy(Ey, by);
  var Zy = {
    ArrayBuffer: Sy,
    DataView: Ey
  };
  var Qy = Fm;
  var $y = "ArrayBuffer";
  var eb = Zy.ArrayBuffer;
  La({
    global: true,
    constructor: true,
    forced: z.ArrayBuffer !== eb
  }, {
    ArrayBuffer: eb
  });
  Qy($y);
  var tb;
  var nb;
  var rb;
  var ab = Og;
  var ib = W;
  var ob = z;
  var sb = xe;
  var ub = Ie;
  var cb = kt;
  var lb = qa;
  var hb = Ke;
  var pb = Cn;
  var fb = Or;
  var db = zi;
  var vb = Ce;
  var mb = Ll;
  var gb = Tc;
  var yb = Mt;
  var bb = Tt;
  var xb = cr.enforce;
  var kb = cr.get;
  var wb = ob.Int8Array;
  var Ib = wb && wb.prototype;
  var Nb = ob.Uint8ClampedArray;
  var Sb = Nb && Nb.prototype;
  var Tb = wb && mb(wb);
  var Eb = Ib && mb(Ib);
  var Cb = Object.prototype;
  var Ab = ob.TypeError;
  var Rb = yb("toStringTag");
  var _b = bb("TYPED_ARRAY_TAG");
  var Ob = "TypedArrayConstructor";
  var Fb = ab && !!gb && lb(ob.opera) !== "Opera";
  var Db = false;
  var Mb = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  };
  var Lb = {
    BigInt64Array: 8,
    BigUint64Array: 8
  };
  function zb(e) {
    if (!ub(e)) {
      return false;
    }
    var t = lb(e);
    return cb(Mb, t) || cb(Lb, t);
  }
  for (tb in Mb) {
    if (rb = (nb = ob[tb]) && nb.prototype) {
      xb(rb).TypedArrayConstructor = nb;
    } else {
      Fb = false;
    }
  }
  for (tb in Lb) {
    if (rb = (nb = ob[tb]) && nb.prototype) {
      xb(rb).TypedArrayConstructor = nb;
    }
  }
  if ((!Fb || !sb(Tb) || Tb === Function.prototype) && (Tb = function () {
    throw Ab("Incorrect invocation");
  }, Fb)) {
    for (tb in Mb) {
      if (ob[tb]) {
        gb(ob[tb], Tb);
      }
    }
  }
  if ((!Fb || !Eb || Eb === Cb) && (Eb = Tb.prototype, Fb)) {
    for (tb in Mb) {
      if (ob[tb]) {
        gb(ob[tb].prototype, Eb);
      }
    }
  }
  if (Fb && mb(Sb) !== Eb) {
    gb(Sb, Eb);
  }
  if (ib && !cb(Eb, Rb)) {
    Db = true;
    db(Eb, Rb, {
      configurable: true,
      get: function () {
        if (ub(this)) {
          return this[_b];
        } else {
          return undefined;
        }
      }
    });
    for (tb in Mb) {
      if (ob[tb]) {
        pb(ob[tb], _b, tb);
      }
    }
  }
  var Pb = {
    NATIVE_ARRAY_BUFFER_VIEWS: Fb,
    TYPED_ARRAY_TAG: Db && _b,
    aTypedArray: function (e) {
      if (zb(e)) {
        return e;
      }
      throw Ab("Target is not a typed array");
    },
    aTypedArrayConstructor: function (e) {
      if (sb(e) && (!gb || vb(Tb, e))) {
        return e;
      }
      throw Ab(hb(e) + " is not a typed array constructor");
    },
    exportTypedArrayMethod: function (e, t, n, r) {
      if (ib) {
        if (n) {
          for (var a in Mb) {
            var i = ob[a];
            if (i && cb(i.prototype, e)) {
              try {
                delete i.prototype[e];
              } catch (n) {
                try {
                  i.prototype[e] = t;
                } catch (e) {}
              }
            }
          }
        }
        if (!Eb[e] || !!n) {
          fb(Eb, e, n ? t : Fb && Ib[e] || t, r);
        }
      }
    },
    exportTypedArrayStaticMethod: function (e, t, n) {
      var r;
      var a;
      if (ib) {
        if (gb) {
          if (n) {
            for (r in Mb) {
              if ((a = ob[r]) && cb(a, e)) {
                try {
                  delete a[e];
                } catch (e) {}
              }
            }
          }
          if (Tb[e] && !n) {
            return;
          }
          try {
            return fb(Tb, e, n ? t : Fb && Tb[e] || t);
          } catch (e) {}
        }
        for (r in Mb) {
          if (!!(a = ob[r]) && (!a[e] || !!n)) {
            fb(a, e, t);
          }
        }
      }
    },
    getTypedArrayConstructor: function e(t) {
      var n = mb(t);
      if (ub(n)) {
        var r = kb(n);
        if (r && cb(r, Ob)) {
          return r.TypedArrayConstructor;
        } else {
          return e(n);
        }
      }
    },
    isView: function (e) {
      if (!ub(e)) {
        return false;
      }
      var t = lb(e);
      return t === "DataView" || cb(Mb, t) || cb(Lb, t);
    },
    isTypedArray: zb,
    TypedArray: Tb,
    TypedArrayPrototype: Eb
  };
  La({
    target: "ArrayBuffer",
    stat: true,
    forced: !Pb.NATIVE_ARRAY_BUFFER_VIEWS
  }, {
    isView: Pb.isView
  });
  var Bb = No;
  var Wb = Ke;
  var Ub = TypeError;
  function Vb(e) {
    if (Bb(e)) {
      return e;
    }
    throw Ub(Wb(e) + " is not a constructor");
  }
  var Gb = dn;
  var jb = Vb;
  var Hb = le;
  var qb = Mt("species");
  function Kb(e, t) {
    var n;
    var r = Gb(e).constructor;
    if (r === undefined || Hb(n = Gb(r)[qb])) {
      return t;
    } else {
      return jb(n);
    }
  }
  var Xb = La;
  var Yb = ro;
  var Jb = B;
  var Zb = dn;
  var Qb = Vr;
  var $b = Hr;
  var ex = Kb;
  var tx = Zy.ArrayBuffer;
  var nx = Zy.DataView;
  var rx = nx.prototype;
  var ax = Yb(tx.prototype.slice);
  var ix = Yb(rx.getUint8);
  var ox = Yb(rx.setUint8);
  Xb({
    target: "ArrayBuffer",
    proto: true,
    unsafe: true,
    forced: Jb(function () {
      return !new tx(2).slice(1, undefined).byteLength;
    })
  }, {
    slice: function (e, t) {
      if (ax && t === undefined) {
        return ax(Zb(this), e);
      }
      var n = Zb(this).byteLength;
      for (var r = Qb(e, n), a = Qb(t === undefined ? n : t, n), i = new (ex(this, tx))($b(a - r)), o = new nx(this), s = new nx(i), u = 0; r < a;) {
        ox(s, u++, ix(o, r++));
      }
      return i;
    }
  });
  La({
    global: true,
    constructor: true,
    forced: !Og
  }, {
    DataView: Zy.DataView
  });
  var sx = La;
  var ux = ee;
  var cx = B(function () {
    return new Date(1600000000000).getYear() !== 120;
  });
  var lx = ux(Date.prototype.getFullYear);
  sx({
    target: "Date",
    proto: true,
    forced: cx
  }, {
    getYear: function () {
      return lx(this) - 1900;
    }
  });
  var hx = La;
  var px = Date;
  var fx = ee(px.prototype.getTime);
  hx({
    target: "Date",
    stat: true
  }, {
    now: function () {
      return fx(new px());
    }
  });
  var dx = La;
  var vx = ee;
  var mx = Pr;
  var gx = Date.prototype;
  var yx = vx(gx.getTime);
  var bx = vx(gx.setFullYear);
  dx({
    target: "Date",
    proto: true
  }, {
    setYear: function (e) {
      yx(this);
      var t = mx(e);
      return bx(this, t >= 0 && t <= 99 ? t + 1900 : t);
    }
  });
  La({
    target: "Date",
    proto: true
  }, {
    toGMTString: Date.prototype.toUTCString
  });
  var xx = Pr;
  var kx = Ya;
  var wx = fe;
  var Ix = RangeError;
  function Nx(e) {
    var t = kx(wx(this));
    var n = "";
    var r = xx(e);
    if (r < 0 || r == Infinity) {
      throw Ix("Wrong number of repetitions");
    }
    for (; r > 0; (r >>>= 1) && (t += t)) {
      if (r & 1) {
        n += t;
      }
    }
    return n;
  }
  var Sx = ee;
  var Tx = Hr;
  var Ex = Ya;
  var Cx = fe;
  var Ax = Sx(Nx);
  var Rx = Sx("".slice);
  var _x = Math.ceil;
  function Ox(e) {
    return function (t, n, r) {
      var a;
      var i;
      var o = Ex(Cx(t));
      var s = Tx(n);
      var u = o.length;
      var c = r === undefined ? " " : Ex(r);
      if (s <= u || c == "") {
        return o;
      } else {
        if ((i = Ax(c, _x((a = s - u) / c.length))).length > a) {
          i = Rx(i, 0, a);
        }
        if (e) {
          return o + i;
        } else {
          return i + o;
        }
      }
    };
  }
  var Fx = {
    start: Ox(false),
    end: Ox(true)
  };
  var Dx = ee;
  var Mx = B;
  var Lx = Fx.start;
  var zx = RangeError;
  var Px = isFinite;
  var Bx = Math.abs;
  var Wx = Date.prototype;
  var Ux = Wx.toISOString;
  var Vx = Dx(Wx.getTime);
  var Gx = Dx(Wx.getUTCDate);
  var jx = Dx(Wx.getUTCFullYear);
  var Hx = Dx(Wx.getUTCHours);
  var qx = Dx(Wx.getUTCMilliseconds);
  var Kx = Dx(Wx.getUTCMinutes);
  var Xx = Dx(Wx.getUTCMonth);
  var Yx = Dx(Wx.getUTCSeconds);
  var Jx = Mx(function () {
    return Ux.call(new Date(-50000000000001)) != "0385-07-25T07:06:39.999Z";
  }) || !Mx(function () {
    Ux.call(new Date(NaN));
  }) ? function () {
    if (!Px(Vx(this))) {
      throw zx("Invalid time value");
    }
    var e = this;
    var t = jx(e);
    var n = qx(e);
    var r = t < 0 ? "-" : t > 9999 ? "+" : "";
    return r + Lx(Bx(t), r ? 6 : 4, 0) + "-" + Lx(Xx(e) + 1, 2, 0) + "-" + Lx(Gx(e), 2, 0) + "T" + Lx(Hx(e), 2, 0) + ":" + Lx(Kx(e), 2, 0) + ":" + Lx(Yx(e), 2, 0) + "." + Lx(n, 3, 0) + "Z";
  } : Ux;
  var Zx = Jx;
  La({
    target: "Date",
    proto: true,
    forced: Date.prototype.toISOString !== Zx
  }, {
    toISOString: Zx
  });
  var Qx = yt;
  var $x = Gt;
  La({
    target: "Date",
    proto: true,
    arity: 1,
    forced: B(function () {
      return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
        toISOString: function () {
          return 1;
        }
      }) !== 1;
    })
  }, {
    toJSON: function (e) {
      var t = Qx(this);
      var n = $x(t, "number");
      if (typeof n != "number" || isFinite(n)) {
        return t.toISOString();
      } else {
        return null;
      }
    }
  });
  var ek = dn;
  var tk = it;
  var nk = TypeError;
  function rk(e) {
    ek(this);
    if (e === "string" || e === "default") {
      e = "string";
    } else if (e !== "number") {
      throw nk("Incorrect hint");
    }
    return tk(this, e);
  }
  var ak = kt;
  var ik = Or;
  var ok = rk;
  var sk = Mt("toPrimitive");
  var uk = Date.prototype;
  if (!ak(uk, sk)) {
    ik(uk, sk, ok);
  }
  var ck = ee;
  var lk = Or;
  var hk = Date.prototype;
  var pk = "Invalid Date";
  var fk = "toString";
  var dk = ck(hk.toString);
  var vk = ck(hk.getTime);
  if (String(new Date(NaN)) != pk) {
    lk(hk, fk, function () {
      var e = vk(this);
      if (e == e) {
        return dk(this);
      } else {
        return pk;
      }
    });
  }
  var mk = La;
  var gk = ee;
  var yk = Ya;
  var bk = gk("".charAt);
  var xk = gk("".charCodeAt);
  var kk = gk(/./.exec);
  var wk = gk(1 .toString);
  var Ik = gk("".toUpperCase);
  var Nk = /[\w*+\-./@]/;
  function Sk(e, t) {
    for (var n = wk(e, 16); n.length < t;) {
      n = "0" + n;
    }
    return n;
  }
  mk({
    global: true
  }, {
    escape: function (e) {
      var t;
      var n;
      var r = yk(e);
      var a = "";
      for (var i = r.length, o = 0; o < i;) {
        t = bk(r, o++);
        if (kk(Nk, t)) {
          a += t;
        } else {
          a += (n = xk(t, 0)) < 256 ? "%" + Sk(n, 2) : "%u" + Ik(Sk(n, 4));
        }
      }
      return a;
    }
  });
  var Tk = ee;
  var Ek = Ze;
  var Ck = Ie;
  var Ak = kt;
  var Rk = du;
  var _k = U;
  var Ok = Function;
  var Fk = Tk([].concat);
  var Dk = Tk([].join);
  var Mk = {};
  function Lk(e, t, n) {
    if (!Ak(Mk, t)) {
      var r = [];
      for (var a = 0; a < t; a++) {
        r[a] = "a[" + a + "]";
      }
      Mk[t] = Ok("C,a", "return new C(" + Dk(r, ",") + ")");
    }
    return Mk[t](e, n);
  }
  var zk = _k ? Ok.bind : function (e) {
    var t = Ek(this);
    var n = t.prototype;
    var r = Rk(arguments, 1);
    function a() {
      var n = Fk(r, Rk(arguments));
      if (this instanceof a) {
        return Lk(t, n.length, n);
      } else {
        return t.apply(e, n);
      }
    }
    if (Ck(n)) {
      a.prototype = n;
    }
    return a;
  };
  var Pk = zk;
  La({
    target: "Function",
    proto: true,
    forced: Function.bind !== Pk
  }, {
    bind: Pk
  });
  var Bk = xe;
  var Wk = Ie;
  var Uk = cn;
  var Vk = Ll;
  var Gk = Er;
  var jk = Mt("hasInstance");
  var Hk = Function.prototype;
  if (!(jk in Hk)) {
    Uk.f(Hk, jk, {
      value: Gk(function (e) {
        if (!Bk(this) || !Wk(e)) {
          return false;
        }
        var t = this.prototype;
        if (!Wk(t)) {
          return e instanceof this;
        }
        while (e = Vk(e)) {
          if (t === e) {
            return true;
          }
        }
        return false;
      }, jk)
    });
  }
  var qk = W;
  var Kk = Mn.EXISTS;
  var Xk = ee;
  var Yk = zi;
  var Jk = Function.prototype;
  var Zk = Xk(Jk.toString);
  var Qk = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
  var $k = Xk(Qk.exec);
  if (qk && !Kk) {
    Yk(Jk, "name", {
      configurable: true,
      get: function () {
        try {
          return $k(Qk, Zk(this))[1];
        } catch (e) {
          return "";
        }
      }
    });
  }
  var ew = z;
  La({
    global: true,
    forced: ew.globalThis !== ew
  }, {
    globalThis: ew
  });
  eo(z.JSON, "JSON", true);
  var tw = {
    exports: {}
  };
  var nw = B(function () {
    if (typeof ArrayBuffer == "function") {
      var e = new ArrayBuffer(8);
      if (Object.isExtensible(e)) {
        Object.defineProperty(e, "a", {
          value: 8
        });
      }
    }
  });
  var rw = B;
  var aw = Ie;
  var iw = ae;
  var ow = nw;
  var sw = Object.isExtensible;
  var uw = rw(function () {
    sw(1);
  }) || ow ? function (e) {
    return !!aw(e) && (!ow || iw(e) != "ArrayBuffer") && (!sw || sw(e));
  } : sw;
  var cw = !B(function () {
    return Object.isExtensible(Object.preventExtensions({}));
  });
  tw.exports;
  var lw = La;
  var hw = ee;
  var pw = Yn;
  var fw = Ie;
  var dw = kt;
  var vw = cn.f;
  var mw = Fr;
  var gw = bi;
  var yw = uw;
  var bw = cw;
  var xw = false;
  var kw = Tt("meta");
  var ww = 0;
  function Iw(e) {
    vw(e, kw, {
      value: {
        objectID: "O" + ww++,
        weakData: {}
      }
    });
  }
  var Nw = tw.exports = {
    enable: function () {
      Nw.enable = function () {};
      xw = true;
      var e = mw.f;
      var t = hw([].splice);
      var n = {
        [kw]: 1
      };
      if (e(n).length) {
        mw.f = function (n) {
          var r = e(n);
          for (var a = 0, i = r.length; a < i; a++) {
            if (r[a] === kw) {
              t(r, a, 1);
              break;
            }
          }
          return r;
        };
        lw({
          target: "Object",
          stat: true,
          forced: true
        }, {
          getOwnPropertyNames: gw.f
        });
      }
    },
    fastKey: function (e, t) {
      if (!fw(e)) {
        if (s(e) == "symbol") {
          return e;
        } else {
          return (typeof e == "string" ? "S" : "P") + e;
        }
      }
      if (!dw(e, kw)) {
        if (!yw(e)) {
          return "F";
        }
        if (!t) {
          return "E";
        }
        Iw(e);
      }
      return e[kw].objectID;
    },
    getWeakData: function (e, t) {
      if (!dw(e, kw)) {
        if (!yw(e)) {
          return true;
        }
        if (!t) {
          return false;
        }
        Iw(e);
      }
      return e[kw].weakData;
    },
    onFreeze: function (e) {
      if (bw && xw && yw(e) && !dw(e, kw)) {
        Iw(e);
      }
      return e;
    }
  };
  pw[kw] = true;
  var Sw = tw.exports;
  var Tw = La;
  var Ew = z;
  var Cw = ee;
  var Aw = Ca;
  var Rw = Or;
  var _w = Sw;
  var Ow = yh;
  var Fw = zg;
  var Dw = xe;
  var Mw = le;
  var Lw = Ie;
  var zw = B;
  var Pw = Uf;
  var Bw = eo;
  var Ww = Oc;
  function Uw(e, t, n) {
    var r = e.indexOf("Map") !== -1;
    var a = e.indexOf("Weak") !== -1;
    var i = r ? "set" : "add";
    var o = Ew[e];
    var s = o && o.prototype;
    var u = o;
    var c = {};
    function l(e) {
      var t = Cw(s[e]);
      Rw(s, e, e == "add" ? function (e) {
        t(this, e === 0 ? 0 : e);
        return this;
      } : e == "delete" ? function (e) {
        return (!a || !!Lw(e)) && t(this, e === 0 ? 0 : e);
      } : e == "get" ? function (e) {
        if (a && !Lw(e)) {
          return undefined;
        } else {
          return t(this, e === 0 ? 0 : e);
        }
      } : e == "has" ? function (e) {
        return (!a || !!Lw(e)) && t(this, e === 0 ? 0 : e);
      } : function (e, n) {
        t(this, e === 0 ? 0 : e, n);
        return this;
      });
    }
    if (Aw(e, !Dw(o) || !a && (!s.forEach || !!zw(function () {
      new o().entries().next();
    })))) {
      u = n.getConstructor(t, e, r, i);
      _w.enable();
    } else if (Aw(e, true)) {
      var h = new u();
      var p = h[i](a ? {} : -0, 1) != h;
      var f = zw(function () {
        h.has(1);
      });
      var d = Pw(function (e) {
        new o(e);
      });
      var v = !a && zw(function () {
        var e = new o();
        for (var t = 5; t--;) {
          e[i](t, t);
        }
        return !e.has(-0);
      });
      if (!d) {
        (u = t(function (e, t) {
          Fw(e, s);
          var n = Ww(new o(), e, u);
          if (!Mw(t)) {
            Ow(t, n[i], {
              that: n,
              AS_ENTRIES: r
            });
          }
          return n;
        })).prototype = s;
        s.constructor = u;
      }
      if (f || v) {
        l("delete");
        l("has");
        if (r) {
          l("get");
        }
      }
      if (v || p) {
        l(i);
      }
      if (a && s.clear) {
        delete s.clear;
      }
    }
    c[e] = u;
    Tw({
      global: true,
      constructor: true,
      forced: u != o
    }, c);
    Bw(u, e);
    if (!a) {
      n.setStrong(u, e, r);
    }
    return u;
  }
  var Vw = yi;
  var Gw = zi;
  var jw = Dg;
  var Hw = so;
  var qw = zg;
  var Kw = le;
  var Xw = yh;
  var Yw = Dd;
  var Jw = Md;
  var Zw = Fm;
  var Qw = W;
  var $w = Sw.fastKey;
  var eI = cr.set;
  var tI = cr.getterFor;
  var nI = {
    getConstructor: function (e, t, n, r) {
      var a = e(function (e, a) {
        qw(e, i);
        eI(e, {
          type: t,
          index: Vw(null),
          first: undefined,
          last: undefined,
          size: 0
        });
        if (!Qw) {
          e.size = 0;
        }
        if (!Kw(a)) {
          Xw(a, e[r], {
            that: e,
            AS_ENTRIES: n
          });
        }
      });
      var i = a.prototype;
      var o = tI(t);
      function s(e, t, n) {
        var r;
        var a;
        var i = o(e);
        var s = u(e, t);
        if (s) {
          s.value = n;
        } else {
          i.last = s = {
            index: a = $w(t, true),
            key: t,
            value: n,
            previous: r = i.last,
            next: undefined,
            removed: false
          };
          i.first ||= s;
          if (r) {
            r.next = s;
          }
          if (Qw) {
            i.size++;
          } else {
            e.size++;
          }
          if (a !== "F") {
            i.index[a] = s;
          }
        }
        return e;
      }
      function u(e, t) {
        var n;
        var r = o(e);
        var a = $w(t);
        if (a !== "F") {
          return r.index[a];
        }
        for (n = r.first; n; n = n.next) {
          if (n.key == t) {
            return n;
          }
        }
      }
      jw(i, {
        clear: function () {
          var e = o(this);
          var t = e.index;
          for (var n = e.first; n;) {
            n.removed = true;
            n.previous &&= n.previous.next = undefined;
            delete t[n.index];
            n = n.next;
          }
          e.first = e.last = undefined;
          if (Qw) {
            e.size = 0;
          } else {
            this.size = 0;
          }
        },
        delete: function (e) {
          var t = this;
          var n = o(t);
          var r = u(t, e);
          if (r) {
            var a = r.next;
            var i = r.previous;
            delete n.index[r.index];
            r.removed = true;
            if (i) {
              i.next = a;
            }
            if (a) {
              a.previous = i;
            }
            if (n.first == r) {
              n.first = a;
            }
            if (n.last == r) {
              n.last = i;
            }
            if (Qw) {
              n.size--;
            } else {
              t.size--;
            }
          }
          return !!r;
        },
        forEach: function (e) {
          for (var t, n = o(this), r = Hw(e, arguments.length > 1 ? arguments[1] : undefined); t = t ? t.next : n.first;) {
            for (r(t.value, t.key, this); t && t.removed;) {
              t = t.previous;
            }
          }
        },
        has: function (e) {
          return !!u(this, e);
        }
      });
      jw(i, n ? {
        get: function (e) {
          var t = u(this, e);
          return t && t.value;
        },
        set: function (e, t) {
          return s(this, e === 0 ? 0 : e, t);
        }
      } : {
        add: function (e) {
          return s(this, e = e === 0 ? 0 : e, e);
        }
      });
      if (Qw) {
        Gw(i, "size", {
          configurable: true,
          get: function () {
            return o(this).size;
          }
        });
      }
      return a;
    },
    setStrong: function (e, t, n) {
      var r = t + " Iterator";
      var a = tI(t);
      var i = tI(r);
      Yw(e, t, function (e, t) {
        eI(this, {
          type: r,
          target: e,
          state: a(e),
          kind: t,
          last: undefined
        });
      }, function () {
        var e = i(this);
        var t = e.kind;
        for (var n = e.last; n && n.removed;) {
          n = n.previous;
        }
        if (e.target && (e.last = n = n ? n.next : e.state.first)) {
          return Jw(t == "keys" ? n.key : t == "values" ? n.value : [n.key, n.value], false);
        } else {
          e.target = undefined;
          return Jw(undefined, true);
        }
      }, n ? "entries" : "values", !n, true);
      Zw(t);
    }
  };
  Uw("Map", function (e) {
    return function () {
      return e(this, arguments.length ? arguments[0] : undefined);
    };
  }, nI);
  var rI = Math.log;
  var aI = Math.log1p || function (e) {
    var t = +e;
    if (t > -1e-8 && t < 1e-8) {
      return t - t * t / 2;
    } else {
      return rI(1 + t);
    }
  };
  var iI = La;
  var oI = aI;
  var sI = Math.acosh;
  var uI = Math.log;
  var cI = Math.sqrt;
  var lI = Math.LN2;
  iI({
    target: "Math",
    stat: true,
    forced: !sI || Math.floor(sI(Number.MAX_VALUE)) != 710 || sI(Infinity) != Infinity
  }, {
    acosh: function (e) {
      var t = +e;
      if (t < 1) {
        return NaN;
      } else if (t > 94906265.62425156) {
        return uI(t) + lI;
      } else {
        return oI(t - 1 + cI(t - 1) * cI(t + 1));
      }
    }
  });
  var hI = La;
  var pI = Math.asinh;
  var fI = Math.log;
  var dI = Math.sqrt;
  hI({
    target: "Math",
    stat: true,
    forced: !pI || !(1 / pI(0) > 0)
  }, {
    asinh: function e(t) {
      var n = +t;
      if (isFinite(n) && n != 0) {
        if (n < 0) {
          return -e(-n);
        } else {
          return fI(n + dI(n * n + 1));
        }
      } else {
        return n;
      }
    }
  });
  var vI = La;
  var mI = Math.atanh;
  var gI = Math.log;
  vI({
    target: "Math",
    stat: true,
    forced: !mI || !(1 / mI(-0) < 0)
  }, {
    atanh: function (e) {
      var t = +e;
      if (t == 0) {
        return t;
      } else {
        return gI((1 + t) / (1 - t)) / 2;
      }
    }
  });
  var yI = Math.sign || function (e) {
    var t = +e;
    if (t == 0 || t != t) {
      return t;
    } else if (t < 0) {
      return -1;
    } else {
      return 1;
    }
  };
  var bI = La;
  var xI = yI;
  var kI = Math.abs;
  var wI = Math.pow;
  bI({
    target: "Math",
    stat: true
  }, {
    cbrt: function (e) {
      var t = +e;
      return xI(t) * wI(kI(t), 1 / 3);
    }
  });
  var II = La;
  var NI = Math.floor;
  var SI = Math.log;
  var TI = Math.LOG2E;
  II({
    target: "Math",
    stat: true
  }, {
    clz32: function (e) {
      var t = e >>> 0;
      if (t) {
        return 31 - NI(SI(t + 0.5) * TI);
      } else {
        return 32;
      }
    }
  });
  var EI = Math.expm1;
  var CI = Math.exp;
  var AI = !EI || EI(10) > 22025.465794806718 || EI(10) < 22025.465794806718 || EI(-2e-17) != -2e-17 ? function (e) {
    var t = +e;
    if (t == 0) {
      return t;
    } else if (t > -0.000001 && t < 0.000001) {
      return t + t * t / 2;
    } else {
      return CI(t) - 1;
    }
  } : EI;
  var RI = La;
  var _I = AI;
  var OI = Math.cosh;
  var FI = Math.abs;
  var DI = Math.E;
  RI({
    target: "Math",
    stat: true,
    forced: !OI || OI(710) === Infinity
  }, {
    cosh: function (e) {
      var t = _I(FI(e) - 1) + 1;
      return (t + 1 / (t * DI * DI)) * (DI / 2);
    }
  });
  var MI = AI;
  La({
    target: "Math",
    stat: true,
    forced: MI != Math.expm1
  }, {
    expm1: MI
  });
  var LI = yI;
  var zI = Math.abs;
  var PI = Math.pow;
  var BI = PI(2, -52);
  var WI = PI(2, -23);
  var UI = PI(2, 127) * (2 - WI);
  var VI = PI(2, -126);
  var GI = Math.fround || function (e) {
    var t;
    var n;
    var r = +e;
    var a = zI(r);
    var i = LI(r);
    if (a < VI) {
      return i * function (e) {
        return e + 1 / BI - 1 / BI;
      }(a / VI / WI) * VI * WI;
    } else if ((n = (t = (1 + WI / BI) * a) - (t - a)) > UI || n != n) {
      return i * Infinity;
    } else {
      return i * n;
    }
  };
  La({
    target: "Math",
    stat: true
  }, {
    fround: GI
  });
  var jI = La;
  var HI = Math.hypot;
  var qI = Math.abs;
  var KI = Math.sqrt;
  jI({
    target: "Math",
    stat: true,
    arity: 2,
    forced: !!HI && HI(Infinity, NaN) !== Infinity
  }, {
    hypot: function (e, t) {
      for (var n, r, a = 0, i = 0, o = arguments.length, s = 0; i < o;) {
        if (s < (n = qI(arguments[i++]))) {
          a = a * (r = s / n) * r + 1;
          s = n;
        } else {
          a += n > 0 ? (r = n / s) * r : n;
        }
      }
      if (s === Infinity) {
        return Infinity;
      } else {
        return s * KI(a);
      }
    }
  });
  var XI = La;
  var YI = B;
  var JI = Math.imul;
  XI({
    target: "Math",
    stat: true,
    forced: YI(function () {
      return JI(4294967295, 5) != -5 || JI.length != 2;
    })
  }, {
    imul: function (e, t) {
      var n = 65535;
      var r = +e;
      var a = +t;
      var i = n & r;
      var o = n & a;
      return i * o + ((n & r >>> 16) * o + i * (n & a >>> 16) << 16 >>> 0) | 0;
    }
  });
  var ZI = Math.log;
  var QI = Math.LOG10E;
  var $I = Math.log10 || function (e) {
    return ZI(e) * QI;
  };
  La({
    target: "Math",
    stat: true
  }, {
    log10: $I
  });
  La({
    target: "Math",
    stat: true
  }, {
    log1p: aI
  });
  var eN = La;
  var tN = Math.log;
  var nN = Math.LN2;
  eN({
    target: "Math",
    stat: true
  }, {
    log2: function (e) {
      return tN(e) / nN;
    }
  });
  La({
    target: "Math",
    stat: true
  }, {
    sign: yI
  });
  var rN = La;
  var aN = B;
  var iN = AI;
  var oN = Math.abs;
  var sN = Math.exp;
  var uN = Math.E;
  rN({
    target: "Math",
    stat: true,
    forced: aN(function () {
      return Math.sinh(-2e-17) != -2e-17;
    })
  }, {
    sinh: function (e) {
      var t = +e;
      if (oN(t) < 1) {
        return (iN(t) - iN(-t)) / 2;
      } else {
        return (sN(t - 1) - sN(-t - 1)) * (uN / 2);
      }
    }
  });
  var cN = La;
  var lN = AI;
  var hN = Math.exp;
  cN({
    target: "Math",
    stat: true
  }, {
    tanh: function (e) {
      var t = +e;
      var n = lN(t);
      var r = lN(-t);
      if (n == Infinity) {
        return 1;
      } else if (r == Infinity) {
        return -1;
      } else {
        return (n - r) / (hN(t) + hN(-t));
      }
    }
  });
  eo(Math, "Math", true);
  La({
    target: "Math",
    stat: true
  }, {
    trunc: Lr
  });
  var pN = ee(1 .valueOf);
  var fN = "\t\n\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029ï»¿";
  var dN = fe;
  var vN = Ya;
  var mN = fN;
  var gN = ee("".replace);
  var yN = RegExp("^[" + mN + "]+");
  var bN = RegExp("(^|[^" + mN + "])[" + mN + "]+$");
  function xN(e) {
    return function (t) {
      var n = vN(dN(t));
      if (e & 1) {
        n = gN(n, yN, "");
      }
      if (e & 2) {
        n = gN(n, bN, "$1");
      }
      return n;
    };
  }
  var kN = {
    start: xN(1),
    end: xN(2),
    trim: xN(3)
  };
  var wN = La;
  var IN = st;
  var NN = W;
  var SN = z;
  var TN = Wi;
  var EN = ee;
  var CN = Ca;
  var AN = kt;
  var RN = Oc;
  var _N = Ce;
  var ON = He;
  var FN = Gt;
  var DN = B;
  var MN = Fr.f;
  var LN = P.f;
  var zN = cn.f;
  var PN = pN;
  var BN = kN.trim;
  var WN = "Number";
  var UN = SN.Number;
  TN.Number;
  var VN = UN.prototype;
  var GN = SN.TypeError;
  var jN = EN("".slice);
  var HN = EN("".charCodeAt);
  function qN(e) {
    var t = FN(e, "number");
    if (typeof t == "bigint") {
      return t;
    } else {
      return KN(t);
    }
  }
  function KN(e) {
    var t;
    var n;
    var r;
    var a;
    var i;
    var o;
    var s;
    var u;
    var c = FN(e, "number");
    if (ON(c)) {
      throw GN("Cannot convert a Symbol value to a number");
    }
    if (typeof c == "string" && c.length > 2) {
      c = BN(c);
      if ((t = HN(c, 0)) === 43 || t === 45) {
        if ((n = HN(c, 2)) === 88 || n === 120) {
          return NaN;
        }
      } else if (t === 48) {
        switch (HN(c, 1)) {
          case 66:
          case 98:
            r = 2;
            a = 49;
            break;
          case 79:
          case 111:
            r = 8;
            a = 55;
            break;
          default:
            return +c;
        }
        o = (i = jN(c, 2)).length;
        s = 0;
        for (; s < o; s++) {
          if ((u = HN(i, s)) < 48 || u > a) {
            return NaN;
          }
        }
        return parseInt(i, r);
      }
    }
    return +c;
  }
  var XN = CN(WN, !UN(" 0o1") || !UN("0b1") || UN("+0x1"));
  function YN(e) {
    return _N(VN, e) && DN(function () {
      PN(e);
    });
  }
  function JN(e) {
    var t = arguments.length < 1 ? 0 : UN(qN(e));
    if (YN(this)) {
      return RN(Object(t), this, JN);
    } else {
      return t;
    }
  }
  JN.prototype = VN;
  if (XN) {
    VN.constructor = JN;
  }
  wN({
    global: true,
    constructor: true,
    wrap: true,
    forced: XN
  }, {
    Number: JN
  });
  function ZN(e, t) {
    var n;
    for (var r = NN ? MN(t) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), a = 0; r.length > a; a++) {
      if (AN(t, n = r[a]) && !AN(e, n)) {
        zN(e, n, LN(t, n));
      }
    }
  }
  if (XN) {
    ZN(TN.Number, UN);
  }
  La({
    target: "Number",
    stat: true,
    nonConfigurable: true,
    nonWritable: true
  }, {
    EPSILON: Math.pow(2, -52)
  });
  var QN = z.isFinite;
  var $N = Number.isFinite || function (e) {
    return typeof e == "number" && QN(e);
  };
  La({
    target: "Number",
    stat: true
  }, {
    isFinite: $N
  });
  var eS = Ie;
  var tS = Math.floor;
  var nS = Number.isInteger || function (e) {
    return !eS(e) && isFinite(e) && tS(e) === e;
  };
  La({
    target: "Number",
    stat: true
  }, {
    isInteger: nS
  });
  La({
    target: "Number",
    stat: true
  }, {
    isNaN: function (e) {
      return e != e;
    }
  });
  var rS = La;
  var aS = nS;
  var iS = Math.abs;
  rS({
    target: "Number",
    stat: true
  }, {
    isSafeInteger: function (e) {
      return aS(e) && iS(e) <= 9007199254740991;
    }
  });
  La({
    target: "Number",
    stat: true,
    nonConfigurable: true,
    nonWritable: true
  }, {
    MAX_SAFE_INTEGER: 9007199254740991
  });
  La({
    target: "Number",
    stat: true,
    nonConfigurable: true,
    nonWritable: true
  }, {
    MIN_SAFE_INTEGER: -9007199254740991
  });
  var oS = z;
  var sS = B;
  var uS = Ya;
  var cS = kN.trim;
  var lS = ee("".charAt);
  var hS = oS.parseFloat;
  var pS = oS.Symbol;
  var fS = pS && pS.iterator;
  var dS = 1 / hS("\t\n\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029ï»¿-0") != -Infinity || fS && !sS(function () {
    hS(Object(fS));
  }) ? function (e) {
    var t = cS(uS(e));
    var n = hS(t);
    if (n === 0 && lS(t, 0) == "-") {
      return -0;
    } else {
      return n;
    }
  } : hS;
  var vS = dS;
  La({
    target: "Number",
    stat: true,
    forced: Number.parseFloat != vS
  }, {
    parseFloat: vS
  });
  var mS = z;
  var gS = B;
  var yS = ee;
  var bS = Ya;
  var xS = kN.trim;
  var kS = fN;
  var wS = mS.parseInt;
  var IS = mS.Symbol;
  var NS = IS && IS.iterator;
  var SS = /^[+-]?0x/i;
  var TS = yS(SS.exec);
  var ES = wS(kS + "08") !== 8 || wS(kS + "0x16") !== 22 || NS && !gS(function () {
    wS(Object(NS));
  }) ? function (e, t) {
    var n = xS(bS(e));
    return wS(n, t >>> 0 || (TS(SS, n) ? 16 : 10));
  } : wS;
  var CS = ES;
  La({
    target: "Number",
    stat: true,
    forced: Number.parseInt != CS
  }, {
    parseInt: CS
  });
  var AS = La;
  var RS = ee;
  var _S = Pr;
  var OS = pN;
  var FS = Nx;
  var DS = $I;
  var MS = B;
  var LS = RangeError;
  var zS = String;
  var PS = isFinite;
  var BS = Math.abs;
  var WS = Math.floor;
  var US = Math.pow;
  var VS = Math.round;
  var GS = RS(1 .toExponential);
  var jS = RS(FS);
  var HS = RS("".slice);
  var qS = GS(-6.9e-11, 4) === "-6.9000e-11" && GS(1.255, 2) === "1.25e+0" && GS(12345, 3) === "1.235e+4" && GS(25, 0) === "3e+1";
  AS({
    target: "Number",
    proto: true,
    forced: !qS || !MS(function () {
      GS(1, Infinity);
    }) || !MS(function () {
      GS(1, -Infinity);
    }) || !!MS(function () {
      GS(Infinity, Infinity);
      GS(NaN, Infinity);
    })
  }, {
    toExponential: function (e) {
      var t = OS(this);
      if (e === undefined) {
        return GS(t);
      }
      var n = _S(e);
      if (!PS(t)) {
        return String(t);
      }
      if (n < 0 || n > 20) {
        throw LS("Incorrect fraction digits");
      }
      if (qS) {
        return GS(t, n);
      }
      var r = "";
      var a = "";
      var i = 0;
      var o = "";
      var s = "";
      if (t < 0) {
        r = "-";
        t = -t;
      }
      if (t === 0) {
        i = 0;
        a = jS("0", n + 1);
      } else {
        var u = DS(t);
        i = WS(u);
        var c = 0;
        var l = US(10, i - n);
        if (t * 2 >= ((c = VS(t / l)) * 2 + 1) * l) {
          c += 1;
        }
        if (c >= US(10, n + 1)) {
          c /= 10;
          i += 1;
        }
        a = zS(c);
      }
      if (n !== 0) {
        a = HS(a, 0, 1) + "." + HS(a, 1);
      }
      if (i === 0) {
        o = "+";
        s = "0";
      } else {
        o = i > 0 ? "+" : "-";
        s = zS(BS(i));
      }
      return r + (a += "e" + o + s);
    }
  });
  var KS = La;
  var XS = ee;
  var YS = Pr;
  var JS = pN;
  var ZS = Nx;
  var QS = B;
  var $S = RangeError;
  var eT = String;
  var tT = Math.floor;
  var nT = XS(ZS);
  var rT = XS("".slice);
  var aT = XS(1 .toFixed);
  var iT = function e(t, n, r) {
    if (n === 0) {
      return r;
    } else if (n % 2 == 1) {
      return e(t, n - 1, r * t);
    } else {
      return e(t * t, n / 2, r);
    }
  };
  function oT(e, t, n) {
    for (var r = -1, a = n; ++r < 6;) {
      a += t * e[r];
      e[r] = a % 10000000;
      a = tT(a / 10000000);
    }
  }
  function sT(e, t) {
    for (var n = 6, r = 0; --n >= 0;) {
      r += e[n];
      e[n] = tT(r / t);
      r = r % t * 10000000;
    }
  }
  function uT(e) {
    for (var t = 6, n = ""; --t >= 0;) {
      if (n !== "" || t === 0 || e[t] !== 0) {
        var r = eT(e[t]);
        n = n === "" ? r : n + nT("0", 7 - r.length) + r;
      }
    }
    return n;
  }
  KS({
    target: "Number",
    proto: true,
    forced: QS(function () {
      return aT(0.00008, 3) !== "0.000" || aT(0.9, 0) !== "1" || aT(1.255, 2) !== "1.25" || aT(1000000000000000100, 0) !== "1000000000000000128";
    }) || !QS(function () {
      aT({});
    })
  }, {
    toFixed: function (e) {
      var t;
      var n;
      var r;
      var a;
      var i = JS(this);
      var o = YS(e);
      var s = [0, 0, 0, 0, 0, 0];
      var u = "";
      var c = "0";
      if (o < 0 || o > 20) {
        throw $S("Incorrect fraction digits");
      }
      if (i != i) {
        return "NaN";
      }
      if (i <= -1e+21 || i >= 1e+21) {
        return eT(i);
      }
      if (i < 0) {
        u = "-";
        i = -i;
      }
      if (i > 1e-21) {
        n = (t = function (e) {
          var t = 0;
          for (var n = e; n >= 4096;) {
            t += 12;
            n /= 4096;
          }
          while (n >= 2) {
            t += 1;
            n /= 2;
          }
          return t;
        }(i * iT(2, 69, 1)) - 69) < 0 ? i * iT(2, -t, 1) : i / iT(2, t, 1);
        n *= 4503599627370496;
        if ((t = 52 - t) > 0) {
          oT(s, 0, n);
          r = o;
          while (r >= 7) {
            oT(s, 10000000, 0);
            r -= 7;
          }
          oT(s, iT(10, r, 1), 0);
          r = t - 1;
          while (r >= 23) {
            sT(s, 8388608);
            r -= 23;
          }
          sT(s, 1 << r);
          oT(s, 1, 1);
          sT(s, 2);
          c = uT(s);
        } else {
          oT(s, 0, n);
          oT(s, 1 << -t, 0);
          c = uT(s) + nT("0", o);
        }
      }
      return c = o > 0 ? u + ((a = c.length) <= o ? "0." + nT("0", o - a) + c : rT(c, 0, a - o) + "." + rT(c, a - o)) : u + c;
    }
  });
  var cT = La;
  var lT = B;
  var hT = pN;
  var pT = ee(1 .toPrecision);
  cT({
    target: "Number",
    proto: true,
    forced: lT(function () {
      return pT(1, undefined) !== "1";
    }) || !lT(function () {
      pT({});
    })
  }, {
    toPrecision: function (e) {
      if (e === undefined) {
        return pT(hT(this));
      } else {
        return pT(hT(this), e);
      }
    }
  });
  var fT = W;
  var dT = ee;
  var vT = j;
  var mT = B;
  var gT = $a;
  var yT = ua;
  var bT = H;
  var xT = yt;
  var kT = ce;
  var wT = Object.assign;
  var IT = Object.defineProperty;
  var NT = dT([].concat);
  var ST = !wT || mT(function () {
    if (fT && wT({
      b: 1
    }, wT(IT({}, "a", {
      enumerable: true,
      get: function () {
        IT(this, "b", {
          value: 3,
          enumerable: false
        });
      }
    }), {
      b: 2
    })).b !== 1) {
      return true;
    }
    var e = {};
    var t = {};
    var n = Symbol();
    var r = "abcdefghijklmnopqrst";
    e[n] = 7;
    r.split("").forEach(function (e) {
      t[e] = e;
    });
    return wT({}, e)[n] != 7 || gT(wT({}, t)).join("") != r;
  }) ? function (e, t) {
    var n = xT(e);
    for (var r = arguments.length, a = 1, i = yT.f, o = bT.f; r > a;) {
      var s;
      var u = kT(arguments[a++]);
      var c = i ? NT(gT(u), i(u)) : gT(u);
      for (var l = c.length, h = 0; l > h;) {
        s = c[h++];
        if (!fT || !!vT(o, u, s)) {
          n[s] = u[s];
        }
      }
    }
    return n;
  } : wT;
  var TT = ST;
  La({
    target: "Object",
    stat: true,
    arity: 2,
    forced: Object.assign !== TT
  }, {
    assign: TT
  });
  La({
    target: "Object",
    stat: true,
    sham: !W
  }, {
    create: yi
  });
  var ET = z;
  var CT = sm;
  var AT = !B(function () {
    if (!CT || !(CT < 535)) {
      var e = Math.random();
      __defineSetter__.call(null, e, function () {});
      delete ET[e];
    }
  });
  var RT = Ze;
  var _T = yt;
  var OT = cn;
  if (W) {
    La({
      target: "Object",
      proto: true,
      forced: AT
    }, {
      __defineGetter__: function (e, t) {
        OT.f(_T(this), e, {
          get: RT(t),
          enumerable: true,
          configurable: true
        });
      }
    });
  }
  var FT = La;
  var DT = W;
  var MT = Ja.f;
  FT({
    target: "Object",
    stat: true,
    forced: Object.defineProperties !== MT,
    sham: !DT
  }, {
    defineProperties: MT
  });
  var LT = La;
  var zT = W;
  var PT = cn.f;
  LT({
    target: "Object",
    stat: true,
    forced: Object.defineProperty !== PT,
    sham: !zT
  }, {
    defineProperty: PT
  });
  var BT = Ze;
  var WT = yt;
  var UT = cn;
  if (W) {
    La({
      target: "Object",
      proto: true,
      forced: AT
    }, {
      __defineSetter__: function (e, t) {
        UT.f(WT(this), e, {
          set: BT(t),
          enumerable: true,
          configurable: true
        });
      }
    });
  }
  var VT = W;
  var GT = ee;
  var jT = $a;
  var HT = me;
  var qT = GT(H.f);
  var KT = GT([].push);
  function XT(e) {
    return function (t) {
      var n;
      var r = HT(t);
      var a = jT(r);
      for (var i = a.length, o = 0, s = []; i > o;) {
        n = a[o++];
        if (!VT || !!qT(r, n)) {
          KT(s, e ? [n, r[n]] : r[n]);
        }
      }
      return s;
    };
  }
  var YT = {
    entries: XT(true),
    values: XT(false)
  };
  var JT = YT.entries;
  La({
    target: "Object",
    stat: true
  }, {
    entries: function (e) {
      return JT(e);
    }
  });
  var ZT = La;
  var QT = cw;
  var $T = B;
  var eE = Ie;
  var tE = Sw.onFreeze;
  var nE = Object.freeze;
  ZT({
    target: "Object",
    stat: true,
    forced: $T(function () {
      nE(1);
    }),
    sham: !QT
  }, {
    freeze: function (e) {
      if (nE && eE(e)) {
        return nE(tE(e));
      } else {
        return e;
      }
    }
  });
  var rE = yh;
  var aE = Ii;
  La({
    target: "Object",
    stat: true
  }, {
    fromEntries: function (e) {
      var t = {};
      rE(e, function (e, n) {
        aE(t, e, n);
      }, {
        AS_ENTRIES: true
      });
      return t;
    }
  });
  var iE = La;
  var oE = B;
  var sE = me;
  var uE = P.f;
  var cE = W;
  iE({
    target: "Object",
    stat: true,
    forced: !cE || oE(function () {
      uE(1);
    }),
    sham: !cE
  }, {
    getOwnPropertyDescriptor: function (e, t) {
      return uE(sE(e), t);
    }
  });
  var lE = da;
  var hE = me;
  var pE = P;
  var fE = Ii;
  La({
    target: "Object",
    stat: true,
    sham: !W
  }, {
    getOwnPropertyDescriptors: function (e) {
      var t;
      var n;
      var r = hE(e);
      var a = pE.f;
      for (var i = lE(r), o = {}, s = 0; i.length > s;) {
        if ((n = a(r, t = i[s++])) !== undefined) {
          fE(o, t, n);
        }
      }
      return o;
    }
  });
  var dE = La;
  var vE = B;
  var mE = bi.f;
  dE({
    target: "Object",
    stat: true,
    forced: vE(function () {
      return !Object.getOwnPropertyNames(1);
    })
  }, {
    getOwnPropertyNames: mE
  });
  var gE = yt;
  var yE = Ll;
  var bE = Cl;
  La({
    target: "Object",
    stat: true,
    forced: B(function () {
      yE(1);
    }),
    sham: !bE
  }, {
    getPrototypeOf: function (e) {
      return yE(gE(e));
    }
  });
  La({
    target: "Object",
    stat: true
  }, {
    hasOwn: kt
  });
  var xE = Object.is || function (e, t) {
    if (e === t) {
      return e !== 0 || 1 / e == 1 / t;
    } else {
      return e != e && t != t;
    }
  };
  La({
    target: "Object",
    stat: true
  }, {
    is: xE
  });
  var kE = uw;
  La({
    target: "Object",
    stat: true,
    forced: Object.isExtensible !== kE
  }, {
    isExtensible: kE
  });
  var wE = La;
  var IE = B;
  var NE = Ie;
  var SE = ae;
  var TE = nw;
  var EE = Object.isFrozen;
  wE({
    target: "Object",
    stat: true,
    forced: TE || IE(function () {
      EE(1);
    })
  }, {
    isFrozen: function (e) {
      return !NE(e) || !!TE && SE(e) == "ArrayBuffer" || !!EE && EE(e);
    }
  });
  var CE = La;
  var AE = B;
  var RE = Ie;
  var _E = ae;
  var OE = nw;
  var FE = Object.isSealed;
  CE({
    target: "Object",
    stat: true,
    forced: OE || AE(function () {
      FE(1);
    })
  }, {
    isSealed: function (e) {
      return !RE(e) || !!OE && _E(e) == "ArrayBuffer" || !!FE && FE(e);
    }
  });
  var DE = yt;
  var ME = $a;
  La({
    target: "Object",
    stat: true,
    forced: B(function () {
      ME(1);
    })
  }, {
    keys: function (e) {
      return ME(DE(e));
    }
  });
  var LE = La;
  var zE = W;
  var PE = AT;
  var BE = yt;
  var WE = qt;
  var UE = Ll;
  var VE = P.f;
  if (zE) {
    LE({
      target: "Object",
      proto: true,
      forced: PE
    }, {
      __lookupGetter__: function (e) {
        var t;
        var n = BE(this);
        var r = WE(e);
        do {
          if (t = VE(n, r)) {
            return t.get;
          }
        } while (n = UE(n));
      }
    });
  }
  var GE = La;
  var jE = W;
  var HE = AT;
  var qE = yt;
  var KE = qt;
  var XE = Ll;
  var YE = P.f;
  if (jE) {
    GE({
      target: "Object",
      proto: true,
      forced: HE
    }, {
      __lookupSetter__: function (e) {
        var t;
        var n = qE(this);
        var r = KE(e);
        do {
          if (t = YE(n, r)) {
            return t.set;
          }
        } while (n = XE(n));
      }
    });
  }
  var JE = La;
  var ZE = Ie;
  var QE = Sw.onFreeze;
  var $E = cw;
  var eC = B;
  var tC = Object.preventExtensions;
  JE({
    target: "Object",
    stat: true,
    forced: eC(function () {
      tC(1);
    }),
    sham: !$E
  }, {
    preventExtensions: function (e) {
      if (tC && ZE(e)) {
        return tC(QE(e));
      } else {
        return e;
      }
    }
  });
  var nC = W;
  var rC = zi;
  var aC = Ie;
  var iC = yt;
  var oC = fe;
  var sC = Object.getPrototypeOf;
  var uC = Object.setPrototypeOf;
  var cC = Object.prototype;
  var lC = "__proto__";
  if (nC && sC && uC && !(lC in cC)) {
    try {
      rC(cC, lC, {
        configurable: true,
        get: function () {
          return sC(iC(this));
        },
        set: function (e) {
          var t = oC(this);
          if ((aC(e) || e === null) && aC(t)) {
            uC(t, e);
          }
        }
      });
    } catch (e) {}
  }
  var hC = La;
  var pC = Ie;
  var fC = Sw.onFreeze;
  var dC = cw;
  var vC = B;
  var mC = Object.seal;
  hC({
    target: "Object",
    stat: true,
    forced: vC(function () {
      mC(1);
    }),
    sham: !dC
  }, {
    seal: function (e) {
      if (mC && pC(e)) {
        return mC(fC(e));
      } else {
        return e;
      }
    }
  });
  La({
    target: "Object",
    stat: true
  }, {
    setPrototypeOf: Tc
  });
  var gC = qa;
  var yC = Ba ? {}.toString : function () {
    return "[object " + gC(this) + "]";
  };
  var bC = yC;
  if (!Ba) {
    Or(Object.prototype, "toString", bC, {
      unsafe: true
    });
  }
  var xC = YT.values;
  La({
    target: "Object",
    stat: true
  }, {
    values: function (e) {
      return xC(e);
    }
  });
  La({
    global: true,
    forced: parseFloat != dS
  }, {
    parseFloat: dS
  });
  La({
    global: true,
    forced: parseInt != ES
  }, {
    parseInt: ES
  });
  var kC;
  var wC;
  var IC;
  var NC;
  var SC = TypeError;
  function TC(e, t) {
    if (e < t) {
      throw SC("Not enough arguments");
    }
    return e;
  }
  var EC = /(?:ipad|iphone|ipod).*applewebkit/i.test(Ae);
  var CC = z;
  var AC = fu;
  var RC = so;
  var _C = xe;
  var OC = kt;
  var FC = B;
  var DC = oi;
  var MC = du;
  var LC = Jt;
  var zC = TC;
  var PC = EC;
  var BC = Rv;
  var WC = CC.setImmediate;
  var UC = CC.clearImmediate;
  var VC = CC.process;
  var GC = CC.Dispatch;
  var jC = CC.Function;
  var HC = CC.MessageChannel;
  var qC = CC.String;
  var KC = 0;
  var XC = {};
  var YC = "onreadystatechange";
  FC(function () {
    kC = CC.location;
  });
  function JC(e) {
    if (OC(XC, e)) {
      var t = XC[e];
      delete XC[e];
      t();
    }
  }
  function ZC(e) {
    return function () {
      JC(e);
    };
  }
  function QC(e) {
    JC(e.data);
  }
  function $C(e) {
    CC.postMessage(qC(e), kC.protocol + "//" + kC.host);
  }
  if (!WC || !UC) {
    WC = function (e) {
      zC(arguments.length, 1);
      var t = _C(e) ? e : jC(e);
      var n = MC(arguments, 1);
      XC[++KC] = function () {
        AC(t, undefined, n);
      };
      wC(KC);
      return KC;
    };
    UC = function (e) {
      delete XC[e];
    };
    if (BC) {
      wC = function (e) {
        VC.nextTick(ZC(e));
      };
    } else if (GC && GC.now) {
      wC = function (e) {
        GC.now(ZC(e));
      };
    } else if (HC && !PC) {
      NC = (IC = new HC()).port2;
      IC.port1.onmessage = QC;
      wC = RC(NC.postMessage, NC);
    } else if (CC.addEventListener && _C(CC.postMessage) && !CC.importScripts && kC && kC.protocol !== "file:" && !FC($C)) {
      wC = $C;
      CC.addEventListener("message", QC, false);
    } else {
      wC = YC in LC("script") ? function (e) {
        DC.appendChild(LC("script")).onreadystatechange = function () {
          DC.removeChild(this);
          JC(e);
        };
      } : function (e) {
        setTimeout(ZC(e), 0);
      };
    }
  }
  var eA = {
    set: WC,
    clear: UC
  };
  function tA() {
    this.head = null;
    this.tail = null;
  }
  tA.prototype = {
    add: function (e) {
      var t = {
        item: e,
        next: null
      };
      var n = this.tail;
      if (n) {
        n.next = t;
      } else {
        this.head = t;
      }
      this.tail = t;
    },
    get: function () {
      var e = this.head;
      if (e) {
        if ((this.head = e.next) === null) {
          this.tail = null;
        }
        return e.item;
      }
    }
  };
  var nA;
  var rA;
  var aA;
  var iA;
  var oA;
  var sA = tA;
  var uA = /ipad|iphone|ipod/i.test(Ae) && typeof Pebble != "undefined";
  var cA = /web0s(?!.*chrome)/i.test(Ae);
  var lA = z;
  var hA = so;
  var pA = P.f;
  var fA = eA.set;
  var dA = sA;
  var vA = EC;
  var mA = uA;
  var gA = cA;
  var yA = Rv;
  var bA = lA.MutationObserver || lA.WebKitMutationObserver;
  var xA = lA.document;
  var kA = lA.process;
  var wA = lA.Promise;
  var IA = pA(lA, "queueMicrotask");
  var NA = IA && IA.value;
  if (!NA) {
    var SA = new dA();
    function TA() {
      var e;
      var t;
      for (yA && (e = kA.domain) && e.exit(); t = SA.get();) {
        try {
          t();
        } catch (e) {
          if (SA.head) {
            nA();
          }
          throw e;
        }
      }
      if (e) {
        e.enter();
      }
    }
    if (vA || yA || gA || !bA || !xA) {
      if (!mA && wA && wA.resolve) {
        (iA = wA.resolve(undefined)).constructor = wA;
        oA = hA(iA.then, iA);
        nA = function () {
          oA(TA);
        };
      } else if (yA) {
        nA = function () {
          kA.nextTick(TA);
        };
      } else {
        fA = hA(fA, lA);
        nA = function () {
          fA(TA);
        };
      }
    } else {
      rA = true;
      aA = xA.createTextNode("");
      new bA(TA).observe(aA, {
        characterData: true
      });
      nA = function () {
        aA.data = rA = !rA;
      };
    }
    NA = function (e) {
      if (!SA.head) {
        nA();
      }
      SA.add(e);
    };
  }
  var EA;
  var CA;
  var AA;
  var RA = NA;
  function _A(e, t) {
    try {
      if (arguments.length == 1) {
        console.error(e);
      } else {
        console.error(e, t);
      }
    } catch (e) {}
  }
  function OA(e) {
    try {
      return {
        error: false,
        value: e()
      };
    } catch (e) {
      return {
        error: true,
        value: e
      };
    }
  }
  var FA = z.Promise;
  var DA = (typeof Deno == "undefined" ? "undefined" : s(Deno)) == "object" && Deno && s(Deno.version) == "object";
  var MA = !DA && !Rv && (typeof window == "undefined" ? "undefined" : s(window)) == "object" && (typeof document == "undefined" ? "undefined" : s(document)) == "object";
  var LA = z;
  var zA = FA;
  var PA = xe;
  var BA = Ca;
  var WA = Vn;
  var UA = Mt;
  var VA = MA;
  var GA = DA;
  var jA = Le;
  if (zA) {
    zA.prototype;
  }
  var HA = UA("species");
  var qA = false;
  var KA = PA(LA.PromiseRejectionEvent);
  var XA = BA("Promise", function () {
    var e = WA(zA);
    var t = e !== String(zA);
    if (!t && jA === 66) {
      return true;
    }
    if (!jA || jA < 51 || !/native code/.test(e)) {
      var n = new zA(function (e) {
        e(1);
      });
      function r(e) {
        e(function () {}, function () {});
      }
      (n.constructor = {})[HA] = r;
      if (!(qA = n.then(function () {}) instanceof r)) {
        return true;
      }
    }
    return !t && (VA || GA) && !KA;
  });
  var YA = {
    CONSTRUCTOR: XA,
    REJECTION_EVENT: KA,
    SUBCLASSING: qA
  };
  var JA = {};
  var ZA = Ze;
  var QA = TypeError;
  function $A(e) {
    var t;
    var n;
    this.promise = new e(function (e, r) {
      if (t !== undefined || n !== undefined) {
        throw QA("Bad Promise constructor");
      }
      t = e;
      n = r;
    });
    this.resolve = ZA(t);
    this.reject = ZA(n);
  }
  JA.f = function (e) {
    return new $A(e);
  };
  var eR = La;
  var tR = Rv;
  var nR = z;
  var rR = j;
  var aR = Or;
  var iR = Tc;
  var oR = eo;
  var sR = Fm;
  var uR = Ze;
  var cR = xe;
  var lR = Ie;
  var hR = zg;
  var pR = Kb;
  var fR = eA.set;
  var dR = RA;
  var vR = _A;
  var mR = OA;
  var gR = sA;
  var yR = cr;
  var bR = FA;
  var xR = JA;
  var kR = "Promise";
  var wR = YA.CONSTRUCTOR;
  var IR = YA.REJECTION_EVENT;
  var NR = YA.SUBCLASSING;
  var SR = yR.getterFor(kR);
  var TR = yR.set;
  var ER = bR && bR.prototype;
  var CR = bR;
  var AR = ER;
  var RR = nR.TypeError;
  var _R = nR.document;
  var OR = nR.process;
  var FR = xR.f;
  var DR = FR;
  var MR = !!_R && !!_R.createEvent && !!nR.dispatchEvent;
  var LR = "unhandledrejection";
  function zR(e) {
    var t;
    return !!lR(e) && !!cR(t = e.then) && t;
  }
  function PR(e, t) {
    var n;
    var r;
    var a;
    var i = t.value;
    var o = t.state == 1;
    var s = o ? e.ok : e.fail;
    var u = e.resolve;
    var c = e.reject;
    var l = e.domain;
    try {
      if (s) {
        if (!o) {
          if (t.rejection === 2) {
            GR(t);
          }
          t.rejection = 1;
        }
        if (s === true) {
          n = i;
        } else {
          if (l) {
            l.enter();
          }
          n = s(i);
          if (l) {
            l.exit();
            a = true;
          }
        }
        if (n === e.promise) {
          c(RR("Promise-chain cycle"));
        } else if (r = zR(n)) {
          rR(r, n, u, c);
        } else {
          u(n);
        }
      } else {
        c(i);
      }
    } catch (e) {
      if (l && !a) {
        l.exit();
      }
      c(e);
    }
  }
  function BR(e, t) {
    if (!e.notified) {
      e.notified = true;
      dR(function () {
        for (var n, r = e.reactions; n = r.get();) {
          PR(n, e);
        }
        e.notified = false;
        if (t && !e.rejection) {
          UR(e);
        }
      });
    }
  }
  function WR(e, t, n) {
    var r;
    var a;
    if (MR) {
      (r = _R.createEvent("Event")).promise = t;
      r.reason = n;
      r.initEvent(e, false, true);
      nR.dispatchEvent(r);
    } else {
      r = {
        promise: t,
        reason: n
      };
    }
    if (!IR && (a = nR["on" + e])) {
      a(r);
    } else if (e === LR) {
      vR("Unhandled promise rejection", n);
    }
  }
  function UR(e) {
    rR(fR, nR, function () {
      var t;
      var n = e.facade;
      var r = e.value;
      if (VR(e) && (t = mR(function () {
        if (tR) {
          OR.emit("unhandledRejection", r, n);
        } else {
          WR(LR, n, r);
        }
      }), e.rejection = tR || VR(e) ? 2 : 1, t.error)) {
        throw t.value;
      }
    });
  }
  function VR(e) {
    return e.rejection !== 1 && !e.parent;
  }
  function GR(e) {
    rR(fR, nR, function () {
      var t = e.facade;
      if (tR) {
        OR.emit("rejectionHandled", t);
      } else {
        WR("rejectionhandled", t, e.value);
      }
    });
  }
  function jR(e, t, n) {
    return function (r) {
      e(t, r, n);
    };
  }
  function HR(e, t, n) {
    if (!e.done) {
      e.done = true;
      if (n) {
        e = n;
      }
      e.value = t;
      e.state = 2;
      BR(e, true);
    }
  }
  var qR = function e(t, n, r) {
    if (!t.done) {
      t.done = true;
      if (r) {
        t = r;
      }
      try {
        if (t.facade === n) {
          throw RR("Promise can't be resolved itself");
        }
        var a = zR(n);
        if (a) {
          dR(function () {
            var r = {
              done: false
            };
            try {
              rR(a, n, jR(e, r, t), jR(HR, r, t));
            } catch (e) {
              HR(r, e, t);
            }
          });
        } else {
          t.value = n;
          t.state = 1;
          BR(t, false);
        }
      } catch (e) {
        HR({
          done: false
        }, e, t);
      }
    }
  };
  if (wR && (AR = (CR = function (e) {
    hR(this, AR);
    uR(e);
    rR(EA, this);
    var t = SR(this);
    try {
      e(jR(qR, t), jR(HR, t));
    } catch (e) {
      HR(t, e);
    }
  }).prototype, (EA = function (e) {
    TR(this, {
      type: kR,
      done: false,
      notified: false,
      parent: false,
      reactions: new gR(),
      rejection: false,
      state: 0,
      value: undefined
    });
  }).prototype = aR(AR, "then", function (e, t) {
    var n = SR(this);
    var r = FR(pR(this, CR));
    n.parent = true;
    r.ok = !cR(e) || e;
    r.fail = cR(t) && t;
    r.domain = tR ? OR.domain : undefined;
    if (n.state == 0) {
      n.reactions.add(r);
    } else {
      dR(function () {
        PR(r, n);
      });
    }
    return r.promise;
  }), CA = function () {
    var e = new EA();
    var t = SR(e);
    this.promise = e;
    this.resolve = jR(qR, t);
    this.reject = jR(HR, t);
  }, xR.f = FR = function (e) {
    if (e === CR || e === undefined) {
      return new CA(e);
    } else {
      return DR(e);
    }
  }, cR(bR) && ER !== Object.prototype)) {
    AA = ER.then;
    if (!NR) {
      aR(ER, "then", function (e, t) {
        var n = this;
        return new CR(function (e, t) {
          rR(AA, n, e, t);
        }).then(e, t);
      }, {
        unsafe: true
      });
    }
    try {
      delete ER.constructor;
    } catch (e) {}
    if (iR) {
      iR(ER, AR);
    }
  }
  eR({
    global: true,
    constructor: true,
    wrap: true,
    forced: wR
  }, {
    Promise: CR
  });
  oR(CR, kR, false, true);
  sR(kR);
  var KR = FA;
  var XR = YA.CONSTRUCTOR || !Uf(function (e) {
    KR.all(e).then(undefined, function () {});
  });
  var YR = j;
  var JR = Ze;
  var ZR = JA;
  var QR = OA;
  var $R = yh;
  La({
    target: "Promise",
    stat: true,
    forced: XR
  }, {
    all: function (e) {
      var t = this;
      var n = ZR.f(t);
      var r = n.resolve;
      var a = n.reject;
      var i = QR(function () {
        var n = JR(t.resolve);
        var i = [];
        var o = 0;
        var s = 1;
        $R(e, function (e) {
          var u = o++;
          var c = false;
          s++;
          YR(n, t, e).then(function (e) {
            if (!c) {
              c = true;
              i[u] = e;
              if (! --s) {
                r(i);
              }
            }
          }, a);
        });
        if (! --s) {
          r(i);
        }
      });
      if (i.error) {
        a(i.value);
      }
      return n.promise;
    }
  });
  var e_ = La;
  var t_ = YA.CONSTRUCTOR;
  var n_ = FA;
  var r_ = Ee;
  var a_ = xe;
  var i_ = Or;
  var o_ = n_ && n_.prototype;
  e_({
    target: "Promise",
    proto: true,
    forced: t_,
    real: true
  }, {
    catch: function (e) {
      return this.then(undefined, e);
    }
  });
  if (a_(n_)) {
    var s_ = r_("Promise").prototype.catch;
    if (o_.catch !== s_) {
      i_(o_, "catch", s_, {
        unsafe: true
      });
    }
  }
  var u_ = j;
  var c_ = Ze;
  var l_ = JA;
  var h_ = OA;
  var p_ = yh;
  La({
    target: "Promise",
    stat: true,
    forced: XR
  }, {
    race: function (e) {
      var t = this;
      var n = l_.f(t);
      var r = n.reject;
      var a = h_(function () {
        var a = c_(t.resolve);
        p_(e, function (e) {
          u_(a, t, e).then(n.resolve, r);
        });
      });
      if (a.error) {
        r(a.value);
      }
      return n.promise;
    }
  });
  var f_ = j;
  var d_ = JA;
  La({
    target: "Promise",
    stat: true,
    forced: YA.CONSTRUCTOR
  }, {
    reject: function (e) {
      var t = d_.f(this);
      f_(t.reject, undefined, e);
      return t.promise;
    }
  });
  var v_ = dn;
  var m_ = Ie;
  var g_ = JA;
  function y_(e, t) {
    v_(e);
    if (m_(t) && t.constructor === e) {
      return t;
    }
    var n = g_.f(e);
    (0, n.resolve)(t);
    return n.promise;
  }
  var b_ = La;
  var x_ = YA.CONSTRUCTOR;
  var k_ = y_;
  Ee("Promise");
  b_({
    target: "Promise",
    stat: true,
    forced: x_
  }, {
    resolve: function (e) {
      return k_(this, e);
    }
  });
  var w_ = j;
  var I_ = Ze;
  var N_ = JA;
  var S_ = OA;
  var T_ = yh;
  La({
    target: "Promise",
    stat: true,
    forced: XR
  }, {
    allSettled: function (e) {
      var t = this;
      var n = N_.f(t);
      var r = n.resolve;
      var a = n.reject;
      var i = S_(function () {
        var n = I_(t.resolve);
        var a = [];
        var i = 0;
        var o = 1;
        T_(e, function (e) {
          var s = i++;
          var u = false;
          o++;
          w_(n, t, e).then(function (e) {
            if (!u) {
              u = true;
              a[s] = {
                status: "fulfilled",
                value: e
              };
              if (! --o) {
                r(a);
              }
            }
          }, function (e) {
            if (!u) {
              u = true;
              a[s] = {
                status: "rejected",
                reason: e
              };
              if (! --o) {
                r(a);
              }
            }
          });
        });
        if (! --o) {
          r(a);
        }
      });
      if (i.error) {
        a(i.value);
      }
      return n.promise;
    }
  });
  var E_ = j;
  var C_ = Ze;
  var A_ = Ee;
  var R_ = JA;
  var __ = OA;
  var O_ = yh;
  var F_ = "No one promise resolved";
  La({
    target: "Promise",
    stat: true,
    forced: XR
  }, {
    any: function (e) {
      var t = this;
      var n = A_("AggregateError");
      var r = R_.f(t);
      var a = r.resolve;
      var i = r.reject;
      var o = __(function () {
        var r = C_(t.resolve);
        var o = [];
        var s = 0;
        var u = 1;
        var c = false;
        O_(e, function (e) {
          var l = s++;
          var h = false;
          u++;
          E_(r, t, e).then(function (e) {
            if (!h && !c) {
              c = true;
              a(e);
            }
          }, function (e) {
            if (!h && !c) {
              h = true;
              o[l] = e;
              if (! --u) {
                i(new n(o, F_));
              }
            }
          });
        });
        if (! --u) {
          i(new n(o, F_));
        }
      });
      if (o.error) {
        i(o.value);
      }
      return r.promise;
    }
  });
  var D_ = La;
  var M_ = FA;
  var L_ = B;
  var z_ = Ee;
  var P_ = xe;
  var B_ = Kb;
  var W_ = y_;
  var U_ = Or;
  var V_ = M_ && M_.prototype;
  D_({
    target: "Promise",
    proto: true,
    real: true,
    forced: !!M_ && L_(function () {
      V_.finally.call({
        then: function () {}
      }, function () {});
    })
  }, {
    finally: function (e) {
      var t = B_(this, z_("Promise"));
      var n = P_(e);
      return this.then(n ? function (n) {
        return W_(t, e()).then(function () {
          return n;
        });
      } : e, n ? function (n) {
        return W_(t, e()).then(function () {
          throw n;
        });
      } : e);
    }
  });
  if (P_(M_)) {
    var G_ = z_("Promise").prototype.finally;
    if (V_.finally !== G_) {
      U_(V_, "finally", G_, {
        unsafe: true
      });
    }
  }
  var j_ = fu;
  var H_ = Ze;
  var q_ = dn;
  La({
    target: "Reflect",
    stat: true,
    forced: !B(function () {
      Reflect.apply(function () {});
    })
  }, {
    apply: function (e, t, n) {
      return j_(H_(e), t, q_(n));
    }
  });
  var K_ = La;
  var X_ = fu;
  var Y_ = zk;
  var J_ = Vb;
  var Z_ = dn;
  var Q_ = Ie;
  var $_ = yi;
  var eO = B;
  var tO = Ee("Reflect", "construct");
  var nO = Object.prototype;
  var rO = [].push;
  var aO = eO(function () {
    function e() {}
    return !(tO(function () {}, [], e) instanceof e);
  });
  var iO = !eO(function () {
    tO(function () {});
  });
  var oO = aO || iO;
  K_({
    target: "Reflect",
    stat: true,
    forced: oO,
    sham: oO
  }, {
    construct: function (e, t) {
      J_(e);
      Z_(t);
      var n = arguments.length < 3 ? e : J_(arguments[2]);
      if (iO && !aO) {
        return tO(e, t, n);
      }
      if (e == n) {
        switch (t.length) {
          case 0:
            return new e();
          case 1:
            return new e(t[0]);
          case 2:
            return new e(t[0], t[1]);
          case 3:
            return new e(t[0], t[1], t[2]);
          case 4:
            return new e(t[0], t[1], t[2], t[3]);
        }
        var r = [null];
        X_(rO, r, t);
        return new (X_(Y_, e, r))();
      }
      var a = n.prototype;
      var i = $_(Q_(a) ? a : nO);
      var o = X_(e, i, t);
      if (Q_(o)) {
        return o;
      } else {
        return i;
      }
    }
  });
  var sO = W;
  var uO = dn;
  var cO = qt;
  var lO = cn;
  La({
    target: "Reflect",
    stat: true,
    forced: B(function () {
      Reflect.defineProperty(lO.f({}, 1, {
        value: 1
      }), 1, {
        value: 2
      });
    }),
    sham: !sO
  }, {
    defineProperty: function (e, t, n) {
      uO(e);
      var r = cO(t);
      uO(n);
      try {
        lO.f(e, r, n);
        return true;
      } catch (e) {
        return false;
      }
    }
  });
  var hO = La;
  var pO = dn;
  var fO = P.f;
  hO({
    target: "Reflect",
    stat: true
  }, {
    deleteProperty: function (e, t) {
      var n = fO(pO(e), t);
      return (!n || !!n.configurable) && delete e[t];
    }
  });
  var dO = kt;
  function vO(e) {
    return e !== undefined && (dO(e, "value") || dO(e, "writable"));
  }
  var mO = j;
  var gO = Ie;
  var yO = dn;
  var bO = vO;
  var xO = P;
  var kO = Ll;
  La({
    target: "Reflect",
    stat: true
  }, {
    get: function e(t, n) {
      var r;
      var a;
      var i = arguments.length < 3 ? t : arguments[2];
      if (yO(t) === i) {
        return t[n];
      } else if (r = xO.f(t, n)) {
        if (bO(r)) {
          return r.value;
        } else if (r.get === undefined) {
          return undefined;
        } else {
          return mO(r.get, i);
        }
      } else if (gO(a = kO(t))) {
        return e(a, n, i);
      } else {
        return undefined;
      }
    }
  });
  var wO = dn;
  var IO = P;
  La({
    target: "Reflect",
    stat: true,
    sham: !W
  }, {
    getOwnPropertyDescriptor: function (e, t) {
      return IO.f(wO(e), t);
    }
  });
  var NO = dn;
  var SO = Ll;
  La({
    target: "Reflect",
    stat: true,
    sham: !Cl
  }, {
    getPrototypeOf: function (e) {
      return SO(NO(e));
    }
  });
  La({
    target: "Reflect",
    stat: true
  }, {
    has: function (e, t) {
      return t in e;
    }
  });
  var TO = dn;
  var EO = uw;
  La({
    target: "Reflect",
    stat: true
  }, {
    isExtensible: function (e) {
      TO(e);
      return EO(e);
    }
  });
  La({
    target: "Reflect",
    stat: true
  }, {
    ownKeys: da
  });
  var CO = Ee;
  var AO = dn;
  La({
    target: "Reflect",
    stat: true,
    sham: !cw
  }, {
    preventExtensions: function (e) {
      AO(e);
      try {
        var t = CO("Object", "preventExtensions");
        if (t) {
          t(e);
        }
        return true;
      } catch (e) {
        return false;
      }
    }
  });
  var RO = La;
  var _O = j;
  var OO = dn;
  var FO = Ie;
  var DO = vO;
  var MO = cn;
  var LO = P;
  var zO = Ll;
  var PO = Y;
  var BO = B(function () {
    function e() {}
    var t = MO.f(new e(), "a", {
      configurable: true
    });
    return Reflect.set(e.prototype, "a", 1, t) !== false;
  });
  RO({
    target: "Reflect",
    stat: true,
    forced: BO
  }, {
    set: function e(t, n, r) {
      var a;
      var i;
      var o;
      var s = arguments.length < 4 ? t : arguments[3];
      var u = LO.f(OO(t), n);
      if (!u) {
        if (FO(i = zO(t))) {
          return e(i, n, r, s);
        }
        u = PO(0);
      }
      if (DO(u)) {
        if (u.writable === false || !FO(s)) {
          return false;
        }
        if (a = LO.f(s, n)) {
          if (a.get || a.set || a.writable === false) {
            return false;
          }
          a.value = r;
          MO.f(s, n, a);
        } else {
          MO.f(s, n, PO(0, r));
        }
      } else {
        if ((o = u.set) === undefined) {
          return false;
        }
        _O(o, s, r);
      }
      return true;
    }
  });
  var WO = dn;
  var UO = wc;
  var VO = Tc;
  if (VO) {
    La({
      target: "Reflect",
      stat: true
    }, {
      setPrototypeOf: function (e, t) {
        WO(e);
        UO(t);
        try {
          VO(e, t);
          return true;
        } catch (e) {
          return false;
        }
      }
    });
  }
  var GO = z;
  var jO = eo;
  La({
    global: true
  }, {
    Reflect: {}
  });
  jO(GO.Reflect, "Reflect", true);
  var HO = Ie;
  var qO = ae;
  var KO = Mt("match");
  function XO(e) {
    var t;
    return HO(e) && ((t = e[KO]) !== undefined ? !!t : qO(e) == "RegExp");
  }
  var YO = dn;
  function JO() {
    var e = YO(this);
    var t = "";
    if (e.hasIndices) {
      t += "d";
    }
    if (e.global) {
      t += "g";
    }
    if (e.ignoreCase) {
      t += "i";
    }
    if (e.multiline) {
      t += "m";
    }
    if (e.dotAll) {
      t += "s";
    }
    if (e.unicode) {
      t += "u";
    }
    if (e.unicodeSets) {
      t += "v";
    }
    if (e.sticky) {
      t += "y";
    }
    return t;
  }
  var ZO = j;
  var QO = kt;
  var $O = Ce;
  var eF = JO;
  var tF = RegExp.prototype;
  function nF(e) {
    var t = e.flags;
    if (t !== undefined || "flags" in tF || QO(e, "flags") || !$O(tF, e)) {
      return t;
    } else {
      return ZO(eF, e);
    }
  }
  var rF = B;
  var aF = z.RegExp;
  var iF = rF(function () {
    var e = aF("a", "y");
    e.lastIndex = 2;
    return e.exec("abcd") != null;
  });
  var oF = iF || rF(function () {
    return !aF("a", "y").sticky;
  });
  var sF = iF || rF(function () {
    var e = aF("^r", "gy");
    e.lastIndex = 2;
    return e.exec("str") != null;
  });
  var uF = {
    BROKEN_CARET: sF,
    MISSED_STICKY: oF,
    UNSUPPORTED_Y: iF
  };
  var cF = B;
  var lF = z.RegExp;
  var hF = cF(function () {
    var e = lF(".", "s");
    return !e.dotAll || !e.exec("\n") || e.flags !== "s";
  });
  var pF = B;
  var fF = z.RegExp;
  var dF = pF(function () {
    var e = fF("(?<a>b)", "g");
    return e.exec("b").groups.a !== "b" || "b".replace(e, "$<a>c") !== "bc";
  });
  var vF = W;
  var mF = z;
  var gF = ee;
  var yF = Ca;
  var bF = Oc;
  var xF = Cn;
  var kF = Fr.f;
  var wF = Ce;
  var IF = XO;
  var NF = Ya;
  var SF = nF;
  var TF = uF;
  var EF = Cc;
  var CF = Or;
  var AF = B;
  var RF = kt;
  var _F = cr.enforce;
  var OF = Fm;
  var FF = hF;
  var DF = dF;
  var MF = Mt("match");
  var LF = mF.RegExp;
  var zF = LF.prototype;
  var PF = mF.SyntaxError;
  var BF = gF(zF.exec);
  var WF = gF("".charAt);
  var UF = gF("".replace);
  var VF = gF("".indexOf);
  var GF = gF("".slice);
  var jF = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
  var HF = /a/g;
  var qF = /a/g;
  var KF = new LF(HF) !== HF;
  var XF = TF.MISSED_STICKY;
  var YF = TF.UNSUPPORTED_Y;
  var JF = vF && (!KF || XF || FF || DF || AF(function () {
    qF[MF] = false;
    return LF(HF) != HF || LF(qF) == qF || LF(HF, "i") != "/a/i";
  }));
  if (yF("RegExp", JF)) {
    var ZF = function (e, t) {
      var n;
      var r;
      var a;
      var i;
      var o;
      var s;
      var u = wF(zF, this);
      var c = IF(e);
      var l = t === undefined;
      var h = [];
      var p = e;
      if (!u && c && l && e.constructor === ZF) {
        return e;
      }
      if (c || wF(zF, e)) {
        e = e.source;
        if (l) {
          t = SF(p);
        }
      }
      e = e === undefined ? "" : NF(e);
      t = t === undefined ? "" : NF(t);
      p = e;
      if (FF && "dotAll" in HF && (r = !!t && VF(t, "s") > -1)) {
        t = UF(t, /s/g, "");
      }
      n = t;
      if (XF && "sticky" in HF && (a = !!t && VF(t, "y") > -1) && YF) {
        t = UF(t, /y/g, "");
      }
      if (DF) {
        i = function (e) {
          var t;
          for (var n = e.length, r = 0, a = "", i = [], o = {}, s = false, u = false, c = 0, l = ""; r <= n; r++) {
            if ((t = WF(e, r)) === "\\") {
              t += WF(e, ++r);
            } else if (t === "]") {
              s = false;
            } else if (!s) {
              switch (true) {
                case t === "[":
                  s = true;
                  break;
                case t === "(":
                  if (BF(jF, GF(e, r + 1))) {
                    r += 2;
                    u = true;
                  }
                  a += t;
                  c++;
                  continue;
                case t === ">" && u:
                  if (l === "" || RF(o, l)) {
                    throw new PF("Invalid capture group name");
                  }
                  o[l] = true;
                  i[i.length] = [l, c];
                  u = false;
                  l = "";
                  continue;
              }
            }
            if (u) {
              l += t;
            } else {
              a += t;
            }
          }
          return [a, i];
        }(e);
        e = i[0];
        h = i[1];
      }
      o = bF(LF(e, t), u ? this : zF, ZF);
      if (r || a || h.length) {
        s = _F(o);
        if (r) {
          s.dotAll = true;
          s.raw = ZF(function (e) {
            var t;
            for (var n = e.length, r = 0, a = "", i = false; r <= n; r++) {
              if ((t = WF(e, r)) !== "\\") {
                if (i || t !== ".") {
                  if (t === "[") {
                    i = true;
                  } else if (t === "]") {
                    i = false;
                  }
                  a += t;
                } else {
                  a += "[\\s\\S]";
                }
              } else {
                a += t + WF(e, ++r);
              }
            }
            return a;
          }(e), n);
        }
        if (a) {
          s.sticky = true;
        }
        if (h.length) {
          s.groups = h;
        }
      }
      if (e !== p) {
        try {
          xF(o, "source", p === "" ? "(?:)" : p);
        } catch (e) {}
      }
      return o;
    };
    for (var QF = kF(LF), $F = 0; QF.length > $F;) {
      EF(ZF, LF, QF[$F++]);
    }
    zF.constructor = ZF;
    ZF.prototype = zF;
    CF(mF, "RegExp", ZF, {
      constructor: true
    });
  }
  OF("RegExp");
  var eD = W;
  var tD = hF;
  var nD = ae;
  var rD = zi;
  var aD = cr.get;
  var iD = RegExp.prototype;
  var oD = TypeError;
  if (eD && tD) {
    rD(iD, "dotAll", {
      configurable: true,
      get: function () {
        if (this !== iD) {
          if (nD(this) === "RegExp") {
            return !!aD(this).dotAll;
          }
          throw oD("Incompatible receiver, RegExp required");
        }
      }
    });
  }
  var sD = j;
  var uD = ee;
  var cD = Ya;
  var lD = JO;
  var hD = uF;
  var pD = yi;
  var fD = cr.get;
  var dD = hF;
  var vD = dF;
  var mD = vt("native-string-replace", String.prototype.replace);
  var gD = RegExp.prototype.exec;
  var yD = gD;
  var bD = uD("".charAt);
  var xD = uD("".indexOf);
  var kD = uD("".replace);
  var wD = uD("".slice);
  var ID = function () {
    var e = /a/;
    var t = /b*/g;
    sD(gD, e, "a");
    sD(gD, t, "a");
    return e.lastIndex !== 0 || t.lastIndex !== 0;
  }();
  var ND = hD.BROKEN_CARET;
  var SD = /()??/.exec("")[1] !== undefined;
  if (ID || SD || ND || dD || vD) {
    yD = function (e) {
      var t;
      var n;
      var r;
      var a;
      var i;
      var o;
      var s;
      var u = this;
      var c = fD(u);
      var l = cD(e);
      var h = c.raw;
      if (h) {
        h.lastIndex = u.lastIndex;
        t = sD(yD, h, l);
        u.lastIndex = h.lastIndex;
        return t;
      }
      var p = c.groups;
      var f = ND && u.sticky;
      var d = sD(lD, u);
      var v = u.source;
      var m = 0;
      var g = l;
      if (f) {
        d = kD(d, "y", "");
        if (xD(d, "g") === -1) {
          d += "g";
        }
        g = wD(l, u.lastIndex);
        if (u.lastIndex > 0 && (!u.multiline || u.multiline && bD(l, u.lastIndex - 1) !== "\n")) {
          v = "(?: " + v + ")";
          g = " " + g;
          m++;
        }
        n = new RegExp("^(?:" + v + ")", d);
      }
      if (SD) {
        n = new RegExp("^" + v + "$(?!\\s)", d);
      }
      if (ID) {
        r = u.lastIndex;
      }
      a = sD(gD, f ? n : u, g);
      if (f) {
        if (a) {
          a.input = wD(a.input, m);
          a[0] = wD(a[0], m);
          a.index = u.lastIndex;
          u.lastIndex += a[0].length;
        } else {
          u.lastIndex = 0;
        }
      } else if (ID && a) {
        u.lastIndex = u.global ? a.index + a[0].length : r;
      }
      if (SD && a && a.length > 1) {
        sD(mD, a[0], n, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) {
              a[i] = undefined;
            }
          }
        });
      }
      if (a && p) {
        a.groups = o = pD(null);
        i = 0;
        for (; i < p.length; i++) {
          o[(s = p[i])[0]] = a[s[1]];
        }
      }
      return a;
    };
  }
  var TD = yD;
  La({
    target: "RegExp",
    proto: true,
    forced: /./.exec !== TD
  }, {
    exec: TD
  });
  var ED = W;
  var CD = zi;
  var AD = JO;
  var RD = B;
  var _D = z.RegExp;
  var OD = _D.prototype;
  var FD = ED && RD(function () {
    var e = true;
    try {
      _D(".", "d");
    } catch (t) {
      e = false;
    }
    var t = {};
    var n = "";
    var r = e ? "dgimsy" : "gimsy";
    function a(e, r) {
      Object.defineProperty(t, e, {
        get: function () {
          n += r;
          return true;
        }
      });
    }
    var i = {
      dotAll: "s",
      global: "g",
      ignoreCase: "i",
      multiline: "m",
      sticky: "y"
    };
    if (e) {
      i.hasIndices = "d";
    }
    for (var o in i) {
      a(o, i[o]);
    }
    return Object.getOwnPropertyDescriptor(OD, "flags").get.call(t) !== r || n !== r;
  });
  if (FD) {
    CD(OD, "flags", {
      configurable: true,
      get: AD
    });
  }
  var DD = W;
  var MD = uF.MISSED_STICKY;
  var LD = ae;
  var zD = zi;
  var PD = cr.get;
  var BD = RegExp.prototype;
  var WD = TypeError;
  if (DD && MD) {
    zD(BD, "sticky", {
      configurable: true,
      get: function () {
        if (this !== BD) {
          if (LD(this) === "RegExp") {
            return !!PD(this).sticky;
          }
          throw WD("Incompatible receiver, RegExp required");
        }
      }
    });
  }
  var UD;
  var VD;
  var GD = La;
  var jD = j;
  var HD = xe;
  var qD = dn;
  var KD = Ya;
  UD = false;
  (VD = /[ac]/).exec = function () {
    UD = true;
    return /./.exec.apply(this, arguments);
  };
  var XD = VD.test("abc") === true && UD;
  var YD = /./.test;
  GD({
    target: "RegExp",
    proto: true,
    forced: !XD
  }, {
    test: function (e) {
      var t = qD(this);
      var n = KD(e);
      var r = t.exec;
      if (!HD(r)) {
        return jD(YD, t, n);
      }
      var a = jD(r, t, n);
      return a !== null && (qD(a), true);
    }
  });
  var JD = Mn.PROPER;
  var ZD = Or;
  var QD = dn;
  var $D = Ya;
  var eM = B;
  var tM = nF;
  var nM = "toString";
  var rM = RegExp.prototype.toString;
  var aM = eM(function () {
    return rM.call({
      source: "a",
      flags: "b"
    }) != "/a/b";
  });
  var iM = JD && rM.name != nM;
  if (aM || iM) {
    ZD(RegExp.prototype, nM, function () {
      var e = QD(this);
      return "/" + $D(e.source) + "/" + $D(tM(e));
    }, {
      unsafe: true
    });
  }
  Uw("Set", function (e) {
    return function () {
      return e(this, arguments.length ? arguments[0] : undefined);
    };
  }, nI);
  var oM = La;
  var sM = fe;
  var uM = Pr;
  var cM = Ya;
  var lM = B;
  var hM = ee("".charAt);
  oM({
    target: "String",
    proto: true,
    forced: lM(function () {
      return "ð ®·".at(-2) !== "\uD842";
    })
  }, {
    at: function (e) {
      var t = cM(sM(this));
      var n = t.length;
      var r = uM(e);
      var a = r >= 0 ? r : n + r;
      if (a < 0 || a >= n) {
        return undefined;
      } else {
        return hM(t, a);
      }
    }
  });
  var pM = ee;
  var fM = Pr;
  var dM = Ya;
  var vM = fe;
  var mM = pM("".charAt);
  var gM = pM("".charCodeAt);
  var yM = pM("".slice);
  function bM(e) {
    return function (t, n) {
      var r;
      var a;
      var i = dM(vM(t));
      var o = fM(n);
      var s = i.length;
      if (o < 0 || o >= s) {
        if (e) {
          return "";
        } else {
          return undefined;
        }
      } else if ((r = gM(i, o)) < 55296 || r > 56319 || o + 1 === s || (a = gM(i, o + 1)) < 56320 || a > 57343) {
        if (e) {
          return mM(i, o);
        } else {
          return r;
        }
      } else if (e) {
        return yM(i, o, o + 2);
      } else {
        return a - 56320 + (r - 55296 << 10) + 65536;
      }
    };
  }
  var xM = {
    codeAt: bM(false),
    charAt: bM(true)
  };
  var kM = xM.codeAt;
  La({
    target: "String",
    proto: true
  }, {
    codePointAt: function (e) {
      return kM(this, e);
    }
  });
  var wM = XO;
  var IM = TypeError;
  function NM(e) {
    if (wM(e)) {
      throw IM("The method doesn't accept regular expressions");
    }
    return e;
  }
  var SM = Mt("match");
  function TM(e) {
    var t = /./;
    try {
      "/./"[e](t);
    } catch (n) {
      try {
        t[SM] = false;
        return "/./"[e](t);
      } catch (e) {}
    }
    return false;
  }
  var EM = La;
  var CM = ro;
  var AM = P.f;
  var RM = Hr;
  var _M = Ya;
  var OM = NM;
  var FM = fe;
  var DM = TM;
  var MM = CM("".endsWith);
  var LM = CM("".slice);
  var zM = Math.min;
  var PM = DM("endsWith");
  var BM = !PM && !!function () {
    var e = AM(String.prototype, "endsWith");
    return e && !e.writable;
  }();
  EM({
    target: "String",
    proto: true,
    forced: !BM && !PM
  }, {
    endsWith: function (e) {
      var t = _M(FM(this));
      OM(e);
      var n = arguments.length > 1 ? arguments[1] : undefined;
      var r = t.length;
      var a = n === undefined ? r : zM(RM(n), r);
      var i = _M(e);
      if (MM) {
        return MM(t, i, a);
      } else {
        return LM(t, a - i.length, a) === i;
      }
    }
  });
  var WM = La;
  var UM = ee;
  var VM = Vr;
  var GM = RangeError;
  var jM = String.fromCharCode;
  var HM = String.fromCodePoint;
  var qM = UM([].join);
  WM({
    target: "String",
    stat: true,
    arity: 1,
    forced: !!HM && HM.length != 1
  }, {
    fromCodePoint: function (e) {
      var t;
      var n = [];
      for (var r = arguments.length, a = 0; r > a;) {
        t = +arguments[a++];
        if (VM(t, 1114111) !== t) {
          throw GM(t + " is not a valid code point");
        }
        n[a] = t < 65536 ? jM(t) : jM(55296 + ((t -= 65536) >> 10), t % 1024 + 56320);
      }
      return qM(n, "");
    }
  });
  var KM = La;
  var XM = NM;
  var YM = fe;
  var JM = Ya;
  var ZM = TM;
  var QM = ee("".indexOf);
  KM({
    target: "String",
    proto: true,
    forced: !ZM("includes")
  }, {
    includes: function (e) {
      return !!~QM(JM(YM(this)), JM(XM(e)), arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var $M = xM.charAt;
  var eL = Ya;
  var tL = cr;
  var nL = Dd;
  var rL = Md;
  var aL = "String Iterator";
  var iL = tL.set;
  var oL = tL.getterFor(aL);
  nL(String, "String", function (e) {
    iL(this, {
      type: aL,
      string: eL(e),
      index: 0
    });
  }, function () {
    var e;
    var t = oL(this);
    var n = t.string;
    var r = t.index;
    if (r >= n.length) {
      return rL(undefined, true);
    } else {
      e = $M(n, r);
      t.index += e.length;
      return rL(e, false);
    }
  });
  var sL = ro;
  var uL = Or;
  var cL = TD;
  var lL = B;
  var hL = Mt;
  var pL = Cn;
  var fL = hL("species");
  var dL = RegExp.prototype;
  function vL(e, t, n, r) {
    var a = hL(e);
    var i = !lL(function () {
      var t = {
        [a]: function () {
          return 7;
        }
      };
      return ""[e](t) != 7;
    });
    var o = i && !lL(function () {
      var t = false;
      var n = /a/;
      if (e === "split") {
        (n = {}).constructor = {};
        n.constructor[fL] = function () {
          return n;
        };
        n.flags = "";
        n[a] = /./[a];
      }
      n.exec = function () {
        t = true;
        return null;
      };
      n[a]("");
      return !t;
    });
    if (!i || !o || n) {
      var s = sL(/./[a]);
      var u = t(a, ""[e], function (e, t, n, r, a) {
        var o = sL(e);
        var u = t.exec;
        if (u === cL || u === dL.exec) {
          if (i && !a) {
            return {
              done: true,
              value: s(t, n, r)
            };
          } else {
            return {
              done: true,
              value: o(n, t, r)
            };
          }
        } else {
          return {
            done: false
          };
        }
      });
      uL(String.prototype, e, u[0]);
      uL(dL, a, u[1]);
    }
    if (r) {
      pL(dL[a], "sham", true);
    }
  }
  var mL = xM.charAt;
  function gL(e, t, n) {
    return t + (n ? mL(e, t).length : 1);
  }
  var yL = j;
  var bL = dn;
  var xL = xe;
  var kL = ae;
  var wL = TD;
  var IL = TypeError;
  function NL(e, t) {
    var n = e.exec;
    if (xL(n)) {
      var r = yL(n, e, t);
      if (r !== null) {
        bL(r);
      }
      return r;
    }
    if (kL(e) === "RegExp") {
      return yL(wL, e, t);
    }
    throw IL("RegExp#exec called on incompatible receiver");
  }
  var SL = j;
  var TL = dn;
  var EL = le;
  var CL = Hr;
  var AL = Ya;
  var RL = fe;
  var _L = et;
  var OL = gL;
  var FL = NL;
  vL("match", function (e, t, n) {
    return [function (t) {
      var n = RL(this);
      var r = EL(t) ? undefined : _L(t, e);
      if (r) {
        return SL(r, t, n);
      } else {
        return new RegExp(t)[e](AL(n));
      }
    }, function (e) {
      var r = TL(this);
      var a = AL(e);
      var i = n(t, r, a);
      if (i.done) {
        return i.value;
      }
      if (!r.global) {
        return FL(r, a);
      }
      var o = r.unicode;
      r.lastIndex = 0;
      for (var s, u = [], c = 0; (s = FL(r, a)) !== null;) {
        var l = AL(s[0]);
        u[c] = l;
        if (l === "") {
          r.lastIndex = OL(a, CL(r.lastIndex), o);
        }
        c++;
      }
      if (c === 0) {
        return null;
      } else {
        return u;
      }
    }];
  });
  var DL = La;
  var ML = j;
  var LL = ro;
  var zL = dd;
  var PL = Md;
  var BL = fe;
  var WL = Hr;
  var UL = Ya;
  var VL = dn;
  var GL = le;
  var jL = XO;
  var HL = nF;
  var qL = et;
  var KL = Or;
  var XL = B;
  var YL = Kb;
  var JL = gL;
  var ZL = NL;
  var QL = cr;
  var $L = Mt("matchAll");
  var ez = "RegExp String";
  var tz = "RegExp String Iterator";
  var nz = QL.set;
  var rz = QL.getterFor(tz);
  var az = RegExp.prototype;
  var iz = TypeError;
  var oz = LL("".indexOf);
  var sz = LL("".matchAll);
  var uz = !!sz && !XL(function () {
    sz("a", /./);
  });
  var cz = zL(function (e, t, n, r) {
    nz(this, {
      type: tz,
      regexp: e,
      string: t,
      global: n,
      unicode: r,
      done: false
    });
  }, ez, function () {
    var e = rz(this);
    if (e.done) {
      return PL(undefined, true);
    }
    var t = e.regexp;
    var n = e.string;
    var r = ZL(t, n);
    if (r === null) {
      e.done = true;
      return PL(undefined, true);
    } else if (e.global) {
      if (UL(r[0]) === "") {
        t.lastIndex = JL(n, WL(t.lastIndex), e.unicode);
      }
      return PL(r, false);
    } else {
      e.done = true;
      return PL(r, false);
    }
  });
  function lz(e) {
    var t;
    var n;
    var r;
    var a = VL(this);
    var i = UL(e);
    var o = YL(a, RegExp);
    var s = UL(HL(a));
    t = new o(o === RegExp ? a.source : a, s);
    n = !!~oz(s, "g");
    r = !!~oz(s, "u");
    t.lastIndex = WL(a.lastIndex);
    return new cz(t, i, n, r);
  }
  DL({
    target: "String",
    proto: true,
    forced: uz
  }, {
    matchAll: function (e) {
      var t;
      var n;
      var r;
      var a = BL(this);
      if (GL(e)) {
        if (uz) {
          return sz(a, e);
        }
      } else {
        if (jL(e) && (t = UL(BL(HL(e))), !~oz(t, "g"))) {
          throw iz("`.matchAll` does not allow non-global regexes");
        }
        if (uz) {
          return sz(a, e);
        }
        if (r = qL(e, $L)) {
          return ML(r, e, a);
        }
      }
      n = UL(a);
      return new RegExp(e, "g")[$L](n);
    }
  });
  if (!($L in az)) {
    KL(az, $L, lz);
  }
  var hz = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(Ae);
  var pz = Fx.end;
  La({
    target: "String",
    proto: true,
    forced: hz
  }, {
    padEnd: function (e) {
      return pz(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var fz = Fx.start;
  La({
    target: "String",
    proto: true,
    forced: hz
  }, {
    padStart: function (e) {
      return fz(this, e, arguments.length > 1 ? arguments[1] : undefined);
    }
  });
  var dz = La;
  var vz = ee;
  var mz = me;
  var gz = yt;
  var yz = Ya;
  var bz = Kr;
  var xz = vz([].push);
  var kz = vz([].join);
  dz({
    target: "String",
    stat: true
  }, {
    raw: function (e) {
      var t = mz(gz(e).raw);
      var n = bz(t);
      if (!n) {
        return "";
      }
      var r = arguments.length;
      var a = [];
      var i = 0;
      while (true) {
        xz(a, yz(t[i++]));
        if (i === n) {
          return kz(a, "");
        }
        if (i < r) {
          xz(a, yz(arguments[i]));
        }
      }
    }
  });
  La({
    target: "String",
    proto: true
  }, {
    repeat: Nx
  });
  var wz = ee;
  var Iz = yt;
  var Nz = Math.floor;
  var Sz = wz("".charAt);
  var Tz = wz("".replace);
  var Ez = wz("".slice);
  var Cz = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var Az = /\$([$&'`]|\d{1,2})/g;
  function Rz(e, t, n, r, a, i) {
    var o = n + e.length;
    var s = r.length;
    var u = Az;
    if (a !== undefined) {
      a = Iz(a);
      u = Cz;
    }
    return Tz(i, u, function (i, u) {
      var c;
      switch (Sz(u, 0)) {
        case "$":
          return "$";
        case "&":
          return e;
        case "`":
          return Ez(t, 0, n);
        case "'":
          return Ez(t, o);
        case "<":
          c = a[Ez(u, 1, -1)];
          break;
        default:
          var l = +u;
          if (l === 0) {
            return i;
          }
          if (l > s) {
            var h = Nz(l / 10);
            if (h === 0) {
              return i;
            } else if (h <= s) {
              if (r[h - 1] === undefined) {
                return Sz(u, 1);
              } else {
                return r[h - 1] + Sz(u, 1);
              }
            } else {
              return i;
            }
          }
          c = r[l - 1];
      }
      if (c === undefined) {
        return "";
      } else {
        return c;
      }
    });
  }
  var _z = fu;
  var Oz = j;
  var Fz = ee;
  var Dz = vL;
  var Mz = B;
  var Lz = dn;
  var zz = xe;
  var Pz = le;
  var Bz = Pr;
  var Wz = Hr;
  var Uz = Ya;
  var Vz = fe;
  var Gz = gL;
  var jz = et;
  var Hz = Rz;
  var qz = NL;
  var Kz = Mt("replace");
  var Xz = Math.max;
  var Yz = Math.min;
  var Jz = Fz([].concat);
  var Zz = Fz([].push);
  var Qz = Fz("".indexOf);
  var $z = Fz("".slice);
  var eP = "a".replace(/./, "$0") === "$0";
  var tP = !!/./[Kz] && /./[Kz]("a", "$0") === "";
  var nP = !Mz(function () {
    var e = /./;
    e.exec = function () {
      var e = [];
      e.groups = {
        a: "7"
      };
      return e;
    };
    return "".replace(e, "$<a>") !== "7";
  });
  Dz("replace", function (e, t, n) {
    var r = tP ? "$" : "$0";
    return [function (e, n) {
      var r = Vz(this);
      var a = Pz(e) ? undefined : jz(e, Kz);
      if (a) {
        return Oz(a, e, r, n);
      } else {
        return Oz(t, Uz(r), e, n);
      }
    }, function (e, a) {
      var i = Lz(this);
      var o = Uz(e);
      if (typeof a == "string" && Qz(a, r) === -1 && Qz(a, "$<") === -1) {
        var s = n(t, i, o, a);
        if (s.done) {
          return s.value;
        }
      }
      var u = zz(a);
      if (!u) {
        a = Uz(a);
      }
      var c = i.global;
      if (c) {
        var l = i.unicode;
        i.lastIndex = 0;
      }
      var h = [];
      while (true) {
        var p = qz(i, o);
        if (p === null) {
          break;
        }
        Zz(h, p);
        if (!c) {
          break;
        }
        if (Uz(p[0]) === "") {
          i.lastIndex = Gz(o, Wz(i.lastIndex), l);
        }
      }
      var f;
      var d = "";
      var v = 0;
      for (var m = 0; m < h.length; m++) {
        var g = Uz((p = h[m])[0]);
        var y = Xz(Yz(Bz(p.index), o.length), 0);
        var b = [];
        for (var x = 1; x < p.length; x++) {
          Zz(b, (f = p[x]) === undefined ? f : String(f));
        }
        var k = p.groups;
        if (u) {
          var w = Jz([g], b, y, o);
          if (k !== undefined) {
            Zz(w, k);
          }
          var I = Uz(_z(a, undefined, w));
        } else {
          I = Hz(g, o, y, b, k, a);
        }
        if (y >= v) {
          d += $z(o, v, y) + I;
          v = y + g.length;
        }
      }
      return d + $z(o, v);
    }];
  }, !nP || !eP || tP);
  var rP = La;
  var aP = j;
  var iP = ee;
  var oP = fe;
  var sP = xe;
  var uP = le;
  var cP = XO;
  var lP = Ya;
  var hP = et;
  var pP = nF;
  var fP = Rz;
  var dP = Mt("replace");
  var vP = TypeError;
  var mP = iP("".indexOf);
  iP("".replace);
  var gP = iP("".slice);
  var yP = Math.max;
  function bP(e, t, n) {
    if (n > e.length) {
      return -1;
    } else if (t === "") {
      return n;
    } else {
      return mP(e, t, n);
    }
  }
  rP({
    target: "String",
    proto: true
  }, {
    replaceAll: function (e, t) {
      var n;
      var r;
      var a;
      var i;
      var o;
      var s;
      var u;
      var c;
      var l = oP(this);
      var h = 0;
      var p = 0;
      var f = "";
      if (!uP(e)) {
        if (cP(e) && (n = lP(oP(pP(e))), !~mP(n, "g"))) {
          throw vP("`.replaceAll` does not allow non-global regexes");
        }
        if (r = hP(e, dP)) {
          return aP(r, e, l, t);
        }
      }
      a = lP(l);
      i = lP(e);
      if (!(o = sP(t))) {
        t = lP(t);
      }
      s = i.length;
      u = yP(1, s);
      h = bP(a, i, 0);
      while (h !== -1) {
        c = o ? lP(t(i, h, a)) : fP(i, a, h, [], undefined, t);
        f += gP(a, p, h) + c;
        p = h + s;
        h = bP(a, i, h + u);
      }
      if (p < a.length) {
        f += gP(a, p);
      }
      return f;
    }
  });
  var xP = j;
  var kP = dn;
  var wP = le;
  var IP = fe;
  var NP = xE;
  var SP = Ya;
  var TP = et;
  var EP = NL;
  vL("search", function (e, t, n) {
    return [function (t) {
      var n = IP(this);
      var r = wP(t) ? undefined : TP(t, e);
      if (r) {
        return xP(r, t, n);
      } else {
        return new RegExp(t)[e](SP(n));
      }
    }, function (e) {
      var r = kP(this);
      var a = SP(e);
      var i = n(t, r, a);
      if (i.done) {
        return i.value;
      }
      var o = r.lastIndex;
      if (!NP(o, 0)) {
        r.lastIndex = 0;
      }
      var s = EP(r, a);
      if (!NP(r.lastIndex, o)) {
        r.lastIndex = o;
      }
      if (s === null) {
        return -1;
      } else {
        return s.index;
      }
    }];
  });
  var CP = fu;
  var AP = j;
  var RP = ee;
  var _P = vL;
  var OP = dn;
  var FP = le;
  var DP = XO;
  var MP = fe;
  var LP = Kb;
  var zP = gL;
  var PP = Hr;
  var BP = Ya;
  var WP = et;
  var UP = Ai;
  var VP = NL;
  var GP = TD;
  var jP = B;
  var HP = uF.UNSUPPORTED_Y;
  var qP = 4294967295;
  var KP = Math.min;
  var XP = [].push;
  var YP = RP(/./.exec);
  var JP = RP(XP);
  var ZP = RP("".slice);
  var QP = !jP(function () {
    var e = /(?:)/;
    var t = e.exec;
    e.exec = function () {
      return t.apply(this, arguments);
    };
    var n = "ab".split(e);
    return n.length !== 2 || n[0] !== "a" || n[1] !== "b";
  });
  _P("split", function (e, t, n) {
    var r;
    r = "abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (e, n) {
      var r = BP(MP(this));
      var a = n === undefined ? qP : n >>> 0;
      if (a === 0) {
        return [];
      }
      if (e === undefined) {
        return [r];
      }
      if (!DP(e)) {
        return AP(t, r, e, a);
      }
      for (var i, o, s, u = [], c = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), l = 0, h = new RegExp(e.source, c + "g"); (i = AP(GP, h, r)) && (!((o = h.lastIndex) > l) || !(JP(u, ZP(r, l, i.index)), i.length > 1 && i.index < r.length && CP(XP, u, UP(i, 1)), s = i[0].length, l = o, u.length >= a));) {
        if (h.lastIndex === i.index) {
          h.lastIndex++;
        }
      }
      if (l === r.length) {
        if (!!s || !YP(h, "")) {
          JP(u, "");
        }
      } else {
        JP(u, ZP(r, l));
      }
      if (u.length > a) {
        return UP(u, 0, a);
      } else {
        return u;
      }
    } : "0".split(undefined, 0).length ? function (e, n) {
      if (e === undefined && n === 0) {
        return [];
      } else {
        return AP(t, this, e, n);
      }
    } : t;
    return [function (t, n) {
      var a = MP(this);
      var i = FP(t) ? undefined : WP(t, e);
      if (i) {
        return AP(i, t, a, n);
      } else {
        return AP(r, BP(a), t, n);
      }
    }, function (e, a) {
      var i = OP(this);
      var o = BP(e);
      var s = n(r, i, o, a, r !== t);
      if (s.done) {
        return s.value;
      }
      var u = LP(i, RegExp);
      var c = i.unicode;
      var l = (i.ignoreCase ? "i" : "") + (i.multiline ? "m" : "") + (i.unicode ? "u" : "") + (HP ? "g" : "y");
      var h = new u(HP ? "^(?:" + i.source + ")" : i, l);
      var p = a === undefined ? qP : a >>> 0;
      if (p === 0) {
        return [];
      }
      if (o.length === 0) {
        if (VP(h, o) === null) {
          return [o];
        } else {
          return [];
        }
      }
      var f = 0;
      for (var d = 0, v = []; d < o.length;) {
        h.lastIndex = HP ? 0 : d;
        var m;
        var g = VP(h, HP ? ZP(o, d) : o);
        if (g === null || (m = KP(PP(h.lastIndex + (HP ? d : 0)), o.length)) === f) {
          d = zP(o, d, c);
        } else {
          JP(v, ZP(o, f, d));
          if (v.length === p) {
            return v;
          }
          for (var y = 1; y <= g.length - 1; y++) {
            JP(v, g[y]);
            if (v.length === p) {
              return v;
            }
          }
          d = f = m;
        }
      }
      JP(v, ZP(o, f));
      return v;
    }];
  }, !QP, HP);
  var $P = La;
  var eB = ro;
  var tB = P.f;
  var nB = Hr;
  var rB = Ya;
  var aB = NM;
  var iB = fe;
  var oB = TM;
  var sB = eB("".startsWith);
  var uB = eB("".slice);
  var cB = Math.min;
  var lB = oB("startsWith");
  var hB = !lB && !!function () {
    var e = tB(String.prototype, "startsWith");
    return e && !e.writable;
  }();
  $P({
    target: "String",
    proto: true,
    forced: !hB && !lB
  }, {
    startsWith: function (e) {
      var t = rB(iB(this));
      aB(e);
      var n = nB(cB(arguments.length > 1 ? arguments[1] : undefined, t.length));
      var r = rB(e);
      if (sB) {
        return sB(t, r, n);
      } else {
        return uB(t, n, n + r.length) === r;
      }
    }
  });
  var pB = La;
  var fB = fe;
  var dB = Pr;
  var vB = Ya;
  var mB = ee("".slice);
  var gB = Math.max;
  var yB = Math.min;
  pB({
    target: "String",
    proto: true,
    forced: !"".substr || "ab".substr(-1) !== "b"
  }, {
    substr: function (e, t) {
      var n;
      var r;
      var a = vB(fB(this));
      var i = a.length;
      var o = dB(e);
      if (o === Infinity) {
        o = 0;
      }
      if (o < 0) {
        o = gB(i + o, 0);
      }
      if ((n = t === undefined ? i : dB(t)) <= 0 || n === Infinity || o >= (r = yB(o + n, i))) {
        return "";
      } else {
        return mB(a, o, r);
      }
    }
  });
  var bB = Mn.PROPER;
  var xB = B;
  var kB = fN;
  function wB(e) {
    return xB(function () {
      return !!kB[e]() || "âÂá "[e]() !== "âÂá " || bB && kB[e].name !== e;
    });
  }
  var IB = kN.trim;
  La({
    target: "String",
    proto: true,
    forced: wB("trim")
  }, {
    trim: function () {
      return IB(this);
    }
  });
  var NB = kN.end;
  var SB = wB("trimEnd") ? function () {
    return NB(this);
  } : "".trimEnd;
  La({
    target: "String",
    proto: true,
    name: "trimEnd",
    forced: "".trimRight !== SB
  }, {
    trimRight: SB
  });
  La({
    target: "String",
    proto: true,
    name: "trimEnd",
    forced: "".trimEnd !== SB
  }, {
    trimEnd: SB
  });
  var TB = kN.start;
  var EB = wB("trimStart") ? function () {
    return TB(this);
  } : "".trimStart;
  La({
    target: "String",
    proto: true,
    name: "trimStart",
    forced: "".trimLeft !== EB
  }, {
    trimLeft: EB
  });
  La({
    target: "String",
    proto: true,
    name: "trimStart",
    forced: "".trimStart !== EB
  }, {
    trimStart: EB
  });
  var CB = fe;
  var AB = Ya;
  var RB = /"/g;
  var _B = ee("".replace);
  function OB(e, t, n, r) {
    var a = AB(CB(e));
    var i = "<" + t;
    if (n !== "") {
      i += " " + n + "=\"" + _B(AB(r), RB, "&quot;") + "\"";
    }
    return i + ">" + a + "</" + t + ">";
  }
  var FB = B;
  function DB(e) {
    return FB(function () {
      var t = ""[e]("\"");
      return t !== t.toLowerCase() || t.split("\"").length > 3;
    });
  }
  var MB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("anchor")
  }, {
    anchor: function (e) {
      return MB(this, "a", "name", e);
    }
  });
  var LB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("big")
  }, {
    big: function () {
      return LB(this, "big", "", "");
    }
  });
  var zB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("blink")
  }, {
    blink: function () {
      return zB(this, "blink", "", "");
    }
  });
  var PB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("bold")
  }, {
    bold: function () {
      return PB(this, "b", "", "");
    }
  });
  var BB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("fixed")
  }, {
    fixed: function () {
      return BB(this, "tt", "", "");
    }
  });
  var WB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("fontcolor")
  }, {
    fontcolor: function (e) {
      return WB(this, "font", "color", e);
    }
  });
  var UB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("fontsize")
  }, {
    fontsize: function (e) {
      return UB(this, "font", "size", e);
    }
  });
  var VB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("italics")
  }, {
    italics: function () {
      return VB(this, "i", "", "");
    }
  });
  var GB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("link")
  }, {
    link: function (e) {
      return GB(this, "a", "href", e);
    }
  });
  var jB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("small")
  }, {
    small: function () {
      return jB(this, "small", "", "");
    }
  });
  var HB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("strike")
  }, {
    strike: function () {
      return HB(this, "strike", "", "");
    }
  });
  var qB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("sub")
  }, {
    sub: function () {
      return qB(this, "sub", "", "");
    }
  });
  var KB = OB;
  La({
    target: "String",
    proto: true,
    forced: DB("sup")
  }, {
    sup: function () {
      return KB(this, "sup", "", "");
    }
  });
  var XB = {
    exports: {}
  };
  var YB = z;
  var JB = B;
  var ZB = Uf;
  var QB = Pb.NATIVE_ARRAY_BUFFER_VIEWS;
  var $B = YB.ArrayBuffer;
  var eW = YB.Int8Array;
  var tW = !QB || !JB(function () {
    eW(1);
  }) || !JB(function () {
    new eW(-1);
  }) || !ZB(function (e) {
    new eW();
    new eW(null);
    new eW(1.5);
    new eW(e);
  }, true) || JB(function () {
    return new eW(new $B(2), 1, undefined).length !== 1;
  });
  var nW = Pr;
  var rW = RangeError;
  function aW(e) {
    var t = nW(e);
    if (t < 0) {
      throw rW("The argument can't be less than 0");
    }
    return t;
  }
  var iW = aW;
  var oW = RangeError;
  function sW(e, t) {
    var n = iW(e);
    if (n % t) {
      throw oW("Wrong offset");
    }
    return n;
  }
  var uW = qa;
  function cW(e) {
    var t = uW(e);
    return t == "BigInt64Array" || t == "BigUint64Array";
  }
  var lW = Gt;
  var hW = TypeError;
  function pW(e) {
    var t = lW(e, "number");
    if (typeof t == "number") {
      throw hW("Can't convert number to bigint");
    }
    return BigInt(t);
  }
  var fW = so;
  var dW = j;
  var vW = Vb;
  var mW = yt;
  var gW = Kr;
  var yW = eh;
  var bW = Kl;
  var xW = Ul;
  var kW = cW;
  var wW = Pb.aTypedArrayConstructor;
  var IW = pW;
  function NW(e) {
    var t;
    var n;
    var r;
    var a;
    var i;
    var o;
    var s;
    var u;
    var c = vW(this);
    var l = mW(e);
    var h = arguments.length;
    var p = h > 1 ? arguments[1] : undefined;
    var f = p !== undefined;
    var d = bW(l);
    if (d && !xW(d)) {
      u = (s = yW(l, d)).next;
      l = [];
      while (!(o = dW(u, s)).done) {
        l.push(o.value);
      }
    }
    if (f && h > 2) {
      p = fW(p, arguments[2]);
    }
    n = gW(l);
    r = new (wW(c))(n);
    a = kW(r);
    t = 0;
    for (; n > t; t++) {
      i = f ? p(l[t], t) : l[t];
      r[t] = a ? IW(i) : +i;
    }
    return r;
  }
  XB.exports;
  var SW = La;
  var TW = z;
  var EW = j;
  var CW = W;
  var AW = tW;
  var RW = Pb;
  var _W = Zy;
  var OW = zg;
  var FW = Y;
  var DW = Cn;
  var MW = nS;
  var LW = Hr;
  var zW = Ug;
  var PW = sW;
  var BW = qt;
  var WW = kt;
  var UW = qa;
  var VW = Ie;
  var GW = He;
  var jW = yi;
  var HW = Ce;
  var qW = Tc;
  var KW = Fr.f;
  var XW = NW;
  var YW = Wo.forEach;
  var JW = Fm;
  var ZW = zi;
  var QW = cn;
  var $W = P;
  var eU = Oc;
  var tU = cr.get;
  var nU = cr.set;
  var rU = cr.enforce;
  var aU = QW.f;
  var iU = $W.f;
  var oU = Math.round;
  var sU = TW.RangeError;
  var uU = _W.ArrayBuffer;
  var cU = uU.prototype;
  var lU = _W.DataView;
  var hU = RW.NATIVE_ARRAY_BUFFER_VIEWS;
  var pU = RW.TYPED_ARRAY_TAG;
  var fU = RW.TypedArray;
  var dU = RW.TypedArrayPrototype;
  var vU = RW.aTypedArrayConstructor;
  var mU = RW.isTypedArray;
  var gU = "BYTES_PER_ELEMENT";
  var yU = "Wrong length";
  function bU(e, t) {
    vU(e);
    for (var n = 0, r = t.length, a = new e(r); r > n;) {
      a[n] = t[n++];
    }
    return a;
  }
  function xU(e, t) {
    ZW(e, t, {
      configurable: true,
      get: function () {
        return tU(this)[t];
      }
    });
  }
  function kU(e) {
    var t;
    return HW(cU, e) || (t = UW(e)) == "ArrayBuffer" || t == "SharedArrayBuffer";
  }
  function wU(e, t) {
    return mU(e) && !GW(t) && t in e && MW(+t) && t >= 0;
  }
  function IU(e, t) {
    t = BW(t);
    if (wU(e, t)) {
      return FW(2, e[t]);
    } else {
      return iU(e, t);
    }
  }
  function NU(e, t, n) {
    t = BW(t);
    if (!wU(e, t) || !VW(n) || !WW(n, "value") || WW(n, "get") || WW(n, "set") || n.configurable || WW(n, "writable") && !n.writable || WW(n, "enumerable") && !n.enumerable) {
      return aU(e, t, n);
    } else {
      e[t] = n.value;
      return e;
    }
  }
  if (CW) {
    if (!hU) {
      $W.f = IU;
      QW.f = NU;
      xU(dU, "buffer");
      xU(dU, "byteOffset");
      xU(dU, "byteLength");
      xU(dU, "length");
    }
    SW({
      target: "Object",
      stat: true,
      forced: !hU
    }, {
      getOwnPropertyDescriptor: IU,
      defineProperty: NU
    });
    XB.exports = function (e, t, n) {
      var r = e.match(/\d+/)[0] / 8;
      var a = e + (n ? "Clamped" : "") + "Array";
      var i = "get" + e;
      var o = "set" + e;
      var s = TW[a];
      var u = s;
      var c = u && u.prototype;
      var l = {};
      function h(e, t) {
        aU(e, t, {
          get: function () {
            return function (e, t) {
              var n = tU(e);
              return n.view[i](t * r + n.byteOffset, true);
            }(this, t);
          },
          set: function (e) {
            return function (e, t, a) {
              var i = tU(e);
              if (n) {
                a = (a = oU(a)) < 0 ? 0 : a > 255 ? 255 : a & 255;
              }
              i.view[o](t * r + i.byteOffset, a, true);
            }(this, t, e);
          },
          enumerable: true
        });
      }
      if (hU) {
        if (AW) {
          u = t(function (e, t, n, a) {
            OW(e, c);
            return eU(VW(t) ? kU(t) ? a !== undefined ? new s(t, PW(n, r), a) : n !== undefined ? new s(t, PW(n, r)) : new s(t) : mU(t) ? bU(u, t) : EW(XW, u, t) : new s(zW(t)), e, u);
          });
          if (qW) {
            qW(u, fU);
          }
          YW(KW(s), function (e) {
            if (!(e in u)) {
              DW(u, e, s[e]);
            }
          });
          u.prototype = c;
        }
      } else {
        u = t(function (e, t, n, a) {
          OW(e, c);
          var i;
          var o;
          var s;
          var l = 0;
          var p = 0;
          if (VW(t)) {
            if (!kU(t)) {
              if (mU(t)) {
                return bU(u, t);
              } else {
                return EW(XW, u, t);
              }
            }
            i = t;
            p = PW(n, r);
            var f = t.byteLength;
            if (a === undefined) {
              if (f % r) {
                throw sU(yU);
              }
              if ((o = f - p) < 0) {
                throw sU(yU);
              }
            } else if ((o = LW(a) * r) + p > f) {
              throw sU(yU);
            }
            s = o / r;
          } else {
            s = zW(t);
            i = new uU(o = s * r);
          }
          for (nU(e, {
            buffer: i,
            byteOffset: p,
            byteLength: o,
            length: s,
            view: new lU(i)
          }); l < s;) {
            h(e, l++);
          }
        });
        if (qW) {
          qW(u, fU);
        }
        c = u.prototype = jW(dU);
      }
      if (c.constructor !== u) {
        DW(c, "constructor", u);
      }
      rU(c).TypedArrayConstructor = u;
      if (pU) {
        DW(c, pU, a);
      }
      var p = u != s;
      l[a] = u;
      SW({
        global: true,
        constructor: true,
        forced: p,
        sham: !hU
      }, l);
      if (!(gU in u)) {
        DW(u, gU, r);
      }
      if (!(gU in c)) {
        DW(c, gU, r);
      }
      JW(a);
    };
  } else {
    XB.exports = function () {};
  }
  var SU = XB.exports;
  SU("Float32", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  SU("Float64", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  SU("Int8", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  SU("Int16", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  SU("Int32", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  SU("Uint8", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  SU("Uint8", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  }, true);
  SU("Uint16", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  SU("Uint32", function (e) {
    return function (t, n, r) {
      return e(this, t, n, r);
    };
  });
  var TU = Kr;
  var EU = Pr;
  var CU = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("at", function (e) {
    var t = CU(this);
    var n = TU(t);
    var r = EU(e);
    var a = r >= 0 ? r : n + r;
    if (a < 0 || a >= n) {
      return undefined;
    } else {
      return t[a];
    }
  });
  var AU = Pb;
  var RU = ee(Ep);
  var _U = AU.aTypedArray;
  (0, AU.exportTypedArrayMethod)("copyWithin", function (e, t) {
    return RU(_U(this), e, t, arguments.length > 2 ? arguments[2] : undefined);
  });
  var OU = Wo.every;
  var FU = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("every", function (e) {
    return OU(FU(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var DU = Mp;
  var MU = pW;
  var LU = qa;
  var zU = j;
  var PU = B;
  var BU = Pb.aTypedArray;
  var WU = Pb.exportTypedArrayMethod;
  var UU = ee("".slice);
  var VU = PU(function () {
    var e = 0;
    new Int8Array(2).fill({
      valueOf: function () {
        return e++;
      }
    });
    return e !== 1;
  });
  WU("fill", function (e) {
    var t = arguments.length;
    BU(this);
    var n = UU(LU(this), 0, 3) === "Big" ? MU(e) : +e;
    return zU(DU, this, n, t > 1 ? arguments[1] : undefined, t > 2 ? arguments[2] : undefined);
  }, VU);
  var GU = Kb;
  var jU = Pb.aTypedArrayConstructor;
  var HU = Pb.getTypedArrayConstructor;
  function qU(e) {
    return jU(GU(e, HU(e)));
  }
  var KU = eg;
  var XU = qU;
  function YU(e, t) {
    return KU(XU(e), t);
  }
  var JU = Wo.filter;
  var ZU = YU;
  var QU = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("filter", function (e) {
    var t = JU(QU(this), e, arguments.length > 1 ? arguments[1] : undefined);
    return ZU(this, t);
  });
  var $U = Wo.find;
  var eV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("find", function (e) {
    return $U(eV(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var tV = Wo.findIndex;
  var nV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("findIndex", function (e) {
    return tV(nV(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var rV = $p.findLast;
  var aV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("findLast", function (e) {
    return rV(aV(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var iV = $p.findLastIndex;
  var oV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("findLastIndex", function (e) {
    return iV(oV(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var sV = Wo.forEach;
  var uV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("forEach", function (e) {
    sV(uV(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  (0, Pb.exportTypedArrayStaticMethod)("from", NW, tW);
  var cV = Qr.includes;
  var lV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("includes", function (e) {
    return cV(lV(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var hV = Qr.indexOf;
  var pV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("indexOf", function (e) {
    return hV(pV(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var fV = z;
  var dV = B;
  var vV = ee;
  var mV = Pb;
  var gV = Kd;
  var yV = Mt("iterator");
  var bV = fV.Uint8Array;
  var xV = vV(gV.values);
  var kV = vV(gV.keys);
  var wV = vV(gV.entries);
  var IV = mV.aTypedArray;
  var NV = mV.exportTypedArrayMethod;
  var SV = bV && bV.prototype;
  var TV = !dV(function () {
    SV[yV].call([1]);
  });
  var EV = !!SV && SV.values && SV[yV] === SV.values && SV.values.name === "values";
  function CV() {
    return xV(IV(this));
  }
  NV("entries", function () {
    return wV(IV(this));
  }, TV);
  NV("keys", function () {
    return kV(IV(this));
  }, TV);
  NV("values", CV, TV || !EV, {
    name: "values"
  });
  NV(yV, CV, TV || !EV, {
    name: "values"
  });
  var AV = Pb.aTypedArray;
  var RV = Pb.exportTypedArrayMethod;
  var _V = ee([].join);
  RV("join", function (e) {
    return _V(AV(this), e);
  });
  var OV = fu;
  var FV = cv;
  var DV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("lastIndexOf", function (e) {
    var t = arguments.length;
    return OV(FV, DV(this), t > 1 ? [e, arguments[1]] : [e]);
  });
  var MV = Wo.map;
  var LV = qU;
  var zV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("map", function (e) {
    return MV(zV(this), e, arguments.length > 1 ? arguments[1] : undefined, function (e, t) {
      return new (LV(e))(t);
    });
  });
  var PV = Pb.aTypedArrayConstructor;
  (0, Pb.exportTypedArrayStaticMethod)("of", function () {
    for (var e = 0, t = arguments.length, n = new (PV(this))(t); t > e;) {
      n[e] = arguments[e++];
    }
    return n;
  }, tW);
  var BV = Av.left;
  var WV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("reduce", function (e) {
    var t = arguments.length;
    return BV(WV(this), e, t, t > 1 ? arguments[1] : undefined);
  });
  var UV = Av.right;
  var VV = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("reduceRight", function (e) {
    var t = arguments.length;
    return UV(VV(this), e, t, t > 1 ? arguments[1] : undefined);
  });
  var GV = Pb.aTypedArray;
  var jV = Pb.exportTypedArrayMethod;
  var HV = Math.floor;
  jV("reverse", function () {
    var e;
    var t = this;
    var n = GV(t).length;
    for (var r = HV(n / 2), a = 0; a < r;) {
      e = t[a];
      t[a++] = t[--n];
      t[n] = e;
    }
    return t;
  });
  var qV = z;
  var KV = j;
  var XV = Pb;
  var YV = Kr;
  var JV = sW;
  var ZV = yt;
  var QV = B;
  var $V = qV.RangeError;
  var eG = qV.Int8Array;
  var tG = eG && eG.prototype;
  var nG = tG && tG.set;
  var rG = XV.aTypedArray;
  var aG = XV.exportTypedArrayMethod;
  var iG = !QV(function () {
    var e = new Uint8ClampedArray(2);
    KV(nG, e, {
      length: 1,
      0: 3
    }, 1);
    return e[1] !== 3;
  });
  var oG = iG && XV.NATIVE_ARRAY_BUFFER_VIEWS && QV(function () {
    var e = new eG(2);
    e.set(1);
    e.set("2", 1);
    return e[0] !== 0 || e[1] !== 2;
  });
  aG("set", function (e) {
    rG(this);
    var t = JV(arguments.length > 1 ? arguments[1] : undefined, 1);
    var n = ZV(e);
    if (iG) {
      return KV(nG, this, n, t);
    }
    var r = this.length;
    var a = YV(n);
    var i = 0;
    if (a + t > r) {
      throw $V("Wrong length");
    }
    while (i < a) {
      this[t + i] = n[i++];
    }
  }, !iG || oG);
  var sG = qU;
  var uG = du;
  var cG = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("slice", function (e, t) {
    var n = uG(cG(this), e, t);
    var r = sG(this);
    for (var a = 0, i = n.length, o = new r(i); i > a;) {
      o[a] = n[a++];
    }
    return o;
  }, B(function () {
    new Int8Array(1).slice();
  }));
  var lG = Wo.some;
  var hG = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("some", function (e) {
    return lG(hG(this), e, arguments.length > 1 ? arguments[1] : undefined);
  });
  var pG = ro;
  var fG = B;
  var dG = Ze;
  var vG = nm;
  var mG = am;
  var gG = im;
  var yG = Le;
  var bG = sm;
  var xG = Pb.aTypedArray;
  var kG = Pb.exportTypedArrayMethod;
  var wG = z.Uint16Array;
  var IG = wG && pG(wG.prototype.sort);
  var NG = !!IG && (!fG(function () {
    IG(new wG(2), null);
  }) || !fG(function () {
    IG(new wG(2), {});
  }));
  var SG = !!IG && !fG(function () {
    if (yG) {
      return yG < 74;
    }
    if (mG) {
      return mG < 67;
    }
    if (gG) {
      return true;
    }
    if (bG) {
      return bG < 602;
    }
    var e;
    var t;
    var n = new wG(516);
    var r = Array(516);
    for (e = 0; e < 516; e++) {
      t = e % 4;
      n[e] = 515 - e;
      r[e] = e - t * 2 + 3;
    }
    IG(n, function (e, t) {
      return (e / 4 | 0) - (t / 4 | 0);
    });
    e = 0;
    for (; e < 516; e++) {
      if (n[e] !== r[e]) {
        return true;
      }
    }
  });
  kG("sort", function (e) {
    if (e !== undefined) {
      dG(e);
    }
    if (SG) {
      return IG(this, e);
    } else {
      return vG(xG(this), function (e) {
        return function (t, n) {
          if (e !== undefined) {
            return +e(t, n) || 0;
          } else if (n != n) {
            return -1;
          } else if (t != t) {
            return 1;
          } else if (t === 0 && n === 0) {
            if (1 / t > 0 && 1 / n < 0) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return t > n;
          }
        };
      }(e));
    }
  }, !SG || NG);
  var TG = Hr;
  var EG = Vr;
  var CG = qU;
  var AG = Pb.aTypedArray;
  (0, Pb.exportTypedArrayMethod)("subarray", function (e, t) {
    var n = AG(this);
    var r = n.length;
    var a = EG(e, r);
    return new (CG(n))(n.buffer, n.byteOffset + a * n.BYTES_PER_ELEMENT, TG((t === undefined ? r : EG(t, r)) - a));
  });
  var RG = fu;
  var _G = Pb;
  var OG = B;
  var FG = du;
  var DG = z.Int8Array;
  var MG = _G.aTypedArray;
  var LG = _G.exportTypedArrayMethod;
  var zG = [].toLocaleString;
  var PG = !!DG && OG(function () {
    zG.call(new DG(1));
  });
  LG("toLocaleString", function () {
    return RG(zG, PG ? FG(MG(this)) : MG(this), FG(arguments));
  }, OG(function () {
    return [1, 2].toLocaleString() != new DG([1, 2]).toLocaleString();
  }) || !OG(function () {
    DG.prototype.toLocaleString.call([1, 2]);
  }));
  var BG = Xm;
  var WG = Pb.aTypedArray;
  var UG = Pb.getTypedArrayConstructor;
  (0, Pb.exportTypedArrayMethod)("toReversed", function () {
    return BG(WG(this), UG(this));
  });
  var VG = Ze;
  var GG = eg;
  var jG = Pb.aTypedArray;
  var HG = Pb.getTypedArrayConstructor;
  var qG = Pb.exportTypedArrayMethod;
  var KG = ee(Pb.TypedArrayPrototype.sort);
  qG("toSorted", function (e) {
    if (e !== undefined) {
      VG(e);
    }
    var t = jG(this);
    var n = GG(HG(t), t);
    return KG(n, e);
  });
  var XG = Pb.exportTypedArrayMethod;
  var YG = B;
  var JG = ee;
  var ZG = z.Uint8Array;
  var QG = ZG && ZG.prototype || {};
  var $G = [].toString;
  var ej = JG([].join);
  if (YG(function () {
    $G.call({});
  })) {
    $G = function () {
      return ej(this);
    };
  }
  var tj = QG.toString != $G;
  XG("toString", $G, tj);
  var nj = Cg;
  var rj = cW;
  var aj = Pr;
  var ij = pW;
  var oj = Pb.aTypedArray;
  var sj = Pb.getTypedArrayConstructor;
  var uj = Pb.exportTypedArrayMethod;
  var cj = !!function () {
    try {
      new Int8Array(1).with(2, {
        valueOf: function () {
          throw 8;
        }
      });
    } catch (e) {
      return e === 8;
    }
  }();
  uj("with", {
    with: function (e, t) {
      var n = oj(this);
      var r = aj(e);
      var a = rj(n) ? ij(t) : +t;
      return nj(n, sj(n), r, a);
    }
  }.with, !cj);
  var lj = La;
  var hj = ee;
  var pj = Ya;
  var fj = String.fromCharCode;
  var dj = hj("".charAt);
  var vj = hj(/./.exec);
  var mj = hj("".slice);
  var gj = /^[\da-f]{2}$/i;
  var yj = /^[\da-f]{4}$/i;
  lj({
    global: true
  }, {
    unescape: function (e) {
      var t;
      var n;
      var r = pj(e);
      var a = "";
      for (var i = r.length, o = 0; o < i;) {
        if ((t = dj(r, o++)) === "%") {
          if (dj(r, o) === "u") {
            n = mj(r, o + 1, o + 5);
            if (vj(yj, n)) {
              a += fj(parseInt(n, 16));
              o += 5;
              continue;
            }
          } else {
            n = mj(r, o, o + 2);
            if (vj(gj, n)) {
              a += fj(parseInt(n, 16));
              o += 2;
              continue;
            }
          }
        }
        a += t;
      }
      return a;
    }
  });
  var bj = ee;
  var xj = Dg;
  var kj = Sw.getWeakData;
  var wj = zg;
  var Ij = dn;
  var Nj = le;
  var Sj = Ie;
  var Tj = yh;
  var Ej = kt;
  var Cj = cr.set;
  var Aj = cr.getterFor;
  var Rj = Wo.find;
  var _j = Wo.findIndex;
  var Oj = bj([].splice);
  var Fj = 0;
  function Dj(e) {
    return e.frozen ||= new Mj();
  }
  function Mj() {
    this.entries = [];
  }
  function Lj(e, t) {
    return Rj(e.entries, function (e) {
      return e[0] === t;
    });
  }
  Mj.prototype = {
    get: function (e) {
      var t = Lj(this, e);
      if (t) {
        return t[1];
      }
    },
    has: function (e) {
      return !!Lj(this, e);
    },
    set: function (e, t) {
      var n = Lj(this, e);
      if (n) {
        n[1] = t;
      } else {
        this.entries.push([e, t]);
      }
    },
    delete: function (e) {
      var t = _j(this.entries, function (t) {
        return t[0] === e;
      });
      if (~t) {
        Oj(this.entries, t, 1);
      }
      return !!~t;
    }
  };
  var zj;
  var Pj = {
    getConstructor: function (e, t, n, r) {
      var a = e(function (e, a) {
        wj(e, i);
        Cj(e, {
          type: t,
          id: Fj++,
          frozen: undefined
        });
        if (!Nj(a)) {
          Tj(a, e[r], {
            that: e,
            AS_ENTRIES: n
          });
        }
      });
      var i = a.prototype;
      var o = Aj(t);
      function s(e, t, n) {
        var r = o(e);
        var a = kj(Ij(t), true);
        if (a === true) {
          Dj(r).set(t, n);
        } else {
          a[r.id] = n;
        }
        return e;
      }
      xj(i, {
        delete: function (e) {
          var t = o(this);
          if (!Sj(e)) {
            return false;
          }
          var n = kj(e);
          if (n === true) {
            return Dj(t).delete(e);
          } else {
            return n && Ej(n, t.id) && delete n[t.id];
          }
        },
        has: function (e) {
          var t = o(this);
          if (!Sj(e)) {
            return false;
          }
          var n = kj(e);
          if (n === true) {
            return Dj(t).has(e);
          } else {
            return n && Ej(n, t.id);
          }
        }
      });
      xj(i, n ? {
        get: function (e) {
          var t = o(this);
          if (Sj(e)) {
            var n = kj(e);
            if (n === true) {
              return Dj(t).get(e);
            } else if (n) {
              return n[t.id];
            } else {
              return undefined;
            }
          }
        },
        set: function (e, t) {
          return s(this, e, t);
        }
      } : {
        add: function (e) {
          return s(this, e, true);
        }
      });
      return a;
    }
  };
  var Bj = cw;
  var Wj = z;
  var Uj = ee;
  var Vj = Dg;
  var Gj = Sw;
  var jj = Uw;
  var Hj = Pj;
  var qj = Ie;
  var Kj = cr.enforce;
  var Xj = B;
  var Yj = Hn;
  var Jj = Object;
  var Zj = Array.isArray;
  var Qj = Jj.isExtensible;
  var $j = Jj.isFrozen;
  var eH = Jj.isSealed;
  var tH = Jj.freeze;
  var nH = Jj.seal;
  var rH = {};
  var aH = {};
  var iH = !Wj.ActiveXObject && "ActiveXObject" in Wj;
  function oH(e) {
    return function () {
      return e(this, arguments.length ? arguments[0] : undefined);
    };
  }
  var sH = jj("WeakMap", oH, Hj);
  var uH = sH.prototype;
  var cH = Uj(uH.set);
  if (Yj) {
    if (iH) {
      zj = Hj.getConstructor(oH, "WeakMap", true);
      Gj.enable();
      var lH = Uj(uH.delete);
      var hH = Uj(uH.has);
      var pH = Uj(uH.get);
      Vj(uH, {
        delete: function (e) {
          if (qj(e) && !Qj(e)) {
            var t = Kj(this);
            t.frozen ||= new zj();
            return lH(this, e) || t.frozen.delete(e);
          }
          return lH(this, e);
        },
        has: function (e) {
          if (qj(e) && !Qj(e)) {
            var t = Kj(this);
            t.frozen ||= new zj();
            return hH(this, e) || t.frozen.has(e);
          }
          return hH(this, e);
        },
        get: function (e) {
          if (qj(e) && !Qj(e)) {
            var t = Kj(this);
            t.frozen ||= new zj();
            if (hH(this, e)) {
              return pH(this, e);
            } else {
              return t.frozen.get(e);
            }
          }
          return pH(this, e);
        },
        set: function (e, t) {
          if (qj(e) && !Qj(e)) {
            var n = Kj(this);
            n.frozen ||= new zj();
            if (hH(this, e)) {
              cH(this, e, t);
            } else {
              n.frozen.set(e, t);
            }
          } else {
            cH(this, e, t);
          }
          return this;
        }
      });
    } else if (Bj && Xj(function () {
      var e = tH([]);
      cH(new sH(), e, 1);
      return !$j(e);
    })) {
      Vj(uH, {
        set: function (e, t) {
          var n;
          if (Zj(e)) {
            if ($j(e)) {
              n = rH;
            } else if (eH(e)) {
              n = aH;
            }
          }
          cH(this, e, t);
          if (n == rH) {
            tH(e);
          }
          if (n == aH) {
            nH(e);
          }
          return this;
        }
      });
    }
  }
  Uw("WeakSet", function (e) {
    return function () {
      return e(this, arguments.length ? arguments[0] : undefined);
    };
  }, Pj);
  var fH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var dH = {};
  for (var vH = 0; vH < 66; vH++) {
    dH[fH.charAt(vH)] = vH;
  }
  var mH = {
    itoc: fH,
    ctoi: dH
  };
  var gH = La;
  var yH = z;
  var bH = Ee;
  var xH = ee;
  var kH = j;
  var wH = B;
  var IH = Ya;
  var NH = kt;
  var SH = TC;
  var TH = mH.ctoi;
  var EH = /[^\d+/a-z]/i;
  var CH = /[\t\n\f\r ]+/g;
  var AH = /[=]{1,2}$/;
  var RH = bH("atob");
  var _H = String.fromCharCode;
  var OH = xH("".charAt);
  var FH = xH("".replace);
  var DH = xH(EH.exec);
  var MH = wH(function () {
    return RH(" ") !== "";
  });
  var LH = !wH(function () {
    RH("a");
  });
  var zH = !MH && !LH && !wH(function () {
    RH();
  });
  var PH = !MH && !LH && RH.length !== 1;
  gH({
    global: true,
    bind: true,
    enumerable: true,
    forced: MH || LH || zH || PH
  }, {
    atob: function (e) {
      SH(arguments.length, 1);
      if (zH || PH) {
        return kH(RH, yH, e);
      }
      var t;
      var n;
      var r = FH(IH(e), CH, "");
      var a = "";
      var i = 0;
      var o = 0;
      if (r.length % 4 == 0) {
        r = FH(r, AH, "");
      }
      if (r.length % 4 == 1 || DH(EH, r)) {
        throw new (bH("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
      }
      while (t = OH(r, i++)) {
        if (NH(TH, t)) {
          n = o % 4 ? n * 64 + TH[t] : TH[t];
          if (o++ % 4) {
            a += _H(n >> (o * -2 & 6) & 255);
          }
        }
      }
      return a;
    }
  });
  var BH = La;
  var WH = z;
  var UH = Ee;
  var VH = ee;
  var GH = j;
  var jH = B;
  var HH = Ya;
  var qH = TC;
  var KH = mH.itoc;
  var XH = UH("btoa");
  var YH = VH("".charAt);
  var JH = VH("".charCodeAt);
  var ZH = !!XH && !jH(function () {
    XH();
  });
  var QH = !!XH && jH(function () {
    return XH(null) !== "bnVsbA==";
  });
  var $H = !!XH && XH.length !== 1;
  BH({
    global: true,
    bind: true,
    enumerable: true,
    forced: ZH || QH || $H
  }, {
    btoa: function (e) {
      qH(arguments.length, 1);
      if (ZH || QH || $H) {
        return GH(XH, WH, HH(e));
      }
      var t;
      var n;
      for (var r = HH(e), a = "", i = 0, o = KH; YH(r, i) || (o = "=", i % 1);) {
        if ((n = JH(r, i += 3 / 4)) > 255) {
          throw new (UH("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
        }
        a += YH(o, (t = t << 8 | n) >> 8 - i % 1 * 8 & 63);
      }
      return a;
    }
  });
  var eq = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  var tq = Jt("span").classList;
  var nq = tq && tq.constructor && tq.constructor.prototype;
  var rq = nq === Object.prototype ? undefined : nq;
  var aq = z;
  var iq = eq;
  var oq = rq;
  var sq = kf;
  var uq = Cn;
  function cq(e) {
    if (e && e.forEach !== sq) {
      try {
        uq(e, "forEach", sq);
      } catch (t) {
        e.forEach = sq;
      }
    }
  }
  for (var lq in iq) {
    if (iq[lq]) {
      cq(aq[lq] && aq[lq].prototype);
    }
  }
  cq(oq);
  var hq = z;
  var pq = eq;
  var fq = rq;
  var dq = Kd;
  var vq = Cn;
  var mq = Mt;
  var gq = mq("iterator");
  var yq = mq("toStringTag");
  var bq = dq.values;
  function xq(e, t) {
    if (e) {
      if (e[gq] !== bq) {
        try {
          vq(e, gq, bq);
        } catch (t) {
          e[gq] = bq;
        }
      }
      if (!e[yq]) {
        vq(e, yq, t);
      }
      if (pq[t]) {
        for (var n in dq) {
          if (e[n] !== dq[n]) {
            try {
              vq(e, n, dq[n]);
            } catch (t) {
              e[n] = dq[n];
            }
          }
        }
      }
    }
  }
  for (var kq in pq) {
    xq(hq[kq] && hq[kq].prototype, kq);
  }
  xq(fq, "DOMTokenList");
  var wq = Rv;
  function Iq(e) {
    try {
      if (wq) {
        return Function("return require(\"" + e + "\")")();
      }
    } catch (e) {}
  }
  var Nq = {
    IndexSizeError: {
      s: "INDEX_SIZE_ERR",
      c: 1,
      m: 1
    },
    DOMStringSizeError: {
      s: "DOMSTRING_SIZE_ERR",
      c: 2,
      m: 0
    },
    HierarchyRequestError: {
      s: "HIERARCHY_REQUEST_ERR",
      c: 3,
      m: 1
    },
    WrongDocumentError: {
      s: "WRONG_DOCUMENT_ERR",
      c: 4,
      m: 1
    },
    InvalidCharacterError: {
      s: "INVALID_CHARACTER_ERR",
      c: 5,
      m: 1
    },
    NoDataAllowedError: {
      s: "NO_DATA_ALLOWED_ERR",
      c: 6,
      m: 0
    },
    NoModificationAllowedError: {
      s: "NO_MODIFICATION_ALLOWED_ERR",
      c: 7,
      m: 1
    },
    NotFoundError: {
      s: "NOT_FOUND_ERR",
      c: 8,
      m: 1
    },
    NotSupportedError: {
      s: "NOT_SUPPORTED_ERR",
      c: 9,
      m: 1
    },
    InUseAttributeError: {
      s: "INUSE_ATTRIBUTE_ERR",
      c: 10,
      m: 1
    },
    InvalidStateError: {
      s: "INVALID_STATE_ERR",
      c: 11,
      m: 1
    },
    SyntaxError: {
      s: "SYNTAX_ERR",
      c: 12,
      m: 1
    },
    InvalidModificationError: {
      s: "INVALID_MODIFICATION_ERR",
      c: 13,
      m: 1
    },
    NamespaceError: {
      s: "NAMESPACE_ERR",
      c: 14,
      m: 1
    },
    InvalidAccessError: {
      s: "INVALID_ACCESS_ERR",
      c: 15,
      m: 1
    },
    ValidationError: {
      s: "VALIDATION_ERR",
      c: 16,
      m: 0
    },
    TypeMismatchError: {
      s: "TYPE_MISMATCH_ERR",
      c: 17,
      m: 1
    },
    SecurityError: {
      s: "SECURITY_ERR",
      c: 18,
      m: 1
    },
    NetworkError: {
      s: "NETWORK_ERR",
      c: 19,
      m: 1
    },
    AbortError: {
      s: "ABORT_ERR",
      c: 20,
      m: 1
    },
    URLMismatchError: {
      s: "URL_MISMATCH_ERR",
      c: 21,
      m: 1
    },
    QuotaExceededError: {
      s: "QUOTA_EXCEEDED_ERR",
      c: 22,
      m: 1
    },
    TimeoutError: {
      s: "TIMEOUT_ERR",
      c: 23,
      m: 1
    },
    InvalidNodeTypeError: {
      s: "INVALID_NODE_TYPE_ERR",
      c: 24,
      m: 1
    },
    DataCloneError: {
      s: "DATA_CLONE_ERR",
      c: 25,
      m: 1
    }
  };
  var Sq = La;
  var Tq = Iq;
  var Eq = Ee;
  var Cq = B;
  var Aq = yi;
  var Rq = Y;
  var _q = cn.f;
  var Oq = Or;
  var Fq = zi;
  var Dq = kt;
  var Mq = zg;
  var Lq = dn;
  var zq = Nl;
  var Pq = Dc;
  var Bq = Nq;
  var Wq = Gc;
  var Uq = cr;
  var Vq = W;
  var Gq = "DOMException";
  var jq = "DATA_CLONE_ERR";
  var Hq = Eq("Error");
  var qq = Eq(Gq) || function () {
    try {
      new (Eq("MessageChannel") || Tq("worker_threads").MessageChannel)().port1.postMessage(new WeakMap());
    } catch (e) {
      if (e.name == jq && e.code == 25) {
        return e.constructor;
      }
    }
  }();
  var Kq = qq && qq.prototype;
  var Xq = Hq.prototype;
  var Yq = Uq.set;
  var Jq = Uq.getterFor(Gq);
  var Zq = "stack" in Hq(Gq);
  function Qq(e) {
    if (Dq(Bq, e) && Bq[e].m) {
      return Bq[e].c;
    } else {
      return 0;
    }
  }
  function $q() {
    Mq(this, eK);
    var e = arguments.length;
    var t = Pq(e < 1 ? undefined : arguments[0]);
    var n = Pq(e < 2 ? undefined : arguments[1], "Error");
    var r = Qq(n);
    Yq(this, {
      type: Gq,
      name: n,
      message: t,
      code: r
    });
    if (!Vq) {
      this.name = n;
      this.message = t;
      this.code = r;
    }
    if (Zq) {
      var a = Hq(t);
      a.name = Gq;
      _q(this, "stack", Rq(1, Wq(a.stack, 1)));
    }
  }
  var eK = $q.prototype = Aq(Xq);
  function tK(e) {
    return {
      enumerable: true,
      configurable: true,
      get: e
    };
  }
  function nK(e) {
    return tK(function () {
      return Jq(this)[e];
    });
  }
  if (Vq) {
    Fq(eK, "code", nK("code"));
    Fq(eK, "message", nK("message"));
    Fq(eK, "name", nK("name"));
  }
  _q(eK, "constructor", Rq(1, $q));
  var rK = Cq(function () {
    return !(new qq() instanceof Hq);
  });
  var aK = rK || Cq(function () {
    return Xq.toString !== zq || String(new qq(1, 2)) !== "2: 1";
  });
  var iK = rK || Cq(function () {
    return new qq(1, "DataCloneError").code !== 25;
  });
  if (!rK && qq.DATA_CLONE_ERR === 25) {
    Kq.DATA_CLONE_ERR;
  }
  Sq({
    global: true,
    constructor: true,
    forced: rK
  }, {
    DOMException: rK ? $q : qq
  });
  var oK = Eq(Gq);
  var sK = oK.prototype;
  if (aK && qq === oK) {
    Oq(sK, "toString", zq);
  }
  if (iK && Vq && qq === oK) {
    Fq(sK, "code", tK(function () {
      return Qq(Lq(this).name);
    }));
  }
  for (var uK in Bq) {
    if (Dq(Bq, uK)) {
      var cK = Bq[uK];
      var lK = cK.s;
      var hK = Rq(6, cK.c);
      if (!Dq(oK, lK)) {
        _q(oK, lK, hK);
      }
      if (!Dq(sK, lK)) {
        _q(sK, lK, hK);
      }
    }
  }
  var pK = La;
  var fK = z;
  var dK = Ee;
  var vK = Y;
  var mK = cn.f;
  var gK = kt;
  var yK = zg;
  var bK = Oc;
  var xK = Dc;
  var kK = Nq;
  var wK = Gc;
  var IK = W;
  var NK = "DOMException";
  var SK = dK("Error");
  var TK = dK(NK);
  function EK() {
    yK(this, CK);
    var e = arguments.length;
    var t = xK(e < 1 ? undefined : arguments[0]);
    var n = xK(e < 2 ? undefined : arguments[1], "Error");
    var r = new TK(t, n);
    var a = SK(t);
    a.name = NK;
    mK(r, "stack", vK(1, wK(a.stack, 1)));
    bK(r, this, EK);
    return r;
  }
  var CK = EK.prototype = TK.prototype;
  var AK = "stack" in SK(NK);
  var RK = "stack" in new TK(1, 2);
  var _K = TK && IK && Object.getOwnPropertyDescriptor(fK, NK);
  var OK = !!_K && (!_K.writable || !_K.configurable);
  var FK = AK && !OK && !RK;
  pK({
    global: true,
    constructor: true,
    forced: FK
  }, {
    DOMException: FK ? EK : TK
  });
  var DK = dK(NK);
  var MK = DK.prototype;
  if (MK.constructor !== DK) {
    mK(MK, "constructor", vK(1, DK));
    for (var LK in kK) {
      if (gK(kK, LK)) {
        var zK = kK[LK];
        var PK = zK.s;
        if (!gK(DK, PK)) {
          mK(DK, PK, vK(6, zK.c));
        }
      }
    }
  }
  var BK = "DOMException";
  eo(Ee(BK), BK);
  var WK = eA.clear;
  La({
    global: true,
    bind: true,
    enumerable: true,
    forced: z.clearImmediate !== WK
  }, {
    clearImmediate: WK
  });
  var UK = typeof Bun == "function" && Bun && typeof Bun.version == "string";
  var VK = z;
  var GK = fu;
  var jK = xe;
  var HK = UK;
  var qK = Ae;
  var KK = du;
  var XK = TC;
  var YK = VK.Function;
  var JK = /MSIE .\./.test(qK) || HK && function () {
    var e = VK.Bun.version.split(".");
    return e.length < 3 || e[0] == 0 && (e[1] < 3 || e[1] == 3 && e[2] == 0);
  }();
  function ZK(e, t) {
    var n = t ? 2 : 1;
    if (JK) {
      return function (r, a) {
        var i = XK(arguments.length, 1) > n;
        var o = jK(r) ? r : YK(r);
        var s = i ? KK(arguments, n) : [];
        var u = i ? function () {
          GK(o, this, s);
        } : o;
        if (t) {
          return e(u, a);
        } else {
          return e(u);
        }
      };
    } else {
      return e;
    }
  }
  var QK = La;
  var $K = z;
  var eX = eA.set;
  var tX = ZK;
  var nX = $K.setImmediate ? tX(eX, false) : eX;
  QK({
    global: true,
    bind: true,
    enumerable: true,
    forced: $K.setImmediate !== nX
  }, {
    setImmediate: nX
  });
  var rX = La;
  var aX = RA;
  var iX = Ze;
  var oX = TC;
  var sX = Rv;
  var uX = z.process;
  rX({
    global: true,
    enumerable: true,
    dontCallGetSet: true
  }, {
    queueMicrotask: function (e) {
      oX(arguments.length, 1);
      iX(e);
      var t = sX && uX.domain;
      aX(t ? t.bind(e) : e);
    }
  });
  var cX = La;
  var lX = z;
  var hX = zi;
  var pX = W;
  var fX = TypeError;
  var dX = Object.defineProperty;
  var vX = lX.self !== lX;
  try {
    if (pX) {
      var mX = Object.getOwnPropertyDescriptor(lX, "self");
      if (!!vX || !mX || !mX.get || !mX.enumerable) {
        hX(lX, "self", {
          get: function () {
            return lX;
          },
          set: function (e) {
            if (this !== lX) {
              throw fX("Illegal invocation");
            }
            dX(lX, "self", {
              value: e,
              writable: true,
              configurable: true,
              enumerable: true
            });
          },
          configurable: true,
          enumerable: true
        });
      }
    } else {
      cX({
        global: true,
        simple: true,
        forced: vX
      }, {
        self: lX
      });
    }
  } catch (e) {}
  var gX;
  var yX = ee;
  var bX = Map.prototype;
  var xX = {
    Map: Map,
    set: yX(bX.set),
    get: yX(bX.get),
    has: yX(bX.has),
    remove: yX(bX.delete),
    proto: bX
  };
  var kX = ee;
  var wX = Set.prototype;
  var IX = {
    Set: Set,
    add: kX(wX.add),
    has: kX(wX.has),
    remove: kX(wX.delete),
    proto: wX,
    $has: wX.has,
    $keys: wX.keys
  };
  var NX = B;
  var SX = Le;
  var TX = MA;
  var EX = DA;
  var CX = Rv;
  var AX = z.structuredClone;
  var RX = !!AX && !NX(function () {
    if (EX && SX > 92 || CX && SX > 94 || TX && SX > 97) {
      return false;
    }
    var e = new ArrayBuffer(8);
    var t = AX(e, {
      transfer: [e]
    });
    return e.byteLength != 0 || t.byteLength != 8;
  });
  var _X = La;
  var OX = z;
  var FX = Ee;
  var DX = ee;
  var MX = B;
  var LX = Tt;
  var zX = xe;
  var PX = No;
  var BX = le;
  var WX = Ie;
  var UX = He;
  var VX = yh;
  var GX = dn;
  var jX = qa;
  var HX = kt;
  var qX = Ii;
  var KX = Cn;
  var XX = Kr;
  var YX = TC;
  var JX = nF;
  var ZX = xX;
  var QX = IX;
  var $X = Hc;
  var eY = RX;
  var tY = OX.Object;
  var nY = OX.Array;
  var rY = OX.Date;
  var aY = OX.Error;
  var iY = OX.EvalError;
  var oY = OX.RangeError;
  var sY = OX.ReferenceError;
  var uY = OX.SyntaxError;
  var cY = OX.TypeError;
  var lY = OX.URIError;
  var hY = OX.PerformanceMark;
  var pY = OX.WebAssembly;
  var fY = pY && pY.CompileError || aY;
  var dY = pY && pY.LinkError || aY;
  var vY = pY && pY.RuntimeError || aY;
  var mY = FX("DOMException");
  var gY = ZX.Map;
  var yY = ZX.has;
  var bY = ZX.get;
  var xY = ZX.set;
  var kY = QX.Set;
  var wY = QX.add;
  var IY = FX("Object", "keys");
  var NY = DX([].push);
  var SY = DX(true.valueOf);
  var TY = DX(1 .valueOf);
  var EY = DX("".valueOf);
  var CY = DX(rY.prototype.getTime);
  var AY = LX("structuredClone");
  var RY = "DataCloneError";
  var _Y = "Transferring";
  function OY(e) {
    return !MX(function () {
      var t = new OX.Set([7]);
      var n = e(t);
      var r = e(tY(7));
      return n == t || !n.has(7) || s(r) != "object" || r != 7;
    }) && e;
  }
  function FY(e, t) {
    return !MX(function () {
      var n = new t();
      var r = e({
        a: n,
        b: n
      });
      return !r || r.a !== r.b || !(r.a instanceof t) || r.a.stack !== n.stack;
    });
  }
  var DY = OX.structuredClone;
  var MY = !FY(DY, aY) || !FY(DY, mY) || (gX = DY, !!MX(function () {
    var e = gX(new OX.AggregateError([1], AY, {
      cause: 3
    }));
    return e.name != "AggregateError" || e.errors[0] != 1 || e.message != AY || e.cause != 3;
  }));
  var LY = !DY && OY(function (e) {
    return new hY(AY, {
      detail: e
    }).detail;
  });
  var zY = OY(DY) || LY;
  function PY(e) {
    throw new mY("Uncloneable type: " + e, RY);
  }
  function BY(e, t) {
    throw new mY((t || "Cloning") + " of " + e + " cannot be properly polyfilled in this engine", RY);
  }
  var WY = function e(t, n) {
    if (UX(t)) {
      PY("Symbol");
    }
    if (!WX(t)) {
      return t;
    }
    if (n) {
      if (yY(n, t)) {
        return bY(n, t);
      }
    } else {
      n = new gY();
    }
    var r;
    var a;
    var i;
    var o;
    var s;
    var u;
    var c;
    var l;
    var h;
    var p;
    var f;
    var d = jX(t);
    var v = false;
    switch (d) {
      case "Array":
        i = nY(XX(t));
        v = true;
        break;
      case "Object":
        i = {};
        v = true;
        break;
      case "Map":
        i = new gY();
        v = true;
        break;
      case "Set":
        i = new kY();
        v = true;
        break;
      case "RegExp":
        i = new RegExp(t.source, JX(t));
        break;
      case "Error":
        switch (a = t.name) {
          case "AggregateError":
            i = FX("AggregateError")([]);
            break;
          case "EvalError":
            i = iY();
            break;
          case "RangeError":
            i = oY();
            break;
          case "ReferenceError":
            i = sY();
            break;
          case "SyntaxError":
            i = uY();
            break;
          case "TypeError":
            i = cY();
            break;
          case "URIError":
            i = lY();
            break;
          case "CompileError":
            i = fY();
            break;
          case "LinkError":
            i = dY();
            break;
          case "RuntimeError":
            i = vY();
            break;
          default:
            i = aY();
        }
        v = true;
        break;
      case "DOMException":
        i = new mY(t.message, t.name);
        v = true;
        break;
      case "DataView":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array":
        r = OX[d];
        if (!WX(r)) {
          BY(d);
        }
        i = new r(e(t.buffer, n), t.byteOffset, d === "DataView" ? t.byteLength : t.length);
        break;
      case "DOMQuad":
        try {
          i = new DOMQuad(e(t.p1, n), e(t.p2, n), e(t.p3, n), e(t.p4, n));
        } catch (e) {
          if (zY) {
            i = zY(t);
          } else {
            BY(d);
          }
        }
        break;
      case "FileList":
        if (o = function () {
          var e;
          try {
            e = new OX.DataTransfer();
          } catch (t) {
            try {
              e = new OX.ClipboardEvent("").clipboardData;
            } catch (e) {}
          }
          if (e && e.items && e.files) {
            return e;
          } else {
            return null;
          }
        }()) {
          s = 0;
          u = XX(t);
          for (; s < u; s++) {
            o.items.add(e(t[s], n));
          }
          i = o.files;
        } else if (zY) {
          i = zY(t);
        } else {
          BY(d);
        }
        break;
      case "ImageData":
        try {
          i = new ImageData(e(t.data, n), t.width, t.height, {
            colorSpace: t.colorSpace
          });
        } catch (e) {
          if (zY) {
            i = zY(t);
          } else {
            BY(d);
          }
        }
        break;
      default:
        if (zY) {
          i = zY(t);
        } else {
          switch (d) {
            case "BigInt":
              i = tY(t.valueOf());
              break;
            case "Boolean":
              i = tY(SY(t));
              break;
            case "Number":
              i = tY(TY(t));
              break;
            case "String":
              i = tY(EY(t));
              break;
            case "Date":
              i = new rY(CY(t));
              break;
            case "ArrayBuffer":
              if (!(r = OX.DataView) && typeof t.slice != "function") {
                BY(d);
              }
              try {
                if (typeof t.slice != "function" || t.resizable) {
                  u = t.byteLength;
                  f = "maxByteLength" in t ? {
                    maxByteLength: t.maxByteLength
                  } : undefined;
                  i = new ArrayBuffer(u, f);
                  h = new r(t);
                  p = new r(i);
                  for (s = 0; s < u; s++) {
                    p.setUint8(s, h.getUint8(s));
                  }
                } else {
                  i = t.slice(0);
                }
              } catch (e) {
                throw new mY("ArrayBuffer is detached", RY);
              }
              break;
            case "SharedArrayBuffer":
              i = t;
              break;
            case "Blob":
              try {
                i = t.slice(0, t.size, t.type);
              } catch (e) {
                BY(d);
              }
              break;
            case "DOMPoint":
            case "DOMPointReadOnly":
              r = OX[d];
              try {
                i = r.fromPoint ? r.fromPoint(t) : new r(t.x, t.y, t.z, t.w);
              } catch (e) {
                BY(d);
              }
              break;
            case "DOMRect":
            case "DOMRectReadOnly":
              r = OX[d];
              try {
                i = r.fromRect ? r.fromRect(t) : new r(t.x, t.y, t.width, t.height);
              } catch (e) {
                BY(d);
              }
              break;
            case "DOMMatrix":
            case "DOMMatrixReadOnly":
              r = OX[d];
              try {
                i = r.fromMatrix ? r.fromMatrix(t) : new r(t);
              } catch (e) {
                BY(d);
              }
              break;
            case "AudioData":
            case "VideoFrame":
              if (!zX(t.clone)) {
                BY(d);
              }
              try {
                i = t.clone();
              } catch (e) {
                PY(d);
              }
              break;
            case "File":
              try {
                i = new File([t], t.name, t);
              } catch (e) {
                BY(d);
              }
              break;
            case "CropTarget":
            case "CryptoKey":
            case "FileSystemDirectoryHandle":
            case "FileSystemFileHandle":
            case "FileSystemHandle":
            case "GPUCompilationInfo":
            case "GPUCompilationMessage":
            case "ImageBitmap":
            case "RTCCertificate":
            case "WebAssembly.Module":
              BY(d);
            default:
              PY(d);
          }
        }
    }
    xY(n, t, i);
    if (v) {
      switch (d) {
        case "Array":
        case "Object":
          c = IY(t);
          s = 0;
          u = XX(c);
          for (; s < u; s++) {
            l = c[s];
            qX(i, l, e(t[l], n));
          }
          break;
        case "Map":
          t.forEach(function (t, r) {
            xY(i, e(r, n), e(t, n));
          });
          break;
        case "Set":
          t.forEach(function (t) {
            wY(i, e(t, n));
          });
          break;
        case "Error":
          KX(i, "message", e(t.message, n));
          if (HX(t, "cause")) {
            KX(i, "cause", e(t.cause, n));
          }
          if (a == "AggregateError") {
            i.errors = e(t.errors, n);
          }
        case "DOMException":
          if ($X) {
            KX(i, "stack", e(t.stack, n));
          }
      }
    }
    return i;
  };
  function UY(e, t) {
    if (!WX(e)) {
      throw cY("Transfer option cannot be converted to a sequence");
    }
    var n = [];
    VX(e, function (e) {
      NY(n, GX(e));
    });
    var r;
    var a;
    var i;
    var o;
    var s;
    var u;
    var c = 0;
    var l = XX(n);
    if (eY) {
      for (o = DY(n, {
        transfer: n
      }); c < l;) {
        xY(t, n[c], o[c++]);
      }
    } else {
      while (c < l) {
        r = n[c++];
        if (yY(t, r)) {
          throw new mY("Duplicate transferable", RY);
        }
        switch (a = jX(r)) {
          case "ImageBitmap":
            i = OX.OffscreenCanvas;
            if (!PX(i)) {
              BY(a, _Y);
            }
            try {
              (u = new i(r.width, r.height)).getContext("bitmaprenderer").transferFromImageBitmap(r);
              s = u.transferToImageBitmap();
            } catch (e) {}
            break;
          case "AudioData":
          case "VideoFrame":
            if (!zX(r.clone) || !zX(r.close)) {
              BY(a, _Y);
            }
            try {
              s = r.clone();
              r.close();
            } catch (e) {}
            break;
          case "ArrayBuffer":
            if (!zX(r.transfer)) {
              BY(a, _Y);
            }
            s = r.transfer();
            break;
          case "MediaSourceHandle":
          case "MessagePort":
          case "OffscreenCanvas":
          case "ReadableStream":
          case "TransformStream":
          case "WritableStream":
            BY(a, _Y);
        }
        if (s === undefined) {
          throw new mY("This object cannot be transferred: " + a, RY);
        }
        xY(t, r, s);
      }
    }
  }
  _X({
    global: true,
    enumerable: true,
    sham: !eY,
    forced: MY
  }, {
    structuredClone: function (e) {
      var t;
      var n = YX(arguments.length, 1) > 1 && !BX(arguments[1]) ? GX(arguments[1]) : undefined;
      var r = n ? n.transfer : undefined;
      if (r !== undefined) {
        t = new gY();
        UY(r, t);
      }
      return WY(e, t);
    }
  });
  var VY = La;
  var GY = z;
  var jY = ZK(GY.setInterval, true);
  VY({
    global: true,
    bind: true,
    forced: GY.setInterval !== jY
  }, {
    setInterval: jY
  });
  var HY = La;
  var qY = z;
  var KY = ZK(qY.setTimeout, true);
  HY({
    global: true,
    bind: true,
    forced: qY.setTimeout !== KY
  }, {
    setTimeout: KY
  });
  var XY = B;
  var YY = W;
  var JY = Mt("iterator");
  var ZY = !XY(function () {
    var e = new URL("b?a=1&b=2&c=3", "http://a");
    var t = e.searchParams;
    var n = "";
    e.pathname = "c%20d";
    t.forEach(function (e, r) {
      t.delete("b");
      n += r + e;
    });
    return !t.size && !YY || !t.sort || e.href !== "http://a/c%20d?a=1&c=3" || t.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !t[JY] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://ÑÐµÑÑ").host !== "xn--e1aybc" || new URL("http://a#Ð±").hash !== "#%D0%B1" || n !== "a1c3" || new URL("http://x", undefined).host !== "x";
  });
  var QY = ee;
  var $Y = 2147483647;
  var eJ = /[^\0-\u007E]/;
  var tJ = /[.\u3002\uFF0E\uFF61]/g;
  var nJ = "Overflow: input needs wider integers to process";
  var rJ = RangeError;
  var aJ = QY(tJ.exec);
  var iJ = Math.floor;
  var oJ = String.fromCharCode;
  var sJ = QY("".charCodeAt);
  var uJ = QY([].join);
  var cJ = QY([].push);
  var lJ = QY("".replace);
  var hJ = QY("".split);
  var pJ = QY("".toLowerCase);
  function fJ(e) {
    return e + 22 + (e < 26) * 75;
  }
  function dJ(e, t, n) {
    var r = 0;
    e = n ? iJ(e / 700) : e >> 1;
    e += iJ(e / t);
    while (e > 455) {
      e = iJ(e / 35);
      r += 36;
    }
    return iJ(r + e * 36 / (e + 38));
  }
  function vJ(e) {
    var t = [];
    e = function (e) {
      for (var t = [], n = 0, r = e.length; n < r;) {
        var a = sJ(e, n++);
        if (a >= 55296 && a <= 56319 && n < r) {
          var i = sJ(e, n++);
          if ((i & 64512) == 56320) {
            cJ(t, ((a & 1023) << 10) + (i & 1023) + 65536);
          } else {
            cJ(t, a);
            n--;
          }
        } else {
          cJ(t, a);
        }
      }
      return t;
    }(e);
    var n;
    var r;
    var a = e.length;
    var i = 128;
    var o = 0;
    var s = 72;
    for (n = 0; n < e.length; n++) {
      if ((r = e[n]) < 128) {
        cJ(t, oJ(r));
      }
    }
    var u = t.length;
    var c = u;
    for (u && cJ(t, "-"); c < a;) {
      var l = $Y;
      for (n = 0; n < e.length; n++) {
        if ((r = e[n]) >= i && r < l) {
          l = r;
        }
      }
      var h = c + 1;
      if (l - i > iJ(($Y - o) / h)) {
        throw rJ(nJ);
      }
      o += (l - i) * h;
      i = l;
      n = 0;
      for (; n < e.length; n++) {
        if ((r = e[n]) < i && ++o > $Y) {
          throw rJ(nJ);
        }
        if (r == i) {
          var p = o;
          var f = 36;
          while (true) {
            var d = f <= s ? 1 : f >= s + 26 ? 26 : f - s;
            if (p < d) {
              break;
            }
            var v = p - d;
            var m = 36 - d;
            cJ(t, oJ(fJ(d + v % m)));
            p = iJ(v / m);
            f += 36;
          }
          cJ(t, oJ(fJ(p)));
          s = dJ(o, h, c == u);
          o = 0;
          c++;
        }
      }
      o++;
      i++;
    }
    return uJ(t, "");
  }
  function mJ(e) {
    var t;
    var n;
    var r = [];
    var a = hJ(lJ(pJ(e), tJ, "."), ".");
    for (t = 0; t < a.length; t++) {
      n = a[t];
      cJ(r, aJ(eJ, n) ? "xn--" + vJ(n) : n);
    }
    return uJ(r, ".");
  }
  var gJ = La;
  var yJ = z;
  var bJ = j;
  var xJ = ee;
  var kJ = W;
  var wJ = ZY;
  var IJ = Or;
  var NJ = zi;
  var SJ = Dg;
  var TJ = eo;
  var EJ = dd;
  var CJ = cr;
  var AJ = zg;
  var RJ = xe;
  var _J = kt;
  var OJ = so;
  var FJ = qa;
  var DJ = dn;
  var MJ = Ie;
  var LJ = Ya;
  var zJ = yi;
  var PJ = Y;
  var BJ = eh;
  var WJ = Kl;
  var UJ = TC;
  var VJ = nm;
  var GJ = Mt("iterator");
  var jJ = "URLSearchParams";
  var HJ = "URLSearchParamsIterator";
  var qJ = CJ.set;
  var KJ = CJ.getterFor(jJ);
  var XJ = CJ.getterFor(HJ);
  var YJ = Object.getOwnPropertyDescriptor;
  function JJ(e) {
    if (!kJ) {
      return yJ[e];
    }
    var t = YJ(yJ, e);
    return t && t.value;
  }
  var ZJ = JJ("fetch");
  var QJ = JJ("Request");
  var $J = JJ("Headers");
  var eZ = QJ && QJ.prototype;
  var tZ = $J && $J.prototype;
  var nZ = yJ.RegExp;
  var rZ = yJ.TypeError;
  var aZ = yJ.decodeURIComponent;
  var iZ = yJ.encodeURIComponent;
  var oZ = xJ("".charAt);
  var sZ = xJ([].join);
  var uZ = xJ([].push);
  var cZ = xJ("".replace);
  var lZ = xJ([].shift);
  var hZ = xJ([].splice);
  var pZ = xJ("".split);
  var fZ = xJ("".slice);
  var dZ = /\+/g;
  var vZ = Array(4);
  function mZ(e) {
    return vZ[e - 1] ||= nZ("((?:%[\\da-f]{2}){" + e + "})", "gi");
  }
  function gZ(e) {
    try {
      return aZ(e);
    } catch (t) {
      return e;
    }
  }
  function yZ(e) {
    var t = cZ(e, dZ, " ");
    var n = 4;
    try {
      return aZ(t);
    } catch (e) {
      while (n) {
        t = cZ(t, mZ(n--), gZ);
      }
      return t;
    }
  }
  var bZ = /[!'()~]|%20/g;
  var xZ = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+"
  };
  function kZ(e) {
    return xZ[e];
  }
  function wZ(e) {
    return cZ(iZ(e), bZ, kZ);
  }
  var IZ = EJ(function (e, t) {
    qJ(this, {
      type: HJ,
      iterator: BJ(KJ(e).entries),
      kind: t
    });
  }, "Iterator", function () {
    var e = XJ(this);
    var t = e.kind;
    var n = e.iterator.next();
    var r = n.value;
    if (!n.done) {
      n.value = t === "keys" ? r.key : t === "values" ? r.value : [r.key, r.value];
    }
    return n;
  }, true);
  function NZ(e) {
    this.entries = [];
    this.url = null;
    if (e !== undefined) {
      if (MJ(e)) {
        this.parseObject(e);
      } else {
        this.parseQuery(typeof e == "string" ? oZ(e, 0) === "?" ? fZ(e, 1) : e : LJ(e));
      }
    }
  }
  NZ.prototype = {
    type: jJ,
    bindURL: function (e) {
      this.url = e;
      this.update();
    },
    parseObject: function (e) {
      var t;
      var n;
      var r;
      var a;
      var i;
      var o;
      var s;
      var u = WJ(e);
      if (u) {
        for (n = (t = BJ(e, u)).next; !(r = bJ(n, t)).done;) {
          i = (a = BJ(DJ(r.value))).next;
          if ((o = bJ(i, a)).done || (s = bJ(i, a)).done || !bJ(i, a).done) {
            throw rZ("Expected sequence with length 2");
          }
          uZ(this.entries, {
            key: LJ(o.value),
            value: LJ(s.value)
          });
        }
      } else {
        for (var c in e) {
          if (_J(e, c)) {
            uZ(this.entries, {
              key: c,
              value: LJ(e[c])
            });
          }
        }
      }
    },
    parseQuery: function (e) {
      if (e) {
        var t;
        for (var n, r = pZ(e, "&"), a = 0; a < r.length;) {
          if ((t = r[a++]).length) {
            n = pZ(t, "=");
            uZ(this.entries, {
              key: yZ(lZ(n)),
              value: yZ(sZ(n, "="))
            });
          }
        }
      }
    },
    serialize: function () {
      var e;
      for (var t = this.entries, n = [], r = 0; r < t.length;) {
        e = t[r++];
        uZ(n, wZ(e.key) + "=" + wZ(e.value));
      }
      return sZ(n, "&");
    },
    update: function () {
      this.entries.length = 0;
      this.parseQuery(this.url.query);
    },
    updateURL: function () {
      if (this.url) {
        this.url.update();
      }
    }
  };
  function SZ() {
    AJ(this, TZ);
    var e = arguments.length > 0 ? arguments[0] : undefined;
    var t = qJ(this, new NZ(e));
    if (!kJ) {
      this.length = t.entries.length;
    }
  }
  var TZ = SZ.prototype;
  SJ(TZ, {
    append: function (e, t) {
      UJ(arguments.length, 2);
      var n = KJ(this);
      uZ(n.entries, {
        key: LJ(e),
        value: LJ(t)
      });
      if (!kJ) {
        this.length++;
      }
      n.updateURL();
    },
    delete: function (e) {
      UJ(arguments.length, 1);
      var t = KJ(this);
      for (var n = t.entries, r = LJ(e), a = 0; a < n.length;) {
        if (n[a].key === r) {
          hZ(n, a, 1);
        } else {
          a++;
        }
      }
      if (!kJ) {
        this.length = n.length;
      }
      t.updateURL();
    },
    get: function (e) {
      UJ(arguments.length, 1);
      for (var t = KJ(this).entries, n = LJ(e), r = 0; r < t.length; r++) {
        if (t[r].key === n) {
          return t[r].value;
        }
      }
      return null;
    },
    getAll: function (e) {
      UJ(arguments.length, 1);
      for (var t = KJ(this).entries, n = LJ(e), r = [], a = 0; a < t.length; a++) {
        if (t[a].key === n) {
          uZ(r, t[a].value);
        }
      }
      return r;
    },
    has: function (e) {
      UJ(arguments.length, 1);
      for (var t = KJ(this).entries, n = LJ(e), r = 0; r < t.length;) {
        if (t[r++].key === n) {
          return true;
        }
      }
      return false;
    },
    set: function (e, t) {
      UJ(arguments.length, 1);
      var n;
      var r = KJ(this);
      for (var a = r.entries, i = false, o = LJ(e), s = LJ(t), u = 0; u < a.length; u++) {
        if ((n = a[u]).key === o) {
          if (i) {
            hZ(a, u--, 1);
          } else {
            i = true;
            n.value = s;
          }
        }
      }
      if (!i) {
        uZ(a, {
          key: o,
          value: s
        });
      }
      if (!kJ) {
        this.length = a.length;
      }
      r.updateURL();
    },
    sort: function () {
      var e = KJ(this);
      VJ(e.entries, function (e, t) {
        if (e.key > t.key) {
          return 1;
        } else {
          return -1;
        }
      });
      e.updateURL();
    },
    forEach: function (e) {
      var t;
      for (var n = KJ(this).entries, r = OJ(e, arguments.length > 1 ? arguments[1] : undefined), a = 0; a < n.length;) {
        r((t = n[a++]).value, t.key, this);
      }
    },
    keys: function () {
      return new IZ(this, "keys");
    },
    values: function () {
      return new IZ(this, "values");
    },
    entries: function () {
      return new IZ(this, "entries");
    }
  }, {
    enumerable: true
  });
  IJ(TZ, GJ, TZ.entries, {
    name: "entries"
  });
  IJ(TZ, "toString", function () {
    return KJ(this).serialize();
  }, {
    enumerable: true
  });
  if (kJ) {
    NJ(TZ, "size", {
      get: function () {
        return KJ(this).entries.length;
      },
      configurable: true,
      enumerable: true
    });
  }
  TJ(SZ, jJ);
  gJ({
    global: true,
    constructor: true,
    forced: !wJ
  }, {
    URLSearchParams: SZ
  });
  if (!wJ && RJ($J)) {
    var EZ = xJ(tZ.has);
    var CZ = xJ(tZ.set);
    function AZ(e) {
      if (MJ(e)) {
        var t;
        var n = e.body;
        if (FJ(n) === jJ) {
          t = e.headers ? new $J(e.headers) : new $J();
          if (!EZ(t, "content-type")) {
            CZ(t, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
          }
          return zJ(e, {
            body: PJ(0, LJ(n)),
            headers: PJ(0, t)
          });
        }
      }
      return e;
    }
    if (RJ(ZJ)) {
      gJ({
        global: true,
        enumerable: true,
        dontCallGetSet: true,
        forced: true
      }, {
        fetch: function (e) {
          return ZJ(e, arguments.length > 1 ? AZ(arguments[1]) : {});
        }
      });
    }
    if (RJ(QJ)) {
      function RZ(e) {
        AJ(this, eZ);
        return new QJ(e, arguments.length > 1 ? AZ(arguments[1]) : {});
      }
      eZ.constructor = RZ;
      RZ.prototype = eZ;
      gJ({
        global: true,
        constructor: true,
        dontCallGetSet: true,
        forced: true
      }, {
        Request: RZ
      });
    }
  }
  var _Z;
  var OZ = {
    URLSearchParams: SZ,
    getState: KJ
  };
  var FZ = La;
  var DZ = W;
  var MZ = ZY;
  var LZ = z;
  var zZ = so;
  var PZ = ee;
  var BZ = Or;
  var WZ = zi;
  var UZ = zg;
  var VZ = kt;
  var GZ = ST;
  var jZ = Lf;
  var HZ = Ai;
  var qZ = xM.codeAt;
  var KZ = mJ;
  var XZ = Ya;
  var YZ = eo;
  var JZ = TC;
  var ZZ = OZ;
  var QZ = cr;
  var $Z = QZ.set;
  var eQ = QZ.getterFor("URL");
  var tQ = ZZ.URLSearchParams;
  var nQ = ZZ.getState;
  var rQ = LZ.URL;
  var aQ = LZ.TypeError;
  var iQ = LZ.parseInt;
  var oQ = Math.floor;
  var sQ = Math.pow;
  var uQ = PZ("".charAt);
  var cQ = PZ(/./.exec);
  var lQ = PZ([].join);
  var hQ = PZ(1 .toString);
  var pQ = PZ([].pop);
  var fQ = PZ([].push);
  var dQ = PZ("".replace);
  var vQ = PZ([].shift);
  var mQ = PZ("".split);
  var gQ = PZ("".slice);
  var yQ = PZ("".toLowerCase);
  var bQ = PZ([].unshift);
  var xQ = "Invalid scheme";
  var kQ = "Invalid host";
  var wQ = "Invalid port";
  var IQ = /[a-z]/i;
  var NQ = /[\d+-.a-z]/i;
  var SQ = /\d/;
  var TQ = /^0x/i;
  var EQ = /^[0-7]+$/;
  var CQ = /^\d+$/;
  var AQ = /^[\da-f]+$/i;
  var RQ = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
  var _Q = /[\0\t\n\r #/:<>?@[\\\]^|]/;
  var OQ = /^[\u0000-\u0020]+/;
  var FQ = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
  var DQ = /[\t\n\r]/g;
  function MQ(e) {
    var t;
    var n;
    var r;
    var a;
    if (typeof e == "number") {
      t = [];
      n = 0;
      for (; n < 4; n++) {
        bQ(t, e % 256);
        e = oQ(e / 256);
      }
      return lQ(t, ".");
    }
    if (s(e) == "object") {
      t = "";
      r = function (e) {
        var t = null;
        var n = 1;
        var r = null;
        var a = 0;
        for (var i = 0; i < 8; i++) {
          if (e[i] !== 0) {
            if (a > n) {
              t = r;
              n = a;
            }
            r = null;
            a = 0;
          } else {
            if (r === null) {
              r = i;
            }
            ++a;
          }
        }
        if (a > n) {
          t = r;
          n = a;
        }
        return t;
      }(e);
      n = 0;
      for (; n < 8; n++) {
        if (!a || e[n] !== 0) {
          a &&= false;
          if (r === n) {
            t += n ? ":" : "::";
            a = true;
          } else {
            t += hQ(e[n], 16);
            if (n < 7) {
              t += ":";
            }
          }
        }
      }
      return "[" + t + "]";
    }
    return e;
  }
  var LQ = {};
  var zQ = GZ({}, LQ, {
    " ": 1,
    "\"": 1,
    "<": 1,
    ">": 1,
    "`": 1
  });
  var PQ = GZ({}, zQ, {
    "#": 1,
    "?": 1,
    "{": 1,
    "}": 1
  });
  var BQ = GZ({}, PQ, {
    "/": 1,
    ":": 1,
    ";": 1,
    "=": 1,
    "@": 1,
    "[": 1,
    "\\": 1,
    "]": 1,
    "^": 1,
    "|": 1
  });
  function WQ(e, t) {
    var n = qZ(e, 0);
    if (n > 32 && n < 127 && !VZ(t, e)) {
      return e;
    } else {
      return encodeURIComponent(e);
    }
  }
  var UQ = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  function VQ(e, t) {
    var n;
    return e.length == 2 && cQ(IQ, uQ(e, 0)) && ((n = uQ(e, 1)) == ":" || !t && n == "|");
  }
  function GQ(e) {
    var t;
    return e.length > 1 && VQ(gQ(e, 0, 2)) && (e.length == 2 || (t = uQ(e, 2)) === "/" || t === "\\" || t === "?" || t === "#");
  }
  function jQ(e) {
    return e === "." || yQ(e) === "%2e";
  }
  var HQ = {};
  var qQ = {};
  var KQ = {};
  var XQ = {};
  var YQ = {};
  var JQ = {};
  var ZQ = {};
  var QQ = {};
  var $Q = {};
  var e$ = {};
  var t$ = {};
  var n$ = {};
  var r$ = {};
  var a$ = {};
  var i$ = {};
  var o$ = {};
  var s$ = {};
  var u$ = {};
  var c$ = {};
  var l$ = {};
  var h$ = {};
  var p$ = function e(t, n, r) {
    var a;
    var i;
    var o;
    var s = XZ(t);
    if (n) {
      if (i = this.parse(s)) {
        throw aQ(i);
      }
      this.searchParams = null;
    } else {
      if (r !== undefined) {
        a = new e(r, true);
      }
      if (i = this.parse(s, null, a)) {
        throw aQ(i);
      }
      (o = nQ(new tQ())).bindURL(this);
      this.searchParams = o;
    }
  };
  p$.prototype = {
    type: "URL",
    parse: function (e, t, n) {
      var r;
      var a;
      var i;
      var o;
      var s;
      var u = this;
      var c = t || HQ;
      var l = 0;
      var h = "";
      var p = false;
      var f = false;
      var d = false;
      e = XZ(e);
      if (!t) {
        u.scheme = "";
        u.username = "";
        u.password = "";
        u.host = null;
        u.port = null;
        u.path = [];
        u.query = null;
        u.fragment = null;
        u.cannotBeABaseURL = false;
        e = dQ(e, OQ, "");
        e = dQ(e, FQ, "$1");
      }
      e = dQ(e, DQ, "");
      r = jZ(e);
      while (l <= r.length) {
        a = r[l];
        switch (c) {
          case HQ:
            if (!a || !cQ(IQ, a)) {
              if (t) {
                return xQ;
              }
              c = KQ;
              continue;
            }
            h += yQ(a);
            c = qQ;
            break;
          case qQ:
            if (a && (cQ(NQ, a) || a == "+" || a == "-" || a == ".")) {
              h += yQ(a);
            } else {
              if (a != ":") {
                if (t) {
                  return xQ;
                }
                h = "";
                c = KQ;
                l = 0;
                continue;
              }
              if (t && (u.isSpecial() != VZ(UQ, h) || h == "file" && (u.includesCredentials() || u.port !== null) || u.scheme == "file" && !u.host)) {
                return;
              }
              u.scheme = h;
              if (t) {
                if (u.isSpecial() && UQ[u.scheme] == u.port) {
                  u.port = null;
                }
                return;
              }
              h = "";
              if (u.scheme == "file") {
                c = a$;
              } else if (u.isSpecial() && n && n.scheme == u.scheme) {
                c = XQ;
              } else if (u.isSpecial()) {
                c = QQ;
              } else if (r[l + 1] == "/") {
                c = YQ;
                l++;
              } else {
                u.cannotBeABaseURL = true;
                fQ(u.path, "");
                c = c$;
              }
            }
            break;
          case KQ:
            if (!n || n.cannotBeABaseURL && a != "#") {
              return xQ;
            }
            if (n.cannotBeABaseURL && a == "#") {
              u.scheme = n.scheme;
              u.path = HZ(n.path);
              u.query = n.query;
              u.fragment = "";
              u.cannotBeABaseURL = true;
              c = h$;
              break;
            }
            c = n.scheme == "file" ? a$ : JQ;
            continue;
          case XQ:
            if (a != "/" || r[l + 1] != "/") {
              c = JQ;
              continue;
            }
            c = $Q;
            l++;
            break;
          case YQ:
            if (a == "/") {
              c = e$;
              break;
            }
            c = u$;
            continue;
          case JQ:
            u.scheme = n.scheme;
            if (a == _Z) {
              u.username = n.username;
              u.password = n.password;
              u.host = n.host;
              u.port = n.port;
              u.path = HZ(n.path);
              u.query = n.query;
            } else if (a == "/" || a == "\\" && u.isSpecial()) {
              c = ZQ;
            } else if (a == "?") {
              u.username = n.username;
              u.password = n.password;
              u.host = n.host;
              u.port = n.port;
              u.path = HZ(n.path);
              u.query = "";
              c = l$;
            } else {
              if (a != "#") {
                u.username = n.username;
                u.password = n.password;
                u.host = n.host;
                u.port = n.port;
                u.path = HZ(n.path);
                u.path.length--;
                c = u$;
                continue;
              }
              u.username = n.username;
              u.password = n.password;
              u.host = n.host;
              u.port = n.port;
              u.path = HZ(n.path);
              u.query = n.query;
              u.fragment = "";
              c = h$;
            }
            break;
          case ZQ:
            if (!u.isSpecial() || a != "/" && a != "\\") {
              if (a != "/") {
                u.username = n.username;
                u.password = n.password;
                u.host = n.host;
                u.port = n.port;
                c = u$;
                continue;
              }
              c = e$;
            } else {
              c = $Q;
            }
            break;
          case QQ:
            c = $Q;
            if (a != "/" || uQ(h, l + 1) != "/") {
              continue;
            }
            l++;
            break;
          case $Q:
            if (a != "/" && a != "\\") {
              c = e$;
              continue;
            }
            break;
          case e$:
            if (a == "@") {
              if (p) {
                h = "%40" + h;
              }
              p = true;
              i = jZ(h);
              for (var v = 0; v < i.length; v++) {
                var m = i[v];
                if (m != ":" || d) {
                  var g = WQ(m, BQ);
                  if (d) {
                    u.password += g;
                  } else {
                    u.username += g;
                  }
                } else {
                  d = true;
                }
              }
              h = "";
            } else if (a == _Z || a == "/" || a == "?" || a == "#" || a == "\\" && u.isSpecial()) {
              if (p && h == "") {
                return "Invalid authority";
              }
              l -= jZ(h).length + 1;
              h = "";
              c = t$;
            } else {
              h += a;
            }
            break;
          case t$:
          case n$:
            if (t && u.scheme == "file") {
              c = o$;
              continue;
            }
            if (a != ":" || f) {
              if (a == _Z || a == "/" || a == "?" || a == "#" || a == "\\" && u.isSpecial()) {
                if (u.isSpecial() && h == "") {
                  return kQ;
                }
                if (t && h == "" && (u.includesCredentials() || u.port !== null)) {
                  return;
                }
                if (o = u.parseHost(h)) {
                  return o;
                }
                h = "";
                c = s$;
                if (t) {
                  return;
                }
                continue;
              }
              if (a == "[") {
                f = true;
              } else if (a == "]") {
                f = false;
              }
              h += a;
            } else {
              if (h == "") {
                return kQ;
              }
              if (o = u.parseHost(h)) {
                return o;
              }
              h = "";
              c = r$;
              if (t == n$) {
                return;
              }
            }
            break;
          case r$:
            if (!cQ(SQ, a)) {
              if (a == _Z || a == "/" || a == "?" || a == "#" || a == "\\" && u.isSpecial() || t) {
                if (h != "") {
                  var y = iQ(h, 10);
                  if (y > 65535) {
                    return wQ;
                  }
                  u.port = u.isSpecial() && y === UQ[u.scheme] ? null : y;
                  h = "";
                }
                if (t) {
                  return;
                }
                c = s$;
                continue;
              }
              return wQ;
            }
            h += a;
            break;
          case a$:
            u.scheme = "file";
            if (a == "/" || a == "\\") {
              c = i$;
            } else {
              if (!n || n.scheme != "file") {
                c = u$;
                continue;
              }
              if (a == _Z) {
                u.host = n.host;
                u.path = HZ(n.path);
                u.query = n.query;
              } else if (a == "?") {
                u.host = n.host;
                u.path = HZ(n.path);
                u.query = "";
                c = l$;
              } else {
                if (a != "#") {
                  if (!GQ(lQ(HZ(r, l), ""))) {
                    u.host = n.host;
                    u.path = HZ(n.path);
                    u.shortenPath();
                  }
                  c = u$;
                  continue;
                }
                u.host = n.host;
                u.path = HZ(n.path);
                u.query = n.query;
                u.fragment = "";
                c = h$;
              }
            }
            break;
          case i$:
            if (a == "/" || a == "\\") {
              c = o$;
              break;
            }
            if (n && n.scheme == "file" && !GQ(lQ(HZ(r, l), ""))) {
              if (VQ(n.path[0], true)) {
                fQ(u.path, n.path[0]);
              } else {
                u.host = n.host;
              }
            }
            c = u$;
            continue;
          case o$:
            if (a == _Z || a == "/" || a == "\\" || a == "?" || a == "#") {
              if (!t && VQ(h)) {
                c = u$;
              } else if (h == "") {
                u.host = "";
                if (t) {
                  return;
                }
                c = s$;
              } else {
                if (o = u.parseHost(h)) {
                  return o;
                }
                if (u.host == "localhost") {
                  u.host = "";
                }
                if (t) {
                  return;
                }
                h = "";
                c = s$;
              }
              continue;
            }
            h += a;
            break;
          case s$:
            if (u.isSpecial()) {
              c = u$;
              if (a != "/" && a != "\\") {
                continue;
              }
            } else if (t || a != "?") {
              if (t || a != "#") {
                if (a != _Z && (c = u$, a != "/")) {
                  continue;
                }
              } else {
                u.fragment = "";
                c = h$;
              }
            } else {
              u.query = "";
              c = l$;
            }
            break;
          case u$:
            if (a == _Z || a == "/" || a == "\\" && u.isSpecial() || !t && (a == "?" || a == "#")) {
              if ((s = yQ(s = h)) === ".." || s === "%2e." || s === ".%2e" || s === "%2e%2e") {
                u.shortenPath();
                if (a != "/" && (a != "\\" || !u.isSpecial())) {
                  fQ(u.path, "");
                }
              } else if (jQ(h)) {
                if (a != "/" && (a != "\\" || !u.isSpecial())) {
                  fQ(u.path, "");
                }
              } else {
                if (u.scheme == "file" && !u.path.length && VQ(h)) {
                  u.host &&= "";
                  h = uQ(h, 0) + ":";
                }
                fQ(u.path, h);
              }
              h = "";
              if (u.scheme == "file" && (a == _Z || a == "?" || a == "#")) {
                while (u.path.length > 1 && u.path[0] === "") {
                  vQ(u.path);
                }
              }
              if (a == "?") {
                u.query = "";
                c = l$;
              } else if (a == "#") {
                u.fragment = "";
                c = h$;
              }
            } else {
              h += WQ(a, PQ);
            }
            break;
          case c$:
            if (a == "?") {
              u.query = "";
              c = l$;
            } else if (a == "#") {
              u.fragment = "";
              c = h$;
            } else if (a != _Z) {
              u.path[0] += WQ(a, LQ);
            }
            break;
          case l$:
            if (t || a != "#") {
              if (a != _Z) {
                if (a == "'" && u.isSpecial()) {
                  u.query += "%27";
                } else {
                  u.query += a == "#" ? "%23" : WQ(a, LQ);
                }
              }
            } else {
              u.fragment = "";
              c = h$;
            }
            break;
          case h$:
            if (a != _Z) {
              u.fragment += WQ(a, zQ);
            }
        }
        l++;
      }
    },
    parseHost: function (e) {
      var t;
      var n;
      var r;
      if (uQ(e, 0) == "[") {
        if (uQ(e, e.length - 1) != "]") {
          return kQ;
        }
        t = function (e) {
          var t;
          var n;
          var r;
          var a;
          var i;
          var o;
          var s;
          var u = [0, 0, 0, 0, 0, 0, 0, 0];
          var c = 0;
          var l = null;
          var h = 0;
          function p() {
            return uQ(e, h);
          }
          if (p() == ":") {
            if (uQ(e, 1) != ":") {
              return;
            }
            h += 2;
            l = ++c;
          }
          while (p()) {
            if (c == 8) {
              return;
            }
            if (p() != ":") {
              for (t = n = 0; n < 4 && cQ(AQ, p());) {
                t = t * 16 + iQ(p(), 16);
                h++;
                n++;
              }
              if (p() == ".") {
                if (n == 0) {
                  return;
                }
                h -= n;
                if (c > 6) {
                  return;
                }
                for (r = 0; p();) {
                  a = null;
                  if (r > 0) {
                    if (p() != "." || !(r < 4)) {
                      return;
                    }
                    h++;
                  }
                  if (!cQ(SQ, p())) {
                    return;
                  }
                  while (cQ(SQ, p())) {
                    i = iQ(p(), 10);
                    if (a === null) {
                      a = i;
                    } else {
                      if (a == 0) {
                        return;
                      }
                      a = a * 10 + i;
                    }
                    if (a > 255) {
                      return;
                    }
                    h++;
                  }
                  u[c] = u[c] * 256 + a;
                  if (++r == 2 || r == 4) {
                    c++;
                  }
                }
                if (r != 4) {
                  return;
                }
                break;
              }
              if (p() == ":") {
                h++;
                if (!p()) {
                  return;
                }
              } else if (p()) {
                return;
              }
              u[c++] = t;
            } else {
              if (l !== null) {
                return;
              }
              h++;
              l = ++c;
            }
          }
          if (l !== null) {
            o = c - l;
            c = 7;
            while (c != 0 && o > 0) {
              s = u[c];
              u[c--] = u[l + o - 1];
              u[l + --o] = s;
            }
          } else if (c != 8) {
            return;
          }
          return u;
        }(gQ(e, 1, -1));
        if (!t) {
          return kQ;
        }
        this.host = t;
      } else if (this.isSpecial()) {
        e = KZ(e);
        if (cQ(RQ, e)) {
          return kQ;
        }
        t = function (e) {
          var t;
          var n;
          var r;
          var a;
          var i;
          var o;
          var s;
          var u = mQ(e, ".");
          if (u.length && u[u.length - 1] == "") {
            u.length--;
          }
          if ((t = u.length) > 4) {
            return e;
          }
          n = [];
          r = 0;
          for (; r < t; r++) {
            if ((a = u[r]) == "") {
              return e;
            }
            i = 10;
            if (a.length > 1 && uQ(a, 0) == "0") {
              i = cQ(TQ, a) ? 16 : 8;
              a = gQ(a, i == 8 ? 1 : 2);
            }
            if (a === "") {
              o = 0;
            } else {
              if (!cQ(i == 10 ? CQ : i == 8 ? EQ : AQ, a)) {
                return e;
              }
              o = iQ(a, i);
            }
            fQ(n, o);
          }
          for (r = 0; r < t; r++) {
            o = n[r];
            if (r == t - 1) {
              if (o >= sQ(256, 5 - t)) {
                return null;
              }
            } else if (o > 255) {
              return null;
            }
          }
          s = pQ(n);
          r = 0;
          for (; r < n.length; r++) {
            s += n[r] * sQ(256, 3 - r);
          }
          return s;
        }(e);
        if (t === null) {
          return kQ;
        }
        this.host = t;
      } else {
        if (cQ(_Q, e)) {
          return kQ;
        }
        t = "";
        n = jZ(e);
        r = 0;
        for (; r < n.length; r++) {
          t += WQ(n[r], LQ);
        }
        this.host = t;
      }
    },
    cannotHaveUsernamePasswordPort: function () {
      return !this.host || this.cannotBeABaseURL || this.scheme == "file";
    },
    includesCredentials: function () {
      return this.username != "" || this.password != "";
    },
    isSpecial: function () {
      return VZ(UQ, this.scheme);
    },
    shortenPath: function () {
      var e = this.path;
      var t = e.length;
      if (!!t && (this.scheme != "file" || t != 1 || !VQ(e[0], true))) {
        e.length--;
      }
    },
    serialize: function () {
      var e = this;
      var t = e.scheme;
      var n = e.username;
      var r = e.password;
      var a = e.host;
      var i = e.port;
      var o = e.path;
      var s = e.query;
      var u = e.fragment;
      var c = t + ":";
      if (a !== null) {
        c += "//";
        if (e.includesCredentials()) {
          c += n + (r ? ":" + r : "") + "@";
        }
        c += MQ(a);
        if (i !== null) {
          c += ":" + i;
        }
      } else if (t == "file") {
        c += "//";
      }
      c += e.cannotBeABaseURL ? o[0] : o.length ? "/" + lQ(o, "/") : "";
      if (s !== null) {
        c += "?" + s;
      }
      if (u !== null) {
        c += "#" + u;
      }
      return c;
    },
    setHref: function (e) {
      var t = this.parse(e);
      if (t) {
        throw aQ(t);
      }
      this.searchParams.update();
    },
    getOrigin: function () {
      var e = this.scheme;
      var t = this.port;
      if (e == "blob") {
        try {
          return new f$(e.path[0]).origin;
        } catch (e) {
          return "null";
        }
      }
      if (e != "file" && this.isSpecial()) {
        return e + "://" + MQ(this.host) + (t !== null ? ":" + t : "");
      } else {
        return "null";
      }
    },
    getProtocol: function () {
      return this.scheme + ":";
    },
    setProtocol: function (e) {
      this.parse(XZ(e) + ":", HQ);
    },
    getUsername: function () {
      return this.username;
    },
    setUsername: function (e) {
      var t = jZ(XZ(e));
      if (!this.cannotHaveUsernamePasswordPort()) {
        this.username = "";
        for (var n = 0; n < t.length; n++) {
          this.username += WQ(t[n], BQ);
        }
      }
    },
    getPassword: function () {
      return this.password;
    },
    setPassword: function (e) {
      var t = jZ(XZ(e));
      if (!this.cannotHaveUsernamePasswordPort()) {
        this.password = "";
        for (var n = 0; n < t.length; n++) {
          this.password += WQ(t[n], BQ);
        }
      }
    },
    getHost: function () {
      var e = this.host;
      var t = this.port;
      if (e === null) {
        return "";
      } else if (t === null) {
        return MQ(e);
      } else {
        return MQ(e) + ":" + t;
      }
    },
    setHost: function (e) {
      if (!this.cannotBeABaseURL) {
        this.parse(e, t$);
      }
    },
    getHostname: function () {
      var e = this.host;
      if (e === null) {
        return "";
      } else {
        return MQ(e);
      }
    },
    setHostname: function (e) {
      if (!this.cannotBeABaseURL) {
        this.parse(e, n$);
      }
    },
    getPort: function () {
      var e = this.port;
      if (e === null) {
        return "";
      } else {
        return XZ(e);
      }
    },
    setPort: function (e) {
      if (!this.cannotHaveUsernamePasswordPort()) {
        if ((e = XZ(e)) == "") {
          this.port = null;
        } else {
          this.parse(e, r$);
        }
      }
    },
    getPathname: function () {
      var e = this.path;
      if (this.cannotBeABaseURL) {
        return e[0];
      } else if (e.length) {
        return "/" + lQ(e, "/");
      } else {
        return "";
      }
    },
    setPathname: function (e) {
      if (!this.cannotBeABaseURL) {
        this.path = [];
        this.parse(e, s$);
      }
    },
    getSearch: function () {
      var e = this.query;
      if (e) {
        return "?" + e;
      } else {
        return "";
      }
    },
    setSearch: function (e) {
      if ((e = XZ(e)) == "") {
        this.query = null;
      } else {
        if (uQ(e, 0) == "?") {
          e = gQ(e, 1);
        }
        this.query = "";
        this.parse(e, l$);
      }
      this.searchParams.update();
    },
    getSearchParams: function () {
      return this.searchParams.facade;
    },
    getHash: function () {
      var e = this.fragment;
      if (e) {
        return "#" + e;
      } else {
        return "";
      }
    },
    setHash: function (e) {
      if ((e = XZ(e)) != "") {
        if (uQ(e, 0) == "#") {
          e = gQ(e, 1);
        }
        this.fragment = "";
        this.parse(e, h$);
      } else {
        this.fragment = null;
      }
    },
    update: function () {
      this.query = this.searchParams.serialize() || null;
    }
  };
  function f$(e) {
    var t = UZ(this, d$);
    var n = JZ(arguments.length, 1) > 1 ? arguments[1] : undefined;
    var r = $Z(t, new p$(e, false, n));
    if (!DZ) {
      t.href = r.serialize();
      t.origin = r.getOrigin();
      t.protocol = r.getProtocol();
      t.username = r.getUsername();
      t.password = r.getPassword();
      t.host = r.getHost();
      t.hostname = r.getHostname();
      t.port = r.getPort();
      t.pathname = r.getPathname();
      t.search = r.getSearch();
      t.searchParams = r.getSearchParams();
      t.hash = r.getHash();
    }
  }
  var d$ = f$.prototype;
  function v$(e, t) {
    return {
      get: function () {
        return eQ(this)[e]();
      },
      set: t && function (e) {
        return eQ(this)[t](e);
      },
      configurable: true,
      enumerable: true
    };
  }
  if (DZ) {
    WZ(d$, "href", v$("serialize", "setHref"));
    WZ(d$, "origin", v$("getOrigin"));
    WZ(d$, "protocol", v$("getProtocol", "setProtocol"));
    WZ(d$, "username", v$("getUsername", "setUsername"));
    WZ(d$, "password", v$("getPassword", "setPassword"));
    WZ(d$, "host", v$("getHost", "setHost"));
    WZ(d$, "hostname", v$("getHostname", "setHostname"));
    WZ(d$, "port", v$("getPort", "setPort"));
    WZ(d$, "pathname", v$("getPathname", "setPathname"));
    WZ(d$, "search", v$("getSearch", "setSearch"));
    WZ(d$, "searchParams", v$("getSearchParams"));
    WZ(d$, "hash", v$("getHash", "setHash"));
  }
  BZ(d$, "toJSON", function () {
    return eQ(this).serialize();
  }, {
    enumerable: true
  });
  BZ(d$, "toString", function () {
    return eQ(this).serialize();
  }, {
    enumerable: true
  });
  if (rQ) {
    var m$ = rQ.createObjectURL;
    var g$ = rQ.revokeObjectURL;
    if (m$) {
      BZ(f$, "createObjectURL", zZ(m$, rQ));
    }
    if (g$) {
      BZ(f$, "revokeObjectURL", zZ(g$, rQ));
    }
  }
  YZ(f$, "URL");
  FZ({
    global: true,
    constructor: true,
    forced: !MZ,
    sham: !DZ
  }, {
    URL: f$
  });
  var y$ = j;
  La({
    target: "URL",
    proto: true,
    enumerable: true
  }, {
    toJSON: function () {
      return y$(URL.prototype.toString, this);
    }
  });
  var b$ = W;
  var x$ = ee;
  var k$ = zi;
  var w$ = URLSearchParams.prototype;
  var I$ = x$(w$.forEach);
  if (b$ && !("size" in w$)) {
    k$(w$, "size", {
      get: function () {
        var e = 0;
        I$(this, function () {
          e++;
        });
        return e;
      },
      configurable: true,
      enumerable: true
    });
  }
  var N$ = {
    exports: {}
  };
  (function (e) {
    var t = function (e) {
      var t;
      var n = Object.prototype;
      var r = n.hasOwnProperty;
      var a = typeof Symbol == "function" ? Symbol : {};
      var i = a.iterator || "@@iterator";
      var o = a.asyncIterator || "@@asyncIterator";
      var u = a.toStringTag || "@@toStringTag";
      function c(e, t, n) {
        Object.defineProperty(e, t, {
          value: n,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return e[t];
      }
      try {
        c({}, "");
      } catch (e) {
        c = function (e, t, n) {
          return e[t] = n;
        };
      }
      function l(e, t, n, r) {
        var a = t && t.prototype instanceof g ? t : g;
        var i = Object.create(a.prototype);
        var o = new A(r || []);
        i._invoke = function (e, t, n) {
          var r = p;
          return function (a, i) {
            if (r === d) {
              throw new Error("Generator is already running");
            }
            if (r === v) {
              if (a === "throw") {
                throw i;
              }
              return _();
            }
            n.method = a;
            n.arg = i;
            while (true) {
              var o = n.delegate;
              if (o) {
                var s = T(o, n);
                if (s) {
                  if (s === m) {
                    continue;
                  }
                  return s;
                }
              }
              if (n.method === "next") {
                n.sent = n._sent = n.arg;
              } else if (n.method === "throw") {
                if (r === p) {
                  r = v;
                  throw n.arg;
                }
                n.dispatchException(n.arg);
              } else if (n.method === "return") {
                n.abrupt("return", n.arg);
              }
              r = d;
              var u = h(e, t, n);
              if (u.type === "normal") {
                r = n.done ? v : f;
                if (u.arg === m) {
                  continue;
                }
                return {
                  value: u.arg,
                  done: n.done
                };
              }
              if (u.type === "throw") {
                r = v;
                n.method = "throw";
                n.arg = u.arg;
              }
            }
          };
        }(e, n, o);
        return i;
      }
      function h(e, t, n) {
        try {
          return {
            type: "normal",
            arg: e.call(t, n)
          };
        } catch (e) {
          return {
            type: "throw",
            arg: e
          };
        }
      }
      e.wrap = l;
      var p = "suspendedStart";
      var f = "suspendedYield";
      var d = "executing";
      var v = "completed";
      var m = {};
      function g() {}
      function y() {}
      function b() {}
      var x = {
        [i]: function () {
          return this;
        }
      };
      var k = Object.getPrototypeOf;
      var w = k && k(k(R([])));
      if (w && w !== n && r.call(w, i)) {
        x = w;
      }
      var I = b.prototype = g.prototype = Object.create(x);
      function N(e) {
        ["next", "throw", "return"].forEach(function (t) {
          c(e, t, function (e) {
            return this._invoke(t, e);
          });
        });
      }
      function S(e, t) {
        function n(a, i, o, u) {
          var c = h(e[a], e, i);
          if (c.type !== "throw") {
            var l = c.arg;
            var p = l.value;
            if (p && s(p) === "object" && r.call(p, "__await")) {
              return t.resolve(p.__await).then(function (e) {
                n("next", e, o, u);
              }, function (e) {
                n("throw", e, o, u);
              });
            } else {
              return t.resolve(p).then(function (e) {
                l.value = e;
                o(l);
              }, function (e) {
                return n("throw", e, o, u);
              });
            }
          }
          u(c.arg);
        }
        var a;
        this._invoke = function (e, r) {
          function i() {
            return new t(function (t, a) {
              n(e, r, t, a);
            });
          }
          return a = a ? a.then(i, i) : i();
        };
      }
      function T(e, n) {
        var r = e.iterator[n.method];
        if (r === t) {
          n.delegate = null;
          if (n.method === "throw") {
            if (e.iterator.return && (n.method = "return", n.arg = t, T(e, n), n.method === "throw")) {
              return m;
            }
            n.method = "throw";
            n.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return m;
        }
        var a = h(r, e.iterator, n.arg);
        if (a.type === "throw") {
          n.method = "throw";
          n.arg = a.arg;
          n.delegate = null;
          return m;
        }
        var i = a.arg;
        if (i) {
          if (i.done) {
            n[e.resultName] = i.value;
            n.next = e.nextLoc;
            if (n.method !== "return") {
              n.method = "next";
              n.arg = t;
            }
            n.delegate = null;
            return m;
          } else {
            return i;
          }
        } else {
          n.method = "throw";
          n.arg = new TypeError("iterator result is not an object");
          n.delegate = null;
          return m;
        }
      }
      function E(e) {
        var t = {
          tryLoc: e[0]
        };
        if (1 in e) {
          t.catchLoc = e[1];
        }
        if (2 in e) {
          t.finallyLoc = e[2];
          t.afterLoc = e[3];
        }
        this.tryEntries.push(t);
      }
      function C(e) {
        var t = e.completion || {};
        t.type = "normal";
        delete t.arg;
        e.completion = t;
      }
      function A(e) {
        this.tryEntries = [{
          tryLoc: "root"
        }];
        e.forEach(E, this);
        this.reset(true);
      }
      function R(e) {
        if (e) {
          var n = e[i];
          if (n) {
            return n.call(e);
          }
          if (typeof e.next == "function") {
            return e;
          }
          if (!isNaN(e.length)) {
            var a = -1;
            var o = function n() {
              while (++a < e.length) {
                if (r.call(e, a)) {
                  n.value = e[a];
                  n.done = false;
                  return n;
                }
              }
              n.value = t;
              n.done = true;
              return n;
            };
            return o.next = o;
          }
        }
        return {
          next: _
        };
      }
      function _() {
        return {
          value: t,
          done: true
        };
      }
      y.prototype = I.constructor = b;
      b.constructor = y;
      y.displayName = c(b, u, "GeneratorFunction");
      e.isGeneratorFunction = function (e) {
        var t = typeof e == "function" && e.constructor;
        return !!t && (t === y || (t.displayName || t.name) === "GeneratorFunction");
      };
      e.mark = function (e) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(e, b);
        } else {
          e.__proto__ = b;
          c(e, u, "GeneratorFunction");
        }
        e.prototype = Object.create(I);
        return e;
      };
      e.awrap = function (e) {
        return {
          __await: e
        };
      };
      N(S.prototype);
      S.prototype[o] = function () {
        return this;
      };
      e.AsyncIterator = S;
      e.async = function (t, n, r, a, i = Promise) {
        var o = new S(l(t, n, r, a), i);
        if (e.isGeneratorFunction(n)) {
          return o;
        } else {
          return o.next().then(function (e) {
            if (e.done) {
              return e.value;
            } else {
              return o.next();
            }
          });
        }
      };
      N(I);
      c(I, u, "Generator");
      I[i] = function () {
        return this;
      };
      I.toString = function () {
        return "[object Generator]";
      };
      e.keys = function (e) {
        var t = [];
        for (var n in e) {
          t.push(n);
        }
        t.reverse();
        return function n() {
          while (t.length) {
            var r = t.pop();
            if (r in e) {
              n.value = r;
              n.done = false;
              return n;
            }
          }
          n.done = true;
          return n;
        };
      };
      e.values = R;
      A.prototype = {
        constructor: A,
        reset: function (e) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = t;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = t;
          this.tryEntries.forEach(C);
          if (!e) {
            for (var n in this) {
              if (n.charAt(0) === "t" && r.call(this, n) && !isNaN(+n.slice(1))) {
                this[n] = t;
              }
            }
          }
        },
        stop: function () {
          this.done = true;
          var e = this.tryEntries[0].completion;
          if (e.type === "throw") {
            throw e.arg;
          }
          return this.rval;
        },
        dispatchException: function (e) {
          if (this.done) {
            throw e;
          }
          var n = this;
          function a(r, a) {
            s.type = "throw";
            s.arg = e;
            n.next = r;
            if (a) {
              n.method = "next";
              n.arg = t;
            }
            return !!a;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var o = this.tryEntries[i];
            var s = o.completion;
            if (o.tryLoc === "root") {
              return a("end");
            }
            if (o.tryLoc <= this.prev) {
              var u = r.call(o, "catchLoc");
              var c = r.call(o, "finallyLoc");
              if (u && c) {
                if (this.prev < o.catchLoc) {
                  return a(o.catchLoc, true);
                }
                if (this.prev < o.finallyLoc) {
                  return a(o.finallyLoc);
                }
              } else if (u) {
                if (this.prev < o.catchLoc) {
                  return a(o.catchLoc, true);
                }
              } else {
                if (!c) {
                  throw new Error("try statement without catch or finally");
                }
                if (this.prev < o.finallyLoc) {
                  return a(o.finallyLoc);
                }
              }
            }
          }
        },
        abrupt: function (e, t) {
          for (var n = this.tryEntries.length - 1; n >= 0; --n) {
            var a = this.tryEntries[n];
            if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
              var i = a;
              break;
            }
          }
          if (i && (e === "break" || e === "continue") && i.tryLoc <= t && t <= i.finallyLoc) {
            i = null;
          }
          var o = i ? i.completion : {};
          o.type = e;
          o.arg = t;
          if (i) {
            this.method = "next";
            this.next = i.finallyLoc;
            return m;
          } else {
            return this.complete(o);
          }
        },
        complete: function (e, t) {
          if (e.type === "throw") {
            throw e.arg;
          }
          if (e.type === "break" || e.type === "continue") {
            this.next = e.arg;
          } else if (e.type === "return") {
            this.rval = this.arg = e.arg;
            this.method = "return";
            this.next = "end";
          } else if (e.type === "normal" && t) {
            this.next = t;
          }
          return m;
        },
        finish: function (e) {
          for (var t = this.tryEntries.length - 1; t >= 0; --t) {
            var n = this.tryEntries[t];
            if (n.finallyLoc === e) {
              this.complete(n.completion, n.afterLoc);
              C(n);
              return m;
            }
          }
        },
        catch: function (e) {
          for (var t = this.tryEntries.length - 1; t >= 0; --t) {
            var n = this.tryEntries[t];
            if (n.tryLoc === e) {
              var r = n.completion;
              if (r.type === "throw") {
                var a = r.arg;
                C(n);
              }
              return a;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function (e, n, r) {
          this.delegate = {
            iterator: R(e),
            resultName: n,
            nextLoc: r
          };
          if (this.method === "next") {
            this.arg = t;
          }
          return m;
        }
      };
      return e;
    }(e.exports);
    try {
      regeneratorRuntime = t;
    } catch (e) {
      Function("r", "regeneratorRuntime = r")(t);
    }
  })(N$);
  var S$ = function () {
    function e(t, n) {
      l(this, e);
      this.backend = t;
      this.dataMover = n;
      this.data = new WeakMap();
      this.dataIdsCount = 0;
    }
    p(e, [{
      key: "get",
      value: function (e) {
        if (!this.data.has(e)) {
          this.dataMover.moveData(this.backend, e);
        }
        return this.data.get(e);
      }
    }, {
      key: "set",
      value: function (e, t) {
        this.dataIdsCount++;
        this.data.set(e, t);
      }
    }, {
      key: "has",
      value: function (e) {
        return this.data.has(e);
      }
    }, {
      key: "delete",
      value: function (e) {
        this.dataIdsCount--;
        return this.data.delete(e);
      }
    }, {
      key: "numDataIds",
      value: function () {
        return this.dataIdsCount;
      }
    }]);
    return e;
  }();
  var T$ = function () {
    function e() {
      l(this, e);
    }
    p(e, [{
      key: "refCount",
      value: function (e) {
        return E$("refCount");
      }
    }, {
      key: "incRef",
      value: function (e) {
        return E$("incRef");
      }
    }, {
      key: "timerAvailable",
      value: function () {
        return true;
      }
    }, {
      key: "time",
      value: function (e) {
        return E$("time");
      }
    }, {
      key: "read",
      value: function (e) {
        return E$("read");
      }
    }, {
      key: "readSync",
      value: function (e) {
        return E$("readSync");
      }
    }, {
      key: "readToGPU",
      value: function (e, t) {
        return E$("readToGPU");
      }
    }, {
      key: "numDataIds",
      value: function () {
        return E$("numDataIds");
      }
    }, {
      key: "disposeData",
      value: function (e, t) {
        return E$("disposeData");
      }
    }, {
      key: "write",
      value: function (e, t, n) {
        return E$("write");
      }
    }, {
      key: "move",
      value: function (e, t, n, r, a) {
        return E$("move");
      }
    }, {
      key: "createTensorFromGPUData",
      value: function (e, t, n) {
        return E$("createTensorFromGPUData");
      }
    }, {
      key: "memory",
      value: function () {
        return E$("memory");
      }
    }, {
      key: "floatPrecision",
      value: function () {
        return E$("floatPrecision");
      }
    }, {
      key: "epsilon",
      value: function () {
        if (this.floatPrecision() === 32) {
          return 1e-7;
        } else {
          return 0.0001;
        }
      }
    }, {
      key: "dispose",
      value: function () {
        return E$("dispose");
      }
    }]);
    return e;
  }();
  function E$(e) {
    throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }
  function C$(e) {
    for (var t = e.length, n = 0; t > 0;) {
      n = Math.random() * t | 0;
      _$(e, --t, n);
    }
  }
  function A$(e, t, n) {
    return Math.max(e, Math.min(t, n));
  }
  function R$(e) {
    if (e % 2 == 0) {
      return e;
    } else {
      return e + 1;
    }
  }
  function _$(e, t, n) {
    var r = e[t];
    e[t] = e[n];
    e[n] = r;
  }
  function O$(e) {
    var t = 0;
    for (var n = 0; n < e.length; n++) {
      t += e[n];
    }
    return t;
  }
  function F$(e, t) {
    if (!e) {
      throw new Error(typeof t == "string" ? t : t());
    }
  }
  function D$(e, t, n = "") {
    F$(P$(e, t), function () {
      return `${n} Shapes ${e} and ${t} must match`;
    });
  }
  function M$(e) {
    F$(e != null, function () {
      return "The input to the tensor constructor must be a non-null value.";
    });
  }
  function L$(e) {
    if (e.length === 0) {
      return 1;
    }
    var t = e[0];
    for (var n = 1; n < e.length; n++) {
      t *= e[n];
    }
    return t;
  }
  function z$(e, t) {
    if (e === t) {
      return true;
    }
    if (e == null || t == null) {
      return false;
    }
    if (e.length !== t.length) {
      return false;
    }
    for (var n = 0; n < e.length; n++) {
      if (e[n] !== null && t[n] !== null && e[n] !== t[n]) {
        return false;
      }
    }
    return true;
  }
  function P$(e, t) {
    if (e === t) {
      return true;
    }
    if (e == null || t == null) {
      return false;
    }
    if (e.length !== t.length) {
      return false;
    }
    for (var n = 0; n < e.length; n++) {
      if (e[n] !== t[n]) {
        return false;
      }
    }
    return true;
  }
  function B$(e) {
    return e % 1 == 0;
  }
  function W$(e) {
    var t = Math.ceil(Math.sqrt(e));
    return [t, Math.ceil(e / t)];
  }
  function U$(e, t) {
    if (t <= e.length) {
      return e;
    } else {
      return e + " ".repeat(t - e.length);
    }
  }
  function V$(e, t = function (e) {
    return 0;
  }, n, r) {
    return new Promise(function (a, i) {
      var o = 0;
      (function s() {
        if (e()) {
          a();
        } else {
          o++;
          var u = t(o);
          if (n != null && o >= n) {
            i();
          } else if (r != null) {
            r(s, u);
          } else {
            setTimeout(s, u);
          }
        }
      })();
    });
  }
  function G$(e, t) {
    var n = 1;
    var r = -1;
    for (var a = 0; a < e.length; ++a) {
      if (e[a] >= 0) {
        n *= e[a];
      } else if (e[a] === -1) {
        if (r !== -1) {
          throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);
        }
        r = a;
      } else if (e[a] < 0) {
        throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);
      }
    }
    if (r === -1) {
      if (t > 0 && t !== n) {
        throw Error(`Size(${t}) must match the product of shape ${e}`);
      }
      return e;
    }
    if (n === 0) {
      throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);
    }
    if (t % n != 0) {
      throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);
    }
    var i = e.slice();
    i[r] = t / n;
    return i;
  }
  function j$(e, t) {
    var n = t.length;
    F$((e = e == null ? t.map(function (e, t) {
      return t;
    }) : [].concat(e)).every(function (e) {
      return e >= -n && e < n;
    }), function () {
      return `All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`;
    });
    F$(e.every(function (e) {
      return B$(e);
    }), function () {
      return `All values in axis param must be integers but got axis ${e}`;
    });
    return e.map(function (e) {
      if (e < 0) {
        return n + e;
      } else {
        return e;
      }
    });
  }
  function H$(e, t) {
    var n = [];
    var r = [];
    var a = t != null && Array.isArray(t) && t.length === 0;
    var i = t == null || a ? null : j$(t, e).sort();
    var o = 0;
    for (var s = 0; s < e.length; ++s) {
      if (i != null) {
        if (i[o] === s && e[s] !== 1) {
          throw new Error(`Can't squeeze axis ${s} since its dim '${e[s]}' is not 1`);
        }
        if ((i[o] == null || i[o] > s) && e[s] === 1) {
          n.push(e[s]);
          r.push(s);
        }
        if (i[o] <= s) {
          o++;
        }
      }
      if (e[s] !== 1) {
        n.push(e[s]);
        r.push(s);
      }
    }
    return {
      newShape: n,
      keptDims: r
    };
  }
  function q$(e, t) {
    return K$(e, t);
  }
  function K$(e, t) {
    var n = null;
    if (e == null || e === "float32") {
      n = new Float32Array(t);
    } else if (e === "int32") {
      n = new Int32Array(t);
    } else if (e === "bool") {
      n = new Uint8Array(t);
    } else {
      if (e !== "string") {
        throw new Error(`Unknown data type ${e}`);
      }
      n = new Array(t);
    }
    return n;
  }
  function X$(e, t) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      if (isNaN(r) || !isFinite(r)) {
        throw Error(`A tensor of type ${t} being uploaded contains ${r}.`);
      }
    }
  }
  function Y$(e) {
    return e === "bool" || e === "complex64" || e === "float32" || e === "int32" || e === "string";
  }
  function J$(e, t) {
    return t !== "complex64" && (t !== "float32" || e === "complex64") && (t !== "int32" || e === "float32" || e === "complex64") && (t !== "bool" || e !== "bool");
  }
  function Z$(e) {
    if (e === "float32" || e === "int32") {
      return 4;
    }
    if (e === "complex64") {
      return 8;
    }
    if (e === "bool") {
      return 1;
    }
    throw new Error(`Unknown dtype ${e}`);
  }
  function Q$(e) {
    if (e == null) {
      return 0;
    }
    var t = 0;
    e.forEach(function (e) {
      return t += e.length;
    });
    return t;
  }
  function $$(e) {
    return typeof e == "string" || e instanceof String;
  }
  function e0(e) {
    return typeof e == "boolean";
  }
  function t0(e) {
    return typeof e == "number";
  }
  function n0(e) {
    if (Array.isArray(e)) {
      return n0(e[0]);
    } else if (e instanceof Float32Array) {
      return "float32";
    } else if (e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray) {
      return "int32";
    } else if (t0(e)) {
      return "float32";
    } else if ($$(e)) {
      return "string";
    } else if (e0(e)) {
      return "bool";
    } else {
      return "float32";
    }
  }
  function r0(e) {
    return !!e && !!e.constructor && !!e.call && !!e.apply;
  }
  function a0(e, t) {
    for (var n = t; n < e; ++n) {
      if (e % n == 0) {
        return n;
      }
    }
    return e;
  }
  function i0(e) {
    var t = e.length;
    if (t < 2) {
      return [];
    }
    var n = new Array(t - 1);
    n[t - 2] = e[t - 1];
    for (var r = t - 3; r >= 0; --r) {
      n[r] = n[r + 1] * e[r + 1];
    }
    return n;
  }
  function o0(e, t, n, r = false) {
    var a = new Array();
    if (t.length === 1) {
      for (var i = t[0] * (r ? 2 : 1), o = 0; o < i; o++) {
        a[o] = n[e + o];
      }
    } else {
      for (var s = t[0], u = t.slice(1), c = u.reduce(function (e, t) {
          return e * t;
        }) * (r ? 2 : 1), l = 0; l < s; l++) {
        a[l] = o0(e + l * c, u, n, r);
      }
    }
    return a;
  }
  function s0(e, t, n = false) {
    if (e.length === 0) {
      return t[0];
    }
    var r = e.reduce(function (e, t) {
      return e * t;
    }) * (n ? 2 : 1);
    if (r === 0) {
      return [];
    }
    if (r !== t.length) {
      throw new Error(`[${e}] does not match the input size ${t.length}${n ? " for a complex tensor" : ""}.`);
    }
    return o0(0, e, t, n);
  }
  function u0(e, t) {
    if (Array.isArray(e)) {
      return e;
    }
    if (t === "float32") {
      if (e instanceof Float32Array) {
        return e;
      } else {
        return new Float32Array(e);
      }
    }
    if (t === "int32") {
      if (e instanceof Int32Array) {
        return e;
      } else {
        return new Int32Array(e);
      }
    }
    if (t === "bool" || t === "string") {
      return Uint8Array.from(new Int32Array(e));
    }
    throw new Error(`Unknown dtype ${t}`);
  }
  function c0(e, t) {
    for (var n = l0(e, t), r = 0; r < n.length; r++) {
      n[r] = 1;
    }
    return n;
  }
  function l0(e, t) {
    if (t == null || t === "float32" || t === "complex64") {
      return new Float32Array(e);
    }
    if (t === "int32") {
      return new Int32Array(e);
    }
    if (t === "bool") {
      return new Uint8Array(e);
    }
    throw new Error(`Unknown data type ${t}`);
  }
  function h0(e, t) {
    var n = e.reduce(function (e, t) {
      return e * t;
    }, 1);
    if (t == null || t === "float32") {
      return s0(e, new Float32Array(n));
    }
    if (t === "int32") {
      return s0(e, new Int32Array(n));
    }
    if (t === "bool") {
      return s0(e, new Uint8Array(n));
    }
    throw new Error(`Unknown data type ${t}`);
  }
  function p0(e) {
    e.forEach(function (t) {
      F$(Number.isInteger(t) && t >= 0, function () {
        return `Tensor must have a shape comprised of positive integers but got shape [${e}].`;
      });
    });
  }
  function f0(e, t, n) {
    if (t === 0) {
      return 0;
    }
    if (t === 1) {
      return e[0];
    }
    var r = e[e.length - 1];
    for (var a = 0; a < e.length - 1; ++a) {
      r += n[a] * e[a];
    }
    return r;
  }
  function d0(e, t, n) {
    if (t === 0) {
      return [];
    }
    if (t === 1) {
      return [e];
    }
    for (var r = new Array(t), a = 0; a < r.length - 1; ++a) {
      r[a] = Math.floor(e / n[a]);
      e -= r[a] * n[a];
    }
    r[r.length - 1] = e;
    return r;
  }
  function v0(e) {
    return e && e.then && typeof e.then == "function";
  }
  var m0;
  var g0 = "tfjsflags";
  var y0 = function () {
    function e(t) {
      l(this, e);
      this.global = t;
      this.flags = {};
      this.flagRegistry = {};
      this.urlFlags = {};
      this.getQueryParams = b0;
      this.populateURLFlags();
    }
    var t;
    p(e, [{
      key: "setPlatform",
      value: function (e, t) {
        if (this.platform != null) {
          if (!k0().getBool("IS_TEST") && !k0().getBool("PROD")) {
            console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`);
          }
        }
        this.platformName = e;
        this.platform = t;
      }
    }, {
      key: "registerFlag",
      value: function (e, t, n) {
        this.flagRegistry[e] = {
          evaluationFn: t,
          setHook: n
        };
        if (this.urlFlags[e] != null) {
          var r = this.urlFlags[e];
          if (!k0().getBool("IS_TEST") && !k0().getBool("PROD")) {
            console.warn(`Setting feature override from URL ${e}: ${r}.`);
          }
          this.set(e, r);
        }
      }
    }, {
      key: "getAsync",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(t in this.flags)) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", this.flags[t]);
              case 2:
                e.next = 4;
                return this.evaluateFlag(t);
              case 4:
                this.flags[t] = e.sent;
                return e.abrupt("return", this.flags[t]);
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "get",
      value: function (e) {
        if (e in this.flags) {
          return this.flags[e];
        }
        var t = this.evaluateFlag(e);
        if (v0(t)) {
          throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);
        }
        this.flags[e] = t;
        return this.flags[e];
      }
    }, {
      key: "getNumber",
      value: function (e) {
        return this.get(e);
      }
    }, {
      key: "getBool",
      value: function (e) {
        return this.get(e);
      }
    }, {
      key: "getString",
      value: function (e) {
        return this.get(e);
      }
    }, {
      key: "getFlags",
      value: function () {
        return this.flags;
      }
    }, {
      key: "features",
      get: function () {
        return this.flags;
      }
    }, {
      key: "set",
      value: function (e, t) {
        if (this.flagRegistry[e] == null) {
          throw new Error(`Cannot set flag ${e} as it has not been registered.`);
        }
        this.flags[e] = t;
        if (this.flagRegistry[e].setHook != null) {
          this.flagRegistry[e].setHook(t);
        }
      }
    }, {
      key: "evaluateFlag",
      value: function (e) {
        if (this.flagRegistry[e] == null) {
          throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);
        }
        return this.flagRegistry[e].evaluationFn();
      }
    }, {
      key: "setFlags",
      value: function (e) {
        this.flags = Object.assign({}, e);
      }
    }, {
      key: "reset",
      value: function () {
        this.flags = {};
        this.urlFlags = {};
        this.populateURLFlags();
      }
    }, {
      key: "populateURLFlags",
      value: function () {
        var e = this;
        if (this.global !== undefined && this.global.location !== undefined && this.global.location.search !== undefined) {
          var t = this.getQueryParams(this.global.location.search);
          if (g0 in t) {
            t.tfjsflags.split(",").forEach(function (t) {
              var n = S(t.split(":"), 2);
              var r = n[0];
              var a = n[1];
              e.urlFlags[r] = function (e, t) {
                var n = t.toLowerCase();
                if (n === "true" || n === "false") {
                  return n === "true";
                } else if (`${+n}` === n) {
                  return +n;
                } else {
                  return t;
                }
              }(0, a);
            });
          }
        }
      }
    }]);
    return e;
  }();
  function b0(e) {
    var t = {};
    e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {
      for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) {
        r[a - 1] = arguments[a];
      }
      x0(t, r[0], r[1]);
      return r.join("=");
    });
    return t;
  }
  function x0(e, t, n) {
    e[decodeURIComponent(t)] = decodeURIComponent(n || "");
  }
  function k0() {
    return e.ENV;
  }
  function w0() {
    if (m0 == null) {
      var e;
      if (typeof window != "undefined") {
        e = window;
      } else if (typeof global != "undefined") {
        e = global;
      } else if (typeof process != "undefined") {
        e = process;
      } else {
        if (typeof self == "undefined") {
          throw new Error("Could not find a global object");
        }
        e = self;
      }
      m0 = e;
    }
    return m0;
  }
  function I0(e, t) {
    var n;
    if ((n = w0())._tfGlobals == null) {
      n._tfGlobals = new Map();
    }
    var r = n._tfGlobals;
    if (r.has(e)) {
      return r.get(e);
    }
    var a = t();
    r.set(e, a);
    return r.get(e);
  }
  e.ENV = null;
  var N0 = "Abs";
  var S0 = "Acos";
  var T0 = "Acosh";
  var E0 = "Add";
  var C0 = "AddN";
  var A0 = "All";
  var R0 = "Any";
  var _0 = "ArgMax";
  var O0 = "ArgMin";
  var F0 = "Asin";
  var D0 = "Asinh";
  var M0 = "Atan";
  var L0 = "Atanh";
  var z0 = "Atan2";
  var P0 = "AvgPool";
  var B0 = "AvgPoolGrad";
  var W0 = "AvgPool3D";
  var U0 = "AvgPool3DGrad";
  var V0 = "BatchMatMul";
  var G0 = "BatchToSpaceND";
  var j0 = "Bincount";
  var H0 = "BitwiseAnd";
  var q0 = "BroadcastTo";
  var K0 = "BroadcastArgs";
  var X0 = "Cast";
  var Y0 = "Ceil";
  var J0 = "ClipByValue";
  var Z0 = "Complex";
  var Q0 = "ComplexAbs";
  var $0 = "Concat";
  var e1 = "Conv2D";
  var t1 = "Conv2DBackpropFilter";
  var n1 = "Conv2DBackpropInput";
  var r1 = "Conv3D";
  var a1 = "Conv3DBackpropFilterV2";
  var i1 = "Conv3DBackpropInputV2";
  var o1 = "Cos";
  var s1 = "Cosh";
  var u1 = "Cumprod";
  var c1 = "Cumsum";
  var l1 = "CropAndResize";
  var h1 = "DenseBincount";
  var p1 = "DepthToSpace";
  var f1 = "DepthwiseConv2dNative";
  var d1 = "DepthwiseConv2dNativeBackpropFilter";
  var v1 = "DepthwiseConv2dNativeBackpropInput";
  var m1 = "Diag";
  var g1 = "Dilation2D";
  var y1 = "Dilation2DBackpropInput";
  var b1 = "Dilation2DBackpropFilter";
  var x1 = "Draw";
  var k1 = "RealDiv";
  var w1 = "Einsum";
  var I1 = "Elu";
  var N1 = "EluGrad";
  var S1 = "Erf";
  var T1 = "Equal";
  var E1 = "Exp";
  var C1 = "ExpandDims";
  var A1 = "Expm1";
  var R1 = "FFT";
  var _1 = "Fill";
  var O1 = "FlipLeftRight";
  var F1 = "Floor";
  var D1 = "FloorDiv";
  var M1 = "FusedBatchNorm";
  var L1 = "GatherV2";
  var z1 = "GatherNd";
  var P1 = "Greater";
  var B1 = "GreaterEqual";
  var W1 = "Identity";
  var U1 = "IFFT";
  var V1 = "Imag";
  var G1 = "IsFinite";
  var j1 = "IsInf";
  var H1 = "IsNan";
  var q1 = "LeakyRelu";
  var K1 = "Less";
  var X1 = "LessEqual";
  var Y1 = "LinSpace";
  var J1 = "Log";
  var Z1 = "Log1p";
  var Q1 = "LogicalAnd";
  var $1 = "LogicalNot";
  var e2 = "LogicalOr";
  var t2 = "LogSoftmax";
  var n2 = "LRN";
  var r2 = "LRNGrad";
  var a2 = "Max";
  var i2 = "Maximum";
  var o2 = "MaxPool";
  var s2 = "MaxPoolGrad";
  var u2 = "MaxPool3D";
  var c2 = "MaxPool3DGrad";
  var l2 = "MaxPoolWithArgmax";
  var h2 = "Mean";
  var p2 = "Min";
  var f2 = "Minimum";
  var d2 = "MirrorPad";
  var v2 = "Mod";
  var m2 = "Multinomial";
  var g2 = "Multiply";
  var y2 = "Neg";
  var b2 = "NotEqual";
  var x2 = "NonMaxSuppressionV3";
  var k2 = "NonMaxSuppressionV4";
  var w2 = "NonMaxSuppressionV5";
  var I2 = "OnesLike";
  var N2 = "OneHot";
  var S2 = "Pack";
  var T2 = "PadV2";
  var E2 = "Pow";
  var C2 = "Prelu";
  var A2 = "Prod";
  var R2 = "RaggedGather";
  var _2 = "RaggedRange";
  var O2 = "RaggedTensorToTensor";
  var F2 = "Range";
  var D2 = "Real";
  var M2 = "Reciprocal";
  var L2 = "Relu";
  var z2 = "Reshape";
  var P2 = "ResizeNearestNeighbor";
  var B2 = "ResizeNearestNeighborGrad";
  var W2 = "ResizeBilinear";
  var U2 = "ResizeBilinearGrad";
  var V2 = "Relu6";
  var G2 = "Reverse";
  var j2 = "Round";
  var H2 = "Rsqrt";
  var q2 = "ScatterNd";
  var K2 = "TensorScatterUpdate";
  var X2 = "SearchSorted";
  var Y2 = "Select";
  var J2 = "Selu";
  var Z2 = "Slice";
  var Q2 = "Sin";
  var $2 = "Sinh";
  var e3 = "Sign";
  var t3 = "Sigmoid";
  var n3 = "Softplus";
  var r3 = "Sqrt";
  var a3 = "Sum";
  var i3 = "SpaceToBatchND";
  var o3 = "SplitV";
  var s3 = "Softmax";
  var u3 = "SparseFillEmptyRows";
  var c3 = "SparseReshape";
  var l3 = "SparseSegmentMean";
  var h3 = "SparseSegmentSum";
  var p3 = "SparseToDense";
  var f3 = "SquaredDifference";
  var d3 = "Square";
  var v3 = "StaticRegexReplace";
  var m3 = "StridedSlice";
  var g3 = "StringNGrams";
  var y3 = "StringSplit";
  var b3 = "StringToHashBucketFast";
  var x3 = "Sub";
  var k3 = "Tan";
  var w3 = "Tanh";
  var I3 = "Tile";
  var N3 = "TopK";
  var S3 = "Transform";
  var T3 = "Transpose";
  var E3 = "Unique";
  var C3 = "Unpack";
  var A3 = "UnsortedSegmentSum";
  var R3 = "ZerosLike";
  var _3 = "Step";
  var O3 = "FromPixels";
  var F3 = "RotateWithOffset";
  var D3 = "_FusedMatMul";
  var M3 = "FusedConv2D";
  var L3 = "FusedDepthwiseConv2D";
  function z3() {
    var e;
    if (!k0().getBool("IS_TEST") && !k0().getBool("PROD")) {
      (e = console).warn.apply(e, arguments);
    }
  }
  var P3 = I0("kernelRegistry", function () {
    return new Map();
  });
  var B3 = I0("gradRegistry", function () {
    return new Map();
  });
  function W3(e, t) {
    var n = H3(e, t);
    return P3.get(n);
  }
  function U3(e) {
    return B3.get(e);
  }
  function V3(e) {
    var t = P3.entries();
    var n = [];
    while (true) {
      var r = t.next();
      var a = r.done;
      var i = r.value;
      if (a) {
        break;
      }
      var o = S(i, 2);
      var s = o[0];
      var u = o[1];
      if (S(s.split("_"), 1)[0] === e) {
        n.push(u);
      }
    }
    return n;
  }
  function G3(e) {
    var t = e.kernelName;
    var n = e.backendName;
    var r = H3(t, n);
    if (P3.has(r)) {
      z3(`The kernel '${t}' for backend '${n}' is already registered`);
    }
    P3.set(r, e);
  }
  function j3(e) {
    var t = e.kernelName;
    if (B3.has(t) && k0().getBool("DEBUG")) {
      z3(`Overriding the gradient for '${t}'`);
    }
    B3.set(t, e);
  }
  function H3(e, t) {
    return `${t}_${e}`;
  }
  function q3(e) {
    return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray;
  }
  var K3 = Y3;
  var X3 = null;
  try {
    X3 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (e) {}
  function Y3(e, t, n) {
    this.low = e | 0;
    this.high = t | 0;
    this.unsigned = !!n;
  }
  function J3(e) {
    return (e && e.__isLong__) === true;
  }
  Y3.prototype.__isLong__;
  Object.defineProperty(Y3.prototype, "__isLong__", {
    value: true
  });
  Y3.isLong = J3;
  var Z3 = {};
  var Q3 = {};
  function $3(e, t) {
    var n;
    var r;
    var a;
    if (t) {
      if ((a = (e >>>= 0) >= 0 && e < 256) && (r = Q3[e])) {
        return r;
      } else {
        n = t4(e, (e | 0) < 0 ? -1 : 0, true);
        if (a) {
          Q3[e] = n;
        }
        return n;
      }
    } else if ((a = (e |= 0) >= -128 && e < 128) && (r = Z3[e])) {
      return r;
    } else {
      n = t4(e, e < 0 ? -1 : 0, false);
      if (a) {
        Z3[e] = n;
      }
      return n;
    }
  }
  function e4(e, t) {
    if (isNaN(e)) {
      if (t) {
        return l4;
      } else {
        return c4;
      }
    }
    if (t) {
      if (e < 0) {
        return l4;
      }
      if (e >= o4) {
        return v4;
      }
    } else {
      if (e <= -s4) {
        return m4;
      }
      if (e + 1 >= s4) {
        return d4;
      }
    }
    if (e < 0) {
      return e4(-e, t).neg();
    } else {
      return t4(e % i4 | 0, e / i4 | 0, t);
    }
  }
  function t4(e, t, n) {
    return new Y3(e, t, n);
  }
  Y3.fromInt = $3;
  Y3.fromNumber = e4;
  Y3.fromBits = t4;
  var n4 = Math.pow;
  function r4(e, t, n) {
    if (e.length === 0) {
      throw Error("empty string");
    }
    if (e === "NaN" || e === "Infinity" || e === "+Infinity" || e === "-Infinity") {
      return c4;
    }
    if (typeof t == "number") {
      n = t;
      t = false;
    } else {
      t = !!t;
    }
    if ((n = n || 10) < 2 || n > 36) {
      throw RangeError("radix");
    }
    var r;
    if ((r = e.indexOf("-")) > 0) {
      throw Error("interior hyphen");
    }
    if (r === 0) {
      return r4(e.substring(1), t, n).neg();
    }
    var a = e4(n4(n, 8));
    var i = c4;
    for (var o = 0; o < e.length; o += 8) {
      var s = Math.min(8, e.length - o);
      var u = parseInt(e.substring(o, o + s), n);
      if (s < 8) {
        var c = e4(n4(n, s));
        i = i.mul(c).add(e4(u));
      } else {
        i = (i = i.mul(a)).add(e4(u));
      }
    }
    i.unsigned = t;
    return i;
  }
  function a4(e, t) {
    if (typeof e == "number") {
      return e4(e, t);
    } else if (typeof e == "string") {
      return r4(e, t);
    } else {
      return t4(e.low, e.high, typeof t == "boolean" ? t : e.unsigned);
    }
  }
  Y3.fromString = r4;
  Y3.fromValue = a4;
  var i4 = 4294967296;
  var o4 = i4 * i4;
  var s4 = o4 / 2;
  var u4 = $3(16777216);
  var c4 = $3(0);
  Y3.ZERO = c4;
  var l4 = $3(0, true);
  Y3.UZERO = l4;
  var h4 = $3(1);
  Y3.ONE = h4;
  var p4 = $3(1, true);
  Y3.UONE = p4;
  var f4 = $3(-1);
  Y3.NEG_ONE = f4;
  var d4 = t4(-1, 2147483647, false);
  Y3.MAX_VALUE = d4;
  var v4 = t4(-1, -1, true);
  Y3.MAX_UNSIGNED_VALUE = v4;
  var m4 = t4(0, -2147483648, false);
  Y3.MIN_VALUE = m4;
  var g4 = Y3.prototype;
  g4.toInt = function () {
    if (this.unsigned) {
      return this.low >>> 0;
    } else {
      return this.low;
    }
  };
  g4.toNumber = function () {
    if (this.unsigned) {
      return (this.high >>> 0) * i4 + (this.low >>> 0);
    } else {
      return this.high * i4 + (this.low >>> 0);
    }
  };
  g4.toString = function (e) {
    if ((e = e || 10) < 2 || e > 36) {
      throw RangeError("radix");
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.eq(m4)) {
        var t = e4(e);
        var n = this.div(t);
        var r = n.mul(t).sub(this);
        return n.toString(e) + r.toInt().toString(e);
      }
      return "-" + this.neg().toString(e);
    }
    var a = e4(n4(e, 6), this.unsigned);
    var i = this;
    var o = "";
    while (true) {
      var s = i.div(a);
      var u = (i.sub(s.mul(a)).toInt() >>> 0).toString(e);
      if ((i = s).isZero()) {
        return u + o;
      }
      while (u.length < 6) {
        u = "0" + u;
      }
      o = "" + u + o;
    }
  };
  g4.getHighBits = function () {
    return this.high;
  };
  g4.getHighBitsUnsigned = function () {
    return this.high >>> 0;
  };
  g4.getLowBits = function () {
    return this.low;
  };
  g4.getLowBitsUnsigned = function () {
    return this.low >>> 0;
  };
  g4.getNumBitsAbs = function () {
    if (this.isNegative()) {
      if (this.eq(m4)) {
        return 64;
      } else {
        return this.neg().getNumBitsAbs();
      }
    }
    for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && (e & 1 << t) == 0; t--);
    if (this.high != 0) {
      return t + 33;
    } else {
      return t + 1;
    }
  };
  g4.isZero = function () {
    return this.high === 0 && this.low === 0;
  };
  g4.eqz = g4.isZero;
  g4.isNegative = function () {
    return !this.unsigned && this.high < 0;
  };
  g4.isPositive = function () {
    return this.unsigned || this.high >= 0;
  };
  g4.isOdd = function () {
    return (this.low & 1) == 1;
  };
  g4.isEven = function () {
    return (this.low & 1) == 0;
  };
  g4.equals = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    return (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && this.high === e.high && this.low === e.low;
  };
  g4.eq = g4.equals;
  g4.notEquals = function (e) {
    return !this.eq(e);
  };
  g4.neq = g4.notEquals;
  g4.ne = g4.notEquals;
  g4.lessThan = function (e) {
    return this.comp(e) < 0;
  };
  g4.lt = g4.lessThan;
  g4.lessThanOrEqual = function (e) {
    return this.comp(e) <= 0;
  };
  g4.lte = g4.lessThanOrEqual;
  g4.le = g4.lessThanOrEqual;
  g4.greaterThan = function (e) {
    return this.comp(e) > 0;
  };
  g4.gt = g4.greaterThan;
  g4.greaterThanOrEqual = function (e) {
    return this.comp(e) >= 0;
  };
  g4.gte = g4.greaterThanOrEqual;
  g4.ge = g4.greaterThanOrEqual;
  g4.compare = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    if (this.eq(e)) {
      return 0;
    }
    var t = this.isNegative();
    var n = e.isNegative();
    if (t && !n) {
      return -1;
    } else if (!t && n) {
      return 1;
    } else if (this.unsigned) {
      if (e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0) {
        return -1;
      } else {
        return 1;
      }
    } else if (this.sub(e).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };
  g4.comp = g4.compare;
  g4.negate = function () {
    if (!this.unsigned && this.eq(m4)) {
      return m4;
    } else {
      return this.not().add(h4);
    }
  };
  g4.neg = g4.negate;
  g4.add = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    var t = this.high >>> 16;
    var n = this.high & 65535;
    var r = this.low >>> 16;
    var a = this.low & 65535;
    var i = e.high >>> 16;
    var o = e.high & 65535;
    var s = e.low >>> 16;
    var u = 0;
    var c = 0;
    var l = 0;
    var h = 0;
    l += (h += a + (e.low & 65535)) >>> 16;
    c += (l += r + s) >>> 16;
    u += (c += n + o) >>> 16;
    u += t + i;
    return t4((l &= 65535) << 16 | (h &= 65535), (u &= 65535) << 16 | (c &= 65535), this.unsigned);
  };
  g4.subtract = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    return this.add(e.neg());
  };
  g4.sub = g4.subtract;
  g4.multiply = function (e) {
    if (this.isZero()) {
      return c4;
    }
    if (!J3(e)) {
      e = a4(e);
    }
    if (X3) {
      return t4(X3.mul(this.low, this.high, e.low, e.high), X3.get_high(), this.unsigned);
    }
    if (e.isZero()) {
      return c4;
    }
    if (this.eq(m4)) {
      if (e.isOdd()) {
        return m4;
      } else {
        return c4;
      }
    }
    if (e.eq(m4)) {
      if (this.isOdd()) {
        return m4;
      } else {
        return c4;
      }
    }
    if (this.isNegative()) {
      if (e.isNegative()) {
        return this.neg().mul(e.neg());
      } else {
        return this.neg().mul(e).neg();
      }
    }
    if (e.isNegative()) {
      return this.mul(e.neg()).neg();
    }
    if (this.lt(u4) && e.lt(u4)) {
      return e4(this.toNumber() * e.toNumber(), this.unsigned);
    }
    var t = this.high >>> 16;
    var n = this.high & 65535;
    var r = this.low >>> 16;
    var a = this.low & 65535;
    var i = e.high >>> 16;
    var o = e.high & 65535;
    var s = e.low >>> 16;
    var u = e.low & 65535;
    var c = 0;
    var l = 0;
    var h = 0;
    var p = 0;
    h += (p += a * u) >>> 16;
    l += (h += r * u) >>> 16;
    h &= 65535;
    l += (h += a * s) >>> 16;
    c += (l += n * u) >>> 16;
    l &= 65535;
    c += (l += r * s) >>> 16;
    l &= 65535;
    c += (l += a * o) >>> 16;
    c += t * u + n * s + r * o + a * i;
    return t4((h &= 65535) << 16 | (p &= 65535), (c &= 65535) << 16 | (l &= 65535), this.unsigned);
  };
  g4.mul = g4.multiply;
  g4.divide = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    if (e.isZero()) {
      throw Error("division by zero");
    }
    var t;
    var n;
    var r;
    if (X3) {
      if (this.unsigned || this.high !== -2147483648 || e.low !== -1 || e.high !== -1) {
        return t4((this.unsigned ? X3.div_u : X3.div_s)(this.low, this.high, e.low, e.high), X3.get_high(), this.unsigned);
      } else {
        return this;
      }
    }
    if (this.isZero()) {
      if (this.unsigned) {
        return l4;
      } else {
        return c4;
      }
    }
    if (this.unsigned) {
      if (!e.unsigned) {
        e = e.toUnsigned();
      }
      if (e.gt(this)) {
        return l4;
      }
      if (e.gt(this.shru(1))) {
        return p4;
      }
      r = l4;
    } else {
      if (this.eq(m4)) {
        if (e.eq(h4) || e.eq(f4)) {
          return m4;
        } else if (e.eq(m4)) {
          return h4;
        } else if ((t = this.shr(1).div(e).shl(1)).eq(c4)) {
          if (e.isNegative()) {
            return h4;
          } else {
            return f4;
          }
        } else {
          n = this.sub(e.mul(t));
          return r = t.add(n.div(e));
        }
      }
      if (e.eq(m4)) {
        if (this.unsigned) {
          return l4;
        } else {
          return c4;
        }
      }
      if (this.isNegative()) {
        if (e.isNegative()) {
          return this.neg().div(e.neg());
        } else {
          return this.neg().div(e).neg();
        }
      }
      if (e.isNegative()) {
        return this.div(e.neg()).neg();
      }
      r = c4;
    }
    for (n = this; n.gte(e);) {
      t = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));
      var a = Math.ceil(Math.log(t) / Math.LN2);
      var i = a <= 48 ? 1 : n4(2, a - 48);
      var o = e4(t);
      for (var s = o.mul(e); s.isNegative() || s.gt(n);) {
        s = (o = e4(t -= i, this.unsigned)).mul(e);
      }
      if (o.isZero()) {
        o = h4;
      }
      r = r.add(o);
      n = n.sub(s);
    }
    return r;
  };
  g4.div = g4.divide;
  g4.modulo = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    if (X3) {
      return t4((this.unsigned ? X3.rem_u : X3.rem_s)(this.low, this.high, e.low, e.high), X3.get_high(), this.unsigned);
    } else {
      return this.sub(this.div(e).mul(e));
    }
  };
  g4.mod = g4.modulo;
  g4.rem = g4.modulo;
  g4.not = function () {
    return t4(~this.low, ~this.high, this.unsigned);
  };
  g4.and = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    return t4(this.low & e.low, this.high & e.high, this.unsigned);
  };
  g4.or = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    return t4(this.low | e.low, this.high | e.high, this.unsigned);
  };
  g4.xor = function (e) {
    if (!J3(e)) {
      e = a4(e);
    }
    return t4(this.low ^ e.low, this.high ^ e.high, this.unsigned);
  };
  g4.shiftLeft = function (e) {
    if (J3(e)) {
      e = e.toInt();
    }
    if ((e &= 63) == 0) {
      return this;
    } else if (e < 32) {
      return t4(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned);
    } else {
      return t4(0, this.low << e - 32, this.unsigned);
    }
  };
  g4.shl = g4.shiftLeft;
  g4.shiftRight = function (e) {
    if (J3(e)) {
      e = e.toInt();
    }
    if ((e &= 63) == 0) {
      return this;
    } else if (e < 32) {
      return t4(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned);
    } else {
      return t4(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
  };
  g4.shr = g4.shiftRight;
  g4.shiftRightUnsigned = function (e) {
    if (J3(e)) {
      e = e.toInt();
    }
    if ((e &= 63) === 0) {
      return this;
    }
    var t = this.high;
    if (e < 32) {
      return t4(this.low >>> e | t << 32 - e, t >>> e, this.unsigned);
    } else {
      return t4(e === 32 ? t : t >>> e - 32, 0, this.unsigned);
    }
  };
  g4.shru = g4.shiftRightUnsigned;
  g4.shr_u = g4.shiftRightUnsigned;
  g4.toSigned = function () {
    if (this.unsigned) {
      return t4(this.low, this.high, false);
    } else {
      return this;
    }
  };
  g4.toUnsigned = function () {
    if (this.unsigned) {
      return this;
    } else {
      return t4(this.low, this.high, true);
    }
  };
  g4.toBytes = function (e) {
    if (e) {
      return this.toBytesLE();
    } else {
      return this.toBytesBE();
    }
  };
  g4.toBytesLE = function () {
    var e = this.high;
    var t = this.low;
    return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
  };
  g4.toBytesBE = function () {
    var e = this.high;
    var t = this.low;
    return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
  };
  Y3.fromBytes = function (e, t, n) {
    if (n) {
      return Y3.fromBytesLE(e, t);
    } else {
      return Y3.fromBytesBE(e, t);
    }
  };
  Y3.fromBytesLE = function (e, t) {
    return new Y3(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
  };
  Y3.fromBytesBE = function (e, t) {
    return new Y3(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
  };
  var y4 = r(K3);
  var b4 = y4 || t({
    __proto__: null,
    default: y4
  }, [K3]);
  function x4(e) {
    return b4.fromString(e, true, 16);
  }
  var k4 = x4("c3a5c85c97cb3127");
  var w4 = x4("b492b66fbe98f273");
  var I4 = x4("9ae16a3b2f90404f");
  function N4(e) {
    return e.xor(e.shru(47));
  }
  function S4(e, t, n) {
    var r = e.slice(t, t + n);
    return b4.fromBytes(Array.from(r), true, true);
  }
  function T4(e, t) {
    return S4(e, t, 8);
  }
  function E4(e, t) {
    return S4(e, t, 4);
  }
  function C4(e, t) {
    if (t === 0) {
      return e;
    } else {
      return e.shru(t).or(e.shl(64 - t));
    }
  }
  function A4(e, t, n = x4("9ddfea08eb382d69")) {
    var r = e.xor(t).mul(n);
    r = r.xor(r.shru(47));
    var a = t.xor(r).mul(n);
    return a = (a = a.xor(a.shru(47))).mul(n);
  }
  function R4(e, t, n, r) {
    return function (e, t, n, r, a, i) {
      a = a.add(e);
      i = C4(i.add(a).add(r), 21);
      var o = a;
      a = (a = a.add(t)).add(n);
      i = i.add(C4(a, 44));
      return [a.add(r), i.add(o)];
    }(T4(e, t), T4(e, t + 8), T4(e, t + 16), T4(e, t + 24), n, r);
  }
  function _4(e, t = e.length) {
    if (t >= 8) {
      var n = I4.add(t * 2);
      var r = T4(e, 0).add(I4);
      var a = T4(e, t - 8);
      var i = C4(a, 37).mul(n).add(r);
      var o = C4(r, 25).add(a).mul(n);
      return A4(i, o, n);
    }
    if (t >= 4) {
      var s = I4.add(t * 2);
      var u = E4(e, 0);
      return A4(u.shl(3).add(t), E4(e, t - 4), s);
    }
    if (t > 0) {
      var c = e[0];
      var l = e[t >> 1];
      var h = e[t - 1];
      var p = c + (l << 8);
      var f = t + (h << 2);
      return N4(I4.mul(p).xor(k4.mul(f))).mul(I4);
    }
    return I4;
  }
  function O4(e, t = e.length) {
    var n = I4.add(t * 2);
    var r = T4(e, 0).mul(w4);
    var a = T4(e, 8);
    var i = T4(e, t - 8).mul(n);
    var o = T4(e, t - 16).mul(I4);
    return A4(C4(r.add(a), 43).add(C4(i, 30)).add(o), r.add(C4(a.add(I4), 18)).add(i), n);
  }
  function F4(e, t = e.length) {
    var n = I4.add(t * 2);
    var r = T4(e, 0).mul(I4);
    var a = T4(e, 8);
    var i = T4(e, t - 8).mul(n);
    var o = T4(e, t - 16).mul(I4);
    var s = C4(r.add(a), 43).add(C4(i, 30)).add(o);
    var u = A4(s, r.add(C4(a.add(I4), 18)).add(i), n);
    var c = T4(e, 16).mul(n);
    var l = T4(e, 24);
    var h = s.add(T4(e, t - 32)).mul(n);
    var p = u.add(T4(e, t - 24)).mul(n);
    return A4(C4(c.add(l), 43).add(C4(h, 30)).add(p), c.add(C4(l.add(r), 18)).add(h), n);
  }
  function D4(e, t = e.length) {
    var n = b4.fromNumber(81, true);
    if (t <= 32) {
      if (t <= 16) {
        return _4(e, t);
      } else {
        return O4(e, t);
      }
    }
    if (t <= 64) {
      return F4(e, t);
    }
    var r = n;
    var a = n.mul(w4).add(113);
    var i = N4(a.mul(I4).add(113)).mul(I4);
    var o = [b4.UZERO, b4.UZERO];
    var s = [b4.UZERO, b4.UZERO];
    r = r.mul(I4).add(T4(e, 0));
    var u = 0;
    var c = (t - 1 >> 6) * 64;
    var l = c + (t - 1 & 63) - 63;
    do {
      r = C4(r.add(a).add(o[0]).add(T4(e, u + 8)), 37).mul(w4);
      a = C4(a.add(o[1]).add(T4(e, u + 48)), 42).mul(w4);
      r = r.xor(s[1]);
      a = a.add(o[0]).add(T4(e, u + 40));
      i = C4(i.add(s[0]), 33).mul(w4);
      o = R4(e, u, o[1].mul(w4), r.add(s[0]));
      s = R4(e, u + 32, i.add(s[1]), a.add(T4(e, u + 16)));
      var h = [r, i];
      i = h[0];
      r = h[1];
      u += 64;
    } while (u !== c);
    var p = w4.add(i.and(255).shl(1));
    u = l;
    s[0] = s[0].add(t - 1 & 63);
    o[0] = o[0].add(s[0]);
    s[0] = s[0].add(o[0]);
    r = C4(r.add(a).add(o[0]).add(T4(e, u + 8)), 37).mul(p);
    a = C4(a.add(o[1]).add(T4(e, u + 48)), 42).mul(p);
    r = r.xor(s[1].mul(9));
    a = a.add(o[0].mul(9).add(T4(e, u + 40)));
    i = C4(i.add(s[0]), 33).mul(p);
    o = R4(e, u, o[1].mul(p), r.add(s[0]));
    s = R4(e, u + 32, i.add(s[1]), a.add(T4(e, u + 16)));
    var f = [r, i];
    i = f[0];
    r = f[1];
    return A4(A4(o[0], s[0], p).add(N4(a).mul(k4)).add(i), A4(o[1], s[1], p).add(r), p);
  }
  function M4(e, t) {
    if (t === "string") {
      return B4(e);
    } else {
      return L4([e], t);
    }
  }
  function L4(e, t) {
    if (t === "string") {
      throw new Error("Cannot convert a string[] to a TypedArray");
    }
    if (Array.isArray(e)) {
      e = V4(e);
    }
    if (k0().getBool("DEBUG")) {
      X$(e, t);
    }
    if (function (e, t) {
      return e instanceof Float32Array && t === "float32" || e instanceof Int32Array && t === "int32" || e instanceof Uint8Array && t === "bool";
    }(e, t)) {
      return e;
    }
    if (t == null || t === "float32" || t === "complex64") {
      return new Float32Array(e);
    }
    if (t === "int32") {
      return new Int32Array(e);
    }
    if (t === "bool") {
      for (var n = new Uint8Array(e.length), r = 0; r < n.length; ++r) {
        if (Math.round(e[r]) !== 0) {
          n[r] = 1;
        }
      }
      return n;
    }
    throw new Error(`Unknown data type ${t}`);
  }
  function z4() {
    return k0().platform.now();
  }
  function P4(e, t) {
    return k0().platform.fetch(e, t);
  }
  function B4(e, t = "utf-8") {
    t = t || "utf-8";
    return k0().platform.encode(e, t);
  }
  function W4(e, t = "utf-8") {
    t = t || "utf-8";
    return k0().platform.decode(e, t);
  }
  function U4(e) {
    if (k0().platform.isTypedArray != null) {
      return k0().platform.isTypedArray(e);
    } else {
      return q3(e);
    }
  }
  function V4(e, t = [], n = false) {
    if (t == null) {
      t = [];
    }
    if (typeof e == "boolean" || typeof e == "number" || typeof e == "string" || v0(e) || e == null || U4(e) && n) {
      t.push(e);
    } else if (Array.isArray(e) || U4(e)) {
      for (var r = 0; r < e.length; ++r) {
        V4(e[r], t, n);
      }
    } else {
      var a = -1;
      for (var i = 0, o = Object.keys(e); i < o.length; i++) {
        var s = o[i];
        if (/^([1-9]+[0-9]*|0)$/.test(s)) {
          a = Math.max(a, Number(s));
        }
      }
      for (var u = 0; u <= a; u++) {
        V4(e[u], t, n);
      }
    }
    return t;
  }
  var G4 = {
    __proto__: null,
    arraysEqual: P$,
    arraysEqualWithNull: z$,
    assert: F$,
    assertNonNegativeIntegerDimensions: p0,
    assertNonNull: M$,
    assertShapesMatch: D$,
    bytesFromStringArray: Q$,
    bytesPerElement: Z$,
    checkConversionForErrors: X$,
    clamp: A$,
    computeStrides: i0,
    convertBackendValuesAndArrayBuffer: u0,
    createScalarValue: M4,
    createShuffledIndices: function (e) {
      var t = new Uint32Array(e);
      for (var n = 0; n < e; ++n) {
        t[n] = n;
      }
      C$(t);
      return t;
    },
    decodeString: W4,
    distSquared: function (e, t) {
      var n = 0;
      for (var r = 0; r < e.length; r++) {
        var a = Number(e[r]) - Number(t[r]);
        n += a * a;
      }
      return n;
    },
    encodeString: B4,
    fetch: P4,
    fingerPrint64: D4,
    flatten: V4,
    getArrayFromDType: K$,
    getTypedArrayFromDType: q$,
    hasEncodingLoss: J$,
    hexToLong: x4,
    indexToLoc: d0,
    inferDtype: n0,
    inferFromImplicitShape: G$,
    isBoolean: e0,
    isFunction: r0,
    isInt: B$,
    isNumber: t0,
    isPromise: v0,
    isScalarShape: function (e) {
      return e.length === 0;
    },
    isString: $$,
    isTypedArray: U4,
    isValidDtype: Y$,
    locToIndex: f0,
    makeOnesTypedArray: c0,
    makeZerosNestedTypedArray: h0,
    makeZerosTypedArray: l0,
    nearestDivisor: a0,
    nearestLargerEven: R$,
    now: z4,
    parseAxisParam: j$,
    randUniform: function (e, t) {
      var n = Math.random();
      return t * n + (1 - n) * e;
    },
    repeatedTry: V$,
    rightPad: U$,
    shuffle: C$,
    shuffleCombo: function (e, t) {
      if (e.length !== t.length) {
        throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);
      }
      for (var n = e.length, r = 0; n > 0;) {
        r = Math.random() * n | 0;
        _$(e, --n, r);
        _$(t, n, r);
      }
    },
    sizeFromShape: L$,
    sizeToSquarishShape: W$,
    squeezeShape: H$,
    sum: O$,
    swap: _$,
    tanh: function (e) {
      if (Math.tanh != null) {
        return Math.tanh(e);
      }
      if (e === Infinity) {
        return 1;
      }
      if (e === -Infinity) {
        return -1;
      }
      var t = Math.exp(e * 2);
      return (t - 1) / (t + 1);
    },
    toNestedArray: s0,
    toTypedArray: L4
  };
  var j4 = function () {
    function e(t, n) {
      l(this, e);
      this.backendTimer = t;
      this.logger = n;
      if (n == null) {
        this.logger = new H4();
      }
    }
    p(e, [{
      key: "profileKernel",
      value: function (e, t, n) {
        var r;
        var a;
        function i() {
          r = n();
        }
        var o = z4();
        if (this.backendTimer.timerAvailable()) {
          a = this.backendTimer.time(i);
        } else {
          i();
          var s;
          var u = O(r);
          try {
            for (u.s(); !(s = u.n()).done;) {
              s.value.dataSync();
            }
          } catch (e) {
            u.e(e);
          } finally {
            u.f();
          }
          a = Promise.resolve({
            kernelMs: z4() - o
          });
        }
        if (k0().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
          var c = function () {
            var t = r[l];
            t.data().then(function (n) {
              (function (e, t, n) {
                if (t !== "float32") {
                  return false;
                }
                for (var r = 0; r < e.length; r++) {
                  var a = e[r];
                  if (isNaN(a) || !isFinite(a)) {
                    console.warn(`Found ${a} in the result of '${n}'`);
                    return true;
                  }
                }
              })(n, t.dtype, e);
            });
          };
          for (var l = 0; l < r.length; l++) {
            c();
          }
        }
        return {
          kernelName: e,
          outputs: r,
          inputs: t,
          timeMs: a.then(function (e) {
            return e.kernelMs;
          }),
          extraInfo: a.then(function (e) {
            if (e.getExtraProfileInfo != null) {
              return e.getExtraProfileInfo();
            } else {
              return "";
            }
          })
        };
      }
    }, {
      key: "logKernelProfile",
      value: function (e) {
        var t = this;
        var n = e.kernelName;
        var r = e.outputs;
        var a = e.timeMs;
        var i = e.inputs;
        var o = e.extraInfo;
        r.forEach(function (e) {
          Promise.all([e.data(), a, o]).then(function (r) {
            t.logger.logKernelProfile(n, e, r[0], r[1], i, r[2]);
          });
        });
      }
    }]);
    return e;
  }();
  var H4 = function () {
    function e() {
      l(this, e);
    }
    p(e, [{
      key: "logKernelProfile",
      value: function (e, t, n, r, a, i) {
        var o = typeof r == "number" ? U$(`${r}ms`, 9) : r.error;
        var s = U$(e, 25);
        var u = t.rank;
        var c = t.size;
        var l = U$(t.shape.toString(), 14);
        var h = "";
        for (var p in a) {
          var f = a[p];
          if (f != null) {
            var d = f.shape || t.shape;
            var v = d.length;
            h += `${p}: ${v}D ${v > 0 ? d : ""} `;
          }
        }
        console.log(`%c${s}\t%c${o}\t%c${u}D ${l}\t%c${c}\t%c${h}\t%c${i}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
      }
    }]);
    return e;
  }();
  function q4(e, t, n) {
    var r = {};
    var a = {};
    for (var i = 0; i < t.length; i++) {
      r[t[i].id] = true;
    }
    for (var o = 0; o < e.length; o++) {
      var s = e[o];
      var u = s.inputs;
      for (var c in u) {
        var l = u[c];
        var h = false;
        for (var p = 0; p < t.length; p++) {
          if (r[l.id]) {
            s.outputs.forEach(function (e) {
              return r[e.id] = true;
            });
            h = true;
            a[s.id] = true;
            break;
          }
        }
        if (h) {
          break;
        }
      }
    }
    var f = {
      [n.id]: true
    };
    var d = {};
    for (var v = e.length - 1; v >= 0; v--) {
      for (var m = e[v], g = m.inputs, y = 0; y < m.outputs.length; y++) {
        if (f[m.outputs[y].id]) {
          for (var b in g) {
            f[g[b].id] = true;
            d[m.id] = true;
          }
          break;
        }
      }
    }
    var x = [];
    for (var k = 0; k < e.length; k++) {
      var w = e[k];
      if (a[w.id] && d[w.id]) {
        var I = {};
        for (var N in w.inputs) {
          var S = w.inputs[N];
          if (r[S.id]) {
            I[N] = S;
          }
        }
        var T = Object.assign({}, w);
        T.inputs = I;
        T.outputs = w.outputs;
        x.push(T);
      }
    }
    return x;
  }
  function K4(e, t, n, r) {
    var a = function () {
      var a = t[i];
      var o = [];
      a.outputs.forEach(function (t) {
        var n = e[t.id];
        if (n != null) {
          o.push(n);
        } else {
          o.push(null);
        }
      });
      if (a.gradient == null) {
        throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);
      }
      var s = a.gradient(o);
      function u(t) {
        if (!(t in s)) {
          throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(s)}.`);
        }
        var i = n(function () {
          return s[t]();
        });
        if (i.dtype !== "float32") {
          throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${i.dtype}'`);
        }
        var o = a.inputs[t];
        if (!P$(i.shape, o.shape)) {
          throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${i.shape}', which does not match the shape of the input '${o.shape}'`);
        }
        if (e[o.id] == null) {
          e[o.id] = i;
        } else {
          var u = e[o.id];
          e[o.id] = r(u, i);
          u.dispose();
        }
      }
      for (var c in a.inputs) {
        u(c);
      }
    };
    for (var i = t.length - 1; i >= 0; i--) {
      a();
    }
  }
  function X4(e, t, n, r) {
    var a = i0(t);
    var i = function (e, t, n, r) {
      var a = L$(t);
      var i = r[r.length - 1];
      var o = new Array(i).fill(0);
      var s = t.length;
      var u = n === "complex64" ? Q4(e) : e;
      if (s > 1) {
        for (var c = 0; c < a / i; c++) {
          var l = c * i;
          for (var h = 0; h < i; h++) {
            o[h] = Math.max(o[h], Y4(u[l + h], 0, n).length);
          }
        }
      }
      return o;
    }(e, t, n, a);
    var o = t.length;
    var s = Z4(e, t, n, a, i);
    var u = ["Tensor"];
    if (r) {
      u.push(`  dtype: ${n}`);
      u.push(`  rank: ${o}`);
      u.push(`  shape: [${t}]`);
      u.push("  values:");
    }
    u.push(s.map(function (e) {
      return "    " + e;
    }).join("\n"));
    return u.join("\n");
  }
  function Y4(e, t, n) {
    return U$(Array.isArray(e) ? `${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j` : $$(e) ? `'${e}'` : n === "bool" ? J4(e) : parseFloat(e.toFixed(7)).toString(), t);
  }
  function J4(e) {
    if (e === 0) {
      return "false";
    } else {
      return "true";
    }
  }
  function Z4(e, t, n, r, a) {
    var i = !(arguments.length > 5) || arguments[5] === undefined || arguments[5];
    var o = n === "complex64" ? 2 : 1;
    var s = t[0];
    var u = t.length;
    if (u === 0) {
      if (n === "complex64") {
        var c = Q4(e);
        return [Y4(c[0], 0, n)];
      }
      if (n === "bool") {
        return [J4(e[0])];
      } else {
        return [e[0].toString()];
      }
    }
    if (u === 1) {
      if (s > 20) {
        var l = o * 3;
        var h = Array.from(e.slice(0, l));
        var p = Array.from(e.slice((s - 3) * o, s * o));
        if (n === "complex64") {
          h = Q4(h);
          p = Q4(p);
        }
        return ["[" + h.map(function (e, t) {
          return Y4(e, a[t], n);
        }).join(", ") + ", ..., " + p.map(function (e, t) {
          return Y4(e, a[s - 3 + t], n);
        }).join(", ") + "]"];
      }
      var f = n === "complex64" ? Q4(e) : Array.from(e);
      return ["[" + f.map(function (e, t) {
        return Y4(e, a[t], n);
      }).join(", ") + "]"];
    }
    var d = t.slice(1);
    var v = r.slice(1);
    var m = r[0] * o;
    var g = [];
    if (s > 20) {
      for (var y = 0; y < 3; y++) {
        var b = y * m;
        var x = b + m;
        g.push.apply(g, T(Z4(e.slice(b, x), d, n, v, a, false)));
      }
      g.push("...");
      for (var k = s - 3; k < s; k++) {
        var w = k * m;
        var I = w + m;
        g.push.apply(g, T(Z4(e.slice(w, I), d, n, v, a, k === s - 1)));
      }
    } else {
      for (var N = 0; N < s; N++) {
        var S = N * m;
        var E = S + m;
        g.push.apply(g, T(Z4(e.slice(S, E), d, n, v, a, N === s - 1)));
      }
    }
    var C = u === 2 ? "," : "";
    g[0] = "[" + (s > 0 ? g[0] + C : "");
    for (var A = 1; A < g.length - 1; A++) {
      g[A] = " " + g[A] + C;
    }
    var R = ",\n";
    for (var _ = 2; _ < u; _++) {
      R += "\n";
    }
    g[g.length - 1] = " " + g[g.length - 1] + "]" + (i ? "" : R);
    return g;
  }
  function Q4(e) {
    var t = [];
    for (var n = 0; n < e.length; n += 2) {
      t.push([e[n], e[n + 1]]);
    }
    return t;
  }
  var $4 = function () {
    function e(t, n, r) {
      var a = this;
      l(this, e);
      this.dtype = n;
      this.shape = t.slice();
      this.size = L$(t);
      if (r != null) {
        var i = r.length;
        F$(i === this.size, function () {
          return `Length of values '${i}' does not match the size inferred by the shape '${a.size}'.`;
        });
      }
      if (n === "complex64") {
        throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
      }
      this.values = r || K$(n, this.size);
      this.strides = i0(t);
    }
    p(e, [{
      key: "set",
      value: function (e) {
        var t = this;
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) {
          r[a - 1] = arguments[a];
        }
        if (r.length === 0) {
          r = [0];
        }
        F$(r.length === this.rank, function () {
          return `The number of provided coordinates (${r.length}) must match the rank (${t.rank})`;
        });
        var i = this.locToIndex(r);
        this.values[i] = e;
      }
    }, {
      key: "get",
      value: function () {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) {
          t[n] = arguments[n];
        }
        if (t.length === 0) {
          t = [0];
        }
        var r = 0;
        for (var a = 0, i = t; a < i.length; a++) {
          var o = i[a];
          if (o < 0 || o >= this.shape[r]) {
            var s = `Requested out of range element at ${t}.   Buffer shape=${this.shape}`;
            throw new Error(s);
          }
          r++;
        }
        var u = t[t.length - 1];
        for (var c = 0; c < t.length - 1; ++c) {
          u += this.strides[c] * t[c];
        }
        return this.values[u];
      }
    }, {
      key: "locToIndex",
      value: function (e) {
        if (this.rank === 0) {
          return 0;
        }
        if (this.rank === 1) {
          return e[0];
        }
        var t = e[e.length - 1];
        for (var n = 0; n < e.length - 1; ++n) {
          t += this.strides[n] * e[n];
        }
        return t;
      }
    }, {
      key: "indexToLoc",
      value: function (e) {
        if (this.rank === 0) {
          return [];
        }
        if (this.rank === 1) {
          return [e];
        }
        for (var t = new Array(this.shape.length), n = 0; n < t.length - 1; ++n) {
          t[n] = Math.floor(e / this.strides[n]);
          e -= t[n] * this.strides[n];
        }
        t[t.length - 1] = e;
        return t;
      }
    }, {
      key: "rank",
      get: function () {
        return this.shape.length;
      }
    }, {
      key: "toTensor",
      value: function () {
        return e5().makeTensor(this.values, this.shape, this.dtype);
      }
    }]);
    return e;
  }();
  var e5 = null;
  var t5 = null;
  var n5 = function () {
    function e(t, n, r, a) {
      l(this, e);
      this.kept = false;
      this.isDisposedInternal = false;
      this.shape = t.slice();
      this.dtype = n || "float32";
      this.size = L$(t);
      this.strides = i0(t);
      this.dataId = r;
      this.id = a;
      this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    var t;
    var n;
    var r;
    var a;
    p(e, [{
      key: "rank",
      get: function () {
        return this.shape.length;
      }
    }, {
      key: "buffer",
      value: (a = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.data();
              case 2:
                t = e.sent;
                return e.abrupt("return", t5.buffer(this.shape, this.dtype, t));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "bufferSync",
      value: function () {
        return t5.buffer(this.shape, this.dtype, this.dataSync());
      }
    }, {
      key: "array",
      value: (r = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.data();
              case 2:
                t = e.sent;
                return e.abrupt("return", s0(this.shape, t, this.dtype === "complex64"));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return r.apply(this, arguments);
      })
    }, {
      key: "arraySync",
      value: function () {
        return s0(this.shape, this.dataSync(), this.dtype === "complex64");
      }
    }, {
      key: "data",
      value: (n = c(o().mark(function e() {
        var t;
        var n;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.throwIfDisposed();
                t = e5().read(this.dataId);
                if (this.dtype !== "string") {
                  e.next = 13;
                  break;
                }
                e.next = 5;
                return t;
              case 5:
                n = e.sent;
                e.prev = 6;
                return e.abrupt("return", n.map(function (e) {
                  return W4(e);
                }));
              case 10:
                e.prev = 10;
                e.t0 = e.catch(6);
                throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
              case 13:
                return e.abrupt("return", t);
              case 14:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[6, 10]]);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "dataToGPU",
      value: function (e) {
        this.throwIfDisposed();
        return e5().readToGPU(this.dataId, e);
      }
    }, {
      key: "dataSync",
      value: function () {
        this.throwIfDisposed();
        var e = e5().readSync(this.dataId);
        if (this.dtype === "string") {
          try {
            return e.map(function (e) {
              return W4(e);
            });
          } catch (e) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
          }
        }
        return e;
      }
    }, {
      key: "bytes",
      value: (t = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.throwIfDisposed();
                e.next = 3;
                return e5().read(this.dataId);
              case 3:
                t = e.sent;
                if (this.dtype !== "string") {
                  e.next = 8;
                  break;
                }
                return e.abrupt("return", t);
              case 8:
                return e.abrupt("return", new Uint8Array(t.buffer));
              case 9:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }, {
      key: "dispose",
      value: function () {
        if (!this.isDisposed) {
          if (this.kerasMask) {
            this.kerasMask.dispose();
          }
          e5().disposeTensor(this);
          this.isDisposedInternal = true;
        }
      }
    }, {
      key: "isDisposed",
      get: function () {
        return this.isDisposedInternal;
      }
    }, {
      key: "throwIfDisposed",
      value: function () {
        if (this.isDisposed) {
          throw new Error("Tensor is disposed.");
        }
      }
    }, {
      key: "print",
      value: function (e = false) {
        return t5.print(this, e);
      }
    }, {
      key: "clone",
      value: function () {
        this.throwIfDisposed();
        return t5.clone(this);
      }
    }, {
      key: "toString",
      value: function (e = false) {
        var t = this.dataSync();
        return X4(t, this.shape, this.dtype, e);
      }
    }, {
      key: "cast",
      value: function (e) {
        this.throwIfDisposed();
        return t5.cast(this, e);
      }
    }, {
      key: "variable",
      value: function () {
        var e = !(arguments.length > 0) || arguments[0] === undefined || arguments[0];
        var t = arguments.length > 1 ? arguments[1] : undefined;
        var n = arguments.length > 2 ? arguments[2] : undefined;
        this.throwIfDisposed();
        return e5().makeVariable(this, e, t, n);
      }
    }]);
    return e;
  }();
  function r5() {
    return I0("Tensor", function () {
      return n5;
    });
  }
  Object.defineProperty(n5, Symbol.hasInstance, {
    value: function (e) {
      return !!e && e.data != null && e.dataSync != null && e.throwIfDisposed != null;
    }
  });
  r5();
  var a5;
  var i5;
  var o5;
  var s5;
  var u5;
  var c5 = function (e) {
    d(n, e);
    var t = w(n);
    function n(e, r, a, i) {
      var o;
      l(this, n);
      (o = t.call(this, e.shape, e.dtype, e.dataId, i)).trainable = r;
      o.name = a;
      return o;
    }
    p(n, [{
      key: "assign",
      value: function (e) {
        if (e.dtype !== this.dtype) {
          throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);
        }
        if (!P$(e.shape, this.shape)) {
          throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);
        }
        e5().disposeTensor(this);
        this.dataId = e.dataId;
        e5().incRef(this, null);
      }
    }, {
      key: "dispose",
      value: function () {
        e5().disposeVariable(this);
        this.isDisposedInternal = true;
      }
    }]);
    return n;
  }(n5);
  Object.defineProperty(c5, Symbol.hasInstance, {
    value: function (e) {
      return e instanceof n5 && e.assign != null && e.assign instanceof Function;
    }
  });
  e.Rank = undefined;
  (a5 = e.Rank ||= {}).R0 = "R0";
  a5.R1 = "R1";
  a5.R2 = "R2";
  a5.R3 = "R3";
  a5.R4 = "R4";
  a5.R5 = "R5";
  a5.R6 = "R6";
  (function (e) {
    e.float32 = "float32";
    e.int32 = "int32";
    e.bool = "int32";
    e.complex64 = "complex64";
  })(i5 ||= {});
  (function (e) {
    e.float32 = "float32";
    e.int32 = "int32";
    e.bool = "bool";
    e.complex64 = "complex64";
  })(o5 ||= {});
  (function (e) {
    e.float32 = "float32";
    e.int32 = "float32";
    e.bool = "float32";
    e.complex64 = "complex64";
  })(s5 ||= {});
  (function (e) {
    e.float32 = "complex64";
    e.int32 = "complex64";
    e.bool = "complex64";
    e.complex64 = "complex64";
  })(u5 ||= {});
  var l5 = {
    float32: s5,
    int32: i5,
    bool: o5,
    complex64: u5
  };
  function h5(e, t) {
    if (e === "string" || t === "string") {
      if (e === "string" && t === "string") {
        return "string";
      }
      throw new Error(`Can not upcast ${e} with ${t}`);
    }
    return l5[e][t];
  }
  function p5(e) {
    return h5(e, "int32");
  }
  function f5(e) {
    return e != null && s(e) === "object" && "texture" in e && e.texture instanceof WebGLTexture;
  }
  function d5(e) {
    return typeof GPUBuffer != "undefined" && e != null && s(e) === "object" && "buffer" in e && e.buffer instanceof GPUBuffer;
  }
  function v5(e, t) {
    if (e.dtype === t.dtype) {
      return [e, t];
    }
    var n = h5(e.dtype, t.dtype);
    return [e.cast(n), t.cast(n)];
  }
  function m5(e, t) {
    F$(e.dtype === t.dtype, function () {
      return `The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`;
    });
  }
  function g5(e, t) {
    return t.some(function (t) {
      return t.id === e.id;
    });
  }
  function y5(e) {
    var t = [];
    b5(e, t, new Set());
    return t;
  }
  function b5(e, t, n) {
    if (e != null) {
      if (e instanceof n5) {
        t.push(e);
      } else {
        r = e;
        if (Array.isArray(r) || s(r) === "object") {
          var r;
          var a = e;
          for (var i in a) {
            var o = a[i];
            if (!n.has(o)) {
              n.add(o);
              b5(o, t, n);
            }
          }
        }
      }
    }
  }
  var x5 = {
    __proto__: null,
    assertTypesMatch: m5,
    getTensorsInContainer: y5,
    isTensorInList: g5,
    makeTypesMatch: v5
  };
  function k5(e) {
    return e.kernelName != null;
  }
  var w5 = function () {
    function e() {
      l(this, e);
      this.registeredVariables = {};
      this.nextTapeNodeId = 0;
      this.numBytes = 0;
      this.numTensors = 0;
      this.numStringTensors = 0;
      this.numDataBuffers = 0;
      this.gradientDepth = 0;
      this.kernelDepth = 0;
      this.scopeStack = [];
      this.numDataMovesStack = [];
      this.nextScopeId = 0;
      this.tensorInfo = new WeakMap();
      this.profiling = false;
      this.activeProfile = {
        newBytes: 0,
        newTensors: 0,
        peakBytes: 0,
        kernels: [],
        result: null,
        get kernelNames() {
          return Array.from(new Set(this.kernels.map(function (e) {
            return e.name;
          })));
        }
      };
    }
    p(e, [{
      key: "dispose",
      value: function () {
        for (var e in this.registeredVariables) {
          this.registeredVariables[e].dispose();
        }
      }
    }]);
    return e;
  }();
  var I5 = function () {
    function e(t) {
      l(this, e);
      this.ENV = t;
      this.registry = {};
      this.registryFactory = {};
      this.pendingBackendInitId = 0;
      this.state = new w5();
    }
    var t;
    var n;
    var r;
    var a;
    p(e, [{
      key: "ready",
      value: (a = c(o().mark(function e() {
        var t;
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.pendingBackendInit == null) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", this.pendingBackendInit.then(function () {}));
              case 2:
                if (this.backendInstance == null) {
                  e.next = 4;
                  break;
                }
                return e.abrupt("return");
              case 4:
                t = this.getSortedBackends();
                n = 0;
              case 6:
                if (!(n < t.length)) {
                  e.next = 18;
                  break;
                }
                r = t[n];
                e.next = 10;
                return this.initializeBackend(r).success;
              case 10:
                if (!e.sent) {
                  e.next = 15;
                  break;
                }
                e.next = 14;
                return this.setBackend(r);
              case 14:
                return e.abrupt("return");
              case 15:
                n++;
                e.next = 6;
                break;
              case 18:
                throw new Error("Could not initialize any backends, all backend initializations failed.");
              case 19:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "backend",
      get: function () {
        if (this.pendingBackendInit != null) {
          throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        }
        if (this.backendInstance == null) {
          var e = this.initializeBackendsAndReturnBest();
          var t = e.name;
          if (e.asyncInit) {
            throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
          }
          this.setBackend(t);
        }
        return this.backendInstance;
      }
    }, {
      key: "backendNames",
      value: function () {
        return Object.keys(this.registryFactory);
      }
    }, {
      key: "findBackend",
      value: function (e) {
        if (!(e in this.registry)) {
          if (!(e in this.registryFactory)) {
            return null;
          }
          if (this.initializeBackend(e).asyncInit) {
            return null;
          }
        }
        return this.registry[e];
      }
    }, {
      key: "findBackendFactory",
      value: function (e) {
        if (e in this.registryFactory) {
          return this.registryFactory[e].factory;
        } else {
          return null;
        }
      }
    }, {
      key: "registerBackend",
      value: function (e, t, n = 1) {
        if (e in this.registryFactory) {
          z3(`${e} backend was already registered. Reusing existing backend factory.`);
          return false;
        } else {
          this.registryFactory[e] = {
            factory: t,
            priority: n
          };
          return true;
        }
      }
    }, {
      key: "setBackend",
      value: (r = c(o().mark(function e(t) {
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.registryFactory[t] != null) {
                  e.next = 2;
                  break;
                }
                throw new Error(`Backend name '${t}' not found in registry`);
              case 2:
                this.backendName = t;
                if (this.registry[t] != null) {
                  e.next = 16;
                  break;
                }
                this.backendInstance = null;
                n = this.initializeBackend(t);
                r = n.success;
                if (!n.asyncInit) {
                  e.next = 12;
                  break;
                }
                e.next = 9;
                return r;
              case 9:
                e.t0 = e.sent;
                e.next = 13;
                break;
              case 12:
                e.t0 = r;
              case 13:
                if (e.t0) {
                  e.next = 16;
                  break;
                }
                return e.abrupt("return", false);
              case 16:
                this.backendInstance = this.registry[t];
                this.setupRegisteredKernels();
                this.profiler = new j4(this.backendInstance);
                return e.abrupt("return", true);
              case 20:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return r.apply(this, arguments);
      })
    }, {
      key: "setupRegisteredKernels",
      value: function () {
        var e = this;
        V3(this.backendName).forEach(function (t) {
          if (t.setupFunc != null) {
            t.setupFunc(e.backendInstance);
          }
        });
      }
    }, {
      key: "disposeRegisteredKernels",
      value: function (e) {
        var t = this;
        V3(e).forEach(function (n) {
          if (n.disposeFunc != null) {
            n.disposeFunc(t.registry[e]);
          }
        });
      }
    }, {
      key: "initializeBackend",
      value: function (e) {
        var t = this;
        var n = this.registryFactory[e];
        if (n == null) {
          throw new Error(`Cannot initialize backend ${e}, no registration found.`);
        }
        try {
          var r = n.factory();
          if (!r || r instanceof T$ || typeof r.then != "function") {
            this.registry[e] = r;
            return {
              success: true,
              asyncInit: false
            };
          }
          var a = ++this.pendingBackendInitId;
          var i = r.then(function (n) {
            return !(a < t.pendingBackendInitId) && (t.registry[e] = n, t.pendingBackendInit = null, true);
          }).catch(function (n) {
            if (!(a < t.pendingBackendInitId)) {
              t.pendingBackendInit = null;
              z3(`Initialization of backend ${e} failed`);
              z3(n.stack || n.message);
            }
            return false;
          });
          this.pendingBackendInit = i;
          return {
            success: i,
            asyncInit: true
          };
        } catch (t) {
          z3(`Initialization of backend ${e} failed`);
          z3(t.stack || t.message);
          return {
            success: false,
            asyncInit: false
          };
        }
      }
    }, {
      key: "removeBackend",
      value: function (e) {
        if (!(e in this.registryFactory)) {
          throw new Error(`${e} backend not found in registry`);
        }
        if (this.backendName === e && this.pendingBackendInit != null) {
          this.pendingBackendInitId++;
        }
        if (e in this.registry) {
          this.disposeRegisteredKernels(e);
          this.registry[e].dispose();
          delete this.registry[e];
        }
        delete this.registryFactory[e];
        if (this.backendName === e) {
          this.pendingBackendInit = null;
          this.backendName = null;
          this.backendInstance = null;
        }
      }
    }, {
      key: "getSortedBackends",
      value: function () {
        var e = this;
        if (Object.keys(this.registryFactory).length === 0) {
          throw new Error("No backend found in registry.");
        }
        return Object.keys(this.registryFactory).sort(function (t, n) {
          return e.registryFactory[n].priority - e.registryFactory[t].priority;
        });
      }
    }, {
      key: "initializeBackendsAndReturnBest",
      value: function () {
        for (var e = this.getSortedBackends(), t = 0; t < e.length; t++) {
          var n = e[t];
          var r = this.initializeBackend(n);
          var a = r.success;
          var i = r.asyncInit;
          if (i || a) {
            return {
              name: n,
              asyncInit: i
            };
          }
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.");
      }
    }, {
      key: "moveData",
      value: function (e, t) {
        var n = this.state.tensorInfo.get(t);
        var r = n.backend;
        var a = this.readSync(t);
        var i = r.refCount(t);
        r.disposeData(t, true);
        n.backend = e;
        e.move(t, a, n.shape, n.dtype, i);
        if (this.shouldCheckForMemLeaks()) {
          this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
        }
      }
    }, {
      key: "tidy",
      value: function (e, t) {
        var n;
        var r = this;
        var a = null;
        if (t == null) {
          if (typeof e != "function") {
            throw new Error("Please provide a function to tidy()");
          }
          t = e;
        } else {
          if (typeof e != "string" && !(e instanceof String)) {
            throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
          }
          if (typeof t != "function") {
            throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
          }
          a = e;
        }
        return this.scopedRun(function () {
          return r.startScope(a);
        }, function () {
          return r.endScope(n);
        }, function () {
          if ((n = t()) instanceof Promise) {
            console.error("Cannot return a Promise inside of tidy.");
          }
          return n;
        });
      }
    }, {
      key: "scopedRun",
      value: function (e, t, n) {
        e();
        try {
          var r = n();
          t();
          return r;
        } catch (e) {
          t();
          throw e;
        }
      }
    }, {
      key: "nextTensorId",
      value: function () {
        return e.nextTensorId++;
      }
    }, {
      key: "nextVariableId",
      value: function () {
        return e.nextVariableId++;
      }
    }, {
      key: "clone",
      value: function (e) {
        var t = E5.runKernel(W1, {
          x: e
        });
        var n = {
          x: e
        };
        this.addTapeNode(this.state.activeScope.name, n, [t], function (e) {
          return {
            x: function () {
              var t = {
                x: e
              };
              var n = {
                dtype: "float32"
              };
              return E5.runKernel(X0, t, n);
            }
          };
        }, [], {});
        return t;
      }
    }, {
      key: "runKernel",
      value: function (e, t, n) {
        if (this.backendName == null) {
          this.backend;
        }
        if (W3(e, this.backendName) == null) {
          throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);
        }
        return this.runKernelFunc({
          kernelName: e,
          inputs: t,
          attrs: n
        });
      }
    }, {
      key: "shouldCheckForMemLeaks",
      value: function () {
        return this.ENV.getBool("IS_TEST");
      }
    }, {
      key: "checkKernelForMemLeak",
      value: function (e, t, n) {
        var r = this.backend.numDataIds();
        var a = 0;
        n.forEach(function (e) {
          a += e.dtype === "complex64" ? 3 : 1;
        });
        var i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
        var o = r - t - a - i;
        if (o > 0) {
          throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`);
        }
      }
    }, {
      key: "runKernelFunc",
      value: function (e) {
        var t;
        var n;
        var r;
        var a = this;
        var i = [];
        var o = this.isTapeOn();
        var s = this.state.numBytes;
        var u = this.state.numTensors;
        if (this.shouldCheckForMemLeaks()) {
          this.state.numDataMovesStack.push(0);
        }
        if (this.backendName == null) {
          this.backend;
        }
        var c = k5(e) ? e.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
        if (k5(e)) {
          var l = e.kernelName;
          var h = e.inputs;
          var p = e.attrs;
          if (this.backendName == null) {
            this.backend;
          }
          var f = W3(l, this.backendName);
          F$(f != null, function () {
            return `Cannot find registered kernel '${l}' for backend '${a.backendName}'`;
          });
          n = function () {
            var e = a.backend.numDataIds();
            r = f.kernelFunc({
              inputs: h,
              attrs: p,
              backend: a.backend
            });
            var t = Array.isArray(r) ? r : [r];
            if (a.shouldCheckForMemLeaks()) {
              a.checkKernelForMemLeak(l, e, t);
            }
            var n = t.map(function (e) {
              if (e.rank != null) {
                return e;
              } else {
                return a.makeTensorFromTensorInfo(e);
              }
            });
            if (o) {
              var s = a.getTensorsForGradient(l, h, n);
              i = a.saveTensorsForBackwardMode(s);
            }
            return n;
          };
        } else {
          var d = e.forwardFunc;
          function v(e) {
            if (o) {
              i = e.map(function (e) {
                return a.keep(a.clone(e));
              });
            }
          }
          n = function () {
            var e = a.backend.numDataIds();
            r = a.tidy(function () {
              return d(a.backend, v);
            });
            var t = Array.isArray(r) ? r : [r];
            if (a.shouldCheckForMemLeaks()) {
              a.checkKernelForMemLeak(c, e, t);
            }
            return t;
          };
        }
        var m;
        var g = e.inputs;
        var y = e.attrs;
        var b = k5(e) ? null : e.backwardsFunc;
        this.scopedRun(function () {
          return a.state.kernelDepth++;
        }, function () {
          return a.state.kernelDepth--;
        }, function () {
          if (a.ENV.getBool("DEBUG") || a.state.profiling) {
            m = a.profiler.profileKernel(c, g, function () {
              return n();
            });
            if (a.ENV.getBool("DEBUG")) {
              a.profiler.logKernelProfile(m);
            }
            t = m.outputs;
          } else {
            t = n();
          }
        });
        if (o) {
          this.addTapeNode(c, g, t, b, i, y);
        }
        if (this.state.profiling) {
          this.state.activeProfile.kernels.push({
            name: c,
            bytesAdded: this.state.numBytes - s,
            totalBytesSnapshot: this.state.numBytes,
            tensorsAdded: this.state.numTensors - u,
            totalTensorsSnapshot: this.state.numTensors,
            inputShapes: Object.keys(g).map(function (e) {
              if (g[e] != null) {
                return g[e].shape;
              } else {
                return null;
              }
            }),
            outputShapes: t.map(function (e) {
              return e.shape;
            }),
            kernelTimeMs: m.timeMs,
            extraInfo: m.extraInfo
          });
        }
        if (Array.isArray(r)) {
          return t;
        } else {
          return t[0];
        }
      }
    }, {
      key: "saveTensorsForBackwardMode",
      value: function (e) {
        var t = this;
        var n = e.map(function (e) {
          return t.keep(t.clone(e));
        });
        return n;
      }
    }, {
      key: "getTensorsForGradient",
      value: function (e, t, n) {
        var r = U3(e);
        if (r != null) {
          var a;
          var i = r.inputsToSave || [];
          var o = r.outputsToSave || [];
          if (r.saveAllInputs) {
            F$(Array.isArray(t), function () {
              return "saveAllInputs is true, expected inputs to be an array.";
            });
            a = Object.keys(t).map(function (e) {
              return t[e];
            });
          } else {
            a = i.map(function (e) {
              return t[e];
            });
          }
          var s = n.filter(function (e, t) {
            return o[t];
          });
          return a.concat(s);
        }
        return [];
      }
    }, {
      key: "makeTensor",
      value: function (e, t, n, r) {
        if (e == null) {
          throw new Error("Values passed to engine.makeTensor() are null");
        }
        n = n || "float32";
        r = r || this.backend;
        var a = e;
        if (n === "string" && $$(e[0])) {
          a = e.map(function (e) {
            return B4(e);
          });
        }
        var i = r.write(a, t, n);
        var o = new n5(t, n, i, this.nextTensorId());
        this.trackTensor(o, r);
        if (n === "string") {
          var s = this.state.tensorInfo.get(i);
          var u = Q$(a);
          this.state.numBytes += u - s.bytes;
          s.bytes = u;
        }
        return o;
      }
    }, {
      key: "makeTensorFromDataId",
      value: function (e, t, n, r) {
        var a = {
          dataId: e,
          shape: t,
          dtype: n = n || "float32"
        };
        return this.makeTensorFromTensorInfo(a, r);
      }
    }, {
      key: "makeTensorFromTensorInfo",
      value: function (e, t) {
        var n = e.dataId;
        var r = e.shape;
        var a = e.dtype;
        var i = new n5(r, a, n, this.nextTensorId());
        this.trackTensor(i, t);
        return i;
      }
    }, {
      key: "makeVariable",
      value: function (e) {
        var t = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
        var n = arguments.length > 2 ? arguments[2] : undefined;
        var r = arguments.length > 3 ? arguments[3] : undefined;
        n = n || this.nextVariableId().toString();
        if (r != null && r !== e.dtype) {
          e = e.cast(r);
        }
        var a = new c5(e, t, n, this.nextTensorId());
        if (this.state.registeredVariables[a.name] != null) {
          throw new Error(`Variable with name ${a.name} was already registered`);
        }
        this.state.registeredVariables[a.name] = a;
        this.incRef(a, this.backend);
        return a;
      }
    }, {
      key: "trackTensor",
      value: function (e, t) {
        this.state.numTensors++;
        if (e.dtype === "string") {
          this.state.numStringTensors++;
        }
        var n = 0;
        if (e.dtype !== "complex64" && e.dtype !== "string") {
          n = e.size * Z$(e.dtype);
        }
        this.state.numBytes += n;
        if (!this.state.tensorInfo.has(e.dataId)) {
          this.state.numDataBuffers++;
          this.state.tensorInfo.set(e.dataId, {
            backend: t || this.backend,
            dtype: e.dtype,
            shape: e.shape,
            bytes: n
          });
        }
        if (!(e instanceof c5)) {
          this.track(e);
        }
      }
    }, {
      key: "incRef",
      value: function (e, t) {
        this.trackTensor(e, t);
        this.backend.incRef(e.dataId);
      }
    }, {
      key: "removeDataId",
      value: function (e, t) {
        if (this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t) {
          this.state.tensorInfo.delete(e);
          this.state.numDataBuffers--;
        }
      }
    }, {
      key: "disposeTensor",
      value: function (e) {
        if (this.state.tensorInfo.has(e.dataId)) {
          var t = this.state.tensorInfo.get(e.dataId);
          this.state.numTensors--;
          if (e.dtype === "string") {
            this.state.numStringTensors--;
            this.state.numBytes -= t.bytes;
          }
          if (e.dtype !== "complex64" && e.dtype !== "string") {
            var n = e.size * Z$(e.dtype);
            this.state.numBytes -= n;
          }
          if (t.backend.disposeData(e.dataId)) {
            this.removeDataId(e.dataId, t.backend);
          }
        }
      }
    }, {
      key: "disposeVariables",
      value: function () {
        for (var e in this.state.registeredVariables) {
          var t = this.state.registeredVariables[e];
          this.disposeVariable(t);
        }
      }
    }, {
      key: "disposeVariable",
      value: function (e) {
        this.disposeTensor(e);
        if (this.state.registeredVariables[e.name] != null) {
          delete this.state.registeredVariables[e.name];
        }
      }
    }, {
      key: "memory",
      value: function () {
        var e = this.backend.memory();
        e.numTensors = this.state.numTensors;
        e.numDataBuffers = this.state.numDataBuffers;
        e.numBytes = this.state.numBytes;
        if (this.state.numStringTensors > 0) {
          e.unreliable = true;
          if (e.reasons == null) {
            e.reasons = [];
          }
          e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
        }
        return e;
      }
    }, {
      key: "profile",
      value: (n = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        var i;
        var s;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.state.profiling = true;
                n = this.state.numBytes;
                r = this.state.numTensors;
                this.state.activeProfile.kernels = [];
                e.next = 6;
                return t();
              case 6:
                this.state.activeProfile.result = e.sent;
                this.state.profiling = false;
                this.state.activeProfile.peakBytes = Math.max.apply(Math, T(this.state.activeProfile.kernels.map(function (e) {
                  return e.totalBytesSnapshot;
                })));
                this.state.activeProfile.newBytes = this.state.numBytes - n;
                this.state.activeProfile.newTensors = this.state.numTensors - r;
                a = O(this.state.activeProfile.kernels);
                e.prev = 12;
                a.s();
              case 14:
                if ((i = a.n()).done) {
                  e.next = 24;
                  break;
                }
                s = i.value;
                e.next = 18;
                return s.kernelTimeMs;
              case 18:
                s.kernelTimeMs = e.sent;
                e.next = 21;
                return s.extraInfo;
              case 21:
                s.extraInfo = e.sent;
              case 22:
                e.next = 14;
                break;
              case 24:
                e.next = 29;
                break;
              case 26:
                e.prev = 26;
                e.t0 = e.catch(12);
                a.e(e.t0);
              case 29:
                e.prev = 29;
                a.f();
                return e.finish(29);
              case 32:
                return e.abrupt("return", this.state.activeProfile);
              case 33:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[12, 26, 29, 32]]);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "isTapeOn",
      value: function () {
        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
      }
    }, {
      key: "addTapeNode",
      value: function (e, t, n, r, a, i) {
        var o = this;
        var s = {
          id: this.state.nextTapeNodeId++,
          kernelName: e,
          inputs: t,
          outputs: n,
          saved: a
        };
        var u = U3(e);
        if (u != null) {
          r = u.gradFunc;
        }
        if (r != null) {
          s.gradient = function (e) {
            e = e.map(function (e, t) {
              if (e == null) {
                var r = n[t];
                var a = l0(r.size, r.dtype);
                return o.makeTensor(a, r.shape, r.dtype);
              }
              return e;
            });
            return r(e.length > 1 ? e : e[0], a, i);
          };
        }
        this.state.activeTape.push(s);
      }
    }, {
      key: "keep",
      value: function (e) {
        e.kept = true;
        return e;
      }
    }, {
      key: "startTape",
      value: function () {
        if (this.state.gradientDepth === 0) {
          this.state.activeTape = [];
        }
        this.state.gradientDepth++;
      }
    }, {
      key: "endTape",
      value: function () {
        this.state.gradientDepth--;
      }
    }, {
      key: "startScope",
      value: function (e) {
        var t = {
          track: [],
          name: "unnamed scope",
          id: this.state.nextScopeId++
        };
        if (e) {
          t.name = e;
        }
        this.state.scopeStack.push(t);
        this.state.activeScope = t;
      }
    }, {
      key: "endScope",
      value: function (e) {
        var t = this;
        var n = y5(e);
        var r = new Set(n.map(function (e) {
          return e.id;
        }));
        for (var a = 0; a < this.state.activeScope.track.length; a++) {
          var i = this.state.activeScope.track[a];
          if (!i.kept && !r.has(i.id)) {
            i.dispose();
          }
        }
        var o = this.state.scopeStack.pop();
        this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
        n.forEach(function (e) {
          if (!e.kept && e.scopeId === o.id) {
            t.track(e);
          }
        });
      }
    }, {
      key: "gradients",
      value: function (e, t, n) {
        var r = this;
        var a = arguments.length > 3 && arguments[3] !== undefined && arguments[3];
        F$(t.length > 0, function () {
          return "gradients() received an empty list of xs.";
        });
        if (n != null && n.dtype !== "float32") {
          throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);
        }
        var i = this.scopedRun(function () {
          return r.startTape();
        }, function () {
          return r.endTape();
        }, function () {
          return r.tidy("forward", e);
        });
        F$(i instanceof n5, function () {
          return "The result y returned by f() must be a tensor.";
        });
        var o = q4(this.state.activeTape, t, i);
        if (!a && o.length === 0 && t.length > 0) {
          throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        }
        return this.tidy("backward", function () {
          var e = {};
          e[i.id] = n == null ? N5(i.shape) : n;
          K4(e, o, function (e) {
            return r.tidy(e);
          }, C5);
          var a = t.map(function (t) {
            return e[t.id];
          });
          if (r.state.gradientDepth === 0) {
            r.state.activeTape.forEach(function (e) {
              var t;
              var n = O(e.saved);
              try {
                for (n.s(); !(t = n.n()).done;) {
                  t.value.dispose();
                }
              } catch (e) {
                n.e(e);
              } finally {
                n.f();
              }
            });
            r.state.activeTape = null;
          }
          return {
            value: i,
            grads: a
          };
        });
      }
    }, {
      key: "customGrad",
      value: function (e) {
        var t = this;
        F$(r0(e), function () {
          return "The f passed in customGrad(f) must be a function.";
        });
        return function () {
          for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++) {
            r[a] = arguments[a];
          }
          var i;
          F$(r.every(function (e) {
            return e instanceof n5;
          }), function () {
            return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
          });
          var o = {};
          r.forEach(function (e, t) {
            o[t] = e;
          });
          function s(t, n) {
            F$((i = e.apply(undefined, [].concat(r, [n]))).value instanceof n5, function () {
              return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
            });
            F$(r0(i.gradFunc), function () {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
            });
            return i.value;
          }
          function u(e, t) {
            var n = i.gradFunc(e, t);
            var a = Array.isArray(n) ? n : [n];
            F$(a.length === r.length, function () {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
            });
            F$(a.every(function (e) {
              return e instanceof n5;
            }), function () {
              return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
            });
            var o = {};
            a.forEach(function (e, t) {
              o[t] = function () {
                return e;
              };
            });
            return o;
          }
          return t.runKernelFunc({
            forwardFunc: s,
            backwardsFunc: u,
            inputs: o
          });
        };
      }
    }, {
      key: "readSync",
      value: function (e) {
        return this.state.tensorInfo.get(e).backend.readSync(e);
      }
    }, {
      key: "read",
      value: function (e) {
        return this.state.tensorInfo.get(e).backend.read(e);
      }
    }, {
      key: "readToGPU",
      value: function (e, t) {
        return this.state.tensorInfo.get(e).backend.readToGPU(e, t);
      }
    }, {
      key: "time",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                n = z4();
                e.next = 3;
                return this.backend.time(t);
              case 3:
                (r = e.sent).wallMs = z4() - n;
                return e.abrupt("return", r);
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "track",
      value: function (e) {
        if (this.state.activeScope != null) {
          e.scopeId = this.state.activeScope.id;
          this.state.activeScope.track.push(e);
        }
        return e;
      }
    }, {
      key: "registeredVariables",
      get: function () {
        return this.state.registeredVariables;
      }
    }, {
      key: "reset",
      value: function () {
        this.pendingBackendInitId++;
        this.state.dispose();
        this.ENV.reset();
        this.state = new w5();
        for (var e in this.registry) {
          this.disposeRegisteredKernels(e);
          this.registry[e].dispose();
          delete this.registry[e];
        }
        this.backendName = null;
        this.backendInstance = null;
        this.pendingBackendInit = null;
      }
    }]);
    return e;
  }();
  function N5(e) {
    var t = c0(L$(e), "float32");
    return E5.makeTensor(t, e, "float32");
  }
  function S5() {
    var t = w0();
    if (t._tfengine == null) {
      var n = new y0(t);
      t._tfengine = new I5(n);
    }
    (function (t) {
      e.ENV = t;
    })(t._tfengine.ENV);
    e5 = function () {
      return t._tfengine;
    };
    return t._tfengine;
  }
  I5.nextTensorId = 0;
  I5.nextVariableId = 0;
  var T5;
  var E5 = S5();
  function C5(e, t) {
    var n = {
      a: e,
      b: t
    };
    return E5.runKernel(E0, n);
  }
  function A5(e) {
    if (T5 !== undefined) {
      return T5;
    }
    if (e || typeof navigator != "undefined" && navigator != null) {
      e ||= navigator;
      if (e.product === "ReactNative") {
        return true;
      }
      var t = e.userAgent || e.vendor || (typeof window != "undefined" ? window.opera : "");
      if (!t) {
        var n = e;
        return n.userAgentData && n.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4));
    }
    return false;
  }
  function R5() {
    return typeof window != "undefined" && window.document != null || typeof WorkerGlobalScope != "undefined";
  }
  var _5 = {
    __proto__: null,
    isBrowser: R5,
    isMobile: A5,
    mockIsMobile: function (e) {
      T5 = e;
    }
  };
  var O5 = k0();
  function F5(e, t) {
    var n = e;
    if (U4(e)) {
      if (t === "string") {
        return [];
      } else {
        return [e.length];
      }
    }
    if (f5(e)) {
      var r = e.channels || "RGBA";
      return [e.height, e.width * r.length];
    }
    if (d5(e)) {
      return [e.buffer.size / (t == null ? 4 : Z$(t))];
    }
    if (!Array.isArray(e)) {
      return [];
    }
    var a = [];
    while (Array.isArray(n) || U4(n) && t !== "string") {
      a.push(n.length);
      n = n[0];
    }
    if (Array.isArray(e) && k0().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
      D5(e, a, []);
    }
    return a;
  }
  function D5(e, t, n) {
    n = n || [];
    if (Array.isArray(e) || U4(e)) {
      F$(t.length > 0, function () {
        return `Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`;
      });
      F$(e.length === t[0], function () {
        return `Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`;
      });
      var r = t.slice(1);
      for (var a = 0; a < e.length; ++a) {
        D5(e[a], r, n.concat(a));
      }
    } else {
      F$(t.length === 0, function () {
        return `Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`;
      });
    }
  }
  function M5(e, t, n, r) {
    if (e !== "string_or_numeric") {
      if (e == null) {
        throw new Error("Expected dtype cannot be null.");
      }
      if (e !== "numeric" && e !== t || e === "numeric" && t === "string") {
        throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`);
      }
    }
  }
  function L5(e, t, n, r = "numeric") {
    if (e instanceof r5()) {
      M5(r, e.dtype, t, n);
      return e;
    }
    var a = n0(e);
    if (a !== "string" && ["bool", "int32", "float32"].indexOf(r) >= 0) {
      a = r;
    }
    M5(r, a, t, n);
    if (e == null || !U4(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string") {
      var i = e == null ? "null" : e.constructor.name;
      throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${i}'`);
    }
    var o = F5(e, a);
    if (!U4(e) && !Array.isArray(e)) {
      e = [e];
    }
    var s = true;
    var u = a !== "string" ? L4(e, a) : V4(e, [], s);
    return E5.makeTensor(u, o, a);
  }
  function z5(e, t, n, r = "numeric") {
    if (!Array.isArray(e)) {
      throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);
    }
    var a = e;
    return a.map(function (e, a) {
      return L5(e, `${t}[${a}]`, n, r);
    });
  }
  O5.registerFlag("DEBUG", function () {
    return false;
  }, function (e) {
    if (e) {
      console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
    }
  });
  O5.registerFlag("IS_BROWSER", function () {
    return R5();
  });
  O5.registerFlag("IS_NODE", function () {
    return typeof process != "undefined" && process.versions !== undefined && process.versions.node !== undefined;
  });
  O5.registerFlag("IS_CHROME", function () {
    return typeof navigator != "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  });
  O5.registerFlag("IS_SAFARI", function () {
    return typeof navigator != "undefined" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor);
  });
  O5.registerFlag("PROD", function () {
    return false;
  });
  O5.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
    return O5.getBool("DEBUG");
  });
  O5.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
    return true;
  });
  O5.registerFlag("IS_TEST", function () {
    return false;
  });
  O5.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", function () {
    return O5.getBool("DEBUG");
  });
  O5.registerFlag("WRAP_TO_IMAGEBITMAP", function () {
    return false;
  });
  O5.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", function () {
    return false;
  });
  O5.registerFlag("USE_SETTIMEOUTCUSTOM", function () {
    return false;
  });
  var P5 = "__op";
  function B5(e) {
    var t = Object.keys(e);
    if (t.length !== 1) {
      throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
    }
    var n = t[0];
    var r = e[n];
    if (n.endsWith("_")) {
      n = n.substring(0, n.length - 1);
    }
    n += P5;
    function a() {
      E5.startScope(n);
      try {
        var e = r.apply(undefined, arguments);
        if (v0(e)) {
          console.error("Cannot return a Promise inside of tidy.");
        }
        E5.endScope(e);
        return e;
      } catch (e) {
        E5.endScope(null);
        throw e;
      }
    }
    Object.defineProperty(a, "name", {
      value: n,
      configurable: true
    });
    return a;
  }
  var W5 = B5({
    complex_: function (e, t) {
      var n = L5(e, "real", "complex");
      var r = L5(t, "imag", "complex");
      D$(n.shape, r.shape, `real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);
      var a = {
        real: n,
        imag: r
      };
      return E5.runKernel(Z0, a);
    }
  });
  function U5(e, t, n, r) {
    if (r == null) {
      r = n0(e);
    } else if (r === "complex64") {
      throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    }
    if (d5(e) || f5(e)) {
      if (r !== "float32" && r !== "int32") {
        throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);
      }
      return E5.backend.createTensorFromGPUData(e, t || n, r);
    }
    if (!U4(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string") {
      throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    }
    if (t != null) {
      p0(t);
      var a = L$(t);
      var i = L$(n);
      F$(a === i, function () {
        return `Based on the provided shape, [${t}], the tensor should have ${a} values but has ${i}`;
      });
      for (var o = 0; o < n.length; ++o) {
        var s = n[o];
        var u = o !== n.length - 1 || s !== L$(t.slice(o));
        F$(n[o] === t[o] || !u, function () {
          return `Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `;
        });
      }
    }
    if (!U4(e) && !Array.isArray(e)) {
      e = [e];
    }
    t = t || n;
    e = r !== "string" ? L4(e, r) : V4(e, [], true);
    return E5.makeTensor(e, t, r);
  }
  function V5(e, t, n) {
    return U5(e, t, F5(e, n), n);
  }
  var G5 = {
    float32: 4,
    float16: 2,
    int32: 4,
    uint16: 2,
    uint8: 1,
    bool: 1,
    complex64: 8
  };
  var j5 = function () {
    function e(t) {
      l(this, e);
      this.shards = [];
      this.previousShardIndex = 0;
      if (t != null && (t instanceof Array || (t = [t]), (t = t.map(function (e) {
        if (U4(e)) {
          return e.buffer;
        } else {
          return e;
        }
      })).length !== 0)) {
        this.bufferUniformSize = t[0].byteLength;
        var n = 0;
        for (var r = 0; r < t.length; r++) {
          var a = t[r];
          if (r !== t.length - 1 && a.byteLength !== this.bufferUniformSize) {
            this.bufferUniformSize = undefined;
          }
          var i = n + a.byteLength;
          this.shards.push({
            buffer: a,
            start: n,
            end: i
          });
          n = i;
        }
        if (this.shards.length === 0) {
          this.byteLength = 0;
        }
        this.byteLength = this.shards[this.shards.length - 1].end;
      }
    }
    p(e, [{
      key: "slice",
      value: function (e = 0, t = this.byteLength) {
        if (this.shards.length === 0) {
          return new ArrayBuffer(0);
        }
        e = isNaN(Number(e)) ? 0 : e;
        t = isNaN(Number(t)) ? 0 : t;
        e = Math.max(0, e);
        if ((t = Math.min(this.byteLength, t)) <= e) {
          return new ArrayBuffer(0);
        }
        var n = this.findShardForByte(e);
        if (n === -1) {
          throw new Error(`Could not find start shard for byte ${e}`);
        }
        var r = t - e;
        var a = new ArrayBuffer(r);
        var i = new Uint8Array(a);
        var o = 0;
        for (var s = n; s < this.shards.length; s++) {
          var u = this.shards[s];
          var c = e + o;
          var l = c - u.start;
          var h = o;
          var p = Math.min(t, u.end);
          var f = p - u.start;
          var d = new Uint8Array(u.buffer, l, f - l);
          i.set(d, h);
          o += d.length;
          if (t < u.end) {
            break;
          }
        }
        return a;
      }
    }, {
      key: "findShardForByte",
      value: function (e) {
        if (this.shards.length === 0 || e < 0 || e >= this.byteLength) {
          return -1;
        }
        if (this.bufferUniformSize != null) {
          this.previousShardIndex = Math.floor(e / this.bufferUniformSize);
          return this.previousShardIndex;
        }
        function t(t) {
          if (e < t.start) {
            return -1;
          } else if (e >= t.end) {
            return 1;
          } else {
            return 0;
          }
        }
        if (t(this.shards[this.previousShardIndex]) === 0) {
          return this.previousShardIndex;
        }
        var n = function (e, t) {
          var n = 0;
          var r = e.length;
          while (n <= r) {
            var a = Math.floor((r - n) / 2) + n;
            var i = t(e[a]);
            if (i === 0) {
              return a;
            }
            if (i < 0) {
              r = a;
            } else {
              n = a + 1;
            }
          }
          return -1;
        }(this.shards, t);
        if (n === -1) {
          return -1;
        } else {
          this.previousShardIndex = n;
          return this.previousShardIndex;
        }
      }
    }], [{
      key: "join",
      value: function (t) {
        return new e(t).slice();
      }
    }]);
    return e;
  }();
  function H5(e) {
    if (k0().getBool("DEPRECATION_WARNINGS_ENABLED")) {
      console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
    }
  }
  function q5() {
    return E5;
  }
  function K5() {
    return E5.memory();
  }
  function X5(e, t) {
    return E5.tidy(e, t);
  }
  function Y5(e) {
    y5(e).forEach(function (e) {
      return e.dispose();
    });
  }
  function J5(e) {
    return E5.keep(e);
  }
  function Z5(e) {
    return E5.setBackend(e);
  }
  function Q5() {
    return E5.backendName;
  }
  function $5(e, t, n = 1) {
    return E5.registerBackend(e, t, n);
  }
  function e6() {
    return E5.backend;
  }
  function t6(e, t) {
    return n6.apply(this, arguments);
  }
  function n6() {
    n6 = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var l;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = [];
              a = [];
              i = Array.isArray(t) ? t.map(function (e) {
                return e.name;
              }) : Object.keys(t);
              s = o().mark(function e() {
                var s;
                var l;
                var h;
                var p;
                return o().wrap(function (e) {
                  while (true) {
                    switch (e.prev = e.next) {
                      case 0:
                        s = i[u];
                        if ((l = Array.isArray(t) ? t[u].tensor : t[s]).dtype === "float32" || l.dtype === "int32" || l.dtype === "bool" || l.dtype === "string" || l.dtype === "complex64") {
                          e.next = 4;
                          break;
                        }
                        throw new Error(`Unsupported dtype in weight '${s}': ${l.dtype}`);
                      case 4:
                        h = {
                          name: s,
                          shape: l.shape,
                          dtype: l.dtype
                        };
                        if (l.dtype === "string") {
                          p = new Promise(function () {
                            var e = c(o().mark(function e(t) {
                              var n;
                              var r;
                              var a;
                              var i;
                              var s;
                              var u;
                              var c;
                              return o().wrap(function (e) {
                                while (true) {
                                  switch (e.prev = e.next) {
                                    case 0:
                                      e.next = 2;
                                      return l.bytes();
                                    case 2:
                                      n = e.sent;
                                      r = n.reduce(function (e, t) {
                                        return e + t.length;
                                      }, 0) + n.length * 4;
                                      a = new Uint8Array(r);
                                      i = 0;
                                      s = 0;
                                      for (; s < n.length; s++) {
                                        u = n[s];
                                        c = new Uint8Array(new Uint32Array([u.length]).buffer);
                                        a.set(c, i);
                                        i += 4;
                                        a.set(u, i);
                                        i += u.length;
                                      }
                                      t(a);
                                    case 8:
                                    case "end":
                                      return e.stop();
                                  }
                                }
                              }, e);
                            }));
                            return function (t) {
                              return e.apply(this, arguments);
                            };
                          }());
                          a.push(p);
                        } else {
                          a.push(l.data());
                        }
                        if (n != null) {
                          h.group = n;
                        }
                        r.push(h);
                      case 8:
                      case "end":
                        return e.stop();
                    }
                  }
                }, e);
              });
              u = 0;
            case 5:
              if (!(u < i.length)) {
                e.next = 10;
                break;
              }
              return e.delegateYield(s(), "t0", 7);
            case 7:
              ++u;
              e.next = 5;
              break;
            case 10:
              e.next = 12;
              return Promise.all(a);
            case 12:
              l = e.sent;
              return e.abrupt("return", {
                data: p6(l),
                specs: r
              });
            case 14:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return n6.apply(this, arguments);
  }
  function r6(e, t) {
    var n;
    var r = new j5(e);
    var a = {};
    var i = 0;
    var o = O(t);
    try {
      for (o.s(); !(n = o.n()).done;) {
        var s = n.value;
        var u = a6(s, function (e, t) {
          return r.slice(i + e, i + t);
        });
        a[s.name] = s6(s, r.slice(i, i + u));
        i += u;
      }
    } catch (e) {
      o.e(e);
    } finally {
      o.f();
    }
    return a;
  }
  function a6(e, t) {
    var n;
    var r = L$(e.shape);
    if ("quantization" in e) {
      var a = e.quantization;
      n = G5[a.dtype];
    } else {
      if (e.dtype === "string") {
        var i = 0;
        for (var o = 0; o < r; o++) {
          i += 4 + new Uint32Array(t(i, i + 4))[0];
        }
        return i;
      }
      n = G5[e.dtype];
    }
    return r * n;
  }
  function i6(e, t) {
    return o6.apply(this, arguments);
  }
  function o6() {
    o6 = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = L$(t.shape);
              if (!("quantization" in t)) {
                e.next = 6;
                break;
              }
              i = t.quantization;
              a = G5[i.dtype];
              e.next = 25;
              break;
            case 6:
              if (t.dtype !== "string") {
                e.next = 24;
                break;
              }
              s = 0;
              u = 0;
            case 9:
              if (!(u < r)) {
                e.next = 21;
                break;
              }
              e.t0 = s;
              e.t1 = 4;
              e.t2 = Uint32Array;
              e.next = 15;
              return n(s, s + 4);
            case 15:
              e.t3 = e.sent;
              e.t4 = new e.t2(e.t3)[0];
              s = e.t0 += e.t1 + e.t4;
            case 18:
              u++;
              e.next = 9;
              break;
            case 21:
              return e.abrupt("return", s);
            case 24:
              a = G5[t.dtype];
            case 25:
              return e.abrupt("return", r * a);
            case 26:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return o6.apply(this, arguments);
  }
  function s6(e, t) {
    var n;
    var r;
    var a;
    var i;
    var o = e.name;
    var s = e.dtype;
    var u = e.shape;
    var c = L$(u);
    var l = 0;
    if ("quantization" in e) {
      var h = e.quantization;
      if (h.dtype === "uint8" || h.dtype === "uint16") {
        if (!("min" in h) || !("scale" in h)) {
          throw new Error(`Weight ${e.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`);
        }
      } else {
        if (h.dtype !== "float16") {
          throw new Error(`Weight ${e.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
        }
        if (s !== "float32") {
          throw new Error(`Weight ${e.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${s}.`);
        }
      }
      var p = G5[h.dtype];
      var f = h.dtype === "uint8" ? new Uint8Array(t) : new Uint16Array(t);
      if (s === "float32") {
        if (h.dtype === "uint8" || h.dtype === "uint16") {
          n = new Float32Array(f.length);
          for (var d = 0; d < f.length; d++) {
            var v = f[d];
            n[d] = v * h.scale + h.min;
          }
        } else {
          if (h.dtype !== "float16") {
            throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);
          }
          r = function () {
            function e(e) {
              for (var t = e << 13, n = 0; (t & 8388608) == 0;) {
                n -= 8388608;
                t <<= 1;
              }
              return (t &= -8388609) | (n += 947912704);
            }
            var t = new Uint32Array(2048);
            t[0] = 0;
            for (var n = 1; n < 1024; n++) {
              t[n] = e(n);
            }
            for (var r = 1024; r < 2048; r++) {
              t[r] = 939524096 + (r - 1024 << 13);
            }
            return t;
          }();
          a = function () {
            var e = new Uint32Array(64);
            e[0] = 0;
            e[31] = 1199570944;
            e[32] = 2147483648;
            e[63] = 3347054592;
            for (var t = 1; t < 31; t++) {
              e[t] = t << 23;
            }
            for (var n = 33; n < 63; n++) {
              e[n] = 2147483648 + (n - 32 << 23);
            }
            return e;
          }();
          i = function () {
            var e = new Uint32Array(64);
            for (var t = 0; t < 64; t++) {
              e[t] = 1024;
            }
            e[0] = e[32] = 0;
            return e;
          }();
          function m(e) {
            var t = new ArrayBuffer(e.length * 4);
            var n = new Uint32Array(t);
            for (var o = 0; o < e.length; o++) {
              var s = e[o];
              var u = r[i[s >> 10] + (s & 1023)] + a[s >> 10];
              n[o] = u;
            }
            return new Float32Array(t);
          }
          n = m(f);
        }
      } else {
        if (s !== "int32") {
          throw new Error(`Unsupported dtype in weight '${o}': ${s}`);
        }
        if (h.dtype !== "uint8" && h.dtype !== "uint16") {
          throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);
        }
        n = new Int32Array(f.length);
        for (var g = 0; g < f.length; g++) {
          var y = f[g];
          n[g] = Math.round(y * h.scale + h.min);
        }
      }
      l += c * p;
    } else if (s === "string") {
      var b = L$(e.shape);
      n = [];
      for (var x = 0; x < b; x++) {
        var k = new Uint32Array(t.slice(l, l + 4))[0];
        l += 4;
        var w = new Uint8Array(t.slice(l, l + k));
        n.push(w);
        l += k;
      }
    } else {
      var I = G5[s];
      if (s === "float32") {
        n = new Float32Array(t);
      } else if (s === "int32") {
        n = new Int32Array(t);
      } else {
        if (s !== "bool") {
          if (s === "complex64") {
            n = new Float32Array(t);
            for (var N = new Float32Array(n.length / 2), S = new Float32Array(n.length / 2), T = 0; T < N.length; T++) {
              N[T] = n[T * 2];
              S[T] = n[T * 2 + 1];
            }
            var E = V5(N, u, "float32");
            var C = V5(S, u, "float32");
            var A = W5(E, C);
            E.dispose();
            C.dispose();
            return A;
          }
          throw new Error(`Unsupported dtype in weight '${o}': ${s}`);
        }
        n = new Uint8Array(t);
      }
      l += c * I;
    }
    return V5(n, u, s);
  }
  function u6(e, t, n) {
    return c6.apply(this, arguments);
  }
  function c6() {
    c6 = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              a = new Uint8Array(n);
            case 1:
              if (!(a.byteLength < r)) {
                e.next = 16;
                break;
              }
              e.next = 4;
              return t.read();
            case 4:
              i = e.sent;
              s = i.done;
              u = i.value;
              if (!s || u != null) {
                e.next = 10;
                break;
              }
              c = r - a.byteLength;
              throw new Error(`Reader is done but ${c} bytes are still expected`);
            case 10:
              (l = new Uint8Array(a.length + u.byteLength)).set(a, 0);
              l.set(new Uint8Array(u), a.length);
              a = l;
              e.next = 1;
              break;
            case 16:
              return e.abrupt("return", a.buffer);
            case 17:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return c6.apply(this, arguments);
  }
  function l6(e, t) {
    return h6.apply(this, arguments);
  }
  function h6() {
    h6 = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var l;
      var h;
      var p;
      var f;
      var d;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = {};
              a = t.getReader();
              i = new ArrayBuffer(0);
              s = O(n);
              e.prev = 4;
              s.s();
            case 6:
              if ((u = s.n()).done) {
                e.next = 21;
                break;
              }
              l = u.value;
              e.next = 10;
              return i6(l, function () {
                var e = c(o().mark(function e(t, n) {
                  return o().wrap(function (e) {
                    while (true) {
                      switch (e.prev = e.next) {
                        case 0:
                          e.next = 2;
                          return u6(a, i, n);
                        case 2:
                          i = e.sent;
                          return e.abrupt("return", i.slice(t, n));
                        case 4:
                        case "end":
                          return e.stop();
                      }
                    }
                  }, e);
                }));
                return function (t, n) {
                  return e.apply(this, arguments);
                };
              }());
            case 10:
              h = e.sent;
              e.next = 13;
              return u6(a, i, h);
            case 13:
              i = e.sent;
              p = i.slice(0, h);
              i = i.slice(h);
              f = s6(l, p);
              r[l.name] = f;
              if (Q5() === "webgpu" && "uploadToGPU" in (d = e6()) && L$(f.shape) >= k0().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")) {
                d.uploadToGPU(f.dataId);
              }
            case 19:
              e.next = 6;
              break;
            case 21:
              e.next = 26;
              break;
            case 23:
              e.prev = 23;
              e.t0 = e.catch(4);
              s.e(e.t0);
            case 26:
              e.prev = 26;
              s.f();
              return e.finish(26);
            case 29:
              return e.abrupt("return", r);
            case 30:
            case "end":
              return e.stop();
          }
        }
      }, e, null, [[4, 23, 26, 29]]);
    }));
    return h6.apply(this, arguments);
  }
  function p6(e) {
    if (e === null) {
      throw new Error(`Invalid input value: ${JSON.stringify(e)}`);
    }
    var t = 0;
    var n = [];
    e.forEach(function (e) {
      t += e.byteLength;
      n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e));
      if (!(e instanceof Float32Array) && !(e instanceof Int32Array) && !(e instanceof Uint8Array)) {
        throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`);
      }
    });
    var r = new Uint8Array(t);
    var a = 0;
    n.forEach(function (e) {
      r.set(new Uint8Array(e.buffer), a);
      a += e.byteLength;
    });
    return r.buffer;
  }
  var f6 = typeof Buffer != "undefined" && (typeof Blob == "undefined" || typeof atob == "undefined" || typeof btoa == "undefined");
  function d6(e) {
    if (f6) {
      return Buffer.byteLength(e, "utf8");
    } else {
      return new Blob([e]).size;
    }
  }
  function v6(e) {
    if (f6) {
      return Buffer.from(e).toString("base64");
    }
    var t = new Uint8Array(e);
    var n = "";
    for (var r = 0, a = t.length; r < a; r++) {
      n += String.fromCharCode(t[r]);
    }
    return btoa(n);
  }
  function m6(e) {
    if (f6) {
      var t = Buffer.from(e, "base64");
      return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
    }
    for (var n = atob(e), r = new Uint8Array(n.length), a = 0; a < n.length; ++a) {
      r.set([n.charCodeAt(a)], a);
    }
    return r.buffer;
  }
  function g6(e) {
    return j5.join(e);
  }
  function y6(e) {
    for (e = e.trim(); e.endsWith("/");) {
      e = e.slice(0, e.length - 1);
    }
    var t = e.split("/");
    return t[t.length - 1];
  }
  function b6(e, t) {
    var n = {
      modelTopology: e.modelTopology,
      format: e.format,
      generatedBy: e.generatedBy,
      convertedBy: e.convertedBy,
      weightsManifest: t
    };
    if (e.signature != null) {
      n.signature = e.signature;
    }
    if (e.userDefinedMetadata != null) {
      n.userDefinedMetadata = e.userDefinedMetadata;
    }
    if (e.modelInitializer != null) {
      n.modelInitializer = e.modelInitializer;
    }
    if (e.initializerSignature != null) {
      n.initializerSignature = e.initializerSignature;
    }
    if (e.trainingConfig != null) {
      n.trainingConfig = e.trainingConfig;
    }
    return n;
  }
  function x6(e, t, n) {
    var r = {
      modelTopology: e.modelTopology,
      format: e.format,
      generatedBy: e.generatedBy,
      convertedBy: e.convertedBy
    };
    if (e.trainingConfig != null) {
      r.trainingConfig = e.trainingConfig;
    }
    if (e.weightsManifest != null) {
      if (!t) {
        throw new Error("modelJSON has weightsManifest but weightSpecs is null");
      }
      if (!n) {
        throw new Error("modelJSON has weightsManifest but weightData is null");
      }
      r.weightSpecs = t;
      r.weightData = n;
    }
    if (e.signature != null) {
      r.signature = e.signature;
    }
    if (e.userDefinedMetadata != null) {
      r.userDefinedMetadata = e.userDefinedMetadata;
    }
    if (e.modelInitializer != null) {
      r.modelInitializer = e.modelInitializer;
    }
    if (e.initializerSignature != null) {
      r.initializerSignature = e.initializerSignature;
    }
    return r;
  }
  function k6(e, t) {
    return w6.apply(this, arguments);
  }
  function w6() {
    w6 = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              if (t.weightsManifest == null) {
                e.next = 7;
                break;
              }
              e.next = 3;
              return n(t.weightsManifest);
            case 3:
              i = e.sent;
              s = S(i, 2);
              r = s[0];
              a = s[1];
            case 7:
              return e.abrupt("return", x6(t, r, a));
            case 8:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return w6.apply(this, arguments);
  }
  function I6(e) {
    if (e.modelTopology instanceof ArrayBuffer) {
      throw new Error("Expected JSON model topology, received ArrayBuffer.");
    }
    return {
      dateSaved: new Date(),
      modelTopologyType: "JSON",
      modelTopologyBytes: e.modelTopology == null ? 0 : d6(JSON.stringify(e.modelTopology)),
      weightSpecsBytes: e.weightSpecs == null ? 0 : d6(JSON.stringify(e.weightSpecs)),
      weightDataBytes: e.weightData == null ? 0 : new j5(e.weightData).byteLength
    };
  }
  function N6(e) {
    var t;
    var n = [];
    var r = O(e);
    try {
      for (r.s(); !(t = r.n()).done;) {
        var a = t.value;
        n.push.apply(n, T(a.weights));
      }
    } catch (e) {
      r.e(e);
    } finally {
      r.f();
    }
    return n;
  }
  var S6 = function () {
    function e() {
      l(this, e);
      this.saveRouters = [];
      this.loadRouters = [];
    }
    p(e, null, [{
      key: "getInstance",
      value: function () {
        if (e.instance == null) {
          e.instance = new e();
        }
        return e.instance;
      }
    }, {
      key: "registerSaveRouter",
      value: function (t) {
        e.getInstance().saveRouters.push(t);
      }
    }, {
      key: "registerLoadRouter",
      value: function (t) {
        e.getInstance().loadRouters.push(t);
      }
    }, {
      key: "getSaveHandlers",
      value: function (t) {
        return e.getHandlers(t, "save");
      }
    }, {
      key: "getLoadHandlers",
      value: function (t, n) {
        return e.getHandlers(t, "load", n);
      }
    }, {
      key: "getHandlers",
      value: function (t, n, r) {
        var a = [];
        (n === "load" ? e.getInstance().loadRouters : e.getInstance().saveRouters).forEach(function (e) {
          var n = e(t, r);
          if (n !== null) {
            a.push(n);
          }
        });
        return a;
      }
    }]);
    return e;
  }();
  function T6(e) {
    return S6.getSaveHandlers(e);
  }
  function E6(e, t) {
    return S6.getLoadHandlers(e, t);
  }
  var C6 = "tensorflowjs";
  var A6 = "models_store";
  var R6 = "model_info_store";
  function _6() {
    if (!k0().getBool("IS_BROWSER")) {
      throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    }
    var e = typeof window == "undefined" ? self : window;
    var t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
    if (t == null) {
      throw new Error("The current browser does not appear to support IndexedDB.");
    }
    return t;
  }
  function O6(e) {
    var t = e.result;
    t.createObjectStore(A6, {
      keyPath: "modelPath"
    });
    t.createObjectStore(R6, {
      keyPath: "modelPath"
    });
  }
  var F6 = function () {
    function e(t) {
      l(this, e);
      this.indexedDB = _6();
      if (t == null || !t) {
        throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = t;
    }
    var t;
    var n;
    p(e, [{
      key: "save",
      value: (n = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(t.modelTopology instanceof ArrayBuffer)) {
                  e.next = 2;
                  break;
                }
                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
              case 2:
                return e.abrupt("return", this.databaseAction(this.modelPath, t));
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "load",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.databaseAction(this.modelPath));
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }, {
      key: "databaseAction",
      value: function (e, t) {
        var n = this;
        return new Promise(function (e, r) {
          var a = n.indexedDB.open(C6, 1);
          a.onupgradeneeded = function () {
            return O6(a);
          };
          a.onsuccess = function () {
            var i = a.result;
            if (t == null) {
              var o = i.transaction(A6, "readonly");
              var s = o.objectStore(A6).get(n.modelPath);
              s.onsuccess = function () {
                if (s.result == null) {
                  i.close();
                  return r(new Error(`Cannot find model with path '${n.modelPath}' in IndexedDB.`));
                }
                e(s.result.modelArtifacts);
              };
              s.onerror = function (e) {
                i.close();
                return r(s.error);
              };
              o.oncomplete = function () {
                return i.close();
              };
            } else {
              t.weightData = j5.join(t.weightData);
              var u;
              var c;
              var l = I6(t);
              var h = i.transaction(R6, "readwrite");
              var p = h.objectStore(R6);
              try {
                u = p.put({
                  modelPath: n.modelPath,
                  modelArtifactsInfo: l
                });
              } catch (e) {
                return r(e);
              }
              u.onsuccess = function () {
                var a;
                var o = (c = i.transaction(A6, "readwrite")).objectStore(A6);
                try {
                  a = o.put({
                    modelPath: n.modelPath,
                    modelArtifacts: t,
                    modelArtifactsInfo: l
                  });
                } catch (e) {
                  return r(e);
                }
                a.onsuccess = function () {
                  return e({
                    modelArtifactsInfo: l
                  });
                };
                a.onerror = function (e) {
                  var t = (p = h.objectStore(R6)).delete(n.modelPath);
                  t.onsuccess = function () {
                    i.close();
                    return r(a.error);
                  };
                  t.onerror = function (e) {
                    i.close();
                    return r(a.error);
                  };
                };
              };
              u.onerror = function (e) {
                i.close();
                return r(u.error);
              };
              h.oncomplete = function () {
                if (c == null) {
                  i.close();
                } else {
                  c.oncomplete = function () {
                    return i.close();
                  };
                }
              };
            }
          };
          a.onerror = function (e) {
            return r(a.error);
          };
        });
      }
    }]);
    return e;
  }();
  F6.URL_SCHEME = "indexeddb://";
  function D6(e) {
    if (k0().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(F6.URL_SCHEME)) {
      t = e.slice(F6.URL_SCHEME.length);
      return new F6(t);
    } else {
      return null;
    }
    var t;
  }
  function M6(e) {
    if (e.startsWith(F6.URL_SCHEME)) {
      return e.slice(F6.URL_SCHEME.length);
    } else {
      return e;
    }
  }
  S6.registerSaveRouter(D6);
  S6.registerLoadRouter(D6);
  var L6 = function () {
    function e() {
      l(this, e);
      this.indexedDB = _6();
    }
    p(e, [{
      key: "listModels",
      value: function () {
        var e = c(o().mark(function e() {
          var t = this;
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  return e.abrupt("return", new Promise(function (e, n) {
                    var r = t.indexedDB.open(C6, 1);
                    r.onupgradeneeded = function () {
                      return O6(r);
                    };
                    r.onsuccess = function () {
                      var t = r.result;
                      var a = t.transaction(R6, "readonly");
                      var i = a.objectStore(R6).getAll();
                      i.onsuccess = function () {
                        var t;
                        var n = {};
                        var r = O(i.result);
                        try {
                          for (r.s(); !(t = r.n()).done;) {
                            var a = t.value;
                            n[a.modelPath] = a.modelArtifactsInfo;
                          }
                        } catch (e) {
                          r.e(e);
                        } finally {
                          r.f();
                        }
                        e(n);
                      };
                      i.onerror = function (e) {
                        t.close();
                        return n(i.error);
                      };
                      a.oncomplete = function () {
                        return t.close();
                      };
                    };
                    r.onerror = function (e) {
                      return n(r.error);
                    };
                  }));
                case 1:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }));
        return function () {
          return e.apply(this, arguments);
        };
      }()
    }, {
      key: "removeModel",
      value: function () {
        var e = c(o().mark(function e(t) {
          var n = this;
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  t = M6(t);
                  return e.abrupt("return", new Promise(function (e, r) {
                    var a = n.indexedDB.open(C6, 1);
                    a.onupgradeneeded = function () {
                      return O6(a);
                    };
                    a.onsuccess = function () {
                      var n;
                      var i = a.result;
                      var o = i.transaction(R6, "readwrite");
                      var s = o.objectStore(R6);
                      var u = s.get(t);
                      u.onsuccess = function () {
                        if (u.result == null) {
                          i.close();
                          return r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));
                        }
                        var a = s.delete(t);
                        function o() {
                          var a = (n = i.transaction(A6, "readwrite")).objectStore(A6).delete(t);
                          a.onsuccess = function () {
                            return e(u.result.modelArtifactsInfo);
                          };
                          a.onerror = function (e) {
                            return r(u.error);
                          };
                        }
                        a.onsuccess = o;
                        a.onerror = function (e) {
                          o();
                          i.close();
                          return r(u.error);
                        };
                      };
                      u.onerror = function (e) {
                        i.close();
                        return r(u.error);
                      };
                      o.oncomplete = function () {
                        if (n == null) {
                          i.close();
                        } else {
                          n.oncomplete = function () {
                            return i.close();
                          };
                        }
                      };
                    };
                    a.onerror = function (e) {
                      return r(a.error);
                    };
                  }));
                case 2:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }));
        return function (t) {
          return e.apply(this, arguments);
        };
      }()
    }]);
    return e;
  }();
  var z6 = "/";
  var P6 = "tensorflowjs_models";
  var B6 = "info";
  var W6 = "model_topology";
  var U6 = "weight_specs";
  var V6 = "weight_data";
  var G6 = "model_metadata";
  function j6(e) {
    return {
      info: [P6, e, B6].join(z6),
      topology: [P6, e, W6].join(z6),
      weightSpecs: [P6, e, U6].join(z6),
      weightData: [P6, e, V6].join(z6),
      modelMetadata: [P6, e, G6].join(z6)
    };
  }
  function H6(e) {
    for (var t = 0, n = Object.values(e); t < n.length; t++) {
      var r = n[t];
      window.localStorage.removeItem(r);
    }
  }
  function q6(e) {
    var t = e.split(z6);
    if (t.length < 3) {
      throw new Error(`Invalid key format: ${e}`);
    }
    return t.slice(1, t.length - 1).join(z6);
  }
  function K6(e) {
    if (e.startsWith(X6.URL_SCHEME)) {
      return e.slice(X6.URL_SCHEME.length);
    } else {
      return e;
    }
  }
  var X6 = function () {
    function e(t) {
      l(this, e);
      if (!k0().getBool("IS_BROWSER") || typeof window == "undefined" || window.localStorage === undefined) {
        throw new Error("The current environment does not support local storage.");
      }
      this.LS = window.localStorage;
      if (t == null || !t) {
        throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = t;
      this.keys = j6(this.modelPath);
    }
    var t;
    var n;
    p(e, [{
      key: "save",
      value: (n = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        var i;
        var s;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(t.modelTopology instanceof ArrayBuffer)) {
                  e.next = 4;
                  break;
                }
                throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
              case 4:
                n = JSON.stringify(t.modelTopology);
                r = JSON.stringify(t.weightSpecs);
                a = I6(t);
                i = j5.join(t.weightData);
                e.prev = 8;
                this.LS.setItem(this.keys.info, JSON.stringify(a));
                this.LS.setItem(this.keys.topology, n);
                this.LS.setItem(this.keys.weightSpecs, r);
                this.LS.setItem(this.keys.weightData, v6(i));
                s = {
                  format: t.format,
                  generatedBy: t.generatedBy,
                  convertedBy: t.convertedBy,
                  signature: t.signature ?? undefined,
                  userDefinedMetadata: t.userDefinedMetadata ?? undefined,
                  modelInitializer: t.modelInitializer ?? undefined,
                  initializerSignature: t.initializerSignature ?? undefined,
                  trainingConfig: t.trainingConfig ?? undefined
                };
                this.LS.setItem(this.keys.modelMetadata, JSON.stringify(s));
                return e.abrupt("return", {
                  modelArtifactsInfo: a
                });
              case 18:
                e.prev = 18;
                e.t0 = e.catch(8);
                H6(this.keys);
                throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`);
              case 22:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[8, 18]]);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "load",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if ((t = JSON.parse(this.LS.getItem(this.keys.info))) != null) {
                  e.next = 3;
                  break;
                }
                throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
              case 3:
                if (t.modelTopologyType === "JSON") {
                  e.next = 5;
                  break;
                }
                throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
              case 5:
                n = {};
                if ((r = JSON.parse(this.LS.getItem(this.keys.topology))) != null) {
                  e.next = 9;
                  break;
                }
                throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
              case 9:
                n.modelTopology = r;
                if ((a = JSON.parse(this.LS.getItem(this.keys.weightSpecs))) != null) {
                  e.next = 13;
                  break;
                }
                throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
              case 13:
                n.weightSpecs = a;
                if ((i = this.LS.getItem(this.keys.modelMetadata)) != null) {
                  s = JSON.parse(i);
                  n.format = s.format;
                  n.generatedBy = s.generatedBy;
                  n.convertedBy = s.convertedBy;
                  if (s.signature != null) {
                    n.signature = s.signature;
                  }
                  if (s.userDefinedMetadata != null) {
                    n.userDefinedMetadata = s.userDefinedMetadata;
                  }
                  if (s.modelInitializer != null) {
                    n.modelInitializer = s.modelInitializer;
                  }
                  if (s.initializerSignature != null) {
                    n.initializerSignature = s.initializerSignature;
                  }
                  if (s.trainingConfig != null) {
                    n.trainingConfig = s.trainingConfig;
                  }
                }
                if ((u = this.LS.getItem(this.keys.weightData)) != null) {
                  e.next = 19;
                  break;
                }
                throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
              case 19:
                n.weightData = m6(u);
                return e.abrupt("return", n);
              case 21:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return e;
  }();
  X6.URL_SCHEME = "localstorage://";
  function Y6(e) {
    if (k0().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(X6.URL_SCHEME)) {
      t = e.slice(X6.URL_SCHEME.length);
      return new X6(t);
    } else {
      return null;
    }
    var t;
  }
  S6.registerSaveRouter(Y6);
  S6.registerLoadRouter(Y6);
  var J6 = function () {
    function e() {
      l(this, e);
      F$(k0().getBool("IS_BROWSER"), function () {
        return "Current environment is not a web browser";
      });
      F$(typeof window == "undefined" || window.localStorage !== undefined, function () {
        return "Current browser does not appear to support localStorage";
      });
      this.LS = window.localStorage;
    }
    p(e, [{
      key: "listModels",
      value: function () {
        var e = c(o().mark(function e() {
          var t;
          var n;
          var r;
          var a;
          var i;
          var s;
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  t = {};
                  n = P6 + z6;
                  r = z6 + B6;
                  a = 0;
                  for (; a < this.LS.length; ++a) {
                    if ((i = this.LS.key(a)).startsWith(n) && i.endsWith(r)) {
                      s = q6(i);
                      t[s] = JSON.parse(this.LS.getItem(i));
                    }
                  }
                  return e.abrupt("return", t);
                case 5:
                case "end":
                  return e.stop();
              }
            }
          }, e, this);
        }));
        return function () {
          return e.apply(this, arguments);
        };
      }()
    }, {
      key: "removeModel",
      value: function () {
        var e = c(o().mark(function e(t) {
          var n;
          var r;
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  t = K6(t);
                  n = j6(t);
                  if (this.LS.getItem(n.info) != null) {
                    e.next = 4;
                    break;
                  }
                  throw new Error(`Cannot find model at path '${t}'`);
                case 4:
                  r = JSON.parse(this.LS.getItem(n.info));
                  H6(n);
                  return e.abrupt("return", r);
                case 7:
                case "end":
                  return e.stop();
              }
            }
          }, e, this);
        }));
        return function (t) {
          return e.apply(this, arguments);
        };
      }()
    }]);
    return e;
  }();
  var Z6 = "://";
  var Q6 = function () {
    function e() {
      l(this, e);
      this.managers = {};
    }
    p(e, null, [{
      key: "getInstance",
      value: function () {
        if (e.instance == null) {
          e.instance = new e();
        }
        return e.instance;
      }
    }, {
      key: "registerManager",
      value: function (t, n) {
        F$(t != null, function () {
          return "scheme must not be undefined or null.";
        });
        if (t.endsWith(Z6)) {
          t = t.slice(0, t.indexOf(Z6));
        }
        F$(t.length > 0, function () {
          return "scheme must not be an empty string.";
        });
        var r = e.getInstance();
        F$(r.managers[t] == null, function () {
          return `A model store manager is already registered for scheme '${t}'.`;
        });
        r.managers[t] = n;
      }
    }, {
      key: "getManager",
      value: function (t) {
        var n = e.getInstance().managers[t];
        if (n == null) {
          throw new Error(`Cannot find model manager for scheme '${t}'`);
        }
        return n;
      }
    }, {
      key: "getSchemes",
      value: function () {
        return Object.keys(e.getInstance().managers);
      }
    }]);
    return e;
  }();
  function $6(e) {
    if (e.indexOf(Z6) === -1) {
      throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Q6.getSchemes().join(",")}`);
    }
    return {
      scheme: e.split(Z6)[0],
      path: e.split(Z6)[1]
    };
  }
  function e8(e, t) {
    return t8.apply(this, arguments);
  }
  function t8() {
    t8 = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = d.length > 2 && d[2] !== undefined && d[2];
              F$(t !== n, function () {
                return `Old path and new path are the same: '${t}'`;
              });
              F$((a = S6.getLoadHandlers(t)).length > 0, function () {
                return `Copying failed because no load handler is found for source URL ${t}.`;
              });
              F$(a.length < 2, function () {
                return `Copying failed because more than one (${a.length}) load handlers for source URL ${t}.`;
              });
              i = a[0];
              F$((s = S6.getSaveHandlers(n)).length > 0, function () {
                return `Copying failed because no save handler is found for destination URL ${n}.`;
              });
              F$(s.length < 2, function () {
                return `Copying failed because more than one (${a.length}) save handlers for destination URL ${n}.`;
              });
              u = s[0];
              c = $6(t).scheme;
              l = $6(t).path;
              h = c === $6(t).scheme;
              e.next = 15;
              return i.load();
            case 15:
              p = e.sent;
              if (!r || !h) {
                e.next = 19;
                break;
              }
              e.next = 19;
              return Q6.getManager(c).removeModel(l);
            case 19:
              e.next = 21;
              return u.save(p);
            case 21:
              f = e.sent;
              if (!r || h) {
                e.next = 25;
                break;
              }
              e.next = 25;
              return Q6.getManager(c).removeModel(l);
            case 25:
              return e.abrupt("return", f.modelArtifactsInfo);
            case 26:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return t8.apply(this, arguments);
  }
  function n8() {
    n8 = c(o().mark(function e() {
      var t;
      var n;
      var r;
      var a;
      var i;
      var s;
      var u;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              t = Q6.getSchemes();
              n = {};
              r = O(t);
              e.prev = 3;
              r.s();
            case 5:
              if ((a = r.n()).done) {
                e.next = 13;
                break;
              }
              i = a.value;
              e.next = 9;
              return Q6.getManager(i).listModels();
            case 9:
              for (u in s = e.sent) {
                n[i + Z6 + u] = s[u];
              }
            case 11:
              e.next = 5;
              break;
            case 13:
              e.next = 18;
              break;
            case 15:
              e.prev = 15;
              e.t0 = e.catch(3);
              r.e(e.t0);
            case 18:
              e.prev = 18;
              r.f();
              return e.finish(18);
            case 21:
              return e.abrupt("return", n);
            case 22:
            case "end":
              return e.stop();
          }
        }
      }, e, null, [[3, 15, 18, 21]]);
    }));
    return n8.apply(this, arguments);
  }
  function r8() {
    return (r8 = c(o().mark(function e(t) {
      var n;
      var r;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              n = $6(t);
              r = Q6.getManager(n.scheme);
              return e.abrupt("return", r.removeModel(n.path));
            case 3:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  function a8() {
    return (a8 = c(o().mark(function e(t, n) {
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              false;
              return e.abrupt("return", e8(t, n, false));
            case 2:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  function i8() {
    return (i8 = c(o().mark(function e(t, n) {
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              true;
              return e.abrupt("return", e8(t, n, true));
            case 2:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  var o8 = function () {
    function e() {
      l(this, e);
      this.messageName = "setTimeoutCustom";
      this.functionRefs = [];
      this.handledMessageCount = 0;
      this.hasEventListener = false;
    }
    p(e, [{
      key: "fetch",
      value: function (e) {
        function t(t, n) {
          return e.apply(this, arguments);
        }
        t.toString = function () {
          return e.toString();
        };
        return t;
      }(function (e, t) {
        return fetch(e, t);
      })
    }, {
      key: "now",
      value: function () {
        return performance.now();
      }
    }, {
      key: "encode",
      value: function (e, t) {
        if (t !== "utf-8" && t !== "utf8") {
          throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);
        }
        if (this.textEncoder == null) {
          this.textEncoder = new TextEncoder();
        }
        return this.textEncoder.encode(e);
      }
    }, {
      key: "decode",
      value: function (e, t) {
        return new TextDecoder(t).decode(e);
      }
    }, {
      key: "setTimeoutCustom",
      value: function (e, t) {
        var n = this;
        if (typeof window != "undefined" && k0().getBool("USE_SETTIMEOUTCUSTOM")) {
          this.functionRefs.push(e);
          setTimeout(function () {
            window.postMessage({
              name: n.messageName,
              index: n.functionRefs.length - 1
            }, "*");
          }, t);
          if (!this.hasEventListener) {
            this.hasEventListener = true;
            window.addEventListener("message", function (e) {
              if (e.source === window && e.data.name === n.messageName) {
                e.stopPropagation();
                (0, n.functionRefs[e.data.index])();
                n.handledMessageCount++;
                if (n.handledMessageCount === n.functionRefs.length) {
                  n.functionRefs = [];
                  n.handledMessageCount = 0;
                }
              }
            }, true);
          }
        } else {
          setTimeout(e, t);
        }
      }
    }, {
      key: "isTypedArray",
      value: function (e) {
        return q3(e);
      }
    }]);
    return e;
  }();
  if (k0().get("IS_BROWSER")) {
    k0().setPlatform("browser", new o8());
    try {
      Q6.registerManager(X6.URL_SCHEME, new J6());
    } catch (e) {}
    try {
      Q6.registerManager(F6.URL_SCHEME, new L6());
    } catch (e) {}
  }
  var s8;
  function u8() {
    return require("node-fetch");
  }
  var c8 = function () {
    function e() {
      l(this, e);
      this.util = require("util");
      this.textEncoder = new this.util.TextEncoder();
    }
    p(e, [{
      key: "fetch",
      value: function (e, t) {
        if (k0().global.fetch != null) {
          return k0().global.fetch(e, t);
        } else {
          if (s8 == null) {
            s8 = u8();
          }
          return s8(e, t);
        }
      }
    }, {
      key: "now",
      value: function () {
        var e = process.hrtime();
        return e[0] * 1000 + e[1] / 1000000;
      }
    }, {
      key: "encode",
      value: function (e, t) {
        if (t !== "utf-8" && t !== "utf8") {
          throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);
        }
        return this.textEncoder.encode(e);
      }
    }, {
      key: "decode",
      value: function (e, t) {
        if (e.length === 0) {
          return "";
        } else {
          return new this.util.TextDecoder(t).decode(e);
        }
      }
    }, {
      key: "isTypedArray",
      value: function (e) {
        return this.util.types.isFloat32Array(e) || this.util.types.isInt32Array(e) || this.util.types.isUint8Array(e) || this.util.types.isUint8ClampedArray(e);
      }
    }]);
    return e;
  }();
  function l8(e, t = "float32", n) {
    t = t || "float32";
    p0(e);
    return new $4(e, t, n);
  }
  if (k0().get("IS_NODE") && !k0().get("IS_BROWSER")) {
    k0().setPlatform("node", new c8());
  }
  var h8 = B5({
    cast_: function (e, t) {
      var n = L5(e, "x", "cast");
      if (!Y$(t)) {
        throw new Error(`Failed to cast to unknown dtype ${t}`);
      }
      if (t === "string" && n.dtype !== "string" || t !== "string" && n.dtype === "string") {
        throw new Error("Only strings can be casted to strings");
      }
      var r = {
        x: n
      };
      var a = {
        dtype: t
      };
      return E5.runKernel(X0, r, a);
    }
  });
  var p8 = B5({
    clone_: function (e) {
      var t = {
        x: L5(e, "x", "clone", "string_or_numeric")
      };
      return E5.runKernel(W1, t);
    }
  });
  function f8(e, t = false) {
    console.log(e.toString(t));
  }
  S5();
  t5 = {
    buffer: l8,
    cast: h8,
    clone: p8,
    print: f8
  };
  var d8 = B5({
    add_: function (e, t) {
      var n = L5(e, "a", "add");
      var r = L5(t, "b", "add");
      var a = S(v5(n, r), 2);
      var i = {
        a: n = a[0],
        b: r = a[1]
      };
      return E5.runKernel(E0, i);
    }
  });
  var v8 = B5({
    floorDiv_: function (e, t) {
      var n = L5(e, "a", "floorDiv");
      var r = L5(t, "b", "floorDiv");
      var a = S(v5(n, r), 2);
      var i = {
        a: n = a[0],
        b: r = a[1]
      };
      return E5.runKernel(D1, i);
    }
  });
  var m8 = B5({
    div_: function (e, t) {
      var n = L5(e, "a", "div");
      var r = L5(t, "b", "div");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      if (n.dtype === "int32" && r.dtype === "int32") {
        return v8(n, r);
      }
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(k1, i, {});
    }
  });
  var g8 = B5({
    mul_: function (e, t) {
      var n = L5(e, "a", "mul");
      var r = L5(t, "b", "mul");
      var a = S(v5(n, r), 2);
      var i = {
        a: n = a[0],
        b: r = a[1]
      };
      return E5.runKernel(g2, i);
    }
  });
  var y8 = B5({
    abs_: function (e) {
      var t = L5(e, "x", "abs");
      if (t.dtype === "complex64") {
        var n = {
          x: t
        };
        return E5.runKernel(Q0, n);
      }
      var r = {
        x: t
      };
      return E5.runKernel(N0, r);
    }
  });
  var b8 = B5({
    acos_: function (e) {
      var t = {
        x: L5(e, "x", "acos")
      };
      return E5.runKernel(S0, t);
    }
  });
  var x8 = B5({
    acosh_: function (e) {
      var t = {
        x: L5(e, "x", "acosh")
      };
      return E5.runKernel(T0, t);
    }
  });
  var k8 = B5({
    addN_: function (e) {
      F$(Array.isArray(e), function () {
        return "The argument passed to tf.addN() must be a list of tensors";
      });
      F$(e.length >= 1, function () {
        return `Must pass at least one tensor to tf.addN(), but got ${e.length}`;
      });
      var t = e.map(function (e, t) {
        return L5(e, `tensors${t}`, "addN");
      });
      var n = t[0];
      t.forEach(function (e) {
        if (e.dtype !== n.dtype) {
          throw new Error("All tensors passed to tf.addN() must have the same dtype");
        }
      });
      t.forEach(function (e) {
        if (!P$(e.shape, n.shape)) {
          throw new Error("All tensors passed to tf.addN() must have the same shape");
        }
      });
      var r = t;
      return E5.runKernel(C0, r);
    }
  });
  var w8 = B5({
    all_: function (e, t = null, n = false) {
      var r = L5(e, "x", "all", "bool");
      var a = {
        x: r
      };
      var i = {
        axis: t,
        keepDims: n
      };
      return E5.runKernel(A0, a, i);
    }
  });
  var I8 = B5({
    any_: function (e, t = null, n = false) {
      var r = L5(e, "x", "any", "bool");
      var a = {
        x: r
      };
      var i = {
        axis: t,
        keepDims: n
      };
      return E5.runKernel(R0, a, i);
    }
  });
  var N8 = B5({
    argMax_: function (e, t = 0) {
      var n = L5(e, "x", "argMax");
      var r = {
        x: n
      };
      var a = {
        axis: t
      };
      return E5.runKernel(_0, r, a);
    }
  });
  var S8 = B5({
    argMin_: function (e, t = 0) {
      var n = L5(e, "x", "argMin");
      var r = {
        x: n
      };
      var a = {
        axis: t
      };
      return E5.runKernel(O0, r, a);
    }
  });
  var T8 = B5({
    asin_: function (e) {
      var t = {
        x: L5(e, "x", "asin")
      };
      return E5.runKernel(F0, t);
    }
  });
  var E8 = B5({
    asinh_: function (e) {
      var t = {
        x: L5(e, "x", "asinh")
      };
      return E5.runKernel(D0, t);
    }
  });
  var C8 = B5({
    atan_: function (e) {
      var t = {
        x: L5(e, "x", "atan")
      };
      return E5.runKernel(M0, t);
    }
  });
  var A8 = B5({
    atan2_: function (e, t) {
      var n = L5(e, "a", "atan2");
      var r = L5(t, "b", "atan2");
      var a = S(v5(n, r), 2);
      var i = {
        a: n = a[0],
        b: r = a[1]
      };
      return E5.runKernel(z0, i);
    }
  });
  var R8 = B5({
    atanh_: function (e) {
      var t = {
        x: L5(e, "x", "atanh")
      };
      return E5.runKernel(L0, t);
    }
  });
  function _8(e, t, n, r, a = "NHWC", i) {
    var o = e[3];
    var s = [].concat(T(t), [o]);
    var u = q8(a);
    return D8(e, s, n, i, r, null, null, u);
  }
  function O8(e, t, n, r, a, i) {
    var o;
    var s = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "channelsLast";
    var u = z8(t);
    var c = S(u, 2);
    var l = c[0];
    var h = c[1];
    if (s === "channelsLast") {
      o = [l, h, e[3], e[3]];
    } else {
      if (s !== "channelsFirst") {
        throw new Error(`Unknown dataFormat ${s}`);
      }
      o = [l, h, e[1], e[1]];
    }
    return D8(e, o, n, r, a, i, false, s);
  }
  function F8(e, t, n, r, a, i) {
    var o;
    var s;
    var u = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "NDHWC";
    var c = P8(t);
    var l = S(c, 3);
    var h = l[0];
    var p = l[1];
    var f = l[2];
    if (u === "NDHWC") {
      s = "channelsLast";
      o = [h, p, f, e[4], e[4]];
    } else {
      if (u !== "NCDHW") {
        throw new Error(`Unknown dataFormat ${u}`);
      }
      s = "channelsFirst";
      o = [h, p, f, e[1], e[1]];
    }
    return M8(e, o, n, r, a, false, s, i);
  }
  function D8(e, t, n, r, a, i, o = false, s = "channelsLast") {
    var u = -1;
    var c = -1;
    var l = -1;
    var h = -1;
    if (s === "channelsLast") {
      var p = S(e, 4);
      u = p[0];
      c = p[1];
      l = p[2];
      h = p[3];
    } else {
      if (s !== "channelsFirst") {
        throw new Error(`Unknown dataFormat ${s}`);
      }
      var f = S(e, 4);
      u = f[0];
      h = f[1];
      c = f[2];
      l = f[3];
    }
    var d;
    var v = S(t, 4);
    var m = v[0];
    var g = v[1];
    var y = v[3];
    var b = z8(n);
    var x = S(b, 2);
    var k = x[0];
    var w = x[1];
    var I = z8(r);
    var N = S(I, 2);
    var T = N[0];
    var E = N[1];
    var C = B8(m, T);
    var A = B8(g, E);
    var R = W8(a, c, l, k, w, C, A, i, s);
    var _ = R.padInfo;
    var O = R.outHeight;
    var F = R.outWidth;
    var D = o ? y * h : y;
    if (s === "channelsFirst") {
      d = [u, D, O, F];
    } else if (s === "channelsLast") {
      d = [u, O, F, D];
    }
    return {
      batchSize: u,
      dataFormat: s,
      inHeight: c,
      inWidth: l,
      inChannels: h,
      outHeight: O,
      outWidth: F,
      outChannels: D,
      padInfo: _,
      strideHeight: k,
      strideWidth: w,
      filterHeight: m,
      filterWidth: g,
      effectiveFilterHeight: C,
      effectiveFilterWidth: A,
      dilationHeight: T,
      dilationWidth: E,
      inShape: e,
      outShape: d,
      filterShape: t
    };
  }
  function M8(e, t, n, r, a, i = false, o = "channelsLast", s) {
    var u = -1;
    var c = -1;
    var l = -1;
    var h = -1;
    var p = -1;
    if (o === "channelsLast") {
      var f = S(e, 5);
      u = f[0];
      c = f[1];
      l = f[2];
      h = f[3];
      p = f[4];
    } else {
      if (o !== "channelsFirst") {
        throw new Error(`Unknown dataFormat ${o}`);
      }
      var d = S(e, 5);
      u = d[0];
      p = d[1];
      c = d[2];
      l = d[3];
      h = d[4];
    }
    var v;
    var m = S(t, 5);
    var g = m[0];
    var y = m[1];
    var b = m[2];
    var x = m[4];
    var k = P8(n);
    var w = S(k, 3);
    var I = w[0];
    var N = w[1];
    var T = w[2];
    var E = P8(r);
    var C = S(E, 3);
    var A = C[0];
    var R = C[1];
    var _ = C[2];
    var O = B8(g, A);
    var F = B8(y, R);
    var D = B8(b, _);
    var M = U8(a, c, l, h, I, N, T, O, F, D, s);
    var L = M.padInfo;
    var z = M.outDepth;
    var P = M.outHeight;
    var B = M.outWidth;
    var W = i ? x * p : x;
    if (o === "channelsFirst") {
      v = [u, W, z, P, B];
    } else if (o === "channelsLast") {
      v = [u, z, P, B, W];
    }
    return {
      batchSize: u,
      dataFormat: o,
      inDepth: c,
      inHeight: l,
      inWidth: h,
      inChannels: p,
      outDepth: z,
      outHeight: P,
      outWidth: B,
      outChannels: W,
      padInfo: L,
      strideDepth: I,
      strideHeight: N,
      strideWidth: T,
      filterDepth: g,
      filterHeight: y,
      filterWidth: b,
      effectiveFilterDepth: O,
      effectiveFilterHeight: F,
      effectiveFilterWidth: D,
      dilationDepth: A,
      dilationHeight: R,
      dilationWidth: _,
      inShape: e,
      outShape: v,
      filterShape: t
    };
  }
  function L8(e, t, n, r = 1) {
    var a = B8(t, r);
    return Math.floor((e[0] * (n - 1) - n + a) / 2);
  }
  function z8(e) {
    if (typeof e == "number") {
      return [e, e, e];
    } else if (e.length === 2) {
      return [e[0], e[1], 1];
    } else {
      return e;
    }
  }
  function P8(e) {
    if (typeof e == "number") {
      return [e, e, e];
    } else {
      return e;
    }
  }
  function B8(e, t) {
    if (t <= 1) {
      return e;
    } else {
      return e + (e - 1) * (t - 1);
    }
  }
  function W8(e, t, n, r, a, i, o, u, c) {
    var l;
    var h;
    var p;
    if (typeof e == "number") {
      l = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        type: e === 0 ? "VALID" : "NUMBER"
      };
      var f = function (e, t, n, r, a) {
        if (r == null) {
          r = L8(e, t, n);
        }
        var i = e[0];
        var o = e[1];
        return [V8((i - t + r * 2) / n + 1, a), V8((o - t + r * 2) / n + 1, a)];
      }([t, n], i, r, e, u);
      h = f[0];
      p = f[1];
    } else if (e === "same") {
      h = Math.ceil(t / r);
      p = Math.ceil(n / a);
      var d = Math.max(0, (h - 1) * r + i - t);
      var v = Math.max(0, (p - 1) * a + o - n);
      var m = Math.floor(d / 2);
      var g = d - m;
      var y = Math.floor(v / 2);
      l = {
        top: m,
        bottom: g,
        left: y,
        right: v - y,
        type: "SAME"
      };
    } else if (e === "valid") {
      l = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        type: "VALID"
      };
      h = Math.ceil((t - i + 1) / r);
      p = Math.ceil((n - o + 1) / a);
    } else {
      if (s(e) !== "object") {
        throw Error(`Unknown padding parameter: ${e}`);
      }
      var b = c === "channelsLast" ? e[1][0] : e[2][0];
      var x = c === "channelsLast" ? e[1][1] : e[2][1];
      var k = c === "channelsLast" ? e[2][0] : e[3][0];
      var w = c === "channelsLast" ? e[2][1] : e[3][1];
      l = {
        top: b,
        bottom: x,
        left: k,
        right: w,
        type: b === 0 && x === 0 && k === 0 && w === 0 ? "VALID" : "EXPLICIT"
      };
      h = V8((t - i + b + x) / r + 1, u);
      p = V8((n - o + k + w) / a + 1, u);
    }
    return {
      padInfo: l,
      outHeight: h,
      outWidth: p
    };
  }
  function U8(e, t, n, r, a, i, o, s, u, c, l) {
    var h;
    var p;
    var f;
    var d;
    if (e === "valid") {
      e = 0;
    }
    if (typeof e == "number") {
      h = {
        top: e,
        bottom: e,
        left: e,
        right: e,
        front: e,
        back: e,
        type: e === 0 ? "VALID" : "NUMBER"
      };
      var v = function (e, t, n, r, a, i) {
        if (a == null) {
          a = L8(e, t[0], r[0]);
        }
        var o = [0, 0, 0, n];
        for (var s = 0; s < 3; s++) {
          if (e[s] + a * 2 >= t[s]) {
            o[s] = V8((e[s] - t[s] + a * 2) / r[s] + 1, i);
          }
        }
        return o;
      }([t, n, r, 1], [s, u, c], 1, [a, i, o], e, l);
      p = v[0];
      f = v[1];
      d = v[2];
    } else {
      if (e !== "same") {
        throw Error(`Unknown padding parameter: ${e}`);
      }
      var m = ((p = Math.ceil(t / a)) - 1) * a + s - t;
      var g = ((f = Math.ceil(n / i)) - 1) * i + u - n;
      var y = ((d = Math.ceil(r / o)) - 1) * o + c - r;
      var b = Math.floor(m / 2);
      var x = m - b;
      var k = Math.floor(g / 2);
      var w = g - k;
      var I = Math.floor(y / 2);
      h = {
        top: k,
        bottom: w,
        left: I,
        right: y - I,
        front: b,
        back: x,
        type: "SAME"
      };
    }
    return {
      padInfo: h,
      outDepth: p,
      outHeight: f,
      outWidth: d
    };
  }
  function V8(e, t) {
    if (!t) {
      return Math.trunc(e);
    }
    switch (t) {
      case "round":
        return Math.round(e);
      case "ceil":
        return Math.ceil(e);
      case "floor":
        return Math.floor(e);
      default:
        throw new Error(`Unknown roundingMode ${t}`);
    }
  }
  function G8(e) {
    var t = S(z8(e), 3);
    var n = t[0];
    var r = t[1];
    var a = t[2];
    return n === 1 && r === 1 && a === 1;
  }
  function j8(e, t) {
    return G8(e) || G8(t);
  }
  function H8(e) {
    return z8(e).every(function (e) {
      return e > 0;
    });
  }
  function q8(e) {
    if (e === "NHWC") {
      return "channelsLast";
    }
    if (e === "NCHW") {
      return "channelsFirst";
    }
    throw new Error(`Unknown dataFormat ${e}`);
  }
  function K8(e, t, n) {
    if (n != null) {
      if (typeof t == "string") {
        throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);
      }
      if (typeof t == "number") {
        F$(B$(t), function () {
          return `Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`;
        });
      } else {
        if (s(t) !== "object") {
          throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);
        }
        t.forEach(function (t) {
          t.forEach(function (t) {
            F$(B$(t), function () {
              return `Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`;
            });
          });
        });
      }
    }
  }
  var X8 = B5({
    reshape_: function (e, t) {
      var n = {
        x: L5(e, "x", "reshape", "string_or_numeric")
      };
      var r = {
        shape: t
      };
      return E5.runKernel(z2, n, r);
    }
  });
  var Y8 = B5({
    avgPool_: function (e, t, n, r, a) {
      var i = L5(e, "x", "avgPool", "float32");
      F$(j8(n, 1), function () {
        return `Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${1}'`;
      });
      var o = i;
      var s = false;
      if (i.rank === 3) {
        s = true;
        o = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]]);
      }
      F$(o.rank === 4, function () {
        return `Error in avgPool: x must be rank 4 but got rank ${o.rank}.`;
      });
      K8("avgPool", r, a);
      var u = {
        x: o
      };
      var c = {
        filterSize: t,
        strides: n,
        pad: r,
        dimRoundingMode: a
      };
      var l = E5.runKernel(P0, u, c);
      l = h8(l, i.dtype);
      if (s) {
        return X8(l, [l.shape[1], l.shape[2], l.shape[3]]);
      } else {
        return l;
      }
    }
  });
  var J8 = B5({
    avgPool3d_: function (e, t, n, r, a, i = "NDHWC") {
      var o = L5(e, "x", "avgPool3d", "float32");
      var s = o;
      var u = false;
      if (o.rank === 4) {
        u = true;
        s = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]);
      }
      F$(s.rank === 5, function () {
        return `Error in avgPool3d: x must be rank 5 but got rank ${s.rank}.`;
      });
      F$(i === "NDHWC", function () {
        return `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`;
      });
      F$(typeof n == "number" && n > 0 || Array.isArray(n) && n[0] > 0 && n[1] > 0 && n[2] > 0, function () {
        return `Error in avgPool3d: Stride must be > 0, but got '${n}'`;
      });
      K8("avgPool3d", r, a);
      var c = {
        x: s
      };
      var l = {
        filterSize: t,
        strides: n,
        pad: r,
        dimRoundingMode: a,
        dataFormat: i
      };
      var h = E5.runKernel(W0, c, l);
      h = h8(h, s.dtype);
      if (u) {
        return X8(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]);
      } else {
        return h;
      }
    }
  });
  var Z8 = B5({
    concat_: function (e, t = 0) {
      F$(e.length >= 1, function () {
        return "Pass at least one tensor to concat";
      });
      var n = z5(e, "tensors", "concat", "string_or_numeric");
      if (n[0].dtype === "complex64") {
        n.forEach(function (e) {
          if (e.dtype !== "complex64") {
            throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e.dtype}. `);
          }
        });
      }
      if (n.length === 1) {
        return p8(n[0]);
      }
      var r = n;
      var a = {
        axis: t
      };
      return E5.runKernel($0, r, a);
    }
  });
  var Q8 = B5({
    matMul_: function (e, t, n = false, r = false) {
      var a = L5(e, "a", "matMul");
      var i = L5(t, "b", "matMul");
      var o = v5(a, i);
      var s = S(o, 2);
      var u = {
        a: a = s[0],
        b: i = s[1]
      };
      var c = {
        transposeA: n,
        transposeB: r
      };
      return E5.runKernel(V0, u, c);
    }
  });
  var $8 = B5({
    sigmoid_: function (e) {
      var t = {
        x: L5(e, "x", "sigmoid", "float32")
      };
      return E5.runKernel(t3, t);
    }
  });
  var e7 = B5({
    slice_: function (e, t, n) {
      var r = L5(e, "x", "slice", "string_or_numeric");
      if (r.rank === 0) {
        throw new Error("Slicing scalar is not possible");
      }
      var a = {
        x: r
      };
      var i = {
        begin: t,
        size: n
      };
      return E5.runKernel(Z2, a, i);
    }
  });
  var t7 = B5({
    tanh_: function (e) {
      var t = {
        x: L5(e, "x", "tanh", "float32")
      };
      return E5.runKernel(w3, t);
    }
  });
  var n7 = B5({
    basicLSTMCell_: function (e, t, n, r, a, i) {
      var o = L5(e, "forgetBias", "basicLSTMCell");
      var s = L5(t, "lstmKernel", "basicLSTMCell");
      var u = L5(n, "lstmBias", "basicLSTMCell");
      var c = L5(r, "data", "basicLSTMCell");
      var l = L5(a, "c", "basicLSTMCell");
      var h = L5(i, "h", "basicLSTMCell");
      var p = Z8([c, h], 1);
      var f = Q8(p, s);
      var d = d8(f, u);
      var v = d.shape[0];
      var m = d.shape[1] / 4;
      var g = [v, m];
      var y = e7(d, [0, 0], g);
      var b = e7(d, [0, m], g);
      var x = e7(d, [0, m * 2], g);
      var k = e7(d, [0, m * 3], g);
      var w = d8(g8($8(y), t7(b)), g8(l, $8(d8(o, x))));
      return [w, g8(t7(w), $8(k))];
    }
  });
  var r7 = B5({
    batchToSpaceND_: function (e, t, n) {
      var r = L5(e, "x", "batchToSpaceND");
      var a = t.reduce(function (e, t) {
        return e * t;
      });
      F$(r.rank >= 1 + t.length, function () {
        return `input rank is ${r.rank} but should be > than blockShape.length ${t.length}`;
      });
      F$(n.length === t.length, function () {
        return `crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`;
      });
      F$(r.shape[0] % a == 0, function () {
        return `input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`;
      });
      var i = {
        x: r
      };
      var o = {
        blockShape: t,
        crops: n
      };
      return E5.runKernel(G0, i, o);
    }
  });
  var a7 = B5({
    batchNorm_: function (e, t, n, r, a, i) {
      if (i == null) {
        i = 0.001;
      }
      var o;
      var s;
      var u = L5(e, "x", "batchNorm");
      var c = L5(t, "mean", "batchNorm");
      var l = L5(n, "variance", "batchNorm");
      if (a != null) {
        o = L5(a, "scale", "batchNorm");
      }
      if (r != null) {
        s = L5(r, "offset", "batchNorm");
      }
      F$(c.rank === l.rank, function () {
        return "Batch normalization gradient requires mean and variance to have equal ranks.";
      });
      F$(s == null || c.rank === s.rank, function () {
        return "Batch normalization gradient requires mean and offset to have equal ranks.";
      });
      F$(o == null || c.rank === o.rank, function () {
        return "Batch normalization gradient requires mean and scale to have equal ranks.";
      });
      var h = function (e) {
        if (e.rank === 0 || e.rank === 1) {
          return X8(e, [1, 1, 1, e.size]);
        } else if (e.rank === 2) {
          return X8(e, [1, 1, e.shape[0], e.shape[1]]);
        } else if (e.rank === 3) {
          return X8(e, [1, e.shape[0], e.shape[1], e.shape[2]]);
        } else {
          return e;
        }
      }(u);
      var p = {
        x: h,
        scale: o,
        offset: s,
        mean: c,
        variance: l
      };
      var f = {
        varianceEpsilon: i
      };
      var d = E5.runKernel(M1, p, f);
      return X8(d, u.shape);
    }
  });
  var i7 = B5({
    batchNorm2d_: function (e, t, n, r, a, i) {
      var o;
      var s;
      var u = L5(e, "x", "batchNorm");
      var c = L5(t, "mean", "batchNorm");
      var l = L5(n, "variance", "batchNorm");
      if (a != null) {
        o = L5(a, "scale", "batchNorm");
      }
      if (r != null) {
        s = L5(r, "offset", "batchNorm");
      }
      F$(u.rank === 2, function () {
        return `Error in batchNorm2D: x must be rank 2 but got rank ${u.rank}.`;
      });
      F$(c.rank === 2 || c.rank === 1, function () {
        return `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${c.rank}.`;
      });
      F$(l.rank === 2 || l.rank === 1, function () {
        return `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`;
      });
      if (o != null) {
        F$(o.rank === 2 || o.rank === 1, function () {
          return `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${o.rank}.`;
        });
      }
      if (s != null) {
        F$(s.rank === 2 || s.rank === 1, function () {
          return `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${s.rank}.`;
        });
      }
      return a7(u, c, l, s, o, i);
    }
  });
  var o7 = B5({
    batchNorm3d_: function (e, t, n, r, a, i) {
      var o;
      var s;
      var u = L5(e, "x", "batchNorm");
      var c = L5(t, "mean", "batchNorm");
      var l = L5(n, "variance", "batchNorm");
      if (a != null) {
        o = L5(a, "scale", "batchNorm");
      }
      if (r != null) {
        s = L5(r, "offset", "batchNorm");
      }
      F$(u.rank === 3, function () {
        return `Error in batchNorm3D: x must be rank 3 but got rank ${u.rank}.`;
      });
      F$(c.rank === 3 || c.rank === 1, function () {
        return `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${c.rank}.`;
      });
      F$(l.rank === 3 || l.rank === 1, function () {
        return `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`;
      });
      if (o != null) {
        F$(o.rank === 3 || o.rank === 1, function () {
          return `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${o.rank}.`;
        });
      }
      if (s != null) {
        F$(s.rank === 3 || s.rank === 1, function () {
          return `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${s.rank}.`;
        });
      }
      return a7(u, c, l, s, o, i);
    }
  });
  var s7 = B5({
    batchNorm4d_: function (e, t, n, r, a, i) {
      var o;
      var s;
      var u = L5(e, "x", "batchNorm");
      var c = L5(t, "mean", "batchNorm");
      var l = L5(n, "variance", "batchNorm");
      if (a != null) {
        o = L5(a, "scale", "batchNorm");
      }
      if (r != null) {
        s = L5(r, "offset", "batchNorm");
      }
      F$(u.rank === 4, function () {
        return `Error in batchNorm4D: x must be rank 4 but got rank ${u.rank}.`;
      });
      F$(c.rank === 4 || c.rank === 1, function () {
        return `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${c.rank}.`;
      });
      F$(l.rank === 4 || l.rank === 1, function () {
        return `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`;
      });
      if (o != null) {
        F$(o.rank === 4 || o.rank === 1, function () {
          return `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${o.rank}.`;
        });
      }
      if (s != null) {
        F$(s.rank === 4 || s.rank === 1, function () {
          return `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${s.rank}.`;
        });
      }
      return a7(u, c, l, s, o, i);
    }
  });
  var u7 = B5({
    bincount_: function (e, t, n) {
      var r = L5(e, "x", "bincount");
      var a = L5(t, "weights", "bincount");
      F$(r.dtype === "int32", function () {
        return `Error in bincount: input dtype must be int32, but got ${r.dtype}`;
      });
      F$(n >= 0, function () {
        return `size must be non-negative, but got ${n}.`;
      });
      F$(a.size === r.size || a.size === 0, function () {
        return `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`;
      });
      var i = {
        x: r,
        weights: a
      };
      var o = {
        size: n
      };
      return E5.runKernel(j0, i, o);
    }
  });
  var c7 = B5({
    bitwiseAnd_: function (e, t) {
      var n = L5(e, "x", "bitwiseAnd");
      var r = L5(t, "y", "bitwiseAnd");
      if (!P$(n.shape, r.shape)) {
        throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);
      }
      if (n.dtype !== "int32" || r.dtype !== "int32") {
        throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);
      }
      var a = {
        a: n,
        b: r
      };
      return E5.runKernel(H0, a);
    }
  });
  var l7 = B5({
    broadcastArgs_: function (e, t) {
      var n = L5(e, "s0", "broadcastArgs", "int32");
      var r = L5(t, "s1", "broadcastArgs", "int32");
      if (n.rank !== 1) {
        throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);
      }
      if (r.rank !== 1) {
        throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);
      }
      var a = {
        s0: n,
        s1: r
      };
      return E5.runKernel(K0, a);
    }
  });
  var h7 = B5({
    broadcastTo_: function (e, t) {
      var n = L5(e, "broadcastTo", "x");
      var r = n.shape;
      p0(t);
      if (t.length < n.rank) {
        throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);
      }
      if (t.length > n.rank) {
        for (var a = n.shape.slice(); a.length < t.length;) {
          a.unshift(1);
        }
        n = X8(n, a);
      }
      var i = n.shape;
      var o = Array.from(t);
      for (var s = t.length - 1; s >= 0; s--) {
        if (i[s] === t[s]) {
          o[s] = 1;
        } else if (n.shape[s] !== 1) {
          throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);
        }
      }
      var u = o.map(function (e, t) {
        if (e > 1) {
          return t;
        } else {
          return -1;
        }
      }).filter(function (e) {
        return e >= 0;
      });
      if (u.length === 0) {
        return p8(n);
      }
      var c = {
        x: n
      };
      var l = {
        reps: o
      };
      return E5.runKernel(I3, c, l);
    }
  });
  var p7 = B5({
    ceil_: function (e) {
      var t = {
        x: L5(e, "x", "ceil", "float32")
      };
      return E5.runKernel(Y0, t);
    }
  });
  function f7(e, t, n) {
    p0(e);
    var r = {
      shape: e,
      value: t,
      dtype: n = n || n0(t)
    };
    return E5.runKernel(_1, {}, r);
  }
  var d7 = B5({
    clipByValue_: function (e, t, n) {
      var r = L5(e, "x", "clipByValue");
      F$(t <= n, function () {
        return `Error in clip: min (${t}) must be less than or equal to max (${n}).`;
      });
      if (t === n) {
        return f7(r.shape, t, r.dtype);
      }
      var a = {
        x: r
      };
      var i = {
        clipValueMin: t,
        clipValueMax: n
      };
      return E5.runKernel(J0, a, i);
    }
  });
  var v7 = B5({
    concat1d_: function (e) {
      return Z8(e, 0);
    }
  });
  var m7 = B5({
    concat2d_: function (e, t) {
      return Z8(e, t);
    }
  });
  var g7 = B5({
    concat3d_: function (e, t) {
      return Z8(e, t);
    }
  });
  var y7 = B5({
    concat4d_: function (e, t) {
      return Z8(e, t);
    }
  });
  var b7 = B5({
    conv2d_: function (e, t, n, r, a = "NHWC", i = [1, 1], o) {
      var s = L5(e, "x", "conv2d", "float32");
      var u = L5(t, "filter", "conv2d", "float32");
      var c = s;
      var l = false;
      if (s.rank === 3) {
        l = true;
        c = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]]);
      }
      F$(c.rank === 4, function () {
        return `Error in conv2d: input must be rank 4, but got rank ${c.rank}.`;
      });
      F$(u.rank === 4, function () {
        return `Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`;
      });
      K8("conv2d", r, o);
      var h = a === "NHWC" ? c.shape[3] : c.shape[1];
      F$(h === u.shape[2], function () {
        return `Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`;
      });
      F$(j8(n, i), function () {
        return `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`;
      });
      F$(H8(i), function () {
        return "Error in conv2D: Dilated rates should be larger than 0.";
      });
      F$(H8(n), function () {
        return "Error in conv2D: Strides should be larger than 0.";
      });
      var p = {
        x: c,
        filter: u
      };
      var f = {
        strides: n,
        pad: r,
        dataFormat: a,
        dilations: i,
        dimRoundingMode: o
      };
      var d = E5.runKernel(e1, p, f);
      if (l) {
        return X8(d, [d.shape[1], d.shape[2], d.shape[3]]);
      } else {
        return d;
      }
    }
  });
  var x7 = B5({
    conv1d_: function (e, t, n, r, a = "NWC", i = 1, o) {
      var s = L5(e, "x", "conv1d");
      var u = L5(t, "filter", "conv1d");
      var c = s;
      var l = false;
      if (s.rank === 2) {
        l = true;
        c = X8(s, [1, s.shape[0], s.shape[1]]);
      }
      F$(c.rank === 3, function () {
        return `Error in conv1d: input must be rank 3, but got rank ${c.rank}.`;
      });
      F$(u.rank === 3, function () {
        return `Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`;
      });
      K8("conv1d", r, o);
      F$(c.shape[2] === u.shape[1], function () {
        return `Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`;
      });
      F$(j8(n, i), function () {
        return `Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`;
      });
      F$(H8(i), function () {
        return "Error in conv1D: Dilated rates should be larger than 0.";
      });
      F$(H8(n), function () {
        return "Error in conv1D: Stride should be larger than 0.";
      });
      F$(a === "NWC", function () {
        return `Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`;
      });
      var h = X8(u, [1, u.shape[0], u.shape[1], u.shape[2]]);
      var p = X8(c, [c.shape[0], 1, c.shape[1], c.shape[2]]);
      var f = [1, n];
      var d = [1, i];
      var v = "NHWC";
      var m = b7(p, h, f, r, v, d, o);
      return X8(m, l ? [m.shape[2], m.shape[3]] : [m.shape[0], m.shape[2], m.shape[3]]);
    }
  });
  var k7 = B5({
    conv2DBackpropInput_: function (e, t, n, r, a, i = "NHWC", o) {
      F$(e.length === t.rank, function () {
        return `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`;
      });
      var s = e;
      var u = t;
      var c = false;
      if (t.rank === 3) {
        c = true;
        u = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]]);
        s = [1, e[0], e[1], e[2]];
      }
      F$(s.length === 4, function () {
        return `Error in conv2dDerInput: inShape must be length 4, but got length ${s.length}.`;
      });
      F$(u.rank === 4, function () {
        return `Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`;
      });
      F$(n.rank === 4, function () {
        return `Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`;
      });
      var l = i === "NHWC" ? s[3] : s[1];
      var h = i === "NHWC" ? u.shape[3] : u.shape[1];
      F$(l === n.shape[2], function () {
        return `Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`;
      });
      F$(h === n.shape[3], function () {
        return `Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`;
      });
      K8("conv2dDerInput", a, o);
      var p = {
        dy: u,
        filter: n
      };
      var f = {
        strides: r,
        pad: a,
        dataFormat: i,
        dimRoundingMode: o,
        inputShape: s
      };
      var d = E5.runKernel(n1, p, f);
      if (c) {
        return X8(d, [d.shape[1], d.shape[2], d.shape[3]]);
      } else {
        return d;
      }
    }
  });
  var w7 = B5({
    conv2dTranspose_: function (e, t, n, r, a, i) {
      var o = L5(e, "x", "conv2dTranspose");
      var s = L5(t, "filter", "conv2dTranspose");
      return k7(n, o, s, r, a, "NHWC", i);
    }
  });
  var I7 = B5({
    conv3d_: function (e, t, n, r, a = "NDHWC", i = [1, 1, 1]) {
      var o = L5(e, "x", "conv3d");
      var s = L5(t, "filter", "conv3d");
      var u = o;
      var c = false;
      if (o.rank === 4) {
        c = true;
        u = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]);
      }
      F$(u.rank === 5, function () {
        return `Error in conv3d: input must be rank 5, but got rank ${u.rank}.`;
      });
      F$(s.rank === 5, function () {
        return `Error in conv3d: filter must be rank 5, but got rank ${s.rank}.`;
      });
      F$(u.shape[4] === s.shape[3], function () {
        return `Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${s.shape[3]}.`;
      });
      F$(j8(n, i), function () {
        return `Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`;
      });
      F$(a === "NDHWC", function () {
        return `Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`;
      });
      F$(H8(i), function () {
        return "Error in conv3D: Dilated rates should be larger than 0.";
      });
      F$(H8(n), function () {
        return "Error in conv3D: Strides should be larger than 0.";
      });
      var l = {
        x: u,
        filter: s
      };
      var h = {
        strides: n,
        pad: r,
        dataFormat: a,
        dilations: i
      };
      var p = E5.runKernel(r1, l, h);
      if (c) {
        return X8(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]);
      } else {
        return p;
      }
    }
  });
  var N7 = B5({
    conv3DBackpropInput_: function (e, t, n, r, a) {
      F$(e.length === t.rank, function () {
        return `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`;
      });
      var i = e;
      var o = t;
      var s = false;
      if (t.rank === 4) {
        s = true;
        o = X8(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]);
        i = [1, e[0], e[1], e[2], e[3]];
      }
      var u = i[4];
      var c = o.shape[4];
      F$(i.length === 5, function () {
        return `Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`;
      });
      F$(o.rank === 5, function () {
        return `Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`;
      });
      F$(n.rank === 5, function () {
        return `Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`;
      });
      F$(u === n.shape[3], function () {
        return `Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`;
      });
      F$(c === n.shape[4], function () {
        return `Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`;
      });
      var l = {
        dy: o,
        filter: n
      };
      var h = {
        pad: a,
        strides: r,
        inputShape: i
      };
      var p = E5.runKernel(i1, l, h);
      if (s) {
        return X8(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]);
      } else {
        return p;
      }
    }
  });
  var S7 = B5({
    conv3dTranspose_: function (e, t, n, r, a) {
      var i = L5(e, "x", "conv3dTranspose");
      var o = L5(t, "filter", "conv3dTranspose");
      return N7(n, i, o, r, a);
    }
  });
  var T7 = B5({
    cos_: function (e) {
      var t = {
        x: L5(e, "x", "cos", "float32")
      };
      return E5.runKernel(o1, t);
    }
  });
  var E7 = B5({
    cosh_: function (e) {
      var t = {
        x: L5(e, "x", "cosh", "float32")
      };
      return E5.runKernel(s1, t);
    }
  });
  var C7 = B5({
    cumprod_: function (e, t = 0, n = false, r = false) {
      var a = L5(e, "x", "cumprod");
      var i = {
        x: a
      };
      var o = {
        axis: t,
        exclusive: n,
        reverse: r
      };
      return E5.runKernel(u1, i, o);
    }
  });
  var A7 = B5({
    cumsum_: function (e, t = 0, n = false, r = false) {
      var a = L5(e, "x", "cumsum");
      var i = {
        x: a
      };
      var o = {
        axis: t,
        exclusive: n,
        reverse: r
      };
      return E5.runKernel(c1, i, o);
    }
  });
  var R7 = B5({
    denseBincount_: function (e, t, n, r = false) {
      var a = L5(e, "x", "denseBincount");
      var i = L5(t, "weights", "denseBincount");
      F$(a.dtype === "int32", function () {
        return `Error in denseBincount: input dtype must be int32, but got ${a.dtype}`;
      });
      F$(a.rank <= 2, function () {
        return `Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`;
      });
      F$(n >= 0, function () {
        return `size must be non-negative, but got ${n}.`;
      });
      F$(i.size === a.size || i.size === 0, function () {
        return `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${i.shape}.`;
      });
      var o = {
        x: a,
        weights: i
      };
      var s = {
        size: n,
        binaryOutput: r
      };
      return E5.runKernel(h1, o, s);
    }
  });
  var _7 = B5({
    depthToSpace_: function (e, t, n = "NHWC") {
      var r = L5(e, "x", "depthToSpace", "float32");
      var a = n === "NHWC" ? r.shape[1] : r.shape[2];
      var i = n === "NHWC" ? r.shape[2] : r.shape[3];
      var o = n === "NHWC" ? r.shape[3] : r.shape[1];
      F$(t > 1, function () {
        return `blockSize should be > 1 for depthToSpace, but was: ${t}`;
      });
      F$(a * t >= 0, function () {
        return `Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`;
      });
      F$(i * t >= 0, function () {
        return `Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${r.shape}`;
      });
      F$(o % (t * t) == 0, function () {
        return `Dimension size must be evenly divisible by ${t * t} but is ${o} for depthToSpace with input shape ${r.shape}`;
      });
      var s = {
        x: r
      };
      var u = {
        blockSize: t,
        dataFormat: n
      };
      return E5.runKernel(p1, s, u);
    }
  });
  var O7 = B5({
    depthwiseConv2d_: function (e, t, n, r, a = "NHWC", i = [1, 1], o) {
      var s = L5(e, "x", "depthwiseConv2d", "float32");
      var u = L5(t, "filter", "depthwiseConv2d", "float32");
      var c = s;
      var l = false;
      if (s.rank === 3) {
        l = true;
        c = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]]);
      }
      F$(c.rank === 4, function () {
        return `Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`;
      });
      F$(u.rank === 4, function () {
        return `Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`;
      });
      var h = a === "NHWC" ? c.shape[3] : c.shape[1];
      F$(h === u.shape[2], function () {
        return `Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`;
      });
      K8("depthwiseConv2d", r, o);
      var p = {
        x: c,
        filter: u
      };
      var f = {
        strides: n,
        pad: r,
        dataFormat: a,
        dilations: i,
        dimRoundingMode: o
      };
      var d = E5.runKernel(f1, p, f);
      if (l) {
        return X8(d, [d.shape[1], d.shape[2], d.shape[3]]);
      } else {
        return d;
      }
    }
  });
  var F7 = B5({
    diag_: function (e) {
      var t = {
        x: L5(e, "x", "diag")
      };
      return E5.runKernel(m1, t);
    }
  });
  var D7 = B5({
    dilation2d_: function (e, t, n, r, a = [1, 1], i = "NHWC") {
      var o = L5(e, "x", "dilation2d");
      var s = L5(t, "filter", "dilation2d");
      F$(o.rank === 3 || o.rank === 4, function () {
        return `Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`;
      });
      F$(s.rank === 3, function () {
        return `Error in dilation2d: filter must be rank 3, but got rank ${s.rank}.`;
      });
      F$(i === "NHWC", function () {
        return `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`;
      });
      var u = o;
      var c = false;
      if (o.rank === 3) {
        u = X8(o, [1, o.shape[0], o.shape[1], o.shape[2]]);
        c = true;
      }
      F$(u.shape[3] === s.shape[2], function () {
        return `Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${s.shape[2]}`;
      });
      var l = {
        x: u,
        filter: s
      };
      var h = {
        strides: n,
        pad: r,
        dilations: a
      };
      var p = E5.runKernel(g1, l, h);
      if (c) {
        return X8(p, [p.shape[1], p.shape[2], p.shape[3]]);
      } else {
        return p;
      }
    }
  });
  function M7(e, t) {
    for (var n = e.length, r = [], a = 0; a < n; a++) {
      var i = n - 1 - a;
      var o = e[i] || 1;
      if ((t[t.length - 1 - a] || 1) > 1 && o === 1) {
        r.unshift(i);
      }
    }
    return r;
  }
  function L7(e, t) {
    var n = [];
    for (var r = 0; r < t.length; r++) {
      var a = e[e.length - r - 1];
      var i = t.length - r - 1;
      var o = t[i];
      if (a == null || a === 1 && o > 1) {
        n.unshift(i);
      }
    }
    return n;
  }
  function z7(e, t) {
    for (var n = Math.max(e.length, t.length), r = new Array(n), a = 0; a < n; a++) {
      var i = e[e.length - a - 1];
      if (i == null) {
        i = 1;
      }
      var o = t[t.length - a - 1];
      if (o == null) {
        o = 1;
      }
      if (i === 1) {
        r[n - a - 1] = o;
      } else if (o === 1) {
        r[n - a - 1] = i;
      } else {
        if (i !== o) {
          var s = `Operands could not be broadcast together with shapes ${e} and ${t}.`;
          throw Error(s);
        }
        r[n - a - 1] = i;
      }
    }
    return r;
  }
  var P7 = {
    __proto__: null,
    assertAndGetBroadcastShape: z7,
    getBroadcastDims: M7,
    getReductionAxes: L7
  };
  var B7 = B5({
    equal_: function (e, t) {
      var n = L5(e, "a", "equal", "string_or_numeric");
      var r = L5(t, "b", "equal", "string_or_numeric");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(T1, i);
    }
  });
  var W7 = B5({
    where_: function (e, t, n) {
      var r = L5(t, "a", "where");
      var a = L5(n, "b", "where");
      var i = L5(e, "condition", "where", "bool");
      var o = z7(z7(i.shape, r.shape), a.shape);
      var s = {
        condition: h7(i, o),
        t: h7(r, o),
        e: h7(a, o)
      };
      return E5.runKernel(Y2, s);
    }
  });
  var U7 = B5({
    zerosLike_: function (e) {
      var t = {
        x: L5(e, "x", "zerosLike")
      };
      return E5.runKernel(R3, t);
    }
  });
  var V7 = B5({
    divNoNan_: function (e, t) {
      var n = L5(e, "a", "div");
      var r = L5(t, "b", "div");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      var i = m8(n, r);
      var o = U7(i);
      var s = B7(r, o);
      return W7(s, o, i);
    }
  });
  var G7 = B5({
    dot_: function (e, t) {
      var n = L5(e, "t1", "dot");
      var r = L5(t, "t2", "dot");
      F$((n.rank === 1 || n.rank === 2) && (r.rank === 1 || r.rank === 2), function () {
        return `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`;
      });
      var a = n.rank === 1 ? n.size : n.shape[1];
      var i = r.rank === 1 ? r.size : r.shape[0];
      F$(a === i, function () {
        return `Error in dot: inner dimensions of inputs must match, but got ${a} and ${i}.`;
      });
      if (n.rank === 1 && r.rank === 1) {
        var o = X8(n, [1, -1]);
        var s = X8(r, [-1, 1]);
        var u = Q8(o, s);
        return X8(u, []);
      }
      if (n.rank === 1 && r.rank === 2) {
        var c = X8(n, [1, -1]);
        var l = X8(r, [r.shape[0], r.shape[1]]);
        var h = Q8(c, l);
        return X8(h, [h.size]);
      }
      if (n.rank === 2 && r.rank === 1) {
        var p = X8(r, [-1, 1]);
        var f = Q8(n, p);
        return X8(f, [f.size]);
      }
      var d = X8(r, [r.shape[0], r.shape[1]]);
      return Q8(n, d);
    }
  });
  var j7 = B5({
    einsum_: function (e) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) {
        n[r - 1] = arguments[r];
      }
      var a = n.map(function (e, t) {
        return L5(e, `tensors${t}`, "einsum");
      });
      var i = {
        equation: e
      };
      return E5.runKernel(w1, a, i);
    }
  });
  var H7 = B5({
    elu_: function (e) {
      var t = {
        x: L5(e, "x", "elu", "float32")
      };
      return E5.runKernel(I1, t);
    }
  });
  var q7 = B5({
    ensureShape_: function (e, t) {
      var n = L5(e, "x", "ensureShape", "string_or_numeric");
      if (!z$(n.shape, t)) {
        throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);
      }
      return e;
    }
  });
  var K7 = B5({
    erf_: function (e) {
      var t = L5(e, "x", "erf");
      F$(t.dtype === "int32" || t.dtype === "float32", function () {
        return "Input dtype must be `int32` or `float32`.";
      });
      if (t.dtype === "int32") {
        t = h8(t, "float32");
      }
      var n = {
        x: t
      };
      return E5.runKernel(S1, n);
    }
  });
  function X7(e, t) {
    for (var n = 0; n < e.length; ++n) {
      if (e[e.length - n - 1] !== t - 1 - n) {
        return false;
      }
    }
    return true;
  }
  function Y7(e, t, n) {
    for (var r = e.length + t.length, a = [], i = 0, o = 0, s = 0; s < r; s++) {
      if (n.indexOf(s) === -1) {
        a.push(e[i++]);
      } else {
        a.push(t[o++]);
      }
    }
    return a;
  }
  function J7(e, t) {
    var n = [];
    for (var r = e.length, a = 0; a < r; a++) {
      if (t.indexOf(a) === -1) {
        n.push(e[a]);
      }
    }
    var i = t.map(function (t) {
      return e[t];
    });
    return [n, i];
  }
  function Z7(e, t) {
    return Y7(e, t.map(function (e) {
      return 1;
    }), t);
  }
  function Q7(e, t, n) {
    F$(X7(t, n), function () {
      return `${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`;
    });
  }
  function $7(e, t) {
    if (X7(e, t)) {
      return null;
    }
    var n = [];
    for (var r = 0; r < t; ++r) {
      if (e.indexOf(r) === -1) {
        n.push(r);
      }
    }
    e.forEach(function (e) {
      return n.push(e);
    });
    return n;
  }
  function e9(e) {
    return e.map(function (e, t) {
      return [t, e];
    }).sort(function (e, t) {
      return e[1] - t[1];
    }).map(function (e) {
      return e[0];
    });
  }
  function t9(e, t) {
    var n = [];
    for (var r = t - e; r < t; ++r) {
      n.push(r);
    }
    return n;
  }
  var n9 = B5({
    max_: function (e, t = null, n = false) {
      var r = L5(e, "x", "max");
      var a = {
        x: r
      };
      var i = {
        reductionIndices: t,
        keepDims: n
      };
      return E5.runKernel(a2, a, i);
    }
  });
  var r9 = B5({
    min_: function (e, t = null, n = false) {
      var r = L5(e, "x", "min");
      var a = {
        x: r
      };
      var i = {
        axis: t,
        keepDims: n
      };
      return E5.runKernel(p2, a, i);
    }
  });
  var a9 = B5({
    pow_: function (e, t) {
      var n = L5(e, "base", "pow");
      var r = L5(t, "exp", "pow");
      var a = S(v5(n, r), 2);
      var i = {
        a: n = a[0],
        b: r = a[1]
      };
      return E5.runKernel(E2, i);
    }
  });
  function i9(e, t) {
    if ((U4(e) && t !== "string" || Array.isArray(e)) && t !== "complex64") {
      throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    }
    if (t === "string" && U4(e) && !(e instanceof Uint8Array)) {
      throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    }
    return U5(e, [], [], t);
  }
  var o9 = B5({
    sqrt_: function (e) {
      var t = {
        x: L5(e, "x", "sqrt", "float32")
      };
      return E5.runKernel(r3, t);
    }
  });
  var s9 = B5({
    square_: function (e) {
      var t = L5(e, "x", "square");
      return E5.runKernel("Square", {
        x: t
      }, {});
    }
  });
  var u9 = B5({
    sum_: function (e, t = null, n = false) {
      var r = L5(e, "x", "sum");
      if (r.dtype === "bool") {
        r = h8(r, "int32");
      }
      var a = {
        x: r
      };
      var i = {
        axis: t,
        keepDims: n
      };
      return E5.runKernel(a3, a, i);
    }
  });
  function c9(e, t, n = null) {
    if (e.rank === 0) {
      return y8(e);
    }
    if (e.rank !== 1 && n === null) {
      return c9(X8(e, [-1]), t, n);
    }
    if (e.rank === 1 || typeof n == "number" || Array.isArray(n) && n.length === 1) {
      if (t === 1) {
        return u9(y8(e), n);
      }
      if (t === Infinity) {
        return n9(y8(e), n);
      }
      if (t === -Infinity) {
        return r9(y8(e), n);
      }
      if (t === "euclidean" || t === 2) {
        return o9(u9(a9(y8(e), i9(2, "int32")), n));
      }
      throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    if (Array.isArray(n) && n.length === 2) {
      if (t === 1) {
        return n9(u9(y8(e), n[0]), n[1] - 1);
      }
      if (t === Infinity) {
        return n9(u9(y8(e), n[1]), n[0]);
      }
      if (t === -Infinity) {
        return r9(u9(y8(e), n[1]), n[0]);
      }
      if (t === "fro" || t === "euclidean") {
        return o9(u9(s9(e), n));
      }
      throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    throw new Error(`Error in norm: invalid axis: ${n}`);
  }
  var l9 = B5({
    norm_: function (e, t = "euclidean", n = null, r = false) {
      var a = c9(e = L5(e, "x", "norm"), t, n);
      var i = a.shape;
      if (r) {
        var o = j$(n, e.shape);
        i = Z7(a.shape, o);
      }
      return X8(a, i);
    }
  });
  var h9 = B5({
    euclideanNorm_: function (e, t = null, n = false) {
      return l9(e, "euclidean", t, n);
    }
  });
  var p9 = B5({
    exp_: function (e) {
      var t = {
        x: L5(e, "x", "exp")
      };
      return E5.runKernel(E1, t);
    }
  });
  var f9 = B5({
    expandDims_: function (e, t = 0) {
      var n = L5(e, "x", "expandDims", "string_or_numeric");
      F$(t <= n.rank, function () {
        return "Axis must be <= rank of the tensor";
      });
      var r = {
        input: n
      };
      var a = {
        dim: t
      };
      return E5.runKernel(C1, r, a);
    }
  });
  var d9 = B5({
    expm1_: function (e) {
      var t = {
        x: L5(e, "x", "expm1")
      };
      return E5.runKernel(A1, t);
    }
  });
  var v9 = B5({
    tile_: function (e, t) {
      var n = L5(e, "x", "tile", "string_or_numeric");
      F$(n.rank === t.length, function () {
        return `Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`;
      });
      var r = {
        x: n
      };
      var a = {
        reps: t
      };
      return E5.runKernel(I3, r, a);
    }
  });
  var m9 = B5({
    eye_: function (e, t, n, r = "float32") {
      if (t == null) {
        t = e;
      }
      var a = l8([e, t], r);
      for (var i = e <= t ? e : t, o = 0; o < i; ++o) {
        a.set(1, o, o);
      }
      var s = X8(a.toTensor(), [e, t]);
      if (n == null) {
        return s;
      }
      if (n.length === 1) {
        return v9(f9(s, 0), [n[0], 1, 1]);
      }
      if (n.length === 2) {
        return v9(f9(f9(s, 0), 0), [n[0], n[1], 1, 1]);
      }
      if (n.length === 3) {
        return v9(f9(f9(f9(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
      }
      throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`);
    }
  });
  var g9 = B5({
    floor_: function (e) {
      var t = {
        x: L5(e, "x", "floor", "float32")
      };
      return E5.runKernel(F1, t);
    }
  });
  var y9 = B5({
    gather_: function (e, t, n = 0, r = 0) {
      var a = L5(e, "x", "gather");
      var i = L5(t, "indices", "gather", "int32");
      var o = {
        x: a,
        indices: i
      };
      var s = {
        axis: n,
        batchDims: r
      };
      return E5.runKernel(L1, o, s);
    }
  });
  var b9 = B5({
    greater_: function (e, t) {
      var n = L5(e, "a", "greater", "string_or_numeric");
      var r = L5(t, "b", "greater", "string_or_numeric");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(P1, i);
    }
  });
  var x9 = B5({
    greaterEqual_: function (e, t) {
      var n = L5(e, "a", "greaterEqual", "string_or_numeric");
      var r = L5(t, "b", "greaterEqual", "string_or_numeric");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(B1, i);
    }
  });
  var k9 = B5({
    imag_: function (e) {
      var t = {
        input: L5(e, "input", "imag")
      };
      return E5.runKernel(V1, t);
    }
  });
  var w9 = B5({
    isFinite_: function (e) {
      var t = {
        x: L5(e, "x", "isFinite")
      };
      return E5.runKernel(G1, t);
    }
  });
  var I9 = B5({
    isInf_: function (e) {
      var t = {
        x: L5(e, "x", "isInf")
      };
      return E5.runKernel(j1, t);
    }
  });
  var N9 = B5({
    isNaN_: function (e) {
      var t = {
        x: L5(e, "x", "isNaN")
      };
      return E5.runKernel(H1, t);
    }
  });
  var S9 = B5({
    leakyRelu_: function (e, t = 0.2) {
      var n = L5(e, "x", "leakyRelu");
      var r = {
        x: n
      };
      var a = {
        alpha: t
      };
      return E5.runKernel(q1, r, a);
    }
  });
  var T9 = B5({
    less_: function (e, t) {
      var n = L5(e, "a", "less", "string_or_numeric");
      var r = L5(t, "b", "less", "string_or_numeric");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(K1, i);
    }
  });
  var E9 = B5({
    lessEqual_: function (e, t) {
      var n = L5(e, "a", "lessEqual", "string_or_numeric");
      var r = L5(t, "b", "lessEqual", "string_or_numeric");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(X1, i);
    }
  });
  function C9(e, t, n) {
    if (n <= 0) {
      throw new Error("The number of values should be positive.");
    }
    var r = {
      start: e,
      stop: t,
      num: n
    };
    return E5.runKernel(Y1, {}, r);
  }
  var A9 = B5({
    localResponseNormalization_: function (e, t = 5, n = 1, r = 1, a = 0.5) {
      var i = L5(e, "x", "localResponseNormalization");
      F$(i.rank === 4 || i.rank === 3, function () {
        return `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`;
      });
      F$(B$(t), function () {
        return `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`;
      });
      var o = i;
      var s = false;
      if (i.rank === 3) {
        s = true;
        o = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]]);
      }
      var u = {
        x: o
      };
      var c = {
        depthRadius: t,
        bias: n,
        alpha: r,
        beta: a
      };
      var l = E5.runKernel(n2, u, c);
      if (s) {
        return X8(l, [l.shape[1], l.shape[2], l.shape[3]]);
      } else {
        return l;
      }
    }
  });
  var R9 = B5({
    log_: function (e) {
      var t = {
        x: L5(e, "x", "log", "float32")
      };
      return E5.runKernel(J1, t);
    }
  });
  var _9 = B5({
    log1p_: function (e) {
      var t = {
        x: L5(e, "x", "log1p")
      };
      return E5.runKernel(Z1, t);
    }
  });
  function O9(e, t) {
    F$(r0(e), function () {
      return "The f passed in variableGrads(f) must be a function";
    });
    F$(t == null || Array.isArray(t) && t.every(function (e) {
      return e instanceof c5;
    }), function () {
      return "The varList passed in variableGrads(f, varList) must be an array of variables";
    });
    var n = t != null;
    if (!n) {
      t = [];
      for (var r in E5.registeredVariables) {
        t.push(E5.registeredVariables[r]);
      }
    }
    var a = n ? t.filter(function (e) {
      return !e.trainable;
    }) : null;
    var i = t.length;
    t = t.filter(function (e) {
      return e.trainable;
    });
    F$(t.length > 0, function () {
      return `variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`;
    });
    var o = E5.gradients(e, t, null, true);
    var s = o.value;
    var u = o.grads;
    F$(u.some(function (e) {
      return e != null;
    }), function () {
      return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
    });
    F$(s.rank === 0, function () {
      return `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`;
    });
    var c = {};
    t.forEach(function (e, t) {
      if (u[t] != null) {
        c[e.name] = u[t];
      }
    });
    if (a != null) {
      a.forEach(function (e) {
        return c[e.name] = null;
      });
    }
    return {
      value: s,
      grads: c
    };
  }
  function F9(e) {
    return E5.customGrad(e);
  }
  function D9(e) {
    if (e.filter(function (e) {
      return e == null;
    }).length > 0) {
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
    }
  }
  var M9 = B5({
    neg_: function (e) {
      var t = {
        x: L5(e, "x", "neg")
      };
      return E5.runKernel(y2, t);
    }
  });
  var L9 = B5({
    softplus_: function (e) {
      var t = {
        x: L5(e, "x", "softplus")
      };
      return E5.runKernel(n3, t);
    }
  });
  var z9 = B5({
    logSigmoid_: function (e) {
      var t = L5(e, "x", "logSigmoid");
      var n = F9(function (e) {
        return {
          value: M9(L9(M9(e))),
          gradFunc: function (t) {
            return g8(t, $8(M9(e)));
          }
        };
      });
      return n(t);
    }
  });
  var P9 = B5({
    sub_: function (e, t) {
      var n = L5(e, "a", "sub");
      var r = L5(t, "b", "sub");
      var a = S(v5(n, r), 2);
      var i = {
        a: n = a[0],
        b: r = a[1]
      };
      return E5.runKernel(x3, i);
    }
  });
  var B9 = B5({
    logSoftmax_: function (e, t = -1) {
      var n = L5(e, "logits", "logSoftmax");
      if (t === -1) {
        t = n.rank - 1;
      }
      if (t !== n.rank - 1) {
        throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);
      }
      var r = F9(function (e, n) {
        var r = n9(e, t, true);
        var a = P9(e, r);
        var i = P9(h8(a, "float32"), R9(u9(p9(a), t, true)));
        n([i]);
        return {
          value: i,
          gradFunc: function (e, n) {
            var r = S(n, 1)[0];
            var a = p9(r);
            return P9(e, g8(u9(e, t, true), a));
          }
        };
      });
      return r(n);
    }
  });
  var W9 = B5({
    logSumExp_: function (e, t = null, n = false) {
      var r = L5(e, "x", "logSumExp");
      var a = j$(t, r.shape);
      var i = n9(r, a, true);
      var o = P9(r, i);
      var s = p9(o);
      var u = u9(s, a);
      var c = R9(u);
      var l = d8(X8(i, c.shape), c);
      if (n) {
        var h = Z7(l.shape, a);
        return X8(l, h);
      }
      return l;
    }
  });
  var U9 = B5({
    logicalAnd_: function (e, t) {
      var n = L5(e, "a", "logicalAnd", "bool");
      var r = L5(t, "b", "logicalAnd", "bool");
      z7(n.shape, r.shape);
      var a = {
        a: n,
        b: r
      };
      return E5.runKernel(Q1, a);
    }
  });
  var V9 = B5({
    logicalNot_: function (e) {
      var t = {
        x: L5(e, "x", "logicalNot", "bool")
      };
      return E5.runKernel($1, t);
    }
  });
  var G9 = B5({
    logicalOr_: function (e, t) {
      var n = L5(e, "a", "logicalOr", "bool");
      var r = L5(t, "b", "logicalOr", "bool");
      z7(n.shape, r.shape);
      var a = {
        a: n,
        b: r
      };
      return E5.runKernel(e2, a);
    }
  });
  var j9 = B5({
    logicalXor_: function (e, t) {
      var n = L5(e, "a", "logicalXor", "bool");
      var r = L5(t, "b", "logicalXor", "bool");
      z7(n.shape, r.shape);
      return U9(G9(e, t), V9(U9(e, t)));
    }
  });
  var H9 = 2147483648;
  var q9 = B5({
    searchSorted_: function (e, t, n = "left") {
      var r = L5(e, "sortedSequence", "searchSorted");
      var a = L5(t, "values", "searchSorted");
      var i = r.shape[r.shape.length - 1];
      var o = a.shape[a.shape.length - 1];
      var s = X8(r, [-1, i]);
      var u = X8(a, [-1, o]);
      if (s.rank < 2) {
        throw new Error("Sorted input argument must be at least 2-dimensional");
      }
      if (s.shape[0] !== u.shape[0]) {
        throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
      }
      if (L$(u.shape) >= H9) {
        throw new Error(`values tensor size must less than ${H9}`);
      }
      if (s.shape[1] >= H9) {
        throw new Error(`trailing dim_size must less than ${H9} for int32 output type, was ${s.shape[1]}`);
      }
      var c = {
        sortedSequence: s,
        values: u
      };
      var l = {
        side: n
      };
      return E5.runKernel(X2, c, l);
    }
  });
  function K9(e, t) {
    return q9(e, t, "left");
  }
  var X9 = B5({
    maxPool_: function (e, t, n, r, a) {
      var i = L5(e, "x", "maxPool");
      var o = i;
      var s = false;
      if (i.rank === 3) {
        s = true;
        o = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]]);
      }
      F$(o.rank === 4, function () {
        return `Error in maxPool: input must be rank 4 but got rank ${o.rank}.`;
      });
      F$(j8(n, 1), function () {
        return `Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${1}'`;
      });
      K8("maxPool", r, a);
      var u = {
        x: o
      };
      var c = {
        filterSize: t,
        strides: n,
        pad: r,
        dimRoundingMode: a
      };
      var l = E5.runKernel(o2, u, c);
      if (s) {
        return X8(l, [l.shape[1], l.shape[2], l.shape[3]]);
      } else {
        return l;
      }
    }
  });
  var Y9 = B5({
    maxPool3d_: function (e, t = [1, 1, 1], n, r, a, i = "NDHWC") {
      var o = L5(e, "x", "maxPool3d");
      var s = o;
      var u = false;
      if (o.rank === 4) {
        u = true;
        s = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]);
      }
      F$(s.rank === 5, function () {
        return `Error in maxPool3d: x must be rank 5 but got rank ${s.rank}.`;
      });
      F$(i === "NDHWC", function () {
        return `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`;
      });
      K8("maxPool3d", r, a);
      var c = {
        x: s
      };
      var l = {
        filterSize: t,
        strides: n,
        pad: r,
        dimRoundingMode: a,
        dataFormat: i
      };
      var h = E5.runKernel(u2, c, l);
      if (u) {
        return X8(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]);
      } else {
        return h;
      }
    }
  });
  var J9 = B5({
    maxPoolWithArgmax_: function (e, t, n, r, a = false) {
      var i = L5(e, "x", "maxPoolWithArgmax");
      var o = {
        x: i
      };
      var s = {
        filterSize: t,
        strides: n,
        pad: r,
        includeBatchInIndex: a
      };
      var u = E5.runKernel(l2, o, s);
      return {
        result: u[0],
        indexes: u[1]
      };
    }
  });
  var Z9 = B5({
    maximum_: function (e, t) {
      var n = L5(e, "a", "maximum");
      var r = L5(t, "b", "maximum");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      if (n.dtype === "bool") {
        n = h8(n, "int32");
        r = h8(r, "int32");
      }
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(i2, i);
    }
  });
  var Q9 = B5({
    mean_: function (e, t = null, n = false) {
      var r = L5(e, "x", "mean");
      var a = {
        x: r
      };
      var i = {
        axis: t,
        keepDims: n
      };
      return E5.runKernel(h2, a, i);
    }
  });
  function $9(e, t = "float32") {
    p0(e);
    if (t === "complex64") {
      var n = $9(e, "float32");
      var r = $9(e, "float32");
      return W5(n, r);
    }
    var a = l0(L$(e), t);
    return E5.makeTensor(a, e, t);
  }
  function eee(e, t = "float32") {
    p0(e);
    if (t === "complex64") {
      var n = eee(e, "float32");
      var r = $9(e, "float32");
      return W5(n, r);
    }
    var a = c0(L$(e), t);
    return E5.makeTensor(a, e, t);
  }
  function tee(e, t, n = {}) {
    var r = n.indexing;
    var a = r === undefined ? "xy" : r;
    if (a !== "xy" && a !== "ij") {
      throw new TypeError(`${a} is not a valid third argument to meshgrid`);
    }
    if (e === undefined) {
      return [];
    }
    var i = L5(e, "x", "meshgrid", e instanceof n5 ? e.dtype : "float32");
    if (t === undefined) {
      return [i];
    }
    var o = L5(t, "y", "meshgrid", t instanceof n5 ? t.dtype : "float32");
    var s = L$(i.shape);
    var u = L$(o.shape);
    if (a === "xy") {
      i = X8(i, [1, -1]);
      o = X8(o, [-1, 1]);
      return [Q8(eee([u, 1], i.dtype), i), Q8(o, eee([1, s], o.dtype))];
    } else {
      i = X8(i, [-1, 1]);
      o = X8(o, [1, -1]);
      return [Q8(i, eee([1, u], i.dtype)), Q8(eee([s, 1], o.dtype), o)];
    }
  }
  var nee = B5({
    minimum_: function (e, t) {
      var n = L5(e, "a", "minimum");
      var r = L5(t, "b", "minimum");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      if (n.dtype === "bool") {
        n = h8(n, "int32");
        r = h8(r, "int32");
      }
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(f2, i);
    }
  });
  var ree = B5({
    mirrorPad_: function (e, t, n) {
      F$(n === "reflect" || n === "symmetric", function () {
        return `Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`;
      });
      var r = L5(e, "x", "mirrorPad");
      if (r.rank === 0) {
        throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
      }
      F$(t.length === r.rank, function () {
        return `Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`;
      });
      var a = n === "reflect" ? 1 : 0;
      var i = function (e) {
        F$(t[e].length === 2, function () {
          return "Invalid number of paddings. Must be length of 2 each.";
        });
        F$(t[e][0] >= 0 && t[e][0] <= r.shape[e] - a && t[e][1] >= 0 && t[e][1] <= r.shape[e] - a, function () {
          return `Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e] - a} or less than 0 for input of shape ${r.shape}`;
        });
      };
      for (var o = 0; o < r.rank; o++) {
        i(o);
      }
      var s = {
        paddings: t,
        mode: n
      };
      var u = {
        x: r
      };
      return E5.runKernel(d2, u, s);
    }
  });
  var aee = B5({
    mod_: function (e, t) {
      var n = L5(e, "a", "mod");
      var r = L5(t, "b", "mod");
      var a = S(v5(n, r), 2);
      var i = {
        a: n = a[0],
        b: r = a[1]
      };
      return E5.runKernel(v2, i);
    }
  });
  var iee = B5({
    moments_: function (e, t = null, n = false) {
      var r = j$(t, (e = L5(e, "x", "moments")).shape);
      var a = Q9(e, r, n);
      var i = a.shape;
      if (!n) {
        i = Z7(a.shape, r);
      }
      var o = s9(P9(h8(e, "float32"), X8(a, i)));
      var s = Q9(o, r, n);
      return {
        mean: a,
        variance: s
      };
    }
  });
  var oee = B5({
    multiRNNCell_: function (e, t, n, r) {
      var a = L5(t, "data", "multiRNNCell");
      var i = z5(n, "c", "multiRNNCell");
      var o = z5(r, "h", "multiRNNCell");
      var s = a;
      var u = [];
      for (var c = 0; c < e.length; c++) {
        var l = e[c](s, i[c], o[c]);
        u.push(l[0]);
        u.push(l[1]);
        s = l[1];
      }
      var h = [];
      var p = [];
      for (var f = 0; f < u.length; f += 2) {
        h.push(u[f]);
        p.push(u[f + 1]);
      }
      return [h, p];
    }
  });
  var see = B5({
    multinomial_: function (e, t, n, r = false) {
      var a = L5(e, "logits", "multinomial");
      var i = a.size;
      var o = a.rank;
      if (i < 2) {
        throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);
      }
      if (o > 2) {
        throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);
      }
      n = n || Math.random();
      var s = o === 1 ? X8(a, [1, -1]) : a;
      var u = {
        logits: s
      };
      var c = {
        numSamples: t,
        seed: n,
        normalized: r
      };
      var l = E5.runKernel(m2, u, c);
      if (o === 1) {
        return X8(l, [l.size]);
      } else {
        return l;
      }
    }
  });
  var uee = B5({
    notEqual_: function (e, t) {
      var n = L5(e, "a", "notEqual", "string_or_numeric");
      var r = L5(t, "b", "notEqual", "string_or_numeric");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(b2, i);
    }
  });
  var cee = B5({
    oneHot_: function (e, t, n = 1, r = 0, a = "int32") {
      if (t < 2) {
        throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
      }
      var i = L5(e, "indices", "oneHot", "int32");
      var o = {
        indices: i
      };
      var s = {
        dtype: a,
        depth: t,
        onValue: n,
        offValue: r
      };
      return E5.runKernel(N2, o, s);
    }
  });
  var lee = B5({
    onesLike_: function (e) {
      var t = {
        x: L5(e, "x", "onesLike")
      };
      return E5.runKernel(I2, t);
    }
  });
  var hee = B5({
    outerProduct_: function (e, t) {
      var n = L5(e, "v1", "outerProduct");
      var r = L5(t, "v2", "outerProduct");
      F$(n.rank === 1 && r.rank === 1, function () {
        return `Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`;
      });
      var a = X8(n, [-1, 1]);
      var i = X8(r, [1, -1]);
      return Q8(a, i);
    }
  });
  var pee = B5({
    pad_: function (e, t, n = 0) {
      var r = L5(e, "x", "pad");
      if (r.rank === 0) {
        throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
      }
      var a = {
        paddings: t,
        constantValue: n
      };
      var i = {
        x: r
      };
      return E5.runKernel(T2, i, a);
    }
  });
  var fee = B5({
    pad1d_: function (e, t, n = 0) {
      F$(t.length === 2, function () {
        return "Invalid number of paddings. Must be length of 2.";
      });
      return pee(e, [t], n);
    }
  });
  var dee = B5({
    pad2d_: function (e, t, n = 0) {
      F$(t.length === 2 && t[0].length === 2 && t[1].length === 2, function () {
        return "Invalid number of paddings. Must be length of 2 each.";
      });
      return pee(e, t, n);
    }
  });
  var vee = B5({
    pad3d_: function (e, t, n = 0) {
      F$(t.length === 3 && t[0].length === 2 && t[1].length === 2 && t[2].length === 2, function () {
        return "Invalid number of paddings. Must be length of 2 each.";
      });
      return pee(e, t, n);
    }
  });
  var mee = B5({
    pad4d_: function (e, t, n = 0) {
      F$(t.length === 4 && t[0].length === 2 && t[1].length === 2 && t[2].length === 2 && t[3].length === 2, function () {
        return "Invalid number of paddings. Must be length of 2 each.";
      });
      return pee(e, t, n);
    }
  });
  var gee = B5({
    spaceToBatchND_: function (e, t, n) {
      var r = L5(e, "x", "spaceToBatchND");
      F$(r.rank >= 1 + t.length, function () {
        return `input rank ${r.rank} should be > than [blockShape] ${t.length}`;
      });
      F$(n.length === t.length, function () {
        return `paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`;
      });
      F$(r.shape.reduce(function (e, r, a) {
        if (a > 0 && a <= t.length) {
          return e && (r + n[a - 1][0] + n[a - 1][1]) % t[a - 1] == 0;
        } else {
          return e;
        }
      }, true), function () {
        return `input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`;
      });
      var a = {
        x: r
      };
      var i = {
        blockShape: t,
        paddings: n
      };
      return E5.runKernel(i3, a, i);
    }
  });
  var yee = B5({
    pool_: function (e, t, n, r, a, i, o) {
      if (a == null) {
        a = [1, 1];
      }
      if (i == null) {
        i = 1;
      }
      if (r === 0) {
        r = "valid";
      }
      var s = L5(e, "x", "maxPool");
      var u = s;
      var c = false;
      if (s.rank === 3) {
        c = true;
        u = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]]);
      }
      F$(j8(i, a), function () {
        return `Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${a}'`;
      });
      var l;
      var h = O8(u.shape, t, i, a, r);
      var p = [h.dilationHeight, h.dilationWidth];
      l = r === "same" ? function (e, t) {
        var n = e.map(function (e, n) {
          return e + (e - 1) * (t[n] - 1);
        }).map(function (e) {
          return e - 1;
        });
        var r = n.map(function (e) {
          return Math.floor(e / 2);
        });
        var a = n.map(function (e, t) {
          return e - r[t];
        });
        return n.map(function (e, t) {
          return [r[t], a[t]];
        });
      }([h.filterHeight, h.filterWidth], p) : [[0, 0], [0, 0]];
      var f = p[0] === 1 && p[1] === 1;
      var d = function (e, t, n) {
        var r = n.map(function (e) {
          return e[0];
        });
        var a = n.map(function (e) {
          return e[1];
        });
        var i = e.concat(r, a);
        var o = t.map(function (e, t) {
          return (e - i[t] % e) % e;
        });
        var s = a.map(function (e, t) {
          return e + o[t];
        });
        var u = t.map(function (e, t) {
          return [r[t], s[t]];
        });
        var c = t.map(function (e, t) {
          return [0, o[t]];
        });
        return [u, c];
      }([h.inHeight, h.inWidth], p, l);
      var v = S(d, 2);
      var m = v[0];
      var g = v[1];
      var y = f ? r : "valid";
      var b = f ? u : gee(u, p, m);
      var x = (n === "avg" ? function () {
        return Y8(b, t, i, y, o);
      } : function () {
        return X9(b, t, i, y, o);
      })();
      var k = f ? x : r7(x, p, g);
      if (c) {
        return X8(k, [k.shape[1], k.shape[2], k.shape[3]]);
      } else {
        return k;
      }
    }
  });
  var bee = B5({
    prelu_: function (e, t) {
      var n = {
        x: L5(e, "x", "prelu"),
        alpha: L5(t, "alpha", "prelu")
      };
      return E5.runKernel(C2, n);
    }
  });
  var xee = B5({
    prod_: function (e, t = null, n = false) {
      var r = L5(e, "x", "prod");
      if (r.dtype === "bool") {
        r = h8(r, "int32");
      }
      var a = {
        x: r
      };
      var i = {
        axis: t,
        keepDims: n
      };
      return E5.runKernel(A2, a, i);
    }
  });
  var kee = B5({
    raggedGather_: function (e, t, n, r) {
      var a = {
        paramsNestedSplits: e.map(function (e, t) {
          return L5(e, `tensors${t}`, "raggedGather", "int32");
        }),
        paramsDenseValues: L5(t, "paramsDenseValues", "raggedGather"),
        indices: L5(n, "indices", "raggedGather", "int32")
      };
      var i = {
        outputRaggedRank: r
      };
      var o = E5.runKernel(R2, a, i);
      return {
        outputNestedSplits: o.slice(0, o.length - 1),
        outputDenseValues: o[o.length - 1]
      };
    }
  });
  var wee = B5({
    raggedRange_: function (e, t, n) {
      var r = L5(e, "starts", "raggedRange");
      var a = {
        starts: r,
        limits: L5(t, "limits", "raggedRange", r.dtype),
        deltas: L5(n, "deltas", "raggedRange", r.dtype)
      };
      var i = E5.runKernel(_2, a);
      return {
        rtNestedSplits: i[0],
        rtDenseValues: i[1]
      };
    }
  });
  var Iee = B5({
    raggedTensorToTensor_: function (e, t, n, r, a) {
      var i = L5(e, "shape", "raggedTensorToTensor", "int32");
      var o = L5(t, "values", "raggedTensorToTensor");
      var s = {
        shape: i,
        values: o,
        defaultValue: L5(n, "defaultValue", "raggedTensorToTensor", o.dtype),
        rowPartitionTensors: r.map(function (e, t) {
          return L5(e, `tensors${t}`, "raggedTensorToTensor", "int32");
        })
      };
      var u = {
        rowPartitionTypes: a
      };
      return E5.runKernel(O2, s, u);
    }
  });
  var Nee = B5({
    rand_: function (e, t, n) {
      p0(e);
      var r = L$(e);
      var a = null;
      if (n == null || n === "float32") {
        a = new Float32Array(r);
      } else if (n === "int32") {
        a = new Int32Array(r);
      } else {
        if (n !== "bool") {
          throw new Error(`Unknown data type ${n}`);
        }
        a = new Uint8Array(r);
      }
      for (var i = 0; i < r; i++) {
        a[i] = t();
      }
      return E5.makeTensor(a, e, n);
    }
  });
  var See = {
    exports: {}
  };
  (function (e) {
    (function (e, t, n) {
      function r(e) {
        var t = this;
        var n = function () {
          var e = 4022871197;
          function t(t) {
            t = String(t);
            for (var n = 0; n < t.length; n++) {
              var r = (e += t.charCodeAt(n)) * 0.02519603282416938;
              r -= e = r >>> 0;
              e = (r *= e) >>> 0;
              e += (r -= e) * 4294967296;
            }
            return (e >>> 0) * 2.3283064365386963e-10;
          }
          return t;
        }();
        t.next = function () {
          var e = t.s0 * 2091639 + t.c * 2.3283064365386963e-10;
          t.s0 = t.s1;
          t.s1 = t.s2;
          return t.s2 = e - (t.c = e | 0);
        };
        t.c = 1;
        t.s0 = n(" ");
        t.s1 = n(" ");
        t.s2 = n(" ");
        t.s0 -= n(e);
        if (t.s0 < 0) {
          t.s0 += 1;
        }
        t.s1 -= n(e);
        if (t.s1 < 0) {
          t.s1 += 1;
        }
        t.s2 -= n(e);
        if (t.s2 < 0) {
          t.s2 += 1;
        }
        n = null;
      }
      function a(e, t) {
        t.c = e.c;
        t.s0 = e.s0;
        t.s1 = e.s1;
        t.s2 = e.s2;
        return t;
      }
      function i(e, t) {
        var n = new r(e);
        var i = t && t.state;
        var o = n.next;
        o.int32 = function () {
          return n.next() * 4294967296 | 0;
        };
        o.double = function () {
          return o() + (o() * 2097152 | 0) * 1.1102230246251565e-16;
        };
        o.quick = o;
        if (i) {
          if (s(i) == "object") {
            a(i, n);
          }
          o.state = function () {
            return a(n, {});
          };
        }
        return o;
      }
      if (t && t.exports) {
        t.exports = i;
      } else if (n && n.amd) {
        n(function () {
          return i;
        });
      } else {
        this.alea = i;
      }
    })(0, e, false);
  })(See);
  var Tee = See.exports;
  var Eee = {
    exports: {}
  };
  (function (e) {
    (function (e, t, n) {
      function r(e) {
        var t = this;
        var n = "";
        t.x = 0;
        t.y = 0;
        t.z = 0;
        t.w = 0;
        t.next = function () {
          var e = t.x ^ t.x << 11;
          t.x = t.y;
          t.y = t.z;
          t.z = t.w;
          return t.w ^= t.w >>> 19 ^ e ^ e >>> 8;
        };
        if (e === (e | 0)) {
          t.x = e;
        } else {
          n += e;
        }
        for (var r = 0; r < n.length + 64; r++) {
          t.x ^= n.charCodeAt(r) | 0;
          t.next();
        }
      }
      function a(e, t) {
        t.x = e.x;
        t.y = e.y;
        t.z = e.z;
        t.w = e.w;
        return t;
      }
      function i(e, t) {
        var n = new r(e);
        var i = t && t.state;
        function o() {
          return (n.next() >>> 0) / 4294967296;
        }
        o.double = function () {
          do {
            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / 2097152;
          } while (e === 0);
          return e;
        };
        o.int32 = n.next;
        o.quick = o;
        if (i) {
          if (s(i) == "object") {
            a(i, n);
          }
          o.state = function () {
            return a(n, {});
          };
        }
        return o;
      }
      if (t && t.exports) {
        t.exports = i;
      } else if (n && n.amd) {
        n(function () {
          return i;
        });
      } else {
        this.xor128 = i;
      }
    })(0, e, false);
  })(Eee);
  var Cee = Eee.exports;
  var Aee = {
    exports: {}
  };
  (function (e) {
    (function (e, t, n) {
      function r(e) {
        var t = this;
        var n = "";
        t.next = function () {
          var e = t.x ^ t.x >>> 2;
          t.x = t.y;
          t.y = t.z;
          t.z = t.w;
          t.w = t.v;
          return (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0;
        };
        t.x = 0;
        t.y = 0;
        t.z = 0;
        t.w = 0;
        t.v = 0;
        if (e === (e | 0)) {
          t.x = e;
        } else {
          n += e;
        }
        for (var r = 0; r < n.length + 64; r++) {
          t.x ^= n.charCodeAt(r) | 0;
          if (r == n.length) {
            t.d = t.x << 10 ^ t.x >>> 4;
          }
          t.next();
        }
      }
      function a(e, t) {
        t.x = e.x;
        t.y = e.y;
        t.z = e.z;
        t.w = e.w;
        t.v = e.v;
        t.d = e.d;
        return t;
      }
      function i(e, t) {
        var n = new r(e);
        var i = t && t.state;
        function o() {
          return (n.next() >>> 0) / 4294967296;
        }
        o.double = function () {
          do {
            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / 2097152;
          } while (e === 0);
          return e;
        };
        o.int32 = n.next;
        o.quick = o;
        if (i) {
          if (s(i) == "object") {
            a(i, n);
          }
          o.state = function () {
            return a(n, {});
          };
        }
        return o;
      }
      if (t && t.exports) {
        t.exports = i;
      } else if (n && n.amd) {
        n(function () {
          return i;
        });
      } else {
        this.xorwow = i;
      }
    })(0, e, false);
  })(Aee);
  var Ree = Aee.exports;
  var _ee = {
    exports: {}
  };
  (function (e) {
    (function (e, t, n) {
      function r(e) {
        var t = this;
        t.next = function () {
          var e;
          var n;
          var r = t.x;
          var a = t.i;
          e = r[a];
          n = (e ^= e >>> 7) ^ e << 24;
          n ^= (e = r[a + 1 & 7]) ^ e >>> 10;
          n ^= (e = r[a + 3 & 7]) ^ e >>> 3;
          n ^= (e = r[a + 4 & 7]) ^ e << 7;
          e = r[a + 7 & 7];
          n ^= (e ^= e << 13) ^ e << 9;
          r[a] = n;
          t.i = a + 1 & 7;
          return n;
        };
        (function (e, t) {
          var n;
          var r = [];
          if (t === (t | 0)) {
            r[0] = t;
          } else {
            t = "" + t;
            n = 0;
            for (; n < t.length; ++n) {
              r[n & 7] = r[n & 7] << 15 ^ t.charCodeAt(n) + r[n + 1 & 7] << 13;
            }
          }
          while (r.length < 8) {
            r.push(0);
          }
          for (n = 0; n < 8 && r[n] === 0; ++n);
          if (n == 8) {
            r[7] = -1;
          } else {
            r[n];
          }
          e.x = r;
          e.i = 0;
          n = 256;
          for (; n > 0; --n) {
            e.next();
          }
        })(t, e);
      }
      function a(e, t) {
        t.x = e.x.slice();
        t.i = e.i;
        return t;
      }
      function i(e, t) {
        if (e == null) {
          e = +new Date();
        }
        var n = new r(e);
        var i = t && t.state;
        function o() {
          return (n.next() >>> 0) / 4294967296;
        }
        o.double = function () {
          do {
            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / 2097152;
          } while (e === 0);
          return e;
        };
        o.int32 = n.next;
        o.quick = o;
        if (i) {
          if (i.x) {
            a(i, n);
          }
          o.state = function () {
            return a(n, {});
          };
        }
        return o;
      }
      if (t && t.exports) {
        t.exports = i;
      } else if (n && n.amd) {
        n(function () {
          return i;
        });
      } else {
        this.xorshift7 = i;
      }
    })(0, e, false);
  })(_ee);
  var Oee = _ee.exports;
  var Fee = {
    exports: {}
  };
  (function (e) {
    (function (e, t, n) {
      function r(e) {
        var t = this;
        t.next = function () {
          var e;
          var n;
          var r = t.w;
          var a = t.X;
          var i = t.i;
          t.w = r = r + 1640531527 | 0;
          n = a[i + 34 & 127];
          e = a[i = i + 1 & 127];
          n ^= n << 13;
          e ^= e << 17;
          n ^= n >>> 15;
          e ^= e >>> 12;
          n = a[i] = n ^ e;
          t.i = i;
          return n + (r ^ r >>> 16) | 0;
        };
        (function (e, t) {
          var n;
          var r;
          var a;
          var i;
          var o;
          var s = [];
          var u = 128;
          if (t === (t | 0)) {
            r = t;
            t = null;
          } else {
            t += "\0";
            r = 0;
            u = Math.max(u, t.length);
          }
          a = 0;
          i = -32;
          for (; i < u; ++i) {
            if (t) {
              r ^= t.charCodeAt((i + 32) % t.length);
            }
            if (i === 0) {
              o = r;
            }
            r ^= r << 10;
            r ^= r >>> 15;
            r ^= r << 4;
            r ^= r >>> 13;
            if (i >= 0) {
              o = o + 1640531527 | 0;
              a = (n = s[i & 127] ^= r + o) == 0 ? a + 1 : 0;
            }
          }
          if (a >= 128) {
            s[(t && t.length || 0) & 127] = -1;
          }
          a = 127;
          i = 512;
          for (; i > 0; --i) {
            r = s[a + 34 & 127];
            n = s[a = a + 1 & 127];
            r ^= r << 13;
            n ^= n << 17;
            r ^= r >>> 15;
            n ^= n >>> 12;
            s[a] = r ^ n;
          }
          e.w = o;
          e.X = s;
          e.i = a;
        })(t, e);
      }
      function a(e, t) {
        t.i = e.i;
        t.w = e.w;
        t.X = e.X.slice();
        return t;
      }
      function i(e, t) {
        if (e == null) {
          e = +new Date();
        }
        var n = new r(e);
        var i = t && t.state;
        function o() {
          return (n.next() >>> 0) / 4294967296;
        }
        o.double = function () {
          do {
            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / 2097152;
          } while (e === 0);
          return e;
        };
        o.int32 = n.next;
        o.quick = o;
        if (i) {
          if (i.X) {
            a(i, n);
          }
          o.state = function () {
            return a(n, {});
          };
        }
        return o;
      }
      if (t && t.exports) {
        t.exports = i;
      } else if (n && n.amd) {
        n(function () {
          return i;
        });
      } else {
        this.xor4096 = i;
      }
    })(0, e, false);
  })(Fee);
  var Dee = Fee.exports;
  var Mee = {
    exports: {}
  };
  (function (e) {
    (function (e, t, n) {
      function r(e) {
        var t = this;
        var n = "";
        t.next = function () {
          var e = t.b;
          var n = t.c;
          var r = t.d;
          var a = t.a;
          e = e << 25 ^ e >>> 7 ^ n;
          n = n - r | 0;
          r = r << 24 ^ r >>> 8 ^ a;
          a = a - e | 0;
          t.b = e = e << 20 ^ e >>> 12 ^ n;
          t.c = n = n - r | 0;
          t.d = r << 16 ^ n >>> 16 ^ a;
          return t.a = a - e | 0;
        };
        t.a = 0;
        t.b = 0;
        t.c = -1640531527;
        t.d = 1367130551;
        if (e === Math.floor(e)) {
          t.a = e / 4294967296 | 0;
          t.b = e | 0;
        } else {
          n += e;
        }
        for (var r = 0; r < n.length + 20; r++) {
          t.b ^= n.charCodeAt(r) | 0;
          t.next();
        }
      }
      function a(e, t) {
        t.a = e.a;
        t.b = e.b;
        t.c = e.c;
        t.d = e.d;
        return t;
      }
      function i(e, t) {
        var n = new r(e);
        var i = t && t.state;
        function o() {
          return (n.next() >>> 0) / 4294967296;
        }
        o.double = function () {
          do {
            var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / 2097152;
          } while (e === 0);
          return e;
        };
        o.int32 = n.next;
        o.quick = o;
        if (i) {
          if (s(i) == "object") {
            a(i, n);
          }
          o.state = function () {
            return a(n, {});
          };
        }
        return o;
      }
      if (t && t.exports) {
        t.exports = i;
      } else if (n && n.amd) {
        n(function () {
          return i;
        });
      } else {
        this.tychei = i;
      }
    })(0, e, false);
  })(Mee);
  var Lee = Mee.exports;
  var zee = {
    exports: {}
  };
  (function (e) {
    (function (t, n, r) {
      var a;
      var i = 256;
      var o = r.pow(i, 6);
      var u = r.pow(2, 52);
      var c = u * 2;
      var l = 255;
      function h(e, s, l) {
        var h = [];
        var g = v(d((s = s == 1 ? {
          entropy: true
        } : s || {}).entropy ? [e, m(n)] : e == null ? function () {
          try {
            var e;
            if (a && (e = a.randomBytes)) {
              e = e(i);
            } else {
              e = new Uint8Array(i);
              (t.crypto || t.msCrypto).getRandomValues(e);
            }
            return m(e);
          } catch (e) {
            var r = t.navigator;
            var o = r && r.plugins;
            return [+new Date(), t, o, t.screen, m(n)];
          }
        }() : e, 3), h);
        var y = new p(h);
        function b() {
          for (var e = y.g(6), t = o, n = 0; e < u;) {
            e = (e + n) * i;
            t *= i;
            n = y.g(1);
          }
          while (e >= c) {
            e /= 2;
            t /= 2;
            n >>>= 1;
          }
          return (e + n) / t;
        }
        b.int32 = function () {
          return y.g(4) | 0;
        };
        b.quick = function () {
          return y.g(4) / 4294967296;
        };
        b.double = b;
        v(m(y.S), n);
        return (s.pass || l || function (e, t, n, a) {
          if (a) {
            if (a.S) {
              f(a, y);
            }
            e.state = function () {
              return f(y, {});
            };
          }
          if (n) {
            r.random = e;
            return t;
          } else {
            return e;
          }
        })(b, g, "global" in s ? s.global : this == r, s.state);
      }
      function p(e) {
        var t;
        var n = e.length;
        var r = this;
        var a = 0;
        var o = r.i = r.j = 0;
        var s = r.S = [];
        for (n || (e = [n++]); a < i;) {
          s[a] = a++;
        }
        for (a = 0; a < i; a++) {
          s[a] = s[o = l & o + e[a % n] + (t = s[a])];
          s[o] = t;
        }
        (r.g = function (e) {
          var t;
          var n = 0;
          var a = r.i;
          var o = r.j;
          var s = r.S;
          while (e--) {
            t = s[a = l & a + 1];
            n = n * i + s[l & (s[a] = s[o = l & o + t]) + (s[o] = t)];
          }
          r.i = a;
          r.j = o;
          return n;
        })(i);
      }
      function f(e, t) {
        t.i = e.i;
        t.j = e.j;
        t.S = e.S.slice();
        return t;
      }
      function d(e, t) {
        var n;
        var r = [];
        var a = s(e);
        if (t && a == "object") {
          for (n in e) {
            try {
              r.push(d(e[n], t - 1));
            } catch (e) {}
          }
        }
        if (r.length) {
          return r;
        } else if (a == "string") {
          return e;
        } else {
          return e + "\0";
        }
      }
      function v(e, t) {
        var n;
        for (var r = e + "", a = 0; a < r.length;) {
          t[l & a] = l & (n ^= t[l & a] * 19) + r.charCodeAt(a++);
        }
        return m(t);
      }
      function m(e) {
        return String.fromCharCode.apply(0, e);
      }
      v(r.random(), n);
      if (e.exports) {
        e.exports = h;
        try {
          a = require("crypto");
        } catch (e) {}
      } else {
        r.seedrandom = h;
      }
    })(typeof self != "undefined" ? self : n, [], Math);
  })(zee);
  var Pee = zee.exports;
  var Bee = Tee;
  var Wee = Cee;
  var Uee = Ree;
  var Vee = Oee;
  var Gee = Dee;
  var jee = Lee;
  var Hee = Pee;
  Hee.alea = Bee;
  Hee.xor128 = Wee;
  Hee.xorwow = Uee;
  Hee.xorshift7 = Vee;
  Hee.xor4096 = Gee;
  Hee.tychei = jee;
  var qee = Hee;
  function Kee() {
    if (E5.backend.floatPrecision() === 32) {
      return 0.001;
    } else {
      return 0.1;
    }
  }
  function Xee(e, t, n) {
    var r = true;
    if (U4(e) || U4(t)) {
      r = false;
    }
    if (U4(e) && U4(t)) {
      r = true;
    }
    if (r) {
      var a = e.constructor.name;
      var i = t.constructor.name;
      if (a !== i) {
        throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`);
      }
    }
    if (Array.isArray(e) && Array.isArray(t)) {
      var o = F5(e);
      var s = F5(t);
      if (!P$(o, s)) {
        throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${s}]`);
      }
    }
    var u = U4(e) ? e : V4(e);
    var c = U4(t) ? t : V4(t);
    if (u.length !== c.length) {
      throw new Error(`Arrays have different lengths actual: ${u.length} vs expected: ${c.length}.
Actual:   ${u}.
Expected: ${c}.`);
    }
    for (var l = 0; l < c.length; ++l) {
      var h = u[l];
      var p = c[l];
      if (!n(h, p)) {
        throw new Error(`Arrays differ: actual[${l}] = ${h}, expected[${l}] = ${p}.
Actual:   ${u}.
Expected: ${c}.`);
      }
    }
    if (typeof expect != "undefined") {
      expect().nothing();
    }
  }
  function Yee(e, t, n) {
    if (n == null) {
      n = Kee();
    }
    if (!Jee(e, t, n)) {
      throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);
    }
    if (typeof expect != "undefined") {
      expect().nothing();
    }
  }
  function Jee(e, t, n) {
    return !isFinite(e) && !isFinite(t) || !isNaN(e) && !isNaN(t) && !(Math.abs(e - t) > n);
  }
  function Zee() {
    return (Zee = c(o().mark(function e(t) {
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              e.next = 2;
              return t.play();
            case 2:
              if (!("requestVideoFrameCallback" in t)) {
                e.next = 5;
                break;
              }
              e.next = 5;
              return new Promise(function (e) {
                t.requestVideoFrameCallback(e);
              });
            case 5:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  var Qee = {
    __proto__: null,
    TEST_EPSILON_FLOAT16: 0.1,
    createVideoElement: function (e) {
      var t = document.createElement("video");
      if ("playsInline" in t) {
        t.playsInline = true;
      }
      t.muted = true;
      t.loop = true;
      t.style.position = "fixed";
      t.style.left = "0px";
      t.style.top = "0px";
      t.preload = "auto";
      t.appendChild(e);
      return new Promise(function (e) {
        t.addEventListener("loadeddata", function (n) {
          return e(t);
        });
        t.load();
      });
    },
    encodeStrings: function e(t) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n];
        if (Array.isArray(r)) {
          e(r);
        } else {
          t[n] = B4(r);
        }
      }
      return t;
    },
    expectArrayBuffersEqual: function (e, t) {
      var n = new Float32Array(e);
      var r = new Float32Array(t);
      if (n.length !== r.length) {
        throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);
      }
      for (var a = 0; a < r.length; a++) {
        if (n[a] !== r[a]) {
          throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`);
        }
      }
    },
    expectArraysClose: function (e, t, n) {
      if (n == null) {
        n = Kee();
      }
      return Xee(e, t, function (e, t) {
        return Jee(e, t, n);
      });
    },
    expectArraysEqual: function (e, t) {
      var n = typeof t == "string" || typeof t == "number" || typeof t == "boolean" ? [t] : t;
      if ($$(e) || $$(e[0]) || $$(t) || $$(t[0])) {
        return Xee(e, n, function (e, t) {
          return e == t;
        });
      } else {
        return Xee(e, t, function (e, t) {
          return Jee(e, t, 0);
        });
      }
    },
    expectNumbersClose: Yee,
    expectPromiseToFail: function (e, t) {
      e().then(function () {
        return t.fail();
      }, function () {
        return t();
      });
      if (typeof expect != "undefined") {
        expect().nothing();
      }
    },
    expectValuesInRange: function (e, t, n) {
      for (var r = 0; r < e.length; r++) {
        if (e[r] < t || e[r] > n) {
          throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`);
        }
      }
    },
    play: function (e) {
      return Zee.apply(this, arguments);
    },
    testEpsilon: Kee
  };
  var $ee = function () {
    function e(t, n, r, a, i) {
      l(this, e);
      this.mean = t;
      this.stdDev = n;
      this.dtype = r;
      this.nextVal = NaN;
      this.truncated = a;
      if (this.truncated) {
        this.upper = this.mean + this.stdDev * 2;
        this.lower = this.mean - this.stdDev * 2;
      }
      var o = i || Math.random();
      this.random = qee.alea(o.toString());
    }
    p(e, [{
      key: "nextValue",
      value: function () {
        if (!isNaN(this.nextVal)) {
          var e = this.nextVal;
          this.nextVal = NaN;
          return e;
        }
        var t;
        var n;
        for (var r = false; !r;) {
          var a = undefined;
          var i = undefined;
          var o = undefined;
          do {
            o = (a = this.random() * 2 - 1) * a + (i = this.random() * 2 - 1) * i;
          } while (o >= 1 || o === 0);
          var s = Math.sqrt(Math.log(o) * -2 / o);
          t = this.mean + this.stdDev * a * s;
          n = this.mean + this.stdDev * i * s;
          if (!this.truncated || !!this.isValidTruncated(t)) {
            r = true;
          }
        }
        if (!this.truncated || !!this.isValidTruncated(n)) {
          this.nextVal = this.convertValue(n);
        }
        return this.convertValue(t);
      }
    }, {
      key: "convertValue",
      value: function (e) {
        if (this.dtype == null || this.dtype === "float32") {
          return e;
        } else {
          return Math.round(e);
        }
      }
    }, {
      key: "isValidTruncated",
      value: function (e) {
        return e <= this.upper && e >= this.lower;
      }
    }]);
    return e;
  }();
  var ete = function () {
    function e(t, n, r, a) {
      l(this, e);
      this.alpha = t;
      this.beta = 1 / n;
      this.dtype = r;
      var i = a || Math.random();
      this.randu = qee.alea(i.toString());
      this.randn = new $ee(0, 1, r, false, this.randu());
      this.d = t < 1 ? t + 2 / 3 : t - 1 / 3;
      this.c = 1 / Math.sqrt(this.d * 9);
    }
    p(e, [{
      key: "nextValue",
      value: function () {
        var e;
        var t;
        var n;
        var r;
        var a;
        var i;
        while (true) {
          do {
            r = this.randn.nextValue();
            i = 1 + this.c * r;
          } while (i <= 0);
          i *= i * i;
          t = 1 - (e = r * r) * 0.331 * e;
          n = e * 0.5 + this.d * (1 - i + Math.log(i));
          if ((a = this.randu()) < t || Math.log(a) < n) {
            break;
          }
        }
        i = 1 / this.beta * this.d * i;
        if (this.alpha < 1) {
          i *= Math.pow(this.randu(), 1 / this.alpha);
        }
        return this.convertValue(i);
      }
    }, {
      key: "convertValue",
      value: function (e) {
        if (this.dtype === "float32") {
          return e;
        } else {
          return Math.round(e);
        }
      }
    }]);
    return e;
  }();
  var tte = function () {
    function e() {
      var t = this;
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var a = arguments.length > 2 ? arguments[2] : undefined;
      var i = arguments.length > 3 ? arguments[3] : undefined;
      l(this, e);
      this.canReturnFloat = function () {
        return t.dtype == null || t.dtype === "float32";
      };
      this.min = n;
      this.range = r - n;
      this.dtype = a;
      if (i == null) {
        i = Math.random();
      }
      if (typeof i == "number") {
        i = i.toString();
      }
      if (!this.canReturnFloat() && this.range <= 1) {
        throw new Error(`The difference between ${n} - ${r} <= 1 and dtype is not float`);
      }
      this.random = qee.alea(i);
    }
    p(e, [{
      key: "convertValue",
      value: function (e) {
        if (this.canReturnFloat()) {
          return e;
        } else {
          return Math.round(e);
        }
      }
    }, {
      key: "nextValue",
      value: function () {
        return this.convertValue(this.min + this.range * this.random());
      }
    }]);
    return e;
  }();
  var nte = B5({
    randomGamma_: function (e, t, n = 1, r = "float32", a) {
      p0(e);
      if (n == null) {
        n = 1;
      }
      if (r == null) {
        r = "float32";
      }
      if (r !== "float32" && r !== "int32") {
        throw new Error(`Unsupported data type ${r}`);
      }
      var i = new ete(t, n, r, a);
      for (var o = l8(e, r), s = 0; s < o.values.length; s++) {
        o.values[s] = i.nextValue();
      }
      return o.toTensor();
    }
  });
  var rte = B5({
    randomNormal_: function (e, t = 0, n = 1, r, a) {
      p0(e);
      if (r != null && r === "bool") {
        throw new Error(`Unsupported data type ${r}`);
      }
      var i = new $ee(t, n, r, false, a);
      for (var o = l8(e, r), s = 0; s < o.values.length; s++) {
        o.values[s] = i.nextValue();
      }
      return o.toTensor();
    }
  });
  var ate = B5({
    randomStandardNormal_: function (e, t, n) {
      if (t != null && t === "bool") {
        throw new Error(`Unsupported data type ${t}`);
      }
      return rte(e, 0, 1, t, n);
    }
  });
  var ite = B5({
    randomUniform_: function (e, t = 0, n = 1, r = "float32", a) {
      p0(e);
      for (var i = l8(e, r), o = new tte(t, n, null, a), s = 0; s < i.values.length; s++) {
        i.values[s] = o.nextValue();
      }
      return i.toTensor();
    }
  });
  var ote = B5({
    randomUniformInt_: function (e, t, n, r) {
      return ite(e, t, n, "int32", r);
    }
  });
  function ste(e, t, n = 1, r = "float32") {
    if (n === 0) {
      throw new Error("Cannot have a step of zero");
    }
    var a = {
      start: e,
      stop: t,
      step: n,
      dtype: r
    };
    return E5.runKernel(F2, {}, a);
  }
  var ute = B5({
    real_: function (e) {
      var t = {
        input: L5(e, "input", "real")
      };
      return E5.runKernel(D2, t);
    }
  });
  var cte = B5({
    reciprocal_: function (e) {
      var t = {
        x: L5(e, "x", "reciprocal")
      };
      return E5.runKernel(M2, t);
    }
  });
  var lte = B5({
    relu_: function (e) {
      var t = {
        x: L5(e, "x", "relu")
      };
      return E5.runKernel(L2, t);
    }
  });
  var hte = B5({
    relu6_: function (e) {
      var t = {
        x: L5(e, "x", "relu6")
      };
      return E5.runKernel(V2, t);
    }
  });
  var pte = B5({
    reverse_: function (e, t) {
      var n = {
        x: L5(e, "x", "reverse")
      };
      var r = {
        dims: t
      };
      return E5.runKernel(G2, n, r);
    }
  });
  var fte = B5({
    reverse1d_: function (e) {
      var t = L5(e, "x", "reverse");
      F$(t.rank === 1, function () {
        return `Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`;
      });
      return pte(t, 0);
    }
  });
  var dte = B5({
    reverse2d_: function (e, t) {
      var n = L5(e, "x", "reverse");
      F$(n.rank === 2, function () {
        return `Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`;
      });
      return pte(n, t);
    }
  });
  var vte = B5({
    reverse3d_: function (e, t) {
      var n = L5(e, "x", "reverse");
      F$(n.rank === 3, function () {
        return `Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`;
      });
      return pte(n, t);
    }
  });
  var mte = B5({
    reverse4d_: function (e, t) {
      var n = L5(e, "x", "reverse");
      F$(n.rank === 4, function () {
        return `Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`;
      });
      return pte(n, t);
    }
  });
  var gte = B5({
    round_: function (e) {
      var t = {
        x: L5(e, "x", "round")
      };
      return E5.runKernel(j2, t);
    }
  });
  var yte = B5({
    rsqrt_: function (e) {
      var t = {
        x: L5(e, "x", "rsqrt", "float32")
      };
      return E5.runKernel(H2, t);
    }
  });
  var bte = B5({
    selu_: function (e) {
      var t = {
        x: L5(e, "x", "selu")
      };
      return E5.runKernel(J2, t);
    }
  });
  var xte = B5({
    separableConv2d_: function (e, t, n, r, a, i = [1, 1], o = "NHWC") {
      var s = L5(e, "x", "separableConv2d");
      var u = L5(t, "depthwiseFilter", "separableConv2d");
      var c = L5(n, "pointwiseFilter", "separableConv2d");
      var l = s;
      var h = false;
      if (s.rank === 3) {
        h = true;
        l = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]]);
      }
      if (o === "NCHW") {
        throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
      }
      F$(l.rank === 4, function () {
        return `Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`;
      });
      F$(u.rank === 4, function () {
        return `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`;
      });
      F$(c.rank === 4, function () {
        return `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`;
      });
      F$(c.shape[0] === 1, function () {
        return `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`;
      });
      F$(c.shape[1] === 1, function () {
        return `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`;
      });
      var p = u.shape[2];
      var f = u.shape[3];
      F$(c.shape[2] === p * f, function () {
        return `Error in separableConv2d: the third dimension of pointwise filter must be ${p * f}, but got ${c.shape[2]}.`;
      });
      var d = O7(l, u, r, a, o, i);
      var v = 1;
      var m = b7(d, c, v, "valid", o);
      if (h) {
        return X8(m, [m.shape[1], m.shape[2], m.shape[3]]);
      } else {
        return m;
      }
    }
  });
  function kte() {
    kte = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = L5(t, "x", "setdiff1d");
              a = L5(n, "y", "setdiff1d");
              F$(r.dtype === a.dtype, function () {
                return `x and y should have the same dtype, but got x (${r.dtype}) and y (${a.dtype}).`;
              });
              F$(r.rank === 1, function () {
                return `x should be 1D tensor, but got x (${r.shape}).`;
              });
              F$(a.rank === 1, function () {
                return `y should be 1D tensor, but got y (${a.shape}).`;
              });
              e.next = 7;
              return r.data();
            case 7:
              i = e.sent;
              e.next = 10;
              return a.data();
            case 10:
              s = e.sent;
              u = new Set(s);
              c = 0;
              l = 0;
              for (; l < i.length; l++) {
                if (!u.has(i[l])) {
                  c++;
                }
              }
              h = new $4([c], r.dtype);
              p = new $4([c], "int32");
              f = 0;
              d = 0;
              for (; f < i.length; f++) {
                if (!u.has(i[f])) {
                  h.values[d] = i[f];
                  p.values[d] = f;
                  d++;
                }
              }
              return e.abrupt("return", [h.toTensor(), p.toTensor()]);
            case 18:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return kte.apply(this, arguments);
  }
  function wte(e, t) {
    return kte.apply(this, arguments);
  }
  var Ite = B5({
    sign_: function (e) {
      var t = {
        x: L5(e, "x", "sign")
      };
      return E5.runKernel(e3, t);
    }
  });
  var Nte = B5({
    sin_: function (e) {
      var t = {
        x: L5(e, "x", "sin", "float32")
      };
      return E5.runKernel(Q2, t);
    }
  });
  var Ste = B5({
    sinh_: function (e) {
      var t = {
        x: L5(e, "x", "sinh")
      };
      return E5.runKernel($2, t);
    }
  });
  var Tte = B5({
    slice1d_: function (e, t, n) {
      var r = L5(e, "x", "slice1d");
      F$(r.rank === 1, function () {
        return `slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`;
      });
      return e7(r, [t], [n]);
    }
  });
  var Ete = B5({
    slice2d_: function (e, t, n) {
      var r = L5(e, "x", "slice2d");
      F$(r.rank === 2, function () {
        return `slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`;
      });
      return e7(r, t, n);
    }
  });
  var Cte = B5({
    slice3d_: function (e, t, n) {
      var r = L5(e, "x", "slice3d");
      F$(r.rank === 3, function () {
        return `slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`;
      });
      return e7(r, t, n);
    }
  });
  var Ate = B5({
    slice4d_: function (e, t, n) {
      var r = L5(e, "x", "slice4d");
      F$(r.rank === 4, function () {
        return `slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`;
      });
      return e7(r, t, n);
    }
  });
  var Rte = B5({
    softmax_: function (e, t = -1) {
      var n = L5(e, "logits", "softmax", "float32");
      if (t === -1) {
        t = n.rank - 1;
      }
      if (t !== n.rank - 1) {
        throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);
      }
      var r = {
        logits: n
      };
      var a = {
        dim: t
      };
      return E5.runKernel(s3, r, a);
    }
  });
  var _te = B5({
    fft_: function (e) {
      F$(e.dtype === "complex64", function () {
        return `The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`;
      });
      var t = {
        input: e
      };
      return E5.runKernel(R1, t);
    }
  });
  var Ote = B5({
    ifft_: function (e) {
      F$(e.dtype === "complex64", function () {
        return `The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`;
      });
      var t = {
        input: e
      };
      return E5.runKernel(U1, t);
    }
  });
  var Fte = B5({
    irfft_: function (e) {
      var t;
      var n = e.shape[e.shape.length - 1];
      var r = e.size / n;
      if (n <= 2) {
        var a = X8(e, [r, n]);
        t = Ote(a);
      } else {
        var i = [r, (n - 1) * 2];
        var o = X8(ute(e), [r, n]);
        var s = X8(k9(e), [r, n]);
        var u = pte(e7(o, [0, 1], [r, n - 2]), 1);
        var c = g8(pte(e7(s, [0, 1], [r, n - 2]), 1), i9(-1));
        var l = Z8([o, u], 1);
        var h = Z8([s, c], 1);
        var p = X8(W5(l, h), [i[0], i[1]]);
        t = Ote(p);
      }
      t = ute(t);
      if (e.rank === 3 && e.shape[0] !== 0) {
        var f = t;
        var d = e.shape[0];
        t = X8(t, [d, t.shape[0] / d, t.shape[1]]);
        f.dispose();
      }
      return t;
    }
  });
  var Dte = B5({
    split_: function (e, t, n = 0) {
      var r = L5(e, "x", "split");
      var a = {
        x: r
      };
      var i = {
        numOrSizeSplits: t,
        axis: n
      };
      return E5.runKernel(o3, a, i);
    }
  });
  var Mte = B5({
    rfft_: function (e, t) {
      F$(e.dtype === "float32", function () {
        return `The dtype for rfft() must be real value but got ${e.dtype}`;
      });
      var n;
      var r = e.shape[e.shape.length - 1];
      var a = e.size / r;
      if (t != null && t < r) {
        var i = e.shape.map(function (e) {
          return 0;
        });
        var o = e.shape.map(function (e) {
          return e;
        });
        o[e.shape.length - 1] = t;
        n = e7(e, i, o);
        r = t;
      } else if (t != null && t > r) {
        var s = e.shape.map(function (e) {
          return e;
        });
        s[e.shape.length - 1] = t - r;
        n = Z8([e, $9(s)], e.shape.length - 1);
        r = t;
      } else {
        n = e;
      }
      var u = U7(n);
      var c = X8(W5(n, u), [a, r]);
      var l = _te(c);
      var h = Math.floor(r / 2) + 1;
      var p = ute(l);
      var f = k9(l);
      var d = Dte(p, [h, r - h], p.shape.length - 1);
      var v = Dte(f, [h, r - h], f.shape.length - 1);
      var m = n.shape.slice();
      m[n.shape.length - 1] = h;
      return X8(W5(d[0], v[0]), m);
    }
  });
  var Lte = B5({
    squaredDifference_: function (e, t) {
      var n = L5(e, "a", "squaredDifference");
      var r = L5(t, "b", "squaredDifference");
      var a = S(v5(n, r), 2);
      n = a[0];
      r = a[1];
      z7(n.shape, r.shape);
      var i = {
        a: n,
        b: r
      };
      return E5.runKernel(f3, i, {});
    }
  });
  var zte = B5({
    squeeze_: function (e, t) {
      var n = L5(e, "x", "squeeze", "string_or_numeric");
      return X8(n, H$(n.shape, t).newShape);
    }
  });
  var Pte = B5({
    stack_: function (e, t = 0) {
      var n = z5(e, "tensors", "stack", "string_or_numeric");
      F$(n.length >= 1, function () {
        return "Pass at least one tensor to tf.stack";
      });
      if (n.length > 0) {
        F$(t <= n[0].rank, function () {
          return "Axis must be <= rank of the tensor";
        });
      }
      var r = n;
      var a = {
        axis: t
      };
      return E5.runKernel(S2, r, a);
    }
  });
  var Bte = B5({
    step_: function (e, t = 0) {
      var n = L5(e, "x", "step");
      var r = {
        x: n
      };
      var a = {
        alpha: t
      };
      return E5.runKernel(_3, r, a);
    }
  });
  var Wte = B5({
    stridedSlice_: function (e, t, n, r, a = 0, i = 0, o = 0, s = 0, u = 0) {
      var c = L5(e, "x", "stridedSlice", "string_or_numeric");
      var l = {
        x: c
      };
      var h = {
        begin: t,
        end: n,
        strides: r,
        beginMask: a,
        endMask: i,
        ellipsisMask: o,
        newAxisMask: s,
        shrinkAxisMask: u
      };
      return E5.runKernel(m3, l, h);
    }
  });
  var Ute = B5({
    tan_: function (e) {
      var t = {
        x: L5(e, "x", "tan", "float32")
      };
      return E5.runKernel(k3, t);
    }
  });
  function Vte(e, t) {
    M$(e);
    var n = F5(e, t);
    if (n.length !== 1) {
      throw new Error("tensor1d() requires values to be a flat/TypedArray");
    }
    return U5(e, null, n, t);
  }
  function Gte(e, t, n) {
    M$(e);
    if (t != null && t.length !== 2) {
      throw new Error("tensor2d() requires shape to have two numbers");
    }
    var r = F5(e, n);
    if (r.length !== 2 && r.length !== 1) {
      throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    }
    if (r.length === 1 && t == null) {
      throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    }
    return U5(e, t, r, n);
  }
  function jte(e, t, n) {
    M$(e);
    if (t != null && t.length !== 3) {
      throw new Error("tensor3d() requires shape to have three numbers");
    }
    var r = F5(e, n);
    if (r.length !== 3 && r.length !== 1) {
      throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    }
    if (r.length === 1 && t == null) {
      throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    }
    return U5(e, t, r, n);
  }
  function Hte(e, t, n) {
    M$(e);
    if (t != null && t.length !== 4) {
      throw new Error("tensor4d() requires shape to have four numbers");
    }
    var r = F5(e, n);
    if (r.length !== 4 && r.length !== 1) {
      throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    }
    if (r.length === 1 && t == null) {
      throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    }
    return U5(e, t, r, n);
  }
  function qte(e, t, n) {
    M$(e);
    if (t != null && t.length !== 5) {
      throw new Error("tensor5d() requires shape to have five numbers");
    }
    var r = F5(e, n);
    if (r.length !== 5 && r.length !== 1) {
      throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    }
    if (r.length === 1 && t == null) {
      throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    }
    return U5(e, t, r, n);
  }
  function Kte(e, t, n) {
    M$(e);
    if (t != null && t.length !== 6) {
      throw new Error("tensor6d() requires shape to have six numbers");
    }
    var r = F5(e, n);
    if (r.length !== 6 && r.length !== 1) {
      throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    }
    if (r.length === 1 && t == null) {
      throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    }
    return U5(e, t = t || r, r, n);
  }
  function Xte(e, t, n) {
    var r = t.rank > 1 ? t.shape[t.rank - 1] : 1;
    var a = t.rank > 1 ? t.rank - 1 : 1;
    var i = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;
    if (n.rank < a) {
      throw new Error(`${i} update.rank < ${a}. `);
    }
    if (e.length < r + (n.rank - a)) {
      throw new Error(`${i} Output shape length < ${r + (n.rank - a)}`);
    }
    if (n.rank !== a + e.length - r) {
      throw new Error(`${i} update.rank != ${a + e.length - r}`);
    }
    for (var o = 0; o < a; ++o) {
      if (n.shape[o] !== t.shape[o]) {
        throw new Error(`${i} updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);
      }
    }
    for (var s = 0; s < n.rank - a; ++s) {
      if (n.shape[s + a] !== e[s + r]) {
        throw new Error(`${i} updates.shape[${s + a}] (${n.shape[s + a]}) != shape[${s + a}] (${e[s + a]})`);
      }
    }
  }
  function Yte(e, t, n) {
    if (t.rank < 1) {
      throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
    }
    if (e.rank < 1) {
      throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);
    }
    if (t.dtype !== "int32") {
      throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
    }
    if (n.length < 1) {
      throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);
    }
    if (n.length === 0) {
      if (t.size === 0) {
        throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
      }
      if (e.size === 0) {
        throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`);
      }
    }
    Xte(n, t, e);
  }
  function Jte(e, t, n) {
    var r = t.shape.length;
    var a = r > 1 ? t.shape[r - 1] : 1;
    for (var i = n.length, o = 1, s = a; s < i; ++s) {
      o *= n[s];
    }
    var u = a < 1 ? 1 : a;
    return {
      sliceRank: a,
      numUpdates: L$(t.shape) / u,
      sliceSize: o,
      strides: [].concat(T(i0(n.slice(0, a))), [1]),
      outputSize: L$(n)
    };
  }
  var Zte = {
    __proto__: null,
    calculateShapes: Jte,
    validateInput: Yte,
    validateUpdateShape: Xte
  };
  var Qte = B5({
    tensorScatterUpdate_: function (e, t, n) {
      var r = L5(e, "tensor", "tensorScatterupdate");
      var a = L5(t, "indices", "tensorScatterupdate", "int32");
      var i = L5(n, "updates", "tensorScatterupdate");
      Yte(i, a, r.shape);
      if (r.dtype !== i.dtype) {
        throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);
      }
      var o = {
        tensor: r,
        indices: a,
        updates: i
      };
      return E5.runKernel(K2, o, {});
    }
  });
  var $te = B5({
    topk_: function (e, t = 1) {
      var n = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
      var r = L5(e, "x", "topk");
      if (r.rank === 0) {
        throw new Error("topk() expects the input to be of rank 1 or higher");
      }
      var a = r.shape[r.shape.length - 1];
      if (t < 0) {
        throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
      }
      if (t > a) {
        throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);
      }
      var i = {
        x: r
      };
      var o = {
        k: t,
        sorted: n
      };
      var s = E5.runKernel(N3, i, o);
      var u = S(s, 2);
      var c = u[0];
      var l = u[1];
      return {
        values: c,
        indices: l
      };
    }
  });
  var ene = B5({
    truncatedNormal_: function (e, t = 0, n = 1, r, a) {
      p0(e);
      if (r != null && r === "bool") {
        throw new Error("Unsupported data type $ { dtype }");
      }
      var i = new $ee(t, n, r, true, a);
      for (var o = l8(e, r), s = 0; s < o.values.length; s++) {
        o.values[s] = i.nextValue();
      }
      return o.toTensor();
    }
  });
  var tne = B5({
    unique_: function (e, t = 0) {
      var n = L5(e, "x", "unique", "string_or_numeric");
      F$(n.rank > 0, function () {
        return "The input tensor must be at least 1D";
      });
      var r = {
        x: n
      };
      var a = {
        axis: t
      };
      var i = E5.runKernel(E3, r, a);
      var o = S(i, 2);
      var s = o[0];
      var u = o[1];
      return {
        values: s,
        indices: u
      };
    }
  });
  var nne = B5({
    unsortedSegmentSum_: function (e, t, n) {
      var r = L5(e, "x", "unsortedSegmentSum");
      var a = L5(t, "segmentIds", "unsortedSegmentSum", "int32");
      F$(B$(n), function () {
        return "numSegments must be of dtype int";
      });
      var i = {
        x: r,
        segmentIds: a
      };
      var o = {
        numSegments: n
      };
      return E5.runKernel(A3, i, o);
    }
  });
  var rne = B5({
    unstack_: function (e, t = 0) {
      var n = L5(e, "x", "unstack", "string_or_numeric");
      F$(t >= -n.shape.length && t < n.shape.length, function () {
        return `Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`;
      });
      var r = {
        value: n
      };
      var a = {
        axis: t
      };
      return E5.runKernel(C3, r, a);
    }
  });
  function ane(e, t) {
    return q9(e, t, "right");
  }
  function ine(e) {
    var t = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
    var n = arguments.length > 2 ? arguments[2] : undefined;
    var r = arguments.length > 3 ? arguments[3] : undefined;
    return E5.makeVariable(e, t, n, r);
  }
  function one(e, t) {
    var n = [];
    for (var r = 0; r < t.length; r++) {
      if (t[r]) {
        n.push(r);
      }
    }
    var a = l8(e, "int32");
    var i = l8([n.length, e.length], "int32");
    for (var o = 0; o < n.length; o++) {
      var s = a.indexToLoc(n[o]);
      var u = o * e.length;
      i.values.set(s, u);
    }
    return i.toTensor();
  }
  function sne() {
    return (sne = c(o().mark(function e(t) {
      var n;
      var r;
      var a;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              n = L5(t, "condition", "whereAsync", "bool");
              e.next = 3;
              return n.data();
            case 3:
              r = e.sent;
              a = one(n.shape, r);
              if (t !== n) {
                n.dispose();
              }
              return e.abrupt("return", a);
            case 7:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  function une(e) {
    return sne.apply(this, arguments);
  }
  function cne() {
    cne = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              a = L5(t, "tensor", "boolMask");
              i = L5(n, "mask", "boolMask", "bool");
              s = r == null ? 0 : r;
              u = i.rank;
              c = a.shape;
              F$(u > 0, function () {
                return "mask cannot be scalar";
              });
              D$(c.slice(s, s + u), i.shape, "mask's shape must match the first K dimensions of tensor's shape,");
              l = 1;
              h = s;
              for (; h < s + u; h++) {
                l *= c[h];
              }
              p = c.slice(0, s).concat([l], c.slice(s + u));
              f = X8(a, p);
              d = X8(i, [-1]);
              e.next = 14;
              return une(d);
            case 14:
              v = e.sent;
              m = zte(v, [1]);
              g = y9(f, m, s);
              if (t !== a) {
                a.dispose();
              }
              if (n !== i) {
                i.dispose();
              }
              m.dispose();
              f.dispose();
              d.dispose();
              v.dispose();
              return e.abrupt("return", g);
            case 24:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return cne.apply(this, arguments);
  }
  function lne(e, t, n) {
    return cne.apply(this, arguments);
  }
  var hne = B5({
    transpose_: function (e, t, n) {
      var r = L5(e, "x", "transpose");
      if (t == null) {
        t = r.shape.map(function (e, t) {
          return t;
        }).reverse();
      }
      F$(r.rank === t.length, function () {
        return `Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`;
      });
      t.forEach(function (e) {
        F$(e >= 0 && e < r.rank, function () {
          return `All entries in 'perm' must be between 0 and ${r.rank - 1} but got ${t}`;
        });
      });
      if (r.rank <= 1) {
        return r.clone();
      }
      var a = {
        x: r
      };
      var i = {
        perm: t
      };
      if (r.dtype === "complex64") {
        return X5(function () {
          var e = ute(r);
          var t = k9(r);
          e = E5.runKernel(T3, {
            x: e
          }, i);
          t = E5.runKernel(T3, {
            x: t
          }, i);
          if (n) {
            t = M9(t);
          }
          return W5(e, t);
        });
      } else {
        return E5.runKernel(T3, a, i);
      }
    }
  });
  var pne = B5({
    movingAverage_: function (e, t, n, r) {
      var a = !(arguments.length > 4) || arguments[4] === undefined || arguments[4];
      var i = L5(e, "v", "movingAverage");
      var o = L5(t, "x", "movingAverage");
      var s = L5(n, "decay", "movingAverage");
      m5(i, o);
      F$(P$(i.shape, o.shape), function () {
        return "Shape mismatch in v and x";
      });
      var u = i9(1);
      var c = P9(u, s);
      var l = g8(P9(o, i), c);
      if (a) {
        F$(r != null, function () {
          return "When using zeroDebias: true, step is required.";
        });
        var h = L5(r, "step", "movingAverage");
        l = m8(l, P9(u, a9(s, h)));
      }
      return d8(i, l);
    }
  });
  var fne = B5({
    scatterND_: function (e, t, n) {
      p0(n);
      var r = L5(e, "indices", "scatterND", "int32");
      var a = L5(t, "updates", "scatterND");
      Yte(a, r, n);
      var i = {
        indices: r,
        updates: a
      };
      var o = {
        shape: n
      };
      return E5.runKernel(q2, i, o);
    }
  });
  function dne(e, t, n, r) {
    if (e.dtype !== "int32") {
      throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);
    }
    if (e.rank > 2) {
      throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);
    }
    var a = e.rank > 0 ? e.shape[0] : 1;
    var i = e.rank > 1 ? e.shape[1] : 1;
    if (n.length !== i) {
      throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);
    }
    var o = t.size;
    if (t.rank !== 0 && (t.rank !== 1 || o !== a)) {
      throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);
    }
    if (t.dtype !== r.dtype) {
      throw new Error("sparseValues.dtype must match defaultValues.dtype");
    }
  }
  var vne = B5({
    sparseToDense_: function (e, t, n, r = 0) {
      p0(n);
      var a = L5(e, "sparseIndices", "sparseToDense", "int32");
      var i = L5(t, "sparseValues", "sparseToDense", "string_or_numeric");
      var o = L5(r, "defaultValue", "sparseToDense", i.dtype);
      dne(a, i, n, o);
      var s = {
        sparseIndices: a,
        sparseValues: i,
        defaultValue: o
      };
      var u = {
        outputShape: n
      };
      return E5.runKernel(p3, s, u);
    }
  });
  var mne = B5({
    gatherND_: function (e, t) {
      var n = L5(t, "indices", "gatherND", "int32");
      var r = {
        params: L5(e, "x", "gatherND", "string_or_numeric"),
        indices: n
      };
      return E5.runKernel(z1, r);
    }
  });
  var gne = B5({
    dropout_: function (e, t, n, r) {
      var a = L5(e, "x", "dropout");
      F$(a.dtype === "float32", function () {
        return `x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`;
      });
      F$(t >= 0 && t < 1, function () {
        return `rate must be a float in the range [0, 1), but got ${t}.`;
      });
      if (t === 0) {
        if (e instanceof n5) {
          return a.clone();
        } else {
          return a;
        }
      }
      var i = function (e, t) {
        if (t == null) {
          return e.shape.slice();
        }
        if (P$(e.shape, t)) {
          return t;
        }
        if (e.shape.length === t.length) {
          var n = [];
          for (var r = 0; r < e.shape.length; r++) {
            if (t[r] == null && e.shape[r] != null) {
              n.push(e.shape[r]);
            } else {
              n.push(t[r]);
            }
          }
          return n;
        }
        return t;
      }(a, n);
      var o = 1 - t;
      var s = m8(g9(d8(ite(i, 0, 1, "float32", r), o)), o);
      return g8(a, s);
    }
  });
  function yne(e) {
    return Math.floor(Math.pow(2, Math.ceil(Math.log(e) / Math.log(2))));
  }
  function bne(e, t, n) {
    var r = 1 - e % 2;
    var a = new Float32Array(e);
    for (var i = 0; i < e; ++i) {
      var o = Math.PI * 2 * i / (e + r - 1);
      a[i] = t - n * Math.cos(o);
    }
    return Vte(a, "float32");
  }
  function xne() {
    xne = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      var y;
      var b = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = b.length > 2 && b[2] !== undefined ? b[2] : 1;
              a = L5(t, "predictions", "inTopK");
              i = L5(n, "targets", "inTopK");
              F$(a.rank > 1, function () {
                return `inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`;
              });
              F$(a.rank - 1 === i.rank, function () {
                return `predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${i.rank}`;
              });
              D$(a.shape.slice(0, a.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
              s = a.shape[a.shape.length - 1];
              F$(r > 0 && r <= s, function () {
                return `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${r}`;
              });
              e.next = 10;
              return a.data();
            case 10:
              u = e.sent;
              e.next = 13;
              return i.data();
            case 13:
              c = e.sent;
              l = u.length / s;
              h = s;
              p = q$("bool", l);
              f = 0;
            case 17:
              if (!(f < l)) {
                e.next = 35;
                break;
              }
              d = f * h;
              v = u.subarray(d, d + h);
              m = [];
              g = 0;
              for (; g < v.length; g++) {
                m.push({
                  value: v[g],
                  index: g
                });
              }
              m.sort(function (e, t) {
                return t.value - e.value;
              });
              p[f] = 0;
              y = 0;
            case 25:
              if (!(y < r)) {
                e.next = 32;
                break;
              }
              if (m[y].index !== c[f]) {
                e.next = 29;
                break;
              }
              p[f] = 1;
              return e.abrupt("break", 32);
            case 29:
              y++;
              e.next = 25;
              break;
            case 32:
              f++;
              e.next = 17;
              break;
            case 35:
              if (t !== a) {
                a.dispose();
              }
              if (n !== i) {
                i.dispose();
              }
              return e.abrupt("return", V5(p, i.shape, "bool"));
            case 38:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return xne.apply(this, arguments);
  }
  function kne(e, t) {
    return xne.apply(this, arguments);
  }
  var wne = B5({
    conv2DBackpropFilter_: function (e, t, n, r, a, i = "NHWC", o) {
      var s = e;
      if (e.rank === 3) {
        s = X8(e, [1, e.shape[0], e.shape[1], e.shape[2]]);
      }
      var u = t;
      if (u.rank === 3) {
        u = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]]);
      }
      F$(s.rank === 4, function () {
        return `Error in conv2dDerFilter: input must be rank 4, but got shape ${s.shape}.`;
      });
      F$(u.rank === 4, function () {
        return `Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`;
      });
      F$(n.length === 4, function () {
        return `Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`;
      });
      var c = i === "NHWC" ? s.shape[3] : s.shape[1];
      var l = i === "NHWC" ? u.shape[3] : u.shape[1];
      F$(c === n[2], function () {
        return `Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`;
      });
      F$(l === n[3], function () {
        return `Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`;
      });
      K8("conv2dDerFilter", a, o);
      var h = {
        x: s,
        dy: u
      };
      var p = {
        strides: r,
        pad: a,
        dataFormat: i,
        dimRoundingMode: o,
        filterShape: n
      };
      return E5.runKernel(t1, h, p);
    }
  });
  function Ine(e, t, n) {
    if (n == null || n === "linear") {
      return e;
    }
    if (n === "relu") {
      return g8(e, Bte(t));
    }
    throw new Error(`Cannot compute gradient for fused activation ${n}.`);
  }
  function Nne(e, t) {
    var n = t;
    var r = L7(e.shape, t.shape);
    if (r.length > 0) {
      n = u9(n, r);
    }
    return X8(n, e.shape);
  }
  function Sne(e, t, n, r) {
    if (t === "linear") {
      return e;
    }
    if (t === "relu") {
      return lte(e);
    }
    if (t === "elu") {
      return H7(e);
    }
    if (t === "relu6") {
      return hte(e);
    }
    if (t === "prelu") {
      return bee(e, n);
    }
    if (t === "leakyrelu") {
      return S9(e, r);
    }
    if (t === "sigmoid") {
      return $8(e);
    }
    throw new Error(`Unknown fused activation ${t}.`);
  }
  function Tne(e, t) {
    return !(e > 0) || t === "linear";
  }
  var Ene = B5({
    fusedConv2d_: function (e) {
      var t = e.x;
      var n = e.filter;
      var r = e.strides;
      var a = e.pad;
      var i = e.dataFormat;
      var o = i === undefined ? "NHWC" : i;
      var s = e.dilations;
      var u = s === undefined ? [1, 1] : s;
      var c = e.dimRoundingMode;
      var l = e.bias;
      var h = e.activation;
      var p = h === undefined ? "linear" : h;
      var f = e.preluActivationWeights;
      var d = e.leakyreluAlpha;
      p = p || "linear";
      if (Tne(E5.state.gradientDepth, p) === false) {
        F$(o === "NHWC", function () {
          return `Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`;
        });
        var v = b7(t, n, r, a, o, u, c);
        if (l != null) {
          v = d8(v, l);
        }
        return Sne(v, p, f, d);
      }
      var m = L5(t, "x", "conv2d", "float32");
      var g = L5(n, "filter", "conv2d", "float32");
      var y = m;
      var b = false;
      if (m.rank === 3) {
        b = true;
        y = X8(m, [1, m.shape[0], m.shape[1], m.shape[2]]);
      }
      F$(y.rank === 4, function () {
        return `Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`;
      });
      F$(g.rank === 4, function () {
        return `Error in fused conv2d: filter must be rank 4, but got rank ${g.rank}.`;
      });
      K8("fused conv2d", a, c);
      var x = o === "NHWC" ? y.shape[3] : y.shape[1];
      F$(g.shape[2] === x, function () {
        return `Error in conv2d: depth of input (${x}) must match input depth for filter ${g.shape[2]}.`;
      });
      F$(j8(r, u), function () {
        return `Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${u}'`;
      });
      var k;
      var w;
      var I = D8(y.shape, g.shape, r, u, a, c);
      if (l != null) {
        var N = S(v5(k = L5(l, "bias", "fused conv2d"), m), 1);
        k = N[0];
        if (o === "NHWC") {
          z7(I.outShape, k.shape);
        } else {
          F$(k.shape.length <= 1, function () {
            return `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${k.shape.length}.`;
          });
          F$(k.shape.length === 0 || k.shape[0] === I.outChannels || k.shape[0] === 1, function () {
            return `Error in fused conv2d: bias shape (${k.shape}) is not compatible with the number of output channels (${I.outChannels})`;
          });
        }
      }
      if (f != null) {
        var T = f.shape;
        F$(T.length <= 1 || T.length === 3, function () {
          return `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${T.length}.`;
        });
        if (T.length === 1) {
          F$(T[0] === 1 || T[0] === I.outChannels, function () {
            return `Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the number of output channels (${I.outChannels}).`;
          });
        } else if (T.length === 3) {
          try {
            z7(T, I.outShape);
          } catch (e) {
            var E = `Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the output shape of the conv2d (${I.outShape}).`;
            throw Error(E);
          }
        }
        w = L5(f, "prelu weights", "fused conv2d");
      }
      function C(e, t) {
        F$(o === "NHWC", function () {
          return `Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`;
        });
        var n = S(t, 4);
        var i = n[0];
        var s = n[1];
        var c = n[2];
        var l = n[3];
        var h = Ine(e, c, p);
        F$(G8(u), function () {
          return `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${u}'`;
        });
        var f = [k7(s.shape, h, i, r, a), wne(s, h, i.shape, r, a)];
        if (l != null) {
          var d = Nne(l, h);
          f.push(d);
        }
        return f;
      }
      var A = {
        x: y,
        filter: g,
        bias: k,
        preluActivationWeights: w
      };
      var R = {
        strides: r,
        pad: a,
        dataFormat: o,
        dilations: u,
        dimRoundingMode: c,
        activation: p,
        leakyreluAlpha: d
      };
      if (l == null) {
        var _ = F9(function (e, t, n) {
          var r = E5.runKernel(M3, A, R);
          n([t, e, r]);
          if (b) {
            r = X8(r, [r.shape[1], r.shape[2], r.shape[3]]);
          }
          return {
            value: r,
            gradFunc: C
          };
        });
        return _(y, g);
      }
      var O = F9(function (e, t, n, r) {
        var a = E5.runKernel(M3, A, R);
        r([t, e, a, n]);
        if (b) {
          a = X8(a, [a.shape[1], a.shape[2], a.shape[3]]);
        }
        return {
          value: a,
          gradFunc: C
        };
      });
      return O(y, g, k);
    }
  });
  var Cne = B5({
    depthwiseConv2dNativeBackpropFilter_: function (e, t, n, r, a, i = [1, 1], o) {
      var s = e;
      if (e.rank === 3) {
        s = X8(e, [1, e.shape[0], e.shape[1], e.shape[2]]);
      }
      var u = t;
      if (u.rank === 3) {
        u = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]]);
      }
      var c = {
        x: s,
        dy: u
      };
      var l = {
        strides: r,
        pad: a,
        dimRoundingMode: o,
        dilations: i,
        filterShape: n
      };
      return E5.runKernel(d1, c, l);
    }
  });
  var Ane = B5({
    depthwiseConv2dNativeBackpropInput_: function (e, t, n, r, a, i = [1, 1], o) {
      var s = t;
      var u = false;
      if (t.rank === 3) {
        u = true;
        s = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]]);
      }
      var c = {
        dy: s,
        filter: n
      };
      var l = {
        strides: r,
        pad: a,
        dimRoundingMode: o,
        dilations: i,
        inputShape: e
      };
      var h = E5.runKernel(v1, c, l);
      if (u) {
        return X8(h, [h.shape[1], h.shape[2], h.shape[3]]);
      } else {
        return h;
      }
    }
  });
  var Rne = B5({
    fusedDepthwiseConv2d_: function (e) {
      var t = e.x;
      var n = e.filter;
      var r = e.strides;
      var a = e.pad;
      var i = e.dataFormat;
      var o = i === undefined ? "NHWC" : i;
      var s = e.dilations;
      var u = s === undefined ? [1, 1] : s;
      var c = e.dimRoundingMode;
      var l = e.bias;
      var h = e.activation;
      var p = h === undefined ? "linear" : h;
      var f = e.preluActivationWeights;
      var d = e.leakyreluAlpha;
      if (Tne(E5.state.gradientDepth, p) === false) {
        var v = O7(t, n, r, a, o, u, c);
        if (l != null) {
          v = d8(v, l);
        }
        return Sne(v, p, f, d);
      }
      var m = L5(t, "x", "depthwiseConv2d", "float32");
      var g = L5(n, "filter", "depthwiseConv2d", "float32");
      var y = m;
      var b = false;
      if (m.rank === 3) {
        b = true;
        y = X8(m, [1, m.shape[0], m.shape[1], m.shape[2]]);
      }
      F$(y.rank === 4, function () {
        return `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`;
      });
      F$(g.rank === 4, function () {
        return `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${g.rank}.`;
      });
      F$(y.shape[3] === g.shape[2], function () {
        return `Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${g.shape[2]}.`;
      });
      if (u == null) {
        u = [1, 1];
      }
      F$(j8(r, u), function () {
        return `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${u}'`;
      });
      K8("fused depthwiseConv2d", a, c);
      var x;
      var k;
      var w = D8(y.shape, g.shape, r, u, a, c, true);
      if (l != null) {
        var I = S(v5(x = L5(l, "bias", "fused conv2d"), m), 1);
        x = I[0];
        z7(w.outShape, x.shape);
      }
      if (f != null) {
        k = L5(f, "prelu weights", "fused depthwiseConv2d");
      }
      function N(e, t) {
        F$(G8(u), function () {
          return `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${u}'`;
        });
        var n = S(t, 4);
        var i = n[0];
        var o = n[1];
        var s = n[2];
        var l = n[3];
        var h = Ine(e, s, p);
        var f = Ane(o.shape, h, i, r, a, u, c);
        var d = Cne(o, h, i.shape, r, a, u, c);
        if (l != null) {
          return [f, d, Nne(x, h)];
        } else {
          return [f, d];
        }
      }
      var T = {
        x: y,
        filter: g,
        bias: x,
        preluActivationWeights: k
      };
      var E = {
        strides: r,
        pad: a,
        dataFormat: o,
        dilations: u,
        dimRoundingMode: c,
        activation: p,
        leakyreluAlpha: d
      };
      if (l == null) {
        var C = F9(function (e, t, n) {
          var r = E5.runKernel(L3, T, E);
          n([t, e, r]);
          if (b) {
            r = X8(r, [r.shape[1], r.shape[2], r.shape[3]]);
          }
          return {
            value: r,
            gradFunc: N
          };
        });
        return C(y, g);
      }
      var A = F9(function (e, t, n, r) {
        var a = E5.runKernel(L3, T, E);
        r([t, e, a, n]);
        if (b) {
          a = X8(a, [a.shape[1], a.shape[2], a.shape[3]]);
        }
        return {
          value: a,
          gradFunc: N
        };
      });
      return A(y, g, x);
    }
  });
  var _ne = B5({
    fusedMatMul_: function (e) {
      var t = e.a;
      var n = e.b;
      var r = e.transposeA;
      var a = r !== undefined && r;
      var i = e.transposeB;
      var o = i !== undefined && i;
      var s = e.bias;
      var u = e.activation;
      var c = u === undefined ? "linear" : u;
      var l = e.preluActivationWeights;
      var h = e.leakyreluAlpha;
      var p = h === undefined ? 0.2 : h;
      if (Tne(E5.state.gradientDepth, c) === false) {
        var f = Q8(t, n, a, o);
        if (s != null) {
          f = d8(f, s);
        }
        return Sne(f, c, l, p);
      }
      var d = L5(t, "a", "fused matMul");
      var v = L5(n, "b", "fused matMul");
      var m = S(v5(d, v), 2);
      d = m[0];
      v = m[1];
      var g = a ? d.shape[d.rank - 2] : d.shape[d.rank - 1];
      var y = o ? v.shape[v.rank - 1] : v.shape[v.rank - 2];
      var b = a ? d.shape[d.rank - 1] : d.shape[d.rank - 2];
      var x = o ? v.shape[v.rank - 2] : v.shape[v.rank - 1];
      var k = d.shape.slice(0, -2);
      var w = v.shape.slice(0, -2);
      var I = L$(k);
      var N = L$(w);
      F$(g === y, function () {
        return `Error in fused matMul: inner shapes (${g}) and (${y}) of Tensors with shapes ${d.shape} and ${v.shape} and transposeA=${a} and transposeB=${o} must match.`;
      });
      var T;
      var E;
      var C = z7(d.shape.slice(0, -2), v.shape.slice(0, -2)).concat([b, x]);
      var A = X8(d, a ? [I, g, b] : [I, b, g]);
      var R = X8(v, o ? [N, x, y] : [N, y, x]);
      if (s != null) {
        T = S(v5(T = L5(s, "bias", "fused matMul"), d), 1)[0];
        z7(C, T.shape);
      }
      if (l != null) {
        E = L5(l, "prelu weights", "fused matMul");
      }
      function _(e, t) {
        var n;
        var r;
        var i = S(t, 4);
        var u = i[0];
        var l = i[1];
        var h = i[2];
        var p = i[3];
        var f = Ine(X8(e, h.shape), h, c);
        if (a || o) {
          if (!a && o) {
            n = Q8(f, l, false, false);
            r = Q8(f, u, true, false);
          } else if (a && !o) {
            n = Q8(l, f, false, true);
            r = Q8(u, f, false, false);
          } else {
            n = Q8(l, f, true, true);
            r = Q8(f, u, true, true);
          }
        } else {
          n = Q8(f, l, false, true);
          r = Q8(u, f, true, false);
        }
        if (s != null) {
          return [n, r, Nne(p, f)];
        } else {
          return [n, r];
        }
      }
      var O = {
        a: A,
        b: R,
        bias: T,
        preluActivationWeights: E
      };
      var F = {
        transposeA: a,
        transposeB: o,
        activation: c,
        leakyreluAlpha: p
      };
      if (s == null) {
        var D = F9(function (e, t, n) {
          var r = E5.runKernel(D3, O, F);
          n([e, t, r]);
          return {
            value: X8(r, C),
            gradFunc: _
          };
        });
        return D(A, R);
      }
      var M = F9(function (e, t, n, r) {
        var a = E5.runKernel(D3, O, F);
        r([e, t, a, n]);
        return {
          value: X8(a, C),
          gradFunc: _
        };
      });
      return M(A, R, T);
    }
  });
  var One = {
    __proto__: null,
    conv2d: Ene,
    depthwiseConv2d: Rne,
    matMul: _ne
  };
  var Fne = B5({
    hammingWindow_: function (e) {
      return bne(e, 0.54, 0.46);
    }
  });
  var Dne = B5({
    hannWindow_: function (e) {
      return bne(e, 0.5, 0.5);
    }
  });
  var Mne = B5({
    frame_: function (e, t, n, r = false, a = 0) {
      for (var i = 0, o = []; i + t <= e.size;) {
        o.push(e7(e, i, t));
        i += n;
      }
      if (r) {
        while (i < e.size) {
          var s = i + t - e.size;
          var u = Z8([e7(e, i, t - s), f7([s], a)]);
          o.push(u);
          i += n;
        }
      }
      if (o.length === 0) {
        return Gte([], [0, t]);
      } else {
        return X8(Z8(o), [o.length, t]);
      }
    }
  });
  var Lne = B5({
    stft_: function (e, t, n, r, a = Dne) {
      if (r == null) {
        r = yne(t);
      }
      var i = Mne(e, t, n);
      var o = g8(i, a(t));
      return Mte(o, r);
    }
  });
  var zne = B5({
    cropAndResize_: function (e, t, n, r, a = "bilinear", i = 0) {
      var o = L5(e, "image", "cropAndResize");
      var s = L5(t, "boxes", "cropAndResize", "float32");
      var u = L5(n, "boxInd", "cropAndResize", "int32");
      var c = s.shape[0];
      F$(o.rank === 4, function () {
        return `Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`;
      });
      F$(s.rank === 2 && s.shape[1] === 4, function () {
        return `Error in cropAndResize: boxes must be have size [${c},4] but had shape ${s.shape}.`;
      });
      F$(u.rank === 1 && u.shape[0] === c, function () {
        return `Error in cropAndResize: boxInd must be have size [${c}] but had shape ${s.shape}.`;
      });
      F$(r.length === 2, function () {
        return `Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`;
      });
      F$(r[0] >= 1 && r[1] >= 1, function () {
        return `cropSize must be atleast [1,1], but was ${r}`;
      });
      F$(a === "bilinear" || a === "nearest", function () {
        return `method must be bilinear or nearest, but was ${a}`;
      });
      var l = {
        image: o,
        boxes: s,
        boxInd: u
      };
      var h = {
        method: a,
        extrapolationValue: i,
        cropSize: r
      };
      var p = E5.runKernel(l1, l, h);
      return p;
    }
  });
  var Pne = B5({
    flipLeftRight_: function (e) {
      var t = L5(e, "image", "flipLeftRight", "float32");
      F$(t.rank === 4, function () {
        return `Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`;
      });
      var n = {
        image: t
      };
      return E5.runKernel(O1, n, {});
    }
  });
  var Bne = B5({
    grayscaleToRGB_: function (e) {
      var t = L5(e, "image", "grayscaleToRGB");
      var n = t.rank - 1;
      var r = t.shape[n];
      F$(t.rank >= 2, function () {
        return `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`;
      });
      F$(r === 1, function () {
        return `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`;
      });
      var a = new Array(t.rank);
      a.fill(1, 0, n);
      a[n] = 3;
      return v9(t, a);
    }
  });
  var Wne = B5({
    rgbToGrayscale_: function (e) {
      var t = L5(e, "image", "RGBToGrayscale");
      var n = t.rank - 1;
      var r = t.shape[n];
      F$(t.rank >= 2, function () {
        return `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`;
      });
      F$(r === 3, function () {
        return `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`;
      });
      var a;
      var i = t.dtype;
      var o = h8(t, "float32");
      var s = Vte([0.2989, 0.587, 0.114]);
      switch (t.rank) {
        case 2:
          a = j7("ij,j->i", o, s);
          break;
        case 3:
          a = j7("ijk,k->ij", o, s);
          break;
        case 4:
          a = j7("ijkl,l->ijk", o, s);
          break;
        case 5:
          a = j7("ijklm,m->ijkl", o, s);
          break;
        case 6:
          a = j7("ijklmn,n->ijklm", o, s);
          break;
        default:
          throw new Error("Not a valid tensor rank.");
      }
      a = f9(a, -1);
      return h8(a, i);
    }
  });
  var Une = B5({
    rotateWithOffset_: function (e, t, n = 0, r = 0.5) {
      var a = L5(e, "image", "rotateWithOffset", "float32");
      F$(a.rank === 4, function () {
        return `Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`;
      });
      var i = {
        image: a
      };
      var o = {
        radians: t,
        fillValue: n,
        center: r
      };
      var s = E5.runKernel(F3, i, o);
      return s;
    }
  });
  function Vne(e, t, n, r, a, i) {
    if (r == null) {
      r = 0.5;
    }
    if (a == null) {
      a = Number.NEGATIVE_INFINITY;
    }
    if (i == null) {
      i = 0;
    }
    var o = e.shape[0];
    n = Math.min(n, o);
    F$(r >= 0 && r <= 1, function () {
      return `iouThreshold must be in [0, 1], but was '${r}'`;
    });
    F$(e.rank === 2, function () {
      return `boxes must be a 2D tensor, but was of rank '${e.rank}'`;
    });
    F$(e.shape[1] === 4, function () {
      return `boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`;
    });
    F$(t.rank === 1, function () {
      return "scores must be a 1D tensor";
    });
    F$(t.shape[0] === o, function () {
      return `scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`;
    });
    F$(i >= 0 && i <= 1, function () {
      return `softNmsSigma must be in [0, 1], but was '${i}'`;
    });
    return {
      maxOutputSize: n,
      iouThreshold: r,
      scoreThreshold: a,
      softNmsSigma: i
    };
  }
  var Gne = B5({
    nonMaxSuppression_: function (e, t, n, r = 0.5, a = Number.NEGATIVE_INFINITY) {
      var i = L5(e, "boxes", "nonMaxSuppression", "float32");
      var o = L5(t, "scores", "nonMaxSuppression", "float32");
      var s = Vne(i, o, n, r, a);
      var u = {
        maxOutputSize: n = s.maxOutputSize,
        iouThreshold: r = s.iouThreshold,
        scoreThreshold: a = s.scoreThreshold
      };
      return E5.runKernel(x2, {
        boxes: i,
        scores: o
      }, u);
    }
  });
  function jne(e, t, n) {
    var r = function (e, t, n) {
      return function (e, t, n) {
        var r = 0;
        var a = e.length;
        var i = 0;
        var o = false;
        while (r < a) {
          var s = n(t, e[i = r + (a - r >>> 1)]);
          if (s > 0) {
            r = i + 1;
          } else {
            a = i;
            o = !s;
          }
        }
        if (o) {
          return r;
        } else {
          return -r - 1;
        }
      }(e, t, n || Hne);
    }(e, t, n);
    var a = r < 0 ? -(r + 1) : r;
    e.splice(a, 0, t);
  }
  function Hne(e, t) {
    if (e > t) {
      return 1;
    } else if (e < t) {
      return -1;
    } else {
      return 0;
    }
  }
  function qne(e, t, n, r, a) {
    return Yne(e, t, n, r, a, 0);
  }
  function Kne(e, t, n, r, a, i) {
    return Yne(e, t, n, r, a, 0, false, i, true);
  }
  function Xne(e, t, n, r, a, i) {
    return Yne(e, t, n, r, a, i, true);
  }
  function Yne(e, t, n, r, a, i, o = false, s = false, u = false) {
    var c = [];
    for (var l = 0; l < t.length; l++) {
      if (t[l] > a) {
        c.push({
          score: t[l],
          boxIndex: l,
          suppressBeginIndex: 0
        });
      }
    }
    c.sort(Qne);
    var h = i > 0 ? -0.5 / i : 0;
    for (var p = [], f = []; p.length < n && c.length > 0;) {
      var d = c.pop();
      var v = d.score;
      var m = d.boxIndex;
      var g = d.suppressBeginIndex;
      if (v < a) {
        break;
      }
      var y = false;
      for (var b = p.length - 1; b >= g; --b) {
        var x = Jne(e, m, p[b]);
        if (x >= r) {
          y = true;
          break;
        }
        d.score = d.score * Zne(r, h, x);
        if (d.score <= a) {
          break;
        }
      }
      d.suppressBeginIndex = p.length;
      if (!y) {
        if (d.score === v) {
          p.push(m);
          f.push(d.score);
        } else if (d.score > a) {
          jne(c, d, Qne);
        }
      }
    }
    var k = p.length;
    var w = n - k;
    if (s && w > 0) {
      p.push.apply(p, T(new Array(w).fill(0)));
      f.push.apply(f, T(new Array(w).fill(0)));
    }
    var I = {
      selectedIndices: p
    };
    if (o) {
      I.selectedScores = f;
    }
    if (u) {
      I.validOutputs = k;
    }
    return I;
  }
  function Jne(e, t, n) {
    var r = e.subarray(t * 4, t * 4 + 4);
    var a = e.subarray(n * 4, n * 4 + 4);
    var i = Math.min(r[0], r[2]);
    var o = Math.min(r[1], r[3]);
    var s = Math.max(r[0], r[2]);
    var u = Math.max(r[1], r[3]);
    var c = Math.min(a[0], a[2]);
    var l = Math.min(a[1], a[3]);
    var h = Math.max(a[0], a[2]);
    var p = Math.max(a[1], a[3]);
    var f = (s - i) * (u - o);
    var d = (h - c) * (p - l);
    if (f <= 0 || d <= 0) {
      return 0;
    }
    var v = Math.max(i, c);
    var m = Math.max(o, l);
    var g = Math.min(s, h);
    var y = Math.min(u, p);
    var b = Math.max(g - v, 0) * Math.max(y - m, 0);
    return b / (f + d - b);
  }
  function Zne(e, t, n) {
    var r = Math.exp(t * n * n);
    if (n <= e) {
      return r;
    } else {
      return 0;
    }
  }
  function Qne(e, t) {
    return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex;
  }
  function $ne() {
    $ne = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              a = v.length > 3 && v[3] !== undefined ? v[3] : 0.5;
              i = v.length > 4 && v[4] !== undefined ? v[4] : Number.NEGATIVE_INFINITY;
              s = L5(t, "boxes", "nonMaxSuppressionAsync");
              u = L5(n, "scores", "nonMaxSuppressionAsync");
              c = Vne(s, u, r, a, i);
              r = c.maxOutputSize;
              a = c.iouThreshold;
              i = c.scoreThreshold;
              e.next = 10;
              return Promise.all([s.data(), u.data()]);
            case 10:
              l = e.sent;
              h = l[0];
              p = l[1];
              f = qne(h, p, r, a, i);
              d = f.selectedIndices;
              if (s !== t) {
                s.dispose();
              }
              if (u !== n) {
                u.dispose();
              }
              return e.abrupt("return", Vte(d, "int32"));
            case 17:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return $ne.apply(this, arguments);
  }
  function ere(e, t, n) {
    return $ne.apply(this, arguments);
  }
  var tre = B5({
    nonMaxSuppressionWithScore_: function (e, t, n, r = 0.5, a = Number.NEGATIVE_INFINITY, i = 0) {
      var o = L5(e, "boxes", "nonMaxSuppression");
      var s = L5(t, "scores", "nonMaxSuppression");
      var u = Vne(o, s, n, r, a, i);
      var c = {
        boxes: o,
        scores: s
      };
      var l = {
        maxOutputSize: n = u.maxOutputSize,
        iouThreshold: r = u.iouThreshold,
        scoreThreshold: a = u.scoreThreshold,
        softNmsSigma: i = u.softNmsSigma
      };
      var h = E5.runKernel(w2, c, l);
      return {
        selectedIndices: h[0],
        selectedScores: h[1]
      };
    }
  });
  function nre() {
    nre = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              a = g.length > 3 && g[3] !== undefined ? g[3] : 0.5;
              i = g.length > 4 && g[4] !== undefined ? g[4] : Number.NEGATIVE_INFINITY;
              s = g.length > 5 && g[5] !== undefined ? g[5] : 0;
              u = L5(t, "boxes", "nonMaxSuppressionAsync");
              c = L5(n, "scores", "nonMaxSuppressionAsync");
              l = Vne(u, c, r, a, i, s);
              r = l.maxOutputSize;
              a = l.iouThreshold;
              i = l.scoreThreshold;
              s = l.softNmsSigma;
              e.next = 12;
              return Promise.all([u.data(), c.data()]);
            case 12:
              h = e.sent;
              p = h[0];
              f = h[1];
              d = Xne(p, f, r, a, i, s);
              v = d.selectedIndices;
              m = d.selectedScores;
              if (u !== t) {
                u.dispose();
              }
              if (c !== n) {
                c.dispose();
              }
              return e.abrupt("return", {
                selectedIndices: Vte(v, "int32"),
                selectedScores: Vte(m)
              });
            case 19:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return nre.apply(this, arguments);
  }
  function rre(e, t, n) {
    return nre.apply(this, arguments);
  }
  var are = B5({
    nonMaxSuppressionPadded_: function (e, t, n, r = 0.5, a = Number.NEGATIVE_INFINITY, i = false) {
      var o = L5(e, "boxes", "nonMaxSuppression");
      var s = L5(t, "scores", "nonMaxSuppression");
      var u = Vne(o, s, n, r, a, null);
      var c = u.maxOutputSize;
      var l = u.iouThreshold;
      var h = u.scoreThreshold;
      var p = {
        boxes: o,
        scores: s
      };
      var f = {
        maxOutputSize: c,
        iouThreshold: l,
        scoreThreshold: h,
        padToMaxOutputSize: i
      };
      var d = E5.runKernel(k2, p, f);
      return {
        selectedIndices: d[0],
        validOutputs: d[1]
      };
    }
  });
  function ire() {
    ire = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      var y;
      var b;
      var x;
      var k = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              a = k.length > 3 && k[3] !== undefined ? k[3] : 0.5;
              i = k.length > 4 && k[4] !== undefined ? k[4] : Number.NEGATIVE_INFINITY;
              s = k.length > 5 && k[5] !== undefined && k[5];
              u = L5(t, "boxes", "nonMaxSuppressionAsync");
              c = L5(n, "scores", "nonMaxSuppressionAsync");
              l = Vne(u, c, r, a, i, null);
              h = l.maxOutputSize;
              p = l.iouThreshold;
              f = l.scoreThreshold;
              e.next = 11;
              return Promise.all([u.data(), c.data()]);
            case 11:
              d = e.sent;
              v = S(d, 2);
              m = v[0];
              g = v[1];
              y = Kne(m, g, h, p, f, s);
              b = y.selectedIndices;
              x = y.validOutputs;
              if (u !== t) {
                u.dispose();
              }
              if (c !== n) {
                c.dispose();
              }
              return e.abrupt("return", {
                selectedIndices: Vte(b, "int32"),
                validOutputs: i9(x, "int32")
              });
            case 19:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return ire.apply(this, arguments);
  }
  function ore(e, t, n) {
    return ire.apply(this, arguments);
  }
  var sre = B5({
    resizeBilinear_: function (e, t, n = false, r = false) {
      var a = L5(e, "images", "resizeBilinear");
      F$(a.rank === 3 || a.rank === 4, function () {
        return `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`;
      });
      F$(t.length === 2, function () {
        return `Error in resizeBilinear: new shape must 2D, but got shape ${t}.`;
      });
      F$(r === false || n === false, function () {
        return "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.";
      });
      var i = a;
      var o = false;
      if (a.rank === 3) {
        o = true;
        i = X8(a, [1, a.shape[0], a.shape[1], a.shape[2]]);
      }
      S(t, 0);
      var s = {
        images: i
      };
      var u = {
        alignCorners: n,
        halfPixelCenters: r,
        size: t
      };
      var c = E5.runKernel(W2, s, u);
      if (o) {
        return X8(c, [c.shape[1], c.shape[2], c.shape[3]]);
      } else {
        return c;
      }
    }
  });
  var ure = B5({
    resizeNearestNeighbor_: function (e, t, n = false, r = false) {
      var a = L5(e, "images", "resizeNearestNeighbor");
      F$(a.rank === 3 || a.rank === 4, function () {
        return `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`;
      });
      F$(t.length === 2, function () {
        return `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`;
      });
      F$(a.dtype === "float32" || a.dtype === "int32", function () {
        return "`images` must have `int32` or `float32` as dtype";
      });
      F$(r === false || n === false, function () {
        return "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.";
      });
      var i = a;
      var o = false;
      if (a.rank === 3) {
        o = true;
        i = X8(a, [1, a.shape[0], a.shape[1], a.shape[2]]);
      }
      S(t, 0);
      var s = {
        images: i
      };
      var u = {
        alignCorners: n,
        halfPixelCenters: r,
        size: t
      };
      var c = E5.runKernel(P2, s, u);
      if (o) {
        return X8(c, [c.shape[1], c.shape[2], c.shape[3]]);
      } else {
        return c;
      }
    }
  });
  function cre(e, t) {
    var n;
    var r;
    var a;
    var i;
    var o;
    var s;
    var u = Vte([-1]);
    var c = Vte([0]);
    var l = Vte([0]);
    for (var h = 0; h < e.size - 1; h++) {
      n = e7(e, 0, h + 1);
      r = e7(e, h + 1);
      o = m8(u9(n), t);
      s = m8(u9(r), t);
      var p = u9(g8(n, ste(0, n.size)));
      a = m8(p, u9(n));
      var f = f7(r.shape, n.size);
      var d = d8(ste(0, r.size), f);
      var v = g8(r, d);
      i = m8(u9(v), u9(r));
      var m = P9(a, i);
      var g = P9(a, i);
      var y = g8(o, s);
      l = g8(g8(y, m), g);
      var b = b9(l, c);
      c = W7(b, l, c);
      u = W7(b, Vte([h]), u);
    }
    return u;
  }
  var lre = B5({
    threshold_: function (e) {
      var t;
      var n;
      var r;
      var a;
      var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "binary";
      var o = arguments.length > 2 && arguments[2] !== undefined && arguments[2];
      var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
      var u = L5(e, "image", "threshold");
      var c = 0.2989;
      var l = 0.587;
      var h = 0.114;
      var p = u.shape[0] * u.shape[1];
      var f = g8(Vte([s]), 255);
      F$(u.rank === 3, function () {
        return `Error in threshold: image must be rank 3,but got rank ${u.rank}.`;
      });
      F$(u.shape[2] === 3 || u.shape[2] === 1, function () {
        return `Error in threshold: image color channel must be equal to 3 or 1but got ${u.shape[2]}.`;
      });
      F$(u.dtype === "int32" || u.dtype === "float32", function () {
        return `Error in dtype: image dtype must be int32 or float32,but got dtype ${u.dtype}.`;
      });
      F$(i === "otsu" || i === "binary", function () {
        return `Method must be binary or otsu, but was ${i}`;
      });
      if (u.shape[2] === 3) {
        var d = Dte(u, [1, 1, 1], -1);
        var v = S(d, 3);
        t = v[0];
        n = v[1];
        r = v[2];
        var m = g8(t, c);
        var g = g8(n, l);
        var y = g8(r, h);
        a = d8(d8(m, g), y);
      } else {
        a = e;
      }
      if (i === "otsu") {
        var b = u7(h8(gte(a), "int32"), V5([]), 256);
        f = cre(b, p);
      }
      var x = o ? E9(a, f) : b9(a, f);
      var k = h8(g8(x, 255), "int32");
      return k;
    }
  });
  var hre = B5({
    transform_: function (e, t, n = "nearest", r = "constant", a = 0, i) {
      var o = L5(e, "image", "transform", "float32");
      var s = L5(t, "transforms", "transform", "float32");
      F$(o.rank === 4, function () {
        return `Error in transform: image must be rank 4,but got rank ${o.rank}.`;
      });
      F$(s.rank === 2 && (s.shape[0] === o.shape[0] || s.shape[0] === 1) && s.shape[1] === 8, function () {
        return "Error in transform: Input transform should be batch x 8 or 1 x 8";
      });
      F$(i == null || i.length === 2, function () {
        return `Error in transform: outputShape must be [height, width] or null, but got ${i}.`;
      });
      var u = {
        image: o,
        transforms: s
      };
      var c = {
        interpolation: n,
        fillMode: r,
        fillValue: a,
        outputShape: i
      };
      return E5.runKernel(S3, u, c);
    }
  });
  var pre = B5({
    bandPart_: function (e, t, n) {
      var r = L5(e, "a", "bandPart");
      F$(r.rank >= 2, function () {
        return `bandPart(): Rank must be at least 2, got ${r.rank}.`;
      });
      var a;
      var i;
      var o = r.shape;
      var s = S(r.shape.slice(-2), 2);
      var u = s[0];
      var c = s[1];
      if (typeof t == "number") {
        F$(t % 1 == 0, function () {
          return `bandPart(): numLower must be an integer, got ${t}.`;
        });
        F$(t <= u, function () {
          return `bandPart(): numLower (${t}) must not be greater than the number of rows (${u}).`;
        });
        a = L5(t < 0 ? u : t, "numLower", "bandPart");
      } else {
        F$(t.dtype === "int32", function () {
          return "bandPart(): numLower's dtype must be an int32.";
        });
        a = W7(T9(t, 0), u, nee(t, u));
      }
      if (typeof n == "number") {
        F$(n % 1 == 0, function () {
          return `bandPart(): numUpper must be an integer, got ${n}.`;
        });
        F$(n <= c, function () {
          return `bandPart(): numUpper (${n}) must not be greater than the number of columns (${c}).`;
        });
        i = L5(n < 0 ? c : n, "numUpper", "bandPart");
      } else {
        F$(n.dtype === "int32", function () {
          return "bandPart(): numUpper's dtype must be an int32.";
        });
        i = W7(T9(n, 0), c, nee(n, c));
      }
      var l = X8(ste(0, u, 1, "int32"), [-1, 1]);
      var h = ste(0, c, 1, "int32");
      var p = P9(l, h);
      var f = U9(E9(p, a), x9(p, M9(i)));
      var d = $9([u, c], r.dtype);
      return X8(Pte(rne(X8(r, [-1, u, c])).map(function (e) {
        return W7(f, e, d);
      })), o);
    }
  });
  var fre = B5({
    gramSchmidt_: function (e) {
      var t;
      if (Array.isArray(e)) {
        t = false;
        F$(e != null && e.length > 0, function () {
          return "Gram-Schmidt process: input must not be null, undefined, or empty";
        });
        var n = e[0].shape[0];
        var r = function (t) {
          F$(e[t].shape[0] === n, function () {
            return `Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`;
          });
        };
        for (var a = 1; a < e.length; ++a) {
          r(a);
        }
      } else {
        t = true;
        e = Dte(e, e.shape[0], 0).map(function (e) {
          return zte(e, [0]);
        });
      }
      F$(e.length <= e[0].shape[0], function () {
        return `Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`;
      });
      var i = [];
      var o = e;
      var s = function (e) {
        i.push(E5.tidy(function () {
          var t = o[e];
          if (e > 0) {
            for (var n = 0; n < e; ++n) {
              var r = g8(u9(g8(i[n], t)), i[n]);
              t = P9(t, r);
            }
          }
          return m8(t, l9(t, "euclidean"));
        }));
      };
      for (var u = 0; u < e.length; ++u) {
        s(u);
      }
      if (t) {
        return Pte(i, 0);
      } else {
        return i;
      }
    }
  });
  function dre(e, t = false) {
    return E5.tidy(function () {
      F$(e.shape.length === 2, function () {
        return `qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`;
      });
      var n = e.shape[0];
      var r = e.shape[1];
      var a = m9(n);
      var i = p8(e);
      var o = Gte([[1]], [1, 1]);
      var s = p8(o);
      for (var u = n >= r ? r : n, c = function (e) {
          var t = i;
          var u = s;
          var c = a;
          var l = S(E5.tidy(function () {
            var t = e7(i, [e, e], [n - e, 1]);
            var u = l9(t);
            var c = e7(i, [e, e], [1, 1]);
            var l = W7(b9(c, 0), Gte([[-1]]), Gte([[1]]));
            var h = P9(c, g8(l, u));
            var p = m8(t, h);
            s = p.shape[0] === 1 ? p8(o) : Z8([o, e7(p, [1, 0], [p.shape[0] - 1, p.shape[1]])], 0);
            var f = M9(m8(Q8(l, h), u));
            var d = e7(i, [e, 0], [n - e, r]);
            var v = g8(f, s);
            var m = hne(s);
            if (e === 0) {
              i = P9(d, Q8(v, Q8(m, d)));
            } else {
              var g = P9(d, Q8(v, Q8(m, d)));
              i = Z8([e7(i, [0, 0], [e, r]), g], 0);
            }
            var y = hne(v);
            var b = e7(a, [0, e], [n, a.shape[1] - e]);
            if (e === 0) {
              a = P9(b, Q8(Q8(b, s), y));
            } else {
              var x = P9(b, Q8(Q8(b, s), y));
              a = Z8([e7(a, [0, 0], [n, e]), x], 1);
            }
            return [s, i, a];
          }), 3);
          s = l[0];
          i = l[1];
          a = l[2];
          Y5([t, u, c]);
        }, l = 0; l < u; ++l) {
        c(l);
      }
      if (!t && n > r) {
        a = e7(a, [0, 0], [n, r]);
        i = e7(i, [0, 0], [r, r]);
      }
      return [a, i];
    });
  }
  var vre;
  var mre = B5({
    qr_: function (e, t = false) {
      F$(e.rank >= 2, function () {
        return `qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`;
      });
      if (e.rank === 2) {
        return dre(e, t);
      }
      var n = e.shape.slice(0, e.shape.length - 2).reduce(function (e, t) {
        return e * t;
      });
      var r = rne(X8(e, [n, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0);
      var a = [];
      var i = [];
      r.forEach(function (e) {
        var n = S(dre(e, t), 2);
        var r = n[0];
        var o = n[1];
        a.push(r);
        i.push(o);
      });
      var o = X8(Pte(a, 0), e.shape);
      var s = X8(Pte(i, 0), e.shape);
      return [o, s];
    }
  });
  e.Reduction = undefined;
  (vre = e.Reduction ||= {})[vre.NONE = 0] = "NONE";
  vre[vre.MEAN = 1] = "MEAN";
  vre[vre.SUM = 2] = "SUM";
  vre[vre.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
  var gre = B5({
    computeWeightedLoss_: function (t, n, r = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var a = L5(t, "losses", "computeWeightedLoss");
      var i = null;
      if (n != null) {
        i = L5(n, "weights", "computeWeightedLoss");
      }
      var o = i == null ? a : g8(a, i);
      if (r === e.Reduction.NONE) {
        return o;
      }
      if (r === e.Reduction.SUM) {
        return u9(o);
      }
      if (r === e.Reduction.MEAN) {
        if (i == null) {
          return Q9(o);
        }
        var s = a.size / i.size;
        var u = m8(u9(o), u9(i));
        if (s > 1) {
          return m8(u, i9(s));
        } else {
          return u;
        }
      }
      if (r === e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
        if (i == null) {
          return m8(u9(o), i9(a.size));
        }
        var c = g8(i, eee(a.shape));
        var l = h8(u9(uee(c, i9(0))), "float32");
        return m8(u9(o), l);
      }
      throw Error(`Unknown reduction: ${r}`);
    }
  });
  var yre = B5({
    absoluteDifference_: function (t, n, r, a = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var i = L5(t, "labels", "absoluteDifference");
      var o = L5(n, "predictions", "absoluteDifference");
      var s = null;
      if (r != null) {
        s = L5(r, "weights", "absoluteDifference");
      }
      D$(i.shape, o.shape, "Error in absoluteDifference: ");
      var u = y8(P9(i, o));
      return gre(u, s, a);
    }
  });
  var bre = B5({
    cosineDistance_: function (t, n, r, a, i = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var o = L5(t, "labels", "cosineDistance");
      var s = L5(n, "predictions", "cosineDistance");
      var u = null;
      if (a != null) {
        u = L5(a, "weights", "cosineDistance");
      }
      D$(o.shape, s.shape, "Error in cosineDistance: ");
      var c = i9(1);
      var l = P9(c, u9(g8(o, s), r, true));
      return gre(l, u, i);
    }
  });
  var xre = B5({
    hingeLoss_: function (t, n, r, a = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var i = L5(t, "labels", "hingeLoss");
      var o = L5(n, "predictions", "hingeLoss");
      var s = null;
      if (r != null) {
        s = L5(r, "weights", "hingeLoss");
      }
      D$(i.shape, o.shape, "Error in hingeLoss: ");
      var u = i9(1);
      i = P9(g8(i9(2), i), u);
      var c = lte(P9(u, g8(i, o)));
      return gre(c, s, a);
    }
  });
  var kre = B5({
    huberLoss_: function (t, n, r, a = 1, i = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var o = L5(t, "labels", "huberLoss");
      var s = L5(n, "predictions", "huberLoss");
      var u = null;
      if (r != null) {
        u = L5(r, "weights", "huberLoss");
      }
      D$(o.shape, s.shape, "Error in huberLoss: ");
      var c = i9(a);
      var l = y8(P9(s, o));
      var h = nee(l, c);
      var p = P9(l, h);
      var f = d8(g8(i9(0.5), s9(h)), g8(c, p));
      return gre(f, u, i);
    }
  });
  var wre = B5({
    logLoss_: function (t, n, r, a = 1e-7, i = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var o = L5(t, "labels", "logLoss");
      var s = L5(n, "predictions", "logLoss");
      var u = null;
      if (r != null) {
        u = L5(r, "weights", "logLoss");
      }
      D$(o.shape, s.shape, "Error in logLoss: ");
      var c = i9(1);
      var l = i9(a);
      var h = M9(g8(o, R9(d8(s, l))));
      var p = g8(P9(c, o), R9(d8(P9(c, s), l)));
      var f = P9(h, p);
      return gre(f, u, i);
    }
  });
  var Ire = B5({
    meanSquaredError_: function (t, n, r, a = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var i = L5(t, "labels", "meanSquaredError");
      var o = L5(n, "predictions", "meanSquaredError");
      var s = null;
      if (r != null) {
        s = L5(r, "weights", "meanSquaredError");
      }
      D$(i.shape, o.shape, "Error in meanSquaredError: ");
      var u = Lte(i, o);
      return gre(u, s, a);
    }
  });
  function Nre(e, t) {
    var n = L5(e, "labels", "sigmoidCrossEntropyWithLogits");
    var r = L5(t, "logits", "sigmoidCrossEntropyWithLogits");
    D$(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    var a = lte(r);
    var i = g8(r, n);
    var o = _9(p9(M9(y8(r))));
    return d8(P9(a, i), o);
  }
  var Sre = B5({
    sigmoidCrossEntropy_: function (t, n, r, a = 0, i = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var o = L5(t, "multiClassLabels", "sigmoidCrossEntropy");
      var s = L5(n, "logits", "sigmoidCrossEntropy");
      var u = null;
      if (r != null) {
        u = L5(r, "weights", "sigmoidCrossEntropy");
      }
      D$(o.shape, s.shape, "Error in sigmoidCrossEntropy: ");
      if (a > 0) {
        var c = i9(a);
        var l = i9(1);
        var h = i9(0.5);
        o = d8(g8(o, P9(l, c)), g8(h, c));
      }
      var p = Nre(o, s);
      return gre(p, u, i);
    }
  });
  function Tre(e, t, n = -1) {
    if (n === -1) {
      n = t.rank - 1;
    }
    if (n !== t.rank - 1) {
      throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);
    }
    var r = F9(function (e, t, r) {
      var a = W9(t, [n], true);
      var i = P9(h8(t, "float32"), a);
      r([e, i]);
      var o = M9(g8(i, e));
      return {
        value: u9(o, [n]),
        gradFunc: function (e, t) {
          var r = S(t, 2);
          var a = r[0];
          var i = r[1];
          var o = Z7(e.shape, [n]);
          return [g8(X8(e, o), P9(h8(a, "float32"), p9(i))), g8(X8(e, o), P9(p9(i), h8(a, "float32")))];
        }
      };
    });
    return r(e, t);
  }
  var Ere = B5({
    softmaxCrossEntropy_: function (t, n, r, a = 0, i = e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      var o = L5(t, "onehotLabels", "softmaxCrossEntropy");
      var s = L5(n, "logits", "softmaxCrossEntropy");
      var u = null;
      if (r != null) {
        u = L5(r, "weights", "softmaxCrossEntropy");
      }
      D$(o.shape, s.shape, "Error in softmaxCrossEntropy: ");
      if (a > 0) {
        var c = i9(a);
        var l = i9(1);
        var h = i9(o.shape[1]);
        o = d8(g8(o, P9(l, c)), m8(c, h));
      }
      var p = Tre(o, s);
      return gre(p, u, i);
    }
  });
  var Cre = B5({
    sparseFillEmptyRows_: function (e, t, n, r) {
      var a = L5(e, "indices", "sparseFillEmptyRows", "int32");
      var i = L5(t, "values", "sparseFillEmptyRows");
      var o = L5(n, "denseShape", "sparseFillEmptyRows", "int32");
      var s = L5(r, "defaultValue", "sparseFillEmptyRows", i.dtype);
      if (a.rank !== 2) {
        throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);
      }
      if (i.rank !== 1) {
        throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);
      }
      if (o.rank !== 1) {
        throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);
      }
      if (s.rank !== 0) {
        throw new Error(`Default value should be a scalar but received shape ${s.shape}`);
      }
      var u = {
        indices: a,
        values: i,
        denseShape: o,
        defaultValue: s
      };
      var c = E5.runKernel(u3, u);
      return {
        outputIndices: c[0],
        outputValues: c[1],
        emptyRowIndicator: c[2],
        reverseIndexMap: c[3]
      };
    }
  });
  var Are = B5({
    sparseReshape_: function (e, t, n) {
      var r = L5(e, "inputIndices", "sparseReshape", "int32");
      var a = L5(t, "inputShape", "sparseReshape", "int32");
      var i = L5(n, "newShape", "sparseReshape", "int32");
      if (r.rank !== 2) {
        throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);
      }
      if (a.rank !== 1) {
        throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);
      }
      if (i.rank !== 1) {
        throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);
      }
      var o = {
        inputIndices: r,
        inputShape: a,
        newShape: i
      };
      var s = E5.runKernel(c3, o);
      return {
        outputIndices: s[0],
        outputShape: s[1]
      };
    }
  });
  var Rre = B5({
    sparseSegmentMean_: function (e, t, n) {
      var r = L5(e, "data", "sparseSegmentMean");
      var a = L5(t, "indices", "sparseSegmentMean", "int32");
      var i = L5(n, "segmentIds", "sparseSegmentMean", "int32");
      if (r.rank < 1) {
        throw new Error("Data should be at least 1 dimensional but received scalar");
      }
      if (a.rank !== 1) {
        throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);
      }
      if (i.rank !== 1) {
        throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);
      }
      var o = {
        data: r,
        indices: a,
        segmentIds: i
      };
      return E5.runKernel(l3, o);
    }
  });
  var _re = B5({
    sparseSegmentSum_: function (e, t, n) {
      var r = L5(e, "data", "sparseSegmentSum");
      var a = L5(t, "indices", "sparseSegmentSum", "int32");
      var i = L5(n, "segmentIds", "sparseSegmentSum", "int32");
      if (r.rank < 1) {
        throw new Error("Data should be at least 1 dimensional but received scalar");
      }
      if (a.rank !== 1) {
        throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);
      }
      if (i.rank !== 1) {
        throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);
      }
      var o = {
        data: r,
        indices: a,
        segmentIds: i
      };
      return E5.runKernel(h3, o);
    }
  });
  var Ore = B5({
    stringNGrams_: function (e, t, n, r, a, i, o, s) {
      var u = L5(e, "data", "stringNGrams", "string");
      if (u.dtype !== "string") {
        throw new Error("Data must be of datatype string");
      }
      if (u.shape.length !== 1) {
        throw new Error(`Data must be a vector, saw: ${u.shape}`);
      }
      var c = L5(t, "dataSplits", "stringNGrams");
      if (c.dtype !== "int32") {
        throw new Error("Data splits must be of datatype int32");
      }
      var l = {
        separator: n,
        nGramWidths: r,
        leftPad: a,
        rightPad: i,
        padWidth: o,
        preserveShortSequences: s
      };
      var h = {
        data: u,
        dataSplits: c
      };
      var p = E5.runKernel(g3, h, l);
      return {
        nGrams: p[0],
        nGramsSplits: p[1]
      };
    }
  });
  var Fre = B5({
    stringSplit_: function (e, t) {
      var n = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
      var r = L5(e, "input", "stringSplit", "string");
      var a = L5(t, "delimiter", "stringSplit", "string");
      if (r.rank !== 1) {
        throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);
      }
      if (a.rank !== 0) {
        throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);
      }
      var i = {
        skipEmpty: n
      };
      var o = {
        input: r,
        delimiter: a
      };
      var s = E5.runKernel(y3, o, i);
      return {
        indices: s[0],
        values: s[1],
        shape: s[2]
      };
    }
  });
  var Dre = B5({
    stringToHashBucketFast_: function (e, t) {
      var n = L5(e, "input", "stringToHashBucketFast", "string");
      var r = {
        numBuckets: t
      };
      if (t <= 0) {
        throw new Error("Number of buckets must be at least 1");
      }
      var a = {
        input: n
      };
      return E5.runKernel(b3, a, r);
    }
  });
  var Mre = B5({
    staticRegexReplace_: function (e, t, n) {
      var r = !(arguments.length > 3) || arguments[3] === undefined || arguments[3];
      var a = L5(e, "input", "staticRegexReplace", "string");
      var i = {
        pattern: t,
        rewrite: n,
        replaceGlobal: r
      };
      return E5.runKernel(v3, {
        x: a
      }, i);
    }
  });
  var Lre = {
    fft: _te,
    ifft: Ote,
    rfft: Mte,
    irfft: Fte
  };
  var zre = {
    hammingWindow: Fne,
    hannWindow: Dne,
    frame: Mne,
    stft: Lne
  };
  var Pre = {
    flipLeftRight: Pne,
    grayscaleToRGB: Bne,
    resizeNearestNeighbor: ure,
    resizeBilinear: sre,
    rgbToGrayscale: Wne,
    rotateWithOffset: Une,
    cropAndResize: zne,
    nonMaxSuppression: Gne,
    nonMaxSuppressionAsync: ere,
    nonMaxSuppressionWithScore: tre,
    nonMaxSuppressionWithScoreAsync: rre,
    nonMaxSuppressionPadded: are,
    nonMaxSuppressionPaddedAsync: ore,
    threshold: lre,
    transform: hre
  };
  var Bre = {
    bandPart: pre,
    gramSchmidt: fre,
    qr: mre
  };
  var Wre = {
    absoluteDifference: yre,
    computeWeightedLoss: gre,
    cosineDistance: bre,
    hingeLoss: xre,
    huberLoss: kre,
    logLoss: wre,
    meanSquaredError: Ire,
    sigmoidCrossEntropy: Sre,
    softmaxCrossEntropy: Ere
  };
  var Ure = {
    sparseFillEmptyRows: Cre,
    sparseReshape: Are,
    sparseSegmentMean: Rre,
    sparseSegmentSum: _re
  };
  var Vre = {
    stringNGrams: Ore,
    stringSplit: Fre,
    stringToHashBucketFast: Dre,
    staticRegexReplace: Mre
  };
  var Gre = new Map();
  var jre = new Map();
  var Hre = function () {
    function e() {
      l(this, e);
    }
    p(e, [{
      key: "getClassName",
      value: function () {
        return this.constructor.className;
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        return new e(t);
      }
    }]);
    return e;
  }();
  var qre = function () {
    function e() {
      l(this, e);
      this.classNameMap = {};
    }
    p(e, null, [{
      key: "getMap",
      value: function () {
        if (e.instance == null) {
          e.instance = new e();
        }
        return e.instance;
      }
    }, {
      key: "register",
      value: function (t) {
        e.getMap().classNameMap[t.className] = [t, t.fromConfig];
      }
    }]);
    return e;
  }();
  function Kre(e, t, n) {
    F$(e.className != null, function () {
      return "Class being registered does not have the static className property defined.";
    });
    F$(typeof e.className == "string", function () {
      return "className is required to be a string, but got type " + s(e.className);
    });
    F$(e.className.length > 0, function () {
      return "Class being registered has an empty-string as its className, which is disallowed.";
    });
    if (t === undefined) {
      t = "Custom";
    }
    if (n === undefined) {
      n = e.className;
    }
    var r = t + ">" + n;
    qre.register(e);
    Gre.set(r, e);
    jre.set(e, r);
    return e;
  }
  var Xre = {
    __proto__: null,
    Serializable: Hre,
    SerializationMap: qre,
    getRegisteredName: function (e) {
      if (jre.has(e)) {
        return jre.get(e);
      } else {
        return e.className;
      }
    },
    registerClass: Kre
  };
  var Yre = function (e) {
    d(s, e);
    var t;
    var n;
    var r;
    var a;
    var i = w(s);
    function s() {
      l(this, s);
      return i.apply(this, arguments);
    }
    p(s, [{
      key: "minimize",
      value: function (e, t = false, n) {
        var r = this.computeGradients(e, n);
        var a = r.value;
        var i = r.grads;
        if (n != null) {
          var o = n.map(function (e) {
            return {
              name: e.name,
              tensor: i[e.name]
            };
          });
          this.applyGradients(o);
        } else {
          this.applyGradients(i);
        }
        Y5(i);
        if (t) {
          return a;
        } else {
          a.dispose();
          return null;
        }
      }
    }, {
      key: "iterations",
      get: function () {
        if (this.iterations_ == null) {
          this.iterations_ = 0;
        }
        return this.iterations_;
      }
    }, {
      key: "incrementIterations",
      value: function () {
        this.iterations_ = this.iterations + 1;
      }
    }, {
      key: "computeGradients",
      value: function (e, t) {
        return O9(e, t);
      }
    }, {
      key: "dispose",
      value: function () {
        if (this.iterations_ != null) {
          Y5(this.iterations_);
        }
      }
    }, {
      key: "saveIterations",
      value: (a = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.iterations_ == null) {
                  this.iterations_ = 0;
                }
                return e.abrupt("return", {
                  name: "iter",
                  tensor: i9(this.iterations_, "int32")
                });
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "getWeights",
      value: (r = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                throw new Error("getWeights() is not implemented for this optimizer yet.");
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function () {
        return r.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (n = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "extractIterations",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return t[0].tensor.data();
              case 2:
                this.iterations_ = e.sent[0];
                return e.abrupt("return", t.slice(1));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }]);
    return s;
  }(Hre);
  Object.defineProperty(Yre, Symbol.hasInstance, {
    value: function (e) {
      return e.minimize != null && e.computeGradients != null && e.applyGradients != null;
    }
  });
  var Jre = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t) {
      var n;
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      l(this, a);
      (n = r.call(this)).learningRate = e;
      n.rho = t;
      n.epsilon = i;
      n.accumulatedGrads = [];
      n.accumulatedUpdates = [];
      if (i == null) {
        n.epsilon = E5.backend.epsilon();
      }
      return n;
    }
    p(a, [{
      key: "applyGradients",
      value: function (e) {
        var t = this;
        (Array.isArray(e) ? e.map(function (e) {
          return e.name;
        }) : Object.keys(e)).forEach(function (n, r) {
          var a = E5.registeredVariables[n];
          if (t.accumulatedGrads[r] == null) {
            t.accumulatedGrads[r] = {
              originalName: `${n}/accum_grad`,
              variable: X5(function () {
                return U7(a).variable(false);
              })
            };
          }
          if (t.accumulatedUpdates[r] == null) {
            t.accumulatedUpdates[r] = {
              originalName: `${n}/accum_var`,
              variable: X5(function () {
                return U7(a).variable(false);
              })
            };
          }
          var i = Array.isArray(e) ? e[r].tensor : e[n];
          if (i != null) {
            var o = t.accumulatedGrads[r].variable;
            var s = t.accumulatedUpdates[r].variable;
            X5(function () {
              var e = d8(g8(o, t.rho), g8(s9(i), 1 - t.rho));
              var n = g8(m8(o9(d8(s, t.epsilon)), o9(d8(o, t.epsilon))), i);
              var r = d8(g8(s, t.rho), g8(s9(n), 1 - t.rho));
              o.assign(e);
              s.assign(r);
              var u = d8(g8(n, -t.learningRate), a);
              a.assign(u);
            });
          }
        });
        this.incrementIterations();
      }
    }, {
      key: "dispose",
      value: function () {
        if (this.accumulatedUpdates != null) {
          Y5(this.accumulatedGrads.map(function (e) {
            return e.variable;
          }));
          Y5(this.accumulatedUpdates.map(function (e) {
            return e.variable;
          }));
        }
      }
    }, {
      key: "getWeights",
      value: (n = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = [].concat(T(this.accumulatedGrads), T(this.accumulatedUpdates));
                e.next = 3;
                return this.saveIterations();
              case 3:
                e.t0 = e.sent;
                return e.abrupt("return", [e.t0].concat(t.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (t = c(o().mark(function e(t) {
        var n;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.extractIterations(t);
              case 2:
                t = e.sent;
                n = t.length / 2;
                this.accumulatedGrads = t.slice(0, n).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                  };
                });
                this.accumulatedUpdates = t.slice(n, n * 2).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                  };
                });
              case 7:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getConfig",
      value: function () {
        return {
          learningRate: this.learningRate,
          rho: this.rho,
          epsilon: this.epsilon
        };
      }
    }], [{
      key: "className",
      get: function () {
        return "Adadelta";
      }
    }, {
      key: "fromConfig",
      value: function (e, t) {
        return new e(t.learningRate, t.rho, t.epsilon);
      }
    }]);
    return a;
  }(Yre);
  var Zre = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e) {
      var t;
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;
      l(this, a);
      (t = r.call(this)).learningRate = e;
      t.initialAccumulatorValue = n;
      t.accumulatedGrads = [];
      return t;
    }
    p(a, [{
      key: "applyGradients",
      value: function (e) {
        var t = this;
        (Array.isArray(e) ? e.map(function (e) {
          return e.name;
        }) : Object.keys(e)).forEach(function (n, r) {
          var a = E5.registeredVariables[n];
          if (t.accumulatedGrads[r] == null) {
            t.accumulatedGrads[r] = {
              originalName: `${n}/accumulator`,
              variable: X5(function () {
                return f7(a.shape, t.initialAccumulatorValue).variable(false);
              })
            };
          }
          var i = Array.isArray(e) ? e[r].tensor : e[n];
          if (i != null) {
            var o = t.accumulatedGrads[r].variable;
            X5(function () {
              var e = d8(o, s9(i));
              o.assign(e);
              var n = d8(g8(m8(i, o9(d8(e, E5.backend.epsilon()))), -t.learningRate), a);
              a.assign(n);
            });
          }
        });
        this.incrementIterations();
      }
    }, {
      key: "dispose",
      value: function () {
        if (this.accumulatedGrads != null) {
          Y5(this.accumulatedGrads.map(function (e) {
            return e.variable;
          }));
        }
      }
    }, {
      key: "getWeights",
      value: (n = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.saveIterations();
              case 2:
                e.t0 = e.sent;
                return e.abrupt("return", [e.t0].concat(this.accumulatedGrads.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.extractIterations(t);
              case 2:
                t = e.sent;
                this.accumulatedGrads = t.map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                  };
                });
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getConfig",
      value: function () {
        return {
          learningRate: this.learningRate,
          initialAccumulatorValue: this.initialAccumulatorValue
        };
      }
    }], [{
      key: "className",
      get: function () {
        return "Adagrad";
      }
    }, {
      key: "fromConfig",
      value: function (e, t) {
        return new e(t.learningRate, t.initialAccumulatorValue);
      }
    }]);
    return a;
  }(Yre);
  var Qre = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t, n) {
      var i;
      var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      l(this, a);
      (i = r.call(this)).learningRate = e;
      i.beta1 = t;
      i.beta2 = n;
      i.epsilon = o;
      i.accumulatedFirstMoment = [];
      i.accumulatedSecondMoment = [];
      X5(function () {
        i.accBeta1 = i9(t).variable();
        i.accBeta2 = i9(n).variable();
      });
      if (o == null) {
        i.epsilon = E5.backend.epsilon();
      }
      return i;
    }
    p(a, [{
      key: "applyGradients",
      value: function (e) {
        var t = this;
        var n = Array.isArray(e) ? e.map(function (e) {
          return e.name;
        }) : Object.keys(e);
        X5(function () {
          var r = P9(1, t.accBeta1);
          var a = P9(1, t.accBeta2);
          n.forEach(function (n, i) {
            var o = E5.registeredVariables[n];
            if (t.accumulatedFirstMoment[i] == null) {
              t.accumulatedFirstMoment[i] = {
                originalName: `${n}/m`,
                variable: X5(function () {
                  return U7(o).variable(false);
                })
              };
            }
            if (t.accumulatedSecondMoment[i] == null) {
              t.accumulatedSecondMoment[i] = {
                originalName: `${n}/v`,
                variable: X5(function () {
                  return U7(o).variable(false);
                })
              };
            }
            var s = Array.isArray(e) ? e[i].tensor : e[n];
            if (s != null) {
              var u = t.accumulatedFirstMoment[i].variable;
              var c = t.accumulatedSecondMoment[i].variable;
              var l = d8(g8(u, t.beta1), g8(s, 1 - t.beta1));
              var h = d8(g8(c, t.beta2), g8(s9(s), 1 - t.beta2));
              var p = m8(l, r);
              var f = m8(h, a);
              u.assign(l);
              c.assign(h);
              var d = d8(g8(m8(p, d8(o9(f), t.epsilon)), -t.learningRate), o);
              o.assign(d);
            }
          });
          t.accBeta1.assign(g8(t.accBeta1, t.beta1));
          t.accBeta2.assign(g8(t.accBeta2, t.beta2));
        });
        this.incrementIterations();
      }
    }, {
      key: "dispose",
      value: function () {
        this.accBeta1.dispose();
        this.accBeta2.dispose();
        if (this.accumulatedFirstMoment != null) {
          Y5(this.accumulatedFirstMoment.map(function (e) {
            return e.variable;
          }));
        }
        if (this.accumulatedSecondMoment != null) {
          Y5(this.accumulatedSecondMoment.map(function (e) {
            return e.variable;
          }));
        }
      }
    }, {
      key: "getWeights",
      value: (n = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = [].concat(T(this.accumulatedFirstMoment), T(this.accumulatedSecondMoment));
                e.next = 3;
                return this.saveIterations();
              case 3:
                e.t0 = e.sent;
                return e.abrupt("return", [e.t0].concat(t.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.extractIterations(t);
              case 2:
                t = e.sent;
                X5(function () {
                  r.accBeta1.assign(a9(r.beta1, r.iterations_ + 1));
                  r.accBeta2.assign(a9(r.beta2, r.iterations_ + 1));
                });
                n = t.length / 2;
                this.accumulatedFirstMoment = t.slice(0, n).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                  };
                });
                this.accumulatedSecondMoment = t.slice(n, n * 2).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                  };
                });
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getConfig",
      value: function () {
        return {
          learningRate: this.learningRate,
          beta1: this.beta1,
          beta2: this.beta2,
          epsilon: this.epsilon
        };
      }
    }], [{
      key: "className",
      get: function () {
        return "Adam";
      }
    }, {
      key: "fromConfig",
      value: function (e, t) {
        return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
      }
    }]);
    return a;
  }(Yre);
  var $re = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t, n) {
      var i;
      var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      l(this, a);
      (i = r.call(this)).learningRate = e;
      i.beta1 = t;
      i.beta2 = n;
      i.epsilon = o;
      i.decay = s;
      i.accumulatedFirstMoment = [];
      i.accumulatedWeightedInfNorm = [];
      X5(function () {
        i.iteration = i9(0).variable();
        i.accBeta1 = i9(t).variable();
      });
      if (o == null) {
        i.epsilon = E5.backend.epsilon();
      }
      return i;
    }
    p(a, [{
      key: "applyGradients",
      value: function (e) {
        var t = this;
        var n = Array.isArray(e) ? e.map(function (e) {
          return e.name;
        }) : Object.keys(e);
        X5(function () {
          var r = P9(1, t.accBeta1);
          var a = m8(-t.learningRate, d8(g8(t.iteration, t.decay), 1));
          n.forEach(function (n, i) {
            var o = E5.registeredVariables[n];
            if (t.accumulatedFirstMoment[i] == null) {
              t.accumulatedFirstMoment[i] = {
                originalName: `${n}/m`,
                variable: U7(o).variable(false)
              };
            }
            if (t.accumulatedWeightedInfNorm[i] == null) {
              t.accumulatedWeightedInfNorm[i] = {
                originalName: `${n}/v`,
                variable: U7(o).variable(false)
              };
            }
            var s = Array.isArray(e) ? e[i].tensor : e[n];
            if (s != null) {
              var u = t.accumulatedFirstMoment[i].variable;
              var c = t.accumulatedWeightedInfNorm[i].variable;
              var l = d8(g8(u, t.beta1), g8(s, 1 - t.beta1));
              var h = g8(c, t.beta2);
              var p = y8(s);
              var f = Z9(h, p);
              u.assign(l);
              c.assign(f);
              var d = d8(g8(m8(a, r), m8(l, d8(f, t.epsilon))), o);
              o.assign(d);
            }
          });
          t.iteration.assign(d8(t.iteration, 1));
          t.accBeta1.assign(g8(t.accBeta1, t.beta1));
        });
        this.incrementIterations();
      }
    }, {
      key: "dispose",
      value: function () {
        this.accBeta1.dispose();
        this.iteration.dispose();
        if (this.accumulatedFirstMoment != null) {
          Y5(this.accumulatedFirstMoment.map(function (e) {
            return e.variable;
          }));
        }
        if (this.accumulatedWeightedInfNorm != null) {
          Y5(this.accumulatedWeightedInfNorm.map(function (e) {
            return e.variable;
          }));
        }
      }
    }, {
      key: "getWeights",
      value: (n = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                throw new Error("getWeights() is not implemented for Adamax yet.");
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                throw new Error("setWeights() is not implemented for Adamax yet.");
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getConfig",
      value: function () {
        return {
          learningRate: this.learningRate,
          beta1: this.beta1,
          beta2: this.beta2,
          epsilon: this.epsilon,
          decay: this.decay
        };
      }
    }], [{
      key: "className",
      get: function () {
        return "Adamax";
      }
    }, {
      key: "fromConfig",
      value: function (e, t) {
        return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
      }
    }]);
    return a;
  }(Yre);
  var eae = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e) {
      var t;
      l(this, a);
      (t = r.call(this)).learningRate = e;
      t.setLearningRate(e);
      return t;
    }
    p(a, [{
      key: "applyGradients",
      value: function (e) {
        var t = this;
        (Array.isArray(e) ? e.map(function (e) {
          return e.name;
        }) : Object.keys(e)).forEach(function (n, r) {
          var a = Array.isArray(e) ? e[r].tensor : e[n];
          if (a != null) {
            var i = E5.registeredVariables[n];
            X5(function () {
              var e = d8(g8(t.c, a), i);
              i.assign(e);
            });
          }
        });
        this.incrementIterations();
      }
    }, {
      key: "setLearningRate",
      value: function (e) {
        this.learningRate = e;
        if (this.c != null) {
          this.c.dispose();
        }
        this.c = J5(i9(-e));
      }
    }, {
      key: "dispose",
      value: function () {
        this.c.dispose();
      }
    }, {
      key: "getWeights",
      value: (n = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.saveIterations();
              case 2:
                e.t0 = e.sent;
                return e.abrupt("return", [e.t0]);
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.extractIterations(t);
              case 2:
                if ((t = e.sent).length === 0) {
                  e.next = 5;
                  break;
                }
                throw new Error("SGD optimizer does not have settable weights.");
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getConfig",
      value: function () {
        return {
          learningRate: this.learningRate
        };
      }
    }], [{
      key: "className",
      get: function () {
        return "SGD";
      }
    }, {
      key: "fromConfig",
      value: function (e, t) {
        return new e(t.learningRate);
      }
    }]);
    return a;
  }(Yre);
  var tae = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t) {
      var n;
      var i = arguments.length > 2 && arguments[2] !== undefined && arguments[2];
      l(this, a);
      (n = r.call(this, e)).learningRate = e;
      n.momentum = t;
      n.useNesterov = i;
      n.accumulations = [];
      n.m = i9(n.momentum);
      return n;
    }
    p(a, [{
      key: "applyGradients",
      value: function (e) {
        var t = this;
        (Array.isArray(e) ? e.map(function (e) {
          return e.name;
        }) : Object.keys(e)).forEach(function (n, r) {
          var a = E5.registeredVariables[n];
          if (t.accumulations[r] == null) {
            t.accumulations[r] = {
              originalName: `${n}/momentum`,
              variable: X5(function () {
                return U7(a).variable(false);
              })
            };
          }
          var i = t.accumulations[r].variable;
          var o = Array.isArray(e) ? e[r].tensor : e[n];
          if (o != null) {
            X5(function () {
              var e;
              var n = d8(g8(t.m, i), o);
              e = t.useNesterov ? d8(g8(t.c, d8(o, g8(n, t.m))), a) : d8(g8(t.c, n), a);
              i.assign(n);
              a.assign(e);
            });
          }
        });
        this.incrementIterations();
      }
    }, {
      key: "dispose",
      value: function () {
        this.m.dispose();
        if (this.accumulations != null) {
          Y5(this.accumulations.map(function (e) {
            return e.variable;
          }));
        }
      }
    }, {
      key: "setMomentum",
      value: function (e) {
        this.momentum = e;
      }
    }, {
      key: "getWeights",
      value: (n = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.saveIterations();
              case 2:
                e.t0 = e.sent;
                return e.abrupt("return", [e.t0].concat(this.accumulations.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.extractIterations(t);
              case 2:
                t = e.sent;
                this.accumulations = t.map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                  };
                });
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getConfig",
      value: function () {
        return {
          learningRate: this.learningRate,
          momentum: this.momentum,
          useNesterov: this.useNesterov
        };
      }
    }], [{
      key: "className",
      get: function () {
        return "Momentum";
      }
    }, {
      key: "fromConfig",
      value: function (e, t) {
        return new e(t.learningRate, t.momentum, t.useNesterov);
      }
    }]);
    return a;
  }(eae);
  var nae = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e) {
      var t;
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.9;
      var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var s = arguments.length > 4 && arguments[4] !== undefined && arguments[4];
      l(this, a);
      (t = r.call(this)).learningRate = e;
      t.decay = n;
      t.momentum = i;
      t.epsilon = o;
      t.accumulatedMeanSquares = [];
      t.accumulatedMoments = [];
      t.accumulatedMeanGrads = [];
      t.centered = s;
      if (o == null) {
        t.epsilon = E5.backend.epsilon();
      }
      if (e == null) {
        throw new Error("learningRate for RMSPropOptimizer must be defined.");
      }
      return t;
    }
    p(a, [{
      key: "applyGradients",
      value: function (e) {
        var t = this;
        (Array.isArray(e) ? e.map(function (e) {
          return e.name;
        }) : Object.keys(e)).forEach(function (n, r) {
          var a = E5.registeredVariables[n];
          var i = false;
          if (t.accumulatedMeanSquares[r] == null) {
            t.accumulatedMeanSquares[r] = {
              originalName: `${n}/rms`,
              variable: X5(function () {
                return U7(a).variable(i);
              })
            };
          }
          if (t.accumulatedMoments[r] == null) {
            t.accumulatedMoments[r] = {
              originalName: `${n}/momentum`,
              variable: X5(function () {
                return U7(a).variable(i);
              })
            };
          }
          if (t.accumulatedMeanGrads[r] == null && t.centered) {
            t.accumulatedMeanGrads[r] = {
              originalName: `${n}/mg`,
              variable: X5(function () {
                return U7(a).variable(i);
              })
            };
          }
          var o = Array.isArray(e) ? e[r].tensor : e[n];
          if (o != null) {
            var s = t.accumulatedMeanSquares[r].variable;
            var u = t.accumulatedMoments[r].variable;
            X5(function () {
              var e = d8(g8(s, t.decay), g8(s9(o), 1 - t.decay));
              if (t.centered) {
                var n = t.accumulatedMeanGrads[r].variable;
                var i = d8(g8(n, t.decay), g8(o, 1 - t.decay));
                var c = m8(g8(o, t.learningRate), o9(P9(e, d8(s9(i), t.epsilon))));
                var l = d8(g8(u, t.momentum), c);
                s.assign(e);
                n.assign(i);
                u.assign(l);
                var h = P9(a, l);
                a.assign(h);
              } else {
                var p = d8(g8(s, t.decay), g8(s9(o), 1 - t.decay));
                var f = d8(g8(u, t.momentum), m8(g8(o, t.learningRate), o9(d8(p, t.epsilon))));
                s.assign(p);
                u.assign(f);
                var d = P9(a, f);
                a.assign(d);
              }
            });
          }
        });
        this.incrementIterations();
      }
    }, {
      key: "dispose",
      value: function () {
        if (this.accumulatedMeanSquares != null) {
          Y5(this.accumulatedMeanSquares.map(function (e) {
            return e.variable;
          }));
        }
        if (this.accumulatedMeanGrads != null && this.centered) {
          Y5(this.accumulatedMeanGrads.map(function (e) {
            return e.variable;
          }));
        }
        if (this.accumulatedMoments != null) {
          Y5(this.accumulatedMoments.map(function (e) {
            return e.variable;
          }));
        }
      }
    }, {
      key: "getWeights",
      value: (n = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = [].concat(T(this.accumulatedMeanSquares), T(this.accumulatedMoments));
                if (this.centered) {
                  t.push.apply(t, T(this.accumulatedMeanGrads));
                }
                e.next = 4;
                return this.saveIterations();
              case 4:
                e.t0 = e.sent;
                return e.abrupt("return", [e.t0].concat(t.map(function (e) {
                  return {
                    name: e.originalName,
                    tensor: e.variable
                  };
                })));
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setWeights",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.extractIterations(t);
              case 2:
                t = e.sent;
                n = this.centered ? t.length / 3 : t.length / 2;
                r = false;
                this.accumulatedMeanSquares = t.slice(0, n).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(r)
                  };
                });
                this.accumulatedMoments = t.slice(n, n * 2).map(function (e) {
                  return {
                    originalName: e.name,
                    variable: e.tensor.variable(r)
                  };
                });
                if (this.centered) {
                  this.accumulatedMeanGrads = t.slice(n * 2, n * 3).map(function (e) {
                    return {
                      originalName: e.name,
                      variable: e.tensor.variable(r)
                    };
                  });
                }
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getConfig",
      value: function () {
        return {
          learningRate: this.learningRate,
          decay: this.decay,
          momentum: this.momentum,
          epsilon: this.epsilon,
          centered: this.centered
        };
      }
    }], [{
      key: "className",
      get: function () {
        return "RMSProp";
      }
    }, {
      key: "fromConfig",
      value: function (e, t) {
        return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
      }
    }]);
    return a;
  }(Yre);
  var rae = [Jre, Zre, Qre, $re, tae, nae, eae];
  function aae(e) {
    return new Promise(function (e) {
      return setTimeout(e);
    }).then(e);
  }
  var iae = function () {
    function e(t) {
      l(this, e);
      if (!k0().getBool("IS_BROWSER")) {
        throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
      }
      if (t.startsWith(e.URL_SCHEME)) {
        t = t.slice(e.URL_SCHEME.length);
      }
      if (t == null || t.length === 0) {
        t = "model";
      }
      this.modelJsonFileName = t + ".json";
      this.weightDataFileName = t + ".weights.bin";
    }
    var t;
    p(e, [{
      key: "save",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (typeof document != "undefined") {
                  e.next = 2;
                  break;
                }
                throw new Error("Browser downloads are not supported in this environment since `document` is not present");
              case 2:
                n = j5.join(t.weightData);
                r = window.URL.createObjectURL(new Blob([n], {
                  type: "application/octet-stream"
                }));
                if (!(t.modelTopology instanceof ArrayBuffer)) {
                  e.next = 8;
                  break;
                }
                throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
              case 8:
                a = [{
                  paths: ["./" + this.weightDataFileName],
                  weights: t.weightSpecs
                }];
                i = b6(t, a);
                s = window.URL.createObjectURL(new Blob([JSON.stringify(i)], {
                  type: "application/json"
                }));
                (u = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor).download = this.modelJsonFileName;
                u.href = s;
                e.next = 16;
                return aae(function () {
                  return u.dispatchEvent(new MouseEvent("click"));
                });
              case 16:
                if (t.weightData == null) {
                  e.next = 22;
                  break;
                }
                (c = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName;
                c.href = r;
                e.next = 22;
                return aae(function () {
                  return c.dispatchEvent(new MouseEvent("click"));
                });
              case 22:
                return e.abrupt("return", {
                  modelArtifactsInfo: I6(t)
                });
              case 23:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }]);
    return e;
  }();
  iae.URL_SCHEME = "downloads://";
  var oae = function () {
    function e(t) {
      l(this, e);
      if (t == null || t.length < 1) {
        throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);
      }
      this.jsonFile = t[0];
      this.weightsFiles = t.slice(1);
    }
    var t;
    p(e, [{
      key: "load",
      value: (t = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", new Promise(function (e, n) {
                  var r = new FileReader();
                  r.onload = function (r) {
                    var a = JSON.parse(r.target.result);
                    var i = a.modelTopology;
                    if (i != null) {
                      if (a.weightsManifest != null) {
                        if (t.weightsFiles.length !== 0) {
                          var o = k6(a, function (e) {
                            return t.loadWeights(e);
                          });
                          e(o);
                        } else {
                          e({
                            modelTopology: i
                          });
                        }
                      } else {
                        n(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));
                      }
                    } else {
                      n(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));
                    }
                  };
                  r.onerror = function (e) {
                    return n(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);
                  };
                  r.readAsText(t.jsonFile);
                }));
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function () {
        return t.apply(this, arguments);
      })
    }, {
      key: "loadWeights",
      value: function (e) {
        var t;
        var n = this;
        var r = [];
        var a = [];
        var i = O(e);
        try {
          for (i.s(); !(t = i.n()).done;) {
            var o = t.value;
            r.push.apply(r, T(o.weights));
            a.push.apply(a, T(o.paths));
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
        var s = this.checkManifestAndWeightFiles(e);
        var u = a.map(function (e) {
          return n.loadWeightsFile(e, s[e]);
        });
        return Promise.all(u).then(function (e) {
          return [r, e];
        });
      }
    }, {
      key: "loadWeightsFile",
      value: function (e, t) {
        return new Promise(function (n, r) {
          var a = new FileReader();
          a.onload = function (e) {
            var t = e.target.result;
            n(t);
          };
          a.onerror = function (t) {
            return r(`Failed to weights data from file of path '${e}'.`);
          };
          a.readAsArrayBuffer(t);
        });
      }
    }, {
      key: "checkManifestAndWeightFiles",
      value: function (e) {
        var t;
        var n = this;
        var r = [];
        var a = this.weightsFiles.map(function (e) {
          return y6(e.name);
        });
        var i = {};
        var o = O(e);
        try {
          for (o.s(); !(t = o.n()).done;) {
            t.value.paths.forEach(function (e) {
              var t = y6(e);
              if (r.indexOf(t) !== -1) {
                throw new Error(`Duplicate file basename found in weights manifest: '${t}'`);
              }
              r.push(t);
              if (a.indexOf(t) === -1) {
                throw new Error(`Weight file with basename '${t}' is not provided.`);
              }
              i[e] = n.weightsFiles[a.indexOf(t)];
            });
          }
        } catch (e) {
          o.e(e);
        } finally {
          o.f();
        }
        if (r.length !== this.weightsFiles.length) {
          throw new Error(`Mismatch in the number of files in weights manifest (${r.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
        }
        return i;
      }
    }]);
    return e;
  }();
  function sae(e, t, n, r) {
    (function (e) {
      F$(e != null && Array.isArray(e) && e.length > 0, function () {
        return "promises must be a none empty array";
      });
    })(e);
    (function (e, t) {
      F$(e >= 0 && e <= 1, function () {
        return `Progress fraction must be in range [0, 1], but got startFraction ${e}`;
      });
      F$(t >= 0 && t <= 1, function () {
        return `Progress fraction must be in range [0, 1], but got endFraction ${t}`;
      });
      F$(t >= e, function () {
        return `startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`;
      });
    })(n = n == null ? 0 : n, r = r == null ? 1 : r);
    var a = 0;
    return Promise.all(e.map(function (i) {
      i.then(function (i) {
        var o = n + ++a / e.length * (r - n);
        t(o);
        return i;
      });
      return i;
    }));
  }
  function uae(e, t) {
    return cae.apply(this, arguments);
  }
  function cae() {
    return (cae = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              if (n == null) {
                n = {};
              }
              r = n.fetchFunc == null ? k0().platform.fetch : n.fetchFunc;
              a = t.map(function (e) {
                return r(e, n.requestInit, {
                  isBinary: true
                });
              });
              i = 0;
              s = 0.5;
              if (n.onProgress != null) {
                e.next = 11;
                break;
              }
              e.next = 8;
              return Promise.all(a);
            case 8:
              e.t0 = e.sent;
              e.next = 14;
              break;
            case 11:
              e.next = 13;
              return sae(a, n.onProgress, i, s);
            case 13:
              e.t0 = e.sent;
            case 14:
              u = e.t0;
              c = u.map(function (e) {
                return e.arrayBuffer();
              });
              l = 0.5;
              h = 1;
              if (n.onProgress != null) {
                e.next = 24;
                break;
              }
              e.next = 21;
              return Promise.all(c);
            case 21:
              e.t1 = e.sent;
              e.next = 27;
              break;
            case 24:
              e.next = 26;
              return sae(c, n.onProgress, l, h);
            case 26:
              e.t1 = e.sent;
            case 27:
              p = e.t1;
              return e.abrupt("return", p);
            case 29:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  function lae(e, t) {
    var n;
    var r;
    var a;
    var i = t.fetchFunc == null ? k0().platform.fetch : t.fetchFunc;
    var s = 0;
    if ((n = t.onProgress) !== null && n !== undefined) {
      n.call(t, 0);
    }
    return new ReadableStream({
      pull: (a = c(o().mark(function n(a) {
        var u;
        var c;
        var l;
        var h;
        var p;
        return o().wrap(function (n) {
          while (true) {
            switch (n.prev = n.next) {
              case 0:
                if (!(s < e.length)) {
                  n.next = 20;
                  break;
                }
                if (r) {
                  n.next = 6;
                  break;
                }
                n.next = 4;
                return i(e[s], t.requestInit, {
                  isBinary: true
                });
              case 4:
                c = n.sent.body;
                r = c.getReader();
              case 6:
                n.next = 8;
                return r.read();
              case 8:
                l = n.sent;
                h = l.done;
                p = l.value;
                if (!h) {
                  n.next = 16;
                  break;
                }
                s++;
                r = undefined;
                if ((u = t.onProgress) !== null && u !== undefined) {
                  u.call(t, s / e.length);
                }
                return n.abrupt("continue", 0);
              case 16:
                a.enqueue(p);
                return n.abrupt("return");
              case 20:
                a.close();
              case 21:
              case "end":
                return n.stop();
            }
          }
        }, n);
      })), function (e) {
        return a.apply(this, arguments);
      })
    });
  }
  function hae(e) {
    return pae.apply(this, arguments);
  }
  function pae() {
    pae = c(o().mark(function e(t) {
      var n;
      var r;
      var a;
      var i;
      var s = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              n = s.length > 1 && s[1] !== undefined ? s[1] : "";
              r = s.length > 2 ? s[2] : undefined;
              a = s.length > 3 ? s[3] : undefined;
              i = fae(function (e) {
                return uae(e, {
                  requestInit: a
                });
              });
              return e.abrupt("return", i(t, n, r));
            case 6:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return pae.apply(this, arguments);
  }
  function fae(e) {
    return function () {
      var t = c(o().mark(function t(n) {
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f;
        var d;
        var v;
        var m = arguments;
        return o().wrap(function (t) {
          while (true) {
            switch (t.prev = t.next) {
              case 0:
                r = m.length > 1 && m[1] !== undefined ? m[1] : "";
                a = m.length > 2 ? m[2] : undefined;
                i = n.map(function () {
                  return false;
                });
                s = {};
                u = a != null ? a.map(function () {
                  return false;
                }) : [];
                c = [];
                n.forEach(function (e, t) {
                  var n = 0;
                  e.weights.forEach(function (e) {
                    var r = "quantization" in e ? e.quantization.dtype : e.dtype;
                    var o = G5[r] * L$(e.shape);
                    function l() {
                      i[t] = true;
                      if (s[t] == null) {
                        s[t] = [];
                      }
                      s[t].push({
                        manifestEntry: e,
                        groupOffset: n,
                        sizeBytes: o
                      });
                    }
                    if (a != null) {
                      a.forEach(function (t, n) {
                        if (t === e.name) {
                          l();
                          u[n] = true;
                        }
                      });
                    } else {
                      l();
                    }
                    c.push(e.name);
                    n += o;
                  });
                });
                if (u.every(function (e) {
                  return e;
                })) {
                  t.next = 10;
                  break;
                }
                l = a.filter(function (e, t) {
                  return !u[t];
                });
                throw new Error(`Could not find weights in manifest with names: ${l.join(", ")}. 
Manifest JSON has weights with names: ${c.join(", ")}.`);
              case 10:
                h = i.reduce(function (e, t, n) {
                  if (t) {
                    e.push(n);
                  }
                  return e;
                }, []);
                p = [];
                h.forEach(function (e) {
                  n[e].paths.forEach(function (e) {
                    var t = r + (r.endsWith("/") ? "" : "/") + e;
                    p.push(t);
                  });
                });
                t.next = 15;
                return e(p);
              case 15:
                f = t.sent;
                d = {};
                v = 0;
                h.forEach(function (e) {
                  var t = n[e].paths.length;
                  var r = new j5(f.slice(v, v + t));
                  s[e].forEach(function (e) {
                    var t = r6(r.slice(e.groupOffset, e.groupOffset + e.sizeBytes), [e.manifestEntry]);
                    for (var n in t) {
                      d[n] = t[n];
                    }
                  });
                  v += t;
                });
                return t.abrupt("return", d);
              case 20:
              case "end":
                return t.stop();
            }
          }
        }, t);
      }));
      return function (e) {
        return t.apply(this, arguments);
      };
    }();
  }
  S6.registerSaveRouter(function (e) {
    if (k0().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(iae.URL_SCHEME)) {
      return function (e = "model") {
        return new iae(e);
      }(e.slice(iae.URL_SCHEME.length));
    } else {
      return null;
    }
  });
  var dae = function () {
    function e(t, n) {
      l(this, e);
      this.DEFAULT_METHOD = "POST";
      if (n == null) {
        n = {};
      }
      this.weightPathPrefix = n.weightPathPrefix;
      this.weightUrlConverter = n.weightUrlConverter;
      if (n.fetchFunc != null) {
        F$(typeof n.fetchFunc == "function", function () {
          return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
        });
        this.fetch = n.fetchFunc;
      } else {
        this.fetch = k0().platform.fetch;
      }
      F$(t != null && t.length > 0, function () {
        return "URL path for http must not be null, undefined or empty.";
      });
      if (Array.isArray(t)) {
        F$(t.length === 2, function () {
          return `URL paths for http must have a length of 2, (actual length is ${t.length}).`;
        });
      }
      this.path = t;
      if (n.requestInit != null && n.requestInit.body != null) {
        throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      }
      this.requestInit = n.requestInit || {};
      this.loadOptions = n;
    }
    var t;
    var n;
    var r;
    var a;
    var i;
    p(e, [{
      key: "save",
      value: (i = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        var i;
        var s;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(t.modelTopology instanceof ArrayBuffer)) {
                  e.next = 2;
                  break;
                }
                throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
              case 2:
                (n = Object.assign({
                  method: this.DEFAULT_METHOD
                }, this.requestInit)).body = new FormData();
                r = [{
                  paths: ["./model.weights.bin"],
                  weights: t.weightSpecs
                }];
                a = b6(t, r);
                n.body.append("model.json", new Blob([JSON.stringify(a)], {
                  type: "application/json"
                }), "model.json");
                if (t.weightData != null) {
                  i = j5.join(t.weightData);
                  n.body.append("model.weights.bin", new Blob([i], {
                    type: "application/octet-stream"
                  }), "model.weights.bin");
                }
                e.next = 10;
                return this.fetch(this.path, n);
              case 10:
                if (!(s = e.sent).ok) {
                  e.next = 15;
                  break;
                }
                return e.abrupt("return", {
                  modelArtifactsInfo: I6(t),
                  responses: [s]
                });
              case 15:
                throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`);
              case 16:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return i.apply(this, arguments);
      })
    }, {
      key: "loadModelJSON",
      value: (a = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.fetch(this.path, this.requestInit);
              case 2:
                if ((t = e.sent).ok) {
                  e.next = 5;
                  break;
                }
                throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);
              case 5:
                e.prev = 5;
                e.next = 8;
                return t.json();
              case 8:
                n = e.sent;
                e.next = 16;
                break;
              case 11:
                e.prev = 11;
                e.t0 = e.catch(5);
                r = `Failed to parse model JSON of response from ${this.path}.`;
                if (this.path.endsWith(".pb")) {
                  r += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
                } else {
                  r += " Please make sure the server is serving valid JSON for this request.";
                }
                throw new Error(r);
              case 16:
                a = n.modelTopology;
                i = n.weightsManifest;
                if (a != null || i != null) {
                  e.next = 20;
                  break;
                }
                throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
              case 20:
                return e.abrupt("return", n);
              case 21:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[5, 11]]);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "load",
      value: (r = c(o().mark(function e() {
        var t;
        var n = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!this.loadOptions.streamWeights) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", this.loadStream());
              case 2:
                e.next = 4;
                return this.loadModelJSON();
              case 4:
                t = e.sent;
                return e.abrupt("return", k6(t, function (e) {
                  return n.loadWeights(e);
                }));
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return r.apply(this, arguments);
      })
    }, {
      key: "loadStream",
      value: (n = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.loadModelJSON();
              case 2:
                t = e.sent;
                e.next = 5;
                return this.getWeightUrls(t.weightsManifest);
              case 5:
                n = e.sent;
                r = N6(t.weightsManifest);
                a = function () {
                  return lae(n, i.loadOptions);
                };
                return e.abrupt("return", Object.assign(Object.assign({}, t), {
                  weightSpecs: r,
                  getWeightStream: a
                }));
              case 9:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "getWeightUrls",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f;
        var d;
        var v;
        var m;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                n = Array.isArray(this.path) ? this.path[1] : this.path;
                r = vae(n);
                a = S(r, 2);
                i = a[0];
                s = a[1];
                u = this.weightPathPrefix || i;
                c = [];
                l = [];
                h = O(t);
                try {
                  for (h.s(); !(p = h.n()).done;) {
                    f = p.value;
                    d = O(f.paths);
                    try {
                      for (d.s(); !(v = d.n()).done;) {
                        m = v.value;
                        if (this.weightUrlConverter != null) {
                          l.push(this.weightUrlConverter(m));
                        } else {
                          c.push(u + m + s);
                        }
                      }
                    } catch (e) {
                      d.e(e);
                    } finally {
                      d.f();
                    }
                  }
                } catch (e) {
                  h.e(e);
                } finally {
                  h.f();
                }
                if (!this.weightUrlConverter) {
                  e.next = 16;
                  break;
                }
                e.t0 = c.push;
                e.t1 = c;
                e.t2 = T;
                e.next = 13;
                return Promise.all(l);
              case 13:
                e.t3 = e.sent;
                e.t4 = (0, e.t2)(e.t3);
                e.t0.apply.call(e.t0, e.t1, e.t4);
              case 16:
                return e.abrupt("return", c);
              case 17:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "loadWeights",
      value: function () {
        var e = c(o().mark(function e(t) {
          var n;
          var r;
          var a;
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  e.next = 2;
                  return this.getWeightUrls(t);
                case 2:
                  n = e.sent;
                  r = N6(t);
                  e.next = 6;
                  return uae(n, this.loadOptions);
                case 6:
                  a = e.sent;
                  return e.abrupt("return", [r, a]);
                case 8:
                case "end":
                  return e.stop();
              }
            }
          }, e, this);
        }));
        return function (t) {
          return e.apply(this, arguments);
        };
      }()
    }]);
    return e;
  }();
  function vae(e) {
    var t = e.lastIndexOf("/");
    var n = e.lastIndexOf("?");
    return [e.substring(0, t) + "/", n > t ? e.substring(n) : ""];
  }
  function mae(e) {
    return e.match(dae.URL_SCHEME_REGEX) != null;
  }
  dae.URL_SCHEME_REGEX = /^https?:\/\//;
  function gae(e, t) {
    if (typeof fetch == "undefined" && (t == null || t.fetchFunc == null)) {
      return null;
    }
    if (Array.isArray(e) ? e.every(function (e) {
      return mae(e);
    }) : mae(e)) {
      return yae(e, t);
    } else {
      return null;
    }
  }
  function yae(e, t) {
    return new dae(e, t);
  }
  function bae(e, t) {
    return yae(e, t);
  }
  S6.registerSaveRouter(gae);
  S6.registerLoadRouter(gae);
  var xae = function () {
    function e(t) {
      l(this, e);
      this.modelArtifacts = t;
    }
    p(e, [{
      key: "load",
      value: function () {
        return this.modelArtifacts;
      }
    }]);
    return e;
  }();
  var kae = function () {
    function e(t) {
      l(this, e);
      this.saveHandler = t;
    }
    p(e, [{
      key: "save",
      value: function (e) {
        return this.saveHandler(e);
      }
    }]);
    return e;
  }();
  var wae = p(function e(t) {
    l(this, e);
    if (t.load) {
      this.load = function () {
        return Promise.resolve(t.load());
      };
    }
    if (t.save) {
      this.save = function (e) {
        return Promise.resolve(t.save(e));
      };
    }
  });
  function Iae(e, t, n, r) {
    if (arguments.length === 1) {
      var a = e.modelTopology != null || e.weightSpecs != null;
      if (a) {
        return new xae(e);
      } else {
        console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
        return new xae({
          modelTopology: e
        });
      }
    }
    console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
    return new xae({
      modelTopology: e,
      weightSpecs: t,
      weightData: n,
      trainingConfig: r
    });
  }
  var Nae = {
    __proto__: null,
    CompositeArrayBuffer: j5,
    browserFiles: function (e) {
      return new oae(e);
    },
    browserHTTPRequest: bae,
    concatenateArrayBuffers: g6,
    copyModel: function (e, t) {
      return a8.apply(this, arguments);
    },
    decodeWeights: r6,
    decodeWeightsStream: l6,
    encodeWeights: t6,
    fromMemory: function (e, t, n, r) {
      var a = arguments;
      return new wae(Iae.apply(undefined, T(a)));
    },
    fromMemorySync: Iae,
    getLoadHandlers: E6,
    getModelArtifactsForJSON: k6,
    getModelArtifactsForJSONSync: x6,
    getModelArtifactsInfoForJSON: I6,
    getSaveHandlers: T6,
    getWeightSpecs: N6,
    http: yae,
    isHTTPScheme: mae,
    listModels: function () {
      return n8.apply(this, arguments);
    },
    loadWeights: hae,
    moveModel: function (e, t) {
      return i8.apply(this, arguments);
    },
    registerLoadRouter: function (e) {
      return S6.registerLoadRouter(e);
    },
    registerSaveRouter: function (e) {
      return S6.registerSaveRouter(e);
    },
    removeModel: function (e) {
      return r8.apply(this, arguments);
    },
    weightsLoaderFactory: fae,
    withSaveHandler: function (e) {
      return new kae(e);
    },
    withSaveHandlerSync: function (e) {
      return new kae(e);
    }
  };
  var Sae;
  var Tae = {
    __proto__: null,
    confusionMatrix: B5({
      confusionMatrix_: function (e, t, n) {
        var r = L5(e, "labels", "confusionMatrix");
        var a = L5(t, "predictions", "confusionMatrix");
        F$(n == null || n > 0 && Number.isInteger(n), function () {
          return `If provided, numClasses must be a positive integer, but got ${n}`;
        });
        F$(r.rank === 1, function () {
          return `Expected the rank of labels to be 1, but got ${r.rank}`;
        });
        F$(a.rank === 1, function () {
          return `Expected the rank of predictions to be 1, but got ${a.rank}`;
        });
        F$(r.shape[0] === a.shape[0], function () {
          return `Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`;
        });
        F$(n > 0 && Number.isInteger(n), function () {
          return `numClasses is required to be a positive integer, but got ${n}`;
        });
        var i = cee(h8(r, "int32"), n);
        var o = cee(h8(a, "int32"), n);
        var s = hne(i);
        var u = Q8(s, o);
        return h8(u, "int32");
      }
    })
  };
  var Eae = false;
  function Cae(e, t = 3) {
    if (t > 4) {
      throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    }
    if (e == null) {
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    }
    var n = false;
    var r = false;
    var a = false;
    var i = false;
    var o = false;
    var s = false;
    if (e.data instanceof Uint8Array) {
      n = true;
    } else if (typeof ImageData != "undefined" && e instanceof ImageData) {
      r = true;
    } else if (typeof HTMLVideoElement != "undefined" && e instanceof HTMLVideoElement) {
      a = true;
    } else if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement) {
      i = true;
    } else if (e.getContext != null) {
      o = true;
    } else {
      if (typeof ImageBitmap == "undefined" || !(e instanceof ImageBitmap)) {
        throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);
      }
      s = true;
    }
    var u = W3(O3, E5.backendName);
    if (u != null) {
      var c = {
        pixels: e
      };
      var l = {
        numChannels: t
      };
      return E5.runKernel(O3, c, l);
    }
    var h;
    var p;
    var f = a ? [e.videoWidth, e.videoHeight] : [e.width, e.height];
    var d = S(f, 2);
    var v = d[0];
    var m = d[1];
    if (o) {
      h = e.getContext("2d").getImageData(0, 0, v, m).data;
    } else if (r || n) {
      h = e.data;
    } else if (i || a || s) {
      if (Sae == null) {
        if (typeof document == "undefined") {
          if (typeof OffscreenCanvas == "undefined" || typeof OffscreenCanvasRenderingContext2D == "undefined") {
            throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
          }
          Sae = new OffscreenCanvas(1, 1).getContext("2d");
        } else {
          Sae = document.createElement("canvas").getContext("2d", {
            willReadFrequently: true
          });
        }
      }
      Sae.canvas.width = v;
      Sae.canvas.height = m;
      Sae.drawImage(e, 0, 0, v, m);
      h = Sae.getImageData(0, 0, v, m).data;
    }
    if (t === 4) {
      p = new Int32Array(h);
    } else {
      var g = v * m;
      p = new Int32Array(g * t);
      for (var y = 0; y < g; y++) {
        for (var b = 0; b < t; ++b) {
          p[y * t + b] = h[y * 4 + b];
        }
      }
    }
    var x = [m, v, t];
    return jte(p, x, "int32");
  }
  function Aae(e) {
    return typeof window != "undefined" && typeof ImageBitmap != "undefined" && window.hasOwnProperty("createImageBitmap") && !(e instanceof ImageBitmap) && function (e) {
      return e != null && e.width !== 0 && e.height !== 0;
    }(e) && !function (e) {
      return e != null && e.data instanceof Uint8Array;
    }(e);
  }
  function Rae() {
    Rae = c(o().mark(function e(t) {
      var n;
      var r;
      var a;
      var i = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              n = i.length > 1 && i[1] !== undefined ? i[1] : 3;
              r = null;
              if (!k0().getBool("WRAP_TO_IMAGEBITMAP") || !Aae(t)) {
                e.next = 15;
                break;
              }
              e.prev = 3;
              e.next = 6;
              return createImageBitmap(t, {
                premultiplyAlpha: "none"
              });
            case 6:
              a = e.sent;
              e.next = 12;
              break;
            case 9:
              e.prev = 9;
              e.t0 = e.catch(3);
              a = null;
            case 12:
              r = a != null && a.width === t.width && a.height === t.height ? a : t;
              e.next = 16;
              break;
            case 15:
              r = t;
            case 16:
              return e.abrupt("return", Cae(r, n));
            case 17:
            case "end":
              return e.stop();
          }
        }
      }, e, null, [[3, 9]]);
    }));
    return Rae.apply(this, arguments);
  }
  function _ae(e) {
    if (e.rank !== 2 && e.rank !== 3) {
      throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);
    }
    var t = e.rank === 2 ? 1 : e.shape[2];
    if (t > 4 || t === 2) {
      throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);
    }
    if (e.dtype !== "float32" && e.dtype !== "int32") {
      throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);
    }
  }
  function Oae() {
    Oae = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      var y;
      var b;
      var x;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = L5(t, "img", "toPixels");
              if (!(t instanceof n5)) {
                r = h8(a = r, "int32");
                a.dispose();
              }
              _ae(r);
              i = r.shape.slice(0, 2);
              s = S(i, 2);
              u = s[0];
              c = s[1];
              l = r.rank === 2 ? 1 : r.shape[2];
              e.next = 7;
              return r.data();
            case 7:
              h = e.sent;
              p = r.dtype === "float32" ? 255 : 1;
              f = new Uint8ClampedArray(c * u * 4);
              d = 0;
            case 11:
              if (!(d < u * c)) {
                e.next = 36;
                break;
              }
              v = [0, 0, 0, 255];
              m = 0;
            case 14:
              if (!(m < l)) {
                e.next = 28;
                break;
              }
              g = h[d * l + m];
              if (r.dtype !== "float32") {
                e.next = 21;
                break;
              }
              if (!(g < 0) && !(g > 1)) {
                e.next = 19;
                break;
              }
              throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`);
            case 19:
              e.next = 24;
              break;
            case 21:
              if (r.dtype !== "int32") {
                e.next = 24;
                break;
              }
              if (!(g < 0) && !(g > 255)) {
                e.next = 24;
                break;
              }
              throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);
            case 24:
              if (l === 1) {
                v[0] = g * p;
                v[1] = g * p;
                v[2] = g * p;
              } else {
                v[m] = g * p;
              }
            case 25:
              m++;
              e.next = 14;
              break;
            case 28:
              f[(y = d * 4) + 0] = Math.round(v[0]);
              f[y + 1] = Math.round(v[1]);
              f[y + 2] = Math.round(v[2]);
              f[y + 3] = Math.round(v[3]);
            case 33:
              ++d;
              e.next = 11;
              break;
            case 36:
              if (n != null) {
                if (!Eae) {
                  if (W3(x1, E5.backendName) != null) {
                    console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead.");
                    Eae = true;
                  }
                }
                n.width = c;
                n.height = u;
                b = n.getContext("2d");
                x = new ImageData(f, c, u);
                b.putImageData(x, 0, 0);
              }
              if (r !== t) {
                r.dispose();
              }
              return e.abrupt("return", f);
            case 39:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return Oae.apply(this, arguments);
  }
  var Fae = B5({
    fromPixels_: Cae
  });
  var Dae = {
    __proto__: null,
    draw: function (e, t, n) {
      var r = L5(e, "img", "draw");
      if (!(e instanceof n5)) {
        var a = r;
        r = h8(a, "int32");
        a.dispose();
      }
      _ae(r);
      (function (e) {
        var t = (e == null ? undefined : e.alpha) || 1;
        if (t > 1 || t < 0) {
          throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`);
        }
      })(n == null ? undefined : n.imageOptions);
      var i = {
        image: r
      };
      var o = {
        canvas: t,
        options: n
      };
      E5.runKernel(x1, i, o);
    },
    fromPixels: Fae,
    fromPixelsAsync: function (e) {
      return Rae.apply(this, arguments);
    },
    toPixels: function (e, t) {
      return Oae.apply(this, arguments);
    }
  };
  function Mae(e, t) {
    var n = e.shape.length;
    var r = t.shape.length;
    if (n < 1) {
      throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);
    }
    if (r < 1) {
      throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);
    }
    if (t.dtype !== "int32") {
      throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
    }
    if (t.shape[r - 1] > n) {
      throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r - 1]} vs. ${n}`);
    }
    if (L$(e.shape) === 0) {
      throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);
    }
    for (var a = t.shape, i = a[a.length - 1], o = 1, s = 0; s < a.length - 1; ++s) {
      o *= a[s];
    }
    var u = e.shape;
    var c = a.slice();
    c.pop();
    var l = 1;
    for (var h = i; h < n; ++h) {
      l *= u[h];
      c.push(u[h]);
    }
    var p = [].concat(T(i0(e.shape).map(function (e) {
      return e / l;
    })), [1]).slice(0, i);
    return [c, o, l, p];
  }
  var Lae = {
    __proto__: null,
    prepareAndValidate: Mae
  };
  function zae(e, t, n) {
    var r = e.shape.length;
    F$(r === t.length, function () {
      return `Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`;
    });
    F$(r === n.length, function () {
      return `Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`;
    });
    var a = function (a) {
      F$(t[a] + n[a] <= e.shape[a], function () {
        return `Error in slice${r}D: begin[${a}] + size[${a}] (${t[a] + n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`;
      });
    };
    for (var i = 0; i < r; ++i) {
      a(i);
    }
  }
  function Pae(e, t, n) {
    var r = [];
    for (var a = 0; a < e.length; a++) {
      r[a] = Math.ceil((t[a] - e[a]) / n[a]);
    }
    return r;
  }
  function Bae(e, t, n, r) {
    var a = T(e);
    for (var i = a.length; i < r.length; i++) {
      a.push(1);
    }
    for (var o = 0; o < n; o++) {
      if (o === 0) {
        a[t] = 1;
      } else {
        a.splice(t, 0, 1);
        a.pop();
      }
    }
    return a;
  }
  function Wae(e, t, n) {
    if (n <= e) {
      return n;
    } else {
      return n - (t - 1);
    }
  }
  function Uae(e, t) {
    var n = [];
    for (var r = 0; r < e; r++) {
      n.push(t + r);
    }
    return n;
  }
  function Vae(e, t, n, r, a) {
    for (var i = T(a), o = Uae(n, t), s = 0; s < i.length; s++) {
      if (o.indexOf(s) > -1) {
        i[s] = 0;
      } else {
        var u = Wae(t, n, s);
        var c = r[u];
        if (e & 1 << u) {
          c = 0;
        }
        i[s] = c;
      }
    }
    return i;
  }
  function Gae(e, t, n, r, a) {
    for (var i = T(a), o = Uae(n, t), s = 0; s < i.length; s++) {
      if (o.indexOf(s) > -1) {
        i[s] = Number.MAX_SAFE_INTEGER;
      } else {
        var u = Wae(t, n, s);
        var c = r[u];
        if (e & 1 << u) {
          c = Number.MAX_SAFE_INTEGER;
        }
        i[s] = c;
      }
    }
    for (var l = 0; l < i.length; l++) {
      var h = a[l];
      if (i[l] < 0) {
        i[l] += h;
      }
      i[l] = A$(0, i[l], a[l]);
    }
    return i;
  }
  function jae(e, t, n) {
    var r = e[t];
    if (n & 1 << t || r == null) {
      r = 1;
    }
    return r;
  }
  function Hae(e, t, n, r, a, i) {
    var o = t[a];
    var s = n[a] || 1;
    if (e & 1 << a || i & 1 << a || o == null) {
      o = s > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;
    }
    var u = r[a];
    if (o < 0) {
      o += u;
    }
    return o = A$(0, o, u - 1);
  }
  function qae(e, t, n, r, a, i) {
    var o = t[a];
    var s = n[a] || 1;
    if (e & 1 << a || i & 1 << a || o == null) {
      o = s > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER;
    }
    var u = r[a];
    if (o < 0) {
      o += u;
    }
    return o = s > 0 ? A$(0, o, u) : A$(-1, o, u - 1);
  }
  function Kae(e, t, n) {
    var r = n.length;
    for (var a = 0; a < n.length; a++) {
      if (n[a] > 1) {
        r = a;
        break;
      }
    }
    for (var i = r + 1; i < n.length; i++) {
      if (t[i] > 0 || n[i] !== e[i]) {
        return false;
      }
    }
    return true;
  }
  function Xae(e, t) {
    var n = e.length > 0 ? e[e.length - 1] : 1;
    for (var r = 0; r < e.length - 1; r++) {
      n += e[r] * t[r];
    }
    return n;
  }
  function Yae(e, t, n) {
    var r;
    var a;
    var i = e.shape.length;
    (r = typeof t == "number" ? [t].concat(T(new Array(i - 1).fill(0))) : t.length < i ? t.concat(new Array(i - t.length).fill(0)) : t.slice()).forEach(function (e) {
      F$(e !== -1, function () {
        return "slice() does not support negative begin indexing.";
      });
    });
    a = (a = n == null ? new Array(i).fill(-1) : typeof n == "number" ? [n].concat(T(new Array(i - 1).fill(-1))) : n.length < i ? n.concat(new Array(i - n.length).fill(-1)) : n).map(function (t, n) {
      if (t >= 0) {
        return t;
      } else {
        F$(t === -1, function () {
          return `Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`;
        });
        return e.shape[n] - r[n];
      }
    });
    return [r, a];
  }
  function Jae(e, t, n, r, a, i, o, s, u) {
    var c;
    if (r == null) {
      (c = new Array(t.length)).fill(1);
    } else {
      c = r;
    }
    if (o != null && (o & o - 1) != 0) {
      throw new Error("Multiple ellipses in slice is not allowed.");
    }
    var l = false;
    for (var h = {
        dims: c.length,
        numAddAxisAfterEllipsis: 0,
        begin: t.slice(),
        end: n.slice(),
        strides: c.slice(),
        beginMask: a,
        endMask: i,
        ellipsisMask: o,
        newAxisMask: s,
        shrinkAxisMask: u
      }, p = 0; p < h.dims; p++) {
      if (l && (1 << p & s) != 0) {
        h.numAddAxisAfterEllipsis++;
      }
      if (1 << p & o) {
        l = true;
      }
    }
    if (!l) {
      h.ellipsisMask |= 1 << h.dims;
      h.dims++;
    }
    var f = {
      dims: e.length,
      beginMask: 0,
      endMask: 0,
      beginValid: false,
      endValid: false
    };
    (function (e, t) {
      t.beginMask = 0;
      t.endMask = 0;
      t.shrinkAxisMask = 0;
      var n = 0;
      t.beginValid = e.begin != null;
      t.endValid = e.end != null;
      t.begin = new Array(t.dims);
      t.end = new Array(t.dims);
      t.strides = new Array(t.dims);
      t.finalShapeGatherIndices = [];
      t.finalShapeGatherIndicesSparse = [];
      t.inputShapeGatherIndicesSparse = new Array(t.dims);
      for (var r = 0; r < e.dims; r++) {
        if (1 << r & e.ellipsisMask) {
          for (var a = Math.min(t.dims - (e.dims - r) + 1 + e.numAddAxisAfterEllipsis, t.dims); n < a; n++) {
            t.begin[n] = 0;
            t.end[n] = 0;
            t.strides[n] = 1;
            t.beginMask |= 1 << n;
            t.endMask |= 1 << n;
            t.finalShapeGatherIndices.push(n);
            t.finalShapeGatherIndicesSparse.push(-1);
            t.inputShapeGatherIndicesSparse[n] = r;
          }
        } else if (1 << r & e.newAxisMask) {
          t.finalShapeGatherIndices.push(-2);
          t.finalShapeGatherIndicesSparse.push(-1);
        } else {
          if (n === t.begin.length) {
            throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);
          }
          if (e.begin != null) {
            t.begin[n] = e.begin[r];
          }
          if (e.end != null) {
            t.end[n] = e.end[r];
          }
          t.strides[n] = e.strides[r];
          if (e.beginMask & 1 << r) {
            t.beginMask |= 1 << n;
          }
          if (e.endMask & 1 << r) {
            t.endMask |= 1 << n;
          }
          if (e.shrinkAxisMask & 1 << r) {
            t.finalShapeGatherIndices.push(-1);
            t.finalShapeGatherIndicesSparse.push(-1);
            t.shrinkAxisMask |= 1 << n;
          } else {
            t.finalShapeGatherIndices.push(n);
            t.finalShapeGatherIndicesSparse.push(r);
          }
          t.inputShapeGatherIndicesSparse[n] = r;
          n++;
        }
      }
    })(h, f);
    var d = true;
    var v = true;
    var m = true;
    var g = [];
    var y = [];
    for (var b = 0; b < e.length; ++b) {
      if (f.strides[b] === 0) {
        throw Error(`strides[${b}] must be non-zero`);
      }
      var x = !!(f.shrinkAxisMask & 1 << b);
      var k = e[b];
      if (k !== -1) {
        var w = [f.beginMask & 1 << b, f.endMask & 1 << b];
        var I = [f.strides[b] > 0 ? 0 : -1, f.strides[b] > 0 ? k : k - 1];
        if (x && f.strides[b] <= 0) {
          throw Error("only stride 1 allowed on non-range indexing.");
        }
        m = m && f.strides[b] === 1;
        var N = !!(f.beginMask & 1 << b) && !!(f.endMask & 1 << b);
        if (f.beginValid && f.endValid) {
          if (x) {
            var S = f.begin[b] < 0 ? k + f.begin[b] : f.begin[b];
            f.begin[b] = S;
            f.end[b] = f.begin[b] + 1;
            if (S < 0 || S >= k) {
              throw Error(`slice index ${f.begin[b]} of dimension ${b} out of bounds.`);
            }
          } else {
            f.begin[b] = Zae(f.begin[b], 0, f.strides[b], k, w, I);
            f.end[b] = Zae(f.end[b], 1, f.strides[b], k, w, I);
          }
          var T = f.strides[b] === 1 && f.begin[b] === 0 && f.end[b] === k;
          d = d && T;
          v = v && (b === 0 && f.strides[b] === 1 || T);
        } else {
          d = d && f.strides[b] === 1 && N;
          v = v && (b === 0 && f.strides[b] === 1 || N);
        }
        var E = undefined;
        var C = false;
        if (f.beginValid && f.endValid) {
          E = f.end[b] - f.begin[b];
          C = true;
        } else if (x) {
          E = 1;
          C = true;
        } else if (N && k >= 0) {
          E = f.strides[b] < 0 ? -k : k;
          C = true;
        }
        if (C) {
          var A = undefined;
          A = E === 0 || E < 0 != f.strides[b] < 0 ? 0 : Math.trunc(E / f.strides[b]) + (E % f.strides[b] != 0 ? 1 : 0);
          g.push(A);
        } else {
          g.push(-1);
        }
      } else {
        g.push(x ? 1 : -1);
      }
    }
    for (var R = 0; R < f.finalShapeGatherIndices.length; ++R) {
      var _ = f.finalShapeGatherIndices[R];
      if (_ >= 0) {
        y.push(g[_]);
      } else if (_ === -2) {
        y.push(1);
      }
    }
    var O = y.filter(function (e, t) {
      return f.finalShapeGatherIndices[t] !== -2;
    });
    return {
      finalShapeSparse: O,
      finalShape: y,
      isIdentity: d,
      sliceDim0: v,
      isSimpleSlice: m,
      begin: f.begin,
      end: f.end,
      strides: f.strides
    };
  }
  function Zae(e, t, n, r, a, i) {
    if (a[t]) {
      if (n > 0) {
        return i[t];
      } else {
        return i[t + 1 & 1];
      }
    }
    var o = e < 0 ? r + e : e;
    if (o < i[0]) {
      return i[0];
    } else if (o > i[1]) {
      return i[1];
    } else {
      return o;
    }
  }
  var Qae;
  var $ae = {
    __proto__: null,
    assertParamsValid: zae,
    computeFlatOffset: Xae,
    computeOutShape: Pae,
    getNormalizedAxes: function (e, t, n, r, a, i, o, s, u) {
      var c = e.length;
      var l = new Array(c);
      var h = new Array(c);
      var p = new Array(c);
      if (t.length && n > 0) {
        var f = t[0];
        var d = n + 1;
        l = Vae(o, f, d, r, e);
        h = Gae(s, f, d, a, e);
        p = Bae(i, f, d, e);
      } else {
        for (var v = 0; v < c; v++) {
          l[v] = Hae(o, r, i, e, v, u);
          h[v] = qae(s, a, i, e, v, u);
          p[v] = jae(i, v, u);
        }
      }
      return {
        begin: l,
        end: h,
        strides: p
      };
    },
    isSliceContinous: Kae,
    maskToAxes: function (e) {
      var t = [];
      var n = 0;
      while (e > 0) {
        if (e & 1) {
          t.push(n);
        }
        e /= 2;
        n++;
      }
      return t;
    },
    parseSliceParams: Yae,
    sliceInfo: Jae,
    startForAxis: Hae,
    startIndicesWithElidedDims: Vae,
    stopForAxis: qae,
    stopIndicesWithElidedDims: Gae,
    stridesForAxis: jae,
    stridesWithElidedDims: Bae
  };
  var eie = "4.15.0";
  var tie = function () {
    function e() {
      l(this, e);
    }
    p(e, null, [{
      key: "sgd",
      value: function (e) {
        return new eae(e);
      }
    }, {
      key: "momentum",
      value: function (e, t, n = false) {
        return new tae(e, t, n);
      }
    }, {
      key: "rmsprop",
      value: function (e, t = 0.9, n = 0, r = null, a = false) {
        return new nae(e, t, n, r, a);
      }
    }, {
      key: "adam",
      value: function (e = 0.001, t = 0.9, n = 0.999, r = null) {
        return new Qre(e, t, n, r);
      }
    }, {
      key: "adadelta",
      value: function (e = 0.001, t = 0.95, n = null) {
        return new Jre(e, t, n);
      }
    }, {
      key: "adamax",
      value: function (e = 0.002, t = 0.9, n = 0.999, r = null, a = 0) {
        return new $re(e, t, n, r, a);
      }
    }, {
      key: "adagrad",
      value: function (e, t = 0.1) {
        return new Zre(e, t);
      }
    }]);
    return e;
  }();
  var nie = tie;
  var rie = typeof requestAnimationFrame != "undefined" ? requestAnimationFrame : typeof setImmediate != "undefined" ? setImmediate : function (e) {
    return e();
  };
  function aie() {
    return new Promise(function (e) {
      return rie(function () {
        return e();
      });
    });
  }
  function iie(e, t) {
    var n = e[0].length;
    e.forEach(function (e, t) {
      F$(e.length === n, function () {
        return `Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`;
      });
    });
    F$(t >= 0 && t < n, function () {
      return `Error in concat${n}D: axis must be between 0 and ${n - 1}.`;
    });
    var r = e[0];
    e.forEach(function (e, a) {
      for (var i = 0; i < n; i++) {
        F$(i === t || e[i] === r[i], function () {
          return `Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`;
        });
      }
    });
  }
  function oie(e, t) {
    var n = e[0].slice();
    for (var r = 1; r < e.length; r++) {
      n[t] += e[r][t];
    }
    return n;
  }
  function sie(e, t, n) {
    var r = new Array();
    if (n == null && t == null) {
      return r;
    }
    if (t == null) {
      while (r.length < e + n.length) {
        r.push(-1);
      }
    } else {
      r = t.slice();
    }
    if (n == null) {
      return r;
    }
    if (e + n.length !== r.length) {
      throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e + n.length}, but shape.rank = ${r.length}`);
    }
    for (var a = 1; a < n.length; ++a) {
      var i = n[a];
      var o = r[r.length - n.length + a];
      var s = r[o];
      if (i >= 0) {
        if (s >= 0) {
          if (s !== i) {
            throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a + e}] = ${i} but shape[${a + e}] = ${s}`);
          }
        } else {
          r[o] = i;
        }
      }
    }
    return r;
  }
  function uie(e) {
    var t;
    var n = {
      FIRST_DIM_SIZE: Qae.FIRST_DIM_SIZE,
      VALUE_ROWIDS: Qae.VALUE_ROWIDS,
      ROW_LENGTHS: Qae.ROW_LENGTHS,
      ROW_SPLITS: Qae.ROW_SPLITS,
      ROW_LIMITS: Qae.ROW_LIMITS,
      ROW_STARTS: Qae.ROW_STARTS
    };
    var r = [];
    var a = O(e);
    try {
      for (a.s(); !(t = a.n()).done;) {
        var i = t.value;
        if (!(i in n)) {
          break;
        }
        r.push(n[i]);
      }
    } catch (e) {
      a.e(e);
    } finally {
      a.f();
    }
    return r;
  }
  function cie(e) {
    if (e.length === 0) {
      return 0;
    } else if (e[0] === Qae.FIRST_DIM_SIZE) {
      return e.length - 1;
    } else {
      return e.length;
    }
  }
  function lie(e, t) {
    if (e != null && t != null) {
      var n = e.length;
      var r = t.length;
      if (n >= r) {
        throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);
      }
      for (var a = 0; a < Math.min(n, r - 1); ++a) {
        var i = e[a];
        var o = t[a + 1];
        if (i >= 0 && o >= 0 && i !== 1 && i !== o) {
          throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a - e.length}] = ${i} but ragged tensor input.flatValues.shape[${a - e.length}] = ${o}`);
        }
      }
    }
  }
  (function (e) {
    e[e.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE";
    e[e.VALUE_ROWIDS = 1] = "VALUE_ROWIDS";
    e[e.ROW_LENGTHS = 2] = "ROW_LENGTHS";
    e[e.ROW_SPLITS = 3] = "ROW_SPLITS";
    e[e.ROW_LIMITS = 4] = "ROW_LIMITS";
    e[e.ROW_STARTS = 5] = "ROW_STARTS";
  })(Qae ||= {});
  function hie(e) {
    if (e <= 30) {
      return e;
    } else {
      return a0(e, Math.floor(Math.sqrt(e)));
    }
  }
  function pie(e, t, n) {
    return [n * (typeof e == "number" ? e : e[0]), t * (typeof e == "number" ? e : e[1])];
  }
  function fie(e, t, n) {
    var r = !(arguments.length > 3) || arguments[3] === undefined || arguments[3];
    var a = [];
    if (r) {
      (a = a.concat(t.slice(0))).push(e[0] / n);
      a = a.concat(e.slice(1));
    } else {
      a = a.concat(e[0]);
      for (var i = t.length, o = 0; o < i; ++o) {
        a = a.concat([e[o + 1] / t[o], t[o]]);
      }
      a = a.concat(e.slice(i + 1));
    }
    return a;
  }
  function die(e, t) {
    var n = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
    var r = [];
    if (n) {
      r.push(t);
      for (var a = t + 1; a < e; ++a) {
        if (a <= t * 2) {
          r.push(a);
          r.push(a - (t + 1));
        } else {
          r.push(a);
        }
      }
    } else {
      var i = [];
      var o = [];
      for (var s = 1; s < e; ++s) {
        if (s >= t * 2 + 1 || s % 2 == 1) {
          o.push(s);
        } else {
          i.push(s);
        }
      }
      r.push.apply(r, i);
      r.push(0);
      r.push.apply(r, o);
    }
    return r;
  }
  function vie(e, t, n) {
    var r = !(arguments.length > 3) || arguments[3] === undefined || arguments[3];
    var a = [];
    if (r) {
      a.push(e[0] / n);
    } else {
      a.push(e[0] * n);
    }
    for (var i = 1; i < e.length; ++i) {
      if (i <= t.length) {
        if (r) {
          a.push(t[i - 1] * e[i]);
        } else {
          a.push(e[i] / t[i - 1]);
        }
      } else {
        a.push(e[i]);
      }
    }
    return a;
  }
  function mie(e, t) {
    var n = [0];
    for (var r = 0; r < t; ++r) {
      n.push(e[r][0]);
    }
    return n;
  }
  function gie(e, t, n) {
    var r = e.slice(0, 1);
    for (var a = 0; a < n; ++a) {
      r.push(e[a + 1] - t[a][0] - t[a][1]);
    }
    return r;
  }
  var yie = 1.7580993408473768;
  var bie = 1.0507009873554805;
  var xie = 0.3275911;
  var kie = 0.254829592;
  var wie = -0.284496736;
  var Iie = 1.421413741;
  var Nie = -1.453152027;
  var Sie = 1.061405429;
  function Tie(e, t) {
    if (e.length !== t.length) {
      throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);
    }
    for (var n = new Float32Array(e.length * 2), r = 0; r < n.length; r += 2) {
      n[r] = e[r / 2];
      n[r + 1] = t[r / 2];
    }
    return n;
  }
  function Eie(e) {
    var t = new Float32Array(e.length / 2);
    var n = new Float32Array(e.length / 2);
    for (var r = 0; r < e.length; r += 2) {
      t[r / 2] = e[r];
      n[r / 2] = e[r + 1];
    }
    return {
      real: t,
      imag: n
    };
  }
  function Cie(e) {
    var t = Math.ceil(e.length / 4);
    var n = new Float32Array(t);
    var r = new Float32Array(t);
    for (var a = 0; a < e.length; a += 4) {
      n[Math.floor(a / 4)] = e[a];
      r[Math.floor(a / 4)] = e[a + 1];
    }
    return {
      real: n,
      imag: r
    };
  }
  function Aie(e) {
    var t = Math.floor(e.length / 4);
    var n = new Float32Array(t);
    var r = new Float32Array(t);
    for (var a = 2; a < e.length; a += 4) {
      n[Math.floor(a / 4)] = e[a];
      r[Math.floor(a / 4)] = e[a + 1];
    }
    return {
      real: n,
      imag: r
    };
  }
  function Rie(e, t) {
    return {
      real: e[t * 2],
      imag: e[t * 2 + 1]
    };
  }
  function _ie(e, t, n, r) {
    e[r * 2] = t;
    e[r * 2 + 1] = n;
  }
  function Oie(e, t) {
    var n = new Float32Array(e / 2);
    var r = new Float32Array(e / 2);
    for (var a = 0; a < Math.ceil(e / 2); a++) {
      var i = (t ? 2 : -2) * Math.PI * (a / e);
      n[a] = Math.cos(i);
      r[a] = Math.sin(i);
    }
    return {
      real: n,
      imag: r
    };
  }
  function Fie(e, t, n) {
    var r = (n ? 2 : -2) * Math.PI * (e / t);
    return {
      real: Math.cos(r),
      imag: Math.sin(r)
    };
  }
  var Die = "->";
  var Mie = /->/g;
  function Lie(e, t) {
    var n = ((e = e.replace(/\s/g, "")).length - e.replace(Mie, "").length) / Die.length;
    if (n < 1) {
      throw new Error("Equations without an arrow are not supported.");
    }
    if (n > 1) {
      throw new Error(`Equation must contain exactly one arrow ("${Die}").`);
    }
    var r = S(e.split(Die), 2);
    var a = r[0];
    var i = r[1];
    F$(a.indexOf("...") === -1, function () {
      return `The ellipsis notation ("...") is not supported yet.`;
    });
    var o = a.split(",");
    var s = o.length;
    if (t !== s) {
      throw new Error(`Expected ${s} input tensors, received ${t}`);
    }
    if (s > 2) {
      throw new Error("Support for more than 2 input tensors is not implemented yet.");
    }
    var u = [];
    var c = function () {
      var e = i[l];
      if (!o.some(function (t) {
        return t.indexOf(e) !== -1;
      })) {
        throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);
      }
      if (u.indexOf(e) === -1) {
        u.push(e);
      }
    };
    for (var l = 0; l < i.length; ++l) {
      c();
    }
    for (var h = 0; h < a.length; ++h) {
      var p = a[h];
      if (u.indexOf(p) === -1 && p !== ",") {
        u.push(p);
      }
    }
    var f = new Array(o.length);
    for (var d = 0; d < s; ++d) {
      if (new Set(o[d].split("")).size !== o[d].length) {
        throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);
      }
      f[d] = [];
      for (var v = 0; v < o[d].length; ++v) {
        f[d].push(u.indexOf(o[d][v]));
      }
    }
    for (var m = u.length, g = [], y = i.length; y < m; ++y) {
      g.push(y);
    }
    return {
      allDims: u,
      summedDims: g,
      idDims: f
    };
  }
  function zie(e, t) {
    var n = new Array(e);
    n.fill(-1);
    for (var r = 0; r < t.length; ++r) {
      n[t[r]] = r;
    }
    var a = [];
    for (var i = 0; i < e; ++i) {
      if (n[i] === -1) {
        a.push(i);
      }
    }
    return {
      permutationIndices: n = n.filter(function (e) {
        return e !== -1;
      }),
      expandDims: a
    };
  }
  function Pie(e, t, n) {
    var r = new Array(e);
    var a = function (e) {
      var a = n[e].shape;
      var i = function (n) {
        if (r[t[e][n]] === undefined) {
          r[t[e][n]] = a[n];
        } else {
          F$(r[t[e][n]] === a[n], function () {
            return `Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(a)}, but got dimension ${a[n]}`;
          });
        }
      };
      for (var o = 0; o < t[e].length; ++o) {
        i(o);
      }
    };
    for (var i = 0; i < n.length; ++i) {
      a(i);
    }
  }
  function Bie(e, t) {
    var n;
    var r = e;
    var a = [];
    if (e.length === 0) {
      r.push(-1);
    }
    n = e.length + 1;
    for (var i = 0; i < n; ++i) {
      a.push([]);
    }
    var o = [];
    for (var s = 0; s < r.length; ++s) {
      var u;
      var c = O(Uie(t, r[s]));
      try {
        for (c.s(); !(u = c.n()).done;) {
          var l = u.value;
          if (o.indexOf(l) === -1) {
            a[s].push(l);
            o.push(l);
          }
        }
      } catch (e) {
        c.e(e);
      } finally {
        c.f();
      }
    }
    return {
      path: r,
      steps: a
    };
  }
  function Wie(e) {
    return e.every(function (e, t) {
      return e === t;
    });
  }
  function Uie(e, t) {
    var n = [];
    for (var r = 0; r < e.length; ++r) {
      if (e[r].length === 0 || e[r].indexOf(t) !== -1 || t === -1) {
        n.push(r);
      }
    }
    return n;
  }
  function Vie(e, t, n = 0) {
    var r = [];
    if (typeof t == "number") {
      F$(e.shape[n] % t == 0, function () {
        return "Number of splits must evenly divide the axis.";
      });
      r = new Array(t).fill(e.shape[n] / t);
    } else {
      var a = t.reduce(function (e, t) {
        if (t === -1) {
          e += 1;
        }
        return e;
      }, 0);
      F$(a <= 1, function () {
        return "There should be only one negative value in split array.";
      });
      var i = t.indexOf(-1);
      if (i !== -1) {
        var o = t.reduce(function (e, t) {
          if (t > 0) {
            return e + t;
          } else {
            return e;
          }
        });
        t[i] = e.shape[n] - o;
      }
      F$(e.shape[n] === t.reduce(function (e, t) {
        return e + t;
      }), function () {
        return "The sum of sizes must match the size of the axis dimension.";
      });
      r = t;
    }
    return r;
  }
  function Gie(e) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`;
  }
  function jie(e, t) {
    return `indices(${e}, 0) is invalid: ${t} < 0`;
  }
  function Hie(e, t, n) {
    return `indices(${e}, 0) is invalid: ${t} >= ${n}`;
  }
  function qie(e, t) {
    return `only one output dimension may be -1, not both ${e} and ${t}`;
  }
  function Kie(e, t) {
    return `size ${e} must be non-negative, not ${t}`;
  }
  function Xie() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
  }
  function Yie(e, t) {
    var n = L$(e);
    var r = L$(t);
    return `Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`;
  }
  function Jie(e, t) {
    var n = L$(e);
    var r = L$(t);
    return `Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`;
  }
  function Zie() {
    return "segment ids must be >= 0";
  }
  function Qie() {
    return "segment ids are not increasing";
  }
  function $ie(e, t) {
    return `Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`;
  }
  function eoe(e, t, n) {
    return `Bad: indices[${e}] == ${t} out of range [0, ${n})`;
  }
  function toe(e, t) {
    var n;
    var r = false;
    for (e <= 30 ? (n = e, r = true) : n = a0(e, Math.floor(Math.sqrt(e))); !r;) {
      if (n > t || n === e) {
        r = true;
      } else {
        n = a0(e, n + 1);
      }
    }
    return n;
  }
  function noe(e, t, n) {
    var r = [];
    for (var a = e.length, i = 0; i < a; i++) {
      if (i !== t) {
        r.push(e[i]);
      } else {
        r.push(n);
      }
    }
    return r;
  }
  function roe(e, t, n, r) {
    var a = t.shape.length;
    var i = e.shape.length;
    if (r !== 0 && (r < -a || r > a)) {
      throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);
    }
    if (r < 0) {
      r += a;
    }
    if (r > i) {
      throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${i}).`);
    }
    if (n < r) {
      throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);
    }
    for (var o = 0; o < r; ++o) {
      if (e.shape[o] !== t.shape[o]) {
        throw new Error(`x.shape[${o}]: ${e.shape[o]} should be equal to indices.shape[${o}]: ${t.shape[o]}.`);
      }
    }
    var s = e.shape[n];
    var u = [];
    var c = 1;
    var l = 1;
    var h = 1;
    for (var p = 0; p < r; ++p) {
      u.push(e.shape[p]);
      c *= e.shape[p];
    }
    for (var f = r; f < n; f++) {
      u.push(e.shape[f]);
      l *= e.shape[f];
    }
    for (var d = r; d < a; d++) {
      u.push(t.shape[d]);
    }
    for (var v = n + 1; v < i; v++) {
      u.push(e.shape[v]);
      h *= e.shape[v];
    }
    return {
      batchSize: c,
      sliceSize: h,
      outerSize: l,
      dimSize: s,
      outputShape: u
    };
  }
  function aoe(e) {
    try {
      return e.map(function (e) {
        return W4(e);
      });
    } catch (e) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`);
    }
  }
  function ioe(e) {
    return e.map(function (e) {
      return B4(e);
    });
  }
  var ooe = {
    __proto__: null,
    ERF_A1: kie,
    ERF_A2: wie,
    ERF_A3: Iie,
    ERF_A4: Nie,
    ERF_A5: Sie,
    ERF_P: xie,
    PARALLELIZE_THRESHOLD: 30,
    get RowPartitionType() {
      return Qae;
    },
    SELU_SCALE: bie,
    SELU_SCALEALPHA: yie,
    applyActivation: Sne,
    assertAndGetBroadcastShape: z7,
    assertAxesAreInnerMostDims: Q7,
    assertParamsConsistent: iie,
    assignToTypedArray: _ie,
    axesAreInnerMostDims: X7,
    calculateShapes: Jte,
    checkEinsumDimSizes: Pie,
    checkPadOnDimRoundingMode: K8,
    combineLocations: Y7,
    combineRaggedTensorToTensorShapes: sie,
    complexWithEvenIndex: Cie,
    complexWithOddIndex: Aie,
    computeConv2DInfo: D8,
    computeConv3DInfo: M8,
    computeDefaultPad: L8,
    computeDilation2DInfo: _8,
    computeOptimalWindowSize: hie,
    computeOutAndReduceShapes: J7,
    computeOutShape: oie,
    computePool2DInfo: O8,
    computePool3DInfo: F8,
    convertConv2DDataFormat: q8,
    decodeEinsumEquation: Lie,
    eitherStridesOrDilationsAreOne: j8,
    expandShapeToKeepDim: Z7,
    exponent: Fie,
    exponents: Oie,
    fromStringArrayToUint8: ioe,
    fromUint8ToStringArray: aoe,
    getAxesPermutation: $7,
    getBroadcastDims: M7,
    getComplexWithIndex: Rie,
    getEinsumComputePath: Bie,
    getEinsumPermutation: zie,
    getFusedBiasGradient: Nne,
    getFusedDyActivation: Ine,
    getImageCenter: pie,
    getInnerMostAxes: t9,
    getPermuted: die,
    getRaggedRank: cie,
    getReductionAxes: L7,
    getReshaped: fie,
    getReshapedPermuted: vie,
    getRowPartitionTypesHelper: uie,
    getSliceBeginCoords: mie,
    getSliceSize: gie,
    getSparseFillEmptyRowsIndicesDenseShapeMismatch: Gie,
    getSparseFillEmptyRowsNegativeIndexErrorMessage: jie,
    getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: Hie,
    getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: Xie,
    getSparseReshapeInputOutputMismatchErrorMessage: Jie,
    getSparseReshapeInputOutputMultipleErrorMessage: Yie,
    getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: qie,
    getSparseReshapeNegativeOutputDimErrorMessage: Kie,
    getSparseSegmentReductionIndicesOutOfRangeErrorMessage: eoe,
    getSparseSegmentReductionNegativeSegmentIdsErrorMessage: Zie,
    getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: Qie,
    getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: $ie,
    getUndoAxesPermutation: e9,
    isIdentityPermutation: Wie,
    log: function () {
      var e;
      if (!k0().getBool("IS_TEST") && !k0().getBool("PROD")) {
        (e = console).log.apply(e, arguments);
      }
    },
    mergeRealAndImagArrays: Tie,
    prepareAndValidate: Mae,
    prepareSplitSize: Vie,
    segment_util: {
      __proto__: null,
      collectGatherOpShapeInfo: roe,
      computeOutShape: noe,
      segOpComputeOptimalWindowSize: toe
    },
    shouldFuse: Tne,
    slice_util: $ae,
    splitRealAndImagArrays: Eie,
    stridesOrDilationsArePositive: H8,
    tupleValuesAreOne: G8,
    upcastType: h5,
    validateDefaultValueShape: lie,
    validateInput: Yte,
    validateUpdateShape: Xte,
    warn: z3
  };
  var soe = {
    __proto__: null,
    nonMaxSuppressionV3Impl: qne,
    nonMaxSuppressionV4Impl: Kne,
    nonMaxSuppressionV5Impl: Xne,
    whereImpl: one
  };
  (function () {
    var e;
    var t = O(rae);
    try {
      for (t.s(); !(e = t.n()).done;) {
        Kre(e.value);
      }
    } catch (e) {
      t.e(e);
    } finally {
      t.f();
    }
  })();
  var uoe = {
    kernelName: N0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return g8(e, Bte(h8(n, "float32"), -1));
        }
      };
    }
  };
  var coe = {
    kernelName: S0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          var t = s9(h8(n, "float32"));
          var r = o9(P9(i9(1), t));
          return M9(m8(e, r));
        }
      };
    }
  };
  var loe = {
    kernelName: T0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          var t = o9(P9(s9(h8(n, "float32")), 1));
          return m8(e, t);
        }
      };
    }
  };
  var hoe = {
    kernelName: E0,
    inputsToSave: ["a", "b"],
    gradFunc: function (e, t) {
      var n = S(t, 2);
      var r = n[0];
      var a = n[1];
      var i = z7(r.shape, a.shape);
      return {
        a: function () {
          var t = e;
          var n = L7(r.shape, i);
          if (n.length > 0) {
            t = u9(t, n);
          }
          return X8(t, r.shape);
        },
        b: function () {
          var t = e;
          var n = L7(a.shape, i);
          if (n.length > 0) {
            t = u9(t, n);
          }
          return X8(t, a.shape);
        }
      };
    }
  };
  var poe = {
    kernelName: C0,
    saveAllInputs: true,
    gradFunc: function (e, t) {
      var n = {};
      t.forEach(function (t, r) {
        n[r] = function () {
          return e.clone();
        };
      });
      return n;
    }
  };
  var foe = {
    kernelName: _0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return U7(n);
        }
      };
    }
  };
  var doe = {
    kernelName: O0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return U7(n);
        }
      };
    }
  };
  var voe = {
    kernelName: F0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return m8(e, o9(P9(i9(1), s9(h8(n, "float32")))));
        }
      };
    }
  };
  var moe = {
    kernelName: D0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          var t = o9(d8(i9(1), s9(h8(n, "float32"))));
          return m8(e, t);
        }
      };
    }
  };
  var goe = {
    kernelName: z0,
    inputsToSave: ["a", "b"],
    gradFunc: function (e, t) {
      var n = S(t, 2);
      var r = n[0];
      var a = n[1];
      var i = z7(r.shape, a.shape);
      return {
        a: function () {
          var t = d8(s9(r), s9(a));
          var n = g8(e, m8(a, t));
          var o = L7(r.shape, i);
          if (o.length > 0) {
            n = u9(n, o);
          }
          return X8(n, r.shape);
        },
        b: function () {
          var t = d8(s9(r), s9(a));
          var n = M9(g8(e, m8(r, t)));
          var o = L7(a.shape, i);
          if (o.length > 0) {
            n = u9(n, o);
          }
          return X8(n, a.shape);
        }
      };
    }
  };
  var yoe = {
    kernelName: M0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return m8(e, d8(s9(h8(n, "float32")), 1));
        }
      };
    }
  };
  var boe = {
    kernelName: L0,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return m8(e, P9(i9(1), s9(h8(n, "float32"))));
        }
      };
    }
  };
  var xoe = B5({
    avgPool3dGrad_: function (e, t, n, r, a, i) {
      var o = L5(e, "dy", "avgPool3dGrad");
      var s = L5(t, "input", "avgPool3dGrad");
      var u = o;
      var c = s;
      var l = false;
      if (s.rank === 4) {
        l = true;
        u = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]);
        c = X8(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]]);
      }
      F$(u.rank === 5, function () {
        return `Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`;
      });
      F$(c.rank === 5, function () {
        return `Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`;
      });
      K8("avgPool3dGrad", a, i);
      var h = {
        dy: u,
        input: c
      };
      var p = {
        filterSize: n,
        strides: r,
        pad: a,
        dimRoundingMode: i
      };
      var f = E5.runKernel(U0, h, p);
      if (l) {
        return X8(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]);
      } else {
        return f;
      }
    }
  });
  var koe = {
    kernelName: W0,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = S(t, 1)[0];
      var a = n.filterSize;
      var i = n.strides;
      var o = n.pad;
      var s = n.dimRoundingMode;
      return {
        x: function () {
          return xoe(e, r, a, i, o, s);
        }
      };
    }
  };
  var woe = B5({
    avgPoolGrad_: function (e, t, n, r, a) {
      var i = L5(e, "dy", "avgPoolGrad");
      var o = L5(t, "input", "avgPoolGrad");
      F$(o.rank === i.rank, function () {
        return `Rank of input (${o.rank}) does not match rank of dy (${i.rank})`;
      });
      var s = o;
      var u = i;
      var c = false;
      if (o.rank === 3) {
        c = true;
        s = X8(o, [1, o.shape[0], o.shape[1], o.shape[2]]);
        u = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]]);
      }
      F$(u.rank === 4, function () {
        return `Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`;
      });
      F$(s.rank === 4, function () {
        return `Error in avgPoolGrad: input must be rank 4 but got rank ${s.rank}.`;
      });
      var l = {
        dy: u,
        input: s
      };
      var h = {
        filterSize: n,
        strides: r,
        pad: a
      };
      var p = E5.runKernel(B0, l, h);
      if (c) {
        return X8(p, [p.shape[1], p.shape[2], p.shape[3]]);
      } else {
        return p;
      }
    }
  });
  var Ioe = {
    kernelName: P0,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = S(t, 1)[0];
      var a = n.filterSize;
      var i = n.strides;
      var o = n.pad;
      return {
        x: function () {
          return woe(e, r, a, i, o);
        }
      };
    }
  };
  var Noe = {
    kernelName: V0,
    inputsToSave: ["a", "b"],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = n.transposeA;
      var s = n.transposeB;
      if (o || s) {
        if (!o && s) {
          return {
            a: function () {
              return Q8(e, i, false, false);
            },
            b: function () {
              return Q8(e, a, true, false);
            }
          };
        } else if (o && !s) {
          return {
            a: function () {
              return Q8(i, e, false, true);
            },
            b: function () {
              return Q8(a, e, false, false);
            }
          };
        } else {
          return {
            a: function () {
              return Q8(i, e, true, true);
            },
            b: function () {
              return Q8(e, a, true, true);
            }
          };
        }
      } else {
        return {
          a: function () {
            return Q8(e, i, false, true);
          },
          b: function () {
            return Q8(a, e, true, false);
          }
        };
      }
    }
  };
  var Soe = {
    kernelName: G0,
    gradFunc: function (e, t, n) {
      var r = n.blockShape;
      var a = n.crops;
      return {
        x: function () {
          return gee(e, r, a);
        }
      };
    }
  };
  var Toe = {
    kernelName: q0,
    gradFunc: function (e, t, n) {
      var r = n;
      var a = r.inputShape;
      var i = r.shape;
      var o = Array.from(i);
      for (var s = a.length - 1; s >= 0; s--) {
        if (a[s] === i[s]) {
          o[s] = 1;
        } else if (a[s] !== 1) {
          throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${i}].`);
        }
      }
      var u = [];
      for (var c = 0; c < o.length; c++) {
        if (o[c] > 1) {
          u.push(c);
        }
      }
      return {
        x: function () {
          return u9(e, u, true);
        }
      };
    }
  };
  var Eoe = {
    kernelName: X0,
    gradFunc: function (e) {
      return {
        x: function () {
          return e.clone();
        }
      };
    }
  };
  var Coe = {
    kernelName: Y0,
    gradFunc: function (e) {
      return {
        x: function () {
          return U7(e);
        }
      };
    }
  };
  var Aoe = {
    kernelName: J0,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = S(t, 1)[0];
      var a = n.clipValueMin;
      var i = n.clipValueMax;
      return {
        x: function () {
          return W7(U9(x9(r, a), E9(r, i)), e, U7(e));
        }
      };
    }
  };
  var Roe = {
    kernelName: Q0,
    inputsToSave: ["x"],
    gradFunc: uoe.gradFunc
  };
  var _oe = {
    kernelName: $0,
    saveAllInputs: true,
    gradFunc: function (e, t, n) {
      var r = t.map(function (e) {
        return e.shape;
      });
      var a = j$(n.axis, t[0].shape)[0];
      var i = r.map(function (e) {
        return e[a];
      });
      return Dte(e, i, a).map(function (e) {
        return function () {
          return e;
        };
      });
    }
  };
  var Ooe = {
    kernelName: e1,
    inputsToSave: ["x", "filter"],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = n.dilations;
      var s = n.strides;
      var u = n.pad;
      var c = n.dataFormat;
      F$(G8(o), function () {
        return `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`;
      });
      return {
        x: function () {
          return k7(a.shape, e, i, s, u, c);
        },
        filter: function () {
          return wne(a, e, i.shape, s, u, c);
        }
      };
    }
  };
  var Foe = {
    kernelName: n1,
    inputsToSave: ["dy", "filter"],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = n.strides;
      var s = n.pad;
      var u = n.dataFormat;
      var c = n.dimRoundingMode;
      return {
        dy: function () {
          return b7(e, i, o, s, u, 1, c);
        },
        filter: function () {
          return wne(e, a, i.shape, o, s, u, c);
        }
      };
    }
  };
  var Doe = B5({
    conv3DBackpropFilter_: function (e, t, n, r, a) {
      var i = e;
      if (e.rank === 4) {
        i = X8(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]);
      }
      var o = t;
      if (o.rank === 4) {
        o = X8(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]);
      }
      F$(i.rank === 5, function () {
        return `Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`;
      });
      F$(o.rank === 5, function () {
        return `Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`;
      });
      F$(n.length === 5, function () {
        return `Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`;
      });
      F$(i.shape[4] === n[3], function () {
        return `Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`;
      });
      F$(o.shape[4] === n[4], function () {
        return `Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`;
      });
      var s = {
        x: i,
        dy: o
      };
      var u = {
        strides: r,
        pad: a,
        filterShape: n
      };
      return E5.runKernel(a1, s, u);
    }
  });
  var Moe = {
    kernelName: r1,
    inputsToSave: ["x", "filter"],
    gradFunc: function (e, t, n) {
      var r = n.dilations;
      var a = n.strides;
      var i = n.pad;
      F$(G8(r), function () {
        return `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`;
      });
      var o = S(t, 2);
      var s = o[0];
      var u = o[1];
      return {
        x: function () {
          return N7(s.shape, e, u, a, i);
        },
        filter: function () {
          return Doe(s, e, u.shape, a, i);
        }
      };
    }
  };
  var Loe = {
    kernelName: o1,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return g8(M9(Nte(h8(n, "float32"))), e);
        }
      };
    }
  };
  var zoe = {
    kernelName: s1,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return g8(Ste(h8(n, "float32")), e);
        }
      };
    }
  };
  var Poe = {
    kernelName: c1,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = S(t, 1)[0];
      var a = n.axis;
      var i = n.exclusive;
      var o = n.reverse;
      return {
        x: function () {
          var t = $7([a], r.rank);
          var n = A7(e, a, i, !o);
          if (t != null) {
            n = hne(n, t);
          }
          return n;
        }
      };
    }
  };
  var Boe = {
    kernelName: f1,
    inputsToSave: ["x", "filter"],
    gradFunc: function (e, t, n) {
      var r = n.dilations;
      var a = n.strides;
      var i = n.pad;
      var o = n.dimRoundingMode;
      var s = r == null ? [1, 1] : r;
      F$(G8(s), function () {
        return `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`;
      });
      var u = S(t, 2);
      var c = u[0];
      var l = u[1];
      F$(c.rank === 4, function () {
        return `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`;
      });
      F$(l.rank === 4, function () {
        return `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`;
      });
      F$(c.shape[3] === l.shape[2], function () {
        return `Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`;
      });
      F$(j8(a, s), function () {
        return `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${s}'.`;
      });
      K8("depthwiseConv2d", i, o);
      return {
        x: function () {
          return Ane(c.shape, e, l, a, i, s, o);
        },
        filter: function () {
          return Cne(c, e, l.shape, a, i, s, o);
        }
      };
    }
  };
  var Woe = {
    kernelName: g1,
    inputsToSave: ["x", "filter"],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = {
        x: a,
        filter: i,
        dy: e
      };
      var s = {
        x: a,
        filter: i,
        dy: e
      };
      return {
        x: function () {
          return E5.runKernel(y1, o, n);
        },
        filter: function () {
          return E5.runKernel(b1, s, n);
        }
      };
    }
  };
  var Uoe = {
    kernelName: I1,
    outputsToSave: [true],
    gradFunc: function (e, t) {
      var n = {
        dy: e,
        y: S(t, 1)[0]
      };
      return {
        x: function () {
          return E5.runKernel(N1, n);
        }
      };
    }
  };
  var Voe = {
    kernelName: S1,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      var r = g8(p9(M9(s9(n))), 2 / Math.sqrt(Math.PI));
      return {
        x: function () {
          return g8(e, r);
        }
      };
    }
  };
  var Goe = {
    kernelName: E1,
    outputsToSave: [true],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return g8(e, n);
        }
      };
    }
  };
  var joe = {
    kernelName: C1,
    inputsToSave: ["input"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        input: function () {
          return X8(e, n.shape);
        }
      };
    }
  };
  var Hoe = {
    kernelName: A1,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return g8(e, p9(n));
        }
      };
    }
  };
  var qoe = {
    kernelName: F1,
    gradFunc: function (e) {
      return {
        x: function () {
          return U7(e);
        }
      };
    }
  };
  var Koe = {
    kernelName: D1,
    inputsToSave: ["a", "b"],
    gradFunc: function (e, t) {
      var n = S(t, 2);
      var r = n[0];
      var a = n[1];
      var i = z7(r.shape, a.shape);
      return {
        a: function () {
          var t = m8(e, h8(a, "float32"));
          var n = L7(r.shape, i);
          if (n.length > 0) {
            return X8(u9(t, n), r.shape);
          } else {
            return t;
          }
        },
        b: function () {
          var t = g8(e, h8(r, "float32"));
          var n = L7(a.shape, i);
          if (n.length > 0) {
            t = X8(u9(t, n), a.shape);
          }
          var o = s9(a);
          return M9(m8(t, h8(o, "float32")));
        }
      };
    }
  };
  var Xoe = {
    kernelName: M1,
    inputsToSave: ["x", "mean", "variance", "scale"],
    gradFunc: function (e, t, n) {
      var r = n.varianceEpsilon;
      var a = S(t, 4);
      var i = a[0];
      var o = a[1];
      var s = a[2];
      var u = a[3];
      var c = u == null ? i9(1) : u;
      var l = L7(o.shape, i.shape);
      var h = [];
      if (o.rank === 1) {
        for (var p = 0; p < i.shape.length - 1; ++p) {
          h.push(i.shape[p]);
        }
        h.push(1);
      }
      var f = P9(i, o);
      var d = g8(e, c);
      var v = yte(d8(s, i9(r)));
      var m = g8(g8(g8(v, v), v), i9(-0.5));
      return {
        x: function () {
          if (o.rank === 1) {
            return X8(g8(g8(e, v9(X8(v, [1, 1, 1, o.shape[0]]), h)), c), i.shape);
          } else {
            return X8(g8(g8(e, v), c), i.shape);
          }
        },
        mean: function () {
          var e = g8(g8(v, i9(-1)), d);
          if (o.rank === 1) {
            e = u9(e, l);
          }
          return X8(e, o.shape);
        },
        variance: function () {
          var e = g8(g8(m, f), d);
          if (o.rank === 1) {
            e = u9(e, l);
          }
          return X8(e, o.shape);
        },
        scale: function () {
          var t = g8(f, v);
          var n = g8(e, t);
          if (o.rank === 1) {
            n = u9(n, l);
          }
          return X8(n, o.shape);
        },
        offset: function () {
          var t = e;
          if (o.rank === 1) {
            t = u9(t, l);
          }
          return X8(t, o.shape);
        }
      };
    }
  };
  var Yoe = {
    kernelName: L1,
    inputsToSave: ["x", "indices"],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = n.axis;
      var s = n.batchDims;
      var u = j$(o, a.shape)[0];
      function c(e, t, n) {
        return function () {
          var r = e.shape;
          var a = t.size;
          var i = r.slice(0, u);
          var s = i.length;
          var c = r.slice(o, r.length).slice(1);
          var l = c.length;
          var h = Joe(0, s);
          var p = Joe(s + 1, s + 1 + l);
          var f = Zoe([i, [a], c]);
          var d = X8(n, f);
          var v = X8(t, [a]);
          var m = Zoe([[s], h, p]);
          var g = hne(d, m);
          var y = nne(g, v, e.shape[u]);
          var b = e9(m);
          return y = hne(y, b);
        };
      }
      if (s === 1) {
        var l = a.shape[0];
        var h = a.split(l, 0);
        return {
          x: function () {
            var t = Pte(h.map(function (t, n) {
              return c(t, i.slice(n, 1), e.slice(n, 1))();
            }));
            return t.reshape(a.shape);
          },
          indices: function () {
            return i;
          }
        };
      }
      return {
        x: c(a, i, e),
        indices: function () {
          return i;
        }
      };
    }
  };
  function Joe(e, t) {
    var n = [];
    for (var r = e; r < t; ++r) {
      n.push(r);
    }
    return n;
  }
  function Zoe(e) {
    var t = [];
    for (var n = 0; n < e.length; ++n) {
      for (var r = 0; r < e[n].length; ++r) {
        t.push(e[n][r]);
      }
    }
    return t;
  }
  var Qoe = {
    kernelName: B1,
    inputsToSave: ["a", "b"],
    gradFunc: function (e, t) {
      var n = S(t, 2);
      var r = n[0];
      var a = n[1];
      return {
        a: function () {
          return U7(r);
        },
        b: function () {
          return U7(a);
        }
      };
    }
  };
  var $oe = {
    kernelName: W1,
    gradFunc: function (e) {
      return {
        x: function () {
          return h8(e, "float32");
        }
      };
    }
  };
  var ese = {
    kernelName: G1,
    gradFunc: function (e) {
      return {
        x: function () {
          return U7(e);
        }
      };
    }
  };
  var tse = {
    kernelName: j1,
    gradFunc: function (e) {
      return {
        x: function () {
          return U7(e);
        }
      };
    }
  };
  var nse = {
    kernelName: H1,
    gradFunc: function (e) {
      return {
        x: function () {
          return U7(e);
        }
      };
    }
  };
  var rse = {
    kernelName: q1,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = S(t, 1)[0];
      var a = n.alpha;
      var i = b9(r, 0);
      return {
        x: function () {
          return W7(i, e, g8(e, a));
        }
      };
    }
  };
  var ase = {
    kernelName: Z1,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return m8(e, d8(n, 1));
        }
      };
    }
  };
  var ise = {
    kernelName: J1,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          return m8(e, h8(n, "float32"));
        }
      };
    }
  };
  var ose = {
    kernelName: t2,
    inputsToSave: [],
    outputsToSave: [true],
    gradFunc: function (e, t, n) {
      var r = S(t, 1)[0];
      var a = n.axis;
      return {
        logits: function () {
          var t = p9(r);
          return P9(e, g8(u9(e, a, true), t));
        }
      };
    }
  };
  var sse = B5({
    localResponseNormalizationBackprop_: function (e, t, n, r = 5, a = 1, i = 1, o = 0.5) {
      var s = {
        x: e,
        y: t,
        dy: n
      };
      var u = {
        depthRadius: r,
        bias: a,
        alpha: i,
        beta: o
      };
      return E5.runKernel(r2, s, u);
    }
  });
  var use = {
    kernelName: n2,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = n.depthRadius;
      var s = n.bias;
      var u = n.alpha;
      var c = n.beta;
      return {
        x: function () {
          return sse(a, i, e, o, s, u, c);
        }
      };
    }
  };
  function cse(e, t, n, r) {
    if (t.rank < n.rank) {
      t = X8(t, Z7(t.shape, r));
    }
    if (e.rank < n.rank) {
      e = X8(e, Z7(e.shape, r));
    }
    return {
      x: function () {
        return g8(e, h8(B7(n, t), e.dtype));
      }
    };
  }
  var lse = {
    kernelName: a2,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: function (e, t, n) {
      var r = n.reductionIndices;
      var a = t[0];
      var i = cse(e, t[1], a, j$(r, a.shape));
      return {
        x: function () {
          return i.x();
        }
      };
    }
  };
  var hse = {
    kernelName: i2,
    inputsToSave: ["a", "b"],
    gradFunc: function (e, t) {
      var n = S(t, 2);
      var r = n[0];
      var a = n[1];
      return {
        a: function () {
          return g8(e, h8(x9(r, a), "float32"));
        },
        b: function () {
          return g8(e, h8(T9(r, a), "float32"));
        }
      };
    }
  };
  var pse = B5({
    maxPool3dGrad_: function (e, t, n, r, a, i, o) {
      var s = L5(e, "dy", "maxPool3dGrad");
      var u = L5(t, "input", "maxPool3dGrad");
      var c = L5(n, "output", "maxPool3dGrad");
      var l = s;
      var h = u;
      var p = c;
      var f = false;
      if (u.rank === 4) {
        f = true;
        l = X8(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]]);
        h = X8(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]);
        p = X8(c, [1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]]);
      }
      F$(l.rank === 5, function () {
        return `Error in maxPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`;
      });
      F$(h.rank === 5, function () {
        return `Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`;
      });
      F$(p.rank === 5, function () {
        return `Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`;
      });
      K8("maxPool3dGrad", i, o);
      var d = {
        dy: l,
        input: h,
        output: p
      };
      var v = {
        filterSize: r,
        strides: a,
        pad: i,
        dimRoundingMode: o
      };
      var m = E5.runKernel(c2, d, v);
      if (f) {
        return X8(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]);
      } else {
        return m;
      }
    }
  });
  var fse = {
    kernelName: u2,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = n.filterSize;
      var s = n.strides;
      var u = n.pad;
      var c = n.dimRoundingMode;
      return {
        x: function () {
          return pse(e, a, i, o, s, u, c);
        }
      };
    }
  };
  var dse = B5({
    maxPoolGrad_: function (e, t, n, r, a, i, o) {
      var s = L5(e, "dy", "maxPoolGrad");
      var u = L5(t, "input", "maxPoolGrad");
      var c = L5(n, "output", "maxPoolGrad");
      F$(u.rank === s.rank, function () {
        return `Rank of input (${u.rank}) does not match rank of dy (${s.rank})`;
      });
      F$(s.rank === 4, function () {
        return `Error in maxPoolGrad: dy must be rank 4 but got rank ${s.rank}.`;
      });
      F$(u.rank === 4, function () {
        return `Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`;
      });
      K8("maxPoolGrad", i, o);
      var l = {
        dy: s,
        input: u,
        output: c
      };
      var h = {
        filterSize: r,
        strides: a,
        pad: i,
        dimRoundingMode: o
      };
      return E5.runKernel(s2, l, h);
    }
  });
  var vse = {
    kernelName: o2,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: function (e, t, n) {
      var r = S(t, 2);
      var a = r[0];
      var i = r[1];
      var o = n.filterSize;
      var s = n.strides;
      var u = n.pad;
      return {
        x: function () {
          return dse(e, a, i, o, s, u);
        }
      };
    }
  };
  var mse = {
    kernelName: d2,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = t[0];
      var a = n.paddings.map(function (e) {
        return e[0];
      });
      return {
        x: function () {
          return e7(e, a, r.shape);
        }
      };
    }
  };
  var gse = {
    kernelName: T2,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = t[0];
      var a = n.paddings.map(function (e) {
        return e[0];
      });
      return {
        x: function () {
          return e7(e, a, r.shape);
        }
      };
    }
  };
  var yse = {
    kernelName: E2,
    inputsToSave: ["a", "b"],
    outputsToSave: [true],
    gradFunc: function (e, t) {
      var n = S(t, 3);
      var r = n[0];
      var a = n[1];
      var i = n[2];
      var o = r;
      var s = a;
      var u = z7(o.shape, s.shape);
      return {
        a: function () {
          var t = h8(s, "float32");
          var n = g8(e, g8(t, a9(o, P9(t, i9(1)))));
          var r = L7(o.shape, u);
          if (r.length > 0) {
            n = u9(n, r);
          }
          return X8(n, o.shape);
        },
        b: function () {
          var t = b9(o, 0);
          var n = W7(t, R9(o), U7(o));
          var r = g8(e, g8(i, n));
          var a = L7(s.shape, u);
          if (a.length > 0) {
            r = u9(r, a);
          }
          return X8(r, s.shape);
        }
      };
    }
  };
  function bse(e, t, n) {
    var r = e.shape.length;
    var a = r - n.length;
    var i = $7(n, r);
    var o = e;
    if (i != null) {
      o = hne(e, i);
    }
    var s = o.shape.slice();
    var u = s.splice(r - n.length, n.length).reduce(function (e, t) {
      return e * t;
    }, 1);
    s.push(u);
    var c = function (e, t, n) {
      var r = e.shape.slice();
      r[n] = 1;
      var a = X8(t, r);
      var i = C7(e, n, true, false);
      var o = C7(e, n, true, true);
      var s = g8(i, o);
      return g8(a, s);
    }(o.reshape(s), t, a);
    c = c.reshape(o.shape);
    if (i != null) {
      var l = e9(i);
      c = hne(c, l);
    }
    return c;
  }
  var xse = {
    kernelName: J2,
    inputsToSave: ["x"],
    gradFunc: function (e, t) {
      var n = S(t, 1)[0];
      return {
        x: function () {
          var t = b9(n, i9(0));
          var r = i9(yie);
          var a = i9(bie);
          var i = g8(e, a);
          var o = g8(g8(e, r), p9(h8(n, "float32")));
          return W7(t, i, o);
        }
      };
    }
  };
  var kse = {
    kernelName: i3,
    gradFunc: function (e, t, n) {
      var r = n.blockShape;
      var a = n.paddings;
      return {
        x: function () {
          return r7(e, r, a);
        }
      };
    }
  };
  var wse = {
    kernelName: o3,
    gradFunc: function (e, t, n) {
      var r = n.axis;
      return {
        x: function () {
          return Z8(e, r);
        }
      };
    }
  };
  var Ise = {
    kernelName: I3,
    inputsToSave: ["x"],
    gradFunc: function (e, t, n) {
      var r = S(t, 1)[0];
      var a = n.reps;
      return {
        x: function () {
          var t = U7(r);
          if (r.rank === 1) {
            for (var n = 0; n < a[0]; ++n) {
              t = d8(t, e7(e, [n * r.shape[0]], [r.shape[0]]));
            }
          } else if (r.rank === 2) {
            for (var i = 0; i < a[0]; ++i) {
              for (var o = 0; o < a[1]; ++o) {
                t = d8(t, e7(e, [i * r.shape[0], o * r.shape[1]], [r.shape[0], r.shape[1]]));
              }
            }
          } else if (r.rank === 3) {
            for (var s = 0; s < a[0]; ++s) {
              for (var u = 0; u < a[1]; ++u) {
                for (var c = 0; c < a[2]; ++c) {
                  t = d8(t, e7(e, [s * r.shape[0], u * r.shape[1], c * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));
                }
              }
            }
          } else {
            if (r.rank !== 4) {
              throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);
            }
            for (var l = 0; l < a[0]; ++l) {
              for (var h = 0; h < a[1]; ++h) {
                for (var p = 0; p < a[2]; ++p) {
                  for (var f = 0; f < a[3]; ++f) {
                    t = d8(t, e7(e, [l * r.shape[0], h * r.shape[1], p * r.shape[2], f * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]));
                  }
                }
              }
            }
          }
          return t;
        }
      };
    }
  };
  for (var Nse = 0, Sse = [uoe, coe, loe, hoe, poe, foe, doe, voe, moe, goe, yoe, boe, koe, Ioe, Noe, Soe, Toe, Eoe, Coe, Aoe, Roe, _oe, Foe, Ooe, Moe, Loe, zoe, Poe, Boe, Woe, {
      kernelName: k1,
      inputsToSave: ["a", "b"],
      gradFunc: function (e, t) {
        var n = S(t, 2);
        var r = n[0];
        var a = n[1];
        var i = z7(r.shape, a.shape);
        return {
          a: function () {
            var t = m8(e, h8(a, "float32"));
            var n = L7(r.shape, i);
            if (n.length > 0) {
              return X8(u9(t, n), r.shape);
            } else {
              return t;
            }
          },
          b: function () {
            var t = g8(e, h8(r, "float32"));
            var n = L7(a.shape, i);
            if (n.length > 0) {
              t = X8(u9(t, n), a.shape);
            }
            var o = s9(a);
            return M9(m8(t, h8(o, "float32")));
          }
        };
      }
    }, Uoe, Voe, Goe, joe, Hoe, Koe, qoe, Xoe, Yoe, Qoe, $oe, ese, tse, nse, rse, ase, ise, ose, use, lse, lse, hse, fse, vse, {
      kernelName: h2,
      inputsToSave: ["x"],
      gradFunc: function (e, t, n) {
        var r = S(t, 1)[0];
        var a = j$(n.axis, r.shape);
        var i = L$(J7(r.shape, a)[1]);
        return {
          x: function () {
            var t = r.shape.slice();
            a.forEach(function (e) {
              t[e] = 1;
            });
            var n = X8(e, t);
            return m8(g8(n, eee(r.shape, "float32")), i);
          }
        };
      }
    }, {
      kernelName: p2,
      inputsToSave: ["x"],
      outputsToSave: [true],
      gradFunc: function (e, t, n) {
        var r = n.axis;
        var a = S(t, 2);
        var i = a[0];
        var o = cse(e, a[1], i, j$(r, i.shape));
        return {
          x: function () {
            return o.x();
          }
        };
      }
    }, {
      kernelName: f2,
      inputsToSave: ["a", "b"],
      gradFunc: function (e, t) {
        var n = S(t, 2);
        var r = n[0];
        var a = n[1];
        return {
          a: function () {
            return g8(e, h8(E9(r, a), "float32"));
          },
          b: function () {
            return g8(e, h8(b9(r, a), "float32"));
          }
        };
      }
    }, mse, {
      kernelName: v2,
      inputsToSave: ["a", "b"],
      gradFunc: function (e, t) {
        var n = S(t, 2);
        var r = n[0];
        var a = n[1];
        var i = z7(r.shape, a.shape);
        return {
          a: function () {
            var t = L7(r.shape, i);
            if (t.length > 0) {
              return X8(u9(e, t), r.shape);
            } else {
              return e;
            }
          },
          b: function () {
            var t = g8(e, M9(g9(m8(r, a))));
            var n = L7(a.shape, i);
            if (n.length > 0) {
              return X8(u9(t, n), a.shape);
            } else {
              return t;
            }
          }
        };
      }
    }, {
      kernelName: g2,
      inputsToSave: ["a", "b"],
      gradFunc: function (e, t) {
        var n = S(t, 2);
        var r = n[0];
        var a = n[1];
        var i = z7(r.shape, a.shape);
        return {
          a: function () {
            var t = g8(e, h8(a, "float32"));
            var n = L7(r.shape, i);
            if (n.length > 0) {
              return X8(u9(t, n), r.shape);
            } else {
              return t;
            }
          },
          b: function () {
            var t = g8(e, h8(r, "float32"));
            var n = L7(a.shape, i);
            if (n.length > 0) {
              return X8(u9(t, n), a.shape);
            } else {
              return t;
            }
          }
        };
      }
    }, {
      kernelName: y2,
      gradFunc: function (e) {
        return {
          x: function () {
            return M9(e);
          }
        };
      }
    }, {
      kernelName: N2,
      inputsToSave: ["indices"],
      gradFunc: function (e, t) {
        var n = t[0];
        return {
          indices: function () {
            return $9(n.shape, "float32");
          }
        };
      }
    }, {
      kernelName: I2,
      gradFunc: function (e) {
        return {
          x: function () {
            return U7(e);
          }
        };
      }
    }, {
      kernelName: S2,
      saveAllInputs: true,
      gradFunc: function (e, t, n) {
        var r = n.axis;
        return rne(e, r).map(function (e) {
          return function () {
            return e;
          };
        });
      }
    }, gse, gse, yse, {
      kernelName: C2,
      inputsToSave: ["x", "alpha"],
      gradFunc: function (e, t) {
        var n = S(t, 2);
        var r = n[0];
        var a = n[1];
        var i = b9(r, 0);
        return {
          x: function () {
            return W7(i, e, g8(e, a));
          },
          alpha: function () {
            var t = W7(i, U7(e), g8(e, r));
            var n = L7(a.shape, e.shape);
            if (n.length > 0) {
              t = u9(t, n);
            }
            return X8(t, a.shape);
          }
        };
      }
    }, {
      kernelName: A2,
      inputsToSave: ["x"],
      gradFunc: function (e, t, n) {
        var r = S(t, 1)[0];
        var a = n.axis;
        var i = [];
        i = a == null ? r.shape.map(function (e, t) {
          return t;
        }) : typeof a == "number" ? [a] : a;
        return {
          x: function () {
            return bse(r, e, i);
          }
        };
      }
    }, {
      kernelName: M2,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return m8(e, M9(s9(n)));
          }
        };
      }
    }, {
      kernelName: V2,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        var r = g8(E9(n, 6), Bte(n));
        return {
          x: function () {
            return g8(e, h8(r, "float32"));
          }
        };
      }
    }, {
      kernelName: L2,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return g8(e, h8(Bte(n), "float32"));
          }
        };
      }
    }, {
      kernelName: z2,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return X8(e, n.shape);
          }
        };
      }
    }, {
      kernelName: W2,
      inputsToSave: ["images"],
      gradFunc: function (e, t, n) {
        var r = {
          dy: e,
          images: S(t, 1)[0]
        };
        return {
          images: function () {
            return E5.runKernel(U2, r, n);
          }
        };
      }
    }, {
      kernelName: P2,
      inputsToSave: ["images"],
      gradFunc: function (e, t, n) {
        var r = {
          dy: e,
          images: S(t, 1)[0]
        };
        return {
          images: function () {
            return E5.runKernel(B2, r, n);
          }
        };
      }
    }, {
      kernelName: G2,
      gradFunc: function (e, t, n) {
        var r = j$(n.dims, e.shape);
        return {
          x: function () {
            return pte(e, r);
          }
        };
      }
    }, {
      kernelName: j2,
      gradFunc: function (e) {
        return {
          x: function () {
            return U7(e);
          }
        };
      }
    }, {
      kernelName: H2,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return M9(m8(e, g8(a9(n, 1.5), 2)));
          }
        };
      }
    }, {
      kernelName: Y2,
      inputsToSave: ["condition"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          condition: function () {
            return h8(U7(n), "float32");
          },
          t: function () {
            return g8(e, h8(n, e.dtype));
          },
          e: function () {
            return g8(e, h8(V9(n), e.dtype));
          }
        };
      }
    }, xse, {
      kernelName: t3,
      outputsToSave: [true],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return g8(e, g8(n, P9(i9(1), n)));
          }
        };
      }
    }, {
      kernelName: e3,
      gradFunc: function (e) {
        return {
          x: function () {
            return U7(e);
          }
        };
      }
    }, {
      kernelName: Q2,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return g8(T7(h8(n, "float32")), e);
          }
        };
      }
    }, {
      kernelName: $2,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return g8(E7(h8(n, "float32")), e);
          }
        };
      }
    }, {
      kernelName: Z2,
      inputsToSave: ["x"],
      gradFunc: function (e, t, n) {
        var r = S(t, 1)[0];
        var a = n.begin;
        var i = n.size;
        var o = r.shape;
        var s = S(Yae(r, a, i), 2);
        var u = s[0];
        var c = s[1];
        var l = [];
        for (var h = 0; h < e.rank; h++) {
          l.push([u[h], o[h] - u[h] - c[h]]);
        }
        return {
          x: function () {
            return pee(e, l);
          }
        };
      }
    }, {
      kernelName: s3,
      outputsToSave: [true],
      gradFunc: function (e, t, n) {
        var r = S(t, 1)[0];
        var a = n.dim;
        var i = g8(e, r);
        return {
          logits: function () {
            return P9(i, g8(u9(i, [a], true), r));
          }
        };
      }
    }, {
      kernelName: n3,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return g8(e, $8(n));
          }
        };
      }
    }, kse, kse, wse, wse, {
      kernelName: r3,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return m8(e, g8(o9(h8(n, "float32")), 2));
          }
        };
      }
    }, {
      kernelName: f3,
      inputsToSave: ["a", "b"],
      gradFunc: function (e, t) {
        var n = S(t, 2);
        var r = n[0];
        var a = n[1];
        var i = i9(2);
        return {
          a: function () {
            return g8(e, g8(i, P9(r, a)));
          },
          b: function () {
            return g8(e, g8(i, P9(a, r)));
          }
        };
      }
    }, {
      kernelName: d3,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return g8(e, g8(h8(n, "float32"), 2));
          }
        };
      }
    }, {
      kernelName: _3,
      gradFunc: function (e) {
        return {
          x: function () {
            return U7(e);
          }
        };
      }
    }, {
      kernelName: x3,
      inputsToSave: ["a", "b"],
      gradFunc: function (e, t) {
        var n = S(t, 2);
        var r = n[0];
        var a = n[1];
        var i = z7(r.shape, a.shape);
        return {
          a: function () {
            var t = e;
            var n = L7(r.shape, i);
            if (n.length > 0) {
              t = u9(t, n);
            }
            return X8(t, r.shape);
          },
          b: function () {
            var t = e;
            var n = L7(a.shape, i);
            if (n.length > 0) {
              t = u9(t, n);
            }
            return X8(M9(t), a.shape);
          }
        };
      }
    }, {
      kernelName: a3,
      inputsToSave: ["x"],
      gradFunc: function (e, t, n) {
        var r = S(t, 1)[0];
        var a = r.shape.slice();
        j$(n.axis, r.shape).forEach(function (e) {
          a[e] = 1;
        });
        var i = X8(e, a);
        var o = g8(i, eee(r.shape, "float32"));
        return {
          x: function () {
            return o;
          }
        };
      }
    }, {
      kernelName: k3,
      inputsToSave: ["x"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return m8(e, s9(T7(n)));
          }
        };
      }
    }, {
      kernelName: w3,
      outputsToSave: [true],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return g8(P9(i9(1), s9(n)), e);
          }
        };
      }
    }, Ise, {
      kernelName: T3,
      gradFunc: function (e, t, n) {
        var r = e9(n.perm);
        return {
          x: function () {
            return hne(e, r);
          }
        };
      }
    }, {
      kernelName: C3,
      gradFunc: function (e, t, n) {
        var r = n.axis;
        return {
          value: function () {
            return Pte(e, r);
          }
        };
      }
    }, {
      kernelName: A3,
      inputsToSave: ["segmentIds"],
      gradFunc: function (e, t) {
        var n = S(t, 1)[0];
        return {
          x: function () {
            return function (e, t) {
              var n = Z9(t, U7(t));
              var r = y9(e, n);
              var a = x9(t, i9(0, "int32"));
              for (var i = r.rank - a.rank, o = 0; o < i; ++o) {
                a = f9(a, o + 1);
              }
              a = U9(a, eee(r.shape, "bool"));
              var s = U7(r);
              return W7(a, r, s);
            }(e, n);
          }
        };
      }
    }, {
      kernelName: R3,
      gradFunc: function (e) {
        return {
          x: function () {
            return U7(e);
          }
        };
      }
    }]; Nse < Sse.length; Nse++) {
    j3(Sse[Nse]);
  }
  r5().prototype.abs = function () {
    this.throwIfDisposed();
    return y8(this);
  };
  r5().prototype.acos = function () {
    this.throwIfDisposed();
    return b8(this);
  };
  r5().prototype.acosh = function () {
    this.throwIfDisposed();
    return x8(this);
  };
  r5().prototype.add = function (e) {
    this.throwIfDisposed();
    return d8(this, e);
  };
  r5().prototype.all = function (e, t) {
    this.throwIfDisposed();
    return w8(this, e, t);
  };
  r5().prototype.any = function (e, t) {
    this.throwIfDisposed();
    return I8(this, e, t);
  };
  r5().prototype.argMax = function (e) {
    this.throwIfDisposed();
    return N8(this, e);
  };
  r5().prototype.argMin = function (e) {
    this.throwIfDisposed();
    return S8(this, e);
  };
  r5().prototype.asScalar = function () {
    this.throwIfDisposed();
    F$(this.size === 1, function () {
      return "The array must have only 1 element.";
    });
    return X8(this, []);
  };
  r5().prototype.asType = function (e) {
    this.throwIfDisposed();
    return h8(this, e);
  };
  r5().prototype.as1D = function () {
    this.throwIfDisposed();
    return X8(this, [this.size]);
  };
  r5().prototype.as2D = function (e, t) {
    this.throwIfDisposed();
    return X8(this, [e, t]);
  };
  r5().prototype.as3D = function (e, t, n) {
    this.throwIfDisposed();
    return X8(this, [e, t, n]);
  };
  r5().prototype.as4D = function (e, t, n, r) {
    this.throwIfDisposed();
    return X8(this, [e, t, n, r]);
  };
  r5().prototype.as5D = function (e, t, n, r, a) {
    this.throwIfDisposed();
    return X8(this, [e, t, n, r, a]);
  };
  r5().prototype.asin = function () {
    this.throwIfDisposed();
    return T8(this);
  };
  r5().prototype.asinh = function () {
    this.throwIfDisposed();
    return E8(this);
  };
  r5().prototype.atan = function () {
    this.throwIfDisposed();
    return C8(this);
  };
  r5().prototype.atan2 = function (e) {
    this.throwIfDisposed();
    return A8(this, e);
  };
  r5().prototype.atanh = function () {
    this.throwIfDisposed();
    return R8(this);
  };
  r5().prototype.avgPool = function (e, t, n, r) {
    this.throwIfDisposed();
    return Y8(this, e, t, n, r);
  };
  r5().prototype.batchToSpaceND = function (e, t) {
    this.throwIfDisposed();
    return r7(this, e, t);
  };
  r5().prototype.batchNorm = function (e, t, n, r, a) {
    this.throwIfDisposed();
    return a7(this, e, t, n, r, a);
  };
  r5().prototype.broadcastTo = function (e) {
    this.throwIfDisposed();
    return h7(this, e);
  };
  r5().prototype.cast = function (e) {
    this.throwIfDisposed();
    return h8(this, e);
  };
  r5().prototype.ceil = function () {
    this.throwIfDisposed();
    return p7(this);
  };
  r5().prototype.clipByValue = function (e, t) {
    this.throwIfDisposed();
    return d7(this, e, t);
  };
  r5().prototype.concat = function (e, t) {
    this.throwIfDisposed();
    if (e instanceof n5) {
      e = [e];
    }
    return Z8([this].concat(T(e)), t);
  };
  r5().prototype.conv1d = function (e, t, n, r, a, i) {
    this.throwIfDisposed();
    return x7(this, e, t, n, r, a, i);
  };
  r5().prototype.conv2dTranspose = function (e, t, n, r, a) {
    this.throwIfDisposed();
    return w7(this, e, t, n, r, a);
  };
  r5().prototype.conv2d = function (e, t, n, r, a, i) {
    this.throwIfDisposed();
    return b7(this, e, t, n, r, a, i);
  };
  r5().prototype.cos = function () {
    this.throwIfDisposed();
    return T7(this);
  };
  r5().prototype.cosh = function () {
    this.throwIfDisposed();
    return E7(this);
  };
  r5().prototype.cumprod = function (e, t, n) {
    this.throwIfDisposed();
    return C7(this, e, t, n);
  };
  r5().prototype.cumsum = function (e, t, n) {
    this.throwIfDisposed();
    return A7(this, e, t, n);
  };
  r5().prototype.depthToSpace = function (e, t) {
    this.throwIfDisposed();
    return _7(this, e, t);
  };
  r5().prototype.depthwiseConv2d = function (e, t, n, r, a, i) {
    this.throwIfDisposed();
    return O7(this, e, t, n, r, a, i);
  };
  r5().prototype.dilation2d = function (e, t, n, r, a) {
    this.throwIfDisposed();
    return D7(this, e, t, n, r, a);
  };
  r5().prototype.divNoNan = function (e) {
    this.throwIfDisposed();
    return V7(this, e);
  };
  r5().prototype.div = function (e) {
    this.throwIfDisposed();
    return m8(this, e);
  };
  r5().prototype.dot = function (e) {
    this.throwIfDisposed();
    return G7(this, e);
  };
  r5().prototype.elu = function () {
    this.throwIfDisposed();
    return H7(this);
  };
  r5().prototype.equal = function (e) {
    this.throwIfDisposed();
    return B7(this, e);
  };
  r5().prototype.erf = function () {
    this.throwIfDisposed();
    return K7(this);
  };
  r5().prototype.euclideanNorm = function (e, t) {
    this.throwIfDisposed();
    return h9(this, e, t);
  };
  r5().prototype.exp = function () {
    this.throwIfDisposed();
    return p9(this);
  };
  r5().prototype.expandDims = function (e) {
    this.throwIfDisposed();
    return f9(this, e);
  };
  r5().prototype.expm1 = function () {
    this.throwIfDisposed();
    return d9(this);
  };
  r5().prototype.fft = function () {
    this.throwIfDisposed();
    return _te(this);
  };
  r5().prototype.flatten = function () {
    this.throwIfDisposed();
    return X8(this, [this.size]);
  };
  r5().prototype.floor = function () {
    this.throwIfDisposed();
    return g9(this);
  };
  r5().prototype.floorDiv = function (e) {
    this.throwIfDisposed();
    return v8(this, e);
  };
  r5().prototype.gather = function (e, t, n) {
    this.throwIfDisposed();
    return y9(this, e, t, n);
  };
  r5().prototype.greaterEqual = function (e) {
    this.throwIfDisposed();
    return x9(this, e);
  };
  r5().prototype.greater = function (e) {
    this.throwIfDisposed();
    return b9(this, e);
  };
  r5().prototype.ifft = function () {
    this.throwIfDisposed();
    return Ote(this);
  };
  r5().prototype.irfft = function () {
    this.throwIfDisposed();
    return Fte(this);
  };
  r5().prototype.isFinite = function () {
    this.throwIfDisposed();
    return w9(this);
  };
  r5().prototype.isInf = function () {
    this.throwIfDisposed();
    return I9(this);
  };
  r5().prototype.isNaN = function () {
    this.throwIfDisposed();
    return N9(this);
  };
  r5().prototype.leakyRelu = function (e) {
    this.throwIfDisposed();
    return S9(this, e);
  };
  r5().prototype.lessEqual = function (e) {
    this.throwIfDisposed();
    return E9(this, e);
  };
  r5().prototype.less = function (e) {
    this.throwIfDisposed();
    return T9(this, e);
  };
  r5().prototype.localResponseNormalization = function (e, t, n, r) {
    this.throwIfDisposed();
    return A9(this, e, t, n, r);
  };
  r5().prototype.logSigmoid = function () {
    this.throwIfDisposed();
    return z9(this);
  };
  r5().prototype.logSoftmax = function (e) {
    this.throwIfDisposed();
    return B9(this, e);
  };
  r5().prototype.logSumExp = function (e, t) {
    this.throwIfDisposed();
    return W9(this, e, t);
  };
  r5().prototype.log = function () {
    this.throwIfDisposed();
    return R9(this);
  };
  r5().prototype.log1p = function () {
    this.throwIfDisposed();
    return _9(this);
  };
  r5().prototype.logicalAnd = function (e) {
    this.throwIfDisposed();
    return U9(this, e);
  };
  r5().prototype.logicalNot = function () {
    this.throwIfDisposed();
    return V9(this);
  };
  r5().prototype.logicalOr = function (e) {
    this.throwIfDisposed();
    return G9(this, e);
  };
  r5().prototype.logicalXor = function (e) {
    this.throwIfDisposed();
    return j9(this, e);
  };
  r5().prototype.matMul = function (e, t, n) {
    this.throwIfDisposed();
    return Q8(this, e, t, n);
  };
  r5().prototype.maxPool = function (e, t, n, r) {
    this.throwIfDisposed();
    return X9(this, e, t, n, r);
  };
  r5().prototype.max = function (e, t) {
    this.throwIfDisposed();
    return n9(this, e, t);
  };
  r5().prototype.maximum = function (e) {
    this.throwIfDisposed();
    return Z9(this, e);
  };
  r5().prototype.mean = function (e, t) {
    this.throwIfDisposed();
    return Q9(this, e, t);
  };
  r5().prototype.min = function (e, t) {
    this.throwIfDisposed();
    return r9(this, e, t);
  };
  r5().prototype.minimum = function (e) {
    this.throwIfDisposed();
    return nee(this, e);
  };
  r5().prototype.mirrorPad = function (e, t) {
    this.throwIfDisposed();
    return ree(this, e, t);
  };
  r5().prototype.mod = function (e) {
    this.throwIfDisposed();
    return aee(this, e);
  };
  r5().prototype.mul = function (e) {
    this.throwIfDisposed();
    return g8(this, e);
  };
  r5().prototype.neg = function () {
    this.throwIfDisposed();
    return M9(this);
  };
  r5().prototype.norm = function (e, t, n) {
    this.throwIfDisposed();
    return l9(this, e, t, n);
  };
  r5().prototype.notEqual = function (e) {
    this.throwIfDisposed();
    return uee(this, e);
  };
  r5().prototype.oneHot = function (e, t = 1, n = 0) {
    this.throwIfDisposed();
    return cee(this, e, t, n);
  };
  r5().prototype.onesLike = function () {
    this.throwIfDisposed();
    return lee(this);
  };
  r5().prototype.pad = function (e, t) {
    this.throwIfDisposed();
    return pee(this, e, t);
  };
  r5().prototype.pool = function (e, t, n, r, a, i) {
    this.throwIfDisposed();
    return yee(this, e, t, n, r, a, i);
  };
  r5().prototype.pow = function (e) {
    this.throwIfDisposed();
    return a9(this, e);
  };
  r5().prototype.prelu = function (e) {
    this.throwIfDisposed();
    return bee(this, e);
  };
  r5().prototype.prod = function (e, t) {
    this.throwIfDisposed();
    return xee(this, e, t);
  };
  r5().prototype.reciprocal = function () {
    this.throwIfDisposed();
    return cte(this);
  };
  r5().prototype.relu = function () {
    this.throwIfDisposed();
    return lte(this);
  };
  r5().prototype.relu6 = function () {
    this.throwIfDisposed();
    return hte(this);
  };
  r5().prototype.reshapeAs = function (e) {
    this.throwIfDisposed();
    return X8(this, e.shape);
  };
  r5().prototype.reshape = function (e) {
    this.throwIfDisposed();
    return X8(this, e);
  };
  r5().prototype.resizeBilinear = function (e, t, n) {
    this.throwIfDisposed();
    return sre(this, e, t, n);
  };
  r5().prototype.resizeNearestNeighbor = function (e, t, n) {
    this.throwIfDisposed();
    return ure(this, e, t, n);
  };
  r5().prototype.reverse = function (e) {
    this.throwIfDisposed();
    return pte(this, e);
  };
  r5().prototype.rfft = function () {
    this.throwIfDisposed();
    return Mte(this);
  };
  r5().prototype.round = function () {
    this.throwIfDisposed();
    return gte(this);
  };
  r5().prototype.rsqrt = function () {
    this.throwIfDisposed();
    return yte(this);
  };
  r5().prototype.selu = function () {
    this.throwIfDisposed();
    return bte(this);
  };
  r5().prototype.separableConv2d = function (e, t, n, r, a, i) {
    this.throwIfDisposed();
    return xte(this, e, t, n, r, a, i);
  };
  r5().prototype.sigmoid = function () {
    this.throwIfDisposed();
    return $8(this);
  };
  r5().prototype.sign = function () {
    this.throwIfDisposed();
    return Ite(this);
  };
  r5().prototype.sin = function () {
    this.throwIfDisposed();
    return Nte(this);
  };
  r5().prototype.sinh = function () {
    this.throwIfDisposed();
    return Ste(this);
  };
  r5().prototype.slice = function (e, t) {
    this.throwIfDisposed();
    return e7(this, e, t);
  };
  r5().prototype.softmax = function (e) {
    this.throwIfDisposed();
    return Rte(this, e);
  };
  r5().prototype.softplus = function () {
    this.throwIfDisposed();
    return L9(this);
  };
  r5().prototype.spaceToBatchND = function (e, t) {
    this.throwIfDisposed();
    return gee(this, e, t);
  };
  r5().prototype.split = function (e, t) {
    this.throwIfDisposed();
    return Dte(this, e, t);
  };
  r5().prototype.sqrt = function () {
    this.throwIfDisposed();
    return o9(this);
  };
  r5().prototype.square = function () {
    this.throwIfDisposed();
    return s9(this);
  };
  r5().prototype.squaredDifference = function (e) {
    this.throwIfDisposed();
    return Lte(this, e);
  };
  r5().prototype.squeeze = function (e) {
    this.throwIfDisposed();
    return zte(this, e);
  };
  r5().prototype.stack = function (e, t) {
    this.throwIfDisposed();
    var n = e instanceof n5 ? [this, e] : [this].concat(T(e));
    return Pte(n, t);
  };
  r5().prototype.step = function (e) {
    this.throwIfDisposed();
    return Bte(this, e);
  };
  r5().prototype.stridedSlice = function (e, t, n, r, a, i, o, s) {
    this.throwIfDisposed();
    return Wte(this, e, t, n, r, a, i, o, s);
  };
  r5().prototype.sub = function (e) {
    this.throwIfDisposed();
    return P9(this, e);
  };
  r5().prototype.sum = function (e, t) {
    this.throwIfDisposed();
    return u9(this, e, t);
  };
  r5().prototype.tan = function () {
    this.throwIfDisposed();
    return Ute(this);
  };
  r5().prototype.tanh = function () {
    this.throwIfDisposed();
    return t7(this);
  };
  r5().prototype.tile = function (e) {
    this.throwIfDisposed();
    return v9(this, e);
  };
  r5().prototype.toBool = function () {
    this.throwIfDisposed();
    return h8(this, "bool");
  };
  r5().prototype.toFloat = function () {
    this.throwIfDisposed();
    return h8(this, "float32");
  };
  r5().prototype.toInt = function () {
    this.throwIfDisposed();
    return h8(this, "int32");
  };
  r5().prototype.topk = function (e, t) {
    this.throwIfDisposed();
    return $te(this, e, t);
  };
  r5().prototype.transpose = function (e) {
    this.throwIfDisposed();
    return hne(this, e);
  };
  r5().prototype.unique = function (e) {
    this.throwIfDisposed();
    return tne(this, e);
  };
  r5().prototype.unsortedSegmentSum = function (e, t) {
    this.throwIfDisposed();
    return nne(this, e, t);
  };
  r5().prototype.unstack = function (e) {
    this.throwIfDisposed();
    return rne(this, e);
  };
  r5().prototype.where = function (e, t) {
    this.throwIfDisposed();
    return W7(e, this, t);
  };
  r5().prototype.zerosLike = function () {
    this.throwIfDisposed();
    return U7(this);
  };
  var Tse = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      Object.setPrototypeOf(x(r), n.prototype);
      return r;
    }
    return p(n);
  }(b(Error));
  var Ese = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      Object.setPrototypeOf(x(r), n.prototype);
      return r;
    }
    return p(n);
  }(b(Error));
  var Cse = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      Object.setPrototypeOf(x(r), n.prototype);
      return r;
    }
    return p(n);
  }(b(Error));
  var Ase = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      Object.setPrototypeOf(x(r), n.prototype);
      return r;
    }
    return p(n);
  }(b(Error));
  var Rse = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      Object.setPrototypeOf(x(r), n.prototype);
      return r;
    }
    return p(n);
  }(b(Error));
  Error;
  var _se = function () {
    function e(t) {
      l(this, e);
      this.maxEntries = t || 100;
      this.cache = new Map();
    }
    p(e, [{
      key: "get",
      value: function (e) {
        var t;
        if (this.cache.has(e)) {
          t = this.cache.get(e);
          this.cache.delete(e);
          this.cache.set(e, t);
        }
        return t;
      }
    }, {
      key: "put",
      value: function (e, t) {
        if (this.cache.has(e)) {
          this.cache.delete(e);
        } else if (this.cache.size >= this.maxEntries) {
          var n = this.cache.keys().next().value;
          this.cache.delete(n);
        }
        this.cache.set(e, t);
      }
    }, {
      key: "getMaxEntries",
      value: function () {
        return this.maxEntries;
      }
    }, {
      key: "setMaxEntries",
      value: function (e) {
        if (e < 0) {
          throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);
        }
        if (this.maxEntries > e) {
          for (var t = 0; t < this.maxEntries - e; t++) {
            var n = this.cache.keys().next().value;
            this.cache.delete(n);
          }
        }
        this.maxEntries = e;
      }
    }]);
    return e;
  }();
  function Ose(e, t) {
    if (Array.isArray(e)) {
      var n = [];
      for (var r = 0; r < t; r++) {
        n = n.concat(e);
      }
      return n;
    }
    var a = new Array(t);
    a.fill(e);
    return a;
  }
  function Fse(e, t) {
    if (!e) {
      throw new Rse(t);
    }
  }
  function Dse(e, t) {
    var n;
    var r = 0;
    var a = O(e);
    try {
      for (a.s(); !(n = a.n()).done;) {
        if (n.value === t) {
          r++;
        }
      }
    } catch (e) {
      a.e(e);
    } finally {
      a.f();
    }
    return r;
  }
  function Mse(e) {
    if (e.length === 1) {
      return e[0];
    } else {
      return e;
    }
  }
  function Lse(e) {
    if (Array.isArray(e)) {
      return e;
    } else {
      return [e];
    }
  }
  function zse(e) {
    var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    if (t[0] !== "_") {
      return t;
    } else {
      return "private" + t;
    }
  }
  function Pse(e) {
    if (e.length <= 1 || e.indexOf("_") === -1) {
      return e;
    } else {
      return e.replace(/[_]+(\w|$)/g, function (e, t) {
        return t.toUpperCase();
      });
    }
  }
  var Bse = {};
  function Wse(e) {
    if (e == null) {
      return null;
    }
    var t = {};
    t.className = e.getClassName();
    t.config = e.getConfig();
    return t;
  }
  function Use(e) {
    if (e != null && s(e) === "object") {
      if (Array.isArray(e)) {
        e.forEach(function (e) {
          return Use(e);
        });
      } else {
        for (var t = 0, n = Object.keys(e); t < n.length; t++) {
          var r = n[t];
          var a = e[r];
          if (a != null && s(a) === "object") {
            if (Array.isArray(a) || a.type !== "ndarray" || typeof a.value != "number") {
              Use(a);
            } else {
              e[r] = a.value;
            }
          }
        }
      }
    }
  }
  function Vse(e, t = {}, n = {}, r = "object", a = false) {
    if (typeof e == "string") {
      var i;
      var o = e;
      if (o in n) {
        i = n[o];
      } else if (o in Bse) {
        i = Bse[o];
      } else if ((i = t[o]) == null) {
        throw new Cse(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      }
      return i;
    }
    var s = e;
    if (s.className == null || s.config == null) {
      throw new Cse(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);
    }
    var u;
    var c;
    var l = s.className;
    if (l in n) {
      var h = S(n[l], 2);
      u = h[0];
      c = h[1];
    } else if (l in Bse) {
      var p = S(Bse.className, 2);
      u = p[0];
      c = p[1];
    } else if (l in t) {
      var f = S(t[l], 2);
      u = f[0];
      c = f[1];
    }
    if (u == null) {
      throw new Cse(`Unknown ${r}: ${l}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
    }
    if (c != null) {
      var d = {};
      for (var v = 0, m = Object.keys(Bse); v < m.length; v++) {
        var g = m[v];
        d[g] = Bse[g];
      }
      for (var y = 0, b = Object.keys(n); y < b.length; y++) {
        var x = b[y];
        d[x] = n[x];
      }
      var k = s.config;
      k.customObjects = d;
      var w = Object.assign({}, Bse);
      for (var I = 0, N = Object.keys(n); I < N.length; I++) {
        var T = N[I];
        Bse[T] = n[T];
      }
      Use(s.config);
      var E = c(u, s.config, n, a);
      Bse = Object.assign({}, w);
      return E;
    }
    var C = Object.assign({}, Bse);
    for (var A = 0, R = Object.keys(n); A < R.length; A++) {
      var _ = R[A];
      Bse[_] = n[_];
    }
    var O = new u(s.config);
    Bse = Object.assign({}, C);
    return O;
  }
  function Gse(e, t) {
    return function (e, t) {
      if (e < t) {
        return -1;
      } else if (e > t) {
        return 1;
      } else {
        return 0;
      }
    }(e, t) * -1;
  }
  function jse(e) {
    if (e == null) {
      return e;
    }
    var t;
    var n = [];
    var r = O(e);
    try {
      for (r.s(); !(t = r.n()).done;) {
        var a = t.value;
        if (n.indexOf(a) === -1) {
          n.push(a);
        }
      }
    } catch (e) {
      r.e(e);
    } finally {
      r.f();
    }
    return n;
  }
  function Hse(e) {
    if (e == null) {
      throw new Cse(`Invalid value in obj: ${JSON.stringify(e)}`);
    }
    for (var t in e) {
      if (e.hasOwnProperty(t)) {
        return false;
      }
    }
    return true;
  }
  function qse(e, t, n) {
    if (n != null && e.indexOf(n) < 0) {
      throw new Cse(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`);
    }
  }
  function Kse(e, t, n = 0, r = Infinity) {
    Fse(n >= 0);
    Fse(r >= n);
    return Array.isArray(e) && e.length >= n && e.length <= r && e.every(function (e) {
      return s(e) === t;
    });
  }
  function Xse(e, t) {
    if (Array.isArray(e)) {
      F$(e.length > 0, function () {
        return `${t} is unexpectedly an empty array.`;
      });
      e.forEach(function (e, n) {
        return Xse(e, `element ${n + 1} of ${t}`);
      });
    } else {
      F$(Number.isInteger(e) && e > 0, function () {
        return `Expected ${t} to be a positive integer, but got ${Yse(e)}.`;
      });
    }
  }
  function Yse(e) {
    if (e === null) {
      return "null";
    } else if (Array.isArray(e)) {
      return "[" + e.map(function (e) {
        return Yse(e);
      }).join(",") + "]";
    } else if (typeof e == "string") {
      return `"${e}"`;
    } else {
      return `${e}`;
    }
  }
  function Jse(e) {
    if (e === "relu") {
      return "relu";
    } else if (e === "linear") {
      return "linear";
    } else if (e === "elu") {
      return "elu";
    } else {
      return null;
    }
  }
  var Zse = 0;
  function Qse() {
    return Zse++;
  }
  var $se = {};
  function eue(e = "") {
    if (!(e in $se)) {
      $se[e] = 0;
    }
    $se[e] += 1;
    return e + $se[e].toString();
  }
  var tue = ["channelsFirst", "channelsLast"];
  var nue = ["nearest", "bilinear"];
  var rue = ["valid", "same", "causal"];
  var aue = ["max", "avg"];
  var iue = ["sum", "mul", "concat", "ave"];
  var oue = new Map();
  function sue(e) {
    qse(tue, "DataFormat", e);
  }
  function uue(e) {
    qse(rue, "PaddingMode", e);
  }
  function cue(e) {
    qse(aue, "PoolMode", e);
  }
  var lue = [];
  function hue(e, t) {
    lue.push(e);
    try {
      var n = t();
      lue.pop();
      return n;
    } catch (e) {
      lue.pop();
      throw e;
    }
  }
  function pue(e) {
    if (!mue(e)) {
      throw new Error("Not a valid tensor name: '" + e + "'");
    }
    return (lue.length === 0 ? "" : lue.join("/") + "/") + e;
  }
  function fue(e) {
    if (!mue(e)) {
      throw new Error("Not a valid tensor name: '" + e + "'");
    }
    if (!oue.has(e)) {
      oue.set(e, 0);
    }
    var t = oue.get(e);
    oue.set(e, oue.get(e) + 1);
    if (t > 0) {
      var n = `${e}_${t}`;
      oue.set(n, 1);
      return n;
    }
    return e;
  }
  var due;
  var vue = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
  function mue(e) {
    return !!e.match(vue);
  }
  function gue(e, t, n) {
    if (t == null) {
      t = 0;
    }
    if (n == null) {
      n = e.length;
    }
    var r = 1;
    for (var a = t; a < n; ++a) {
      r *= e[a];
    }
    return r;
  }
  function yue(e) {
    if (e.length === 0) {
      return Number.NaN;
    }
    var t = Number.POSITIVE_INFINITY;
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      if (r < t) {
        t = r;
      }
    }
    return t;
  }
  function bue(e) {
    if (e.length === 0) {
      return Number.NaN;
    }
    var t = Number.NEGATIVE_INFINITY;
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      if (r > t) {
        t = r;
      }
    }
    return t;
  }
  function xue(e, t) {
    if (t < e) {
      throw new Cse(`end (${t}) < begin (${e}) is forbidden.`);
    }
    var n = [];
    for (var r = e; r < t; ++r) {
      n.push(r);
    }
    return n;
  }
  function kue() {
    if (due == null) {
      due = e6().epsilon();
    }
    return due;
  }
  function wue(e, t) {
    return h8(e, t);
  }
  function Iue(e, t = -1) {
    var n = e.shape.slice();
    if (t < 0) {
      t = n.length + t + 1;
    }
    n.splice(t, 0, 1);
    return X8(e, n);
  }
  function Nue(e) {
    var t = [gue(e.shape)];
    return X8(e, t);
  }
  function Sue(e, t, n) {
    return X5(function () {
      switch (e.rank) {
        case 1:
          return Tte(e, t, n);
        case 2:
          return Ete(e, [t, 0], [n, e.shape[1]]);
        case 3:
          return Cte(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);
        case 4:
          return Ate(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);
        case 5:
          return e7(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);
        case 6:
          return e7(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);
        default:
          throw new Cse(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`);
      }
    });
  }
  function Tue(e, t, n) {
    return X5(function () {
      switch (e.rank) {
        case 1:
          return Tte(e, t, n);
        case 2:
          return Ete(e, [0, t], [e.shape[0], n]);
        case 3:
          return Cte(e, [0, 0, t], [e.shape[0], e.shape[1], n]);
        case 4:
          return Ate(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);
        default:
          throw new Cse(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`);
      }
    });
  }
  function Eue(e, t, n, r) {
    return X5(function () {
      switch (e.rank) {
        case 1:
          return Tte(e, t, n);
        case 2:
          switch (r) {
            case 1:
              return Sue(e, t, n);
            case 2:
              return Tue(e, t, n);
            default:
              throw new Cse(`The axis is not within the rank of the tensor ${r}`);
          }
        case 3:
          switch (r) {
            case 1:
              return Sue(e, t, n);
            case 2:
              return Cte(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);
            case 3:
              return Tue(e, t, n);
            default:
              throw new Cse(`The axis is not within the rank of the tensor ${r}`);
          }
        case 4:
          switch (r) {
            case 1:
              return Sue(e, t, n);
            case 2:
              return Ate(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);
            case 3:
              return Ate(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);
            case 4:
              return Tue(e, t, n);
            default:
              throw new Cse(`The axis is not within the rank of the tensor ${r}`);
          }
        default:
          throw new Cse(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`);
      }
    });
  }
  function Cue(e) {
    var t;
    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    if (n < 0) {
      n = (t = e[0].rank) !== 0 ? t : 0;
    }
    if (n === e[0].rank) {
      n = -1;
    }
    return Z8(e, n);
  }
  function Aue(e, t) {
    switch (e.rank) {
      case 1:
        return v7([e, t]);
      case 2:
        return m7([e, t], 0);
      case 3:
        return g7([e, t], 0);
      case 4:
        return y7([e, t], 0);
      default:
        throw new Cse(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`);
    }
  }
  function Rue(e, t) {
    if (!Array.isArray(t)) {
      t = [t];
    }
    if (e.rank !== t.length) {
      throw new Cse(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);
    }
    return v9(e, t);
  }
  function _ue(e, t = 0, n = 1, r, a) {
    return rte(e, t, n, r, a);
  }
  function Oue(e, t, n, r) {
    if (e.rank < 2 || t.rank < 2) {
      throw new Ase(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);
    }
    if (t.rank >= 3 && e.shape.slice(-1)[0] !== t.shape.slice(-2)[0]) {
      throw new Ase(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);
    }
    if (e.rank === 2 && t.rank === 2) {
      return _ne({
        a: e,
        b: t,
        transposeA: false,
        transposeB: false,
        bias: r ? Mue(e.rank, r, "channelsLast") : null,
        activation: n
      });
    }
    var a = e.shape.slice();
    var i = a.pop();
    e = X8(e, [-1, i]);
    var o = t.shape.slice();
    var s = o.pop();
    var u = o.pop();
    var c = [].concat(T(o), [s]);
    var l = Array.from({
      length: t.rank
    }, function (e, n) {
      if (n === 0) {
        return t.rank - 2;
      } else if (n <= t.rank - 2) {
        return n - 1;
      } else {
        return n;
      }
    });
    t = X8(hne(t, l), [u, -1]);
    var h = [].concat(T(a), T(c));
    return X8(_ne({
      a: e,
      b: t,
      transposeA: false,
      transposeB: false,
      bias: r ? Mue(e.rank, r, "channelsLast") : null,
      activation: n
    }), h);
  }
  function Fue(e, t, n) {
    return X5(function () {
      t = Array.isArray(t) ? Vte(t, "int32") : h8(t, "int32");
      return y9(e, t, n);
    });
  }
  function Due(e) {
    return g8(e, e);
  }
  function Mue(e, t, n) {
    var r = t.shape;
    if (t.rank !== 1 && t.rank !== e) {
      throw new Cse(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);
    }
    if (e === 5) {
      if (n === "channelsFirst") {
        if (r.length === 1) {
          return X8(t, [1, r[0], 1, 1, 1]);
        } else {
          return X8(t, [1, r[3], r[0], r[1], r[2]]);
        }
      }
      if (n === "channelsLast") {
        if (r.length === 1) {
          return X8(t, [1, 1, 1, 1, r[0]]);
        } else {
          return X8(t, [1].concat(r));
        }
      }
    } else if (e === 4) {
      if (n === "channelsFirst") {
        if (r.length === 1) {
          return X8(t, [1, r[0], 1, 1]);
        } else {
          return X8(t, [1, r[2], r[0], r[1]]);
        }
      }
      if (n === "channelsLast") {
        if (r.length === 1) {
          return X8(t, [1, 1, 1, r[0]]);
        } else {
          return X8(t, [1].concat(r));
        }
      }
    } else if (e === 3) {
      if (n === "channelsFirst") {
        if (r.length === 1) {
          return X8(t, [1, r[0], 1]);
        } else {
          return X8(t, [1, r[1], r[0]]);
        }
      }
      if (n === "channelsLast") {
        if (r.length === 1) {
          return X8(t, [1, 1, r[0]]);
        } else {
          return X8(t, [1].concat(r));
        }
      }
    } else if (e < 3) {
      return t;
    }
    throw new Cse(`Unsupported input rank by biasAdd: ${t.rank}`);
  }
  function Lue(e, t, n) {
    return X5(function () {
      if (n == null) {
        n = "channelsLast";
      }
      sue(n);
      return d8(e, Mue(e.rank, t, n));
    });
  }
  function zue(e, t = 1) {
    if (t !== 1) {
      throw new Ase(`Support for alpha values other than 1 (${t}) is not implemented yet.`);
    }
    return H7(e);
  }
  function Pue(e, t, n, r) {
    return X5(function () {
      return gne(e, t, n, r);
    });
  }
  function Bue(e, t, n = false) {
    if (n) {
      return e();
    } else {
      return t();
    }
  }
  var Wue = ["fanIn", "fanOut", "fanAvg"];
  var Uue = ["normal", "uniform", "truncatedNormal"];
  var Vue = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "fromConfigUsesCustomObjects",
      value: function () {
        return false;
      }
    }, {
      key: "getConfig",
      value: function () {
        return {};
      }
    }]);
    return n;
  }(Hre);
  var Gue = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        return $9(e, t);
      }
    }]);
    return n;
  }(Vue);
  Gue.className = "Zeros";
  Kre(Gue);
  var jue = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        return eee(e, t);
      }
    }]);
    return n;
  }(Vue);
  jue.className = "Ones";
  Kre(jue);
  var Hue = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this);
      if (s(e) !== "object") {
        throw new Cse(`Expected argument of type ConstantConfig but got ${e}`);
      }
      if (e.value === undefined) {
        throw new Cse(`config must have value set but got ${e}`);
      }
      r.value = e.value;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          return g8(i9(n.value), eee(e, t));
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          value: this.value
        };
      }
    }]);
    return n;
  }(Vue);
  Hue.className = "Constant";
  Kre(Hue);
  var que = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).DEFAULT_MINVAL = -0.05;
      r.DEFAULT_MAXVAL = 0.05;
      r.minval = e.minval || r.DEFAULT_MINVAL;
      r.maxval = e.maxval || r.DEFAULT_MAXVAL;
      r.seed = e.seed;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        return ite(e, this.minval, this.maxval, t, this.seed);
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          minval: this.minval,
          maxval: this.maxval,
          seed: this.seed
        };
      }
    }]);
    return n;
  }(Vue);
  que.className = "RandomUniform";
  Kre(que);
  var Kue = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).DEFAULT_MEAN = 0;
      r.DEFAULT_STDDEV = 0.05;
      r.mean = e.mean || r.DEFAULT_MEAN;
      r.stddev = e.stddev || r.DEFAULT_STDDEV;
      r.seed = e.seed;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        if ((t = t || "float32") !== "float32" && t !== "int32") {
          throw new Ase(`randomNormal does not support dType ${t}.`);
        }
        return _ue(e, this.mean, this.stddev, t, this.seed);
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          mean: this.mean,
          stddev: this.stddev,
          seed: this.seed
        };
      }
    }]);
    return n;
  }(Vue);
  Kue.className = "RandomNormal";
  Kre(Kue);
  var Xue = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).DEFAULT_MEAN = 0;
      r.DEFAULT_STDDEV = 0.05;
      r.mean = e.mean || r.DEFAULT_MEAN;
      r.stddev = e.stddev || r.DEFAULT_STDDEV;
      r.seed = e.seed;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        if ((t = t || "float32") !== "float32" && t !== "int32") {
          throw new Ase(`truncatedNormal does not support dType ${t}.`);
        }
        return ene(e, this.mean, this.stddev, t, this.seed);
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          mean: this.mean,
          stddev: this.stddev,
          seed: this.seed
        };
      }
    }]);
    return n;
  }(Vue);
  Xue.className = "TruncatedNormal";
  Kre(Xue);
  var Yue = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).gain = e.gain ?? 1;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (e.length !== 2 || e[0] !== e[1]) {
            throw new Cse("Identity matrix initializer can only be used for 2D square matrices.");
          }
          return g8(n.gain, m9(e[0]));
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          gain: this.gain
        };
      }
    }]);
    return n;
  }(Vue);
  Yue.className = "Identity";
  Kre(Yue);
  var Jue = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      var a;
      l(this, n);
      r = t.call(this);
      if (e.scale < 0) {
        throw new Cse(`scale must be a positive float. Got: ${e.scale}`);
      }
      r.scale = e.scale == null ? 1 : e.scale;
      r.mode = e.mode == null ? "fanIn" : e.mode;
      a = r.mode;
      qse(Wue, "FanMode", a);
      r.distribution = e.distribution == null ? "normal" : e.distribution;
      (function (e) {
        qse(Uue, "Distribution", e);
      })(r.distribution);
      r.seed = e.seed;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        var n = function (e) {
          var t;
          var n;
          var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "channelsLast";
          sue(r);
          if (e.length === 2) {
            t = e[0];
            n = e[1];
          } else if ([3, 4, 5].indexOf(e.length) !== -1) {
            if (r === "channelsFirst") {
              var a = gue(e, 2);
              t = e[1] * a;
              n = e[0] * a;
            } else if (r === "channelsLast") {
              var i = gue(e, 0, e.length - 2);
              t = e[e.length - 2] * i;
              n = e[e.length - 1] * i;
            }
          } else {
            var o = gue(e);
            t = Math.sqrt(o);
            n = Math.sqrt(o);
          }
          return [t, n];
        }(e);
        var r = n[0];
        var a = n[1];
        var i = this.scale;
        if (this.mode === "fanIn") {
          i /= Math.max(1, r);
        } else if (this.mode === "fanOut") {
          i /= Math.max(1, a);
        } else {
          i /= Math.max(1, (r + a) / 2);
        }
        if (this.distribution === "normal") {
          var o = Math.sqrt(i);
          if ((t = t || "float32") !== "float32" && t !== "int32") {
            throw new Ase(`${this.getClassName()} does not support dType ${t}.`);
          }
          return ene(e, 0, o, t, this.seed);
        }
        var s = Math.sqrt(i * 3);
        return ite(e, -s, s, t, this.seed);
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          scale: this.scale,
          mode: this.mode,
          distribution: this.distribution,
          seed: this.seed
        };
      }
    }]);
    return n;
  }(Vue);
  Jue.className = "VarianceScaling";
  Kre(Jue);
  var Zue = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, {
        scale: 1,
        mode: "fanAvg",
        distribution: "uniform",
        seed: e == null ? null : e.seed
      });
    }
    p(n, [{
      key: "getClassName",
      value: function () {
        return Jue.className;
      }
    }]);
    return n;
  }(Jue);
  Zue.className = "GlorotUniform";
  Kre(Zue);
  var Que = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, {
        scale: 1,
        mode: "fanAvg",
        distribution: "normal",
        seed: e == null ? null : e.seed
      });
    }
    p(n, [{
      key: "getClassName",
      value: function () {
        return Jue.className;
      }
    }]);
    return n;
  }(Jue);
  Que.className = "GlorotNormal";
  Kre(Que);
  var $ue = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, {
        scale: 2,
        mode: "fanIn",
        distribution: "normal",
        seed: e == null ? null : e.seed
      });
    }
    p(n, [{
      key: "getClassName",
      value: function () {
        return Jue.className;
      }
    }]);
    return n;
  }(Jue);
  $ue.className = "HeNormal";
  Kre($ue);
  var ece = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, {
        scale: 2,
        mode: "fanIn",
        distribution: "uniform",
        seed: e == null ? null : e.seed
      });
    }
    p(n, [{
      key: "getClassName",
      value: function () {
        return Jue.className;
      }
    }]);
    return n;
  }(Jue);
  ece.className = "HeUniform";
  Kre(ece);
  var tce = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, {
        scale: 1,
        mode: "fanIn",
        distribution: "normal",
        seed: e == null ? null : e.seed
      });
    }
    p(n, [{
      key: "getClassName",
      value: function () {
        return Jue.className;
      }
    }]);
    return n;
  }(Jue);
  tce.className = "LeCunNormal";
  Kre(tce);
  var nce = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, {
        scale: 1,
        mode: "fanIn",
        distribution: "uniform",
        seed: e == null ? null : e.seed
      });
    }
    p(n, [{
      key: "getClassName",
      value: function () {
        return Jue.className;
      }
    }]);
    return n;
  }(Jue);
  nce.className = "LeCunUniform";
  Kre(nce);
  var rce = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).DEFAULT_GAIN = 1;
      r.ELEMENTS_WARN_SLOW = 2000;
      r.gain = e.gain == null ? r.DEFAULT_GAIN : e.gain;
      r.seed = e.seed;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (e.length < 2) {
            throw new Ase("Shape must be at least 2D.");
          }
          if (t !== "int32" && t !== "float32" && t !== undefined) {
            throw new TypeError(`Unsupported data type ${t}.`);
          }
          var r = L$(e.slice(0, -1));
          var a = e[e.length - 1];
          var i = r * a;
          if (i > n.ELEMENTS_WARN_SLOW) {
            console.warn(`Orthogonal initializer is being called on a matrix with more than ${n.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);
          }
          var o = _ue([Math.max(a, r), Math.min(a, r)], 0, 1, t, n.seed);
          var s = Bre.qr(o, false);
          var u = s[0];
          var c = s[1].flatten().stridedSlice([0], [Math.min(a, r) * Math.min(a, r)], [Math.min(a, r) + 1]);
          u = g8(u, c.sign());
          if (r < a) {
            u = u.transpose();
          }
          return g8(i9(n.gain), u.reshape(e));
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          gain: this.gain,
          seed: this.seed
        };
      }
    }]);
    return n;
  }(Vue);
  rce.className = "Orthogonal";
  Kre(rce);
  var ace = {
    constant: "Constant",
    glorotNormal: "GlorotNormal",
    glorotUniform: "GlorotUniform",
    heNormal: "HeNormal",
    heUniform: "HeUniform",
    identity: "Identity",
    leCunNormal: "LeCunNormal",
    leCunUniform: "LeCunUniform",
    ones: "Ones",
    orthogonal: "Orthogonal",
    randomNormal: "RandomNormal",
    randomUniform: "RandomUniform",
    truncatedNormal: "TruncatedNormal",
    varianceScaling: "VarianceScaling",
    zeros: "Zeros"
  };
  function ice(e, t = {}) {
    return Vse(e, qre.getMap().classNameMap, t, "initializer");
  }
  function oce(e) {
    return Wse(e);
  }
  function sce(e) {
    if (typeof e == "string") {
      var t = e in ace ? ace[e] : e;
      if (t === "GlorotNormal") {
        return new Que();
      }
      if (t === "GlorotUniform") {
        return new Zue();
      }
      if (t === "HeNormal") {
        return new $ue();
      }
      if (t === "HeUniform") {
        return new ece();
      }
      if (t === "LeCunNormal") {
        return new tce();
      }
      if (t === "LeCunUniform") {
        return new nce();
      }
      var n = {
        className: t,
        config: {}
      };
      return ice(n);
    }
    if (e instanceof Vue) {
      return e;
    } else {
      return ice(e);
    }
  }
  function uce(e) {
    return Array.isArray(e) && Array.isArray(e[0]);
  }
  function cce(e) {
    if (e.length === 0) {
      return [];
    } else if (Array.isArray(e[0])) {
      return e;
    } else {
      return [e];
    }
  }
  function lce(e) {
    var t;
    if (Array.isArray(e)) {
      if (e.length !== 1) {
        throw new Cse(`Expected Tensor length to be 1; got ${e.length}`);
      }
      t = e[0];
    } else {
      t = e;
    }
    return t;
  }
  function hce(e) {
    if (Array.isArray(e) && Array.isArray(e[0])) {
      if (e.length === 1) {
        return e[0];
      }
      throw new Cse(`Expected exactly 1 Shape; got ${e.length}`);
    }
    return e;
  }
  function pce(e) {
    var t;
    var n = 0;
    var r = O(e);
    try {
      for (r.s(); !(t = r.n()).done;) {
        var a = t.value;
        if (a.shape.length === 0) {
          n += 1;
        } else {
          n += a.shape.reduce(function (e, t) {
            return e * t;
          });
        }
      }
    } catch (e) {
      r.e(e);
    } finally {
      r.f();
    }
    return n;
  }
  var fce = "Variable";
  var dce = function () {
    function e(t, n = "float32", r = fce) {
      var a = !(arguments.length > 3) || arguments[3] === undefined || arguments[3];
      var i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      l(this, e);
      this.dtype = n == null ? "float32" : n;
      this.shape = t.shape;
      this.id = Qse();
      r = r == null ? fce : r;
      this.originalName = pue(r);
      this.name = fue(this.originalName);
      this.trainable_ = a;
      this.constraint = i;
      this.val = ine(t, this.trainable_, this.name, this.dtype);
    }
    p(e, [{
      key: "read",
      value: function () {
        this.assertNotDisposed();
        return this.val;
      }
    }, {
      key: "write",
      value: function (e) {
        this.assertNotDisposed();
        (function (e, t) {
          if (e.shape.toString() !== t.shape.toString()) {
            throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
          }
        })(this.val, e);
        if (this.val.id !== e.id) {
          this.val.assign(e);
          if (this.constraint != null) {
            this.val.assign(this.constraint.apply(this.val));
          }
        }
        return this;
      }
    }, {
      key: "dispose",
      value: function () {
        this.assertNotDisposed();
        this.val.dispose();
      }
    }, {
      key: "assertNotDisposed",
      value: function () {
        if (this.val.isDisposed) {
          throw new Error(`LayersVariable ${this.name} is already disposed.`);
        }
      }
    }, {
      key: "trainable",
      get: function () {
        return this.trainable_;
      },
      set: function (e) {
        this.trainable_ = e;
        this.val.trainable = e;
      }
    }]);
    return e;
  }();
  function vce(e) {
    return e.map(function (e) {
      return e.read();
    });
  }
  function mce(e) {
    e.forEach(function (e) {
      e[0].write(e[1]);
    });
  }
  var gce = p(function e(t) {
    l(this, e);
    this.dtype = t.dtype;
    this.shape = t.shape;
    if (t.shape != null) {
      this.ndim = t.shape.length;
    } else {
      this.ndim = t.ndim;
    }
    this.maxNDim = t.maxNDim;
    this.minNDim = t.minNDim;
    this.axes = t.axes || {};
  });
  var yce = p(function e(t, n, r, a, i, o, s) {
    l(this, e);
    this.dtype = t;
    this.shape = n;
    this.sourceLayer = r;
    this.inputs = a;
    this.callArgs = i;
    this.outputTensorIndex = s;
    this.id = Qse();
    if (o != null) {
      this.originalName = pue(o);
      this.name = fue(this.originalName);
    }
    this.rank = n.length;
  });
  var bce = 0;
  var xce = function () {
    function e(t, n) {
      l(this, e);
      this.callArgs = n;
      this.id = bce++;
      this.outboundLayer = t.outboundLayer;
      this.inboundLayers = t.inboundLayers;
      this.nodeIndices = t.nodeIndices;
      this.tensorIndices = t.tensorIndices;
      this.inputTensors = t.inputTensors;
      this.outputTensors = t.outputTensors;
      this.inputMasks = t.inputMasks;
      this.outputMasks = t.outputMasks;
      this.inputShapes = t.inputShapes;
      this.outputShapes = t.outputShapes;
      var r;
      var a = O(t.inboundLayers);
      try {
        for (a.s(); !(r = a.n()).done;) {
          var i = r.value;
          if (i != null) {
            i.outboundNodes.push(this);
          }
        }
      } catch (e) {
        a.e(e);
      } finally {
        a.f();
      }
      t.outboundLayer.inboundNodes.push(this);
    }
    p(e, [{
      key: "getConfig",
      value: function () {
        var e;
        var t = [];
        var n = O(this.inboundLayers);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            if (r != null) {
              t.push(r.name);
            } else {
              t.push(null);
            }
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        return {
          outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
          inboundLayers: t,
          nodeIndices: this.nodeIndices,
          tensorIndices: this.tensorIndices
        };
      }
    }]);
    return e;
  }();
  var kce = 0;
  var wce = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      var e;
      var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      l(this, n);
      (e = t.call(this))._callHook = null;
      e._addedWeightNames = [];
      e._stateful = false;
      e.id = kce++;
      e.activityRegularizer = null;
      e.inputSpec = null;
      e.supportsMasking = false;
      e._trainableWeights = [];
      e._nonTrainableWeights = [];
      e._losses = [];
      e._updates = [];
      e._built = false;
      e.inboundNodes = [];
      e.outboundNodes = [];
      var a = r.name;
      if (!a) {
        var i = e.getClassName();
        a = zse(i) + "_" + eue(i);
      }
      e.name = a;
      e.trainable_ = r.trainable == null || r.trainable;
      if (r.inputShape != null || r.batchInputShape != null) {
        var o;
        if (r.batchInputShape != null) {
          o = r.batchInputShape;
        } else if (r.inputShape != null) {
          var s = null;
          if (r.batchSize != null) {
            s = r.batchSize;
          }
          o = [s].concat(r.inputShape);
        }
        e.batchInputShape = o;
        var u = r.dtype;
        if (u == null) {
          u = r.inputDType;
        }
        if (u == null) {
          u = "float32";
        }
        e.dtype = u;
      }
      if (r.weights != null) {
        e.initialWeights = r.weights;
      } else {
        e.initialWeights = null;
      }
      e._refCount = null;
      e.fastWeightInitDuringBuild = false;
      return e;
    }
    p(n, [{
      key: "getNodeAtIndex",
      value: function (e, t) {
        if (this.inboundNodes.length === 0) {
          throw new Ese(`The layer has never been called and thus has no defined ${t}.`);
        }
        if (this.inboundNodes.length <= e) {
          throw new Cse(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
        }
        return this.inboundNodes[e];
      }
    }, {
      key: "getInputAt",
      value: function (e) {
        return Mse(this.getNodeAtIndex(e, "input").inputTensors);
      }
    }, {
      key: "getOutputAt",
      value: function (e) {
        return Mse(this.getNodeAtIndex(e, "output").outputTensors);
      }
    }, {
      key: "input",
      get: function () {
        if (this.inboundNodes.length > 1) {
          throw new Tse(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
        }
        if (this.inboundNodes.length === 0) {
          throw new Tse(`Layer ${this.name} is not connected, no input to return.`);
        }
        return Mse(this.getNodeAtIndex(0, "input").inputTensors);
      }
    }, {
      key: "output",
      get: function () {
        if (this.inboundNodes.length === 0) {
          throw new Tse(`Layer ${this.name} has no inbound nodes.`);
        }
        if (this.inboundNodes.length > 1) {
          throw new Tse(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
        }
        return Mse(this.getNodeAtIndex(0, "output").outputTensors);
      }
    }, {
      key: "losses",
      get: function () {
        return this._losses;
      }
    }, {
      key: "calculateLosses",
      value: function () {
        return this.losses.map(function (e) {
          return e();
        });
      }
    }, {
      key: "updates",
      get: function () {
        return this._updates;
      }
    }, {
      key: "built",
      get: function () {
        return this._built;
      },
      set: function (e) {
        this._built = e;
      }
    }, {
      key: "trainable",
      get: function () {
        return this.trainable_;
      },
      set: function (e) {
        this._trainableWeights.forEach(function (t) {
          return t.trainable = e;
        });
        this.trainable_ = e;
      }
    }, {
      key: "trainableWeights",
      get: function () {
        if (this.trainable_) {
          return this._trainableWeights.filter(function (e) {
            return e.trainable;
          });
        } else {
          return [];
        }
      },
      set: function (e) {
        this._trainableWeights = e;
      }
    }, {
      key: "nonTrainableWeights",
      get: function () {
        if (this.trainable) {
          return this._trainableWeights.filter(function (e) {
            return !e.trainable;
          }).concat(this._nonTrainableWeights);
        } else {
          return this._trainableWeights.concat(this._nonTrainableWeights);
        }
      },
      set: function (e) {
        this._nonTrainableWeights = e;
      }
    }, {
      key: "weights",
      get: function () {
        return this.trainableWeights.concat(this.nonTrainableWeights);
      }
    }, {
      key: "stateful",
      get: function () {
        return this._stateful;
      }
    }, {
      key: "resetStates",
      value: function () {
        if (!this.stateful) {
          throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
        }
      }
    }, {
      key: "assertInputCompatibility",
      value: function (e) {
        var t = Lse(e);
        if (this.inputSpec != null && this.inputSpec.length !== 0) {
          var n = Lse(this.inputSpec);
          if (t.length !== n.length) {
            throw new Cse(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);
          }
          for (var r = 0; r < t.length; r++) {
            var a = t[r];
            var i = n[r];
            if (i != null) {
              var o = a.rank;
              if (i.ndim != null && o !== i.ndim) {
                throw new Cse(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);
              }
              if (i.maxNDim != null && o > i.maxNDim) {
                throw new Cse(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);
              }
              if (i.minNDim != null && o < i.minNDim) {
                throw new Cse(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);
              }
              if (i.dtype != null && a.dtype !== i.dtype) {
                throw new Cse(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);
              }
              if (i.axes) {
                var s = a.shape;
                for (var u in i.axes) {
                  var c = Number(u);
                  var l = i.axes[u];
                  var h = c >= 0 ? s[c] : s[s.length + c];
                  if (l != null && [l, null].indexOf(h) === -1) {
                    throw new Cse(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${l} but got shape ${s}.`);
                  }
                }
              }
              if (i.shape != null) {
                for (var p = 0; p < i.shape.length; ++p) {
                  var f = i.shape[p];
                  var d = a.shape[p];
                  if (f != null && d != null && f !== d) {
                    throw new Cse(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`);
                  }
                }
              }
            }
          }
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        return e;
      }
    }, {
      key: "invokeCallHook",
      value: function (e, t) {
        if (this._callHook != null) {
          this._callHook(e, t);
        }
      }
    }, {
      key: "setCallHook",
      value: function (e) {
        this._callHook = e;
      }
    }, {
      key: "clearCallHook",
      value: function () {
        this._callHook = null;
      }
    }, {
      key: "apply",
      value: function (e, t) {
        var n = this;
        t = t || {};
        this.assertNotDisposed();
        var r = Lse(e);
        var a = function (e) {
          var t;
          var n = true;
          var r = O(Lse(e));
          try {
            for (r.s(); !(t = r.n()).done;) {
              if (!(t.value instanceof yce)) {
                n = false;
                break;
              }
            }
          } catch (e) {
            r.e(e);
          } finally {
            r.f();
          }
          return n;
        }(e);
        var i = function (e) {
          var t;
          var n = true;
          var r = O(Lse(e));
          try {
            for (r.s(); !(t = r.n()).done;) {
              if (t.value instanceof yce) {
                n = false;
                break;
              }
            }
          } catch (e) {
            r.e(e);
          } finally {
            r.f();
          }
          return n;
        }(e);
        if (a === i) {
          throw new Cse("Arguments to apply() must be all SymbolicTensors or all Tensors");
        }
        return hue(this.name, function () {
          if (!n.built) {
            n.assertInputCompatibility(e);
            var a;
            var o = [];
            var s = O(Lse(e));
            try {
              for (s.s(); !(a = s.n()).done;) {
                var u = a.value;
                o.push(u.shape);
              }
            } catch (e) {
              s.e(e);
            } finally {
              s.f();
            }
            n.build(Mse(o));
            n.built = true;
            if (n.initialWeights) {
              n.setWeights(n.initialWeights);
            }
            if (n._refCount === null && i) {
              n._refCount = 1;
            }
          }
          n.assertInputCompatibility(e);
          if (i) {
            var c = n.call(e, t);
            if (n.supportsMasking) {
              n.setMaskMetadata(e, c);
            }
            var l;
            var h = [];
            var p = O(Lse(c));
            try {
              for (p.s(); !(l = p.n()).done;) {
                var f = l.value;
                if (r.indexOf(f) !== -1) {
                  f = f.clone();
                }
                h.push(f);
              }
            } catch (e) {
              p.e(e);
            } finally {
              p.f();
            }
            c = Mse(h);
            if (n.activityRegularizer != null) {
              throw new Ase("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
            }
            return c;
          }
          var d;
          var v = function (e) {
            e = Lse(e);
            var t;
            var n = [];
            var r = O(e);
            try {
              for (r.s(); !(t = r.n()).done;) {
                var a = t.value;
                n.push(a.shape);
              }
            } catch (e) {
              r.e(e);
            } finally {
              r.f();
            }
            return Mse(n);
          }(e);
          var m = n.computeOutputShape(v);
          var g = "float32";
          n.warnOnIncompatibleInputShape(Array.isArray(e) ? v[0] : v);
          d = m != null && m.length > 0 && Array.isArray(m[0]) ? m.map(function (r, a) {
            return new yce(g, r, n, Lse(e), t, n.name, a);
          }) : new yce(g, m, n, Lse(e), t, n.name);
          n.addInboundNode(e, d, null, null, v, m, t);
          n._refCount++;
          if (n.activityRegularizer != null) {
            throw new Ase("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          }
          return d;
        });
      }
    }, {
      key: "warnOnIncompatibleInputShape",
      value: function (e) {
        if (this.batchInputShape != null) {
          if (e.length !== this.batchInputShape.length) {
            console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
          } else {
            var t = false;
            this.batchInputShape.forEach(function (n, r) {
              if (n != null && e[r] != null && e[r] !== n) {
                t = true;
              }
            });
            if (t) {
              console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
            }
          }
        }
      }
    }, {
      key: "outputShape",
      get: function () {
        if (this.inboundNodes == null || this.inboundNodes.length === 0) {
          throw new Tse(`The layer ${this.name} has never been called and thus has no defined output shape.`);
        }
        var e;
        var t = [];
        var n = O(this.inboundNodes);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            var a = JSON.stringify(r.outputShapes);
            if (t.indexOf(a) === -1) {
              t.push(a);
            }
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        if (t.length === 1) {
          var i = this.inboundNodes[0].outputShapes;
          if (Array.isArray(i) && Array.isArray(i[0]) && i.length === 1) {
            return i[0];
          } else {
            return i;
          }
        }
        throw new Tse(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
      }
    }, {
      key: "countParams",
      value: function () {
        if (!this.built) {
          throw new Ese(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
        }
        return pce(this.weights);
      }
    }, {
      key: "build",
      value: function (e) {
        this.built = true;
      }
    }, {
      key: "getWeights",
      value: function (e = false) {
        return vce(e ? this.trainableWeights : this.weights);
      }
    }, {
      key: "setWeights",
      value: function (e) {
        var t = this;
        X5(function () {
          var n = t.weights;
          if (n.length !== e.length) {
            throw new Cse(`You called setWeights(weights) on layer "${t.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);
          }
          if (n.length !== 0) {
            var r = [];
            for (var a = vce(n), i = 0; i < a.length; ++i) {
              var o = a[i];
              var s = n[i];
              var u = e[i];
              if (!P$(o.shape, u.shape)) {
                throw new Cse(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);
              }
              r.push([s, u]);
            }
            mce(r);
          }
        });
      }
    }, {
      key: "addWeight",
      value: function (e, t, n, r, a, i, o, s) {
        if (this._addedWeightNames.indexOf(e) !== -1) {
          throw new Cse(`Duplicate weight name ${e} for layer ${this.name}`);
        }
        this._addedWeightNames.push(e);
        if (n == null) {
          n = "float32";
        }
        if (this.fastWeightInitDuringBuild) {
          r = s != null ? s() : sce("zeros");
        }
        var u = r.apply(t, n);
        var c = new dce(u, n, e, i, o);
        u.dispose();
        if (a != null) {
          this.addLoss(function () {
            return a.apply(c.read());
          });
        }
        if (i == null) {
          i = true;
        }
        if (i) {
          this._trainableWeights.push(c);
        } else {
          this._nonTrainableWeights.push(c);
        }
        return c;
      }
    }, {
      key: "setFastWeightInitDuringBuild",
      value: function (e) {
        this.fastWeightInitDuringBuild = e;
      }
    }, {
      key: "addLoss",
      value: function (e) {
        var t;
        if (e != null && (!Array.isArray(e) || e.length !== 0)) {
          e = Lse(e);
          if (this._losses !== undefined && this._losses !== null) {
            (t = this.losses).push.apply(t, T(e));
          }
        }
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        var n = this;
        if (!this.supportsMasking) {
          if (t != null) {
            if (!Array.isArray(t)) {
              throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
            }
            t.forEach(function (e) {
              if (e != null) {
                throw new TypeError(`Layer ${n.name} does not support masking, but was passed an inputMask.`);
              }
            });
          }
          return null;
        }
        return t;
      }
    }, {
      key: "setMaskMetadata",
      value: function (e, t, n) {
        if (this.supportsMasking) {
          var r = this.computeMask(e, n);
          var a = Lse(t);
          var i = Lse(r);
          if (a.length !== i.length) {
            throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);
          }
          for (var o = 0; o < a.length; o++) {
            a[o].kerasMask = i[o];
          }
        }
      }
    }, {
      key: "addInboundNode",
      value: function (e, t, n, r, a, i, o = null) {
        var s = Lse(e);
        t = Lse(t);
        n = Lse(n);
        r = Lse(r);
        a = cce(a);
        i = cce(i);
        var u;
        var c = [];
        var l = [];
        var h = [];
        var p = O(s);
        try {
          for (p.s(); !(u = p.n()).done;) {
            var f = u.value;
            c.push(f.sourceLayer);
            l.push(f.nodeIndex);
            h.push(f.tensorIndex);
          }
        } catch (e) {
          p.e(e);
        } finally {
          p.f();
        }
        new xce({
          outboundLayer: this,
          inboundLayers: c,
          nodeIndices: l,
          tensorIndices: h,
          inputTensors: s,
          outputTensors: t,
          inputMasks: n,
          outputMasks: r,
          inputShapes: a,
          outputShapes: i
        }, o);
        for (var d = 0; d < t.length; d++) {
          t[d].sourceLayer = this;
          t[d].nodeIndex = this.inboundNodes.length - 1;
          t[d].tensorIndex = d;
        }
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          name: this.name,
          trainable: this.trainable
        };
        if (this.batchInputShape != null) {
          e.batchInputShape = this.batchInputShape;
        }
        if (this.dtype != null) {
          e.dtype = this.dtype;
        }
        return e;
      }
    }, {
      key: "disposeWeights",
      value: function () {
        this.weights.forEach(function (e) {
          return e.dispose();
        });
        return this.weights.length;
      }
    }, {
      key: "assertNotDisposed",
      value: function () {
        if (this._refCount === 0) {
          throw new Error(`Layer '${this.name}' is already disposed.`);
        }
      }
    }, {
      key: "dispose",
      value: function () {
        if (!this.built) {
          throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
        }
        if (this._refCount === null) {
          throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
        }
        this.assertNotDisposed();
        var e = 0;
        if (--this._refCount == 0) {
          e = this.disposeWeights();
        }
        return {
          refCountAfterDispose: this._refCount,
          numDisposedVariables: e
        };
      }
    }], [{
      key: "nodeKey",
      value: function (e, t) {
        return e.name + "_ib-" + t.toString();
      }
    }]);
    return n;
  }(Hre);
  function Ice(e, t, n) {
    if (t == null || n != null && n > 0) {
      t = e.sourceLayer;
      n = e.nodeIndex;
    }
    if (t.inboundNodes.length === 0) {
      return [e];
    }
    var r = t.inboundNodes[n];
    if (r.inboundLayers.length === 0) {
      return r.inputTensors;
    }
    var a = [];
    for (var i = 0; i < r.inboundLayers.length; i++) {
      var o;
      var s = O(Ice(r.inputTensors[i], r.inboundLayers[i], r.nodeIndices[i]));
      try {
        for (s.s(); !(o = s.n()).done;) {
          var u = o.value;
          if (a.indexOf(u) === -1) {
            a.push(u);
          }
        }
      } catch (e) {
        s.e(e);
      } finally {
        s.f();
      }
    }
    return a;
  }
  var Nce = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, {
        dtype: e.dtype,
        name: e.name ?? eue("input").toString()
      });
      if (e.batchSize == null) {
        e.batchSize = null;
      }
      if (e.sparse == null) {
        e.sparse = false;
      }
      r.trainable = false;
      r.built = true;
      r.sparse = e.sparse;
      if (e.inputShape != null && e.batchInputShape != null) {
        throw new Cse("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      }
      var a = e.batchInputShape;
      if (a == null) {
        if (e.inputShape == null) {
          throw new Cse("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
        }
        a = [e.batchSize].concat(e.inputShape);
      } else if (e.batchSize != null) {
        throw new Cse("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      }
      var i = e.dtype || "float32";
      r.batchInputShape = a;
      r.dtype = i;
      r.inputSpec = [{
        shape: a
      }];
      var o = new yce(r.dtype, r.batchInputShape, x(r), [], {}, r.name);
      o.nodeIndex = 0;
      o.tensorIndex = 0;
      new xce({
        outboundLayer: x(r),
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: [o],
        outputTensors: [o],
        inputMasks: [null],
        outputMasks: [null],
        inputShapes: [a],
        outputShapes: [a]
      });
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e, t) {
        throw new Cse(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
      }
    }, {
      key: "dispose",
      value: function () {
        return {
          refCountAfterDispose: this._refCount,
          numDisposedVariables: 0
        };
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          batchInputShape: this.batchInputShape,
          dtype: this.dtype,
          sparse: this.sparse,
          name: this.name
        };
      }
    }]);
    return n;
  }(wce);
  function Sce(e) {
    if (e.batchShape == null && e.shape == null) {
      throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    }
    if (e.batchShape != null && e.shape != null) {
      throw new Cse("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    }
    var t = e.batchShape;
    if (e.shape != null && t == null) {
      t = [null].concat(e.shape);
    }
    var n = e.dtype;
    if (n == null) {
      n = "float32";
    }
    return new Nce({
      batchInputShape: t,
      name: e.name,
      dtype: n,
      sparse: e.sparse
    }).inboundNodes[0].outputTensors[0];
  }
  Nce.className = "InputLayer";
  Kre(Nce);
  var Tce = function () {
    function e(t) {
      l(this, e);
      this.id2Value = {};
      this.id2Mask = {};
      this.name2Id = {};
      if (t instanceof e) {
        for (var n in t.id2Value) {
          this.id2Value[n] = t.id2Value[n];
          if (n in t.id2Mask) {
            this.id2Mask[n] = t.id2Mask[n];
          }
        }
      } else {
        if (t == null) {
          return;
        }
        var r;
        var a = O(t);
        try {
          for (a.s(); !(r = a.n()).done;) {
            var i = r.value;
            this.add(i.key, i.value);
          }
        } catch (e) {
          a.e(e);
        } finally {
          a.f();
        }
      }
    }
    p(e, [{
      key: "add",
      value: function (e, t, n) {
        if (this.id2Value[e.id] != null) {
          throw new Cse(`Duplicate key: name=${e.name}, id=${e.id}`);
        }
        this.id2Value[e.id] = function (e, t) {
          if (e.dtype == null || e.dtype === t.dtype) {
            return t;
          }
          try {
            return h8(t, e.dtype);
          } catch (n) {
            throw new Cse(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`);
          }
        }(e, t);
        this.name2Id[e.name] = e.id;
        if (n != null) {
          this.id2Mask[e.id] = n;
        }
        return this;
      }
    }, {
      key: "addFeed",
      value: function (e) {
        this.add(e.key, e.value);
      }
    }, {
      key: "hasKey",
      value: function (e) {
        return this.id2Value[e.id] != null;
      }
    }, {
      key: "names",
      value: function () {
        return Object.keys(this.name2Id);
      }
    }, {
      key: "getValue",
      value: function (e) {
        if (e instanceof yce) {
          if (this.id2Value[e.id] == null) {
            throw new Cse(`Nonexistent key: ${e.name}`);
          }
          return this.id2Value[e.id];
        }
        var t = this.name2Id[e];
        if (t == null) {
          throw new Cse(`Feed dict has no SymbolicTensor name: ${e}`);
        }
        return this.id2Value[t];
      }
    }, {
      key: "getMask",
      value: function (e) {
        if (e instanceof yce) {
          if (this.id2Value[e.id] == null) {
            throw new Cse(`Nonexistent key: ${e.name}`);
          }
          return this.id2Mask[e.id];
        }
        var t = this.name2Id[e];
        if (t == null) {
          throw new Cse(`Feed dict has no SymbolicTensor name: ${e}`);
        }
        return this.id2Mask[t];
      }
    }, {
      key: "disposeMasks",
      value: function () {
        if (this.id2Mask != null) {
          Y5(this.id2Mask);
        }
      }
    }]);
    return e;
  }();
  var Ece = new _se();
  var Cce = new _se();
  function Ace(e, t, n, r) {
    var a;
    var i = n != null && n.training;
    var o = Array.isArray(e);
    var s = o ? e : [e];
    var u = s.map(function (e) {
      return e.name;
    });
    var c = [];
    var l = t.names();
    var h = O(u);
    try {
      for (h.s(); !(a = h.n()).done;) {
        var p = a.value;
        if (l.indexOf(p) !== -1) {
          c.push(t.getValue(p));
        } else {
          c.push(null);
        }
      }
    } catch (e) {
      h.e(e);
    } finally {
      h.f();
    }
    if (r != null) {
      r.maxNumTensors = -Infinity;
      r.minNumTensors = Infinity;
    }
    var f;
    var d = u.join(",") + "|" + t.names().sort().join(",");
    var v = Ece.get(d);
    if (v == null) {
      var m = function (e, t) {
        F$(e != null && e.length > 0, function () {
          return "Expected at least one fetch, got none";
        });
        var n = [];
        var r = {};
        if (e.length === 1) {
          var a = _ce(e[0], t);
          n = a.sorted;
          r = a.recipientMap;
        } else {
          var i;
          var o = new Set();
          var s = O(e);
          try {
            for (s.s(); !(i = s.n()).done;) {
              var u;
              var c = _ce(i.value, t);
              var l = c.sorted;
              var h = c.recipientMap;
              var p = O(l);
              try {
                for (p.s(); !(u = p.n()).done;) {
                  var f = u.value;
                  if (!o.has(f.name)) {
                    n.push(f);
                    o.add(f.name);
                  }
                }
              } catch (e) {
                p.e(e);
              } finally {
                p.f();
              }
              function d(e) {
                if (r[e] == null) {
                  r[e] = new Set();
                }
                h[e].forEach(function (t) {
                  return r[e].add(t);
                });
              }
              for (var v in h) {
                d(v);
              }
            }
          } catch (e) {
            s.e(e);
          } finally {
            s.f();
          }
        }
        return {
          sorted: n,
          recipientCounts: Rce(r)
        };
      }(s, t);
      v = m.sorted;
      f = m.recipientCounts;
      Ece.put(d, v);
      Cce.put(d, f);
    }
    f = {};
    if (!i) {
      Object.assign(f, Cce.get(d));
    }
    var g = new Tce(t);
    for (var y = 0; y < v.length; ++y) {
      if (r != null) {
        var b = K5().numTensors;
        if (b > r.maxNumTensors) {
          r.maxNumTensors = b;
        }
        if (b < r.minNumTensors) {
          r.minNumTensors = b;
        }
      }
      var x = v[y];
      var k = x.sourceLayer;
      if (!(k instanceof Nce)) {
        var w;
        var I = [];
        var N = [];
        var S = [];
        var T = false;
        var E = O(x.inputs);
        try {
          for (E.s(); !(w = E.n()).done;) {
            var C = w.value;
            var A = g.getValue(C);
            var R = g.getMask(C);
            I.push(A);
            N.push(R);
            if (R != null) {
              T = true;
            }
            if (!i) {
              f[C.name]--;
              if (f[C.name] === 0 && !t.hasKey(C) && u.indexOf(C.name) === -1 && !A.isDisposed && C.sourceLayer.stateful !== true) {
                S.push(A);
              }
            }
          }
        } catch (e) {
          E.e(e);
        } finally {
          E.f();
        }
        if (T) {
          (n = n || {}).mask = N[0];
        }
        var _ = Lse(k.apply(I, n));
        var F = null;
        if (k.supportsMasking) {
          F = k.computeMask(I, N);
        }
        var D = Oce(x);
        for (var M = Array.isArray(D) ? D : [D], L = 0; L < M.length; ++L) {
          if (!g.hasKey(M[L])) {
            g.add(M[L], _[L], Array.isArray(F) ? F[0] : F);
          }
          var z = u.indexOf(M[L].name);
          if (z !== -1) {
            c[z] = _[L];
          }
        }
        if (!i) {
          Y5(S);
        }
      }
    }
    g.disposeMasks();
    if (o) {
      return c;
    } else {
      return c[0];
    }
  }
  function Rce(e) {
    var t = {};
    for (var n in e) {
      t[n] = e[n].size;
    }
    return t;
  }
  function _ce(e, t) {
    var n;
    var r = new Set();
    var a = [];
    var i = {};
    var o = O(t.names());
    try {
      for (o.s(); !(n = o.n()).done;) {
        var s = n.value;
        r.add(s);
      }
    } catch (e) {
      o.e(e);
    } finally {
      o.f();
    }
    var u = [];
    var c = [];
    for (u.push(e); u.length > 0;) {
      var l = u[u.length - 1];
      if (r.has(l.name)) {
        u.pop();
      } else {
        var h = c[c.length - 1] === u.length - 1;
        if (l.inputs.length === 0 || h) {
          u.pop();
          a.push(l);
          r.add(l.name);
          if (h) {
            c.pop();
          }
        } else {
          c.push(u.length - 1);
          var p;
          var f = O(l.inputs);
          try {
            for (f.s(); !(p = f.n()).done;) {
              var d = p.value;
              if (i[d.name] == null) {
                i[d.name] = new Set();
              }
              i[d.name].add(l.name);
              if (!r.has(d.name)) {
                u.push(d);
              }
            }
          } catch (e) {
            f.e(e);
          } finally {
            f.f();
          }
        }
      }
    }
    return {
      sorted: a,
      recipientMap: i
    };
  }
  function Oce(e) {
    var t;
    if (e.sourceLayer.inboundNodes.length === 1) {
      t = e.sourceLayer.output;
    } else {
      var n = null;
      for (var r = 0; r < e.sourceLayer.inboundNodes.length; ++r) {
        var a;
        var i = O(e.sourceLayer.inboundNodes[r].outputTensors);
        try {
          for (i.s(); !(a = i.n()).done;) {
            if (a.value.id === e.id) {
              n = r;
              break;
            }
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
      }
      t = e.sourceLayer.getOutputAt(n);
    }
    return t;
  }
  function Fce(e, t) {
    return X5(function () {
      return o9(u9(g8(e, e), t, true));
    });
  }
  k0().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", function () {
    return 100;
  }, function (e) {
    if (Ece != null) {
      Ece.setMaxEntries(e);
    }
    if (Cce != null) {
      Cce.setMaxEntries(e);
    }
  });
  var Dce = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        return {};
      }
    }]);
    return n;
  }(Hre);
  var Mce = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).defaultMaxValue = 2;
      r.defaultAxis = 0;
      r.maxValue = e.maxValue ?? r.defaultMaxValue;
      r.axis = e.axis ?? r.defaultAxis;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        var t = this;
        return X5(function () {
          var n = Fce(e, t.axis);
          var r = d7(n, 0, t.maxValue);
          return g8(e, m8(r, d8(kue(), n)));
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          maxValue: this.maxValue,
          axis: this.axis
        };
      }
    }]);
    return n;
  }(Dce);
  Mce.className = "MaxNorm";
  Kre(Mce);
  var Lce = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).defaultAxis = 0;
      r.axis = e.axis ?? r.defaultAxis;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        var t = this;
        return X5(function () {
          return m8(e, d8(kue(), Fce(e, t.axis)));
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          axis: this.axis
        };
      }
    }]);
    return n;
  }(Dce);
  Lce.className = "UnitNorm";
  Kre(Lce);
  var zce = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return lte(e);
      }
    }]);
    return n;
  }(Dce);
  zce.className = "NonNeg";
  Kre(zce);
  var Pce = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this)).defaultMinValue = 0;
      r.defaultMaxValue = 1;
      r.defaultRate = 1;
      r.defaultAxis = 0;
      r.minValue = e.minValue ?? r.defaultMinValue;
      r.maxValue = e.maxValue ?? r.defaultMaxValue;
      r.rate = e.rate ?? r.defaultRate;
      r.axis = e.axis ?? r.defaultAxis;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        var t = this;
        return X5(function () {
          var n = Fce(e, t.axis);
          var r = d8(g8(t.rate, d7(n, t.minValue, t.maxValue)), g8(1 - t.rate, n));
          return g8(e, m8(r, d8(kue(), n)));
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          minValue: this.minValue,
          maxValue: this.maxValue,
          rate: this.rate,
          axis: this.axis
        };
      }
    }]);
    return n;
  }(Dce);
  Pce.className = "MinMaxNorm";
  Kre(Pce);
  var Bce = {
    maxNorm: "MaxNorm",
    minMaxNorm: "MinMaxNorm",
    nonNeg: "NonNeg",
    unitNorm: "UnitNorm"
  };
  function Wce(e) {
    return Wse(e);
  }
  function Uce(e, t = {}) {
    return Vse(e, qre.getMap().classNameMap, t, "constraint");
  }
  function Vce(e) {
    if (e == null) {
      return null;
    } else if (typeof e == "string") {
      return Uce({
        className: e in Bce ? Bce[e] : e,
        config: {}
      });
    } else if (e instanceof Dce) {
      return e;
    } else {
      return Uce(e);
    }
  }
  var Gce = {
    __proto__: null,
    maxNorm: function (e) {
      return new Mce(e);
    },
    minMaxNorm: function (e) {
      return new Pce(e);
    },
    nonNeg: function () {
      return new zce();
    },
    unitNorm: function (e) {
      return new Lce(e);
    }
  };
  var jce;
  var Hce = {
    __proto__: null,
    constant: function (e) {
      return new Hue(e);
    },
    glorotNormal: function (e) {
      return new Que(e);
    },
    glorotUniform: function (e) {
      return new Zue(e);
    },
    heNormal: function (e) {
      return new $ue(e);
    },
    heUniform: function (e) {
      return new ece(e);
    },
    identity: function (e) {
      return new Yue(e);
    },
    leCunNormal: function (e) {
      return new tce(e);
    },
    leCunUniform: function (e) {
      return new nce(e);
    },
    ones: function () {
      return new jue();
    },
    orthogonal: function (e) {
      return new rce(e);
    },
    randomNormal: function (e) {
      return new Kue(e);
    },
    randomUniform: function (e) {
      return new que(e);
    },
    truncatedNormal: function (e) {
      return new Xue(e);
    },
    varianceScaling: function (e) {
      return new Jue(e);
    },
    zeros: function () {
      return new Gue();
    }
  };
  function qce(e) {
    return Kce.apply(this, arguments);
  }
  function Kce() {
    Kce = c(o().mark(function e(t) {
      var n;
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              if (t != null) {
                e.next = 2;
                break;
              }
              return e.abrupt("return");
            case 2:
              n = [];
              r = [];
              a = [];
              for (i in t) {
                if (typeof (s = t[i]) != "number") {
                  u = s;
                  n.push(u.data());
                  r.push(i);
                  a.push(u);
                }
              }
              if (!(n.length > 0)) {
                e.next = 12;
                break;
              }
              e.next = 9;
              return Promise.all(n);
            case 9:
              c = e.sent;
              l = 0;
              for (; l < c.length; ++l) {
                t[r[l]] = c[l][0];
              }
              Y5(a);
            case 12:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return Kce.apply(this, arguments);
  }
  function Xce(e) {
    if (e != null) {
      for (var t in e) {
        var n = e[t];
        if (typeof n != "number") {
          n.dispose();
        }
      }
    }
  }
  (function (e) {
    e[e.SILENT = 0] = "SILENT";
    e[e.VERBOSE = 1] = "VERBOSE";
  })(jce ||= {});
  var Yce = function () {
    function e() {
      l(this, e);
      this.validationData = null;
    }
    var t;
    var n;
    var r;
    var a;
    var i;
    var s;
    p(e, [{
      key: "setParams",
      value: function (e) {
        this.params = e;
      }
    }, {
      key: "onEpochBegin",
      value: (s = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e, t) {
        return s.apply(this, arguments);
      })
    }, {
      key: "onEpochEnd",
      value: (i = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e, t) {
        return i.apply(this, arguments);
      })
    }, {
      key: "onBatchBegin",
      value: (a = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e, t) {
        return a.apply(this, arguments);
      })
    }, {
      key: "onBatchEnd",
      value: (r = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e, t) {
        return r.apply(this, arguments);
      })
    }, {
      key: "onTrainBegin",
      value: (n = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "onTrainEnd",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "setModel",
      value: function (e) {}
    }]);
    return e;
  }();
  var Jce = function () {
    function e(t, n = 10) {
      l(this, e);
      if (t == null) {
        t = [];
      }
      this.callbacks = t;
      this.queueLength = n;
    }
    var t;
    var n;
    var r;
    var a;
    var i;
    var s;
    p(e, [{
      key: "append",
      value: function (e) {
        this.callbacks.push(e);
      }
    }, {
      key: "setParams",
      value: function (e) {
        var t;
        var n = O(this.callbacks);
        try {
          for (n.s(); !(t = n.n()).done;) {
            t.value.setParams(e);
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
      }
    }, {
      key: "setModel",
      value: function (e) {
        var t;
        var n = O(this.callbacks);
        try {
          for (n.s(); !(t = n.n()).done;) {
            t.value.setModel(e);
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
      }
    }, {
      key: "onEpochBegin",
      value: (s = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (n == null) {
                  n = {};
                }
                r = O(this.callbacks);
                e.prev = 2;
                r.s();
              case 4:
                if ((a = r.n()).done) {
                  e.next = 10;
                  break;
                }
                i = a.value;
                e.next = 8;
                return i.onEpochBegin(t, n);
              case 8:
                e.next = 4;
                break;
              case 10:
                e.next = 15;
                break;
              case 12:
                e.prev = 12;
                e.t0 = e.catch(2);
                r.e(e.t0);
              case 15:
                e.prev = 15;
                r.f();
                return e.finish(15);
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 12, 15, 18]]);
      })), function (e, t) {
        return s.apply(this, arguments);
      })
    }, {
      key: "onEpochEnd",
      value: (i = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (n == null) {
                  n = {};
                }
                r = O(this.callbacks);
                e.prev = 2;
                r.s();
              case 4:
                if ((a = r.n()).done) {
                  e.next = 10;
                  break;
                }
                i = a.value;
                e.next = 8;
                return i.onEpochEnd(t, n);
              case 8:
                e.next = 4;
                break;
              case 10:
                e.next = 15;
                break;
              case 12:
                e.prev = 12;
                e.t0 = e.catch(2);
                r.e(e.t0);
              case 15:
                e.prev = 15;
                r.f();
                return e.finish(15);
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 12, 15, 18]]);
      })), function (e, t) {
        return i.apply(this, arguments);
      })
    }, {
      key: "onBatchBegin",
      value: (a = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (n == null) {
                  n = {};
                }
                r = O(this.callbacks);
                e.prev = 2;
                r.s();
              case 4:
                if ((a = r.n()).done) {
                  e.next = 10;
                  break;
                }
                i = a.value;
                e.next = 8;
                return i.onBatchBegin(t, n);
              case 8:
                e.next = 4;
                break;
              case 10:
                e.next = 15;
                break;
              case 12:
                e.prev = 12;
                e.t0 = e.catch(2);
                r.e(e.t0);
              case 15:
                e.prev = 15;
                r.f();
                return e.finish(15);
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 12, 15, 18]]);
      })), function (e, t) {
        return a.apply(this, arguments);
      })
    }, {
      key: "onBatchEnd",
      value: (r = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (n == null) {
                  n = {};
                }
                r = O(this.callbacks);
                e.prev = 2;
                r.s();
              case 4:
                if ((a = r.n()).done) {
                  e.next = 10;
                  break;
                }
                i = a.value;
                e.next = 8;
                return i.onBatchEnd(t, n);
              case 8:
                e.next = 4;
                break;
              case 10:
                e.next = 15;
                break;
              case 12:
                e.prev = 12;
                e.t0 = e.catch(2);
                r.e(e.t0);
              case 15:
                e.prev = 15;
                r.f();
                return e.finish(15);
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 12, 15, 18]]);
      })), function (e, t) {
        return r.apply(this, arguments);
      })
    }, {
      key: "onTrainBegin",
      value: (n = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (t == null) {
                  t = {};
                }
                n = O(this.callbacks);
                e.prev = 2;
                n.s();
              case 4:
                if ((r = n.n()).done) {
                  e.next = 10;
                  break;
                }
                a = r.value;
                e.next = 8;
                return a.onTrainBegin(t);
              case 8:
                e.next = 4;
                break;
              case 10:
                e.next = 15;
                break;
              case 12:
                e.prev = 12;
                e.t0 = e.catch(2);
                n.e(e.t0);
              case 15:
                e.prev = 15;
                n.f();
                return e.finish(15);
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 12, 15, 18]]);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "onTrainEnd",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (t == null) {
                  t = {};
                }
                n = O(this.callbacks);
                e.prev = 2;
                n.s();
              case 4:
                if ((r = n.n()).done) {
                  e.next = 10;
                  break;
                }
                a = r.value;
                e.next = 8;
                return a.onTrainEnd(t);
              case 8:
                e.next = 4;
                break;
              case 10:
                e.next = 15;
                break;
              case 12:
                e.prev = 12;
                e.t0 = e.catch(2);
                n.e(e.t0);
              case 15:
                e.prev = 15;
                n.f();
                return e.finish(15);
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 12, 15, 18]]);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }]);
    return e;
  }();
  var Zce = function (e) {
    d(i, e);
    var t;
    var n;
    var r;
    var a = w(i);
    function i() {
      l(this, i);
      return a.call(this);
    }
    p(i, [{
      key: "onEpochBegin",
      value: (r = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.seen = 0;
                this.totals = {};
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return r.apply(this, arguments);
      })
    }, {
      key: "onBatchEnd",
      value: (n = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        var s = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (n == null) {
                  n = {};
                }
                r = n.size == null ? 0 : n.size;
                this.seen += r;
                a = o().mark(function e(t) {
                  var a;
                  var i;
                  var u;
                  return o().wrap(function (e) {
                    while (true) {
                      switch (e.prev = e.next) {
                        case 0:
                          if (typeof (a = n[t]) == "number") {
                            if (!s.totals.hasOwnProperty(t)) {
                              s.totals[t] = 0;
                            }
                            s.totals[t] = s.totals[t] + a * r;
                          } else {
                            if (t in s.totals) {
                              i = s.totals[t];
                            } else {
                              s.totals[t] = 0;
                            }
                            u = X5(function () {
                              return d8(s.totals[t], g8(a, r));
                            });
                            s.totals[t] = u;
                            if (i != null) {
                              i.dispose();
                            }
                          }
                        case 2:
                        case "end":
                          return e.stop();
                      }
                    }
                  }, e);
                });
                e.t0 = o().keys(n);
              case 5:
                if ((e.t1 = e.t0()).done) {
                  e.next = 10;
                  break;
                }
                i = e.t1.value;
                return e.delegateYield(a(i), "t2", 8);
              case 8:
                e.next = 5;
                break;
              case 10:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return n.apply(this, arguments);
      })
    }, {
      key: "onEpochEnd",
      value: (t = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        var s = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (n == null) {
                  e.next = 20;
                  break;
                }
                r = O(this.params.metrics);
                e.prev = 2;
                i = o().mark(function e() {
                  var t;
                  return o().wrap(function (e) {
                    while (true) {
                      switch (e.prev = e.next) {
                        case 0:
                          t = a.value;
                          if (s.totals[t] != null) {
                            e.next = 3;
                            break;
                          }
                          return e.abrupt("return", "continue");
                        case 3:
                          if (typeof s.totals[t] == "number") {
                            n[t] = s.totals[t] / s.seen;
                          } else {
                            X5(function () {
                              var e = g8(m8(1, s.seen), s.totals[t]);
                              n[t] = e;
                              s.totals[t].dispose();
                              J5(n[t]);
                            });
                          }
                        case 4:
                        case "end":
                          return e.stop();
                      }
                    }
                  }, e);
                });
                r.s();
              case 5:
                if ((a = r.n()).done) {
                  e.next = 12;
                  break;
                }
                return e.delegateYield(i(), "t0", 7);
              case 7:
                if (e.t0 !== "continue") {
                  e.next = 10;
                  break;
                }
                return e.abrupt("continue", 10);
              case 10:
                e.next = 5;
                break;
              case 12:
                e.next = 17;
                break;
              case 14:
                e.prev = 14;
                e.t1 = e.catch(2);
                r.e(e.t1);
              case 17:
                e.prev = 17;
                r.f();
                return e.finish(17);
              case 20:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 14, 17, 20]]);
      })), function (e, n) {
        return t.apply(this, arguments);
      })
    }]);
    return i;
  }(Yce);
  var Qce = function (e) {
    d(i, e);
    var t;
    var n;
    var r;
    var a = w(i);
    function i() {
      l(this, i);
      return a.apply(this, arguments);
    }
    p(i, [{
      key: "onTrainBegin",
      value: (r = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.epoch = [];
                this.history = {};
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return r.apply(this, arguments);
      })
    }, {
      key: "onEpochEnd",
      value: (n = c(o().mark(function e(t, n) {
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (n == null) {
                  n = {};
                }
                this.epoch.push(t);
                for (r in n) {
                  if (this.history[r] == null) {
                    this.history[r] = [];
                  }
                  this.history[r].push(n[r]);
                }
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return n.apply(this, arguments);
      })
    }, {
      key: "syncData",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = [];
                n = [];
                r = [];
                for (a in this.history) {
                  i = this.history[a];
                  s = 0;
                  for (; s < i.length; ++s) {
                    if (typeof i[s] != "number") {
                      u = i[s];
                      t.push(u.data());
                      n.push(a);
                      r.push(s);
                    }
                  }
                }
                e.next = 6;
                return Promise.all(t);
              case 6:
                c = e.sent;
                l = 0;
                for (; l < c.length; ++l) {
                  this.history[n[l]][r[l]].dispose();
                  this.history[n[l]][r[l]] = c[l][0];
                }
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return i;
  }(Yce);
  var $ce = function (e) {
    d(f, e);
    var t;
    var n;
    var r;
    var a;
    var i;
    var s;
    var u;
    var h = w(f);
    function f(e, t) {
      var n;
      l(this, f);
      (n = h.call(this)).currentEpoch = 0;
      n.nowFunc = e.nowFunc;
      n.nextFrameFunc = e.nextFrameFunc || aie;
      n.yieldEvery = t || "auto";
      if (n.yieldEvery === "auto") {
        n.yieldEvery = 125;
      }
      if (n.yieldEvery === "never" && e.onYield != null) {
        throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
      }
      if (t0(n.yieldEvery)) {
        n.maybeWait = function (e, t, n) {
          var r;
          var a = n != null ? n() : z4();
          return function () {
            var i = n != null ? n() : z4();
            if (i - a < t) {
              return r;
            } else {
              a = i;
              return r = e.apply(undefined, arguments);
            }
          };
        }(n.maybeWait.bind(x(n)), n.yieldEvery, n.nowFunc);
      }
      n.trainBegin = e.onTrainBegin;
      n.trainEnd = e.onTrainEnd;
      n.epochBegin = e.onEpochBegin;
      n.epochEnd = e.onEpochEnd;
      n.batchBegin = e.onBatchBegin;
      n.batchEnd = e.onBatchEnd;
      n.yield = e.onYield;
      return n;
    }
    p(f, [{
      key: "maybeWait",
      value: (u = c(o().mark(function e(t, n, r) {
        var a;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                a = [];
                if (this.yield == null) {
                  e.next = 5;
                  break;
                }
                e.next = 4;
                return qce(r);
              case 4:
                a.push(this.yield(t, n, r));
              case 5:
                a.push(this.nextFrameFunc());
                e.next = 8;
                return Promise.all(a);
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t, n) {
        return u.apply(this, arguments);
      })
    }, {
      key: "onEpochBegin",
      value: (s = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.currentEpoch = t;
                if (this.epochBegin == null) {
                  e.next = 6;
                  break;
                }
                e.next = 4;
                return qce(n);
              case 4:
                e.next = 6;
                return this.epochBegin(t, n);
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return s.apply(this, arguments);
      })
    }, {
      key: "onEpochEnd",
      value: (i = c(o().mark(function e(t, n) {
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                r = [];
                if (this.epochEnd == null) {
                  e.next = 5;
                  break;
                }
                e.next = 4;
                return qce(n);
              case 4:
                r.push(this.epochEnd(t, n));
              case 5:
                if (this.yieldEvery === "epoch") {
                  r.push(this.nextFrameFunc());
                }
                e.next = 8;
                return Promise.all(r);
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return i.apply(this, arguments);
      })
    }, {
      key: "onBatchBegin",
      value: (a = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.batchBegin == null) {
                  e.next = 5;
                  break;
                }
                e.next = 3;
                return qce(n);
              case 3:
                e.next = 5;
                return this.batchBegin(t, n);
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return a.apply(this, arguments);
      })
    }, {
      key: "onBatchEnd",
      value: (r = c(o().mark(function e(t, n) {
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                r = [];
                if (this.batchEnd == null) {
                  e.next = 5;
                  break;
                }
                e.next = 4;
                return qce(n);
              case 4:
                r.push(this.batchEnd(t, n));
              case 5:
                if (this.yieldEvery === "batch") {
                  r.push(this.nextFrameFunc());
                } else if (t0(this.yieldEvery)) {
                  r.push(this.maybeWait(this.currentEpoch, t, n));
                }
                e.next = 8;
                return Promise.all(r);
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return r.apply(this, arguments);
      })
    }, {
      key: "onTrainBegin",
      value: (n = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.trainBegin == null) {
                  e.next = 5;
                  break;
                }
                e.next = 3;
                return qce(t);
              case 3:
                e.next = 5;
                return this.trainBegin(t);
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "onTrainEnd",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.trainEnd == null) {
                  e.next = 5;
                  break;
                }
                e.next = 3;
                return qce(t);
              case 3:
                e.next = 5;
                return this.trainEnd(t);
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }]);
    return f;
  }(Yce);
  function ele(e, t) {
    if (e == null) {
      e = {};
    }
    if (e instanceof Yce) {
      return [e];
    } else if (Array.isArray(e) && e[0] instanceof Yce) {
      return e;
    } else {
      return Lse(e).map(function (e) {
        return new $ce(e, t);
      });
    }
  }
  var tle = function () {
    function e() {
      l(this, e);
    }
    p(e, null, [{
      key: "registerCallbackConstructor",
      value: function (t, n) {
        F$(t >= 0 && Number.isInteger(t), function () {
          return `Verbosity level is expected to be an integer >= 0, but got ${t}`;
        });
        e.checkForDuplicate(n);
        if (e.constructors[t] == null) {
          e.constructors[t] = [];
        }
        e.constructors[t].push(n);
      }
    }, {
      key: "checkForDuplicate",
      value: function (t) {
        for (var n in e.constructors) {
          e.constructors[+n].forEach(function (e) {
            if (e === t) {
              throw new Cse("Duplicate callback constructor.");
            }
          });
        }
      }
    }, {
      key: "clear",
      value: function () {
        e.constructors = {};
      }
    }, {
      key: "createCallbacks",
      value: function (t) {
        var n = [];
        for (var r in e.constructors) {
          var a = +r;
          if (t >= a) {
            n.push.apply(n, T(e.constructors[a]));
          }
        }
        return n.map(function (e) {
          return new e();
        });
      }
    }]);
    return e;
  }();
  function nle(e, t, n, r, a, i, o, s, u) {
    var c = new Qce();
    var l = [new Zce()].concat(T(tle.createCallbacks(t)));
    if (e != null) {
      l.push.apply(l, T(e));
    }
    l.push(c);
    var h = new Jce(l);
    h.setParams({
      epochs: n,
      initialEpoch: r,
      samples: a,
      steps: i,
      batchSize: o,
      verbose: t,
      doValidation: s,
      metrics: u
    });
    return {
      callbackList: h,
      history: c
    };
  }
  function rle(e, t = {}, n = false) {
    return Vse(e, qre.getMap().classNameMap, t, "layer", n);
  }
  function ale(e, t) {
    return X5(function () {
      if (e.dtype !== "float32") {
        e = h8(e, "float32");
      }
      var n = u9(Due(e), t, true);
      var r = f7(n.shape, kue());
      var a = o9(Z9(n, r));
      return m8(e, a);
    });
  }
  function ile(e, t) {
    return X5(function () {
      return Q9(Due(P9(t, e)), -1);
    });
  }
  function ole(e, t) {
    return X5(function () {
      return Q9(y8(P9(t, e)), -1);
    });
  }
  function sle(e, t) {
    return X5(function () {
      var n = P9(e, t);
      var r = d7(y8(e), kue(), Number.MAX_VALUE);
      var a = y8(m8(n, r));
      return g8(100, Q9(a, -1));
    });
  }
  function ule(e, t) {
    return X5(function () {
      var n = d7(t, kue(), Number.MAX_VALUE);
      var r = R9(d8(1, n));
      var a = d7(e, kue(), Number.MAX_VALUE);
      var i = R9(d8(1, a));
      return Q9(Due(P9(r, i)), -1);
    });
  }
  function cle(e, t, n = false) {
    return X5(function () {
      if (n) {
        t = Rte(t);
      } else {
        var r = u9(t, t.shape.length - 1, true);
        t = m8(t, r);
      }
      t = d7(t, kue(), 1 - kue());
      return M9(u9(g8(h8(e, "float32"), R9(t)), t.shape.length - 1));
    });
  }
  function lle(e, t, n = false) {
    return X5(function () {
      var r = h8(g9(Nue(e)), "int32");
      var a = (t = d7(t, kue(), 1 - kue())).shape;
      return cle(X8(cee(r, a[a.length - 1]), a), t, n);
    });
  }
  function hle(e, t) {
    return X5(function () {
      var n;
      n = d7(t, kue(), 1 - kue());
      n = R9(m8(n, P9(1, n)));
      return Q9(function (e, t) {
        if (!P$(e.shape, t.shape)) {
          throw new Cse(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);
        }
        return X5(function () {
          var n = lte(t);
          var r = M9(y8(t));
          return d8(P9(n, g8(t, e)), _9(p9(r)));
        });
      }(e, n), -1);
    });
  }
  function ple(e, t) {
    return X5(function () {
      var n = d7(e, kue(), 1);
      var r = d7(t, kue(), 1);
      return u9(g8(e, R9(m8(n, r))), -1);
    });
  }
  function fle(e, t) {
    return X5(function () {
      var n = ale(e, -1);
      var r = ale(t, -1);
      var a = g8(n, r);
      return M9(u9(a, -1));
    });
  }
  tle.constructors = {};
  var dle = {
    meanSquaredError: ile,
    meanAbsoluteError: ole,
    meanAbsolutePercentageError: sle,
    meanSquaredLogarithmicError: ule,
    squaredHinge: function (e, t) {
      return X5(function () {
        var n = Z9(0, P9(1, g8(e, t)));
        return Q9(Due(n), -1);
      });
    },
    hinge: function (e, t) {
      return X5(function () {
        var n = Z9(0, P9(1, g8(e, t)));
        return Q9(n, -1);
      });
    },
    categoricalHinge: function (e, t) {
      return X5(function () {
        var n = u9(g8(e, t), -1);
        var r = n9(g8(P9(1, e), t), -1);
        return Z9(0, d8(1, P9(r, n)));
      });
    },
    logcosh: function (e, t) {
      return X5(function () {
        var n = Math.log(2);
        var r = P9(t, e);
        var a = P9(d8(r, L9(g8(-2, r))), n);
        return Q9(a, -1);
      });
    },
    categoricalCrossentropy: cle,
    sparseCategoricalCrossentropy: lle,
    binaryCrossentropy: hle,
    kullbackLeiblerDivergence: ple,
    poisson: function (e, t) {
      return X5(function () {
        var n = R9(d8(kue(), t));
        return Q9(P9(t, g8(e, n)), -1);
      });
    },
    cosineProximity: fle
  };
  function vle(e) {
    if (typeof e == "string") {
      if (e in dle) {
        return dle[e];
      }
      var t = `Unknown loss ${e}`;
      if (e.toLowerCase().includes("softmaxcrossentropy")) {
        t = `Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`;
      }
      throw new Cse(t);
    }
    return e;
  }
  function mle(e, t) {
    return X5(function () {
      var n = g8(0.5, lee(t));
      var r = wue(b9(t, n), e.dtype);
      return Q9(B7(e, r), -1);
    });
  }
  function gle(e, t) {
    return X5(function () {
      return wue(B7(N8(e, -1), N8(t, -1)), "float32");
    });
  }
  function yle(e, t) {
    return X5(function () {
      return h8(u9(U9(B7(e, 1), B7(t, 1))), "float32");
    });
  }
  function ble(e, t) {
    return X5(function () {
      var n = yle(e, t);
      var r = function (e, t) {
        return X5(function () {
          return h8(u9(U9(B7(e, 0), B7(t, 1))), "float32");
        });
      }(e, t);
      var a = d8(n, r);
      return h8(W7(b9(a, 0), m8(n, a), 0), "float32");
    });
  }
  function xle(e, t) {
    return X5(function () {
      var n = yle(e, t);
      var r = function (e, t) {
        return X5(function () {
          return h8(u9(U9(B7(e, 1), B7(t, 0))), "float32");
        });
      }(e, t);
      var a = d8(n, r);
      return h8(W7(b9(a, 0), m8(n, a), 0), "float32");
    });
  }
  function kle(e, t) {
    return hle(e, t);
  }
  function wle(e, t) {
    if (e.rank === t.rank) {
      e = zte(e, [e.rank - 1]);
    }
    if ((t = N8(t, -1)).dtype !== e.dtype) {
      t = h8(t, e.dtype);
    }
    return h8(B7(e, t), "float32");
  }
  var Ile = cle;
  var Nle = lle;
  var Sle = {
    binaryAccuracy: mle,
    categoricalAccuracy: gle,
    precision: ble,
    categoricalCrossentropy: Ile,
    sparseCategoricalCrossentropy: Nle,
    mse: ile,
    MSE: ile,
    mae: ole,
    MAE: ole,
    mape: sle,
    MAPE: sle,
    cosine: fle
  };
  function Tle(e) {
    Fse(e !== null, `Unknown LossOrMetricFn ${e}`);
    if (typeof e == "string") {
      return e;
    }
    var t;
    for (var n = 0, r = Object.keys(dle); n < r.length; n++) {
      var a = r[n];
      if (dle[a] === e) {
        t = a;
        break;
      }
    }
    if (t !== undefined) {
      return t;
    }
    for (var i = 0, o = Object.keys(Sle); i < o.length; i++) {
      var s = o[i];
      if (Sle[s] === e) {
        t = s;
        break;
      }
    }
    if (t !== undefined) {
      return t;
    } else {
      return e.name;
    }
  }
  var Ele = 1048576;
  function Cle(e, t, n = false) {
    if (e == null || s(e) !== "object" || Object.getPrototypeOf(e) !== Object.prototype || !Ale(e)) {
      throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    }
    if (n) {
      var r = JSON.stringify(e);
      if (r.length > Ele) {
        console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Ele}.`);
      }
    }
  }
  function Ale(e) {
    if (e === null) {
      return true;
    }
    if (s(e) === "object") {
      if (Object.getPrototypeOf(e) === Object.prototype) {
        for (var t = 0, n = Object.keys(e); t < n.length; t++) {
          var r = n[t];
          if (typeof r != "string") {
            return false;
          }
          if (!Ale(e[r])) {
            return false;
          }
        }
        return true;
      }
      if (Array.isArray(e)) {
        var a;
        var i = O(e);
        try {
          for (i.s(); !(a = i.n()).done;) {
            if (!Ale(a.value)) {
              return false;
            }
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
        return true;
      }
      return false;
    }
    var o = s(e);
    return o === "string" || o === "number" || o === "boolean";
  }
  function Rle(e, t, n) {
    var r;
    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : console.log;
    var i = Ole(e);
    var o = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
    if (i) {
      t = t || 90;
      n = n || [0.32, 0.61, 0.89, 1];
    } else {
      t = t || 115;
      n = n || [0.24, 0.48, 0.7, 0.8, 1];
    }
    if (n[n.length - 1] <= 1) {
      n = n.map(function (e) {
        return Math.floor(t * e);
      });
    }
    if (!i) {
      o.push("Receives inputs");
      r = [];
      for (var s in e.nodesByDepth) {
        var u;
        (u = r).push.apply(u, T(e.nodesByDepth[s]));
      }
    }
    a("_".repeat(t));
    Fle(o, n, a);
    a("=".repeat(t));
    for (var c = e.layers, l = 0; l < c.length; ++l) {
      if (i) {
        Dle(c[l], n, a);
      } else {
        Mle(c[l], n, r, a);
      }
      a((l === c.length - 1 ? "=" : "_").repeat(t));
    }
    e.checkTrainableWeightsConsistency();
    var h = _le(e);
    var p = pce(e.nonTrainableWeights);
    a(`Total params: ${h + p}`);
    a(`Trainable params: ${h}`);
    a(`Non-trainable params: ${p}`);
    a("_".repeat(t));
  }
  function _le(e) {
    if (e.collectedTrainableWeights != null) {
      return pce(e.collectedTrainableWeights);
    } else {
      return pce(e.trainableWeights);
    }
  }
  function Ole(e) {
    var t = true;
    var n = [];
    var r = [];
    for (var a in e.nodesByDepth) {
      n.push(e.nodesByDepth[a]);
    }
    for (var i = 0, o = n; i < o.length; i++) {
      var s = o[i];
      if (s.length > 1 || s.length === 1 && s[0].inboundLayers.length > 1) {
        t = false;
        break;
      }
      r.push.apply(r, T(s));
    }
    if (t) {
      var u;
      var c = O(e.layers);
      try {
        for (c.s(); !(u = c.n()).done;) {
          var l;
          var h = u.value;
          var p = false;
          var f = O(h.inboundNodes);
          try {
            for (f.s(); !(l = f.n()).done;) {
              var d = l.value;
              if (r.indexOf(d) !== -1) {
                if (p) {
                  t = false;
                  break;
                }
                p = true;
              }
            }
          } catch (e) {
            f.e(e);
          } finally {
            f.f();
          }
          if (!t) {
            break;
          }
        }
      } catch (e) {
        c.e(e);
      } finally {
        c.f();
      }
    }
    return t;
  }
  function Fle(e, t, n = console.log) {
    var r = "";
    for (var a = 0; a < e.length; ++a) {
      if (a > 0) {
        r = r.slice(0, r.length - 1) + " ";
      }
      r = (r += e[a]).slice(0, t[a]);
      r += " ".repeat(t[a] - r.length);
    }
    n(r);
  }
  function Dle(e, t, n) {
    var r;
    var a;
    try {
      a = e.inboundNodes.map(function (e) {
        return JSON.stringify(e.inputShapes);
      }).join(",");
    } catch (e) {
      a = "multiple";
    }
    try {
      r = JSON.stringify(e.outputShape);
    } catch (e) {
      r = "multiple";
    }
    var i = e.name;
    var o = e.getClassName();
    Fle([`${i} (${o})`, a, r, e.countParams().toString()], t, n);
  }
  function Mle(e, t, n, r) {
    var a;
    var i;
    try {
      i = e.inboundNodes.map(function (e) {
        return JSON.stringify(e.inputShapes);
      }).join(",");
    } catch (e) {
      i = "multiple";
    }
    try {
      a = JSON.stringify(e.outputShape);
    } catch (e) {
      a = "multiple";
    }
    var o;
    var s = [];
    var u = O(e.inboundNodes);
    try {
      for (u.s(); !(o = u.n()).done;) {
        var c = o.value;
        if (n == null || !(n.length > 0) || n.indexOf(c) !== -1) {
          for (var l = 0; l < c.inboundLayers.length; ++l) {
            var h = c.inboundLayers[l].name;
            var p = c.nodeIndices[l];
            var f = c.tensorIndices[l];
            s.push(`${h}[${p}][${f}]`);
          }
        }
      }
    } catch (e) {
      u.e(e);
    } finally {
      u.f();
    }
    var d = e.name;
    var v = e.getClassName();
    var m = s.length === 0 ? "" : s[0];
    Fle([`${d} (${v})`, i, a, e.countParams().toString(), m], t, r);
    for (var g = 1; g < s.length; ++g) {
      Fle(["", "", "", "", s[g]], t, r);
    }
  }
  function Lle(e, t, n) {
    return (e === "inboundNodes" || e === "outputLayers" || e === "inputLayers") && t === 0 && typeof n == "string";
  }
  function zle(e, t) {
    if (e === null) {
      return null;
    }
    if (typeof e == "string") {
      return Pse(e);
    }
    if (typeof e == "number" || typeof e == "boolean") {
      return e;
    }
    if (e instanceof Array) {
      var n = [];
      for (var r = e.length, a = 0; a < r; ++a) {
        var i = e[a];
        if (Lle(t, a, i)) {
          n.push(i);
        } else {
          n.push(zle(i, t));
        }
      }
      return n;
    }
    var o = {};
    for (var s = 0, u = Object.keys(e); s < u.length; s++) {
      var c = u[s];
      var l = e[c];
      if (c === "name" && typeof l == "string") {
        o[c] = l;
      } else {
        var h = Pse(c);
        o[h] = zle(l, h);
      }
    }
    return o;
  }
  function Ple(e, t) {
    if (e == null) {
      return null;
    }
    if (typeof e == "string") {
      return zse(e);
    }
    if (typeof e == "number" || typeof e == "boolean") {
      return e;
    }
    if (e instanceof Array) {
      var n = [];
      for (var r = e.length, a = 0; a < r; ++a) {
        var i = e[a];
        if (Lle(t, a, i)) {
          n.push(i);
        } else {
          n.push(Ple(i, t));
        }
      }
      return n;
    }
    var o = {};
    for (var s = 0, u = Object.keys(e); s < u.length; s++) {
      var c = u[s];
      var l = e[c];
      var h = zse(c);
      o[h] = c !== "name" && c !== "className" || typeof l != "string" ? Ple(l, c) : l;
    }
    return o;
  }
  var Ble = "4.15.0";
  function Wle(e) {
    var t = Object.keys(e);
    if (t.length === 0) {
      return false;
    }
    var n = t[0].split("/");
    return !isNaN(parseInt(n[n.length - 1], 10));
  }
  var Ule = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, {})).containerNodes = new Set();
      r.name = e.name;
      if (r.name == null) {
        var a = r.getClassName().toLowerCase();
        r.name = eue(a);
      }
      r.supportsMasking = false;
      r.trainable_ = true;
      if (Array.isArray(e.inputs)) {
        r.inputs = e.inputs.slice();
      } else {
        r.inputs = [e.inputs];
      }
      if (Array.isArray(e.outputs)) {
        r.outputs = e.outputs.slice();
      } else {
        r.outputs = [e.outputs];
      }
      if (jse(r.inputs).length !== r.inputs.length) {
        throw new Cse(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${r.inputs.map(function (e) {
          return e.name;
        })}`);
      }
      if (jse(r.outputs).length !== r.outputs.length) {
        console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${r.outputs.map(function (e) {
          return e.name;
        })}`);
      }
      r.inputLayers = [];
      r.inputLayersNodeIndices = [];
      r.inputLayersTensorIndices = [];
      r.outputLayers = [];
      r.outputLayersNodeIndices = [];
      r.outputLayersTensorIndices = [];
      r.layers = [];
      r.internalContainerRefs = [];
      var i;
      var o = O(r.outputs);
      try {
        for (o.s(); !(i = o.n()).done;) {
          var s = i.value;
          var u = s.sourceLayer;
          var c = s.nodeIndex;
          var h = s.tensorIndex;
          r.outputLayers.push(u);
          r.outputLayersNodeIndices.push(c);
          r.outputLayersTensorIndices.push(h);
        }
      } catch (e) {
        o.e(e);
      } finally {
        o.f();
      }
      var p;
      var f = O(r.inputs);
      try {
        for (f.s(); !(p = f.n()).done;) {
          var d = p.value;
          var v = d.sourceLayer;
          var m = d.nodeIndex;
          var g = d.tensorIndex;
          Fse(m === 0, "input layer has >1 nodes");
          Fse(g === 0, "input layer has >1 tensors");
          r.inputLayers.push(v);
          r.inputLayersNodeIndices.push(m);
          r.inputLayersTensorIndices.push(g);
        }
      } catch (e) {
        f.e(e);
      } finally {
        f.f();
      }
      r.inputNames = [];
      r.outputNames = [];
      r.feedInputShapes = [];
      r.feedInputNames = [];
      r.feedOutputNames = [];
      for (var y = 0; y < r.inputLayers.length; y++) {
        var b = r.inputLayers[y];
        if (!(b instanceof Nce)) {
          throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${b.getClassName()}.`);
        }
        r.inputNames.push(b.name);
        r.feedInputShapes.push(b.batchInputShape);
        r.feedInputNames.push(b.name);
      }
      var k;
      var w = O(r.outputLayers);
      try {
        for (w.s(); !(k = w.n()).done;) {
          var I = k.value;
          r.outputNames.push(I.name);
        }
      } catch (e) {
        w.e(e);
      } finally {
        w.f();
      }
      r.internalInputShapes = r.inputs.map(function (e) {
        return e.shape;
      });
      r.internalOutputShapes = r.outputs.map(function (e) {
        return e.shape;
      });
      var N;
      var S = {};
      var T = {};
      var E = {};
      var C = {};
      var A = {};
      var R = [];
      var _ = function e(t, a, i, o, s, u) {
        if (o == null || s == null || u == null) {
          o = t.sourceLayer;
          s = t.nodeIndex;
          u = t.tensorIndex;
        }
        var c = o.inboundNodes[s];
        if (i.indexOf(c) !== -1) {
          throw new Ese(`The tensor ${t.name} at layer "${o.name}" is part of a cycle.`);
        }
        if (a.indexOf(c) === -1) {
          r.containerNodes.add(n.nodeKey(o, s));
          if (!(o.id in A)) {
            A[o.id] = Object.keys(A).length;
          }
          if (i.indexOf(c) === -1) {
            i.push(c);
          }
          for (var l = c.inboundLayers.length, h = 0; h < l; h++) {
            e(c.inputTensors[h], a, i, c.inboundLayers[h], c.nodeIndices[h], c.tensorIndices[h]);
          }
          for (a.push(c); i.indexOf(c) >= 0;) {
            i.splice(i.indexOf(c), 1);
          }
          R.push(c);
        }
      };
      var F = [];
      var D = [];
      var M = O(r.outputs);
      try {
        for (M.s(); !(N = M.n()).done;) {
          _(N.value, F, D);
        }
      } catch (e) {
        M.e(e);
      } finally {
        M.f();
      }
      var L;
      var z = O(R.slice().reverse());
      try {
        for (z.s(); !(L = z.n()).done;) {
          var P = L.value;
          T[P.id] = P;
          if (!(P.id in S)) {
            S[P.id] = 0;
          }
          var B = S[P.id];
          var W = E[P.outboundLayer.id] == null ? 0 : E[P.outboundLayer.id];
          B = Math.max(B, W);
          E[P.outboundLayer.id] = B;
          C[P.outboundLayer.id] = P.outboundLayer;
          S[P.id] = B;
          for (var U = 0; U < P.inboundLayers.length; U++) {
            var V = P.inboundLayers[U];
            var G = P.nodeIndices[U];
            var j = V.inboundNodes[G];
            var H = S[j.id] == null ? 0 : S[j.id];
            S[j.id] = Math.max(B + 1, H);
            T[j.id] = j;
          }
        }
      } catch (e) {
        z.e(e);
      } finally {
        z.f();
      }
      var q = {};
      for (var K in S) {
        var X = S[K];
        if (!(X in q)) {
          q[X] = [];
        }
        q[X].push(T[K]);
      }
      var Y = {};
      for (var J in E) {
        var Z = E[J];
        if (!(Z in Y)) {
          Y[Z] = [];
        }
        Y[Z].push(C[J]);
      }
      var Q = Object.keys(Y).map(function (e) {
        return parseInt(e, 10);
      }).sort(Gse);
      r.layers = [];
      var $;
      var ee = O(Q);
      try {
        for (ee.s(); !($ = ee.n()).done;) {
          var te = Y[$.value];
          te.sort(function (e, t) {
            var n = A[e.id];
            var r = A[t.id];
            if (n < r) {
              return -1;
            } else if (n > r) {
              return 1;
            } else {
              return 0;
            }
          });
          var ne;
          var re = O(te);
          try {
            for (re.s(); !(ne = re.n()).done;) {
              var ae = ne.value;
              if (ae instanceof n) {
                r.internalContainerRefs.push(ae);
              }
              r.layers.push(ae);
            }
          } catch (e) {
            re.e(e);
          } finally {
            re.f();
          }
        }
      } catch (e) {
        ee.e(e);
      } finally {
        ee.f();
      }
      r.layersByDepth = Y;
      Q = Object.keys(q).map(function (e) {
        return parseInt(e, 10);
      }).sort(Gse);
      var ie;
      var oe = r.inputs.slice();
      var se = [];
      var ue = O(Q);
      try {
        for (ue.s(); !(ie = ue.n()).done;) {
          var ce;
          var le = O(q[ie.value]);
          try {
            for (le.s(); !(ce = le.n()).done;) {
              var he = ce.value;
              var pe = he.outboundLayer;
              if (pe != null) {
                var fe;
                var de = O(he.inputTensors);
                try {
                  for (de.s(); !(fe = de.n()).done;) {
                    var ve = fe.value;
                    if (oe.indexOf(ve) === -1) {
                      throw new Ese(`Graph disconnected: cannot obtain value for tensor ${ve} at layer "${pe.name}". The following previous layers were accessed without issue: ${se}`);
                    }
                  }
                } catch (e) {
                  de.e(e);
                } finally {
                  de.f();
                }
                var me;
                var ge = O(he.outputTensors);
                try {
                  for (ge.s(); !(me = ge.n()).done;) {
                    var ye = me.value;
                    oe.push(ye);
                  }
                } catch (e) {
                  ge.e(e);
                } finally {
                  ge.f();
                }
                se.push(pe.name);
              }
            }
          } catch (e) {
            le.e(e);
          } finally {
            le.f();
          }
        }
      } catch (e) {
        ue.e(e);
      } finally {
        ue.f();
      }
      r.nodesByDepth = q;
      var be;
      var xe = r.layers.map(function (e) {
        return e.name;
      });
      var ke = O(xe);
      try {
        function we() {
          var e = be.value;
          var t = xe.filter(function (t) {
            return t === e;
          }).length;
          if (t !== 1) {
            throw new Ese(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: ${JSON.stringify(xe)}`);
          }
        }
        for (ke.s(); !(be = ke.n()).done;) {
          we();
        }
      } catch (e) {
        ke.e(e);
      } finally {
        ke.f();
      }
      r.outboundNodes = [];
      r.inboundNodes = [];
      new xce({
        outboundLayer: x(r),
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: r.inputs,
        outputTensors: r.outputs,
        inputMasks: r.inputs.map(function (e) {
          return null;
        }),
        outputMasks: r.outputs.map(function (e) {
          return null;
        }),
        inputShapes: r.inputs.map(function (e) {
          return e.shape;
        }),
        outputShapes: r.outputs.map(function (e) {
          return e.shape;
        })
      });
      r.built = true;
      r._refCount = 1;
      return r;
    }
    p(n, [{
      key: "assertNotDisposed",
      value: function () {
        if (this._refCount === 0) {
          throw new Error(`Container '${this.name}' is already disposed.`);
        }
      }
    }, {
      key: "dispose",
      value: function () {
        this.assertNotDisposed();
        var e = {
          refCountAfterDispose: null,
          numDisposedVariables: 0
        };
        if (--this._refCount == 0) {
          var t;
          var n = O(this.layers);
          try {
            for (n.s(); !(t = n.n()).done;) {
              var r = t.value;
              e.numDisposedVariables += r.dispose().numDisposedVariables;
            }
          } catch (e) {
            n.e(e);
          } finally {
            n.f();
          }
          var a;
          var i = O(this.internalContainerRefs);
          try {
            for (i.s(); !(a = i.n()).done;) {
              var o = a.value;
              e.numDisposedVariables += o.dispose().numDisposedVariables;
            }
          } catch (e) {
            i.e(e);
          } finally {
            i.f();
          }
        }
        e.refCountAfterDispose = this._refCount;
        return e;
      }
    }, {
      key: "trainable",
      get: function () {
        return this.trainable_;
      },
      set: function (e) {
        this.layers.forEach(function (t) {
          t._trainableWeights.forEach(function (t) {
            return t.trainable = e;
          });
        });
        this.trainable_ = e;
      }
    }, {
      key: "trainableWeights",
      get: function () {
        if (this._trainableWeights.length > 0) {
          throw new Cse("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
        }
        if (!this.trainable) {
          return [];
        }
        var e;
        var t = [];
        var n = O(this.layers);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            t = t.concat(r.trainableWeights);
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        return t;
      }
    }, {
      key: "nonTrainableWeights",
      get: function () {
        var e;
        var t = [];
        var n = O(this.layers);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            t.push.apply(t, T(r.nonTrainableWeights));
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        if (!this.trainable) {
          var a;
          var i = [];
          var o = O(this.layers);
          try {
            for (o.s(); !(a = o.n()).done;) {
              var s = a.value;
              i.push.apply(i, T(s.trainableWeights));
            }
          } catch (e) {
            o.e(e);
          } finally {
            o.f();
          }
          return i.concat(t);
        }
        return t;
      }
    }, {
      key: "weights",
      get: function () {
        return this.trainableWeights.concat(this.nonTrainableWeights);
      }
    }, {
      key: "loadWeights",
      value: function (e) {
        var t = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
        var n = {};
        var r = 0;
        var a = Wle(e);
        if (a) {
          this.parseWeights(e);
        }
        var i;
        var o = O(this.layers);
        try {
          for (o.s(); !(i = o.n()).done;) {
            var s;
            var u = i.value;
            var c = O(u.weights.entries());
            try {
              for (c.s(); !(s = c.n()).done;) {
                var l = S(s.value, 2);
                var h = l[0];
                var p = l[1];
                var f = a ? `${p.name.split("/").slice(0, -1).join("/") + "/"}${h}` : p.originalName;
                if (n[f] != null) {
                  throw new Cse(`Duplicate weight name: ${f}`);
                }
                n[f] = p;
                r++;
              }
            } catch (e) {
              c.e(e);
            } finally {
              c.f();
            }
          }
        } catch (e) {
          o.e(e);
        } finally {
          o.f();
        }
        var d = [];
        for (var v in e) {
          var m = v;
          if (n[v] == null) {
            var g = v.split("/");
            var y = g.slice(0, -2).concat([g[g.length - 1]]);
            m = y.join("/");
          }
          if (n[m] != null) {
            d.push([n[m], e[v]]);
          } else if (t) {
            throw new Cse(`Provided weight data has no target variable: ${v}`);
          }
          delete n[m];
        }
        if (t) {
          var b = [];
          for (var x in n) {
            b.push(x);
          }
          if (b.length > 0) {
            throw new Cse(`${b.length} of ${r} weights are not set: ${b}`);
          }
        }
        mce(d);
      }
    }, {
      key: "parseWeights",
      value: function (e) {
        function t() {
          var t = n.split("/");
          var r = ["vars", "layer_checkpoint_dependencies"];
          var a = t.map(function (e) {
            if (e.startsWith("_")) {
              return e.slice(1);
            } else {
              return e;
            }
          }).filter(function (e) {
            return !r.includes(e);
          }).join("/");
          if (a !== n) {
            e[a] = e[n];
            delete e[n];
          }
        }
        for (var n in Object.keys(e)) {
          t();
        }
      }
    }, {
      key: "updatedConfig",
      value: function () {
        var e = this.getConfig();
        var t = {};
        t.className = this.getClassName();
        t.config = e;
        t.kerasVersion = `tfjs-layers ${Ble}`;
        t.backend = "TensorFlow.js";
        return t;
      }
    }, {
      key: "toJSON",
      value: function (e) {
        var t = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
        var n = Ple(this.updatedConfig());
        if (t) {
          return JSON.stringify(n);
        } else {
          return n;
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          e = Lse(e);
          var r = new Tce();
          for (var a = 0; a < n.inputs.length; ++a) {
            r.add(n.inputs[a], e[a]);
          }
          return Ace(n.outputs, r, t);
        });
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r;
          e = Lse(e);
          r = t == null ? Ose(null, e.length) : Lse(t);
          return n.runInternalGraph(e, r)[1];
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t = cce(e);
        if (t.length !== this.inputLayers.length) {
          throw new Cse(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);
        }
        var n = {};
        for (var r = 0; r < t.length; r++) {
          var a = this.inputLayers[r];
          var i = t[r];
          n[a.name + "_0_0"] = i;
        }
        var o = Object.keys(this.nodesByDepth).map(function (e) {
          return parseInt(e, 10);
        }).sort(Gse);
        if (o.length > 1) {
          var s;
          var u = O(o);
          try {
            for (u.s(); !(s = u.n()).done;) {
              var c;
              var l = s.value;
              var h = O(this.nodesByDepth[l]);
              try {
                for (h.s(); !(c = h.n()).done;) {
                  var p = c.value;
                  var f = p.outboundLayer;
                  if (this.inputLayers.map(function (e) {
                    return e.id;
                  }).indexOf(f.id) === -1) {
                    var d = [];
                    for (var v = 0; v < p.inboundLayers.length; v++) {
                      var m = p.inboundLayers[v];
                      var g = p.nodeIndices[v];
                      var y = p.tensorIndices[v];
                      var b = n[`${m.name}_${g}_${y}`];
                      d.push(b);
                    }
                    for (var x = cce(f.computeOutputShape(Mse(d))), k = f.inboundNodes.indexOf(p), w = 0; w < x.length; w++) {
                      n[`${f.name}_${k}_${w}`] = x[w];
                    }
                  }
                }
              } catch (e) {
                h.e(e);
              } finally {
                h.f();
              }
            }
          } catch (e) {
            u.e(e);
          } finally {
            u.f();
          }
        }
        var I = [];
        var N = [];
        for (var S = 0; S < this.outputLayers.length; S++) {
          var T = this.outputLayers[S];
          var E = this.outputLayersNodeIndices[S];
          var C = this.outputLayersTensorIndices[S];
          var A = `${T.name}_${E}_${C}`;
          N.push(A);
        }
        for (var R = 0; R < N.length; R++) {
          var _ = N[R];
          Fse(_ in n);
          I.push(n[_]);
        }
        return Mse(I);
      }
    }, {
      key: "runInternalGraph",
      value: function (e, t) {
        if (t == null) {
          t = Ose(null, e.length);
        }
        var n = {};
        for (var r = 0; r < this.inputs.length; ++r) {
          var a = this.inputs[r];
          var i = e[r];
          var o = t[r];
          n[a.id] = [i, o];
        }
        var s;
        var u = Object.keys(this.nodesByDepth).map(function (e) {
          return parseInt(e, 10);
        }).sort(Gse);
        var c = O(u);
        try {
          for (c.s(); !(s = c.n()).done;) {
            var l;
            var h = s.value;
            var p = O(this.nodesByDepth[h]);
            try {
              for (p.s(); !(l = p.n()).done;) {
                var f;
                var d = l.value;
                var v = d.outboundLayer;
                var m = d.inputTensors;
                var g = d.outputTensors;
                var y = new Array();
                var b = O(m);
                try {
                  for (b.s(); !(f = b.n()).done;) {
                    var x = f.value;
                    if (x.id in n) {
                      y.push(n[x.id]);
                    }
                  }
                } catch (e) {
                  b.e(e);
                } finally {
                  b.f();
                }
                if (y.length === m.length) {
                  var k = {};
                  var w = undefined;
                  var I = undefined;
                  var N = undefined;
                  var T = undefined;
                  if (d.callArgs != null) {
                    k = d.callArgs;
                  }
                  if (y.length === 1) {
                    var E = S(y[0], 2);
                    var C = E[0];
                    var A = E[1];
                    if (k.mask == null) {
                      k.mask = A;
                    }
                    N = Lse(v.call(C, k));
                    T = Lse(v.computeMask(C, A));
                    w = [C];
                    I = [A];
                  } else {
                    w = y.map(function (e) {
                      return e[0];
                    });
                    I = y.map(function (e) {
                      return e[1];
                    });
                    if (k.mask == null) {
                      k.mask = I;
                    }
                    N = Lse(v.call(w, k));
                    T = Lse(v.computeMask(w, I));
                  }
                  if (v.activityRegularizer) {
                    throw new Ase("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
                  }
                  for (var R = 0; R < g.length; ++R) {
                    var _ = g[R];
                    var F = N[R];
                    var D = T[R];
                    n[_.id] = [F, D];
                  }
                }
              }
            } catch (e) {
              p.e(e);
            } finally {
              p.f();
            }
          }
        } catch (e) {
          c.e(e);
        } finally {
          c.f();
        }
        var M;
        var L = [];
        var z = [];
        var P = [];
        var B = O(this.outputs);
        try {
          for (B.s(); !(M = B.n()).done;) {
            var W = M.value;
            Fse(W.id in n, `Could not compute output ${W.name} : ${W.id}`);
            var U = S(n[W.id], 2);
            var V = U[0];
            var G = U[1];
            P.push(V.shape);
            L.push(V);
            z.push(G);
          }
        } catch (e) {
          B.e(e);
        } finally {
          B.f();
        }
        return [L, z, P];
      }
    }, {
      key: "buildNodeConversionMap",
      value: function (e) {
        var t;
        var r;
        var a = {};
        var i = O(this.layers);
        try {
          for (i.s(); !(r = i.n()).done;) {
            var o = r.value;
            t = o instanceof n ? 1 : 0;
            for (var s = 0; s < o.inboundNodes.length; s++) {
              var u = n.nodeKey(o, s);
              if (this.containerNodes.has(u)) {
                a[u] = t;
                t += 1;
              }
            }
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
        return a;
      }
    }, {
      key: "getLayer",
      value: function (e, t) {
        if (t != null) {
          return this.findLayer(t);
        }
        if (e == null) {
          throw new Cse("Provide either a layer name or layer index");
        }
        if (typeof e == "number") {
          return this.findLayer(e);
        }
        var n;
        var r = O(this.layers);
        try {
          for (r.s(); !(n = r.n()).done;) {
            var a = n.value;
            if (a.name === e) {
              return a;
            }
          }
        } catch (e) {
          r.e(e);
        } finally {
          r.f();
        }
        throw new Cse(`No such layer: ${e}`);
      }
    }, {
      key: "findLayer",
      value: function (e) {
        if (this.layers.length <= e) {
          throw new Cse(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);
        }
        return this.layers[e];
      }
    }, {
      key: "calculateLosses",
      value: function () {
        var e = this;
        return X5(function () {
          var t;
          var r = [];
          var a = O(e.layers);
          try {
            for (a.s(); !(t = a.n()).done;) {
              for (var i = t.value, o = 0; o < i.inboundNodes.length; ++o) {
                var s = n.nodeKey(i, o);
                if (e.containerNodes.has(s)) {
                  r.push.apply(r, T(i.calculateLosses()));
                }
              }
            }
          } catch (e) {
            a.e(e);
          } finally {
            a.f();
          }
          return r;
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e;
        var t = {
          name: this.name
        };
        var r = this.buildNodeConversionMap(this.layers);
        var a = [];
        var i = O(this.layers);
        try {
          for (i.s(); !(e = i.n()).done;) {
            for (var o = e.value, s = o.getClassName(), u = o.getConfig(), c = [], l = 0; l < o.inboundNodes.length; l++) {
              var h = o.inboundNodes[l];
              var p = n.nodeKey(o, l);
              var f = {};
              if (this.containerNodes.has(p)) {
                if (h.callArgs) {
                  try {
                    JSON.stringify(h.callArgs);
                    f = h.callArgs;
                  } catch (e) {
                    console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`);
                    f = {};
                  }
                }
                if (h.inboundLayers.length > 0) {
                  var d = [];
                  for (var v = 0; v < h.inboundLayers.length; v++) {
                    var m = h.inboundLayers[v];
                    var g = h.nodeIndices[v];
                    var y = h.tensorIndices[v];
                    var b = r[n.nodeKey(m, g)];
                    if (b == null) {
                      b = 0;
                    }
                    d.push([m.name, b, y, f]);
                  }
                  c.push(d);
                }
              }
            }
            var x = {
              name: o.name,
              className: s,
              config: u,
              inboundNodes: c
            };
            a.push(x);
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
        t.layers = a;
        var k = [];
        for (var w = 0; w < this.inputLayers.length; w++) {
          var I = this.inputLayers[w];
          var N = this.inputLayersNodeIndices[w];
          var S = n.nodeKey(I, N);
          if (this.containerNodes.has(S)) {
            var T = r[S];
            if (T == null) {
              T = 0;
            }
            var E = this.inputLayersTensorIndices[w];
            k.push([I.name, T, E]);
          }
        }
        t.inputLayers = k;
        var C = [];
        for (var A = 0; A < this.outputLayers.length; A++) {
          var R = this.outputLayers[A];
          var _ = this.outputLayersNodeIndices[A];
          var F = n.nodeKey(R, _);
          if (this.containerNodes.has(F)) {
            var D = r[F];
            if (D == null) {
              D = 0;
            }
            var M = this.outputLayersTensorIndices[A];
            C.push([R.name, D, M]);
          }
        }
        t.outputLayers = C;
        return t;
      }
    }, {
      key: "stateful",
      get: function () {
        if (this._stateful) {
          throw new Cse("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
        }
        var e;
        var t = O(this.layers);
        try {
          for (t.s(); !(e = t.n()).done;) {
            if (e.value.stateful) {
              return true;
            }
          }
        } catch (e) {
          t.e(e);
        } finally {
          t.f();
        }
        return false;
      }
    }, {
      key: "resetStates",
      value: function () {
        var e = this;
        X5(function () {
          e.layers.forEach(function (e) {
            if (e.stateful) {
              e.resetStates();
            }
          });
        });
      }
    }], [{
      key: "fromConfig",
      value: function (e, t, _param, n = false) {
        var r = {};
        var a = {};
        function i(e, t) {
          if (e.name in a) {
            a[e.name].push(t);
          } else {
            a[e.name] = [t];
          }
        }
        function o(e, t) {
          var n;
          var a;
          var o = [];
          var s = O(t);
          try {
            for (s.s(); !(a = s.n()).done;) {
              var u = a.value;
              var c = u[0];
              var l = u[1];
              var h = u[2];
              n = u[3] == null ? {} : u[3];
              if (!(c in r)) {
                i(e, t);
                return;
              }
              var p = r[c];
              if (p.inboundNodes.length <= l) {
                i(e, t);
                return;
              }
              var f = p.inboundNodes[l];
              o.push(f.outputTensors[h]);
            }
          } catch (e) {
            s.e(e);
          } finally {
            s.f();
          }
          if (o.length > 0) {
            e.apply(Mse(o), n);
          }
        }
        function s(e) {
          var a = e.name;
          var o = rle(e, t.customObjects ?? {});
          o.setFastWeightInitDuringBuild(n);
          r[a] = o;
          e.inboundNodes.forEach(function (e) {
            if (!(e instanceof Array)) {
              throw new Cse(`Corrupted configuration, expected array for nodeData: ${e}`);
            }
            i(o, e);
          });
        }
        var u;
        var c = t.name;
        var l = t.layers;
        var h = O(l);
        try {
          for (h.s(); !(u = h.n()).done;) {
            var p = u.value;
            s(p);
          }
        } catch (e) {
          h.e(e);
        } finally {
          h.f();
        }
        while (!Hse(a)) {
          var f;
          var d = O(l);
          try {
            for (d.s(); !(f = d.n()).done;) {
              var v = f.value;
              var m = r[v.name];
              if (m.name in a) {
                var g = a[m.name];
                delete a[m.name];
                var y;
                var b = O(g);
                try {
                  for (b.s(); !(y = b.n()).done;) {
                    var x = y.value;
                    o(m, x);
                  }
                } catch (e) {
                  b.e(e);
                } finally {
                  b.f();
                }
              }
            }
          } catch (e) {
            d.e(e);
          } finally {
            d.f();
          }
        }
        var k;
        var w = [];
        var I = [];
        var N = t.inputLayers;
        var S = O(N);
        try {
          for (S.s(); !(k = S.n()).done;) {
            var T = k.value;
            var E = T[0];
            var C = T[1];
            var A = T[2];
            Fse(E in r);
            var R = r[E];
            var _ = R.inboundNodes[C].outputTensors;
            w.push(_[A]);
          }
        } catch (e) {
          S.e(e);
        } finally {
          S.f();
        }
        var F;
        var D = t.outputLayers;
        var M = O(D);
        try {
          for (M.s(); !(F = M.n()).done;) {
            var L = F.value;
            var z = L[0];
            var P = L[1];
            var B = L[2];
            Fse(z in r);
            var W = r[z];
            var U = W.inboundNodes[P].outputTensors;
            I.push(U[B]);
          }
        } catch (e) {
          M.e(e);
        } finally {
          M.f();
        }
        return new e({
          inputs: w,
          outputs: I,
          name: c
        });
      }
    }]);
    return n;
  }(wce);
  function Vle(e, t, n) {
    var r = t.length;
    if (e == null || Array.isArray(e) && e.length === 0) {
      return t.map(function (e) {
        return null;
      });
    }
    if (r === 1) {
      if (Array.isArray(e) && e.length === 1) {
        return e;
      } else if (s(e) === "object" && t[0] in e) {
        return [e[t[0]]];
      } else {
        return [e];
      }
    }
    if (Array.isArray(e)) {
      if (e.length !== r) {
        throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);
      }
      return e;
    }
    if (s(e) === "object" && Object.keys(e).length > 0 && s(e[Object.keys(e)[0]]) === "object") {
      var a = [];
      t.forEach(function (t) {
        if (t in e) {
          a.push(e[t]);
        } else {
          a.push(null);
        }
      });
      return a;
    }
    throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`);
  }
  function Gle(e, t) {
    return Vle(e, t, "classWeight");
  }
  function jle(e, t, n, r) {
    return Hle.apply(this, arguments);
  }
  function Hle() {
    return (Hle = c(o().mark(function e(t, n, r, a) {
      var i;
      var s;
      var u;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              if (n == null && a == null) {
                e.next = 2;
                break;
              }
              throw new Error("Support sampleWeight is not implemented yet");
            case 2:
              if (r == null) {
                e.next = 15;
                break;
              }
              i = X5(function () {
                if (t.shape.length === 1) {
                  return p8(t);
                }
                if (t.shape.length === 2) {
                  if (t.shape[1] > 1) {
                    return N8(t, 1);
                  }
                  if (t.shape[1] === 1) {
                    return X8(t, [t.shape[0]]);
                  }
                  throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
                }
                throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
              });
              e.t0 = Array;
              e.next = 7;
              return i.data();
            case 7:
              e.t1 = e.sent;
              s = e.t0.from.call(e.t0, e.t1);
              Y5(i);
              u = [];
              s.forEach(function (e) {
                if (r[e] == null) {
                  throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);
                }
                u.push(r[e]);
              });
              return e.abrupt("return", Vte(u, "float32"));
            case 15:
              return e.abrupt("return", null);
            case 16:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  function qle(e, t) {
    return g8(e, t);
  }
  function Kle(e, t) {
    var n;
    var r;
    var a = t;
    n = a.xs;
    r = a.ys;
    F$(n != null && r != null, function () {
      return `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`;
    });
    var i = Xle("input", e.inputNames, n);
    var o = Xle("output", e.outputNames, r);
    var s = i[0].shape[0];
    F$(i.length === e.inputs.length, function () {
      return `LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`;
    });
    F$(o.length === e.outputs.length, function () {
      return `LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`;
    });
    var u = function (t) {
      F$(i[t].shape[0] === s, function () {
        return `Batch size mismatch: input ${e.inputNames[t]} has ${i[t].shape[0]}; expected  ${s} based on input ${e.inputNames[0]}.`;
      });
    };
    for (var c = 0; c < i.length; c++) {
      u(c);
    }
    var l = function (t) {
      F$(o[t].shape[0] === s, function () {
        return `Batch size mismatch: output ${e.outputNames[t]} has ${o[t].shape[0]}; expected  ${s} based on input ${e.inputNames[0]}.`;
      });
    };
    for (var h = 0; h < o.length; h++) {
      l(h);
    }
    return {
      xs: i,
      ys: o
    };
  }
  function Xle(e, t, n) {
    if (n instanceof n5) {
      return [n];
    }
    if (Array.isArray(n)) {
      F$(n.length === t.length, function () {
        return `Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`;
      });
      return n;
    }
    var r;
    var a = [];
    var i = O(t);
    try {
      for (i.s(); !(r = i.n()).done;) {
        var o = r.value;
        if (n[o] == null) {
          throw new Cse(`The feature data generated by the dataset lacks the required ${e} key '${o}'.`);
        }
        a.push(n[o]);
      }
    } catch (e) {
      i.e(e);
    } finally {
      i.f();
    }
    return a;
  }
  function Yle(e) {
    if (e.length === 3) {
      throw new Ase("Validation with sample weights is not implemented yet.");
    }
    return {
      xs: e[0],
      ys: e[1]
    };
  }
  function Jle(e, t, n) {
    return Zle.apply(this, arguments);
  }
  function Zle() {
    Zle = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      var y;
      var b;
      var x;
      var k;
      var w;
      var I;
      var N;
      var S;
      var T;
      var E;
      var C;
      var A;
      var R;
      var _;
      var O;
      var F;
      var D;
      var M;
      var L;
      var z;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              a = r.batchesPerEpoch != null;
              F$(t.optimizer != null, function () {
                return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
              });
              F$(r != null, function () {
                return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
              });
              F$(r.epochs != null && r.epochs > 0 && Number.isInteger(r.epochs), function () {
                return `For fitDataset(), config.epochs is expected to be a positive integer, but got ${r.epochs}`;
              });
              F$(!a || r.batchesPerEpoch > 0 && Number.isInteger(r.batchesPerEpoch), function () {
                return `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${r.batchesPerEpoch}`;
              });
              F$(r.validationSplit == null, function () {
                return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
              });
              if (!t.isTraining) {
                e.next = 8;
                break;
              }
              throw new Error("Cannot start training because another fit() call is ongoing.");
            case 8:
              t.isTraining = true;
              e.prev = 9;
              if (i = r.validationData != null) {
                if ($le(r.validationData)) {
                  F$(r.validationBatches == null || r.validationBatches > 0 && Number.isInteger(r.validationBatches), function () {
                    return `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${r.validationBatches}`;
                  });
                } else {
                  c = Yle(r.validationData);
                  s = c.xs;
                  u = c.ys;
                }
              }
              l = t.makeTrainFunction();
              h = t.getDedupedMetricsNames();
              p = i ? h.slice().concat(h.map(function (e) {
                return "val_" + e;
              })) : h.slice();
              f = ele(r.callbacks, r.yieldEvery);
              d = r.verbose == null ? 1 : r.verbose;
              v = nle(f, d, r.epochs, null, null, Qle(n, r), null, i, p);
              m = v.callbackList;
              g = v.history;
              m.setModel(t);
              t.history = g;
              e.next = 22;
              return m.onTrainBegin();
            case 22:
              t.stopTraining_ = false;
              y = r.initialEpoch == null ? 0 : r.initialEpoch;
              e.next = 26;
              return n.iterator();
            case 26:
              b = e.sent;
            case 27:
              if (!(y < r.epochs)) {
                e.next = 98;
                break;
              }
              x = {};
              e.next = 31;
              return m.onEpochBegin(y);
            case 31:
              k = 0;
              w = 0;
              if (a) {
                e.next = 37;
                break;
              }
              e.next = 36;
              return n.iterator();
            case 36:
              b = e.sent;
            case 37:
              if (a && !(k < r.batchesPerEpoch)) {
                e.next = 91;
                break;
              }
              e.next = 40;
              return b.next();
            case 40:
              I = e.sent;
              if (!a || !I.done) {
                e.next = 44;
                break;
              }
              console.warn(`You provided \`batchesPerEpoch\` as ${r.batchesPerEpoch}, but your dataset iterator ran out of data after ${k} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${r.batchesPerEpoch * r.epochs} batches). You may need to use the repeat() function when building your dataset.`);
              return e.abrupt("break", 91);
            case 44:
              if (I.value == null) {
                e.next = 73;
                break;
              }
              N = Kle(t, I.value);
              S = N.xs;
              T = N.ys;
              (E = {}).batch = w;
              E.size = S[0].shape[0];
              e.next = 51;
              return m.onBatchBegin(w, E);
            case 51:
              C = [];
              if (r.classWeight == null) {
                e.next = 64;
                break;
              }
              A = Gle(r.classWeight, t.outputNames);
              R = 0;
            case 55:
              if (!(R < A.length)) {
                e.next = 64;
                break;
              }
              e.t0 = C;
              e.next = 59;
              return jle(T[R], null, A[R]);
            case 59:
              e.t1 = e.sent;
              e.t0.push.call(e.t0, e.t1);
            case 61:
              ++R;
              e.next = 55;
              break;
            case 64:
              _ = S.concat(T).concat(C);
              O = l(_);
              Y5(_);
              F = 0;
              for (; F < h.length; ++F) {
                D = h[F];
                M = O[F];
                E[D] = M;
                J5(M);
              }
              e.next = 70;
              return m.onBatchEnd(w, E);
            case 70:
              Xce(E);
              w++;
              k++;
            case 73:
              if (!(a ? k >= r.batchesPerEpoch : I.done)) {
                e.next = 87;
                break;
              }
              if (!i) {
                e.next = 86;
                break;
              }
              L = undefined;
              if (!$le(r.validationData)) {
                e.next = 84;
                break;
              }
              e.t2 = Lse;
              e.next = 80;
              return t.evaluateDataset(r.validationData, {
                batches: r.validationBatches
              });
            case 80:
              e.t3 = e.sent;
              L = (0, e.t2)(e.t3);
              e.next = 85;
              break;
            case 84:
              L = Lse(t.evaluate(s, u, {
                batchSize: r.validationBatchSize == null ? 32 : r.validationBatchSize,
                verbose: 0
              }));
            case 85:
              for (z = 0; z < t.metricsNames.length; ++z) {
                x[`val_${t.metricsNames[z]}`] = L[z];
              }
            case 86:
              return e.abrupt("break", 91);
            case 87:
              if (!t.stopTraining_) {
                e.next = 89;
                break;
              }
              return e.abrupt("break", 91);
            case 89:
              e.next = 37;
              break;
            case 91:
              e.next = 93;
              return m.onEpochEnd(y, x);
            case 93:
              y++;
              if (!t.stopTraining_) {
                e.next = 96;
                break;
              }
              return e.abrupt("break", 98);
            case 96:
              e.next = 27;
              break;
            case 98:
              e.next = 100;
              return m.onTrainEnd();
            case 100:
              e.next = 102;
              return t.history.syncData();
            case 102:
              return e.abrupt("return", t.history);
            case 103:
              e.prev = 103;
              t.isTraining = false;
              return e.finish(103);
            case 106:
            case "end":
              return e.stop();
          }
        }
      }, e, null, [[9,, 103, 106]]);
    }));
    return Zle.apply(this, arguments);
  }
  function Qle(e, t) {
    var n = null;
    if (t.batchesPerEpoch != null) {
      n = t.batchesPerEpoch;
    } else if (Number.isFinite(e.size)) {
      n = e.size;
    }
    return n;
  }
  function $le(e) {
    return typeof e.iterator == "function";
  }
  function ehe(e) {
    return typeof e.next == "function";
  }
  function the(e, t, n) {
    return nhe.apply(this, arguments);
  }
  function nhe() {
    nhe = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              a = (r = r || {}).batches != null;
              i = t.testFunction;
              s = [];
              if (!(r.verbose > 0)) {
                e.next = 6;
                break;
              }
              throw new Ase("Verbose mode is not implemented yet.");
            case 6:
              F$(!a || r.batches > 0 && Number.isInteger(r.batches), function () {
                return `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(r.batches)}`;
              });
              if (!ehe(n)) {
                e.next = 11;
                break;
              }
              e.t0 = n;
              e.next = 14;
              break;
            case 11:
              e.next = 13;
              return n.iterator();
            case 13:
              e.t0 = e.sent;
            case 14:
              u = e.t0;
              c = 0;
              l = 0;
              h = o().mark(function e() {
                var n;
                return o().wrap(function (e) {
                  while (true) {
                    switch (e.prev = e.next) {
                      case 0:
                        e.next = 2;
                        return u.next();
                      case 2:
                        n = e.sent;
                        s = X5(function () {
                          if (n.value) {
                            var e = Kle(t, n.value);
                            var r = e.xs;
                            var a = e.ys;
                            var o = r.concat(a);
                            var u = X5(function () {
                              return i(o);
                            });
                            Y5(o);
                            if (l === 0) {
                              for (var h = 0; h < u.length; ++h) {
                                s.push(i9(0));
                              }
                            }
                            var p = o[0].shape[0];
                            var f = function (e) {
                              var t = u[e];
                              var n = s[e];
                              s[e] = X5(function () {
                                return d8(s[e], g8(p, t));
                              });
                              if (l > 0) {
                                Y5(n);
                              }
                            };
                            for (var d = 0; d < u.length; ++d) {
                              f(d);
                            }
                            Y5(u);
                            c += p;
                            ++l;
                          }
                          return s;
                        });
                        if (!n.done) {
                          e.next = 7;
                          break;
                        }
                        if (a) {
                          console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${r.batches} batches). You may need to use the repeat() function when building your dataset.`);
                        }
                        return e.abrupt("return", "break");
                      case 7:
                      case "end":
                        return e.stop();
                    }
                  }
                }, e);
              });
            case 18:
              if (a && !(l < r.batches)) {
                e.next = 25;
                break;
              }
              return e.delegateYield(h(), "t1", 20);
            case 20:
              if (e.t1 !== "break") {
                e.next = 23;
                break;
              }
              return e.abrupt("break", 25);
            case 23:
              e.next = 18;
              break;
            case 25:
              for (p = 0; p < s.length; ++p) {
                f = s[p];
                s[p] = m8(s[p], c);
                Y5(f);
              }
              return e.abrupt("return", Mse(s));
            case 27:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return nhe.apply(this, arguments);
  }
  function rhe(e) {
    F$(e > 0 && Number.isInteger(e), function () {
      return `batchSize is required to be a positive integer, but got ${e}`;
    });
  }
  function ahe(e, t, n) {
    if (e == null) {
      return [null];
    } else if (Array.isArray(e)) {
      return e.map(function (e) {
        return Sue(e, t, n - t);
      });
    } else {
      return Sue(e, t, n - t);
    }
  }
  function ihe(e, t) {
    return X5(function () {
      if (e == null) {
        return null;
      } else if (Array.isArray(e)) {
        return e.map(function (e) {
          return ihe(e, t);
        });
      } else {
        return Fue(e, t.dtype === "int32" ? t : h8(t, "int32"));
      }
    });
  }
  function ohe(e, t) {
    var n = [];
    for (var r = 0, a = null; r < e;) {
      if ((a = r + t) >= e) {
        a = e;
      }
      n.push([r, a]);
      r = a;
    }
    return n;
  }
  function she(e) {
    var t = [];
    if (e instanceof n5) {
      e = [e];
    }
    for (var n = 0; n < e.length; ++n) {
      var r = e[n];
      if (r.rank === 1) {
        t.push(Iue(r, 1));
      } else {
        if (r.rank === 0) {
          throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
        }
        t.push(r);
      }
    }
    return t;
  }
  function uhe(e, t) {
    if (e != null) {
      var n = [];
      if (t instanceof n5) {
        n.push(t.id);
      } else if (Array.isArray(t)) {
        t.forEach(function (e) {
          return n.push(e.id);
        });
      } else if (t != null) {
        for (var r in t) {
          var a = t[r];
          n.push(a.id);
        }
      }
      var i = [];
      if (e instanceof n5) {
        if (n.indexOf(e.id) === -1) {
          i.push(e);
        }
      } else if (Array.isArray(e)) {
        e.forEach(function (e) {
          if (n.indexOf(e.id) === -1) {
            i.push(e);
          }
        });
      } else if (e != null) {
        for (var o in e) {
          var s = e[o];
          if (n.indexOf(s.id) === -1) {
            i.push(s);
          }
        }
      }
      i.forEach(function (e) {
        if (!e.isDisposed) {
          e.dispose();
        }
      });
    }
  }
  function che(e) {
    return Array.isArray(e);
  }
  function lhe(e) {
    return !function (e) {
      return e instanceof n5;
    }(e) && !che(e);
  }
  function hhe(e, t, n) {
    var r;
    var a = !(arguments.length > 3) || arguments[3] === undefined || arguments[3];
    var i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
    if (t == null || t.length === 0) {
      if (e != null) {
        var o = false;
        if (che(e) && e.length > 0) {
          o = true;
        } else if (lhe(e)) {
          for (var s in e) {
            if (e.hasOwnProperty(s)) {
              o = true;
              break;
            }
          }
        } else {
          o = true;
        }
        if (o) {
          throw new Cse(`Error when checking model ${i} expected no data, but got ${e}`);
        }
      }
      return [];
    }
    if (e == null) {
      return t.map(function (e) {
        return null;
      });
    }
    if (lhe(e)) {
      r = [];
      var u;
      var c = O(t);
      try {
        for (c.s(); !(u = c.n()).done;) {
          var l = u.value;
          if (e[l] == null) {
            throw new Cse(`No data provided for "${l}". Need data for each key in: ${t}`);
          }
          r.push(e[l]);
        }
      } catch (e) {
        c.e(e);
      } finally {
        c.f();
      }
    } else if (che(e)) {
      if (e.length !== t.length) {
        throw new Cse(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);
      }
      r = e;
    } else {
      if (t.length > 1) {
        throw new Cse(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);
      }
      r = [e];
    }
    r = she(r);
    if (n != null) {
      for (var h = 0; h < t.length; ++h) {
        if (n[h] != null) {
          var p = r[h];
          if (p.shape.length !== n[h].length) {
            throw new Cse(`Error when checking ${i}: expected ${t[h]} to have ${n[h].length} dimension(s). but got array with shape ${p.shape}`);
          }
          for (var f = 0; f < n[h].length; ++f) {
            if (f !== 0 || a) {
              var d = p.shape[f];
              var v = n[h][f];
              if (v != null && v >= 0 && d !== v) {
                throw new Cse(`${i} expected a batch of elements where each example has shape [${n[h].slice(1, n[h].length)}] (i.e.,tensor shape [*,${n[h].slice(1, n[h].length)}]) but the ${i} received an input with ${p.shape[0]} examples, each with shape [${p.shape.slice(1, p.shape.length)}] (tensor shape [${p.shape}])`);
              }
            }
          }
        }
      }
    }
    return r;
  }
  function phe(e, t, n) {
    var r = jse(e.map(function (e) {
      return e.shape[0];
    }));
    r.sort();
    var a = jse(t.map(function (e) {
      return e.shape[0];
    }));
    a.sort();
    if (r.length > 1) {
      throw new Cse(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(function (e) {
        return e.shape;
      }))}`);
    }
    if (a.length > 1) {
      throw new Cse(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(function (e) {
        return e.shape;
      }))}`);
    }
    if (r.length > 0 && a.length > 0 && !P$(r, a)) {
      throw new Cse(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`);
    }
  }
  function fhe(e, t, n) {
    var r = [ile, hle, cle];
    for (var a = 0; a < e.length; ++a) {
      var i = e[a];
      var o = t[a];
      var s = n[a];
      if (o != null) {
        if (o === cle && i.shape[i.shape.length - 1] === 1) {
          throw new Cse(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
        }
        if (r.indexOf(o) !== -1) {
          for (var u = i.shape.slice(1), c = s.slice(1), l = 0; l < u.length; ++l) {
            var h = u[l];
            var p = c[l];
            if (p != null && h !== p) {
              throw new Cse(`A target Tensor with shape ${i.shape} was passed for an output of shape ${s}, while using a loss function that expects targets to have the same shape as the output.`);
            }
          }
        }
      }
    }
  }
  function dhe(e, t, n) {
    var r;
    var a = !(arguments.length > 3) || arguments[3] === undefined || arguments[3];
    var i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
    if (Array.isArray(e)) {
      if (e.length !== t.length) {
        throw new Cse(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);
      }
      r = e;
    } else {
      if (t.length > 1) {
        throw new Cse(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);
      }
      r = [e];
    }
    if (n != null) {
      for (var o = 0; o < t.length; ++o) {
        if (n[o] != null) {
          var s = r[o];
          if (s.shape.length !== n[o].length) {
            throw new Cse(`Error when checking ${i}: expected ${t[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(s.shape)}`);
          }
          for (var u = 0; u < n[o].length; ++u) {
            if (u !== 0 || a) {
              var c = s.shape[u];
              var l = n[o][u];
              if (l != null && l !== c) {
                throw new Cse(`Error when checking ${i}: expected ${t[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(s.shape)}.`);
              }
            }
          }
        }
      }
    }
  }
  var vhe = function (e) {
    d(m, e);
    var t;
    var n;
    var r;
    var a;
    var i;
    var u;
    var h;
    var f = w(m);
    function m(e) {
      var t;
      l(this, m);
      (t = f.call(this, e)).isTraining = false;
      return t;
    }
    p(m, [{
      key: "summary",
      value: function (e, t, n = console.log) {
        if (!this.built) {
          throw new Cse("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
        }
        Rle(this, e, t, n);
      }
    }, {
      key: "compile",
      value: function (e) {
        var t = this;
        if (e.loss == null) {
          e.loss = [];
        }
        this.loss = e.loss;
        if (typeof e.optimizer == "string") {
          this.optimizer_ = function (e) {
            var t = {
              Adagrad: function () {
                return nie.adagrad(0.01);
              },
              Adadelta: function () {
                return nie.adadelta(1, 0.95, kue());
              },
              Adam: function () {
                return nie.adam(0.001, 0.9, 0.999, kue());
              },
              Adamax: function () {
                return nie.adamax(0.002, 0.9, 0.999, kue(), 0);
              },
              RMSProp: function () {
                return nie.rmsprop(0.001, 0.9, 0, kue());
              },
              SGD: function () {
                return nie.sgd(0.01);
              }
            };
            t.adagrad = t.Adagrad;
            t.adadelta = t.Adadelta;
            t.adam = t.Adam;
            t.adamax = t.Adamax;
            t.rmsprop = t.RMSProp;
            t.sgd = t.SGD;
            if (e in t) {
              return t[e]();
            }
            throw new Cse(`Unknown Optimizer ${e}`);
          }(e.optimizer);
          this.isOptimizerOwned = true;
        } else {
          if (!(e.optimizer instanceof Yre)) {
            throw new Cse("User-defined optimizer must be an instance of tf.Optimizer.");
          }
          this.optimizer_ = e.optimizer;
          this.isOptimizerOwned = false;
        }
        var n = [];
        if (Array.isArray(e.loss) || typeof e.loss == "string" || typeof e.loss == "function") {
          if (Array.isArray(e.loss)) {
            if (e.loss.length !== this.outputs.length) {
              throw new Cse(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);
            }
            var r = e.loss;
            n = r.map(function (e) {
              return vle(e);
            });
          } else {
            var a = vle(e.loss);
            this.outputs.forEach(function (e) {
              n.push(a);
            });
          }
        } else {
          e.loss = e.loss;
          for (var i in e.loss) {
            if (this.outputNames.indexOf(i) === -1) {
              throw new Cse(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);
            }
          }
          var o;
          var u = O(this.outputNames);
          try {
            for (u.s(); !(o = u.n()).done;) {
              var c = o.value;
              if (e.loss[c] == null) {
                console.warn(`Output "${c}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${c} during training`);
              }
              n.push(vle(e.loss[c]));
            }
          } catch (e) {
            u.e(e);
          } finally {
            u.f();
          }
        }
        this.lossFunctions = n;
        this.feedOutputNames = [];
        this.feedOutputShapes = [];
        this.feedLossFns = [];
        for (var l = 0; l < this.outputs.length; ++l) {
          var h = this.internalOutputShapes[l];
          var p = this.outputNames[l];
          this.feedOutputNames.push(p);
          this.feedOutputShapes.push(h);
          this.feedLossFns.push(this.lossFunctions[l]);
        }
        var f = [];
        this.metrics = e.metrics;
        this.metricsNames = ["loss"];
        this.metricsTensors = [];
        hue("loss", function () {
          for (var e = 0; e < t.outputs.length; ++e) {
            if (f.indexOf(e) === -1) {
              var n = t.lossFunctions[e];
              if (t.outputs.length > 1) {
                t.metricsTensors.push([n, e]);
                t.metricsNames.push(t.outputNames[e] + "_loss");
              }
            }
          }
        });
        var d = function (e, t) {
          if (e == null || Array.isArray(e) && e.length === 0) {
            return t.map(function (e) {
              return [];
            });
          }
          var n;
          if (typeof e == "string" || typeof e == "function") {
            n = [e];
          } else {
            if (!Array.isArray(e) && s(e) !== "object") {
              throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);
            }
            n = e;
          }
          if (Array.isArray(n)) {
            return t.map(function (e) {
              return n;
            });
          }
          var r;
          var a = [];
          var i = O(t);
          try {
            for (i.s(); !(r = i.n()).done;) {
              var o = r.value;
              var u = n.hasOwnProperty(o) ? n[o] : [];
              if (!Array.isArray(u)) {
                u = [u];
              }
              a.push(u);
            }
          } catch (e) {
            i.e(e);
          } finally {
            i.f();
          }
          return a;
        }(e.metrics, this.outputNames);
        hue("metric", function () {
          var e = function (e) {
            if (f.indexOf(e) !== -1) {
              return "continue";
            }
            (function (n) {
              var r;
              var a;
              var i;
              var o;
              var s = O(n);
              try {
                function u() {
                  var n;
                  var s = o.value;
                  if (typeof s == "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(s) !== -1) {
                    var u;
                    var c = t.internalOutputShapes[e];
                    if (c[c.length - 1] === 1 || t.lossFunctions[e] === hle) {
                      if (["accuracy", "acc"].indexOf(s) !== -1) {
                        a = mle;
                      } else if (["crossentropy", "ce"].indexOf(s) !== -1) {
                        a = kle;
                      }
                    } else if (t.lossFunctions[e] === lle) {
                      if (["accuracy", "acc"].indexOf(s) !== -1) {
                        a = wle;
                      } else if (["crossentropy", "ce"].indexOf(s) !== -1) {
                        a = Nle;
                      }
                    } else if (["accuracy", "acc"].indexOf(s) !== -1) {
                      a = gle;
                    } else if (["crossentropy", "ce"].indexOf(s) !== -1) {
                      a = Ile;
                    }
                    if (["accuracy", "acc"].indexOf(s) !== -1) {
                      u = "acc";
                    } else if (["crossentropy", "ce"].indexOf(s) !== -1) {
                      u = "ce";
                    }
                    i = a;
                    r = "" + u;
                  } else {
                    var l = function (e) {
                      if (typeof e == "string" && e in Sle) {
                        return Sle[e];
                      }
                      if (typeof e != "string" && e != null) {
                        return e;
                      }
                      throw new Cse(`Unknown metric ${e}`);
                    }(s);
                    i = l;
                    r = "" + Tle(s);
                  }
                  hue(r, function () {
                    n = i;
                  });
                  (function (e, n, r) {
                    if (t.outputNames.length > 1) {
                      n = t.outputNames[e] + "_" + n;
                    }
                    t.metricsNames.push(n);
                    t.metricsTensors.push([r, e]);
                  })(e, r, n);
                }
                for (s.s(); !(o = s.n()).done;) {
                  u();
                }
              } catch (e) {
                s.e(e);
              } finally {
                s.f();
              }
            })(d[e]);
          };
          for (var n = 0; n < t.outputs.length; ++n) {
            e(n);
          }
        });
        this.collectedTrainableWeights = this.trainableWeights;
      }
    }, {
      key: "checkTrainableWeightsConsistency",
      value: function () {
        if (this.collectedTrainableWeights != null && this.trainableWeights.length !== this.collectedTrainableWeights.length) {
          console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
        }
      }
    }, {
      key: "evaluate",
      value: function (e, t, n = {}) {
        var r = n.batchSize == null ? 32 : n.batchSize;
        rhe(r);
        var a = true;
        var i = this.standardizeUserDataXY(e, t, a, r);
        try {
          var o = i[0].concat(i[1]);
          this.makeTestFunction();
          var s = this.testFunction;
          var u = this.testLoop(s, o, r, n.verbose, n.steps);
          return Mse(u);
        } finally {
          uhe(i[0], e);
          uhe(i[1], t);
        }
      }
    }, {
      key: "evaluateDataset",
      value: (h = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.makeTestFunction();
                return e.abrupt("return", the(this, t, n));
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return h.apply(this, arguments);
      })
    }, {
      key: "checkNumSamples",
      value: function (e, t, n) {
        var r;
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "steps";
        if (n != null) {
          r = null;
          if (t != null) {
            throw new Cse(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`);
          }
        } else {
          if (e == null) {
            throw new Cse(`Either the input data should have a defined shape, or ${a} shoud be specified.`);
          }
          r = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
        }
        return r;
      }
    }, {
      key: "execute",
      value: function (e, t) {
        if (Array.isArray(t) && t.length === 0) {
          throw new Cse("`outputs` is an empty Array, which is not allowed.");
        }
        var n = Array.isArray(t);
        var r = n ? t : [t];
        var a = this.retrieveSymbolicTensors(r);
        var i = new Tce();
        if (e instanceof n5) {
          e = [e];
        }
        if (Array.isArray(e)) {
          if (e.length !== this.inputs.length) {
            throw new Cse(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
          }
          for (var o = 0; o < this.inputs.length; ++o) {
            i.add(this.inputs[o], e[o]);
          }
        } else {
          var s;
          var u = O(this.inputs);
          try {
            for (u.s(); !(s = u.n()).done;) {
              var c = s.value;
              var l = e[c.name];
              if (l == null) {
                throw new Cse(`No value is provided for the model's input ${c.name}`);
              }
              i.add(c, l);
            }
          } catch (e) {
            u.e(e);
          } finally {
            u.f();
          }
        }
        var h = Ace(a, i);
        if (n) {
          return h;
        } else {
          return h[0];
        }
      }
    }, {
      key: "retrieveSymbolicTensors",
      value: function (e) {
        var t;
        var n = Ose(null, e.length);
        var r = e.length;
        var a = O(this.layers);
        try {
          for (a.s(); !(t = a.n()).done;) {
            var i = t.value;
            var o = Array.isArray(i.output) ? i.output : [i.output];
            var s = o.map(function (e) {
              return e.name;
            });
            for (var u = 0; u < e.length; ++u) {
              var c = s.indexOf(e[u]);
              if (c !== -1) {
                n[u] = o[c];
                r--;
              }
              if (r === 0) {
                break;
              }
            }
            if (r === 0) {
              break;
            }
          }
        } catch (e) {
          a.e(e);
        } finally {
          a.f();
        }
        if (r > 0) {
          var l = [];
          n.forEach(function (t, n) {
            if (t == null) {
              l.push(e[n]);
            }
          });
          throw new Cse(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(l)}`);
        }
        return n;
      }
    }, {
      key: "predictLoop",
      value: function (e) {
        var t = this;
        var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
        var r = arguments.length > 2 && arguments[2] !== undefined && arguments[2];
        return X5(function () {
          var a = t.checkNumSamples(e);
          if (r) {
            throw new Ase("Verbose predictLoop() is not implemented yet.");
          }
          for (var i = ohe(a, n), o = t.outputs.map(function (e) {
              return [];
            }), s = function (n) {
              X5(function () {
                var r = i[n][0];
                var a = i[n][1];
                var o = ahe(e, r, a);
                var s = [];
                if (Array.isArray(o)) {
                  for (var u = 0; u < o.length; ++u) {
                    s.push({
                      key: t.inputs[u],
                      value: o[u]
                    });
                  }
                } else {
                  s.push({
                    key: t.inputs[0],
                    value: o
                  });
                }
                var c = new Tce(s);
                return Ace(t.outputs, c);
              }).forEach(function (e, t) {
                return o[t].push(e);
              });
            }, u = 0; u < i.length; ++u) {
            s(u);
          }
          return Mse(o.map(function (e) {
            return Z8(e, 0);
          }));
        });
      }
    }, {
      key: "predict",
      value: function (e, t = {}) {
        var n = she(e);
        dhe(n, this.inputNames, this.feedInputShapes, false);
        try {
          var r = t.batchSize == null ? 32 : t.batchSize;
          rhe(r);
          return this.predictLoop(n, r);
        } finally {
          uhe(n, e);
        }
      }
    }, {
      key: "predictOnBatch",
      value: function (e) {
        dhe(e, this.inputNames, this.feedInputShapes, true);
        var t = (Array.isArray(e) ? e[0] : e).shape[0];
        return this.predictLoop(e, t);
      }
    }, {
      key: "standardizeUserDataXY",
      value: function (e, t, _param2, n) {
        if (this.optimizer_ == null) {
          throw new Ese("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
        }
        var r = [];
        for (var a = 0; a < this.feedOutputShapes.length; ++a) {
          var i = this.feedOutputShapes[a];
          var o = this.feedLossFns[a];
          if (o === lle) {
            r.push(i.slice(0, i.length - 1).concat([1]));
          } else {
            r.push(i);
          }
        }
        phe(e = hhe(e, this.feedInputNames, this.feedInputShapes, false, "input"), t = hhe(t, this.feedOutputNames, r, false, "target"));
        fhe(t, this.feedLossFns, this.feedOutputShapes);
        if (this.stateful && n != null && n > 0 && e[0].shape[0] % n != 0) {
          throw new Cse(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);
        }
        return [e, t];
      }
    }, {
      key: "standardizeUserData",
      value: (u = c(o().mark(function e(t, n, r, a) {
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f;
        var d;
        var v = arguments;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                i = !(v.length > 4) || v[4] === undefined || v[4];
                s = v.length > 5 ? v[5] : undefined;
                u = this.standardizeUserDataXY(t, n, i, s);
                c = S(u, 2);
                l = c[0];
                h = c[1];
                if (r == null) {
                  e.next = 5;
                  break;
                }
                throw new Error("sample weight is not supported yet.");
              case 5:
                p = null;
                if (a == null) {
                  e.next = 19;
                  break;
                }
                f = Gle(a, this.outputNames);
                p = [];
                d = 0;
              case 10:
                if (!(d < f.length)) {
                  e.next = 19;
                  break;
                }
                e.t0 = p;
                e.next = 14;
                return jle(h[d], null, f[d]);
              case 14:
                e.t1 = e.sent;
                e.t0.push.call(e.t0, e.t1);
              case 16:
                ++d;
                e.next = 10;
                break;
              case 19:
                return e.abrupt("return", [l, h, p]);
              case 20:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t, n, r) {
        return u.apply(this, arguments);
      })
    }, {
      key: "testLoop",
      value: function (e, t, n) {
        var r = this;
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var i = arguments.length > 4 ? arguments[4] : undefined;
        return X5(function () {
          var o = r.checkNumSamples(t, n, i, "steps");
          var s = [];
          if (a > 0) {
            throw new Ase("Verbose mode is not implemented yet.");
          }
          if (i != null) {
            throw new Ase("steps mode in testLoop() is not implemented yet");
          }
          for (var u = ohe(o, n), c = Vte(xue(0, o)), l = 0; l < u.length; ++l) {
            var h = u[l][0];
            var p = u[l][1];
            var f = Sue(c, h, p - h);
            var d = ihe(t, f);
            var v = e(d);
            if (l === 0) {
              for (var m = 0; m < v.length; ++m) {
                s.push(i9(0));
              }
            }
            for (var g = 0; g < v.length; ++g) {
              var y = v[g];
              s[g] = d8(s[g], g8(p - h, y));
            }
          }
          for (var b = 0; b < s.length; ++b) {
            s[b] = m8(s[b], o);
          }
          return s;
        });
      }
    }, {
      key: "getDedupedMetricsNames",
      value: function () {
        for (var e = this.metricsNames, t = [], n = 0; n < e.length; ++n) {
          var r = e[n];
          var a = r;
          if (Dse(e, r) > 1) {
            var i = Dse(e.slice(0, n), r);
            a += `_${i}`;
          }
          t.push(a);
        }
        return t;
      }
    }, {
      key: "makeTrainFunction",
      value: function () {
        var e = this;
        return function (t) {
          var n = [];
          var r = t.slice(0, e.inputs.length);
          var a = t.slice(e.inputs.length, e.inputs.length + e.outputs.length);
          var i = t.slice(e.inputs.length + e.outputs.length, e.inputs.length + e.outputs.length * 2);
          var o = [];
          var s = e.collectedTrainableWeights.map(function (e) {
            return e.read();
          });
          return [e.optimizer_.minimize(function () {
            var t = [];
            for (var s = 0; s < e.inputs.length; ++s) {
              t.push({
                key: e.inputs[s],
                value: r[s]
              });
            }
            var u;
            var c = new Tce(t);
            var l = Ace(e.outputs, c, {
              training: true
            });
            for (var h = 0; h < e.lossFunctions.length; ++h) {
              var p = (0, e.lossFunctions[h])(a[h], l[h]);
              if (i[h] != null) {
                p = qle(p, i[h]);
              }
              var f = Q9(p);
              n.push(f);
              u = h === 0 ? p : d8(u, p);
            }
            for (var d = 0; d < e.metricsTensors.length; ++d) {
              var v = undefined;
              if (e.outputs.length > 1 && d < e.outputs.length) {
                v = n[d];
              } else {
                var m = e.metricsTensors[d][0];
                var g = e.metricsTensors[d][1];
                v = Q9(m(a[g], l[g]));
              }
              J5(v);
              o.push(v);
            }
            u = Q9(u);
            e.calculateLosses().forEach(function (e) {
              u = d8(u, e);
            });
            return u;
          }, true, s)].concat(o);
        };
      }
    }, {
      key: "makeTestFunction",
      value: function () {
        var e = this;
        this.testFunction = function (t) {
          return X5(function () {
            var n;
            var r = [];
            var a = t.slice(0, e.inputs.length);
            var i = t.slice(e.inputs.length, e.inputs.length + e.outputs.length);
            var o = [];
            for (var s = 0; s < e.inputs.length; ++s) {
              o.push({
                key: e.inputs[s],
                value: a[s]
              });
            }
            var u = new Tce(o);
            var c = Ace(e.outputs, u);
            for (var l = 0; l < e.lossFunctions.length; ++l) {
              var h = e.lossFunctions[l];
              var p = Q9(h(i[l], c[l]));
              n = l === 0 ? p : d8(n, p);
              r.push(n);
            }
            for (var f = 0; f < e.metricsTensors.length; ++f) {
              var d = e.metricsTensors[f][0];
              var v = e.metricsTensors[f][1];
              var m = Q9(d(i[v], c[v]));
              r.push(m);
            }
            return r;
          });
        };
      }
    }, {
      key: "fit",
      value: (i = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f;
        var d;
        var v;
        var m;
        var g;
        var y;
        var b;
        var x;
        var k;
        var w;
        var I;
        var N;
        var S;
        var T;
        var E;
        var C;
        var A;
        var R = arguments;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                r = R.length > 2 && R[2] !== undefined ? R[2] : {};
                if (!this.isTraining) {
                  e.next = 3;
                  break;
                }
                throw new Error("Cannot start training because another fit() call is ongoing.");
              case 3:
                this.isTraining = true;
                e.prev = 4;
                rhe(d = r.batchSize == null ? 32 : r.batchSize);
                v = false;
                e.next = 10;
                return this.standardizeUserData(t, n, r.sampleWeight, r.classWeight, v, d);
              case 10:
                m = e.sent;
                a = m[0];
                i = m[1];
                f = m[2];
                g = false;
                if (r.validationData == null || !(r.validationData.length > 0)) {
                  e.next = 36;
                  break;
                }
                g = true;
                if (r.validationData.length !== 2) {
                  e.next = 22;
                  break;
                }
                c = r.validationData[0];
                l = r.validationData[1];
                e.next = 27;
                break;
              case 22:
                if (r.validationData.length !== 3) {
                  e.next = 26;
                  break;
                }
                throw new Ase("validationData including sample weights is not supported yet.");
              case 26:
                throw new Cse(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);
              case 27:
                b = true;
                e.next = 30;
                return this.standardizeUserData(c, l, null, null, b, d);
              case 30:
                x = e.sent;
                h = x[0];
                p = x[1];
                y = h.concat(p);
                e.next = 37;
                break;
              case 36:
                if (r.validationSplit != null && r.validationSplit > 0 && r.validationSplit < 1) {
                  g = true;
                  k = Math.floor(a[0].shape[0] * (1 - r.validationSplit));
                  w = a[0].shape[0];
                  h = ahe(a, k, w);
                  s = a;
                  a = ahe(a, 0, k);
                  p = ahe(i, k, w);
                  u = i;
                  i = ahe(i, 0, k);
                  y = h.concat(p);
                } else if (r.validationSteps != null) {
                  g = true;
                }
              case 37:
                I = a.concat(i).concat(f);
                this.checkTrainableWeightsConsistency();
                N = this.makeTrainFunction();
                S = this.getDedupedMetricsNames();
                if (g) {
                  this.makeTestFunction();
                  T = this.testFunction;
                  E = S.slice().concat(S.map(function (e) {
                    return "val_" + e;
                  }));
                } else {
                  T = null;
                  y = [];
                  E = S.slice();
                }
                C = ele(r.callbacks, r.yieldEvery);
                e.next = 45;
                return this.fitLoop(N, I, S, d, r.epochs, r.verbose, C, T, y, r.shuffle, E, r.initialEpoch, null, null);
              case 45:
                A = e.sent;
                return e.abrupt("return", A);
              case 47:
                e.prev = 47;
                this.isTraining = false;
                uhe(a, t);
                uhe(i, n);
                uhe(s, t);
                uhe(u, n);
                uhe(h, c);
                uhe(p, l);
                if (f != null) {
                  Y5(f);
                }
                return e.finish(47);
              case 57:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[4,, 47, 57]]);
      })), function (e, t) {
        return i.apply(this, arguments);
      })
    }, {
      key: "fitLoop",
      value: (a = c(o().mark(function e(t, n, r, a, i, s, u, c, l, h, p, f, d, v) {
        var m;
        var g;
        var y;
        var b;
        var x;
        var k;
        var w;
        var I;
        var N = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (a == null) {
                  a = 32;
                }
                if (i == null) {
                  i = 1;
                }
                if (h == null) {
                  h = true;
                }
                if (f == null) {
                  f = 0;
                }
                m = false;
                if (c != null && l != null) {
                  m = true;
                }
                if (v == null) {
                  e.next = 10;
                  break;
                }
                m = true;
                if (d != null) {
                  e.next = 10;
                  break;
                }
                throw new Cse("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
              case 10:
                if ((g = this.checkNumSamples(n, a, d, "steps_per_epoch")) != null) {
                  y = xue(0, g);
                }
                if (s == null) {
                  s = 1;
                }
                b = nle(u, s, i, f, g, d, a, m, p);
                x = b.callbackList;
                k = b.history;
                x.setModel(this);
                this.history = k;
                e.next = 18;
                return x.onTrainBegin();
              case 18:
                this.stopTraining_ = false;
                w = o().mark(function e() {
                  var i;
                  var s;
                  var u;
                  var p;
                  var f;
                  return o().wrap(function (e) {
                    while (true) {
                      switch (e.prev = e.next) {
                        case 0:
                          e.next = 2;
                          return x.onEpochBegin(I);
                        case 2:
                          i = {};
                          if (d == null) {
                            e.next = 7;
                            break;
                          }
                          throw new Ase("stepsPerEpoch mode is not implemented yet.");
                        case 7:
                          if (h !== "batch") {
                            e.next = 11;
                            break;
                          }
                          throw new Ase("batch shuffling is not implemneted yet");
                        case 11:
                          if (h) {
                            C$(y);
                          }
                        case 12:
                          s = Vte(y);
                          u = ohe(g, a);
                          p = o().mark(function e(h) {
                            var p;
                            return o().wrap(function (e) {
                              while (true) {
                                switch (e.prev = e.next) {
                                  case 0:
                                    p = {};
                                    e.next = 3;
                                    return x.onBatchBegin(h, p);
                                  case 3:
                                    X5(function () {
                                      var e = u[h][0];
                                      var o = u[h][1];
                                      var f = Sue(s, e, o - e);
                                      p.batch = h;
                                      p.size = o - e;
                                      var d = ihe(n, f);
                                      var v = t(d);
                                      for (var g = 0; g < r.length; ++g) {
                                        var y = r[g];
                                        var b = v[g];
                                        p[y] = b;
                                        J5(b);
                                      }
                                      if (h === u.length - 1 && m) {
                                        var x = N.testLoop(c, l, a);
                                        for (var k = 0; k < r.length; ++k) {
                                          var w = r[k];
                                          var I = x[k];
                                          J5(I);
                                          i["val_" + w] = I;
                                        }
                                      }
                                    });
                                    e.next = 6;
                                    return x.onBatchEnd(h, p);
                                  case 6:
                                    Xce(p);
                                    if (!N.stopTraining_) {
                                      e.next = 9;
                                      break;
                                    }
                                    return e.abrupt("return", "break");
                                  case 9:
                                  case "end":
                                    return e.stop();
                                }
                              }
                            }, e);
                          });
                          f = 0;
                        case 16:
                          if (!(f < u.length)) {
                            e.next = 24;
                            break;
                          }
                          return e.delegateYield(p(f), "t0", 18);
                        case 18:
                          if (e.t0 !== "break") {
                            e.next = 21;
                            break;
                          }
                          return e.abrupt("break", 24);
                        case 21:
                          ++f;
                          e.next = 16;
                          break;
                        case 24:
                          s.dispose();
                        case 25:
                          e.next = 27;
                          return x.onEpochEnd(I, i);
                        case 27:
                          if (!N.stopTraining_) {
                            e.next = 29;
                            break;
                          }
                          return e.abrupt("return", "break");
                        case 29:
                        case "end":
                          return e.stop();
                      }
                    }
                  }, e);
                });
                I = f;
              case 21:
                if (!(I < i)) {
                  e.next = 29;
                  break;
                }
                return e.delegateYield(w(), "t0", 23);
              case 23:
                if (e.t0 !== "break") {
                  e.next = 26;
                  break;
                }
                return e.abrupt("break", 29);
              case 26:
                ++I;
                e.next = 21;
                break;
              case 29:
                e.next = 31;
                return x.onTrainEnd();
              case 31:
                e.next = 33;
                return this.history.syncData();
              case 33:
                return e.abrupt("return", this.history);
              case 34:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t, n, r, i, o, s, u, c, l, h, p, f, d) {
        return a.apply(this, arguments);
      })
    }, {
      key: "fitDataset",
      value: (r = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", Jle(this, t, n));
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return r.apply(this, arguments);
      })
    }, {
      key: "trainOnBatch",
      value: (n = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.standardizeUserData(t, n);
              case 2:
                r = e.sent;
                a = r[0];
                i = r[1];
                s = this.makeTrainFunction();
                u = s(a.concat(i));
                c = [];
                l = O(u);
                e.prev = 9;
                l.s();
              case 11:
                if ((h = l.n()).done) {
                  e.next = 19;
                  break;
                }
                p = h.value;
                e.next = 15;
                return p.data();
              case 15:
                f = e.sent;
                c.push(f[0]);
              case 17:
                e.next = 11;
                break;
              case 19:
                e.next = 24;
                break;
              case 21:
                e.prev = 21;
                e.t0 = e.catch(9);
                l.e(e.t0);
              case 24:
                e.prev = 24;
                l.f();
                return e.finish(24);
              case 27:
                Y5(u);
                uhe(r[0], t);
                uhe(r[1], n);
                return e.abrupt("return", Mse(c));
              case 31:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[9, 21, 24, 27]]);
      })), function (e, t) {
        return n.apply(this, arguments);
      })
    }, {
      key: "getNamedWeights",
      value: function (e) {
        var t = [];
        var n = e != null && e.trainableOnly;
        for (var r = n ? this.trainableWeights : this.weights, a = this.getWeights(n), i = 0; i < r.length; ++i) {
          if (!n || !!r[i].trainable) {
            t.push({
              name: r[i].originalName,
              tensor: a[i]
            });
          }
        }
        return t;
      }
    }, {
      key: "stopTraining",
      get: function () {
        return this.stopTraining_;
      },
      set: function (e) {
        this.stopTraining_ = e;
      }
    }, {
      key: "optimizer",
      get: function () {
        return this.optimizer_;
      },
      set: function (e) {
        if (this.optimizer_ !== e) {
          this.optimizer_ = e;
          this.isOptimizerOwned = false;
        }
      }
    }, {
      key: "dispose",
      value: function () {
        var e = N(v(m.prototype), "dispose", this).call(this);
        if (e.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
          var t = K5().numTensors;
          this.optimizer_.dispose();
          e.numDisposedVariables += t - K5().numTensors;
        }
        return e;
      }
    }, {
      key: "getLossIdentifiers",
      value: function () {
        var e;
        if (typeof this.loss == "string") {
          e = zse(this.loss);
        } else if (Array.isArray(this.loss)) {
          var t;
          var n = O(this.loss);
          try {
            for (n.s(); !(t = n.n()).done;) {
              if (typeof t.value != "string") {
                throw new Error("Serialization of non-string loss is not supported.");
              }
            }
          } catch (e) {
            n.e(e);
          } finally {
            n.f();
          }
          e = this.loss.map(function (e) {
            return zse(e);
          });
        } else {
          var r = Object.keys(this.loss);
          e = {};
          var a = this.loss;
          for (var i = 0, o = r; i < o.length; i++) {
            var s = o[i];
            if (typeof a[s] != "string") {
              throw new Error("Serialization of non-string loss is not supported.");
            }
            e[s] = zse(a[s]);
          }
        }
        return e;
      }
    }, {
      key: "getMetricIdentifiers",
      value: function () {
        if (typeof this.metrics == "string" || typeof this.metrics == "function") {
          return [zse(Tle(this.metrics))];
        }
        if (Array.isArray(this.metrics)) {
          return this.metrics.map(function (e) {
            return zse(Tle(e));
          });
        }
        var e = {};
        for (var t in this.metrics) {
          e[t] = zse(Tle(this.metrics[t]));
        }
        return e;
      }
    }, {
      key: "getTrainingConfig",
      value: function () {
        return {
          loss: this.getLossIdentifiers(),
          metrics: this.getMetricIdentifiers(),
          optimizer_config: {
            class_name: this.optimizer.getClassName(),
            config: this.optimizer.getConfig()
          }
        };
      }
    }, {
      key: "loadTrainingConfig",
      value: function (e) {
        if (e.weighted_metrics != null) {
          throw new Error("Loading weight_metrics is not supported yet.");
        }
        if (e.loss_weights != null) {
          throw new Error("Loading loss_weights is not supported yet.");
        }
        if (e.sample_weight_mode != null) {
          throw new Error("Loading sample_weight_mode is not supported yet.");
        }
        var t;
        var n;
        var r = rle(zle(e.optimizer_config));
        if (typeof e.loss == "string") {
          t = Pse(e.loss);
        } else if (Array.isArray(e.loss)) {
          t = e.loss.map(function (e) {
            return Pse(e);
          });
        } else if (e.loss != null) {
          t = {};
          for (var a in e.loss) {
            t[a] = Pse(e.loss[a]);
          }
        }
        if (Array.isArray(e.metrics)) {
          n = e.metrics.map(function (e) {
            return Pse(e);
          });
        } else if (e.metrics != null) {
          n = {};
          for (var i in e.metrics) {
            n[i] = Pse(e.metrics[i]);
          }
        }
        this.compile({
          loss: t,
          metrics: n,
          optimizer: r
        });
      }
    }, {
      key: "save",
      value: (t = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (typeof t != "string") {
                  e.next = 9;
                  break;
                }
                if ((r = T6(t)).length !== 0) {
                  e.next = 6;
                  break;
                }
                throw new Cse(`Cannot find any save handlers for URL '${t}'`);
              case 6:
                if (!(r.length > 1)) {
                  e.next = 8;
                  break;
                }
                throw new Cse(`Found more than one (${r.length}) save handlers for URL '${t}'`);
              case 8:
                t = r[0];
              case 9:
                if (t.save != null) {
                  e.next = 11;
                  break;
                }
                throw new Cse("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
              case 11:
                e.next = 13;
                return t6(this.getNamedWeights(n));
              case 13:
                a = e.sent;
                i = this.toJSON(null, false);
                s = {
                  modelTopology: i,
                  format: "layers-model",
                  generatedBy: `TensorFlow.js tfjs-layers v${Ble}`,
                  convertedBy: null
                };
                if (n == null || !n.includeOptimizer || this.optimizer == null) {
                  e.next = 34;
                  break;
                }
                s.trainingConfig = this.getTrainingConfig();
                c = "optimizer";
                e.t0 = Nae;
                e.next = 25;
                return this.optimizer.getWeights();
              case 25:
                e.t1 = e.sent;
                e.t2 = c;
                e.next = 29;
                return e.t0.encodeWeights.call(e.t0, e.t1, e.t2);
              case 29:
                l = e.sent;
                h = l.data;
                p = l.specs;
                (u = a.specs).push.apply(u, T(p));
                a.data = g6([a.data, h]);
              case 34:
                if (this.userDefinedMetadata != null) {
                  Cle(this.userDefinedMetadata, this.name, true);
                  s.userDefinedMetadata = this.userDefinedMetadata;
                }
                s.weightData = a.data;
                s.weightSpecs = a.specs;
                return e.abrupt("return", t.save(s));
              case 38:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, n) {
        return t.apply(this, arguments);
      })
    }, {
      key: "setUserDefinedMetadata",
      value: function (e) {
        Cle(e, this.name);
        this.userDefinedMetadata = e;
      }
    }, {
      key: "getUserDefinedMetadata",
      value: function () {
        return this.userDefinedMetadata;
      }
    }]);
    return m;
  }(Ule);
  vhe.className = "Model";
  Kre(vhe);
  var mhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    return p(n);
  }(vhe);
  function ghe() {
    ghe = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              if (!("modelTopology" in t)) {
                t = {
                  modelTopology: t
                };
              }
              if ((r = t.modelTopology).model_config != null) {
                r = r.model_config;
              }
              a = zle(r);
              i = rle(a, n);
              if (t.weightsManifest == null) {
                e.next = 15;
                break;
              }
              e.next = 9;
              return hae(t.weightsManifest, t.pathPrefix, i.weights.map(function (e) {
                return e.originalName;
              }));
            case 9:
              s = e.sent;
              u = {};
              c = O(i.weights);
              try {
                for (c.s(); !(l = c.n()).done;) {
                  h = l.value;
                  u[h.originalName] = s[h.originalName];
                }
              } catch (e) {
                c.e(e);
              } finally {
                c.f();
              }
              i.loadWeights(u);
              Y5(s);
            case 15:
              return e.abrupt("return", i);
            case 16:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return ghe.apply(this, arguments);
  }
  function yhe() {
    return (yhe = c(o().mark(function e(t, n) {
      var r;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              if (n == null) {
                n = {};
              }
              if (typeof t != "string") {
                e.next = 10;
                break;
              }
              if ((r = E6(t, n)).length !== 0) {
                e.next = 7;
                break;
              }
              r.push(bae(t, n));
              e.next = 9;
              break;
            case 7:
              if (!(r.length > 1)) {
                e.next = 9;
                break;
              }
              throw new Cse(`Found more than one (${r.length}) load handlers for URL '${t}'`);
            case 9:
              t = r[0];
            case 10:
              return e.abrupt("return", bhe(t, undefined, n));
            case 11:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  function bhe(e, t, n) {
    return xhe.apply(this, arguments);
  }
  function xhe() {
    xhe = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              if (r == null) {
                r = {};
              }
              if (t.load != null) {
                e.next = 3;
                break;
              }
              throw new Cse("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            case 3:
              e.next = 5;
              return t.load();
            case 5:
              a = e.sent;
              if ((i = a.modelTopology).model_config != null) {
                i = i.model_config;
              }
              s = r.strict == null || r.strict;
              u = a.weightData != null && a.weightSpecs != null && s;
              c = rle(zle(i), n, u);
              if ((l = a.trainingConfig) != null) {
                c.loadTrainingConfig(l);
              }
              if (a.userDefinedMetadata != null) {
                c.setUserDefinedMetadata(a.userDefinedMetadata);
              }
              if (a.weightData == null) {
                e.next = 24;
                break;
              }
              if (a.weightSpecs != null) {
                e.next = 17;
                break;
              }
              throw new Cse("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
            case 17:
              h = khe(a.weightData, a.weightSpecs);
              p = h.modelWeights;
              f = h.optimizerWeights;
              c.loadWeights(p, s);
              if (c.optimizer == null || !(f.length > 0)) {
                e.next = 22;
                break;
              }
              e.next = 22;
              return c.optimizer.setWeights(f);
            case 22:
              Y5(p);
              Y5(f.map(function (e) {
                return e.tensor;
              }));
            case 24:
              return e.abrupt("return", c);
            case 25:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return xhe.apply(this, arguments);
  }
  function khe(e, t) {
    var n = r6(e, t);
    var r = {};
    var a = [];
    t.forEach(function (e) {
      if (e.group === "optimizer") {
        a.push({
          name: e.name,
          tensor: n[e.name]
        });
      } else {
        r[e.name] = n[e.name];
      }
    });
    return {
      modelWeights: r,
      optimizerWeights: a
    };
  }
  mhe.className = "Functional";
  Kre(mhe);
  var whe = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e) {
      var t;
      l(this, a);
      e = e || {};
      (t = r.call(this, {
        inputs: [],
        outputs: []
      })).trainable = true;
      t.built = false;
      t.name = e.name ?? eue("sequential_");
      if (e.layers != null) {
        var n;
        var i = O(e.layers);
        try {
          for (i.s(); !(n = i.n()).done;) {
            var o = n.value;
            t.add(o);
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
      }
      return t;
    }
    p(a, [{
      key: "checkShape",
      value: function (e) {
        if (e.inboundNodes[0].outputTensors[0].shape.some(function (e) {
          return e < 0;
        })) {
          throw new Cse(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`);
        }
      }
    }, {
      key: "add",
      value: function (e) {
        var t;
        var n = e instanceof a || e instanceof vhe;
        if (n) {
          if ((t = e).outputs.length !== 1) {
            throw new Cse("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          }
          if (t.inputs.length !== 1) {
            throw new Cse("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
          }
        }
        if (this.outputs.length === 0) {
          if (e.inboundNodes.length === 0) {
            if (e.batchInputShape == null) {
              throw new Cse("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
            }
            var r = Sce({
              batchShape: e.batchInputShape,
              dtype: e.dtype,
              name: e.name + "_input"
            });
            e.apply(r);
          }
          if (n) {
            this.outputs = t.outputs;
            this.inputs = t.inputs;
          } else {
            if (e.inboundNodes.length !== 1) {
              throw new Cse(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);
            }
            if (e.inboundNodes[0].outputTensors.length !== 1) {
              throw new Cse("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
            }
            this.checkShape(e);
            this.outputs = [e.inboundNodes[0].outputTensors[0]];
            this.inputs = Ice(this.outputs[0]);
          }
          this.inboundNodes = [];
          new xce({
            outboundLayer: this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: this.inputs,
            outputTensors: this.outputs,
            inputMasks: Ose(null, this.inputs.length),
            outputMasks: [null],
            inputShapes: this.inputs.map(function (e) {
              return e.shape;
            }),
            outputShapes: this.outputs[0].shape
          });
        } else {
          var i = e.apply(this.outputs[0]);
          if (Array.isArray(i)) {
            throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          }
          this.checkShape(e);
          this.outputs = [i];
          this.inboundNodes[0].outputTensors = this.outputs;
          this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
        this.layers.push(e);
        this.built = false;
      }
    }, {
      key: "pop",
      value: function () {
        if (this.layers.length === 0) {
          throw new TypeError("There are no layers in the model.");
        }
        this.layers.pop();
        if (this.layers.length === 0) {
          this.outputs = [];
          this.inboundNodes = [];
          this.outboundNodes = [];
        } else {
          var e = this.layers.length - 1;
          this.layers[e].outboundNodes = [];
          this.outputs = [this.layers[e].output];
          this.inboundNodes[0].outputTensors = this.outputs;
          this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        if (this.model == null) {
          this.build();
        }
        return this.model.call(e, t);
      }
    }, {
      key: "build",
      value: function (e) {
        hce(e);
        if (this.inputs.length === 0 || this.outputs.length === 0) {
          throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
        }
        this.model = new vhe({
          inputs: this.inputs,
          outputs: this.outputs[0],
          name: this.name + "_model"
        });
        this.model.trainable = this.trainable;
        this.supportsMasking = this.model.supportsMasking;
        this.inputLayers = this.model.inputLayers;
        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
        this.outputLayers = this.model.outputLayers;
        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
        this.nodesByDepth = this.model.nodesByDepth;
        this.containerNodes = this.model.containerNodes;
        this.outputNames = this.model.outputNames;
        this.inputNames = this.model.inputNames;
        this.built = true;
      }
    }, {
      key: "countParams",
      value: function () {
        if (!this.built) {
          this.build();
        }
        return N(v(a.prototype), "countParams", this).call(this);
      }
    }, {
      key: "summary",
      value: function (e, t, n = console.log) {
        if (!this.built) {
          this.build();
        }
        N(v(a.prototype), "summary", this).call(this, e, t, n);
      }
    }, {
      key: "setWeights",
      value: function (e) {
        if (this.model == null) {
          this.build();
        }
        this.model.setWeights(e);
      }
    }, {
      key: "evaluate",
      value: function (e, t, n = {}) {
        if (!this.built) {
          throw new Ese("The model needs to be compiled before being used.");
        }
        return this.model.evaluate(e, t, n);
      }
    }, {
      key: "evaluateDataset",
      value: function () {
        var e = c(o().mark(function e(t, n) {
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  if (this.built) {
                    e.next = 2;
                    break;
                  }
                  throw new Ese("The model needs to be compiled before being used.");
                case 2:
                  return e.abrupt("return", this.model.evaluateDataset(t, n));
                case 3:
                case "end":
                  return e.stop();
              }
            }
          }, e, this);
        }));
        return function (t, n) {
          return e.apply(this, arguments);
        };
      }()
    }, {
      key: "predict",
      value: function (e, t = {}) {
        if (this.model == null) {
          this.build();
        }
        return this.model.predict(e, t);
      }
    }, {
      key: "predictOnBatch",
      value: function (e) {
        if (this.model == null) {
          this.build();
        }
        return this.model.predictOnBatch(e);
      }
    }, {
      key: "compile",
      value: function (e) {
        this.build();
        this.model.compile(e);
        this.optimizer_ = this.model.optimizer;
        this.isOptimizerOwned = this.model.isOptimizerOwned;
        this.loss = this.model.loss;
        this.metrics = this.model.metrics;
        this.metricsTensors = this.model.metricsTensors;
        this.metricsNames = this.model.metricsNames;
      }
    }, {
      key: "optimizer",
      get: function () {
        if (this.model == null) {
          return undefined;
        } else {
          return this.model.optimizer;
        }
      },
      set: function (e) {
        this.model.optimizer = e;
      }
    }, {
      key: "fit",
      value: (n = c(o().mark(function e(t, n) {
        var r;
        var a = arguments;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                r = a.length > 2 && a[2] !== undefined ? a[2] : {};
                if (this.built) {
                  e.next = 3;
                  break;
                }
                throw new Ese("The model needs to be compiled before being used.");
              case 3:
                return e.abrupt("return", this.model.fit(t, n, r));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return n.apply(this, arguments);
      })
    }, {
      key: "fitDataset",
      value: function () {
        var e = c(o().mark(function e(t, n) {
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  if (this.built) {
                    e.next = 2;
                    break;
                  }
                  throw new Ese("The model needs to be compiled before being used.");
                case 2:
                  return e.abrupt("return", this.model.fitDataset(t, n));
                case 3:
                case "end":
                  return e.stop();
              }
            }
          }, e, this);
        }));
        return function (t, n) {
          return e.apply(this, arguments);
        };
      }()
    }, {
      key: "trainOnBatch",
      value: (t = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.model.trainOnBatch(t, n));
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, n) {
        return t.apply(this, arguments);
      })
    }, {
      key: "stopTraining",
      get: function () {
        if (this.model == null) {
          throw new Cse("Cannot get the stopTraining property of a sequential model before it is compiled.");
        }
        return this.model.stopTraining;
      },
      set: function (e) {
        if (this.model == null) {
          throw new Cse("Cannot set the stopTraining property of a sequential model before it is compiled.");
        }
        this.model.stopTraining = e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e;
        var t = [];
        var n = O(this.layers);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            var a = {};
            a.className = r.getClassName();
            a.config = r.getConfig();
            t.push(a);
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        return {
          name: this.name,
          layers: t
        };
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        var n;
        var r = arguments.length > 3 && arguments[3] !== undefined && arguments[3];
        var i = {};
        if (t instanceof Array) {
          if (t[0].className == null || t[0].className === "Merge") {
            throw new Cse("Legacy serialization format not supported yet.");
          }
          n = t;
        } else {
          F$(t.layers != null, function () {
            return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
          });
          n = t.layers;
          delete t.layers;
          i = t;
        }
        var o = new e(i);
        if (!(o instanceof a)) {
          throw new Ase(`Sequential.fromConfig called on non-Sequential input: ${o}`);
        }
        var s;
        var u = O(n);
        try {
          for (u.s(); !(s = u.n()).done;) {
            var c = s.value;
            var l = undefined;
            var h = rle(c, l, r);
            if (r) {
              h.setFastWeightInitDuringBuild(true);
            }
            o.add(h);
          }
        } catch (e) {
          u.e(e);
        } finally {
          u.f();
        }
        return o;
      }
    }]);
    return a;
  }(vhe);
  function Ihe(e) {
    return Sce(e);
  }
  whe.className = "Sequential";
  Kre(whe);
  var Nhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        return {};
      }
    }]);
    return n;
  }(Hre);
  var She = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e, t = 1) {
        return zue(e, t);
      }
    }]);
    return n;
  }(Nhe);
  She.className = "elu";
  Kre(She);
  var The = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return bte(e);
      }
    }]);
    return n;
  }(Nhe);
  The.className = "selu";
  Kre(The);
  var Ehe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return lte(e);
      }
    }]);
    return n;
  }(Nhe);
  Ehe.className = "relu";
  Kre(Ehe);
  var Che = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return X5(function () {
          return nee(6, lte(e));
        });
      }
    }]);
    return n;
  }(Nhe);
  Che.className = "relu6";
  Kre(Che);
  var Ahe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return e;
      }
    }]);
    return n;
  }(Nhe);
  Ahe.className = "linear";
  Kre(Ahe);
  var Rhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return $8(e);
      }
    }]);
    return n;
  }(Nhe);
  Rhe.className = "sigmoid";
  Kre(Rhe);
  var _he = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return function (e) {
          return X5(function () {
            var t = d8(0.5, g8(0.2, e));
            return d7(t, 0, 1);
          });
        }(e);
      }
    }]);
    return n;
  }(Nhe);
  _he.className = "hardSigmoid";
  Kre(_he);
  var Ohe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return L9(e);
      }
    }]);
    return n;
  }(Nhe);
  Ohe.className = "softplus";
  Kre(Ohe);
  var Fhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return function (e) {
          return X5(function () {
            return m8(e, d8(y8(e), 1));
          });
        }(e);
      }
    }]);
    return n;
  }(Nhe);
  Fhe.className = "softsign";
  Kre(Fhe);
  var Dhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return t7(e);
      }
    }]);
    return n;
  }(Nhe);
  Dhe.className = "tanh";
  Kre(Dhe);
  var Mhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e, t = -1) {
        return Rte(e, t);
      }
    }]);
    return n;
  }(Nhe);
  Mhe.className = "softmax";
  Kre(Mhe);
  var Lhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e, t = -1) {
        return B9(e, t);
      }
    }]);
    return n;
  }(Nhe);
  Lhe.className = "logSoftmax";
  Kre(Lhe);
  var zhe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e, t = 1) {
        return X5(function () {
          return g8($8(g8(e, t)), e);
        });
      }
    }]);
    return n;
  }(Nhe);
  zhe.className = "swish";
  Kre(zhe);
  var Phe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        return X5(function () {
          return g8(e, t7(L9(e)));
        });
      }
    }]);
    return n;
  }(Nhe);
  function Bhe(e) {
    return e.getClassName();
  }
  function Whe(e, t = {}) {
    return Vse(e, qre.getMap().classNameMap, t, "activation");
  }
  function Uhe(e) {
    if (e == null) {
      var t = {
        className: "linear",
        config: {}
      };
      return Whe(t);
    }
    if (typeof e == "string") {
      var n = {
        className: e,
        config: {}
      };
      return Whe(n);
    }
    if (e instanceof Nhe) {
      return e;
    } else {
      return Whe(e);
    }
  }
  function Vhe(e) {
    if (e != null && s(e) !== "object") {
      throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`);
    }
  }
  Phe.className = "mish";
  Kre(Phe);
  var Ghe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    return p(n);
  }(Hre);
  var jhe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this);
      Vhe(e);
      r.l1 = e == null || e.l1 == null ? 0.01 : e.l1;
      r.l2 = e == null || e.l2 == null ? 0.01 : e.l2;
      r.hasL1 = r.l1 !== 0;
      r.hasL2 = r.l2 !== 0;
      return r;
    }
    p(n, [{
      key: "apply",
      value: function (e) {
        var t = this;
        return X5(function () {
          var n = $9([1]);
          if (t.hasL1) {
            n = d8(n, u9(g8(t.l1, y8(e))));
          }
          if (t.hasL2) {
            n = d8(n, u9(g8(t.l2, Due(e))));
          }
          return X8(n, []);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        return {
          l1: this.l1,
          l2: this.l2
        };
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        return new e({
          l1: t.l1,
          l2: t.l2
        });
      }
    }]);
    return n;
  }(Ghe);
  jhe.className = "L1L2";
  Kre(jhe);
  var Hhe = {
    l1l2: "L1L2"
  };
  function qhe(e) {
    return Wse(e);
  }
  function Khe(e, t = {}) {
    return Vse(e, qre.getMap().classNameMap, t, "regularizer");
  }
  function Xhe(e) {
    if (e == null) {
      return null;
    } else if (typeof e == "string") {
      return Khe({
        className: e in Hhe ? Hhe[e] : e,
        config: {}
      });
    } else if (e instanceof Ghe) {
      return e;
    } else {
      return Khe(e);
    }
  }
  var Yhe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e == null ? {} : e)).supportsMasking = true;
      if (e != null) {
        r.maxValue = e.maxValue;
      }
      return r;
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        e = lce(e);
        var n = lte(e);
        if (this.maxValue != null) {
          n = d7(n, 0, this.maxValue);
        }
        return n;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          maxValue: this.maxValue
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Yhe.className = "ReLU";
  Kre(Yhe);
  var Jhe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e == null ? {} : e)).DEFAULT_ALPHA = 0.3;
      if (e == null) {
        e = {};
      }
      r.alpha = e.alpha == null ? r.DEFAULT_ALPHA : e.alpha;
      return r;
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var n = lce(e);
        return S9(n, this.alpha);
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          alpha: this.alpha
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Jhe.className = "LeakyReLU";
  Kre(Jhe);
  var Zhe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e == null ? {} : e)).DEFAULT_ALPHA_INITIALIZER = "zeros";
      if (e == null) {
        e = {};
      }
      r.supportsMasking = true;
      r.alphaInitializer = sce(e.alphaInitializer || r.DEFAULT_ALPHA_INITIALIZER);
      r.alphaRegularizer = Xhe(e.alphaRegularizer);
      r.alphaConstraint = Vce(e.alphaConstraint);
      if (e.sharedAxes == null) {
        r.sharedAxes = null;
      } else if (Array.isArray(e.sharedAxes)) {
        r.sharedAxes = e.sharedAxes;
      } else {
        if (typeof e.sharedAxes != "number") {
          throw new Cse(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);
        }
        r.sharedAxes = [e.sharedAxes];
      }
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        var t = (e = hce(e)).slice(1);
        if (this.sharedAxes != null) {
          var n;
          var r = O(this.sharedAxes);
          try {
            for (r.s(); !(n = r.n()).done;) {
              t[n.value - 1] = 1;
            }
          } catch (e) {
            r.e(e);
          } finally {
            r.f();
          }
        }
        this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
        var a = {};
        if (this.sharedAxes != null) {
          for (var i = 1; i < e.length; ++i) {
            a[i] = e[i];
          }
        }
        this.inputSpec = [new gce({
          ndim: e.length,
          axes: a
        })];
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        e = lce(e);
        return bee(e, this.alpha.read());
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          alphaInitializer: oce(this.alphaInitializer),
          alphaRegularizer: qhe(this.alphaRegularizer),
          alphaConstraint: Wce(this.alphaConstraint),
          sharedAxes: this.sharedAxes
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Zhe.className = "PReLU";
  Kre(Zhe);
  var Qhe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e == null ? {} : e)).DEFAULT_ALPHA = 1;
      if (e == null) {
        e = {};
      }
      if (e.alpha != null && e.alpha !== r.DEFAULT_ALPHA) {
        throw new Ase(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);
      }
      r.alpha = e.alpha == null ? r.DEFAULT_ALPHA : e.alpha;
      return r;
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var n = lce(e);
        return H7(n);
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          alpha: this.alpha
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Qhe.className = "ELU";
  Kre(Qhe);
  var $he = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e == null ? {} : e)).DEFAULT_THETA = 1;
      if (e == null) {
        e = {};
      }
      r.theta = e.theta == null ? r.DEFAULT_THETA : e.theta;
      return r;
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var n = lce(e);
        return g8(n, h8(b9(n, this.theta), "float32"));
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          theta: this.theta
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  $he.className = "ThresholdedReLU";
  Kre($he);
  var epe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e == null ? {} : e)).DEFAULT_AXIS = 1;
      if (e == null) {
        e = {};
      }
      r.softmax = new Mhe().apply;
      r.axis = e.axis == null ? r.DEFAULT_AXIS : e.axis;
      return r;
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r = lce(e);
          var a = t.mask;
          if (a != null) {
            var i = g8(P9(eee(r.shape), h8(a, r.dtype)), i9(-1000000000));
            r = d8(r, i);
          }
          if (n.axis instanceof Array) {
            if (n.axis.length > 1) {
              return p9(P9(r, W9(r, n.axis, true)));
            } else {
              return n.softmax(r, n.axis[0]);
            }
          } else {
            return n.softmax(r, n.axis);
          }
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          axis: this.axis
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  function tpe(e, t, n) {
    if (typeof e == "number") {
      return Ose(e, t);
    }
    if (e.length !== t) {
      throw new Cse(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);
    }
    for (var r = 0; r < t; ++r) {
      var a = e[r];
      if ((i = a) !== parseInt(i.toString(), 10)) {
        throw new Cse(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`);
      }
    }
    return e;
    var i;
  }
  function npe(e, t, n, r, a = 1) {
    if (e == null) {
      return e;
    }
    var i;
    var o = t + (t - 1) * (a - 1);
    i = n === "same" ? e : e - o + 1;
    return Math.floor((i + r - 1) / r);
  }
  function rpe(e, t, n, r) {
    if (e == null) {
      return null;
    }
    if (r === "valid") {
      e = e * t + bue([n - t, 0]);
    } else {
      if (r !== "same") {
        throw new Cse(`Unsupport padding mode: ${r}.`);
      }
      e *= t;
    }
    return e;
  }
  function ape(e, t) {
    return X5(function () {
      sue(t);
      if (t === "channelsFirst") {
        return hne(e, [0, 2, 3, 1]);
      } else {
        return e;
      }
    });
  }
  function ipe(e, t) {
    return X5(function () {
      sue(t);
      if (t === "channelsFirst") {
        return hne(e, [0, 2, 3, 4, 1]);
      } else {
        return e;
      }
    });
  }
  function ope(e, t, n, r = 1, a = "valid", i, o = 1) {
    return X5(function () {
      if (i == null) {
        i = "channelsLast";
      }
      sue(i);
      if (e.shape.length !== 3) {
        throw new Cse(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);
      }
      if (t.shape.length !== 3) {
        throw new Cse(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);
      }
      if (n != null && n.shape.length !== 1) {
        throw new Cse(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);
      }
      if (i === "channelsFirst") {
        e = hne(e, [0, 2, 1]);
      }
      if (a === "causal") {
        throw new Ase("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      }
      var s = x7(e, t, r, a === "same" ? "same" : "valid", "NWC", o);
      if (n != null) {
        s = Lue(s, n);
      }
      return s;
    });
  }
  function spe(e, t, n, r = [1, 1], a = "valid", i, o, s = null) {
    return X5(function () {
      if (i == null) {
        i = "channelsLast";
      }
      sue(i);
      if (e.rank !== 3 && e.rank !== 4) {
        throw new Cse(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);
      }
      if (t.rank !== 3 && t.rank !== 4) {
        throw new Cse(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);
      }
      var u = ape(e, i);
      if (a === "causal") {
        throw new Ase("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      }
      u = Ene({
        x: u,
        filter: t,
        strides: r,
        pad: a === "same" ? "same" : "valid",
        dilations: o,
        dataFormat: "NHWC",
        bias: n,
        activation: s
      });
      if (i === "channelsFirst") {
        u = hne(u, [0, 3, 1, 2]);
      }
      return u;
    });
  }
  function upe(e, t, n, r = [1, 1, 1], a = "valid", i, o) {
    return X5(function () {
      if (i == null) {
        i = "channelsLast";
      }
      sue(i);
      if (e.rank !== 4 && e.rank !== 5) {
        throw new Cse(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);
      }
      if (t.rank !== 4 && t.rank !== 5) {
        throw new Cse(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);
      }
      var s = ipe(e, i);
      if (a === "causal") {
        throw new Ase("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
      }
      s = I7(s, t, r, a === "same" ? "same" : "valid", "NDHWC", o);
      if (n != null) {
        s = Lue(s, n);
      }
      if (i === "channelsFirst") {
        s = hne(s, [0, 4, 1, 2, 3]);
      }
      return s;
    });
  }
  epe.className = "Softmax";
  Kre(epe);
  var cpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e, r) {
      var a;
      l(this, n);
      (a = t.call(this, r)).bias = null;
      a.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      a.DEFAULT_BIAS_INITIALIZER = "zeros";
      n.verifyArgs(r);
      a.rank = e;
      Xse(a.rank, "rank");
      if (a.rank !== 1 && a.rank !== 2 && a.rank !== 3) {
        throw new Ase(`Convolution layer for rank other than 1, 2, or 3 (${a.rank}) is not implemented yet.`);
      }
      a.kernelSize = tpe(r.kernelSize, e, "kernelSize");
      a.strides = tpe(r.strides == null ? 1 : r.strides, e, "strides");
      a.padding = r.padding == null ? "valid" : r.padding;
      uue(a.padding);
      a.dataFormat = r.dataFormat == null ? "channelsLast" : r.dataFormat;
      sue(a.dataFormat);
      a.activation = Uhe(r.activation);
      a.useBias = r.useBias == null || r.useBias;
      a.biasInitializer = sce(r.biasInitializer || a.DEFAULT_BIAS_INITIALIZER);
      a.biasConstraint = Vce(r.biasConstraint);
      a.biasRegularizer = Xhe(r.biasRegularizer);
      a.activityRegularizer = Xhe(r.activityRegularizer);
      a.dilationRate = tpe(r.dilationRate == null ? 1 : r.dilationRate, e, "dilationRate");
      if (a.rank === 1 && Array.isArray(a.dilationRate) && a.dilationRate.length !== 1) {
        throw new Cse(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(a.dilationRate)}`);
      }
      if (a.rank === 2) {
        if (typeof a.dilationRate == "number") {
          a.dilationRate = [a.dilationRate, a.dilationRate];
        } else if (a.dilationRate.length !== 2) {
          throw new Cse(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(a.dilationRate)}`);
        }
      } else if (a.rank === 3) {
        if (typeof a.dilationRate == "number") {
          a.dilationRate = [a.dilationRate, a.dilationRate, a.dilationRate];
        } else if (a.dilationRate.length !== 3) {
          throw new Cse(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(a.dilationRate)}`);
        }
      }
      return a;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = {
          kernelSize: this.kernelSize,
          strides: this.strides,
          padding: this.padding,
          dataFormat: this.dataFormat,
          dilationRate: this.dilationRate,
          activation: Bhe(this.activation),
          useBias: this.useBias,
          biasInitializer: oce(this.biasInitializer),
          biasRegularizer: qhe(this.biasRegularizer),
          activityRegularizer: qhe(this.activityRegularizer),
          biasConstraint: Wce(this.biasConstraint)
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }], [{
      key: "verifyArgs",
      value: function (e) {
        Fse("kernelSize" in e, "required key 'kernelSize' not in config");
        if (typeof e.kernelSize != "number" && !Kse(e.kernelSize, "number", 1, 3)) {
          throw new Cse(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`);
        }
      }
    }]);
    return n;
  }(wce);
  var lpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e, r) {
      var a;
      l(this, n);
      (a = t.call(this, e, r)).kernel = null;
      n.verifyArgs(r);
      a.filters = r.filters;
      Xse(a.filters, "filters");
      a.kernelInitializer = sce(r.kernelInitializer || a.DEFAULT_KERNEL_INITIALIZER);
      a.kernelConstraint = Vce(r.kernelConstraint);
      a.kernelRegularizer = Xhe(r.kernelRegularizer);
      return a;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        e = hce(e);
        var t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
        if (e[t] == null) {
          throw new Cse(`The channel dimension of the input should be defined. Found ${e[t]}`);
        }
        var n = e[t];
        var r = this.kernelSize.concat([n, this.filters]);
        this.kernel = this.addWeight("kernel", r, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [{
          ndim: this.rank + 2,
          axes: f({}, t, n)
        }];
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t;
          e = lce(e);
          var r = n.bias == null ? null : n.bias.read();
          var a = Jse(n.activation.getClassName());
          if (a != null && n.rank === 2) {
            t = spe(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, a);
          } else {
            if (n.rank === 1) {
              t = ope(e, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);
            } else if (n.rank === 2) {
              t = spe(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
            } else {
              if (n.rank !== 3) {
                throw new Ase("convolutions greater than 3D are not implemented yet.");
              }
              t = upe(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
            }
            if (n.activation != null) {
              t = n.activation.apply(t);
            }
          }
          return t;
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        e = hce(e);
        var t = [];
        for (var n = this.dataFormat === "channelsLast" ? e.slice(1, e.length - 1) : e.slice(2), r = 0; r < n.length; ++r) {
          var a = npe(n[r], this.kernelSize[r], this.padding, this.strides[r], typeof this.dilationRate == "number" ? this.dilationRate : this.dilationRate[r]);
          t.push(a);
        }
        var i = [e[0]];
        if (this.dataFormat === "channelsLast") {
          (i = i.concat(t)).push(this.filters);
        } else {
          i.push(this.filters);
          i = i.concat(t);
        }
        return i;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          filters: this.filters,
          kernelInitializer: oce(this.kernelInitializer),
          kernelRegularizer: qhe(this.kernelRegularizer),
          kernelConstraint: Wce(this.kernelConstraint)
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }], [{
      key: "verifyArgs",
      value: function (e) {
        if (!("filters" in e) || typeof e.filters != "number" || e.filters < 1) {
          throw new Cse(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`);
        }
      }
    }]);
    return n;
  }(cpe);
  var hpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, 2, e);
      n.verifyArgs(e);
      return r;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        delete e.rank;
        return e;
      }
    }], [{
      key: "verifyArgs",
      value: function (e) {
        if (typeof e.kernelSize != "number" && !Kse(e.kernelSize, "number", 1, 2)) {
          throw new Cse(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`);
        }
      }
    }]);
    return n;
  }(lpe);
  hpe.className = "Conv2D";
  Kre(hpe);
  var ppe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, 3, e);
      n.verifyArgs(e);
      return r;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        delete e.rank;
        return e;
      }
    }], [{
      key: "verifyArgs",
      value: function (e) {
        if (typeof e.kernelSize != "number" && (!Array.isArray(e.kernelSize) || e.kernelSize.length !== 1 && e.kernelSize.length !== 3)) {
          throw new Cse(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`);
        }
      }
    }]);
    return n;
  }(lpe);
  ppe.className = "Conv3D";
  Kre(ppe);
  var fpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).inputSpec = [new gce({
        ndim: 4
      })];
      if (r.padding !== "same" && r.padding !== "valid") {
        throw new Cse(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${r.padding}`);
      }
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        if ((e = hce(e)).length !== 4) {
          throw new Cse("Input should have rank 4; Received input shape: " + JSON.stringify(e));
        }
        var t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
        if (e[t] == null) {
          throw new Cse("The channel dimension of the inputs should be defined. Found `None`.");
        }
        var n = e[t];
        var r = this.kernelSize.concat([this.filters, n]);
        this.kernel = this.addWeight("kernel", r, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [new gce({
          ndim: 4,
          axes: f({}, t, n)
        })];
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = lce(e);
          if (t.shape.length !== 4) {
            throw new Cse(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);
          }
          var r;
          var a;
          var i = t.shape;
          var o = i[0];
          if (n.dataFormat === "channelsFirst") {
            r = 2;
            a = 3;
          } else {
            r = 1;
            a = 2;
          }
          var s = i[r];
          var u = i[a];
          var c = n.kernelSize[0];
          var l = n.kernelSize[1];
          var h = n.strides[0];
          var p = n.strides[1];
          var f = [o, rpe(s, h, c, n.padding), rpe(u, p, l, n.padding), n.filters];
          if (n.dataFormat !== "channelsLast") {
            t = hne(t, [0, 2, 3, 1]);
          }
          var d = w7(t, n.kernel.read(), f, n.strides, n.padding);
          if (n.dataFormat !== "channelsLast") {
            d = hne(d, [0, 3, 1, 2]);
          }
          if (n.bias != null) {
            d = Lue(d, n.bias.read(), n.dataFormat);
          }
          if (n.activation != null) {
            d = n.activation.apply(d);
          }
          return d;
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t;
        var n;
        var r;
        var a = (e = hce(e)).slice();
        if (this.dataFormat === "channelsFirst") {
          t = 1;
          n = 2;
          r = 3;
        } else {
          t = 3;
          n = 1;
          r = 2;
        }
        var i = this.kernelSize[0];
        var o = this.kernelSize[1];
        var s = this.strides[0];
        var u = this.strides[1];
        a[t] = this.filters;
        a[n] = rpe(a[n], s, i, this.padding);
        a[r] = rpe(a[r], u, o, this.padding);
        return a;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        delete e.dilationRate;
        return e;
      }
    }]);
    return n;
  }(hpe);
  fpe.className = "Conv2DTranspose";
  Kre(fpe);
  var dpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).inputSpec = [new gce({
        ndim: 5
      })];
      if (r.padding !== "same" && r.padding !== "valid") {
        throw new Cse(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${r.padding}`);
      }
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        if ((e = hce(e)).length !== 5) {
          throw new Cse("Input should have rank 5; Received input shape: " + JSON.stringify(e));
        }
        var t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
        if (e[t] == null) {
          throw new Cse("The channel dimension of the inputs should be defined. Found `None`.");
        }
        var n = e[t];
        var r = this.kernelSize.concat([this.filters, n]);
        this.kernel = this.addWeight("kernel", r, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [new gce({
          ndim: 5,
          axes: f({}, t, n)
        })];
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = lce(e);
          if (t.shape.length !== 5) {
            throw new Cse(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);
          }
          var r;
          var a;
          var i;
          var o = t.shape;
          var s = o[0];
          if (n.dataFormat === "channelsFirst") {
            i = 2;
            r = 3;
            a = 4;
          } else {
            i = 1;
            r = 2;
            a = 3;
          }
          var u = o[i];
          var c = o[r];
          var l = o[a];
          var h = n.kernelSize[0];
          var p = n.kernelSize[1];
          var f = n.kernelSize[2];
          var d = n.strides[0];
          var v = n.strides[1];
          var m = n.strides[2];
          var g = [s, rpe(u, d, h, n.padding), rpe(c, v, p, n.padding), rpe(l, m, f, n.padding), n.filters];
          if (n.dataFormat !== "channelsLast") {
            t = hne(t, [0, 2, 3, 4, 1]);
          }
          var y = S7(t, n.kernel.read(), g, n.strides, n.padding);
          if (n.dataFormat !== "channelsLast") {
            y = hne(y, [0, 4, 1, 2, 3]);
          }
          if (n.bias !== null) {
            y = Lue(y, n.bias.read(), n.dataFormat);
          }
          if (n.activation !== null) {
            y = n.activation.apply(y);
          }
          return y;
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t;
        var n;
        var r;
        var a;
        var i = (e = hce(e)).slice();
        if (this.dataFormat === "channelsFirst") {
          t = 1;
          n = 2;
          r = 3;
          a = 4;
        } else {
          t = 4;
          n = 1;
          r = 2;
          a = 3;
        }
        var o = this.kernelSize[0];
        var s = this.kernelSize[1];
        var u = this.kernelSize[2];
        var c = this.strides[0];
        var l = this.strides[1];
        var h = this.strides[2];
        i[t] = this.filters;
        i[n] = rpe(i[n], c, o, this.padding);
        i[r] = rpe(i[r], l, s, this.padding);
        i[a] = rpe(i[a], h, u, this.padding);
        return i;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        delete e.dilationRate;
        return e;
      }
    }]);
    return n;
  }(ppe);
  dpe.className = "Conv3DTranspose";
  Kre(dpe);
  var vpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e, r) {
      var a;
      l(this, n);
      (a = t.call(this, e, r)).DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform";
      a.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform";
      a.depthwiseKernel = null;
      a.pointwiseKernel = null;
      if (r.filters == null) {
        throw new Cse("The `filters` configuration field is required by SeparableConv, but is unspecified.");
      }
      if (r.kernelInitializer != null || r.kernelRegularizer != null || r.kernelConstraint != null) {
        throw new Cse("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
      }
      if (r.padding != null && r.padding !== "same" && r.padding !== "valid") {
        throw new Cse(`SeparableConv${a.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);
      }
      a.depthMultiplier = r.depthMultiplier == null ? 1 : r.depthMultiplier;
      a.depthwiseInitializer = sce(r.depthwiseInitializer || a.DEFAULT_DEPTHWISE_INITIALIZER);
      a.depthwiseRegularizer = Xhe(r.depthwiseRegularizer);
      a.depthwiseConstraint = Vce(r.depthwiseConstraint);
      a.pointwiseInitializer = sce(r.depthwiseInitializer || a.DEFAULT_POINTWISE_INITIALIZER);
      a.pointwiseRegularizer = Xhe(r.pointwiseRegularizer);
      a.pointwiseConstraint = Vce(r.pointwiseConstraint);
      return a;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        if ((e = hce(e)).length < this.rank + 2) {
          throw new Cse(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(e)}`);
        }
        var t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
        if (e[t] == null || e[t] < 0) {
          throw new Cse(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);
        }
        var n = e[t];
        var r = this.kernelSize.concat([n, this.depthMultiplier]);
        var a = [];
        for (var i = 0; i < this.rank; ++i) {
          a.push(1);
        }
        a.push(n * this.depthMultiplier, this.filters);
        var o = true;
        this.depthwiseKernel = this.addWeight("depthwise_kernel", r, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, o, this.depthwiseConstraint);
        this.pointwiseKernel = this.addWeight("pointwise_kernel", a, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, o, this.pointwiseConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, o, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.inputSpec = [new gce({
          ndim: this.rank + 2,
          axes: f({}, t, n)
        })];
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t;
          e = lce(e);
          if (n.rank === 1) {
            throw new Ase("1D separable convolution is not implemented yet.");
          }
          if (n.rank === 2) {
            if (n.dataFormat === "channelsFirst") {
              e = hne(e, [0, 2, 3, 1]);
            }
            t = xte(e, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC");
          }
          if (n.useBias) {
            t = Lue(t, n.bias.read(), n.dataFormat);
          }
          if (n.activation != null) {
            t = n.activation.apply(t);
          }
          if (n.dataFormat === "channelsFirst") {
            t = hne(t, [0, 3, 1, 2]);
          }
          return t;
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        delete e.rank;
        delete e.kernelInitializer;
        delete e.kernelRegularizer;
        delete e.kernelConstraint;
        e.depthwiseInitializer = oce(this.depthwiseInitializer);
        e.pointwiseInitializer = oce(this.pointwiseInitializer);
        e.depthwiseRegularizer = qhe(this.depthwiseRegularizer);
        e.pointwiseRegularizer = qhe(this.pointwiseRegularizer);
        e.depthwiseConstraint = Wce(this.depthwiseConstraint);
        e.pointwiseConstraint = Wce(this.pointwiseConstraint);
        return e;
      }
    }]);
    return n;
  }(lpe);
  vpe.className = "SeparableConv";
  var mpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, 2, e);
    }
    return p(n);
  }(vpe);
  mpe.className = "SeparableConv2D";
  Kre(mpe);
  var gpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, 1, e);
      n.verifyArgs(e);
      r.inputSpec = [{
        ndim: 3
      }];
      return r;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        delete e.rank;
        delete e.dataFormat;
        return e;
      }
    }], [{
      key: "verifyArgs",
      value: function (e) {
        if (typeof e.kernelSize != "number" && !Kse(e.kernelSize, "number", 1, 1)) {
          throw new Cse(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`);
        }
      }
    }]);
    return n;
  }(lpe);
  gpe.className = "Conv1D";
  Kre(gpe);
  var ype = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      if (typeof e.cropping == "number") {
        r.cropping = [[e.cropping, e.cropping], [e.cropping, e.cropping]];
      } else if (typeof e.cropping[0] == "number") {
        r.cropping = [[e.cropping[0], e.cropping[0]], [e.cropping[1], e.cropping[1]]];
      } else {
        r.cropping = e.cropping;
      }
      r.dataFormat = e.dataFormat === undefined ? "channelsLast" : e.dataFormat;
      r.inputSpec = [{
        ndim: 4
      }];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        if (this.dataFormat === "channelsFirst") {
          return [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]];
        } else {
          return [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]];
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          e = lce(e);
          if (n.dataFormat === "channelsLast") {
            var t = Eue(e, n.cropping[0][0], e.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2);
            return Eue(t, n.cropping[1][0], e.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3);
          }
          var r = Eue(e, n.cropping[0][0], e.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3);
          return Eue(r, n.cropping[1][0], e.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          cropping: this.cropping,
          dataFormat: this.dataFormat
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  ype.className = "Cropping2D";
  Kre(ype);
  var bpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      var a;
      l(this, n);
      (r = t.call(this, e)).DEFAULT_SIZE = [2, 2];
      r.inputSpec = [{
        ndim: 4
      }];
      r.size = e.size == null ? r.DEFAULT_SIZE : e.size;
      r.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat;
      sue(r.dataFormat);
      r.interpolation = e.interpolation == null ? "nearest" : e.interpolation;
      a = r.interpolation;
      qse(nue, "InterpolationFormat", a);
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        if (this.dataFormat === "channelsFirst") {
          var t = e[2] == null ? null : this.size[0] * e[2];
          var n = e[3] == null ? null : this.size[1] * e[3];
          return [e[0], e[1], t, n];
        }
        var r = e[1] == null ? null : this.size[0] * e[1];
        var a = e[2] == null ? null : this.size[1] * e[2];
        return [e[0], r, a, e[3]];
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = lce(e);
          var r = t.shape;
          if (n.dataFormat === "channelsFirst") {
            t = hne(t, [0, 2, 3, 1]);
            var a = n.size[0] * r[2];
            var i = n.size[1] * r[3];
            var o = n.interpolation === "nearest" ? Pre.resizeNearestNeighbor(t, [a, i]) : Pre.resizeBilinear(t, [a, i]);
            return hne(o, [0, 3, 1, 2]);
          }
          var s = n.size[0] * r[1];
          var u = n.size[1] * r[2];
          if (n.interpolation === "nearest") {
            return Pre.resizeNearestNeighbor(t, [s, u]);
          } else {
            return Pre.resizeBilinear(t, [s, u]);
          }
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          size: this.size,
          dataFormat: this.dataFormat,
          interpolation: this.interpolation
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  bpe.className = "UpSampling2D";
  Kre(bpe);
  var xpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, 2, e)).depthwiseKernel = null;
      r.depthMultiplier = e.depthMultiplier == null ? 1 : e.depthMultiplier;
      r.depthwiseInitializer = sce(e.depthwiseInitializer || r.DEFAULT_KERNEL_INITIALIZER);
      r.depthwiseConstraint = Vce(e.depthwiseConstraint);
      r.depthwiseRegularizer = Xhe(e.depthwiseRegularizer);
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        if ((e = hce(e)).length < 4) {
          throw new Cse(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);
        }
        var t = this.dataFormat === "channelsFirst" ? 1 : 3;
        if (e[t] == null || e[t] < 0) {
          throw new Cse(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);
        }
        var n = e[t];
        var r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
        this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = function (e, t, n = [1, 1], r = "valid", a, i) {
            return X5(function () {
              if (a == null) {
                a = "channelsLast";
              }
              sue(a);
              var o = ape(e, a);
              if (e.rank !== 4) {
                throw new Cse(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);
              }
              if (t.rank !== 4) {
                throw new Cse(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);
              }
              o = O7(o, t, n, r === "same" ? "same" : "valid", "NHWC", i);
              if (a === "channelsFirst") {
                o = hne(o, [0, 3, 1, 2]);
              }
              return o;
            });
          }(e = lce(e), n.depthwiseKernel.read(), n.strides, n.padding, n.dataFormat, null);
          if (n.useBias) {
            t = Lue(t, n.bias.read(), n.dataFormat);
          }
          if (n.activation != null) {
            t = n.activation.apply(t);
          }
          return t;
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        e = hce(e);
        var t = this.dataFormat === "channelsFirst" ? e[2] : e[1];
        var n = this.dataFormat === "channelsFirst" ? e[3] : e[2];
        var r = this.dataFormat === "channelsFirst" ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier;
        var a = npe(t, this.kernelSize[0], this.padding, this.strides[0]);
        var i = npe(n, this.kernelSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === "channelsFirst") {
          return [e[0], r, a, i];
        } else {
          return [e[0], a, i, r];
        }
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        e.depthMultiplier = this.depthMultiplier;
        e.depthwiseInitializer = oce(this.depthwiseInitializer);
        e.depthwiseRegularizer = qhe(this.depthwiseRegularizer);
        e.depthwiseConstraint = Wce(this.depthwiseRegularizer);
        return e;
      }
    }]);
    return n;
  }(cpe);
  function kpe(e, t, n, r) {
    if (Array.isArray(e)) {
      if (t != null || n != null) {
        throw new Cse("When inputs is an array, neither initialState or constants should be provided");
      }
      if (r != null) {
        n = e.slice(e.length - r, e.length);
        e = e.slice(0, e.length - r);
      }
      if (e.length > 1) {
        t = e.slice(1, e.length);
      }
      e = e[0];
    }
    function a(e) {
      if (e == null || Array.isArray(e)) {
        return e;
      } else {
        return [e];
      }
    }
    return {
      inputs: e,
      initialState: t = a(t),
      constants: n = a(n)
    };
  }
  function wpe(e, t, n, r = false, a, i, o = false, s = false) {
    return X5(function () {
      var u = t.shape.length;
      if (u < 3) {
        throw new Cse(`Input should be at least 3D, but is ${u}D.`);
      }
      var c = [1, 0].concat(xue(2, u));
      t = hne(t, c);
      if (i != null) {
        throw new Ase("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
      }
      if (o) {
        console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend.");
      }
      if (a != null) {
        if ((a = h8(h8(a, "bool"), "float32")).rank === u - 1) {
          a = f9(a, -1);
        }
        a = hne(a, c);
      }
      if (r) {
        t = pte(t, 0);
        if (a != null) {
          a = pte(a, 0);
        }
      }
      var l;
      var h;
      var p = [];
      var f = n;
      var d = t.shape[0];
      var v = rne(t);
      if (a != null) {
        h = rne(a);
      }
      var m;
      var g = function (t) {
        var n = v[t];
        var r = X5(function () {
          return e(n, f);
        });
        if (a == null) {
          l = r[0];
          f = r[1];
        } else {
          var i = X5(function () {
            var e = h[t];
            var n = P9(lee(e), e);
            return {
              output: d8(g8(r[0], e), g8(f[0], n)),
              newStates: f.map(function (t, a) {
                return d8(g8(r[1][a], e), g8(t, n));
              })
            };
          });
          l = i.output;
          f = i.newStates;
        }
        if (s) {
          p.push(l);
        }
      };
      for (var y = 0; y < d; ++y) {
        g(y);
      }
      if (s) {
        m = Pte(p, 1);
      }
      return [l, m, f];
    });
  }
  xpe.className = "DepthwiseConv2D";
  Kre(xpe);
  var Ipe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      var a;
      l(this, n);
      r = t.call(this, e);
      if (e.cell == null) {
        throw new Cse("cell property is missing for the constructor of RNN.");
      }
      if ((a = Array.isArray(e.cell) ? new _pe({
        cells: e.cell
      }) : e.cell).stateSize == null) {
        throw new Cse("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      }
      r.cell = a;
      r.returnSequences = e.returnSequences != null && e.returnSequences;
      r.returnState = e.returnState != null && e.returnState;
      r.goBackwards = e.goBackwards != null && e.goBackwards;
      r._stateful = e.stateful != null && e.stateful;
      r.unroll = e.unroll != null && e.unroll;
      r.supportsMasking = true;
      r.inputSpec = [new gce({
        ndim: 3
      })];
      r.stateSpec = null;
      r.states_ = null;
      r.numConstants = null;
      r.keptStates = [];
      return r;
    }
    p(n, [{
      key: "getStates",
      value: function () {
        if (this.states_ == null) {
          return xue(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function (e) {
            return null;
          });
        } else {
          return this.states_;
        }
      }
    }, {
      key: "setStates",
      value: function (e) {
        this.states_ = e;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        if (uce(e)) {
          e = e[0];
        }
        var t = this.cell.stateSize;
        if (!Array.isArray(t)) {
          t = [t];
        }
        var n;
        var r = t[0];
        n = this.returnSequences ? [e[0], e[1], r] : [e[0], r];
        if (this.returnState) {
          var a;
          var i = [];
          var o = O(t);
          try {
            for (o.s(); !(a = o.n()).done;) {
              var s = a.value;
              i.push([e[0], s]);
            }
          } catch (e) {
            o.e(e);
          } finally {
            o.f();
          }
          return [n].concat(i);
        }
        return n;
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (Array.isArray(t)) {
            t = t[0];
          }
          var e = n.returnSequences ? t : null;
          if (n.returnState) {
            var r = n.states.map(function (e) {
              return null;
            });
            return [e].concat(r);
          }
          return e;
        });
      }
    }, {
      key: "states",
      get: function () {
        if (this.states_ == null) {
          for (var e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [], n = 0; n < e; ++n) {
            t.push(null);
          }
          return t;
        }
        return this.states_;
      },
      set: function (e) {
        this.states_ = e;
      }
    }, {
      key: "build",
      value: function (e) {
        if (this.numConstants != null) {
          throw new Ase("Constants support is not implemented in RNN yet.");
        }
        if (uce(e)) {
          e = e[0];
        }
        var t = this.stateful ? e[0] : null;
        var n = e.slice(2);
        this.inputSpec[0] = new gce({
          shape: [t, null].concat(T(n))
        });
        var r;
        var a = [e[0]].concat(e.slice(2));
        this.cell.build(a);
        r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize];
        if (this.stateSpec != null) {
          if (!P$(this.stateSpec.map(function (e) {
            return e.shape[e.shape.length - 1];
          }), r)) {
            throw new Cse(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
          }
        } else {
          this.stateSpec = r.map(function (e) {
            return new gce({
              shape: [null, e]
            });
          });
        }
        if (this.stateful) {
          this.resetStates();
        }
      }
    }, {
      key: "resetStates",
      value: function (e) {
        var t = this;
        var n = arguments.length > 1 && arguments[1] !== undefined && arguments[1];
        X5(function () {
          if (!t.stateful) {
            throw new Tse("Cannot call resetStates() on an RNN Layer that is not stateful.");
          }
          var r = t.inputSpec[0].shape[0];
          if (r == null) {
            throw new Cse("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
          }
          if (t.states_ == null) {
            if (Array.isArray(t.cell.stateSize)) {
              t.states_ = t.cell.stateSize.map(function (e) {
                return $9([r, e]);
              });
            } else {
              t.states_ = [$9([r, t.cell.stateSize])];
            }
          } else if (e == null) {
            Y5(t.states_);
            if (t.keptStates != null) {
              Y5(t.keptStates);
              t.keptStates = [];
            }
            if (Array.isArray(t.cell.stateSize)) {
              t.states_ = t.cell.stateSize.map(function (e) {
                return $9([r, e]);
              });
            } else {
              t.states_[0] = $9([r, t.cell.stateSize]);
            }
          } else {
            if (!Array.isArray(e)) {
              e = [e];
            }
            if (e.length !== t.states_.length) {
              throw new Cse(`Layer ${t.name} expects ${t.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
            }
            if (n === true) {
              t.keptStates.push(t.states_.slice());
            } else {
              Y5(t.states_);
            }
            for (var a = 0; a < t.states_.length; ++a) {
              var i = e[a];
              var o = Array.isArray(t.cell.stateSize) ? t.cell.stateSize[a] : t.cell.stateSize;
              var s = [r, o];
              if (!P$(i.shape, s)) {
                throw new Cse(`State ${a} is incompatible with layer ${t.name}: expected shape=${s}, received shape=${i.shape}`);
              }
              t.states_[a] = i;
            }
          }
          t.states_ = t.states_.map(function (e) {
            return J5(e.clone());
          });
        });
      }
    }, {
      key: "apply",
      value: function (e, t) {
        var r = t == null ? null : t.initialState;
        var a = t == null ? null : t.constants;
        if (t == null) {
          t = {};
        }
        var i = kpe(e, r, a, this.numConstants);
        e = i.inputs;
        r = i.initialState;
        a = i.constants;
        var o = [];
        var s = [];
        if (r != null) {
          t.initialState = r;
          o = o.concat(r);
          this.stateSpec = [];
          var u;
          var c = O(r);
          try {
            for (c.s(); !(u = c.n()).done;) {
              var l = u.value;
              this.stateSpec.push(new gce({
                shape: l.shape
              }));
            }
          } catch (e) {
            c.e(e);
          } finally {
            c.f();
          }
          s = s.concat(this.stateSpec);
        }
        if (a != null) {
          t.constants = a;
          o = o.concat(a);
          this.numConstants = a.length;
        }
        if (o[0] instanceof yce) {
          var h = [e].concat(o);
          var p = this.inputSpec.concat(s);
          var f = this.inputSpec;
          this.inputSpec = p;
          var d = N(v(n.prototype), "apply", this).call(this, h, t);
          this.inputSpec = f;
          return d;
        }
        return N(v(n.prototype), "apply", this).call(this, e, t);
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r = t == null ? null : t.mask;
          var a = t == null ? null : t.training;
          var i = t == null ? null : t.initialState;
          e = lce(e);
          if (i == null) {
            i = n.stateful ? n.states_ : n.getInitialState(e);
          }
          var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
          if (i.length !== o) {
            throw new Cse(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);
          }
          if (n.unroll) {
            console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
          }
          var s = {
            training: a
          };
          var u = wpe(function (e, t) {
            var r = n.cell.call([e].concat(t), s);
            return [r[0], r.slice(1)];
          }, e, i, n.goBackwards, r, null, n.unroll, n.returnSequences);
          var c = u[0];
          var l = u[1];
          var h = u[2];
          if (n.stateful) {
            n.resetStates(h, a);
          }
          var p = n.returnSequences ? l : c;
          if (n.returnState) {
            return [p].concat(h);
          } else {
            return p;
          }
        });
      }
    }, {
      key: "getInitialState",
      value: function (e) {
        var t = this;
        return X5(function () {
          var n = $9(e.shape);
          n = Iue(n = u9(n, [1, 2]));
          if (Array.isArray(t.cell.stateSize)) {
            return t.cell.stateSize.map(function (e) {
              if (e > 1) {
                return Rue(n, [1, e]);
              } else {
                return n;
              }
            });
          } else if (t.cell.stateSize > 1) {
            return [Rue(n, [1, t.cell.stateSize])];
          } else {
            return [n];
          }
        });
      }
    }, {
      key: "trainableWeights",
      get: function () {
        if (this.trainable) {
          return this.cell.trainableWeights;
        } else {
          return [];
        }
      }
    }, {
      key: "nonTrainableWeights",
      get: function () {
        if (this.trainable) {
          return this.cell.nonTrainableWeights;
        } else {
          return this.cell.weights;
        }
      }
    }, {
      key: "setFastWeightInitDuringBuild",
      value: function (e) {
        N(v(n.prototype), "setFastWeightInitDuringBuild", this).call(this, e);
        if (this.cell != null) {
          this.cell.setFastWeightInitDuringBuild(e);
        }
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          returnSequences: this.returnSequences,
          returnState: this.returnState,
          goBackwards: this.goBackwards,
          stateful: this.stateful,
          unroll: this.unroll
        };
        if (this.numConstants != null) {
          t.numConstants = this.numConstants;
        }
        var r = this.cell.getConfig();
        if (this.getClassName() === n.className) {
          t.cell = {
            className: this.cell.getClassName(),
            config: r
          };
        }
        return Object.assign(Object.assign(Object.assign({}, r), e), t);
      }
    }], [{
      key: "fromConfig",
      value: function (e, t, n = {}) {
        var r = t.cell;
        var a = rle(r, n);
        return new e(Object.assign(t, {
          cell: a
        }));
      }
    }]);
    return n;
  }(wce);
  Ipe.className = "RNN";
  Kre(Ipe);
  var Npe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    return p(n);
  }(wce);
  var Spe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).DEFAULT_ACTIVATION = "tanh";
      r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      r.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      r.DEFAULT_BIAS_INITIALIZER = "zeros";
      r.units = e.units;
      Xse(r.units, "units");
      r.activation = Uhe(e.activation == null ? r.DEFAULT_ACTIVATION : e.activation);
      r.useBias = e.useBias == null || e.useBias;
      r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER);
      r.recurrentInitializer = sce(e.recurrentInitializer || r.DEFAULT_RECURRENT_INITIALIZER);
      r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER);
      r.kernelRegularizer = Xhe(e.kernelRegularizer);
      r.recurrentRegularizer = Xhe(e.recurrentRegularizer);
      r.biasRegularizer = Xhe(e.biasRegularizer);
      r.kernelConstraint = Vce(e.kernelConstraint);
      r.recurrentConstraint = Vce(e.recurrentConstraint);
      r.biasConstraint = Vce(e.biasConstraint);
      r.dropout = yue([1, bue([0, e.dropout == null ? 0 : e.dropout])]);
      r.recurrentDropout = yue([1, bue([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])]);
      r.dropoutFunc = e.dropoutFunc;
      r.stateSize = r.units;
      r.dropoutMask = null;
      r.recurrentDropoutMask = null;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        e = hce(e);
        this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (e.length !== 2) {
            throw new Cse(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);
          }
          var r = e[1];
          e = e[0];
          var a;
          var i = t.training != null && t.training;
          if (n.dropout > 0 && n.dropout < 1 && n.dropoutMask == null) {
            n.dropoutMask = Ope({
              ones: function () {
                return lee(e);
              },
              rate: n.dropout,
              training: i,
              dropoutFunc: n.dropoutFunc
            });
          }
          if (n.recurrentDropout > 0 && n.recurrentDropout < 1 && n.recurrentDropoutMask == null) {
            n.recurrentDropoutMask = Ope({
              ones: function () {
                return lee(r);
              },
              rate: n.recurrentDropout,
              training: i,
              dropoutFunc: n.dropoutFunc
            });
          }
          var o = n.dropoutMask;
          var s = n.recurrentDropoutMask;
          a = Oue(o != null ? g8(e, o) : e, n.kernel.read());
          if (n.bias != null) {
            a = Lue(a, n.bias.read());
          }
          if (s != null) {
            r = g8(r, s);
          }
          var u = d8(a, Oue(r, n.recurrentKernel.read()));
          if (n.activation != null) {
            u = n.activation.apply(u);
          }
          return [u, u];
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          units: this.units,
          activation: Bhe(this.activation),
          useBias: this.useBias,
          kernelInitializer: oce(this.kernelInitializer),
          recurrentInitializer: oce(this.recurrentInitializer),
          biasInitializer: oce(this.biasInitializer),
          kernelRegularizer: qhe(this.kernelRegularizer),
          recurrentRegularizer: qhe(this.recurrentRegularizer),
          biasRegularizer: qhe(this.biasRegularizer),
          activityRegularizer: qhe(this.activityRegularizer),
          kernelConstraint: Wce(this.kernelConstraint),
          recurrentConstraint: Wce(this.recurrentConstraint),
          biasConstraint: Wce(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout
        };
        return Object.assign(Object.assign({}, e), t);
      }
    }]);
    return n;
  }(Npe);
  Spe.className = "SimpleRNNCell";
  Kre(Spe);
  var Tpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      e.cell = new Spe(e);
      return t.call(this, e);
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var r = this;
        return X5(function () {
          if (r.cell.dropoutMask != null) {
            Y5(r.cell.dropoutMask);
            r.cell.dropoutMask = null;
          }
          if (r.cell.recurrentDropoutMask != null) {
            Y5(r.cell.recurrentDropoutMask);
            r.cell.recurrentDropoutMask = null;
          }
          var a = t == null ? null : t.mask;
          var i = t == null ? null : t.training;
          var o = t == null ? null : t.initialState;
          return N(v(n.prototype), "call", r).call(r, e, {
            mask: a,
            training: i,
            initialState: o
          });
        });
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        return new e(t);
      }
    }]);
    return n;
  }(Ipe);
  Tpe.className = "SimpleRNN";
  Kre(Tpe);
  var Epe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).DEFAULT_ACTIVATION = "tanh";
      r.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
      r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      r.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      r.DEFAULT_BIAS_INITIALIZER = "zeros";
      if (e.resetAfter) {
        throw new Cse("GRUCell does not support reset_after parameter set to true.");
      }
      r.units = e.units;
      Xse(r.units, "units");
      r.activation = Uhe(e.activation === undefined ? r.DEFAULT_ACTIVATION : e.activation);
      r.recurrentActivation = Uhe(e.recurrentActivation === undefined ? r.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation);
      r.useBias = e.useBias == null || e.useBias;
      r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER);
      r.recurrentInitializer = sce(e.recurrentInitializer || r.DEFAULT_RECURRENT_INITIALIZER);
      r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER);
      r.kernelRegularizer = Xhe(e.kernelRegularizer);
      r.recurrentRegularizer = Xhe(e.recurrentRegularizer);
      r.biasRegularizer = Xhe(e.biasRegularizer);
      r.kernelConstraint = Vce(e.kernelConstraint);
      r.recurrentConstraint = Vce(e.recurrentConstraint);
      r.biasConstraint = Vce(e.biasConstraint);
      r.dropout = yue([1, bue([0, e.dropout == null ? 0 : e.dropout])]);
      r.recurrentDropout = yue([1, bue([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])]);
      r.dropoutFunc = e.dropoutFunc;
      r.implementation = e.implementation;
      r.stateSize = r.units;
      r.dropoutMask = null;
      r.recurrentDropoutMask = null;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        var t = (e = hce(e))[e.length - 1];
        this.kernel = this.addWeight("kernel", [t, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (e.length !== 2) {
            throw new Cse(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);
          }
          var r = t.training != null && t.training;
          var a = e[1];
          e = e[0];
          if (n.dropout > 0 && n.dropout < 1 && n.dropoutMask == null) {
            n.dropoutMask = Ope({
              ones: function () {
                return lee(e);
              },
              rate: n.dropout,
              training: r,
              count: 3,
              dropoutFunc: n.dropoutFunc
            });
          }
          if (n.recurrentDropout > 0 && n.recurrentDropout < 1 && n.recurrentDropoutMask == null) {
            n.recurrentDropoutMask = Ope({
              ones: function () {
                return lee(a);
              },
              rate: n.recurrentDropout,
              training: r,
              count: 3,
              dropoutFunc: n.dropoutFunc
            });
          }
          var i;
          var o;
          var s;
          var u = n.dropoutMask;
          var c = n.recurrentDropoutMask;
          if (n.dropout > 0 && n.dropout < 1) {
            e = g8(e, u[0]);
          }
          var l = Oue(e, n.kernel.read());
          if (n.useBias) {
            l = Lue(l, n.bias.read());
          }
          if (n.recurrentDropout > 0 && n.recurrentDropout < 1) {
            a = g8(a, c[0]);
          }
          var h = n.recurrentKernel.read();
          var p = S(Dte(h, [n.units * 2, n.units], h.rank - 1), 2);
          var f = p[0];
          var d = p[1];
          var v = Oue(a, f);
          var m = S(Dte(l, 3, l.rank - 1), 3);
          var g = m[0];
          var y = m[1];
          var b = m[2];
          var x = S(Dte(v, 2, v.rank - 1), 2);
          var k = x[0];
          var w = x[1];
          i = n.recurrentActivation.apply(d8(g, k));
          o = n.recurrentActivation.apply(d8(y, w));
          var I = Oue(g8(o, a), d);
          s = n.activation.apply(d8(b, I));
          var N = d8(g8(i, a), g8(d8(1, M9(i)), s));
          return [N, N];
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          units: this.units,
          activation: Bhe(this.activation),
          recurrentActivation: Bhe(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: oce(this.kernelInitializer),
          recurrentInitializer: oce(this.recurrentInitializer),
          biasInitializer: oce(this.biasInitializer),
          kernelRegularizer: qhe(this.kernelRegularizer),
          recurrentRegularizer: qhe(this.recurrentRegularizer),
          biasRegularizer: qhe(this.biasRegularizer),
          activityRegularizer: qhe(this.activityRegularizer),
          kernelConstraint: Wce(this.kernelConstraint),
          recurrentConstraint: Wce(this.recurrentConstraint),
          biasConstraint: Wce(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation,
          resetAfter: false
        };
        return Object.assign(Object.assign({}, e), t);
      }
    }]);
    return n;
  }(Npe);
  Epe.className = "GRUCell";
  Kre(Epe);
  var Cpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      if (e.implementation === 0) {
        console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
      }
      e.cell = new Epe(e);
      return t.call(this, e);
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var r = this;
        return X5(function () {
          if (r.cell.dropoutMask != null) {
            Y5(r.cell.dropoutMask);
            r.cell.dropoutMask = null;
          }
          if (r.cell.recurrentDropoutMask != null) {
            Y5(r.cell.recurrentDropoutMask);
            r.cell.recurrentDropoutMask = null;
          }
          var a = t == null ? null : t.mask;
          var i = t == null ? null : t.training;
          var o = t == null ? null : t.initialState;
          return N(v(n.prototype), "call", r).call(r, e, {
            mask: a,
            training: i,
            initialState: o
          });
        });
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        if (t.implmentation === 0) {
          t.implementation = 1;
        }
        return new e(t);
      }
    }]);
    return n;
  }(Ipe);
  Cpe.className = "GRU";
  Kre(Cpe);
  var Ape = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).DEFAULT_ACTIVATION = "tanh";
      r.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
      r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      r.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      r.DEFAULT_BIAS_INITIALIZER = "zeros";
      r.units = e.units;
      Xse(r.units, "units");
      r.activation = Uhe(e.activation === undefined ? r.DEFAULT_ACTIVATION : e.activation);
      r.recurrentActivation = Uhe(e.recurrentActivation === undefined ? r.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation);
      r.useBias = e.useBias == null || e.useBias;
      r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER);
      r.recurrentInitializer = sce(e.recurrentInitializer || r.DEFAULT_RECURRENT_INITIALIZER);
      r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER);
      r.unitForgetBias = e.unitForgetBias;
      r.kernelRegularizer = Xhe(e.kernelRegularizer);
      r.recurrentRegularizer = Xhe(e.recurrentRegularizer);
      r.biasRegularizer = Xhe(e.biasRegularizer);
      r.kernelConstraint = Vce(e.kernelConstraint);
      r.recurrentConstraint = Vce(e.recurrentConstraint);
      r.biasConstraint = Vce(e.biasConstraint);
      r.dropout = yue([1, bue([0, e.dropout == null ? 0 : e.dropout])]);
      r.recurrentDropout = yue([1, bue([0, e.recurrentDropout == null ? 0 : e.recurrentDropout])]);
      r.dropoutFunc = e.dropoutFunc;
      r.implementation = e.implementation;
      r.stateSize = [r.units, r.units];
      r.dropoutMask = null;
      r.recurrentDropoutMask = null;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        var t;
        var n;
        var r = (e = hce(e))[e.length - 1];
        this.kernel = this.addWeight("kernel", [r, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
          if (this.unitForgetBias) {
            var a = this.biasInitializer;
            var i = this.units;
            n = new (t = function (e) {
              d(n, e);
              var t = w(n);
              function n() {
                l(this, n);
                return t.apply(this, arguments);
              }
              p(n, [{
                key: "apply",
                value: function (e, t) {
                  var n = a.apply([i]);
                  var r = new jue().apply([i]);
                  var o = a.apply([i * 2]);
                  return Aue(Aue(n, r), o);
                }
              }]);
              return n;
            }(Vue), t.className = "CustomInit", t)();
          } else {
            n = this.biasInitializer;
          }
          this.bias = this.addWeight("bias", [this.units * 4], null, n, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r = t.training != null && t.training;
          if (e.length !== 3) {
            throw new Cse(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
          }
          var a = e[1];
          var i = e[2];
          e = e[0];
          if (n.dropout > 0 && n.dropout < 1 && n.dropoutMask == null) {
            n.dropoutMask = Ope({
              ones: function () {
                return lee(e);
              },
              rate: n.dropout,
              training: r,
              count: 4,
              dropoutFunc: n.dropoutFunc
            });
          }
          if (n.recurrentDropout > 0 && n.recurrentDropout < 1 && n.recurrentDropoutMask == null) {
            n.recurrentDropoutMask = Ope({
              ones: function () {
                return lee(a);
              },
              rate: n.recurrentDropout,
              training: r,
              count: 4,
              dropoutFunc: n.dropoutFunc
            });
          }
          var o;
          var s;
          var u;
          var c;
          var l = n.dropoutMask;
          var h = n.recurrentDropoutMask;
          if (n.dropout > 0 && n.dropout < 1) {
            e = g8(e, l[0]);
          }
          var p = Oue(e, n.kernel.read());
          if (n.recurrentDropout > 0 && n.recurrentDropout < 1) {
            a = g8(a, h[0]);
          }
          p = d8(p, Oue(a, n.recurrentKernel.read()));
          if (n.useBias) {
            p = Lue(p, n.bias.read());
          }
          var f = S(Dte(p, 4, p.rank - 1), 4);
          var d = f[0];
          var v = f[1];
          var m = f[2];
          var g = f[3];
          o = n.recurrentActivation.apply(d);
          s = n.recurrentActivation.apply(v);
          u = d8(g8(s, i), g8(o, n.activation.apply(m)));
          c = n.recurrentActivation.apply(g);
          var y = g8(c, n.activation.apply(u));
          return [y, y, u];
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          units: this.units,
          activation: Bhe(this.activation),
          recurrentActivation: Bhe(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: oce(this.kernelInitializer),
          recurrentInitializer: oce(this.recurrentInitializer),
          biasInitializer: oce(this.biasInitializer),
          unitForgetBias: this.unitForgetBias,
          kernelRegularizer: qhe(this.kernelRegularizer),
          recurrentRegularizer: qhe(this.recurrentRegularizer),
          biasRegularizer: qhe(this.biasRegularizer),
          activityRegularizer: qhe(this.activityRegularizer),
          kernelConstraint: Wce(this.kernelConstraint),
          recurrentConstraint: Wce(this.recurrentConstraint),
          biasConstraint: Wce(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation
        };
        return Object.assign(Object.assign({}, e), t);
      }
    }]);
    return n;
  }(Npe);
  Ape.className = "LSTMCell";
  Kre(Ape);
  var Rpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      if (e.implementation === 0) {
        console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
      }
      e.cell = new Ape(e);
      return t.call(this, e);
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var r = this;
        return X5(function () {
          if (r.cell.dropoutMask != null) {
            Y5(r.cell.dropoutMask);
            r.cell.dropoutMask = null;
          }
          if (r.cell.recurrentDropoutMask != null) {
            Y5(r.cell.recurrentDropoutMask);
            r.cell.recurrentDropoutMask = null;
          }
          var a = t == null ? null : t.mask;
          var i = t == null ? null : t.training;
          var o = t == null ? null : t.initialState;
          return N(v(n.prototype), "call", r).call(r, e, {
            mask: a,
            training: i,
            initialState: o
          });
        });
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        if (t.implmentation === 0) {
          t.implementation = 1;
        }
        return new e(t);
      }
    }]);
    return n;
  }(Ipe);
  Rpe.className = "LSTM";
  Kre(Rpe);
  var _pe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).cells = e.cells;
      return r;
    }
    p(n, [{
      key: "stateSize",
      get: function () {
        var e;
        var t = [];
        var n = O(this.cells.slice().reverse());
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            if (Array.isArray(r.stateSize)) {
              t.push.apply(t, T(r.stateSize));
            } else {
              t.push(r.stateSize);
            }
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        return t;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r;
          var a = e.slice(1);
          var i = [];
          var o = O(n.cells.slice().reverse());
          try {
            for (o.s(); !(r = o.n()).done;) {
              var s = r.value;
              if (Array.isArray(s.stateSize)) {
                i.push(a.splice(0, s.stateSize.length));
              } else {
                i.push(a.splice(0, 1));
              }
            }
          } catch (e) {
            o.e(e);
          } finally {
            o.f();
          }
          i.reverse();
          var u;
          var c = [];
          for (var l = 0; l < n.cells.length; ++l) {
            var h = n.cells[l];
            a = i[l];
            u = l === 0 ? [e[0]].concat(a) : [u[0]].concat(a);
            u = h.call(u, t);
            c.push(u.slice(1));
          }
          a = [];
          var p;
          var f = O(c.slice().reverse());
          try {
            for (f.s(); !(p = f.n()).done;) {
              var d;
              var v = p.value;
              (d = a).push.apply(d, T(v));
            }
          } catch (e) {
            f.e(e);
          } finally {
            f.f();
          }
          return [u[0]].concat(a);
        });
      }
    }, {
      key: "build",
      value: function (e) {
        var t;
        if (uce(e)) {
          e = e[0];
        }
        this.cells.forEach(function (n, r) {
          hue(`RNNCell_${r}`, function () {
            n.build(e);
            t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize;
            e = [e[0], t];
          });
        });
        this.built = true;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          cells: this.cells.map(function (e) {
            return {
              className: e.getClassName(),
              config: e.getConfig()
            };
          })
        };
        return Object.assign(Object.assign({}, e), t);
      }
    }, {
      key: "trainableWeights",
      get: function () {
        if (!this.trainable) {
          return [];
        }
        var e;
        var t = [];
        var n = O(this.cells);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            t.push.apply(t, T(r.trainableWeights));
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        return t;
      }
    }, {
      key: "nonTrainableWeights",
      get: function () {
        var e;
        var t = [];
        var n = O(this.cells);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            t.push.apply(t, T(r.nonTrainableWeights));
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        if (!this.trainable) {
          var a;
          var i = [];
          var o = O(this.cells);
          try {
            for (o.s(); !(a = o.n()).done;) {
              var s = a.value;
              i.push.apply(i, T(s.trainableWeights));
            }
          } catch (e) {
            o.e(e);
          } finally {
            o.f();
          }
          return i.concat(t);
        }
        return t;
      }
    }, {
      key: "getWeights",
      value: function () {
        var e;
        var t = [];
        var n = O(this.cells);
        try {
          for (n.s(); !(e = n.n()).done;) {
            var r = e.value;
            t.push.apply(t, T(r.weights));
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        return vce(t);
      }
    }, {
      key: "setWeights",
      value: function (e) {
        var t;
        var n = [];
        var r = O(this.cells);
        try {
          for (r.s(); !(t = r.n()).done;) {
            for (var a = t.value, i = a.weights.length, o = e.splice(i), s = 0; s < a.weights.length; ++s) {
              n.push([a.weights[s], o[s]]);
            }
          }
        } catch (e) {
          r.e(e);
        } finally {
          r.f();
        }
        mce(n);
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        var n;
        var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var a = [];
        var i = O(t.cells);
        try {
          for (i.s(); !(n = i.n()).done;) {
            var o = n.value;
            a.push(rle(o, r));
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
        return new e({
          cells: a
        });
      }
    }]);
    return n;
  }(Npe);
  function Ope(e) {
    var t = e.ones;
    var n = e.rate;
    var r = e.training;
    var a = r !== undefined && r;
    var i = e.count;
    var o = i === undefined ? 1 : i;
    var s = e.dropoutFunc;
    function u() {
      if (s != null) {
        return s(t(), n);
      } else {
        return Pue(t(), n);
      }
    }
    function c() {
      return Bue(u, t, a);
    }
    if (!o || o <= 1) {
      return J5(c().clone());
    } else {
      return Array(o).fill(undefined).map(c).map(function (e) {
        return J5(e.clone());
      });
    }
  }
  _pe.className = "StackedRNNCells";
  Kre(_pe);
  function Fpe(e, t) {
    var n = {};
    for (var r in e) {
      if (Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0) {
        n[r] = e[r];
      }
    }
    if (e != null && typeof Object.getOwnPropertySymbols == "function") {
      var a = 0;
      for (r = Object.getOwnPropertySymbols(e); a < r.length; a++) {
        if (t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a])) {
          n[r[a]] = e[r[a]];
        }
      }
    }
    return n;
  }
  var Dpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      if (e.unroll) {
        throw new Ase("Unrolling is not possible with convolutional RNNs.");
      }
      if (Array.isArray(e.cell)) {
        throw new Ase("It is not possible at the moment to stack convolutional cells.");
      }
      (r = t.call(this, e)).inputSpec = [new gce({
        ndim: 5
      })];
      return r;
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var r = this;
        return X5(function () {
          if (r.cell.dropoutMask != null) {
            Y5(r.cell.dropoutMask);
            r.cell.dropoutMask = null;
          }
          if (r.cell.recurrentDropoutMask != null) {
            Y5(r.cell.recurrentDropoutMask);
            r.cell.recurrentDropoutMask = null;
          }
          if (t && t.constants) {
            throw new Cse("ConvRNN2D cell does not support constants");
          }
          var a = t == null ? null : t.mask;
          var i = t == null ? null : t.training;
          var o = t == null ? null : t.initialState;
          return N(v(n.prototype), "call", r).call(r, e, {
            mask: a,
            training: i,
            initialState: o
          });
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t = this.computeSingleOutputShape(e);
        if (!this.returnSequences) {
          t = [t[0]].concat(T(t.slice(2)));
        }
        if (this.returnState) {
          t = [t].concat(T(Array(2).fill([e[0]].concat(T(t.slice(-3))))));
        }
        return t;
      }
    }, {
      key: "getInitialState",
      value: function (e) {
        var t = this;
        return X5(function () {
          var n = t.cell.stateSize;
          var r = e.shape;
          var a = t.computeSingleOutputShape(r);
          var i = $9([a[0]].concat(T(a.slice(2))));
          if (Array.isArray(n)) {
            return Array(n.length).fill(i);
          } else {
            return [i];
          }
        });
      }
    }, {
      key: "resetStates",
      value: function (e) {
        var t = this;
        var n = arguments.length > 1 && arguments[1] !== undefined && arguments[1];
        X5(function () {
          if (!t.stateful) {
            throw new Tse("Cannot call resetStates() on an RNN Layer that is not stateful.");
          }
          var r = t.inputSpec[0].shape;
          var a = t.computeSingleOutputShape(r);
          var i = [a[0]].concat(T(a.slice(2)));
          if (r[0] == null) {
            throw new Cse("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
          }
          if (t.getStates() == null) {
            if (Array.isArray(t.cell.stateSize)) {
              t.states_ = t.cell.stateSize.map(function () {
                return $9(i);
              });
            } else {
              t.states_ = [$9(i)];
            }
          } else if (e == null) {
            Y5(t.states_);
            if (t.keptStates != null) {
              Y5(t.keptStates);
              t.keptStates = [];
            }
            if (Array.isArray(t.cell.stateSize)) {
              t.states_ = t.cell.stateSize.map(function () {
                return $9(i);
              });
            } else {
              t.states_[0] = $9(i);
            }
          } else {
            if (!Array.isArray(e)) {
              e = [e];
            }
            if (e.length !== t.states_.length) {
              throw new Cse(`Layer ${t.name} expects ${t.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
            }
            if (n) {
              t.keptStates.push(t.states_.slice());
            } else {
              Y5(t.states_);
            }
            for (var o = 0; o < t.states_.length; ++o) {
              var s = e[o];
              var u = i;
              if (!P$(s.shape, u)) {
                throw new Cse(`State ${o} is incompatible with layer ${t.name}: expected shape=${u}, received shape=${s.shape}`);
              }
              t.states_[o] = s;
            }
          }
          t.states_ = t.states_.map(function (e) {
            return J5(e.clone());
          });
        });
      }
    }, {
      key: "computeSingleOutputShape",
      value: function (e) {
        var t = this.cell;
        var n = t.dataFormat;
        var r = t.filters;
        var a = t.kernelSize;
        var i = t.padding;
        var o = t.strides;
        var s = t.dilationRate;
        var u = n === "channelsFirst";
        var c = e[u ? 3 : 2];
        var l = e[u ? 4 : 3];
        var h = npe(c, a[0], i, o[0], s[0]);
        var p = npe(l, a[1], i, o[1], s[1]);
        return [].concat(T(e.slice(0, 2)), T(u ? [r, h, p] : [h, p, r]));
      }
    }]);
    return n;
  }(Ipe);
  Dpe.className = "ConvRNN2D";
  var Mpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      var a = e.filters;
      var i = e.kernelSize;
      var o = e.strides;
      var s = e.padding;
      var u = e.dataFormat;
      var c = e.dilationRate;
      (r = t.call(this, Object.assign(Object.assign({}, e), {
        units: a
      }))).filters = a;
      Xse(r.filters, "filters");
      r.kernelSize = tpe(i, 2, "kernelSize");
      r.kernelSize.forEach(function (e) {
        return Xse(e, "kernelSize");
      });
      r.strides = tpe(o || 1, 2, "strides");
      r.strides.forEach(function (e) {
        return Xse(e, "strides");
      });
      r.padding = s || "valid";
      uue(r.padding);
      r.dataFormat = u || "channelsLast";
      sue(r.dataFormat);
      r.dilationRate = tpe(c || 1, 2, "dilationRate");
      r.dilationRate.forEach(function (e) {
        return Xse(e, "dilationRate");
      });
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        var t;
        e = hce(e);
        var n = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
        if (e[n] == null) {
          throw new Cse(`The channel dimension of the input should be defined. Found ${e[n]}`);
        }
        var r = e[n];
        var a = this.kernelSize.concat([r, this.filters * 4]);
        this.kernel = this.addWeight("kernel", a, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        var i = this.kernelSize.concat([this.filters, this.filters * 4]);
        this.recurrentKernel = this.addWeight("recurrent_kernel", i, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
          var o;
          if (this.unitForgetBias) {
            var s = this.biasInitializer;
            var u = this.filters;
            o = new (t = function (e) {
              d(n, e);
              var t = w(n);
              function n() {
                l(this, n);
                return t.apply(this, arguments);
              }
              p(n, [{
                key: "apply",
                value: function (e, t) {
                  return Cue([s.apply([u]), eee([u]), s.apply([u * 2])]);
                }
              }]);
              return n;
            }(Vue), t.className = "CustomInit", t)();
          } else {
            o = this.biasInitializer;
          }
          this.bias = this.addWeight("bias", [this.filters * 4], null, o, this.biasRegularizer, true, this.biasConstraint);
        }
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (e.length !== 3) {
            throw new Cse(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
          }
          var r = t.training || false;
          var a = e[0];
          var i = e[1];
          var o = e[2];
          if (n.dropout > 0 && n.dropout < 1 && n.dropoutMask == null) {
            n.dropoutMask = Ope({
              ones: function () {
                return lee(a);
              },
              rate: n.dropout,
              training: r,
              count: 4,
              dropoutFunc: n.dropoutFunc
            });
          }
          var s = n.dropoutMask;
          function u(e, t, n) {
            if (t && t[n]) {
              return g8(t[n], e);
            } else {
              return e;
            }
          }
          var c = u(a, s, 0);
          var l = u(a, s, 1);
          var h = u(a, s, 2);
          var p = u(a, s, 3);
          if (n.recurrentDropout > 0 && n.recurrentDropout < 1 && n.recurrentDropoutMask == null) {
            n.recurrentDropoutMask = Ope({
              ones: function () {
                return lee(i);
              },
              rate: n.recurrentDropout,
              training: r,
              count: 4,
              dropoutFunc: n.dropoutFunc
            });
          }
          var f = n.recurrentDropoutMask;
          var d = u(i, f, 0);
          var v = u(i, f, 1);
          var m = u(i, f, 2);
          var g = u(i, f, 3);
          var y = S(Dte(n.kernel.read(), 4, 3), 4);
          var b = y[0];
          var x = y[1];
          var k = y[2];
          var w = y[3];
          var I = S(n.useBias ? Dte(n.bias.read(), 4) : [null, null, null, null], 4);
          var N = I[0];
          var T = I[1];
          var E = I[2];
          var C = I[3];
          c = n.inputConv(c, b, N, n.padding);
          l = n.inputConv(l, x, T, n.padding);
          h = n.inputConv(h, k, E, n.padding);
          p = n.inputConv(p, w, C, n.padding);
          var A = S(Dte(n.recurrentKernel.read(), 4, 3), 4);
          var R = A[0];
          var _ = A[1];
          var O = A[2];
          var F = A[3];
          d = n.recurrentConv(d, R);
          v = n.recurrentConv(v, _);
          m = n.recurrentConv(m, O);
          g = n.recurrentConv(g, F);
          var D = n.recurrentActivation.apply(d8(c, d));
          var M = n.recurrentActivation.apply(d8(l, v));
          var L = d8(g8(M, o), g8(D, n.activation.apply(d8(h, m))));
          var z = g8(n.recurrentActivation.apply(d8(p, g)), n.activation.apply(L));
          return [z, z, L];
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        e.units;
        var t = Fpe(e, ["units"]);
        var r = {
          filters: this.filters,
          kernelSize: this.kernelSize,
          padding: this.padding,
          dataFormat: this.dataFormat,
          dilationRate: this.dilationRate,
          strides: this.strides
        };
        return Object.assign(Object.assign({}, t), r);
      }
    }, {
      key: "inputConv",
      value: function (e, t, n, r) {
        var a = b7(e, t, this.strides, r || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
        if (n) {
          return Lue(a, n, this.dataFormat);
        } else {
          return a;
        }
      }
    }, {
      key: "recurrentConv",
      value: function (e, t) {
        return b7(e, t, 1, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
      }
    }]);
    return n;
  }(Ape);
  Mpe.className = "ConvLSTM2DCell";
  Kre(Mpe);
  var Lpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      var r = new Mpe(e);
      return t.call(this, Object.assign(Object.assign({}, e), {
        cell: r
      }));
    }
    p(n, null, [{
      key: "fromConfig",
      value: function (e, t) {
        return new e(t);
      }
    }]);
    return n;
  }(Dpe);
  Lpe.className = "ConvLSTM2D";
  Kre(Lpe);
  var zpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).rate = Math.max(Math.min(e.rate, 1), 0);
      r.noiseShape = e.noiseShape;
      r.seed = e.seed;
      r.supportsMasking = true;
      return r;
    }
    p(n, [{
      key: "getNoiseShape",
      value: function (e) {
        if (this.noiseShape == null) {
          return this.noiseShape;
        }
        var t = e.shape;
        var n = [];
        for (var r = 0; r < this.noiseShape.length; ++r) {
          n.push(this.noiseShape[r] == null ? t[r] : this.noiseShape[r]);
        }
        return n;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          if (n.rate > 0 && n.rate < 1) {
            var a = t.training != null && t.training;
            var i = n.getNoiseShape(r);
            return Bue(function () {
              return Pue(r, n.rate, i, n.seed);
            }, function () {
              return r;
            }, a);
          }
          return e;
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          rate: this.rate,
          noiseShape: this.noiseShape,
          seed: this.seed
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }, {
      key: "dispose",
      value: function () {
        return N(v(n.prototype), "dispose", this).call(this);
      }
    }]);
    return n;
  }(wce);
  zpe.className = "Dropout";
  Kre(zpe);
  var Ppe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).inputSpec = [{
        ndim: 3
      }];
      return r;
    }
    p(n, [{
      key: "getNoiseShape",
      value: function (e) {
        var t = e.shape;
        return [t[0], 1, t[2]];
      }
    }]);
    return n;
  }(zpe);
  Ppe.className = "SpatialDropout1D";
  Kre(Ppe);
  var Bpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).activation = null;
      r.useBias = true;
      r.kernel = null;
      r.bias = null;
      r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      r.DEFAULT_BIAS_INITIALIZER = "zeros";
      if (e.batchInputShape == null && e.inputShape == null && e.inputDim != null) {
        var a = null;
        if (e.batchSize != null) {
          a = e.batchSize;
        }
        r.batchInputShape = [a, e.inputDim];
      }
      r.units = e.units;
      Xse(r.units, "units");
      r.activation = Uhe(e.activation);
      if (e.useBias != null) {
        r.useBias = e.useBias;
      }
      r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER);
      r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER);
      r.kernelConstraint = Vce(e.kernelConstraint);
      r.biasConstraint = Vce(e.biasConstraint);
      r.kernelRegularizer = Xhe(e.kernelRegularizer);
      r.biasRegularizer = Xhe(e.biasRegularizer);
      r.activityRegularizer = Xhe(e.activityRegularizer);
      r.supportsMasking = true;
      r.inputSpec = [{
        minNDim: 2
      }];
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        var t = (e = hce(e))[e.length - 1];
        if (this.kernel == null) {
          this.kernel = this.addWeight("kernel", [t, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
          if (this.useBias) {
            this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
          }
        }
        this.inputSpec = [{
          minNDim: 2,
          axes: f({}, -1, t)
        }];
        this.built = true;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t = (e = hce(e)).slice();
        t[t.length - 1] = this.units;
        return t;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r;
          var a = lce(e);
          var i = Jse(n.activation.getClassName());
          if (i != null) {
            r = Oue(a, n.kernel.read(), i, n.bias ? n.bias.read() : null);
          } else {
            r = Oue(a, n.kernel.read());
            if (n.bias != null) {
              r = Lue(r, n.bias.read());
            }
            if (n.activation != null) {
              r = n.activation.apply(r);
            }
          }
          return r;
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          units: this.units,
          activation: Bhe(this.activation),
          useBias: this.useBias,
          kernelInitializer: oce(this.kernelInitializer),
          biasInitializer: oce(this.biasInitializer),
          kernelRegularizer: qhe(this.kernelRegularizer),
          biasRegularizer: qhe(this.biasRegularizer),
          activityRegularizer: qhe(this.activityRegularizer),
          kernelConstraint: Wce(this.kernelConstraint),
          biasConstraint: Wce(this.biasConstraint)
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Bpe.className = "Dense";
  Kre(Bpe);
  var Wpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      e = e || {};
      (r = t.call(this, e)).inputSpec = [{
        minNDim: 3
      }];
      r.dataFormat = e.dataFormat;
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        var t;
        var n = O((e = hce(e)).slice(1));
        try {
          for (n.s(); !(t = n.n()).done;) {
            if (t.value == null) {
              throw new Cse(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
            }
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
        return [e[0], gue(e, 1)];
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          if (n.dataFormat === "channelsFirst" && r.rank > 1) {
            var a = [0];
            for (var i = 2; i < r.rank; ++i) {
              a.push(i);
            }
            a.push(1);
            r = hne(r, a);
          }
          return function (e) {
            if (e.rank <= 1) {
              throw new Cse(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);
            }
            var t = [e.shape[0], gue(e.shape, 1)];
            return X8(e, t);
          }(r);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {};
        if (this.dataFormat != null) {
          e.dataFormat = this.dataFormat;
        }
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Wpe.className = "Flatten";
  Kre(Wpe);
  var Upe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).supportsMasking = true;
      r.activation = Uhe(e.activation);
      return r;
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          return n.activation.apply(r);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          activation: Bhe(this.activation)
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Upe.className = "Activation";
  Kre(Upe);
  var Vpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).n = e.n;
      r.inputSpec = [{
        ndim: 2
      }];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        return [e[0], this.n, e[1]];
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          e = lce(e);
          t = e;
          r = n.n;
          return X5(function () {
            if (t.shape.length !== 2) {
              throw new Cse(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);
            }
            return Rue(Iue(t, 1), [1, r, 1]);
          });
          var t;
          var r;
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          n: this.n
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Vpe.className = "RepeatVector";
  Kre(Vpe);
  var Gpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).targetShape = e.targetShape;
      for (var a = 0; a < r.targetShape.length; ++a) {
        if (r.isUnknown(r.targetShape[a])) {
          r.targetShape[a] = null;
        }
      }
      return r;
    }
    p(n, [{
      key: "isUnknown",
      value: function (e) {
        return e < 0 || e == null;
      }
    }, {
      key: "fixUnknownDimension",
      value: function (e, t) {
        var n = "Total size of new array must be unchanged.";
        for (var r = t.slice(), a = 1, i = null, o = 0; o < r.length; ++o) {
          var s = r[o];
          if (this.isUnknown(s)) {
            if (i !== null) {
              throw new Cse("Can only specifiy one unknown dimension.");
            }
            i = o;
          } else {
            a *= s;
          }
        }
        var u = gue(e);
        if (i !== null) {
          if (a === 0 || u % a != 0) {
            throw new Cse(n);
          }
          r[i] = u / a;
        } else if (u !== a) {
          throw new Cse(n);
        }
        return r;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t = false;
        for (var n = 0; n < e.length; ++n) {
          if (this.isUnknown(e[n])) {
            t = true;
            break;
          }
        }
        if (t) {
          return e.slice(0, 1).concat(this.targetShape);
        } else {
          return e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          var a = r.shape;
          var i = a.slice(0, 1).concat(n.fixUnknownDimension(a.slice(1), n.targetShape));
          return X8(r, i);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          targetShape: this.targetShape
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Gpe.className = "Reshape";
  Kre(Gpe);
  var jpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      if (e.dims == null) {
        throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      }
      if (!Array.isArray(e.dims)) {
        throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);
      }
      var a = xue(1, e.dims.length + 1);
      if (!P$(e.dims.slice().sort(), a)) {
        throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
      }
      r.dims = e.dims;
      r.dimsIncludingBatch = [0].concat(r.dims);
      r.inputSpec = [new gce({
        ndim: r.dims.length + 1
      })];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        var t = (e = hce(e)).slice();
        this.dims.forEach(function (n, r) {
          t[r + 1] = e[n];
        });
        return t;
      }
    }, {
      key: "call",
      value: function (e, t) {
        return hne(lce(e), this.dimsIncludingBatch);
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          dims: this.dims
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  jpe.className = "Permute";
  Kre(jpe);
  var Hpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e == null ? {} : e)).supportsMasking = true;
      r.maskValue = e != null ? e.maskValue == null ? 0 : e.maskValue : 0;
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          maskValue: this.maskValue
        };
        Object.assign(t, e);
        return t;
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        var n = lce(e);
        return I8(uee(n, this.maskValue), -1);
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          var a = I8(uee(r, n.maskValue), -1, true);
          return g8(r, h8(a, r.dtype));
        });
      }
    }]);
    return n;
  }(wce);
  Hpe.className = "Masking";
  Kre(Hpe);
  var qpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).embeddings = null;
      r.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform";
      if (e.batchInputShape == null && e.inputShape == null) {
        var a = null;
        if (e.batchSize != null) {
          a = e.batchSize;
        }
        if (e.inputLength == null) {
          r.batchInputShape = [a, null];
        } else {
          r.batchInputShape = [a].concat(Lse(e.inputLength));
        }
      }
      r.inputDim = e.inputDim;
      Xse(r.inputDim, "inputDim");
      r.outputDim = e.outputDim;
      Xse(r.outputDim, "outputDim");
      r.embeddingsInitializer = sce(e.embeddingsInitializer || r.DEFAULT_EMBEDDINGS_INITIALIZER);
      r.embeddingsRegularizer = Xhe(e.embeddingsRegularizer);
      r.activityRegularizer = Xhe(e.activityRegularizer);
      r.embeddingsConstraint = Vce(e.embeddingsConstraint);
      r.maskZero = e.maskZero;
      r.supportsMasking = e.maskZero;
      r.inputLength = e.inputLength;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
        this.built = true;
      }
    }, {
      key: "warnOnIncompatibleInputShape",
      value: function (e) {}
    }, {
      key: "computeMask",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (n.maskZero) {
            e = lce(e);
            return uee(e, U7(e));
          } else {
            return null;
          }
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        e = hce(e);
        if (this.inputLength == null) {
          return [].concat(T(e), [this.outputDim]);
        }
        var t = Lse(this.inputLength);
        if (t.length !== e.length - 1) {
          throw new Cse(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
        }
        var n = 0;
        for (var r = 0; r < t.length; ++r) {
          var a = t[r];
          var i = e[r + 1];
          if (a != null && i != null && a !== i) {
            throw new Cse(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
          }
          if (a == null) {
            t[n] = i;
          }
          n++;
        }
        return [e[0]].concat(T(t), [this.outputDim]);
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          if (r.dtype !== "int32") {
            r = wue(r, "int32");
          }
          var a = Fue(n.embeddings.read(), X8(r, [r.size]));
          return X8(a, hce(n.computeOutputShape(r.shape)));
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          inputDim: this.inputDim,
          outputDim: this.outputDim,
          embeddingsInitializer: oce(this.embeddingsInitializer),
          embeddingsRegularizer: qhe(this.embeddingsRegularizer),
          activityRegularizer: qhe(this.activityRegularizer),
          embeddingsConstraint: Wce(this.embeddingsConstraint),
          maskZero: this.maskZero,
          inputLength: this.inputLength
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  qpe.className = "Embedding";
  Kre(qpe);
  var Kpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e || {})).supportsMasking = true;
      return r;
    }
    p(n, [{
      key: "mergeFunction",
      value: function (e) {
        throw new Ase();
      }
    }, {
      key: "computeElementwiseOpOutputShape",
      value: function (e, t) {
        if (e == null || t == null) {
          return null;
        }
        if (e.length < t.length) {
          return this.computeElementwiseOpOutputShape(t, e);
        }
        if (t.length === 0) {
          return e;
        }
        var n = e.slice(0, e.length - t.length);
        for (var r = 0; r < t.length; ++r) {
          var a = e[e.length - t.length + r];
          var i = t[r];
          if (a == null || i == null || a < 0 || i < 0) {
            n.push(null);
          } else if (a === 1) {
            n.push(i);
          } else if (i === 1) {
            n.push(a);
          } else {
            if (a !== i) {
              throw new Cse("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
            }
            n.push(a);
          }
        }
        return n;
      }
    }, {
      key: "build",
      value: function (e) {
        if (Array.isArray(e) && !Array.isArray(e[0])) {
          e = [hce(e)];
        }
        if (e.length < 2) {
          throw new Cse(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);
        }
        var t;
        var n = [];
        var r = O(e);
        try {
          for (r.s(); !(t = r.n()).done;) {
            var a = t.value;
            if (a != null && a[0] !== null) {
              n.push(a[0]);
            }
          }
        } catch (e) {
          r.e(e);
        } finally {
          r.f();
        }
        if ((n = jse(n)).length > 1) {
          throw new Cse(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);
        }
        var i = e[0] == null ? null : e[0].slice(1);
        for (var o = 1; o < e.length; ++o) {
          var s = e[o] == null ? null : e[o].slice(1);
          i = this.computeElementwiseOpOutputShape(i, s);
        }
        var u = e.map(function (e) {
          return e.length;
        });
        if (e.indexOf(null) === -1 && jse(u).length === 1) {
          this.reshapeRequired = false;
        } else {
          this.reshapeRequired = true;
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (n.reshapeRequired) {
            var t = [];
            var r = e.map(function (e) {
              return e.rank;
            });
            if (r.indexOf(null) === -1) {
              var a;
              var i = bue(r);
              var o = O(e);
              try {
                for (o.s(); !(a = o.n()).done;) {
                  var s = a.value;
                  for (var u = s.rank, c = 0; c < i - u; ++c) {
                    s = Iue(s, 1);
                  }
                  t.push(s);
                }
              } catch (e) {
                o.e(e);
              } finally {
                o.f();
              }
              return n.mergeFunction(t);
            }
            var l;
            var h = false;
            var p = O(e);
            try {
              for (p.s(); !(l = p.n()).done;) {
                var f = l.value;
                var d = f.rank;
                if (d == null) {
                  var v = f.shape;
                  var m = v[0];
                  var g = v.slice(1).concat([m]);
                  var y = X8(f, [m].concat(gue(v.slice(1))));
                  y = hne(y, [1, 0]);
                  y = X8(y, g);
                  t.push(y);
                  h = true;
                } else if (d > 1) {
                  var b = xue(1, d).concat([0]);
                  t.push(hne(f, b));
                  h = true;
                } else {
                  t.push(f);
                }
              }
            } catch (e) {
              p.e(e);
            } finally {
              p.f();
            }
            var x = n.mergeFunction(t);
            var k = x.rank;
            if (h) {
              if (k == null) {
                var w = x.shape;
                var I = w[w.length - 1];
                var N = [I].concat(w.slice(0, w.length - 1));
                x = X8(hne(X8(x, [-1, I]), [1, 0]), N);
              } else if (k > 1) {
                var S = [k - 1].concat(xue(0, k - 1));
                x = hne(x, S);
              }
            }
            return x;
          }
          return n.mergeFunction(e);
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t;
        t = e[0] == null ? null : e[0].slice(1);
        for (var n = 1; n < e.length; ++n) {
          var r = e[n] == null ? null : e[n].slice(1);
          t = this.computeElementwiseOpOutputShape(t, r);
        }
        var a;
        var i = [];
        var o = O(e);
        try {
          for (o.s(); !(a = o.n()).done;) {
            var s = a.value;
            if (s != null && s[0] !== null) {
              i.push(s[0]);
            }
          }
        } catch (e) {
          o.e(e);
        } finally {
          o.f();
        }
        return t = (i = jse(i)).length === 1 ? i.concat(t) : [null].concat(t);
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        return X5(function () {
          if (t == null) {
            return null;
          }
          if (!Array.isArray(t)) {
            throw new Cse("`mask` should be an Array");
          }
          if (!Array.isArray(e)) {
            throw new Cse("`inputs` should be an Array");
          }
          if (t.length !== e.length) {
            throw new Cse(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);
          }
          if (t.every(function (e) {
            return e == null;
          })) {
            return null;
          }
          var n = (t = t.map(function (e) {
            if (e == null) {
              return e;
            } else {
              return f9(e, 0);
            }
          }))[0];
          for (var r = 1; r < t.length - 1; ++r) {
            n = U9(n, t[r]);
          }
          return n;
        });
      }
    }]);
    return n;
  }(wce);
  var Xpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "mergeFunction",
      value: function (e) {
        return X5(function () {
          var t = e[0].clone();
          for (var n = 1; n < e.length; ++n) {
            t = d8(t, e[n]);
          }
          return t;
        });
      }
    }]);
    return n;
  }(Kpe);
  Xpe.className = "Add";
  Kre(Xpe);
  var Ype = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "mergeFunction",
      value: function (e) {
        return X5(function () {
          var t = e[0].clone();
          for (var n = 1; n < e.length; ++n) {
            t = g8(t, e[n]);
          }
          return t;
        });
      }
    }]);
    return n;
  }(Kpe);
  Ype.className = "Multiply";
  Kre(Ype);
  var Jpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "mergeFunction",
      value: function (e) {
        return X5(function () {
          var t = e[0].clone();
          for (var n = 1; n < e.length; ++n) {
            t = d8(t, e[n]);
          }
          return g8(1 / e.length, t);
        });
      }
    }]);
    return n;
  }(Kpe);
  Jpe.className = "Average";
  Kre(Jpe);
  var Zpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "mergeFunction",
      value: function (e) {
        return X5(function () {
          var t = e[0];
          for (var n = 1; n < e.length; ++n) {
            t = Z9(t, e[n]);
          }
          return t;
        });
      }
    }]);
    return n;
  }(Kpe);
  Zpe.className = "Maximum";
  Kre(Zpe);
  var Qpe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "mergeFunction",
      value: function (e) {
        return X5(function () {
          var t = e[0];
          for (var n = 1; n < e.length; ++n) {
            t = nee(t, e[n]);
          }
          return t;
        });
      }
    }]);
    return n;
  }(Kpe);
  Qpe.className = "Minimum";
  Kre(Qpe);
  var $pe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).DEFAULT_AXIS = -1;
      if (e == null) {
        e = {};
      }
      r.axis = e.axis == null ? r.DEFAULT_AXIS : e.axis;
      r.supportsMasking = true;
      r.reshapeRequired = false;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        if (!Array.isArray(e) || !Array.isArray(e[0]) || e.length === 1) {
          throw new Cse("A `Concatenate` layer should be called on a list of at least 2 inputs");
        }
        var t;
        var n = true;
        var r = O(e);
        try {
          for (r.s(); !(t = r.n()).done;) {
            if (t.value != null) {
              n = false;
              break;
            }
          }
        } catch (e) {
          r.e(e);
        } finally {
          r.f();
        }
        if (!n) {
          var a = [];
          for (var i = 0; i < e.length; ++i) {
            var o = e[i].slice();
            o.splice(this.axis, 1);
            var s;
            var u = false;
            var c = O(a);
            try {
              for (c.s(); !(s = c.n()).done;) {
                if (P$(s.value, o)) {
                  u = true;
                  break;
                }
              }
            } catch (e) {
              c.e(e);
            } finally {
              c.f();
            }
            if (!u) {
              a.push(o);
            }
          }
          if (a.length > 1) {
            throw new Cse("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
          }
        }
      }
    }, {
      key: "mergeFunction",
      value: function (e) {
        var t = this;
        return X5(function () {
          return Cue(e, t.axis);
        });
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        if (!Array.isArray(e) || !Array.isArray(e[0])) {
          throw new Cse("A `Concatenate` layer should be called on a list of inputs.");
        }
        var t;
        var n = e;
        var r = n[0].slice();
        var a = this.axis < 0 ? r.length + this.axis : this.axis;
        var i = O(n.slice(1));
        try {
          for (i.s(); !(t = i.n()).done;) {
            var o = t.value;
            if (r[a] == null || o[a] == null) {
              r[a] = null;
              break;
            }
            r[a] += o[a];
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
        return r;
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        var n = this;
        if (t == null) {
          return null;
        }
        if (!Array.isArray(t)) {
          throw new Cse("`mask` should be an array for Concatenate");
        }
        if (!Array.isArray(e)) {
          throw new Cse("`inputs` should be an array for Concatenate");
        }
        if (t.length !== e.length) {
          throw new Cse(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);
        }
        return X5(function () {
          var r = true;
          t.forEach(function (e) {
            if (e != null) {
              r = false;
            }
          });
          if (r) {
            return null;
          }
          var a = [];
          for (var i = 0; i < e.length; ++i) {
            if (t[i] == null) {
              a.push(h8(lee(e[i]), "bool"));
            } else if (t[i].rank < e[i].rank) {
              a.push(f9(t[i], -1));
            } else {
              a.push(t[i]);
            }
          }
          var o = Z8(a, n.axis);
          return w8(o, -1, false);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          axis: this.axis
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(Kpe);
  function efe(e, t) {
    while (e < 0) {
      e += t;
    }
    return e;
  }
  $pe.className = "Concatenate";
  Kre($pe);
  var tfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).axes = e.axes;
      r.normalize = e.normalize != null && e.normalize;
      r.supportsMasking = true;
      r.reshapeRequired = false;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        F$(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
          return "A `Dot` layer should be called on a list of exactly 2 inputs.";
        });
        var t = e[0];
        var n = e[1];
        if (t.length > 3 || n.length > 3) {
          throw new Ase("Dot layer does not support tensors of 4D or higher rank yet.");
        }
        var r = this.interpretAxes(t, n);
        if (t[r[0]] !== n[r[1]]) {
          throw new Cse(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`);
        }
      }
    }, {
      key: "mergeFunction",
      value: function (e) {
        if (e.length !== 2) {
          throw new Cse(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);
        }
        var t;
        var n = e[0];
        var r = e[1];
        t = Array.isArray(this.axes) ? this.axes.map(function (t, n) {
          return efe(t, e[n].shape.length);
        }) : [efe(this.axes, n.shape.length), efe(this.axes, r.shape.length)];
        if (this.normalize) {
          n = ale(n, t[0]);
          r = ale(r, t[1]);
        }
        return function (e, t, n) {
          if (e.shape.length > 3 || t.shape.length > 3) {
            throw new Ase("batchDot is not implemented for tensors of 4D or higher rank yet");
          }
          F$(e.shape.length >= 2, function () {
            return `batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`;
          });
          F$(e.shape.length >= 2, function () {
            return `batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`;
          });
          if (typeof n == "number") {
            n = [n, n];
          }
          if (e.dtype === "complex64" || t.dtype === "complex64") {
            throw new Ase("batchDot is not implemented for complex64-type Tensors yet.");
          }
          var r = e.shape.length;
          var a = t.shape.length;
          if (n == null) {
            n = [r - 1, a - 2];
          }
          var i = n;
          return X5(function () {
            var n;
            var o;
            if (r > a) {
              n = r - a;
              var s = [];
              for (var u = 0; u < n; ++u) {
                s.push(1);
              }
              t = X8(t, t.shape.concat(s));
            } else if (a > r) {
              n = a - r;
              var c = [];
              for (var l = 0; l < n; ++l) {
                c.push(1);
              }
              e = X8(e, e.shape.concat(c));
            } else {
              n = 0;
            }
            if (e.shape.length === 2 && t.shape.length === 2) {
              o = i[0] === i[1] ? u9(g8(e, t), i[0]) : u9(g8(hne(e, [1, 0]), t), i[1]);
            } else {
              var h = i[0] !== e.shape.length - 1;
              var p = i[1] === t.shape.length - 1;
              o = Q8(e, t, h, p);
            }
            if (n > 0) {
              for (var f, d = [], v = f = r > a ? r + a - 3 : r - 1; v < f + n; ++v) {
                d.push(v);
              }
              o = zte(o, d);
            }
            if (o.shape.length === 1) {
              o = f9(o, 1);
            }
            return o;
          });
        }(n, r, t);
      }
    }, {
      key: "interpretAxes",
      value: function (e, t) {
        if (Array.isArray(this.axes)) {
          return this.axes;
        } else {
          return [efe(this.axes, e.length), efe(this.axes, t.length)];
        }
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        F$(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), function () {
          return "A `Dot` layer should be called on a list of exactly 2 inputs.";
        });
        var t = e[0].slice();
        var n = e[1].slice();
        if (t.length > 3 || n.length > 3) {
          throw new Ase("Dot layer does not support tensors of 4D or higher rank yet.");
        }
        var r = this.interpretAxes(t, n);
        t.splice(r[0], 1);
        n.splice(r[1], 1);
        n.splice(0, 1);
        var a = t.concat(n);
        if (a.length === 1) {
          a.push(1);
        }
        return a;
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        return null;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          axes: this.axes,
          normalize: this.normalize
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(Kpe);
  tfe.className = "Dot";
  Kre(tfe);
  var nfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).supportsMasking = true;
      r.stddev = e.stddev;
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          stddev: this.stddev
        };
        Object.assign(t, e);
        return t;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          return Bue(function () {
            return d8(_ue(r.shape, 0, n.stddev), r);
          }, function () {
            return r;
          }, t.training || false);
        });
      }
    }]);
    return n;
  }(wce);
  nfe.className = "GaussianNoise";
  Kre(nfe);
  var rfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).supportsMasking = true;
      r.rate = e.rate;
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          rate: this.rate
        };
        Object.assign(t, e);
        return t;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          var r = lce(e);
          if (n.rate > 0 && n.rate < 1) {
            return Bue(function () {
              var e = Math.sqrt(n.rate / (1 - n.rate));
              return g8(r, _ue(r.shape, 1, e));
            }, function () {
              return r;
            }, t.training || false);
          }
          return r;
        });
      }
    }]);
    return n;
  }(wce);
  rfe.className = "GaussianDropout";
  Kre(rfe);
  var afe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).supportsMasking = true;
      r.rate = e.rate;
      r.noiseShape = e.noiseShape;
      return r;
    }
    p(n, [{
      key: "_getNoiseShape",
      value: function (e) {
        return this.noiseShape || lce(e).shape;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        return e;
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = N(v(n.prototype), "getConfig", this).call(this);
        var t = {
          rate: this.rate
        };
        Object.assign(t, e);
        return t;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if (n.rate < 1 && n.rate > 0) {
            var r = n._getNoiseShape(e);
            return Bue(function () {
              var t = lce(e);
              var a = -1.7580993408473766;
              var i = x9(ite(r), n.rate);
              i = wue(i, "float32");
              var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(a, 2)), -0.5);
              var s = -o * a * n.rate;
              var u = d8(g8(t, i), g8(d8(i, -1), a));
              return d8(g8(u, o), s);
            }, function () {
              return lce(e);
            }, t.training || false);
          }
          return e;
        });
      }
    }]);
    return n;
  }(wce);
  function ife(e, t, n, r, a) {
    var i;
    var o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.001;
    if (e.rank === 2) {
      i = i7(e, t, n, r, a, o);
    } else if (e.rank === 3) {
      i = o7(e, t, n, r, a, o);
    } else {
      if (e.rank !== 4) {
        throw new Ase(`batchNormalization is not implemented for array of rank ${e.rank} yet`);
      }
      i = s7(e, t, n, r, a, o);
    }
    return i;
  }
  function ofe(e, t, n, r, a = 0.001) {
    return X5(function () {
      var i = iee(e, r);
      var o = i.mean;
      var s = i.variance;
      return [ife(e, o, s, n, t, a), o, s];
    });
  }
  function sfe(e, t, n, r, a = 0.001) {
    return X5(function () {
      var i;
      var o = iee(e, r);
      var s = o.mean;
      var u = o.variance;
      var c = [];
      var l = O(xue(0, e.rank));
      try {
        for (l.s(); !(i = l.n()).done;) {
          var h = i.value;
          if (r.indexOf(h) !== -1) {
            c.push(1);
          } else {
            c.push(e.shape[h]);
          }
        }
      } catch (e) {
        l.e(e);
      } finally {
        l.f();
      }
      var p = X8(s, c);
      var f = X8(u, c);
      var d = t == null ? null : X8(t, c);
      var v = n == null ? null : X8(n, c);
      return [ife(e, p, f, v, d, a), s, u];
    });
  }
  afe.className = "AlphaDropout";
  Kre(afe);
  var ufe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      if (e == null) {
        e = {};
      }
      (r = t.call(this, e)).supportsMasking = true;
      r.axis = e.axis == null ? -1 : e.axis;
      r.momentum = e.momentum == null ? 0.99 : e.momentum;
      r.epsilon = e.epsilon == null ? 0.001 : e.epsilon;
      r.center = e.center == null || e.center;
      r.scale = e.scale == null || e.scale;
      r.betaInitializer = sce(e.betaInitializer || "zeros");
      r.gammaInitializer = sce(e.gammaInitializer || "ones");
      r.movingMeanInitializer = sce(e.movingMeanInitializer || "zeros");
      r.movingVarianceInitializer = sce(e.movingVarianceInitializer || "ones");
      r.betaConstraint = Vce(e.betaConstraint);
      r.gammaConstraint = Vce(e.gammaConstraint);
      r.betaRegularizer = Xhe(e.betaRegularizer);
      r.gammaRegularizer = Xhe(e.gammaRegularizer);
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        e = hce(e);
        var t = this.axis >= 0 ? this.axis : this.axis + e.length;
        var n = e[t];
        if (n == null) {
          throw new Cse(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);
        }
        this.inputSpec = [new gce({
          ndim: e.length,
          axes: f({}, t, n)
        })];
        var r = [n];
        if (this.scale) {
          this.gamma = this.addWeight("gamma", r, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
        }
        if (this.center) {
          this.beta = this.addWeight("beta", r, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
        }
        this.movingMean = this.addWeight("moving_mean", r, null, this.movingMeanInitializer, null, false);
        this.movingVariance = this.addWeight("moving_variance", r, null, this.movingVarianceInitializer, null, false);
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r = t.training != null && t.training;
          var a = lce(e);
          var i = a.shape;
          var o = i.length;
          var s = xue(0, o);
          var u = n.axis >= 0 ? n.axis : n.axis + o;
          s.splice(u, 1);
          var c = Ose(1, o);
          c[u] = i[u];
          var l = s.slice();
          l.sort();
          var h = !P$(l, xue(0, o).slice(0, o - 1));
          if (!r) {
            return function () {
              if (h) {
                var e = X8(n.movingMean.read(), c);
                var t = X8(n.movingVariance.read(), c);
                var r = n.center ? X8(n.beta.read(), c) : null;
                var i = n.scale ? X8(n.gamma.read(), c) : null;
                return ife(a, e, t, r, i, n.epsilon);
              }
              return ife(a, n.movingMean.read(), n.movingVariance.read(), n.beta == null ? null : n.beta.read(), n.gamma == null ? null : n.gamma.read(), n.epsilon);
            }();
          }
          var p = function (e, t, n, r, a = 0.001) {
            if (P$(r.slice().sort(), xue(0, e.rank - 1))) {
              return ofe(e, t, n, r, a);
            } else {
              return sfe(e, t, n, r, a);
            }
          }(a, n.gamma.read(), n.beta.read(), s, n.epsilon);
          var f = S(p, 3);
          var d = f[0];
          var v = f[1];
          var m = f[2];
          function g(e, t, n) {
            X5(function () {
              var r = 1 - n;
              var a = e.read();
              var i = g8(P9(a, t), r);
              e.write(P9(a, i));
            });
          }
          g(n.movingMean, v, n.momentum);
          g(n.movingVariance, m, n.momentum);
          return d;
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          axis: this.axis,
          momentum: this.momentum,
          epsilon: this.epsilon,
          center: this.center,
          scale: this.scale,
          betaInitializer: oce(this.betaInitializer),
          gammaInitializer: oce(this.gammaInitializer),
          movingMeanInitializer: oce(this.movingMeanInitializer),
          movingVarianceInitializer: oce(this.movingVarianceInitializer),
          betaRegularizer: qhe(this.betaRegularizer),
          gammaRegularizer: qhe(this.gammaRegularizer),
          betaConstraint: Wce(this.betaConstraint),
          gammaConstraint: Wce(this.gammaConstraint)
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  ufe.className = "BatchNormalization";
  Kre(ufe);
  var cfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      if (e == null) {
        e = {};
      }
      (r = t.call(this, e)).axis = e.axis == null ? -1 : e.axis;
      if (typeof r.axis == "number") {
        if (!Number.isInteger(r.axis)) {
          throw new Error(`Expected axis to be an integer, but received ${r.axis}`);
        }
      } else {
        if (!Array.isArray(r.axis)) {
          throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(r.axis)}`);
        }
        var a;
        var i = O(r.axis);
        try {
          for (i.s(); !(a = i.n()).done;) {
            var o = a.value;
            if (!Number.isInteger(o)) {
              throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(r.axis)}`);
            }
          }
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
      }
      r.epsilon = e.epsilon == null ? 0.001 : e.epsilon;
      r.center = e.center == null || e.center;
      r.scale = e.scale == null || e.scale;
      r.betaInitializer = sce(e.betaInitializer || "zeros");
      r.gammaInitializer = sce(e.gammaInitializer || "ones");
      r.betaRegularizer = Xhe(e.betaRegularizer);
      r.gammaRegularizer = Xhe(e.gammaRegularizer);
      r.supportsMasking = true;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        var t = (e = hce(e)).length;
        if (typeof this.axis == "number") {
          this.axis = [this.axis];
        }
        for (var n = 0; n < this.axis.length; ++n) {
          if (this.axis[n] < 0) {
            this.axis[n] += t;
          }
        }
        var r;
        var a = O(this.axis);
        try {
          for (a.s(); !(r = a.n()).done;) {
            var i = r.value;
            if (i < 0 || i >= t) {
              throw new Error(`Invalid axis: ${i}`);
            }
          }
        } catch (e) {
          a.e(e);
        } finally {
          a.f();
        }
        if (this.axis.length !== jse(this.axis).length) {
          throw new Error(`Found duplicate axes in: ${this.axis}`);
        }
        var o = this.axis.map(function (t) {
          return e[t];
        });
        if (this.scale) {
          this.gamma = this.addWeight("gamma", o, "float32", this.gammaInitializer, this.gammaRegularizer, true);
        } else {
          this.gamma = null;
        }
        if (this.center) {
          this.beta = this.addWeight("beta", o, "float32", this.betaInitializer, this.betaRegularizer, true);
        } else {
          this.beta = null;
        }
        this.built = true;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        var r = lce(e);
        var a = r.shape;
        var i = a.length;
        return X5(function () {
          var e;
          var t = iee(r, n.axis, true);
          var o = t.mean;
          var s = t.variance;
          var u = Ose(1, i);
          var c = O(n.axis);
          try {
            for (c.s(); !(e = c.n()).done;) {
              var l = e.value;
              u[l] = a[l];
            }
          } catch (e) {
            c.e(e);
          } finally {
            c.f();
          }
          var h = function (e) {
            if (e != null && e.shape.length !== i) {
              return X8(e, u);
            } else {
              return e;
            }
          };
          var p = n.scale ? h(n.gamma.read()) : null;
          var f = n.center ? h(n.beta.read()) : null;
          var d = [];
          var v = [];
          for (var m = 0; m < i; ++m) {
            if (n.axis.indexOf(m) !== -1) {
              d.push(a[m]);
              v.push(1);
            } else {
              d.push(1);
              v.push(a[m]);
            }
          }
          o = v9(o, d);
          s = v9(s, d);
          if (p != null) {
            p = v9(p, v);
          }
          if (f != null) {
            f = v9(f, v);
          }
          return ife(r, o, s, f, p, n.epsilon);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          axis: this.axis,
          epsilon: this.epsilon,
          center: this.center,
          scale: this.scale,
          betaInitializer: oce(this.betaInitializer),
          gammaInitializer: oce(this.gammaInitializer),
          betaRegularizer: qhe(this.betaRegularizer),
          gammaRegularizer: qhe(this.gammaRegularizer)
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  cfe.className = "LayerNormalization";
  Kre(cfe);
  var lfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      if (e == null) {
        e = {};
      }
      (r = t.call(this, e)).dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat;
      if (e.padding == null) {
        r.padding = [[1, 1], [1, 1]];
      } else if (typeof e.padding == "number") {
        r.padding = [[e.padding, e.padding], [e.padding, e.padding]];
      } else {
        e.padding = e.padding;
        if (e.padding.length !== 2) {
          throw new Cse(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);
        }
        var a;
        var i;
        if (typeof e.padding[0] == "number") {
          a = [e.padding[0], e.padding[0]];
          i = [e.padding[1], e.padding[1]];
        } else {
          e.padding = e.padding;
          if (e.padding[0].length !== 2) {
            throw new Cse(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);
          }
          a = e.padding[0];
          if (e.padding[1].length !== 2) {
            throw new Cse(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);
          }
          i = e.padding[1];
        }
        r.padding = [a, i];
      }
      r.inputSpec = [new gce({
        ndim: 4
      })];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        var t;
        var n;
        e = hce(e);
        if (this.dataFormat === "channelsFirst") {
          t = e[2] != null && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null;
          n = e[3] != null && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null;
          return [e[0], e[1], t, n];
        } else {
          t = e[1] != null && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null;
          n = e[2] != null && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null;
          return [e[0], t, n, e[3]];
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          t = lce(e);
          r = n.padding;
          a = n.dataFormat;
          return X5(function () {
            if (t.rank !== 4) {
              throw new Cse(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);
            }
            if (r == null) {
              r = [[1, 1], [1, 1]];
            }
            if (r.length !== 2 || r[0].length !== 2 || r[1].length !== 2) {
              throw new Cse("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
            }
            if (a == null) {
              a = "channelsLast";
            }
            if (a !== "channelsLast" && a !== "channelsFirst") {
              throw new Cse(`Unknown data format: ${a}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
            }
            var e;
            e = a === "channelsFirst" ? [[0, 0], [0, 0], r[0], r[1]] : [[0, 0], r[0], r[1], [0, 0]];
            return pee(t, e);
          });
          var t;
          var r;
          var a;
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          padding: this.padding,
          dataFormat: this.dataFormat
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  function hfe(e, t, n, r, a, i) {
    return X5(function () {
      var o;
      sue(a);
      cue(i);
      uue(r);
      if (n == null) {
        n = [1, 1];
      }
      if (r == null) {
        r = "valid";
      }
      if (a == null) {
        a = "channelsLast";
      }
      if (i == null) {
        i = "max";
      }
      e = ape(e, a);
      var s = r === "same" ? "same" : "valid";
      o = i === "max" ? X9(e, t, n, s) : Y8(e, t, n, s);
      if (a === "channelsFirst") {
        o = hne(o, [0, 3, 1, 2]);
      }
      return o;
    });
  }
  function pfe(e, t, n, r, a, i) {
    return X5(function () {
      var o;
      sue(a);
      cue(i);
      uue(r);
      if (n == null) {
        n = [1, 1, 1];
      }
      if (r == null) {
        r = "valid";
      }
      if (a == null) {
        a = "channelsLast";
      }
      if (i == null) {
        i = "max";
      }
      e = ipe(e, a);
      var s = r === "same" ? "same" : "valid";
      o = i === "max" ? Y9(e, t, n, s) : J8(e, t, n, s);
      if (a === "channelsFirst") {
        o = hne(o, [0, 4, 1, 2, 3]);
      }
      return o;
    });
  }
  lfe.className = "ZeroPadding2D";
  Kre(lfe);
  var ffe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      if (e.poolSize == null) {
        e.poolSize = 2;
      }
      r = t.call(this, e);
      if (typeof e.poolSize == "number") {
        r.poolSize = [e.poolSize];
      } else {
        if (!Array.isArray(e.poolSize) || e.poolSize.length !== 1 || typeof e.poolSize[0] != "number") {
          throw new Cse(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);
        }
        r.poolSize = e.poolSize;
      }
      Xse(r.poolSize, "poolSize");
      if (e.strides == null) {
        r.strides = r.poolSize;
      } else if (typeof e.strides == "number") {
        r.strides = [e.strides];
      } else {
        if (!Array.isArray(e.strides) || e.strides.length !== 1 || typeof e.strides[0] != "number") {
          throw new Cse(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);
        }
        r.strides = e.strides;
      }
      Xse(r.strides, "strides");
      r.padding = e.padding == null ? "valid" : e.padding;
      uue(r.padding);
      r.inputSpec = [new gce({
        ndim: 3
      })];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        var t = npe((e = hce(e))[1], this.poolSize[0], this.padding, this.strides[0]);
        return [e[0], t, e[2]];
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          e = Iue(lce(e), 2);
          var r = n.poolingFunction(lce(e), [n.poolSize[0], 1], [n.strides[0], 1], n.padding, "channelsLast");
          return zte(r, [2]);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          poolSize: this.poolSize,
          padding: this.padding,
          strides: this.strides
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  var dfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "poolingFunction",
      value: function (e, t, n, r, a) {
        sue(a);
        uue(r);
        return hfe(e, t, n, r, a, "max");
      }
    }]);
    return n;
  }(ffe);
  dfe.className = "MaxPooling1D";
  Kre(dfe);
  var vfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "poolingFunction",
      value: function (e, t, n, r, a) {
        sue(a);
        uue(r);
        return hfe(e, t, n, r, a, "avg");
      }
    }]);
    return n;
  }(ffe);
  vfe.className = "AveragePooling1D";
  Kre(vfe);
  var mfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      if (e.poolSize == null) {
        e.poolSize = [2, 2];
      }
      (r = t.call(this, e)).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize];
      if (e.strides == null) {
        r.strides = r.poolSize;
      } else if (Array.isArray(e.strides)) {
        if (e.strides.length !== 2) {
          throw new Cse(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);
        }
        r.strides = e.strides;
      } else {
        r.strides = [e.strides, e.strides];
      }
      Xse(r.poolSize, "poolSize");
      Xse(r.strides, "strides");
      r.padding = e.padding == null ? "valid" : e.padding;
      r.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat;
      sue(r.dataFormat);
      uue(r.padding);
      r.inputSpec = [new gce({
        ndim: 4
      })];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        e = hce(e);
        var t = this.dataFormat === "channelsFirst" ? e[2] : e[1];
        var n = this.dataFormat === "channelsFirst" ? e[3] : e[2];
        t = npe(t, this.poolSize[0], this.padding, this.strides[0]);
        n = npe(n, this.poolSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === "channelsFirst") {
          return [e[0], e[1], t, n];
        } else {
          return [e[0], t, n, e[3]];
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          return n.poolingFunction(lce(e), n.poolSize, n.strides, n.padding, n.dataFormat);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          poolSize: this.poolSize,
          padding: this.padding,
          strides: this.strides,
          dataFormat: this.dataFormat
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  var gfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "poolingFunction",
      value: function (e, t, n, r, a) {
        sue(a);
        uue(r);
        return hfe(e, t, n, r, a, "max");
      }
    }]);
    return n;
  }(mfe);
  gfe.className = "MaxPooling2D";
  Kre(gfe);
  var yfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "poolingFunction",
      value: function (e, t, n, r, a) {
        sue(a);
        uue(r);
        return hfe(e, t, n, r, a, "avg");
      }
    }]);
    return n;
  }(mfe);
  yfe.className = "AveragePooling2D";
  Kre(yfe);
  var bfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      if (e.poolSize == null) {
        e.poolSize = [2, 2, 2];
      }
      (r = t.call(this, e)).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize];
      if (e.strides == null) {
        r.strides = r.poolSize;
      } else if (Array.isArray(e.strides)) {
        if (e.strides.length !== 3) {
          throw new Cse(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);
        }
        r.strides = e.strides;
      } else {
        r.strides = [e.strides, e.strides, e.strides];
      }
      Xse(r.poolSize, "poolSize");
      Xse(r.strides, "strides");
      r.padding = e.padding == null ? "valid" : e.padding;
      r.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat;
      sue(r.dataFormat);
      uue(r.padding);
      r.inputSpec = [new gce({
        ndim: 5
      })];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        e = hce(e);
        var t = this.dataFormat === "channelsFirst" ? e[2] : e[1];
        var n = this.dataFormat === "channelsFirst" ? e[3] : e[2];
        var r = this.dataFormat === "channelsFirst" ? e[4] : e[3];
        t = npe(t, this.poolSize[0], this.padding, this.strides[0]);
        n = npe(n, this.poolSize[1], this.padding, this.strides[1]);
        r = npe(r, this.poolSize[2], this.padding, this.strides[2]);
        if (this.dataFormat === "channelsFirst") {
          return [e[0], e[1], t, n, r];
        } else {
          return [e[0], t, n, r, e[4]];
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          n.invokeCallHook(e, t);
          return n.poolingFunction(lce(e), n.poolSize, n.strides, n.padding, n.dataFormat);
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          poolSize: this.poolSize,
          padding: this.padding,
          strides: this.strides,
          dataFormat: this.dataFormat
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  var xfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "poolingFunction",
      value: function (e, t, n, r, a) {
        sue(a);
        uue(r);
        return pfe(e, t, n, r, a, "max");
      }
    }]);
    return n;
  }(bfe);
  xfe.className = "MaxPooling3D";
  Kre(xfe);
  var kfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e);
    }
    p(n, [{
      key: "poolingFunction",
      value: function (e, t, n, r, a) {
        sue(a);
        uue(r);
        return pfe(e, t, n, r, a, "avg");
      }
    }]);
    return n;
  }(bfe);
  kfe.className = "AveragePooling3D";
  Kre(kfe);
  var wfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).inputSpec = [new gce({
        ndim: 3
      })];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        return [e[0], e[2]];
      }
    }, {
      key: "call",
      value: function (e, t) {
        throw new Ase();
      }
    }]);
    return n;
  }(wce);
  var Ife = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e || {});
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        return X5(function () {
          var t = lce(e);
          return Q9(t, 1);
        });
      }
    }]);
    return n;
  }(wfe);
  Ife.className = "GlobalAveragePooling1D";
  Kre(Ife);
  var Nfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, e || {});
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        return X5(function () {
          var t = lce(e);
          return n9(t, 1);
        });
      }
    }]);
    return n;
  }(wfe);
  Nfe.className = "GlobalMaxPooling1D";
  Kre(Nfe);
  var Sfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat;
      sue(r.dataFormat);
      r.inputSpec = [new gce({
        ndim: 4
      })];
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        if (this.dataFormat === "channelsLast") {
          return [e[0], e[3]];
        } else {
          return [e[0], e[1]];
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        throw new Ase();
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          dataFormat: this.dataFormat
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  var Tfe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = lce(e);
          if (n.dataFormat === "channelsLast") {
            return Q9(t, [1, 2]);
          } else {
            return Q9(t, [2, 3]);
          }
        });
      }
    }]);
    return n;
  }(Sfe);
  Tfe.className = "GlobalAveragePooling2D";
  Kre(Tfe);
  var Efe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = lce(e);
          if (n.dataFormat === "channelsLast") {
            return n9(t, [1, 2]);
          } else {
            return n9(t, [2, 3]);
          }
        });
      }
    }]);
    return n;
  }(Sfe);
  Efe.className = "GlobalMaxPooling2D";
  Kre(Efe);
  var Cfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).layer = e.layer;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        this.built = true;
      }
    }, {
      key: "trainable",
      get: function () {
        return this.layer != null && this.layer.trainable;
      },
      set: function (e) {
        if (this.layer != null) {
          this.layer.trainable = e;
        }
      }
    }, {
      key: "trainableWeights",
      get: function () {
        return this.layer.trainableWeights;
      }
    }, {
      key: "nonTrainableWeights",
      get: function () {
        return this.layer.nonTrainableWeights;
      }
    }, {
      key: "updates",
      get: function () {
        return this.layer._updates;
      }
    }, {
      key: "losses",
      get: function () {
        return this.layer.losses;
      }
    }, {
      key: "getWeights",
      value: function () {
        return this.layer.getWeights();
      }
    }, {
      key: "setWeights",
      value: function (e) {
        this.layer.setWeights(e);
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          layer: {
            className: this.layer.getClassName(),
            config: this.layer.getConfig()
          }
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }, {
      key: "setFastWeightInitDuringBuild",
      value: function (e) {
        N(v(n.prototype), "setFastWeightInitDuringBuild", this).call(this, e);
        if (this.layer != null) {
          this.layer.setFastWeightInitDuringBuild(e);
        }
      }
    }], [{
      key: "fromConfig",
      value: function (e, t, n = {}) {
        var r = t.layer;
        var a = rle(r, n);
        delete t.layer;
        var i = {
          layer: a
        };
        Object.assign(i, t);
        return new e(i);
      }
    }]);
    return n;
  }(wce);
  var Afe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).supportsMasking = true;
      return r;
    }
    p(n, [{
      key: "build",
      value: function (e) {
        if ((e = hce(e)).length < 3) {
          throw new Cse(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);
        }
        this.inputSpec = [{
          shape: e
        }];
        var t = [e[0]].concat(e.slice(2));
        if (!this.layer.built) {
          this.layer.build(t);
          this.layer.built = true;
        }
        N(v(n.prototype), "build", this).call(this, e);
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t = [(e = hce(e))[0]].concat(e.slice(2));
        var n = this.layer.computeOutputShape(t);
        var r = e[1];
        return [n[0], r].concat(n.slice(1));
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          return wpe(function (e, r) {
            return [lce(n.layer.call(e, t)), []];
          }, e = lce(e), [], false, null, null, false, true)[1];
        });
      }
    }]);
    return n;
  }(Cfe);
  Afe.className = "TimeDistributed";
  Kre(Afe);
  var Rfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      var a = e.layer.getConfig();
      var i = {};
      i.className = e.layer.getClassName();
      i.config = a;
      r.forwardLayer = rle(i);
      a.goBackwards = a.goBackwards !== true;
      var o;
      var s = {};
      s.className = e.layer.getClassName();
      s.config = a;
      r.backwardLayer = rle(s);
      r.forwardLayer.name = "forward_" + r.forwardLayer.name;
      r.backwardLayer.name = "backward_" + r.backwardLayer.name;
      r.mergeMode = e.mergeMode === undefined ? "concat" : e.mergeMode;
      o = r.mergeMode;
      qse(iue, "BidirectionalMergeMode", o);
      if (e.weights) {
        throw new Ase("weights support is not implemented for Bidirectional layer yet.");
      }
      r._stateful = e.layer.stateful;
      r.returnSequences = e.layer.returnSequences;
      r.returnState = e.layer.returnState;
      r.supportsMasking = true;
      r._trainable = true;
      r.inputSpec = e.layer.inputSpec;
      r.numConstants = null;
      return r;
    }
    p(n, [{
      key: "trainable",
      get: function () {
        return this._trainable;
      },
      set: function (e) {
        this._trainable = e;
        if (this.forwardLayer != null) {
          this.forwardLayer.trainable = e;
        }
        if (this.backwardLayer != null) {
          this.backwardLayer.trainable = e;
        }
      }
    }, {
      key: "getWeights",
      value: function () {
        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
      }
    }, {
      key: "setWeights",
      value: function (e) {
        var t = e.length;
        var n = Math.floor(t / 2);
        this.forwardLayer.setWeights(e.slice(0, n));
        this.backwardLayer.setWeights(e.slice(n));
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t;
        var n;
        var r;
        var a = this.forwardLayer.computeOutputShape(e);
        if (!Array.isArray(a) || !Array.isArray(a[0])) {
          a = [a];
        }
        if (this.returnState) {
          r = a.slice(1);
          t = a[0];
        } else {
          t = a[0];
        }
        if (this.mergeMode === "concat") {
          t[t.length - 1] *= 2;
          n = [t];
        } else {
          n = this.mergeMode == null ? [t, t.slice()] : [t];
        }
        if (this.returnState) {
          if (this.mergeMode == null) {
            return n.concat(r).concat(r.slice());
          } else {
            return [t].concat(r).concat(r.slice());
          }
        } else {
          return Mse(n);
        }
      }
    }, {
      key: "apply",
      value: function (e, t) {
        var r = t == null ? null : t.initialState;
        var a = t == null ? null : t.constants;
        if (t == null) {
          t = {};
        }
        var i = kpe(e, r, a, this.numConstants);
        e = i.inputs;
        r = i.initialState;
        a = i.constants;
        if (Array.isArray(e)) {
          r = e.slice(1);
          e = e[0];
        }
        if ((r == null || r.length === 0) && a == null) {
          return N(v(n.prototype), "apply", this).call(this, e, t);
        }
        var o = [];
        var s = [];
        if (r != null) {
          var u = r.length;
          if (u % 2 > 0) {
            throw new Cse("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
          }
          t.initialState = r;
          o.push.apply(o, T(r));
          var c = r.map(function (e) {
            return new gce({
              shape: e.shape
            });
          });
          this.forwardLayer.stateSpec = c.slice(0, u / 2);
          this.backwardLayer.stateSpec = c.slice(u / 2);
          s.push.apply(s, T(c));
        }
        if (a != null) {
          throw new Ase("Support for constants in Bidirectional layers is not implemented yet.");
        }
        var l = o[0] instanceof yce;
        for (var h = 0, p = o; h < p.length; h++) {
          if (p[h] instanceof yce !== l) {
            throw new Cse("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
          }
        }
        if (l) {
          var f = [e].concat(o);
          var d = this.inputSpec.concat(s);
          var m = this.inputSpec;
          this.inputSpec = d;
          var g = N(v(n.prototype), "apply", this).call(this, f, t);
          this.inputSpec = m;
          return g;
        }
        return N(v(n.prototype), "apply", this).call(this, e, t);
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r;
          var a;
          var i;
          var o;
          var s = t.initialState;
          if (s == null) {
            r = n.forwardLayer.call(e, t);
            a = n.backwardLayer.call(e, t);
          } else {
            var u = s.slice(0, s.length / 2);
            var c = s.slice(s.length / 2);
            r = n.forwardLayer.call(e, Object.assign(t, {
              initialState: u
            }));
            a = n.backwardLayer.call(e, Object.assign(t, {
              initialState: c
            }));
          }
          if (n.returnState) {
            if (Array.isArray(r)) {
              i = r.slice(1).concat(a.slice(1));
            }
            r = r[0];
            a = a[0];
          }
          if (n.returnSequences) {
            a = pte(a, 1);
          }
          if (n.mergeMode === "concat") {
            o = Cue([r, a]);
          } else if (n.mergeMode === "sum") {
            o = d8(r, a);
          } else if (n.mergeMode === "ave") {
            o = g8(0.5, d8(r, a));
          } else if (n.mergeMode === "mul") {
            o = g8(r, a);
          } else if (n.mergeMode == null) {
            o = [r, a];
          }
          if (n.returnState) {
            if (n.mergeMode == null) {
              return o.concat(i);
            } else {
              return [o].concat(i);
            }
          } else {
            return o;
          }
        });
      }
    }, {
      key: "resetStates",
      value: function (e) {
        this.forwardLayer.resetStates();
        this.backwardLayer.resetStates();
      }
    }, {
      key: "build",
      value: function (e) {
        var t = this;
        hue(this.forwardLayer.name, function () {
          t.forwardLayer.build(e);
        });
        hue(this.backwardLayer.name, function () {
          t.backwardLayer.build(e);
        });
        this.built = true;
      }
    }, {
      key: "computeMask",
      value: function (e, t) {
        var n;
        if (Array.isArray(t)) {
          t = t[0];
        }
        n = this.returnSequences ? this.mergeMode == null ? [t, t] : t : this.mergeMode == null ? [null, null] : null;
        if (this.returnState) {
          var r = this.forwardLayer.states.map(function (e) {
            return null;
          });
          if (Array.isArray(n)) {
            return n.concat(r).concat(r);
          } else {
            return [n].concat(r).concat(r);
          }
        }
        return n;
      }
    }, {
      key: "trainableWeights",
      get: function () {
        return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
      }
    }, {
      key: "nonTrainableWeights",
      get: function () {
        return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
      }
    }, {
      key: "setFastWeightInitDuringBuild",
      value: function (e) {
        N(v(n.prototype), "setFastWeightInitDuringBuild", this).call(this, e);
        if (this.forwardLayer != null) {
          this.forwardLayer.setFastWeightInitDuringBuild(e);
        }
        if (this.backwardLayer != null) {
          this.backwardLayer.setFastWeightInitDuringBuild(e);
        }
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          mergeMode: this.mergeMode
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }], [{
      key: "fromConfig",
      value: function (e, t) {
        var n = rle(t.layer);
        delete t.layer;
        if (t.numConstants != null) {
          throw new Ase("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
        }
        var r = t;
        r.layer = n;
        return new e(r);
      }
    }]);
    return n;
  }(Cfe);
  Rfe.className = "Bidirectional";
  Kre(Rfe);
  var _fe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).scale = e.scale;
      if (e.offset) {
        r.offset = e.offset;
      } else {
        r.offset = 0;
      }
      return r;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = {
          scale: this.scale,
          offset: this.offset
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          if ((e = lce(e)).dtype !== "float32") {
            e = wue(e, "float32");
          }
          return d8(g8(e, n.scale), n.offset);
        });
      }
    }]);
    return n;
  }(wce);
  _fe.className = "Rescaling";
  Kre(_fe);
  var Ofe = Pre.resizeBilinear;
  var Ffe = Pre.cropAndResize;
  var Dfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).height = e.height;
      r.width = e.width;
      return r;
    }
    p(n, [{
      key: "centerCrop",
      value: function (e, t, n, r, a, i, o, s) {
        return X5(function () {
          var u;
          var c = false;
          var l = [t / i, n / o, (r + t) / i, (a + n) / o];
          var h = [];
          if (e.rank === 3) {
            c = true;
            u = Pte([e]);
          } else {
            u = e;
          }
          for (var p = 0; p < u.shape[0]; p++) {
            h.push(l);
          }
          var f = V5(h, [h.length, 4]);
          var d = ste(0, h.length, 1, "int32");
          var v = Ffe(u, f, d, [r, a], "nearest");
          return wue(c ? lce(rne(v)) : v, s);
        });
      }
    }, {
      key: "upsize",
      value: function (e, t, n, r) {
        return X5(function () {
          return wue(Ofe(e, [t, n]), r);
        });
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = lce(e);
          var r = t.dtype;
          var a = t.shape;
          var i = a[a.length - 3];
          var o = a[a.length - 2];
          var s = 0;
          if (i !== n.height) {
            s = Math.floor((i - n.height) / 2);
          }
          var u = 0;
          if (o !== n.width && (u = Math.floor((o - n.width) / 2)) === 0) {
            u = 1;
          }
          if (s >= 0 && u >= 0) {
            return n.centerCrop(t, s, u, n.height, n.width, i, o, r);
          } else {
            return n.upsize(e, n.height, n.width, r);
          }
        });
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          height: this.height,
          width: this.width
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t = (e = hce(e)).length - 3;
        var n = e.length - 2;
        e[t] = this.height;
        e[n] = this.width;
        return e;
      }
    }]);
    return n;
  }(wce);
  Dfe.className = "CenterCrop";
  Kre(Dfe);
  var Mfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).numTokens = e.numTokens;
      if (e.outputMode) {
        r.outputMode = e.outputMode;
      } else {
        r.outputMode = "multiHot";
      }
      return r;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = {
          numTokens: this.numTokens,
          outputMode: this.outputMode
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        if ((e = hce(e)) == null) {
          return [this.numTokens];
        } else if (this.outputMode === "oneHot" && e[e.length - 1] !== 1) {
          e.push(this.numTokens);
          return e;
        } else {
          e[e.length - 1] = this.numTokens;
          return e;
        }
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var r;
          if ((e = lce(e)).dtype !== "int32") {
            e = wue(e, "int32");
          }
          if (t.countWeights !== undefined) {
            if (n.outputMode !== "count") {
              throw new Cse(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);
            }
            r = lce(t.countWeights);
          }
          var a = n9(e);
          var i = r9(e);
          var o = b9(n.numTokens, a).bufferSync().get(0);
          var s = x9(i, 0).bufferSync().get(0);
          if (!o || !s) {
            throw new Cse(`Input values must be between 0 < values <= numTokens with numTokens=${n.numTokens}`);
          }
          return function (e, t, n, r) {
            var a = lce(e);
            if (a.dtype !== "int32") {
              a = wue(a, "int32");
            }
            if (t === "int") {
              return a;
            }
            var i = a.shape;
            if (a.rank === 0) {
              a = f9(a, -1);
            }
            if (t === "oneHot" && a.shape[a.shape.length - 1] !== 1) {
              a = f9(a, -1);
            }
            if (a.rank > 2) {
              throw new Cse(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${a.rank}.`);
            }
            var o;
            var s = ["multiHot", "oneHot"].includes(t);
            o = R7(a, r !== undefined && t === "count" ? r : [], n, s);
            if (t !== "tfIdf") {
              return o;
            }
            if (r) {
              return g8(o, r);
            }
            throw new Cse("When outputMode is 'tfIdf', weights must be provided.");
          }(e, n.outputMode, n.numTokens, r);
        });
      }
    }]);
    return n;
  }(wce);
  Mfe.className = "CategoryEncoding";
  Kre(Mfe);
  var Lfe = new Set(["bilinear", "nearest"]);
  var zfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).height = e.height;
      r.width = e.width;
      if (e.interpolation) {
        if (!Lfe.has(e.interpolation)) {
          throw new Cse(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);
        }
        r.interpolation = e.interpolation;
      } else {
        r.interpolation = "bilinear";
      }
      r.cropToAspectRatio = Boolean(e.cropToAspectRatio);
      return r;
    }
    p(n, [{
      key: "computeOutputShape",
      value: function (e) {
        var t = (e = hce(e))[2];
        return [this.height, this.width, t];
      }
    }, {
      key: "getConfig",
      value: function () {
        var e = {
          height: this.height,
          width: this.width,
          interpolation: this.interpolation,
          cropToAspectRatio: this.cropToAspectRatio
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = [n.height, n.width];
          if (n.interpolation === "bilinear") {
            return Pre.resizeBilinear(e, t, !n.cropToAspectRatio);
          }
          if (n.interpolation === "nearest") {
            return Pre.resizeNearestNeighbor(e, t, !n.cropToAspectRatio);
          }
          throw new Error(`Interpolation is ${n.interpolation} but only ${T(Lfe)} are supported`);
        });
      }
    }]);
    return n;
  }(wce);
  zfe.className = "Resizing";
  Kre(zfe);
  var Pfe = function () {
    function e(t) {
      l(this, e);
      this.seed = t;
    }
    p(e, [{
      key: "next",
      value: function () {
        if (this.seed !== undefined) {
          return this.seed++;
        }
      }
    }]);
    return e;
  }();
  Pfe.className = "RandomSeed";
  var Bfe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      (r = t.call(this, e)).randomGenerator = new Pfe(e.seed);
      return r;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = {
          seed: this.randomGenerator.seed
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }]);
    return n;
  }(wce);
  Bfe.className = "BaseRandomLayer";
  var Wfe = new Set(["bilinear", "nearest"]);
  var Ufe = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      var r;
      l(this, n);
      r = t.call(this, e);
      var a = e.factor;
      var i = e.interpolation;
      var o = i === undefined ? "bilinear" : i;
      r.factor = a;
      if (Array.isArray(r.factor) && r.factor.length === 2) {
        r.widthLower = r.factor[0];
        r.widthUpper = r.factor[1];
      } else {
        if (Array.isArray(r.factor) || !(r.factor > 0)) {
          throw new Cse(`Invalid factor: ${r.factor}. Must be positive number or tuple of 2 numbers`);
        }
        r.widthLower = -r.factor;
        r.widthUpper = r.factor;
      }
      if (r.widthLower < -1 || r.widthUpper < -1) {
        throw new Cse(`factor must have values larger than -1. Got: ${r.factor}`);
      }
      if (r.widthUpper < r.widthLower) {
        throw new Cse(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${r.widthUpper}.
        Got lower bound: ${r.widthLower}
      `);
      }
      if (o) {
        if (!Wfe.has(o)) {
          throw new Cse(`Invalid interpolation parameter: ${o} is not implemented`);
        }
        r.interpolation = o;
      }
      return r;
    }
    p(n, [{
      key: "getConfig",
      value: function () {
        var e = {
          factor: this.factor,
          interpolation: this.interpolation
        };
        var t = N(v(n.prototype), "getConfig", this).call(this);
        Object.assign(e, t);
        return e;
      }
    }, {
      key: "computeOutputShape",
      value: function (e) {
        var t = (e = hce(e))[2];
        return [this.imgHeight, -1, t];
      }
    }, {
      key: "call",
      value: function (e, t) {
        var n = this;
        return X5(function () {
          var t = lce(e);
          n.imgHeight = t.shape[t.shape.length - 3];
          var r = t.shape[t.shape.length - 2];
          n.widthFactor = ite([1], 1 + n.widthLower, 1 + n.widthUpper, "float32", n.randomGenerator.next());
          var a = n.widthFactor.dataSync()[0] * r;
          a = Math.round(a);
          var i = [n.imgHeight, a];
          switch (n.interpolation) {
            case "bilinear":
              return Pre.resizeBilinear(e, i);
            case "nearest":
              return Pre.resizeNearestNeighbor(e, i);
            default:
              throw new Error(`Interpolation is ${n.interpolation}
          but only ${T(Wfe)} are supported`);
          }
        });
      }
    }]);
    return n;
  }(Bfe);
  function Vfe(e) {
    return new vfe(e);
  }
  function Gfe(e) {
    return new yfe(e);
  }
  function jfe(e) {
    return new kfe(e);
  }
  function Hfe(e) {
    return new Nfe(e);
  }
  function qfe(e) {
    return new Efe(e);
  }
  function Kfe(e) {
    return new dfe(e);
  }
  function Xfe(e) {
    return new gfe(e);
  }
  Ufe.className = "RandomWidth";
  Kre(Ufe);
  var Yfe = {
    __proto__: null,
    Layer: wce,
    RNN: Ipe,
    RNNCell: Npe,
    activation: function (e) {
      return new Upe(e);
    },
    add: function (e) {
      return new Xpe(e);
    },
    alphaDropout: function (e) {
      return new afe(e);
    },
    average: function (e) {
      return new Jpe(e);
    },
    averagePooling1d: Vfe,
    averagePooling2d: Gfe,
    averagePooling3d: jfe,
    avgPool1d: function (e) {
      return Vfe(e);
    },
    avgPool2d: function (e) {
      return Gfe(e);
    },
    avgPool3d: function (e) {
      return jfe(e);
    },
    avgPooling1d: function (e) {
      return Vfe(e);
    },
    avgPooling2d: function (e) {
      return Gfe(e);
    },
    avgPooling3d: function (e) {
      return jfe(e);
    },
    batchNormalization: function (e) {
      return new ufe(e);
    },
    bidirectional: function (e) {
      return new Rfe(e);
    },
    categoryEncoding: function (e) {
      return new Mfe(e);
    },
    centerCrop: function (e) {
      return new Dfe(e);
    },
    concatenate: function (e) {
      return new $pe(e);
    },
    conv1d: function (e) {
      return new gpe(e);
    },
    conv2d: function (e) {
      return new hpe(e);
    },
    conv2dTranspose: function (e) {
      return new fpe(e);
    },
    conv3d: function (e) {
      return new ppe(e);
    },
    conv3dTranspose: function (e) {
      return new dpe(e);
    },
    convLstm2d: function (e) {
      return new Lpe(e);
    },
    convLstm2dCell: function (e) {
      return new Mpe(e);
    },
    cropping2D: function (e) {
      return new ype(e);
    },
    dense: function (e) {
      return new Bpe(e);
    },
    depthwiseConv2d: function (e) {
      return new xpe(e);
    },
    dot: function (e) {
      return new tfe(e);
    },
    dropout: function (e) {
      return new zpe(e);
    },
    elu: function (e) {
      return new Qhe(e);
    },
    embedding: function (e) {
      return new qpe(e);
    },
    flatten: function (e) {
      return new Wpe(e);
    },
    gaussianDropout: function (e) {
      return new rfe(e);
    },
    gaussianNoise: function (e) {
      return new nfe(e);
    },
    globalAveragePooling1d: function (e) {
      return new Ife(e);
    },
    globalAveragePooling2d: function (e) {
      return new Tfe(e);
    },
    globalMaxPool1d: Hfe,
    globalMaxPool2d: qfe,
    globalMaxPooling1d: Hfe,
    globalMaxPooling2d: qfe,
    gru: function (e) {
      return new Cpe(e);
    },
    gruCell: function (e) {
      return new Epe(e);
    },
    input: Ihe,
    inputLayer: function (e) {
      return new Nce(e);
    },
    layerNormalization: function (e) {
      return new cfe(e);
    },
    leakyReLU: function (e) {
      return new Jhe(e);
    },
    lstm: function (e) {
      return new Rpe(e);
    },
    lstmCell: function (e) {
      return new Ape(e);
    },
    masking: function (e) {
      return new Hpe(e);
    },
    maxPool1d: Kfe,
    maxPool2d: Xfe,
    maxPooling1d: Kfe,
    maxPooling2d: Xfe,
    maxPooling3d: function (e) {
      return new xfe(e);
    },
    maximum: function (e) {
      return new Zpe(e);
    },
    minimum: function (e) {
      return new Qpe(e);
    },
    multiply: function (e) {
      return new Ype(e);
    },
    permute: function (e) {
      return new jpe(e);
    },
    prelu: function (e) {
      return new Zhe(e);
    },
    randomWidth: function (e) {
      return new Ufe(e);
    },
    reLU: function (e) {
      return new Yhe(e);
    },
    repeatVector: function (e) {
      return new Vpe(e);
    },
    rescaling: function (e) {
      return new _fe(e);
    },
    reshape: function (e) {
      return new Gpe(e);
    },
    resizing: function (e) {
      return new zfe(e);
    },
    rnn: function (e) {
      return new Ipe(e);
    },
    separableConv2d: function (e) {
      return new mpe(e);
    },
    simpleRNN: function (e) {
      return new Tpe(e);
    },
    simpleRNNCell: function (e) {
      return new Spe(e);
    },
    softmax: function (e) {
      return new epe(e);
    },
    spatialDropout1d: function (e) {
      return new Ppe(e);
    },
    stackedRNNCells: function (e) {
      return new _pe(e);
    },
    thresholdedReLU: function (e) {
      return new $he(e);
    },
    timeDistributed: function (e) {
      return new Afe(e);
    },
    upSampling2d: function (e) {
      return new bpe(e);
    },
    zeroPadding2d: function (e) {
      return new lfe(e);
    }
  };
  var Jfe = {
    __proto__: null,
    MAPE: function (e, t) {
      return sle(e, t);
    },
    MSE: function (e, t) {
      return ile(e, t);
    },
    binaryAccuracy: function (e, t) {
      return mle(e, t);
    },
    binaryCrossentropy: function (e, t) {
      return kle(e, t);
    },
    categoricalAccuracy: function (e, t) {
      return gle(e, t);
    },
    categoricalCrossentropy: function (e, t) {
      return Ile(e, t);
    },
    cosineProximity: function (e, t) {
      return fle(e, t);
    },
    mape: function (e, t) {
      return sle(e, t);
    },
    meanAbsoluteError: function (e, t) {
      return ole(e, t);
    },
    meanAbsolutePercentageError: function (e, t) {
      return sle(e, t);
    },
    meanSquaredError: function (e, t) {
      return ile(e, t);
    },
    mse: function (e, t) {
      return ile(e, t);
    },
    precision: function (e, t) {
      return ble(e, t);
    },
    recall: function (e, t) {
      return xle(e, t);
    },
    sparseCategoricalAccuracy: function (e, t) {
      return wle(e, t);
    }
  };
  var Zfe = {
    __proto__: null,
    modelFromJSON: function (e, t) {
      return ghe.apply(this, arguments);
    }
  };
  var Qfe = {
    __proto__: null,
    l1: function (e) {
      Vhe(t = e);
      return new jhe({
        l1: t != null ? t.l1 : null,
        l2: 0
      });
      var t;
    },
    l1l2: function (e) {
      return new jhe(e);
    },
    l2: function (e) {
      Vhe(t = e);
      return new jhe({
        l2: t != null ? t.l2 : null,
        l1: 0
      });
      var t;
    }
  };
  var $fe = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      var e;
      l(this, n);
      (e = t.apply(this, arguments)).model = null;
      return e;
    }
    p(n, [{
      key: "setModel",
      value: function (e) {
        if (!(e instanceof vhe)) {
          throw new Error("model must be a LayersModel, not some other Container");
        }
        this.model = e;
      }
    }]);
    return n;
  }(Yce);
  function ede(e, t) {
    return e < t;
  }
  function tde(e, t) {
    return e > t;
  }
  var nde = function (e) {
    d(i, e);
    var t;
    var n;
    var r;
    var a = w(i);
    function i(e) {
      var t;
      l(this, i);
      t = a.call(this);
      if (e == null) {
        e = {};
      }
      if (e.restoreBestWeights) {
        throw new Ase("restoreBestWeights = True is not implemented in EarlyStopping yet.");
      }
      t.monitor = e.monitor || "val_loss";
      t.minDelta = Math.abs(e.minDelta || 0);
      t.patience = e.patience || 0;
      t.verbose = e.verbose || 0;
      t.mode = e.mode || "auto";
      t.baseline = e.baseline;
      if (["auto", "min", "max"].indexOf(t.mode) === -1) {
        console.warn(`EarlyStopping mode '${t.mode}' is invalid. Falling back to mode 'auto'.`);
        t.mode = "auto";
      }
      if (t.mode === "min") {
        t.monitorFunc = ede;
      } else if (t.mode === "max" || t.monitor.indexOf("acc") !== -1) {
        t.monitorFunc = tde;
      } else {
        t.monitorFunc = ede;
      }
      if (t.monitorFunc === ede) {
        t.minDelta *= -1;
      }
      return t;
    }
    p(i, [{
      key: "onTrainBegin",
      value: (r = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.wait = 0;
                this.stoppedEpoch = 0;
                if (this.baseline != null) {
                  this.best = this.baseline;
                } else {
                  this.best = this.monitorFunc === ede ? Infinity : -Infinity;
                }
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return r.apply(this, arguments);
      })
    }, {
      key: "onEpochEnd",
      value: (n = c(o().mark(function e(t, n) {
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return qce(n);
              case 2:
                if ((r = this.getMonitorValue(n)) != null) {
                  e.next = 5;
                  break;
                }
                return e.abrupt("return");
              case 5:
                if (this.monitorFunc(r - this.minDelta, this.best)) {
                  this.best = r;
                  this.wait = 0;
                } else {
                  this.wait++;
                  if (this.wait >= this.patience) {
                    this.stoppedEpoch = t;
                    this.model.stopTraining = true;
                  }
                }
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return n.apply(this, arguments);
      })
    }, {
      key: "onTrainEnd",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.stoppedEpoch > 0 && this.verbose) {
                  console.log(`Epoch ${this.stoppedEpoch}: early stopping.`);
                }
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getMonitorValue",
      value: function (e) {
        if (e == null) {
          e = {};
        }
        var t = e[this.monitor];
        if (t == null) {
          console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`);
        }
        return t;
      }
    }]);
    return i;
  }($fe);
  var rde;
  var ade;
  var ide = {
    earlyStopping: function (e) {
      return new nde(e);
    }
  };
  k0().registerFlag("KEEP_INTERMEDIATE_TENSORS", function () {
    return false;
  }, function (e) {
    if (e) {
      console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
    }
  });
  (function (e) {
    e[e.DT_INVALID = 0] = "DT_INVALID";
    e[e.DT_FLOAT = 1] = "DT_FLOAT";
    e[e.DT_DOUBLE = 2] = "DT_DOUBLE";
    e[e.DT_INT32 = 3] = "DT_INT32";
    e[e.DT_UINT8 = 4] = "DT_UINT8";
    e[e.DT_INT16 = 5] = "DT_INT16";
    e[e.DT_INT8 = 6] = "DT_INT8";
    e[e.DT_STRING = 7] = "DT_STRING";
    e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64";
    e[e.DT_INT64 = 9] = "DT_INT64";
    e[e.DT_BOOL = 10] = "DT_BOOL";
    e[e.DT_QINT8 = 11] = "DT_QINT8";
    e[e.DT_QUINT8 = 12] = "DT_QUINT8";
    e[e.DT_QINT32 = 13] = "DT_QINT32";
    e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16";
    e[e.DT_QINT16 = 15] = "DT_QINT16";
    e[e.DT_QUINT16 = 16] = "DT_QUINT16";
    e[e.DT_UINT16 = 17] = "DT_UINT16";
    e[e.DT_COMPLEX128 = 18] = "DT_COMPLEX128";
    e[e.DT_HALF = 19] = "DT_HALF";
    e[e.DT_RESOURCE = 20] = "DT_RESOURCE";
    e[e.DT_VARIANT = 21] = "DT_VARIANT";
    e[e.DT_UINT32 = 22] = "DT_UINT32";
    e[e.DT_UINT64 = 23] = "DT_UINT64";
    e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF";
    e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF";
    e[e.DT_INT32_REF = 103] = "DT_INT32_REF";
    e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF";
    e[e.DT_INT16_REF = 105] = "DT_INT16_REF";
    e[e.DT_INT8_REF = 106] = "DT_INT8_REF";
    e[e.DT_STRING_REF = 107] = "DT_STRING_REF";
    e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF";
    e[e.DT_INT64_REF = 109] = "DT_INT64_REF";
    e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF";
    e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF";
    e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF";
    e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF";
    e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
    e[e.DT_QINT16_REF = 115] = "DT_QINT16_REF";
    e[e.DT_QUINT16_REF = 116] = "DT_QUINT16_REF";
    e[e.DT_UINT16_REF = 117] = "DT_UINT16_REF";
    e[e.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF";
    e[e.DT_HALF_REF = 119] = "DT_HALF_REF";
    e[e.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF";
    e[e.DT_VARIANT_REF = 121] = "DT_VARIANT_REF";
    e[e.DT_UINT32_REF = 122] = "DT_UINT32_REF";
    e[e.DT_UINT64_REF = 123] = "DT_UINT64_REF";
  })(rde ||= {});
  (function (e) {
    (function (e) {
      e[e.LEGACY = 0] = "LEGACY";
      e[e.V1 = 1] = "V1";
      e[e.V2 = 2] = "V2";
    })(e.CheckpointFormatVersion ||= {});
  })(ade ||= {});
  var ode = {};
  function sde(e) {
    return ode[e];
  }
  function ude(e, t, n, r, a) {
    var i = t.inputParams[e];
    if (i && i.inputIndexStart !== undefined) {
      var o = i.inputIndexStart;
      var s = i.inputIndexEnd === 0 ? undefined : i.inputIndexEnd === undefined ? o + 1 : i.inputIndexEnd;
      var u = o < 0 ? t.inputNames.length + o : o;
      if (i.type === "tensor") {
        return cde(t.inputNames[u], n, r, a);
      }
      if (i.type === "tensors") {
        var c = t.inputs.slice(o, s);
        var l = t.inputNames.slice(o, s).filter(function (e, t) {
          return c[t]?.op !== "NoOp";
        });
        return l.map(function (e) {
          return cde(e, n, r, a);
        });
      }
      var h = cde(t.inputNames[u], n, r, a);
      var p = h.dataSync();
      if (i.type === "number") {
        return p[0];
      } else {
        return s0(h.shape, p);
      }
    }
    var f = t.attrParams[e];
    return f && f.value;
  }
  function cde(e, t, n, r) {
    var a = S(fde(e, n), 2);
    var i = a[0];
    var o = a[1];
    if (r != null) {
      var s = r.getHashTableHandleByName(i);
      if (s != null) {
        return s;
      }
    }
    var u = n.currentContextIds.find(function (e) {
      return !!t[pde(i, e)];
    });
    if (u !== undefined) {
      return t[pde(i, u)][o];
    } else {
      return undefined;
    }
  }
  function lde(e, t, n) {
    return t[pde(e, n.currentContextId)];
  }
  function hde(e, t) {
    var n = S(fde(e, t), 3);
    var r = n[0];
    var a = n[1];
    var i = n[2];
    return [pde(r, t && t.currentContextId), a, i];
  }
  function pde(e, t) {
    if (t) {
      return `${e}-${t}`;
    } else {
      return e;
    }
  }
  function fde(e, t) {
    if (e === "") {
      return ["", 0, undefined];
    }
    var n = t != null && t.parseNodeNameCache != null;
    if (n) {
      var r = t.parseNodeNameCache.get(e);
      if (r != null) {
        return r;
      }
    }
    var a;
    var i = e.split(":");
    if (i.length === 1) {
      a = [e, 0, undefined];
    } else {
      var o = i[0];
      var s = i.length === 3 ? i[1] : undefined;
      a = [o, Number(i[i.length - 1]), s];
    }
    if (n) {
      t.parseNodeNameCache.set(e, a);
    }
    return a;
  }
  function dde(e, t, n) {
    var r = ude("pad", e, t, n);
    if (r === "explicit") {
      r = ude("explicitPaddings", e, t, n);
      var a = [[0, 0], [0, 0], [0, 0], [0, 0]];
      for (var i = 0; i < 4; i++) {
        a[i][0] = r[i * 2];
        a[i][1] = r[i * 2 + 1];
      }
      return a;
    }
    return r;
  }
  function vde(e) {
    if (e.kept) {
      return e;
    } else {
      return p8(e);
    }
  }
  var mde = {
    __proto__: null,
    json: [{
      tfOpName: "Add",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "AddV2",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "AddN",
      category: "arithmetic",
      inputs: [{
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }]
    }, {
      tfOpName: "BiasAdd",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }]
    }, {
      tfOpName: "Sub",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "RealDiv",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Div",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "DivNoNan",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "FloorDiv",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Mul",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Maximum",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Minimum",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Pow",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "SquaredDifference",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Mod",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "FloorMod",
      category: "arithmetic",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }]
  };
  var gde = {
    __proto__: null,
    json: [{
      tfOpName: "Abs",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Acos",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Asin",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Atan",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Atan2",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "y",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Ceil",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "ClipByValue",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "clipValueMin",
        type: "number"
      }, {
        start: 2,
        name: "clipValueMax",
        type: "number"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Complex",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "real",
        type: "tensor"
      }, {
        start: 1,
        name: "imag",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "ComplexAbs",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Cos",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Cosh",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Elu",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Exp",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Floor",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Log",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Imag",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Neg",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Real",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Prelu",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "alpha",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Relu",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Relu6",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Selu",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Sigmoid",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Sin",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Sinh",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Sqrt",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Rsqrt",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Square",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Tan",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Tanh",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Sign",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Round",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Expm1",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Log1p",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Reciprocal",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Softplus",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Asinh",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Acosh",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Atanh",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Erf",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LeakyRelu",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 0.2
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "IsNan",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "IsFinite",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "IsInf",
      category: "basic_math",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }]
  };
  var yde = {
    __proto__: null,
    json: [{
      tfOpName: "EmptyTensorList",
      category: "control",
      inputs: [{
        start: 0,
        name: "elementShape",
        type: "shape"
      }, {
        start: 1,
        name: "maxNumElements",
        type: "number"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "LoopCond",
      category: "control",
      inputs: [{
        start: 0,
        name: "pred",
        type: "tensor"
      }]
    }, {
      tfOpName: "Switch",
      category: "control",
      inputs: [{
        start: 0,
        name: "data",
        type: "tensor"
      }, {
        start: 1,
        name: "pred",
        type: "tensor"
      }]
    }, {
      tfOpName: "Merge",
      category: "control",
      inputs: [{
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }]
    }, {
      tfOpName: "Enter",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "frame_name",
        name: "frameName",
        type: "string"
      }, {
        tfName: "is_constant",
        name: "isConstant",
        type: "bool"
      }]
    }, {
      tfOpName: "Exit",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "NextIteration",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "TensorArrayV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "size",
        type: "number"
      }],
      attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }, {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      }, {
        tfName: "dynamic_size",
        name: "dynamicSize",
        type: "bool"
      }, {
        tfName: "clear_after_read",
        name: "clearAfterRead",
        type: "bool"
      }, {
        tfName: "identical_element_shapes",
        name: "identicalElementShapes",
        type: "bool"
      }, {
        tfName: "tensor_array_name",
        name: "name",
        type: "string"
      }]
    }, {
      tfOpName: "TensorArrayWriteV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }, {
        start: 1,
        name: "index",
        type: "number"
      }, {
        start: 2,
        name: "tensor",
        type: "tensor"
      }, {
        start: 3,
        name: "flowIn",
        type: "number"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "TensorArrayReadV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }, {
        start: 1,
        name: "index",
        type: "number"
      }, {
        start: 2,
        name: "flowIn",
        type: "number"
      }],
      attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "TensorArrayGatherV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "number[]"
      }, {
        start: 2,
        name: "flowIn",
        type: "number"
      }],
      attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }, {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      }]
    }, {
      tfOpName: "TensorArrayScatterV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "number[]"
      }, {
        start: 2,
        name: "tensor",
        type: "tensor"
      }, {
        start: 3,
        name: "flowIn",
        type: "number"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorArrayConcatV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }, {
        start: 1,
        name: "flowIn",
        type: "number"
      }],
      attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }, {
        tfName: "element_shape_except0",
        name: "elementShapeExcept0",
        type: "shape",
        notSupported: true
      }]
    }, {
      tfOpName: "TensorArraySplitV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }, {
        start: 1,
        name: "tensor",
        type: "tensor"
      }, {
        start: 2,
        name: "lengths",
        type: "number[]"
      }, {
        start: 3,
        name: "flowIn",
        type: "number"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorArraySizeV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }, {
        start: 1,
        name: "flowIn",
        type: "number"
      }]
    }, {
      tfOpName: "TensorArrayCloseV3",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
      }]
    }, {
      tfOpName: "StatelessIf",
      category: "control",
      inputs: [{
        start: 0,
        name: "cond",
        type: "tensor"
      }, {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }],
      attrs: [{
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      }, {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }]
    }, {
      tfOpName: "If",
      category: "control",
      inputs: [{
        start: 0,
        name: "cond",
        type: "tensor"
      }, {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
      }],
      attrs: [{
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
      }, {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
      }]
    }, {
      tfOpName: "StatelessWhile",
      category: "control",
      inputs: [{
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }],
      attrs: [{
        tfName: "cond",
        name: "cond",
        type: "func"
      }, {
        tfName: "body",
        name: "body",
        type: "func"
      }]
    }, {
      tfOpName: "While",
      category: "control",
      inputs: [{
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
      }],
      attrs: [{
        tfName: "cond",
        name: "cond",
        type: "func"
      }, {
        tfName: "body",
        name: "body",
        type: "func"
      }]
    }, {
      tfOpName: "TensorListScatter",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "number[]"
      }, {
        start: 2,
        name: "elementShape",
        type: "shape"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListScatterV2",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "number[]"
      }, {
        start: 2,
        name: "elementShape",
        type: "shape"
      }, {
        start: 3,
        name: "numElements",
        type: "number"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListGather",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "number[]"
      }, {
        start: 2,
        name: "elementShape",
        type: "shape"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListGetItem",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }, {
        start: 1,
        name: "index",
        type: "number"
      }, {
        start: 2,
        name: "elementShape",
        type: "shape"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListSetItem",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }, {
        start: 1,
        name: "index",
        type: "number"
      }, {
        start: 2,
        name: "tensor",
        type: "tensor"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListReserve",
      category: "control",
      inputs: [{
        start: 0,
        name: "elementShape",
        type: "shape"
      }, {
        start: 1,
        name: "numElements",
        type: "number"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListFromTensor",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }, {
        start: 1,
        name: "elementShape",
        type: "shape"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListStack",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }, {
        start: 1,
        name: "elementShape",
        type: "shape"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }, {
        tfName: "num_elements",
        name: "numElements",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListSplit",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }, {
        start: 1,
        name: "elementShape",
        type: "shape"
      }, {
        start: 2,
        name: "lengths",
        type: "number[]"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListConcat",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }],
      attrs: [{
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      }, {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListConcatV2",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }],
      attrs: [{
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
      }, {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListPopBack",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }, {
        start: 1,
        name: "elementShape",
        type: "shape"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListPushBack",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }, {
        start: 1,
        name: "tensor",
        type: "tensor"
      }],
      attrs: [{
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "TensorListLength",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }]
    }, {
      tfOpName: "TensorListResize",
      category: "control",
      inputs: [{
        start: 0,
        name: "tensorListId",
        type: "tensor"
      }, {
        start: 1,
        name: "size",
        type: "number"
      }]
    }]
  };
  var bde = {
    __proto__: null,
    json: [{
      tfOpName: "AvgPool",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "MaxPool",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: [],
        notSupported: true
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "MaxPoolWithArgmax",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      }, {
        tfName: "include_batch_in_index",
        name: "includeBatchInIndex",
        type: "bool"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "AvgPool3D",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "MaxPool3D",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Conv1D",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }],
      attrs: [{
        tfName: "stride",
        name: "stride",
        type: "number"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NWC"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "dilation",
        name: "dilation",
        type: "number",
        defaultValue: 1
      }]
    }, {
      tfOpName: "Conv2D",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "useCudnnOnGpu",
        name: "useCudnnOnGpu",
        type: "bool"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }]
    }, {
      tfOpName: "_FusedConv2D",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }],
      attrs: [{
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }, {
        tfName: "use_cudnn_on_gpu",
        name: "useCudnnOnGpu",
        type: "bool",
        defaultValue: true
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [1, 1, 1, 1]
      }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      }, {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 0.0001
      }, {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      }]
    }, {
      tfOpName: "Conv2DBackpropInput",
      category: "convolution",
      inputs: [{
        start: 2,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }, {
        start: 0,
        name: "outputShape",
        type: "number[]"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        notSupported: true
      }]
    }, {
      tfOpName: "DepthwiseConv2d",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "input",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }]
    }, {
      tfOpName: "DepthwiseConv2dNative",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "input",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }]
    }, {
      tfOpName: "FusedDepthwiseConv2dNative",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }],
      attrs: [{
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [1, 1, 1, 1]
      }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
      }]
    }, {
      tfOpName: "Conv3D",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
      }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
      }]
    }, {
      tfOpName: "Dilation2D",
      category: "convolution",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "filter",
        type: "tensor"
      }],
      attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
      }, {
        tfName: "rates",
        name: "dilations",
        type: "number[]"
      }, {
        tfName: "padding",
        name: "pad",
        type: "string"
      }]
    }]
  };
  var xde = {
    __proto__: null,
    json: [{
      tfOpName: "Fill",
      category: "creation",
      inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
      }, {
        start: 1,
        name: "value",
        type: "number"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "LinSpace",
      category: "creation",
      inputs: [{
        start: 0,
        name: "start",
        type: "number"
      }, {
        start: 1,
        name: "stop",
        type: "number"
      }, {
        start: 2,
        name: "num",
        type: "number"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "OneHot",
      category: "creation",
      inputs: [{
        start: 0,
        name: "indices",
        type: "tensor"
      }, {
        start: 1,
        name: "depth",
        type: "number"
      }, {
        start: 2,
        name: "onValue",
        type: "number",
        defaultValue: 1
      }, {
        start: 3,
        name: "offValue",
        type: "number",
        defaultValue: 0
      }],
      attrs: [{
        tfName: "axis",
        name: "axis",
        type: "number",
        notSupported: true
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "Ones",
      category: "creation",
      inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "OnesLike",
      category: "creation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "RandomStandardNormal",
      category: "creation",
      inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
      }],
      attrs: [{
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: true
      }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: true
      }]
    }, {
      tfOpName: "RandomUniform",
      category: "creation",
      inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
      }],
      attrs: [{
        tfName: "minval",
        name: "minval",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "maxval",
        name: "maxval",
        type: "number",
        defaultValue: 1
      }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }, {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: true
      }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: true
      }]
    }, {
      tfOpName: "RandomUniformInt",
      category: "creation",
      inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
      }],
      attrs: [{
        tfName: "minval",
        name: "minval",
        type: "number"
      }, {
        tfName: "maxval",
        name: "maxval",
        type: "number"
      }, {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: true
      }]
    }, {
      tfOpName: "Range",
      category: "creation",
      inputs: [{
        start: 0,
        name: "start",
        type: "number"
      }, {
        start: 1,
        name: "stop",
        type: "number"
      }, {
        start: 2,
        name: "step",
        type: "number",
        defaultValue: 0
      }],
      attrs: [{
        tfName: "Tidx",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "TruncatedNormal",
      category: "creation",
      inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
      }],
      attrs: [{
        tfName: "means",
        name: "mean",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "stddev",
        name: "stdDev",
        type: "number",
        defaultValue: 1
      }, {
        tfName: "seed",
        name: "seed",
        type: "number"
      }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: true
      }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: true
      }]
    }, {
      tfOpName: "Zeros",
      category: "creation",
      inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "ZerosLike",
      category: "creation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "Multinomial",
      category: "creation",
      inputs: [{
        start: 0,
        name: "logits",
        type: "tensor"
      }, {
        start: 1,
        name: "numSamples",
        type: "number"
      }],
      attrs: [{
        tfName: "seed",
        name: "seed",
        type: "number"
      }, {
        tfName: "seed2",
        name: "seed2",
        type: "number"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }, {
        tfName: "output_dtype",
        name: "output_dtype",
        type: "dtype"
      }]
    }]
  };
  var kde = {
    __proto__: null,
    json: [{
      tfOpName: "NonMaxSuppressionV2",
      category: "dynamic",
      inputs: [{
        start: 0,
        name: "boxes",
        type: "tensor"
      }, {
        start: 1,
        name: "scores",
        type: "tensor"
      }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
      }]
    }, {
      tfOpName: "NonMaxSuppressionV3",
      category: "dynamic",
      inputs: [{
        start: 0,
        name: "boxes",
        type: "tensor"
      }, {
        start: 1,
        name: "scores",
        type: "tensor"
      }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
      }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }]
    }, {
      tfOpName: "NonMaxSuppressionV4",
      category: "dynamic",
      inputs: [{
        start: 0,
        name: "boxes",
        type: "tensor"
      }, {
        start: 1,
        name: "scores",
        type: "tensor"
      }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
      }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "T_threshold",
        name: "threshold",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "pad_to_max_output_size",
        name: "padToMaxOutputSize",
        type: "bool"
      }]
    }, {
      tfOpName: "NonMaxSuppressionV5",
      category: "dynamic",
      inputs: [{
        start: 0,
        name: "boxes",
        type: "tensor"
      }, {
        start: 1,
        name: "scores",
        type: "tensor"
      }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
      }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
      }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
      }, {
        start: 5,
        name: "softNmsSigma",
        type: "number"
      }]
    }, {
      tfOpName: "Where",
      category: "dynamic",
      inputs: [{
        start: 0,
        name: "condition",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "ListDiff",
      category: "dynamic",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "y",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }]
  };
  var wde = {
    __proto__: null,
    json: [{
      tfOpName: "LowerBound",
      category: "evaluation",
      inputs: [{
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      }, {
        start: 1,
        name: "values",
        type: "tensor"
      }]
    }, {
      tfOpName: "TopKV2",
      category: "evaluation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "k",
        type: "number"
      }],
      attrs: [{
        tfName: "sorted",
        name: "sorted",
        type: "bool"
      }]
    }, {
      tfOpName: "UpperBound",
      category: "evaluation",
      inputs: [{
        start: 0,
        name: "sortedSequence",
        type: "tensor"
      }, {
        start: 1,
        name: "values",
        type: "tensor"
      }]
    }, {
      tfOpName: "Unique",
      category: "evaluation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "UniqueV2",
      category: "evaluation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number"
      }]
    }]
  };
  var Ide = {
    __proto__: null,
    json: [{
      tfOpName: "PlaceholderWithDefault",
      category: "graph",
      inputs: [{
        start: 0,
        name: "default",
        type: "tensor"
      }],
      attrs: [{
        tfName: "shape",
        name: "shape",
        type: "shape"
      }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "Placeholder",
      category: "graph",
      attrs: [{
        tfName: "shape",
        name: "shape",
        type: "shape"
      }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "Const",
      category: "graph"
    }, {
      tfOpName: "Identity",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "IdentityN",
      category: "graph",
      inputs: [{
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }]
    }, {
      tfOpName: "Snapshot",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "Rank",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "Size",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "Shape",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "ShapeN",
      category: "graph",
      inputs: [{
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
      }]
    }, {
      tfOpName: "Print",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "data",
        type: "tensors"
      }],
      attrs: [{
        tfName: "message",
        name: "message",
        type: "string"
      }, {
        tfName: "first_n",
        name: "firstN",
        type: "number",
        notSupported: true
      }, {
        tfName: "summarize",
        name: "summarize",
        type: "number",
        defaultValue: 3
      }]
    }, {
      tfOpName: "NoOp",
      category: "graph",
      inputs: []
    }, {
      tfOpName: "StopGradient",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "FakeQuantWithMinMaxVars",
      category: "graph",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "min",
        name: "min",
        type: "number"
      }, {
        tfName: "max",
        name: "max",
        type: "number"
      }]
    }]
  };
  var Nde = {
    __proto__: null,
    json: [{
      tfOpName: "HashTable",
      category: "hash_table",
      inputs: [],
      attrs: [{
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      }, {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      }, {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      }, {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "HashTableV2",
      category: "hash_table",
      inputs: [],
      attrs: [{
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
      }, {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
      }, {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
      }, {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
      }]
    }, {
      tfOpName: "LookupTableImport",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }, {
        start: 1,
        name: "keys",
        type: "tensor"
      }, {
        start: 2,
        name: "values",
        type: "tensor"
      }],
      attrs: [{
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LookupTableImportV2",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }, {
        start: 1,
        name: "keys",
        type: "tensor"
      }, {
        start: 2,
        name: "values",
        type: "tensor"
      }],
      attrs: [{
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LookupTableFind",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }, {
        start: 1,
        name: "keys",
        type: "tensor"
      }, {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }],
      attrs: [{
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LookupTableFindV2",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }, {
        start: 1,
        name: "keys",
        type: "tensor"
      }, {
        start: 2,
        name: "defaultValue",
        type: "tensor"
      }],
      attrs: [{
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LookupTableSize",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }]
    }, {
      tfOpName: "LookupTableSizeV2",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }]
    }, {
      tfOpName: "InitializeTable",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }, {
        start: 1,
        name: "keys",
        type: "tensor"
      }, {
        start: 2,
        name: "values",
        type: "tensor"
      }]
    }, {
      tfOpName: "InitializeTableV2",
      category: "hash_table",
      inputs: [{
        start: 0,
        name: "tableHandle",
        type: "tensor"
      }, {
        start: 1,
        name: "keys",
        type: "tensor"
      }, {
        start: 2,
        name: "values",
        type: "tensor"
      }]
    }]
  };
  var Sde = {
    __proto__: null,
    json: [{
      tfOpName: "ResizeBilinear",
      category: "image",
      inputs: [{
        start: 0,
        name: "images",
        type: "tensor"
      }, {
        start: 1,
        name: "size",
        type: "number[]"
      }],
      attrs: [{
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      }, {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "ResizeNearestNeighbor",
      category: "image",
      inputs: [{
        start: 0,
        name: "images",
        type: "tensor"
      }, {
        start: 1,
        name: "size",
        type: "number[]"
      }],
      attrs: [{
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
      }, {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "CropAndResize",
      category: "image",
      inputs: [{
        start: 0,
        name: "image",
        type: "tensor"
      }, {
        start: 1,
        name: "boxes",
        type: "tensor"
      }, {
        start: 2,
        name: "boxInd",
        type: "tensor"
      }, {
        start: 3,
        name: "cropSize",
        type: "number[]"
      }],
      attrs: [{
        tfName: "method",
        name: "method",
        type: "string"
      }, {
        tfName: "extrapolation_value",
        name: "extrapolationValue",
        type: "number"
      }]
    }, {
      tfOpName: "ImageProjectiveTransformV3",
      category: "image",
      inputs: [{
        start: 0,
        name: "images",
        type: "tensor"
      }, {
        start: 1,
        name: "transforms",
        type: "tensor"
      }, {
        start: 2,
        name: "outputShape",
        type: "number[]"
      }, {
        start: 3,
        name: "fillValue",
        type: "number"
      }],
      attrs: [{
        tfName: "interpolation",
        name: "interpolation",
        type: "string"
      }, {
        tfName: "fill_mode",
        name: "fillMode",
        type: "string"
      }]
    }]
  };
  var Tde = {
    __proto__: null,
    json: [{
      tfOpName: "Equal",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "NotEqual",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Greater",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "GreaterEqual",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Less",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LessEqual",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LogicalAnd",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LogicalNot",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "LogicalOr",
      category: "logical",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Select",
      category: "logical",
      inputs: [{
        start: 0,
        name: "condition",
        type: "tensor"
      }, {
        start: 1,
        name: "a",
        type: "tensor"
      }, {
        start: 2,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "SelectV2",
      category: "logical",
      inputs: [{
        start: 0,
        name: "condition",
        type: "tensor"
      }, {
        start: 1,
        name: "a",
        type: "tensor"
      }, {
        start: 2,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "BitwiseAnd",
      category: "logical",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "y",
        type: "tensor"
      }]
    }]
  };
  var Ede = {
    __proto__: null,
    json: [{
      tfOpName: "_FusedMatMul",
      category: "matrices",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
      }],
      attrs: [{
        tfName: "num_args",
        name: "numArgs",
        type: "number"
      }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
      }, {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 0.0001
      }, {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: 0.2
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "MatMul",
      category: "matrices",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "BatchMatMul",
      category: "matrices",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "BatchMatMulV2",
      category: "matrices",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "b",
        type: "tensor"
      }],
      attrs: [{
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: false
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Transpose",
      category: "matrices",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "perm",
        type: "number[]"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Einsum",
      category: "matrices",
      inputs: [{
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }],
      attrs: [{
        tfName: "equation",
        name: "equation",
        type: "string"
      }, {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "MatrixBandPart",
      category: "matrices",
      inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
      }, {
        start: 1,
        name: "numLower",
        type: "tensor"
      }, {
        start: 1,
        name: "numUpper",
        type: "tensor"
      }]
    }]
  };
  var Cde = {
    __proto__: null,
    json: [{
      tfOpName: "EuclideanNorm",
      category: "normalization",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool",
        defaultValue: false
      }]
    }, {
      tfOpName: "FusedBatchNorm",
      category: "normalization",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "scale",
        type: "tensor"
      }, {
        start: 2,
        name: "offset",
        type: "tensor"
      }, {
        start: 3,
        name: "mean",
        type: "tensor"
      }, {
        start: 4,
        name: "variance",
        type: "tensor"
      }],
      attrs: [{
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 0.001
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }]
    }, {
      tfOpName: "FusedBatchNormV2",
      category: "normalization",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "scale",
        type: "tensor"
      }, {
        start: 2,
        name: "offset",
        type: "tensor"
      }, {
        start: 3,
        name: "mean",
        type: "tensor"
      }, {
        start: 4,
        name: "variance",
        type: "tensor"
      }],
      attrs: [{
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 0.001
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }]
    }, {
      tfOpName: "FusedBatchNormV3",
      category: "normalization",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "scale",
        type: "tensor"
      }, {
        start: 2,
        name: "offset",
        type: "tensor"
      }, {
        start: 3,
        name: "mean",
        type: "tensor"
      }, {
        start: 4,
        name: "variance",
        type: "tensor"
      }],
      attrs: [{
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 0.001
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: true
      }]
    }, {
      tfOpName: "LRN",
      category: "normalization",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "depth_radius",
        name: "radius",
        type: "number",
        defaultValue: 5
      }, {
        tfName: "bias",
        name: "bias",
        type: "number",
        defaultValue: 1
      }, {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 1
      }, {
        tfName: "beta",
        name: "beta",
        type: "number",
        defaultValue: 0.5
      }]
    }, {
      tfOpName: "Softmax",
      category: "normalization",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "LogSoftmax",
      category: "normalization",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }]
  };
  var Ade = {
    __proto__: null,
    json: [{
      tfOpName: "Bincount",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "size",
        type: "number"
      }, {
        start: 2,
        name: "weights",
        type: "tensor"
      }]
    }, {
      tfOpName: "DenseBincount",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "size",
        type: "number"
      }, {
        start: 2,
        name: "weights",
        type: "tensor"
      }],
      attrs: [{
        tfName: "binary_output",
        name: "binaryOutput",
        type: "bool"
      }]
    }, {
      tfOpName: "Max",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }]
    }, {
      tfOpName: "Mean",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }]
    }, {
      tfOpName: "Min",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }]
    }, {
      tfOpName: "Sum",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }]
    }, {
      tfOpName: "All",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }]
    }, {
      tfOpName: "Any",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }]
    }, {
      tfOpName: "ArgMax",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number"
      }]
    }, {
      tfOpName: "ArgMin",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number"
      }]
    }, {
      tfOpName: "Prod",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }],
      attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
      }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "Cumprod",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number"
      }],
      attrs: [{
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      }, {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }]
    }, {
      tfOpName: "Cumsum",
      category: "reduction",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number"
      }],
      attrs: [{
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
      }, {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
      }]
    }]
  };
  var Rde = {
    __proto__: null,
    json: [{
      tfOpName: "ConcatV2",
      category: "slice_join",
      inputs: [{
        start: 0,
        end: -1,
        name: "tensors",
        type: "tensors"
      }, {
        start: -1,
        name: "axis",
        type: "number"
      }],
      attrs: [{
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }]
    }, {
      tfOpName: "Concat",
      category: "slice_join",
      inputs: [{
        start: 1,
        end: 0,
        name: "tensors",
        type: "tensors"
      }, {
        start: 0,
        name: "axis",
        type: "number"
      }],
      attrs: [{
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
      }]
    }, {
      tfOpName: "GatherV2",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "tensor"
      }, {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }],
      attrs: [{
        tfName: "batch_dims",
        name: "batchDims",
        type: "number",
        defaultValue: 0
      }]
    }, {
      tfOpName: "Gather",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "tensor"
      }],
      attrs: [{
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        notSupported: true
      }]
    }, {
      tfOpName: "Reverse",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "dims",
        type: "bool[]"
      }]
    }, {
      tfOpName: "ReverseV2",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number[]"
      }]
    }, {
      tfOpName: "Slice",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "begin",
        type: "number[]"
      }, {
        start: 2,
        name: "size",
        type: "number[]"
      }]
    }, {
      tfOpName: "StridedSlice",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "begin",
        type: "number[]"
      }, {
        start: 2,
        name: "end",
        type: "number[]"
      }, {
        start: 3,
        name: "strides",
        type: "number[]"
      }],
      attrs: [{
        tfName: "begin_mask",
        name: "beginMask",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "end_mask",
        name: "endMask",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "new_axis_mask",
        name: "newAxisMask",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "ellipsis_mask",
        name: "ellipsisMask",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "shrink_axis_mask",
        name: "shrinkAxisMask",
        type: "number",
        defaultValue: 0
      }]
    }, {
      tfOpName: "Pack",
      category: "slice_join",
      inputs: [{
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
      }],
      attrs: [{
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      }]
    }, {
      tfOpName: "Unpack",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }],
      attrs: [{
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
      }, {
        tfName: "num",
        name: "num",
        type: "number",
        defaultValue: 0,
        notSupported: true
      }]
    }, {
      tfOpName: "Tile",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "reps",
        type: "number[]"
      }]
    }, {
      tfOpName: "Split",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "axis",
        type: "number",
        defaultValue: 0
      }, {
        start: 1,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "num_split",
        name: "numOrSizeSplits",
        type: "number",
        defaultValue: 1
      }]
    }, {
      tfOpName: "SplitV",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "numOrSizeSplits",
        type: "number[]"
      }, {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
      }]
    }, {
      tfOpName: "ScatterNd",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "indices",
        type: "tensor"
      }, {
        start: 1,
        name: "values",
        type: "tensor"
      }, {
        start: 2,
        name: "shape",
        type: "number[]"
      }]
    }, {
      tfOpName: "GatherNd",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "tensor"
      }]
    }, {
      tfOpName: "SparseToDense",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "sparseIndices",
        type: "tensor"
      }, {
        start: 1,
        name: "outputShape",
        type: "number[]"
      }, {
        start: 2,
        name: "sparseValues",
        type: "tensor"
      }, {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }],
      attrs: [{
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: false,
        notSupported: true
      }]
    }, {
      tfOpName: "TensorScatterUpdate",
      category: "slice_join",
      inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "tensor"
      }, {
        start: 2,
        name: "values",
        type: "tensor"
      }]
    }]
  };
  var _de = {
    __proto__: null,
    json: [{
      tfOpName: "SparseFillEmptyRows",
      category: "sparse",
      inputs: [{
        start: 0,
        name: "indices",
        type: "tensor"
      }, {
        start: 1,
        name: "values",
        type: "tensor"
      }, {
        start: 2,
        name: "denseShape",
        type: "tensor"
      }, {
        start: 3,
        name: "defaultValue",
        type: "tensor"
      }]
    }, {
      tfOpName: "SparseReshape",
      category: "sparse",
      inputs: [{
        start: 0,
        name: "inputIndices",
        type: "tensor"
      }, {
        start: 1,
        name: "inputShape",
        type: "tensor"
      }, {
        start: 2,
        name: "newShape",
        type: "tensor"
      }],
      attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: true
      }]
    }, {
      tfOpName: "SparseSegmentMean",
      category: "sparse",
      inputs: [{
        start: 0,
        name: "data",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "tensor"
      }, {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }]
    }, {
      tfOpName: "SparseSegmentSum",
      category: "sparse",
      inputs: [{
        start: 0,
        name: "data",
        type: "tensor"
      }, {
        start: 1,
        name: "indices",
        type: "tensor"
      }, {
        start: 2,
        name: "segmentIds",
        type: "tensor"
      }]
    }]
  };
  var Ode = {
    __proto__: null,
    json: [{
      tfOpName: "FFT",
      category: "spectral",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "IFFT",
      category: "spectral",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }]
    }, {
      tfOpName: "RFFT",
      category: "spectral",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: true
      }]
    }, {
      tfOpName: "IRFFT",
      category: "spectral",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: true
      }]
    }]
  };
  var Fde = {
    __proto__: null,
    json: [{
      tfOpName: "StaticRegexReplace",
      category: "string",
      inputs: [{
        start: 0,
        name: "input",
        type: "tensor"
      }],
      attrs: [{
        tfName: "pattern",
        name: "pattern",
        type: "string"
      }, {
        tfName: "rewrite",
        name: "rewrite",
        type: "string"
      }, {
        tfName: "replace_global",
        name: "replaceGlobal",
        type: "bool"
      }]
    }, {
      tfOpName: "StringNGrams",
      category: "string",
      inputs: [{
        start: 0,
        name: "data",
        type: "tensor"
      }, {
        start: 1,
        name: "dataSplits",
        type: "tensor"
      }],
      attrs: [{
        tfName: "separator",
        name: "separator",
        type: "string"
      }, {
        tfName: "ngram_widths",
        name: "nGramWidths",
        type: "number[]"
      }, {
        tfName: "left_pad",
        name: "leftPad",
        type: "string"
      }, {
        tfName: "right_pad",
        name: "rightPad",
        type: "string"
      }, {
        tfName: "pad_width",
        name: "padWidth",
        type: "number"
      }, {
        tfName: "preserve_short_sequences",
        name: "preserveShortSequences",
        type: "bool"
      }],
      outputs: ["ngrams", "ngrams_splits"]
    }, {
      tfOpName: "StringSplit",
      category: "string",
      inputs: [{
        start: 0,
        name: "input",
        type: "tensor"
      }, {
        start: 1,
        name: "delimiter",
        type: "tensor"
      }],
      attrs: [{
        tfName: "skip_empty",
        name: "skipEmpty",
        type: "bool"
      }],
      outputs: ["indices", "values", "shape"]
    }, {
      tfOpName: "StringToHashBucketFast",
      category: "string",
      inputs: [{
        start: 0,
        name: "input",
        type: "tensor"
      }],
      attrs: [{
        tfName: "num_buckets",
        name: "numBuckets",
        type: "number"
      }]
    }]
  };
  var Dde = {
    __proto__: null,
    json: [{
      tfOpName: "Cast",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "SrcT",
        name: "sdtype",
        type: "dtype",
        notSupported: true
      }, {
        tfName: "DstT",
        name: "dtype",
        type: "dtype"
      }]
    }, {
      tfOpName: "ExpandDims",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "axis",
        type: "number"
      }]
    }, {
      tfOpName: "MirrorPad",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "padding",
        type: "number[]"
      }],
      attrs: [{
        tfName: "mode",
        name: "mode",
        type: "string"
      }]
    }, {
      tfOpName: "Pad",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "padding",
        type: "number[]"
      }],
      attrs: [{
        tfName: "constant_value",
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }]
    }, {
      tfOpName: "PadV2",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "padding",
        type: "number[]"
      }, {
        start: 2,
        name: "constantValue",
        type: "number",
        defaultValue: 0
      }]
    }, {
      tfOpName: "Reshape",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "shape",
        type: "number[]"
      }]
    }, {
      tfOpName: "EnsureShape",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "shape",
        type: "number[]"
      }]
    }, {
      tfOpName: "Squeeze",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "axis",
        tfDeprecatedName: "squeeze_dims",
        name: "axis",
        type: "number[]"
      }]
    }, {
      tfOpName: "SpaceToBatchND",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "blockShape",
        type: "number[]"
      }, {
        start: 2,
        name: "paddings",
        type: "number[]"
      }]
    }, {
      tfOpName: "BatchToSpaceND",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "blockShape",
        type: "number[]"
      }, {
        start: 2,
        name: "crops",
        type: "number[]"
      }]
    }, {
      tfOpName: "DepthToSpace",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }],
      attrs: [{
        tfName: "block_size",
        name: "blockSize",
        type: "number"
      }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string"
      }]
    }, {
      tfOpName: "BroadcastTo",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
      }, {
        start: 1,
        name: "shape",
        type: "number[]"
      }],
      attrs: []
    }, {
      tfOpName: "BroadcastArgs",
      category: "transformation",
      inputs: [{
        start: 0,
        name: "s0",
        type: "tensor"
      }, {
        start: 1,
        name: "s1",
        type: "tensor"
      }],
      attrs: []
    }]
  };
  var Mde = function () {
    function e() {
      var t;
      l(this, e);
      var n = [mde, gde, yde, bde, xde, kde, wde, Ide, Nde, Sde, Tde, Ede, Cde, Ade, Rde, _de, Ode, Fde, Dde];
      var r = (t = []).concat.apply(t, T(n.map(function (e) {
        return e.json;
      })));
      this.opMappers = r.reduce(function (e, t) {
        e[t.tfOpName] = t;
        return e;
      }, {});
    }
    p(e, [{
      key: "transformGraph",
      value: function (e) {
        var t = this;
        var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var r = e.node;
        var a = [];
        var i = [];
        var o = [];
        var s = r.reduce(function (e, n) {
          e[n.name] = t.mapNode(n);
          if (n.op.startsWith("Placeholder")) {
            a.push(e[n.name]);
          } else if (n.op === "Const") {
            i.push(e[n.name]);
          } else if (n.input == null || n.input.length === 0) {
            o.push(e[n.name]);
          }
          return e;
        }, {});
        var u = [];
        var c = [];
        var l = {};
        var h = {};
        if (n != null) {
          l = this.mapSignatureEntries(n.inputs);
          h = this.mapSignatureEntries(n.outputs);
        }
        var p = Object.keys(s);
        p.forEach(function (e) {
          var t = s[e];
          t.inputNames.forEach(function (e, n) {
            var r = S(hde(e), 3);
            var a = r[0];
            var i = r[2];
            var o = s[a];
            if (o.outputs != null) {
              var u = o.outputs.indexOf(i);
              if (u !== -1) {
                var c = `${a}:${u}`;
                t.inputNames[n] = c;
              }
            }
            t.inputs.push(o);
            o.children.push(t);
          });
        });
        if (Object.keys(h).length === 0) {
          p.forEach(function (e) {
            var t = s[e];
            if (t.children.length === 0) {
              c.push(t);
            }
          });
        } else {
          Object.keys(h).forEach(function (e) {
            var t = S(hde(e), 1)[0];
            var n = s[t];
            if (n != null) {
              n.signatureKey = h[e];
              c.push(n);
            }
          });
        }
        if (Object.keys(l).length > 0) {
          Object.keys(l).forEach(function (e) {
            var t = S(hde(e), 1)[0];
            var n = s[t];
            if (n) {
              n.signatureKey = l[e];
              u.push(n);
            }
          });
        } else {
          u = a;
        }
        var f = {};
        if (e.library != null && e.library.function != null) {
          f = e.library.function.reduce(function (e, n) {
            e[n.signature.name] = t.mapFunction(n);
            return e;
          }, {});
        }
        var d = {
          nodes: s,
          inputs: u,
          outputs: c,
          weights: i,
          placeholders: a,
          signature: n,
          functions: f
        };
        if (o.length > 0) {
          d.initNodes = o;
        }
        return d;
      }
    }, {
      key: "mapSignatureEntries",
      value: function (e) {
        return Object.keys(e || {}).reduce(function (t, n) {
          t[e[n].name] = n;
          return t;
        }, {});
      }
    }, {
      key: "mapNode",
      value: function (e) {
        var t = sde(e.op) || this.opMappers[e.op] || {};
        if (e.attr == null) {
          e.attr = {};
        }
        var n = {
          name: e.name,
          op: e.op,
          category: t.category,
          inputNames: (e.input || []).map(function (e) {
            if (e.startsWith("^")) {
              return e.slice(1);
            } else {
              return e;
            }
          }),
          inputs: [],
          children: [],
          inputParams: {},
          attrParams: {},
          rawAttrs: e.attr,
          outputs: t.outputs
        };
        if (t.inputs != null) {
          n.inputParams = t.inputs.reduce(function (e, t) {
            e[t.name] = {
              type: t.type,
              inputIndexStart: t.start,
              inputIndexEnd: t.end
            };
            return e;
          }, {});
        }
        if (t.attrs != null) {
          n.attrParams = t.attrs.reduce(function (t, n) {
            var r = n.type;
            var a = undefined;
            switch (n.type) {
              case "string":
                if ((a = zde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = zde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "string[]":
                if ((a = Kde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Kde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "number":
                if ((a = Bde(e.attr, n.tfName, n.defaultValue || 0)) === undefined && n.tfDeprecatedName) {
                  a = Bde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "number[]":
                if ((a = qde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = qde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "bool":
                if ((a = Pde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Pde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "bool[]":
                if ((a = Yde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Yde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "shape":
                if ((a = Hde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Hde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "shape[]":
                if ((a = Xde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Xde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "dtype":
                if ((a = Vde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Vde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "dtype[]":
                if ((a = Gde(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Gde(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "func":
                if ((a = Ude(e.attr, n.tfName, n.defaultValue)) === undefined && n.tfDeprecatedName) {
                  a = Ude(e.attr, n.tfDeprecatedName, n.defaultValue);
                }
                break;
              case "tensor":
              case "tensors":
                break;
              default:
                throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`);
            }
            t[n.name] = {
              value: a,
              type: r
            };
            return t;
          }, {});
        }
        return n;
      }
    }, {
      key: "mapFunction",
      value: function (e) {
        var t = this;
        var n = e.nodeDef;
        var r = [];
        var a = {};
        if (n != null) {
          a = n.reduce(function (e, n) {
            e[n.name] = t.mapNode(n);
            if (n.op === "Const") {
              r.push(e[n.name]);
            }
            return e;
          }, {});
        }
        var i = [];
        var o = [];
        e.signature.inputArg.forEach(function (e) {
          var t = S(hde(e.name), 1)[0];
          var n = {
            name: t,
            op: "Placeholder",
            inputs: [],
            inputNames: [],
            category: "graph",
            inputParams: {},
            attrParams: {
              dtype: {
                value: Wde(e.type),
                type: "dtype"
              }
            },
            children: []
          };
          n.signatureKey = e.name;
          i.push(n);
          a[t] = n;
        });
        Object.keys(a).forEach(function (e) {
          var t = a[e];
          t.inputNames.forEach(function (e, n) {
            var r = S(hde(e), 3);
            var i = r[0];
            var o = r[2];
            var s = a[i];
            if (s.outputs != null) {
              var u = s.outputs.indexOf(o);
              if (u !== -1) {
                var c = `${i}:${u}`;
                t.inputNames[n] = c;
              }
            }
            t.inputs.push(s);
            s.children.push(t);
          });
        });
        var s = e.ret;
        e.signature.outputArg.forEach(function (e) {
          var t = S(hde(s[e.name]), 2);
          var n = t[0];
          var r = t[1];
          var i = a[n];
          if (i != null) {
            i.defaultOutput = r;
            o.push(i);
          }
        });
        var u = this.mapArgsToSignature(e);
        return {
          nodes: a,
          inputs: i,
          outputs: o,
          weights: r,
          placeholders: [],
          signature: u
        };
      }
    }, {
      key: "mapArgsToSignature",
      value: function (e) {
        var t = this;
        return {
          methodName: e.signature.name,
          inputs: e.signature.inputArg.reduce(function (e, n) {
            e[n.name] = t.mapArgToTensorInfo(n);
            return e;
          }, {}),
          outputs: e.signature.outputArg.reduce(function (n, r) {
            n[r.name] = t.mapArgToTensorInfo(r, e.ret);
            return n;
          }, {})
        };
      }
    }, {
      key: "mapArgToTensorInfo",
      value: function (e, t) {
        var n = e.name;
        if (t != null) {
          n = t[n];
        }
        return {
          name: n,
          dtype: e.type
        };
      }
    }], [{
      key: "Instance",
      get: function () {
        return this._instance ||= new this();
      }
    }]);
    return e;
  }();
  function Lde(e, t) {
    var n = Array.isArray(e) ? String.fromCharCode.apply(null, e) : function (e) {
      var t = k0().global;
      if (t.atob !== undefined) {
        return t.atob(e);
      }
      if (typeof Buffer != "undefined") {
        return new Buffer(e, "base64").toString();
      }
      throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
    }(e);
    if (t) {
      return n;
    } else {
      return n.toLowerCase();
    }
  }
  function zde(e, t, n, r = false) {
    var a = e[t];
    if (a != null) {
      return Lde(a.s, r);
    } else {
      return n;
    }
  }
  function Pde(e, t, n) {
    var r = e[t];
    if (r) {
      return r.b;
    } else {
      return n;
    }
  }
  function Bde(e, t, n) {
    var r = e[t] || {};
    var a = r.i ?? r.f ?? n;
    if (typeof a == "number") {
      return a;
    } else {
      return parseInt(a, 10);
    }
  }
  function Wde(e) {
    if (typeof e == "string") {
      e = rde[e];
    }
    switch (e) {
      case rde.DT_FLOAT:
      case rde.DT_HALF:
        return "float32";
      case rde.DT_INT32:
      case rde.DT_INT64:
      case rde.DT_INT8:
      case rde.DT_UINT8:
        return "int32";
      case rde.DT_BOOL:
        return "bool";
      case rde.DT_DOUBLE:
        return "float32";
      case rde.DT_STRING:
        return "string";
      default:
        return null;
    }
  }
  function Ude(e, t, n) {
    var r = e[t];
    if (r && r.func) {
      return r.func.name;
    } else {
      return n;
    }
  }
  function Vde(e, t, n) {
    var r = e[t];
    if (r && r.type) {
      return Wde(r.type);
    } else {
      return n;
    }
  }
  function Gde(e, t, n) {
    var r = e[t];
    if (r && r.list && r.list.type) {
      return r.list.type.map(function (e) {
        return Wde(e);
      });
    } else {
      return n;
    }
  }
  function jde(e) {
    if (!e.unknownRank) {
      if (e.dim != null) {
        return e.dim.map(function (e) {
          if (typeof e.size == "number") {
            return e.size;
          } else {
            return parseInt(e.size, 10);
          }
        });
      } else {
        return [];
      }
    }
  }
  function Hde(e, t, n) {
    var r = e[t];
    if (r && r.shape) {
      return jde(r.shape);
    } else {
      return n;
    }
  }
  function qde(e, t, n) {
    var r = e[t];
    if (r) {
      return ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function (e) {
        if (typeof e == "number") {
          return e;
        } else {
          return parseInt(e, 10);
        }
      });
    } else {
      return n;
    }
  }
  function Kde(e, t, n, r = false) {
    var a = e[t];
    if (a && a.list && a.list.s) {
      return a.list.s.map(function (e) {
        return Lde(e, r);
      });
    } else {
      return n;
    }
  }
  function Xde(e, t, n) {
    var r = e[t];
    if (r && r.list && r.list.shape) {
      return r.list.shape.map(function (e) {
        return jde(e);
      });
    } else {
      return n;
    }
  }
  function Yde(e, t, n) {
    var r = e[t];
    if (r && r.list && r.list.b) {
      return r.list.b;
    } else {
      return n;
    }
  }
  var Jde = function () {
    function e(t, n, r) {
      var a = this;
      l(this, e);
      this.node = t;
      this.tensorMap = n;
      this.context = r;
      this.inputs = [];
      this.attrs = {};
      this.inputs = t.inputNames.map(function (e) {
        return a.getInput(e);
      });
      if (t.rawAttrs != null) {
        this.attrs = Object.keys(t.rawAttrs).reduce(function (e, t) {
          e[t] = a.getAttr(t);
          return e;
        }, {});
      }
    }
    p(e, [{
      key: "getInput",
      value: function (e) {
        return cde(e, this.tensorMap, this.context);
      }
    }, {
      key: "getAttr",
      value: function (e, t) {
        var n = this.node.rawAttrs[e];
        if (n.tensor != null) {
          return cde(e, this.tensorMap, this.context);
        }
        if (n.i != null || n.f != null) {
          return Bde(this.node.rawAttrs, e, t);
        }
        if (n.s != null) {
          return zde(this.node.rawAttrs, e, t);
        }
        if (n.b != null) {
          return Pde(this.node.rawAttrs, e, t);
        }
        if (n.shape != null) {
          return Hde(this.node.rawAttrs, e, t);
        }
        if (n.type != null) {
          return Vde(this.node.rawAttrs, e, t);
        }
        if (n.list != null) {
          if (n.list.i != null || n.list.f != null) {
            return qde(this.node.rawAttrs, e, t);
          }
          if (n.list.s != null) {
            return Kde(this.node.rawAttrs, e, t);
          }
          if (n.list.shape != null) {
            return Xde(this.node.rawAttrs, e, t);
          }
          if (n.list.b != null) {
            return Yde(this.node.rawAttrs, e, t);
          }
          if (n.list.type != null) {
            return Gde(this.node.rawAttrs, e, t);
          }
        }
        return t;
      }
    }]);
    return e;
  }();
  var Zde = {
    __proto__: null,
    OP_SCOPE_SUFFIX: P5,
    abs: y8,
    acos: b8,
    acosh: x8,
    add: d8,
    addN: k8,
    all: w8,
    any: I8,
    argMax: N8,
    argMin: S8,
    asin: T8,
    asinh: E8,
    atan: C8,
    atan2: A8,
    atanh: R8,
    avgPool: Y8,
    avgPool3d: J8,
    basicLSTMCell: n7,
    batchNorm: a7,
    batchNorm2d: i7,
    batchNorm3d: o7,
    batchNorm4d: s7,
    batchToSpaceND: r7,
    bincount: u7,
    bitwiseAnd: c7,
    booleanMaskAsync: lne,
    broadcastArgs: l7,
    broadcastTo: h7,
    buffer: l8,
    cast: h8,
    ceil: p7,
    clipByValue: d7,
    clone: p8,
    complex: W5,
    concat: Z8,
    concat1d: v7,
    concat2d: m7,
    concat3d: g7,
    concat4d: y7,
    conv1d: x7,
    conv2d: b7,
    conv2dTranspose: w7,
    conv3d: I7,
    conv3dTranspose: S7,
    cos: T7,
    cosh: E7,
    cosineWindow: bne,
    cumprod: C7,
    cumsum: A7,
    denseBincount: R7,
    depthToSpace: _7,
    depthwiseConv2d: O7,
    diag: F7,
    dilation2d: D7,
    div: m8,
    divNoNan: V7,
    dot: G7,
    dropout: gne,
    einsum: j7,
    elu: H7,
    enclosingPowerOfTwo: yne,
    ensureShape: q7,
    equal: B7,
    erf: K7,
    euclideanNorm: h9,
    exp: p9,
    expandDims: f9,
    expm1: d9,
    eye: m9,
    fft: _te,
    fill: f7,
    floor: g9,
    floorDiv: v8,
    fused: One,
    gather: y9,
    gatherND: mne,
    greater: b9,
    greaterEqual: x9,
    ifft: Ote,
    imag: k9,
    image: Pre,
    inTopKAsync: kne,
    irfft: Fte,
    isFinite: w9,
    isInf: I9,
    isNaN: N9,
    leakyRelu: S9,
    less: T9,
    lessEqual: E9,
    linalg: Bre,
    linspace: C9,
    localResponseNormalization: A9,
    log: R9,
    log1p: _9,
    logSigmoid: z9,
    logSoftmax: B9,
    logSumExp: W9,
    logicalAnd: U9,
    logicalNot: V9,
    logicalOr: G9,
    logicalXor: j9,
    losses: Wre,
    lowerBound: K9,
    matMul: Q8,
    max: n9,
    maxPool: X9,
    maxPool3d: Y9,
    maxPoolWithArgmax: J9,
    maximum: Z9,
    mean: Q9,
    meshgrid: tee,
    min: r9,
    minimum: nee,
    mirrorPad: ree,
    mod: aee,
    moments: iee,
    movingAverage: pne,
    mul: g8,
    multiRNNCell: oee,
    multinomial: see,
    neg: M9,
    norm: l9,
    notEqual: uee,
    oneHot: cee,
    ones: eee,
    onesLike: lee,
    op: B5,
    outerProduct: hee,
    pad: pee,
    pad1d: fee,
    pad2d: dee,
    pad3d: vee,
    pad4d: mee,
    pool: yee,
    pow: a9,
    prelu: bee,
    print: f8,
    prod: xee,
    raggedGather: kee,
    raggedRange: wee,
    raggedTensorToTensor: Iee,
    rand: Nee,
    randomGamma: nte,
    randomNormal: rte,
    randomStandardNormal: ate,
    randomUniform: ite,
    randomUniformInt: ote,
    range: ste,
    real: ute,
    reciprocal: cte,
    relu: lte,
    relu6: hte,
    reshape: X8,
    reverse: pte,
    reverse1d: fte,
    reverse2d: dte,
    reverse3d: vte,
    reverse4d: mte,
    rfft: Mte,
    round: gte,
    rsqrt: yte,
    scalar: i9,
    scatterND: fne,
    searchSorted: q9,
    selu: bte,
    separableConv2d: xte,
    setdiff1dAsync: wte,
    sigmoid: $8,
    sign: Ite,
    signal: zre,
    sin: Nte,
    sinh: Ste,
    slice: e7,
    slice1d: Tte,
    slice2d: Ete,
    slice3d: Cte,
    slice4d: Ate,
    softmax: Rte,
    softplus: L9,
    spaceToBatchND: gee,
    sparse: Ure,
    sparseToDense: vne,
    spectral: Lre,
    split: Dte,
    sqrt: o9,
    square: s9,
    squaredDifference: Lte,
    squeeze: zte,
    stack: Pte,
    step: Bte,
    stridedSlice: Wte,
    string: Vre,
    sub: P9,
    sum: u9,
    tan: Ute,
    tanh: t7,
    tensor: V5,
    tensor1d: Vte,
    tensor2d: Gte,
    tensor3d: jte,
    tensor4d: Hte,
    tensor5d: qte,
    tensor6d: Kte,
    tensorScatterUpdate: Qte,
    tile: v9,
    topk: $te,
    transpose: hne,
    truncatedNormal: ene,
    unique: tne,
    unsortedSegmentSum: nne,
    unstack: rne,
    upperBound: ane,
    variable: ine,
    where: W7,
    whereAsync: une,
    zeros: $9,
    zerosLike: U7
  };
  function Qde(e, t, n, r = Zde) {
    switch (e.op) {
      case "BiasAdd":
      case "AddV2":
      case "Add":
        return [r.add(ude("a", e, t, n), ude("b", e, t, n))];
      case "AddN":
        return [r.addN(ude("tensors", e, t, n))];
      case "FloorMod":
      case "Mod":
        return [r.mod(ude("a", e, t, n), ude("b", e, t, n))];
      case "Mul":
        return [r.mul(ude("a", e, t, n), ude("b", e, t, n))];
      case "RealDiv":
      case "Div":
        return [r.div(ude("a", e, t, n), ude("b", e, t, n))];
      case "DivNoNan":
        return [r.divNoNan(ude("a", e, t, n), ude("b", e, t, n))];
      case "FloorDiv":
        return [r.floorDiv(ude("a", e, t, n), ude("b", e, t, n))];
      case "Sub":
        return [r.sub(ude("a", e, t, n), ude("b", e, t, n))];
      case "Minimum":
        return [r.minimum(ude("a", e, t, n), ude("b", e, t, n))];
      case "Maximum":
        return [r.maximum(ude("a", e, t, n), ude("b", e, t, n))];
      case "Pow":
        return [r.pow(ude("a", e, t, n), ude("b", e, t, n))];
      case "SquaredDifference":
        return [r.squaredDifference(ude("a", e, t, n), ude("b", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function $de(e, t, n, r = Zde) {
    switch (e.op) {
      case "Abs":
      case "ComplexAbs":
        return [r.abs(ude("x", e, t, n))];
      case "Acos":
        return [r.acos(ude("x", e, t, n))];
      case "Acosh":
        return [r.acosh(ude("x", e, t, n))];
      case "Asin":
        return [r.asin(ude("x", e, t, n))];
      case "Asinh":
        return [r.asinh(ude("x", e, t, n))];
      case "Atan":
        return [r.atan(ude("x", e, t, n))];
      case "Atan2":
        return [r.atan2(ude("x", e, t, n), ude("y", e, t, n))];
      case "Atanh":
        return [r.atanh(ude("x", e, t, n))];
      case "Ceil":
        return [r.ceil(ude("x", e, t, n))];
      case "Complex":
        return [r.complex(ude("real", e, t, n), ude("imag", e, t, n))];
      case "Cos":
        return [r.cos(ude("x", e, t, n))];
      case "Cosh":
        return [r.cosh(ude("x", e, t, n))];
      case "Elu":
        return [r.elu(ude("x", e, t, n))];
      case "Erf":
        return [r.erf(ude("x", e, t, n))];
      case "Exp":
        return [r.exp(ude("x", e, t, n))];
      case "Expm1":
        return [r.expm1(ude("x", e, t, n))];
      case "Floor":
        return [r.floor(ude("x", e, t, n))];
      case "Log":
        return [r.log(ude("x", e, t, n))];
      case "Log1p":
        return [r.log1p(ude("x", e, t, n))];
      case "Imag":
        return [r.imag(ude("x", e, t, n))];
      case "Neg":
        return [r.neg(ude("x", e, t, n))];
      case "Reciprocal":
        return [r.reciprocal(ude("x", e, t, n))];
      case "Real":
        return [r.real(ude("x", e, t, n))];
      case "Relu":
        return [r.relu(ude("x", e, t, n))];
      case "Round":
        return [r.round(ude("x", e, t, n))];
      case "Selu":
        return [r.selu(ude("x", e, t, n))];
      case "Sigmoid":
        return [r.sigmoid(ude("x", e, t, n))];
      case "Sin":
        return [r.sin(ude("x", e, t, n))];
      case "Sign":
        return [r.sign(ude("x", e, t, n))];
      case "Sinh":
        return [r.sinh(ude("x", e, t, n))];
      case "Softplus":
        return [r.softplus(ude("x", e, t, n))];
      case "Sqrt":
        return [r.sqrt(ude("x", e, t, n))];
      case "Square":
        return [r.square(ude("x", e, t, n))];
      case "Tanh":
        return [r.tanh(ude("x", e, t, n))];
      case "Tan":
        return [r.tan(ude("x", e, t, n))];
      case "ClipByValue":
        return [r.clipByValue(ude("x", e, t, n), ude("clipValueMin", e, t, n), ude("clipValueMax", e, t, n))];
      case "Relu6":
        return [r.relu6(ude("x", e, t, n))];
      case "Rsqrt":
        return [r.rsqrt(cde(e.inputNames[0], t, n))];
      case "LeakyRelu":
        return [r.leakyRelu(ude("x", e, t, n), ude("alpha", e, t, n))];
      case "Prelu":
        return [r.prelu(ude("x", e, t, n), ude("alpha", e, t, n))];
      case "IsNan":
        return [r.isNaN(cde(e.inputNames[0], t, n))];
      case "IsInf":
        return [r.isInf(cde(e.inputNames[0], t, n))];
      case "IsFinite":
        return [r.isFinite(cde(e.inputNames[0], t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function eve(e, t, n = "") {
    if (typeof e != "number" && typeof t != "number") {
      F$(e.length === t.length, function () {
        return `${n} Shapes ${e} and ${t} must match`;
      });
      for (var r = 0; r < e.length; r++) {
        var a = e[r];
        var i = t[r];
        F$(a < 0 || i < 0 || a === i, function () {
          return `${n} Shapes ${e} and ${t} must match`;
        });
      }
    }
  }
  function tve(e) {
    return typeof e != "number" && !e.some(function (e) {
      return e < 0;
    });
  }
  function nve(e, t, n) {
    var r = rve(e, n);
    var a = !tve(r);
    if (a && t.length === 0) {
      throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);
    }
    if (a) {
      t.forEach(function (e) {
        r = rve(e.shape, r);
      });
    }
    if (!tve(r)) {
      throw new Error(`Non-fully-defined elementShape: ${r}`);
    }
    return r;
  }
  function rve(e, t) {
    if (typeof e == "number") {
      return t;
    }
    if (typeof t == "number") {
      return e;
    }
    if (e.length !== t.length) {
      throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);
    }
    var n = [];
    for (var r = 0; r < e.length; ++r) {
      var a = e[r];
      var i = t[r];
      if (a >= 0 && i >= 0 && a !== i) {
        throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);
      }
      n[r] = a >= 0 ? a : i;
    }
    return n;
  }
  var ave = function () {
    function e(t, n, r, a, i, o, s) {
      l(this, e);
      this.name = t;
      this.dtype = n;
      this.maxSize = r;
      this.elementShape = a;
      this.identicalElementShapes = i;
      this.dynamicSize = o;
      this.clearAfterRead = s;
      this.tensors = [];
      this.closed_ = false;
      this.idTensor = i9(0);
      J5(this.idTensor);
    }
    p(e, [{
      key: "id",
      get: function () {
        return this.idTensor.id;
      }
    }, {
      key: "closed",
      get: function () {
        return this.closed_;
      }
    }, {
      key: "clearAndClose",
      value: function (e) {
        this.tensors.forEach(function (t) {
          if (e == null || !e.has(t.tensor.id)) {
            t.tensor.dispose();
          }
        });
        this.tensors = [];
        this.closed_ = true;
        this.idTensor.dispose();
      }
    }, {
      key: "size",
      value: function () {
        return this.tensors.length;
      }
    }, {
      key: "read",
      value: function (e) {
        if (this.closed_) {
          throw new Error(`TensorArray ${this.name} has already been closed.`);
        }
        if (e < 0 || e >= this.size()) {
          throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
        }
        var t = this.tensors[e];
        if (t.cleared) {
          throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
        }
        if (this.clearAfterRead) {
          t.cleared = true;
        }
        t.read = true;
        return t.tensor;
      }
    }, {
      key: "readMany",
      value: function (e) {
        var t = this;
        return e.map(function (e) {
          return t.read(e);
        });
      }
    }, {
      key: "write",
      value: function (e, t) {
        if (this.closed_) {
          throw new Error(`TensorArray ${this.name} has already been closed.`);
        }
        if (e < 0 || !this.dynamicSize && e >= this.maxSize) {
          throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);
        }
        var n = this.tensors[e] || {};
        if (t.dtype !== this.dtype) {
          throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);
        }
        if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
          this.elementShape = t.shape;
        }
        eve(this.elementShape, t.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e}.`);
        if (n.read) {
          throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);
        }
        if (n.written) {
          throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);
        }
        n.tensor = t;
        J5(t);
        n.written = true;
        this.tensors[e] = n;
      }
    }, {
      key: "writeMany",
      value: function (e, t) {
        var n = this;
        if (e.length !== t.length) {
          throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);
        }
        e.forEach(function (e, r) {
          return n.write(e, t[r]);
        });
      }
    }, {
      key: "gather",
      value: function (e, t) {
        if (t && t !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);
        }
        if (e) {
          e = e.slice(0, this.size());
        } else {
          e = [];
          for (var n = 0; n < this.size(); n++) {
            e.push(n);
          }
        }
        if (e.length === 0) {
          return V5([], [0].concat(this.elementShape));
        }
        var r = this.readMany(e);
        eve(this.elementShape, r[0].shape, "TensorArray shape mismatch: ");
        return Pte(r, 0);
      }
    }, {
      key: "concat",
      value: function (e) {
        if (e && e !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);
        }
        if (this.size() === 0) {
          return V5([], [0].concat(this.elementShape));
        }
        var t = [];
        for (var n = 0; n < this.size(); n++) {
          t.push(n);
        }
        var r = this.readMany(t);
        eve(this.elementShape, r[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`);
        return Z8(r, 0);
      }
    }, {
      key: "scatter",
      value: function (e, t) {
        if (t.dtype !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
        }
        if (e.length !== t.shape[0]) {
          throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);
        }
        var n = Math.max.apply(Math, T(e));
        if (!this.dynamicSize && n >= this.maxSize) {
          throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);
        }
        this.writeMany(e, rne(t, 0));
      }
    }, {
      key: "split",
      value: function (e, t) {
        var n = this;
        if (t.dtype !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
        }
        var r = 0;
        var a = e.map(function (e) {
          return r += e;
        });
        if (r !== t.shape[0]) {
          throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);
        }
        if (!this.dynamicSize && e.length !== this.maxSize) {
          throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);
        }
        var i = r === 0 ? 0 : t.size / r;
        var o = [];
        X5(function () {
          t = X8(t, [1, r, i]);
          for (var s = 0; s < e.length; ++s) {
            var u = [0, s === 0 ? 0 : a[s - 1], 0];
            var c = [1, e[s], i];
            o[s] = X8(e7(t, u, c), n.elementShape);
          }
          return o;
        });
        var s = [];
        for (var u = 0; u < e.length; u++) {
          s[u] = u;
        }
        this.writeMany(s, o);
      }
    }]);
    return e;
  }();
  var ive = function () {
    function e(t, n, r, a = -1) {
      l(this, e);
      this.tensors = t;
      this.elementShape = n;
      this.elementDtype = r;
      if (t != null) {
        t.forEach(function (e) {
          if (r !== e.dtype) {
            throw new Error(`Invalid data types; op elements ${r}, but list elements ${e.dtype}`);
          }
          eve(n, e.shape, "TensorList shape mismatch: ");
          J5(e);
        });
      }
      this.idTensor = i9(0);
      this.maxNumElements = a;
      J5(this.idTensor);
    }
    p(e, [{
      key: "id",
      get: function () {
        return this.idTensor.id;
      }
    }, {
      key: "copy",
      value: function () {
        return new e(T(this.tensors), this.elementShape, this.elementDtype);
      }
    }, {
      key: "clearAndClose",
      value: function (e) {
        this.tensors.forEach(function (t) {
          if (e == null || !e.has(t.id)) {
            t.dispose();
          }
        });
        this.tensors.length = 0;
        this.idTensor.dispose();
      }
    }, {
      key: "size",
      value: function () {
        return this.tensors.length;
      }
    }, {
      key: "stack",
      value: function (e, t) {
        var n = this;
        var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        if (t !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
        }
        if (r !== -1 && this.tensors.length !== r) {
          throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);
        }
        eve(e, this.elementShape, "TensorList shape mismatch: ");
        var a = nve(this.elementShape, this.tensors, e);
        return X5(function () {
          var e = n.tensors.map(function (e) {
            return X8(e, a);
          });
          return Pte(e, 0);
        });
      }
    }, {
      key: "popBack",
      value: function (e, t) {
        if (t !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
        }
        if (this.size() === 0) {
          throw new Error("Trying to pop from an empty list.");
        }
        var n = nve(this.elementShape, this.tensors, e);
        var r = this.tensors.pop();
        r.kept = false;
        eve(r.shape, e, "TensorList shape mismatch: ");
        return X8(r, n);
      }
    }, {
      key: "pushBack",
      value: function (e) {
        if (e.dtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);
        }
        eve(e.shape, this.elementShape, "TensorList shape mismatch: ");
        if (this.maxNumElements === this.size()) {
          throw new Error("Trying to push element into a full list.");
        }
        J5(e);
        this.tensors.push(e);
      }
    }, {
      key: "resize",
      value: function (t) {
        if (t < 0) {
          throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);
        }
        if (this.maxNumElements !== -1 && t > this.maxNumElements) {
          throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);
        }
        var n = new e([], this.elementShape, this.elementDtype, this.maxNumElements);
        n.tensors.length = t;
        for (var r = 0; r < Math.min(this.tensors.length, t); ++r) {
          n.tensors[r] = this.tensors[r];
        }
        return n;
      }
    }, {
      key: "getItem",
      value: function (e, t, n) {
        if (n !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
        }
        if (e < 0 || e > this.tensors.length) {
          throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);
        }
        if (this.tensors[e] == null) {
          throw new Error(`element at index ${e} is null.`);
        }
        eve(this.tensors[e].shape, t, "TensorList shape mismatch: ");
        var r = nve(this.elementShape, this.tensors, t);
        return X8(this.tensors[e], r);
      }
    }, {
      key: "setItem",
      value: function (e, t) {
        if (t.dtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);
        }
        if (e < 0 || this.maxNumElements !== -1 && e >= this.maxNumElements) {
          throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);
        }
        eve(this.elementShape, t.shape, "TensorList shape mismatch: ");
        J5(t);
        if (this.tensors[e] != null) {
          this.tensors[e].kept = false;
        }
        this.tensors[e] = t;
      }
    }, {
      key: "gather",
      value: function (e, t, n) {
        var r = this;
        if (t !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
        }
        eve(this.elementShape, n, "TensorList shape mismatch: ");
        e = e.slice(0, this.size());
        var a = nve(this.elementShape, this.tensors, n);
        if (e.length === 0) {
          return V5([], [0].concat(a));
        } else {
          return X5(function () {
            var t = e.map(function (e) {
              return X8(r.tensors[e], a);
            });
            return Pte(t, 0);
          });
        }
      }
    }, {
      key: "concat",
      value: function (e, t) {
        var n = this;
        if (e && e !== this.elementDtype) {
          throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);
        }
        eve(this.elementShape, t, "TensorList shape mismatch: ");
        var r = nve(this.elementShape, this.tensors, t);
        if (this.size() === 0) {
          return V5([], [0].concat(r));
        } else {
          return X5(function () {
            var e = n.tensors.map(function (e) {
              return X8(e, r);
            });
            return Z8(e, 0);
          });
        }
      }
    }]);
    return e;
  }();
  function ove(e, t, n) {
    var r = e.dtype;
    if (e.shape.length < 1) {
      throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);
    }
    if (e.dtype !== n) {
      throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);
    }
    eve(e.shape.slice(1), t, "TensorList shape mismatch: ");
    var a = rne(e);
    return new ive(a, t, r);
  }
  function sve(e, t, n, r) {
    return new ive([], e, t, r);
  }
  function uve(e, t, n, r) {
    if (t.length !== e.shape[0]) {
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);
    }
    var a = Math.max.apply(Math, T(t));
    if (r != null && r !== -1 && a >= r) {
      throw new Error(`Max index must be < array size (${a}  vs. ${r})`);
    }
    var i = new ive([], n, e.dtype, r);
    var o = rne(e, 0);
    t.forEach(function (e, t) {
      i.setItem(e, o[t]);
    });
    return i;
  }
  function cve(e, t, n) {
    var r = 0;
    var a = t.map(function (e) {
      return r += e;
    });
    if (r !== e.shape[0]) {
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);
    }
    var i = rve(e.shape.slice(1), n);
    var o = r === 0 ? 0 : e.size / r;
    for (var s = X5(function () {
        var n = [];
        e = X8(e, [1, r, o]);
        for (var s = 0; s < t.length; ++s) {
          var u = [0, s === 0 ? 0 : a[s - 1], 0];
          var c = [1, t[s], o];
          n[s] = X8(e7(e, u, c), i);
        }
        e.dispose();
        return n;
      }), u = new ive([], n, e.dtype, t.length), c = 0; c < s.length; c++) {
      u.setItem(c, s[c]);
    }
    return u;
  }
  var lve = function () {
    var e = c(o().mark(function e(t, n, r) {
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      var y;
      var b;
      var x;
      var k;
      var w;
      var I;
      var N;
      var S;
      var T;
      var E;
      var C;
      var A;
      var R;
      var _;
      var O;
      var F;
      var D;
      var M;
      var L;
      var z;
      var P;
      var B;
      var W;
      var U;
      var V;
      var G;
      var j;
      var H;
      var q;
      var K;
      var X;
      var Y;
      var J;
      var Z;
      var Q;
      var $;
      var ee;
      var te;
      var ne;
      var re;
      var ae;
      var ie;
      var oe;
      var se;
      var ue;
      var ce;
      var le;
      var he;
      var pe;
      var fe;
      var de;
      var ve;
      var me;
      var ge;
      var ye;
      var be;
      var xe;
      var ke;
      var we;
      var Ie;
      var Ne;
      var Se;
      var Te;
      var Ee;
      var Ce;
      var Ae;
      var Re;
      var _e;
      var Oe;
      var Fe;
      var De;
      var Me;
      var Le;
      var ze;
      var Pe;
      var Be;
      var We;
      var Ue;
      var Ve;
      var Ge;
      var je;
      var He;
      var qe;
      var Ke;
      var Xe;
      var Ye;
      var Je;
      var Ze;
      var Qe;
      var $e;
      var et;
      var tt;
      var nt;
      var rt;
      var at;
      var it;
      var ot;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              e.t0 = t.op;
              e.next = e.t0 === "If" || e.t0 === "StatelessIf" ? 3 : e.t0 === "While" || e.t0 === "StatelessWhile" ? 15 : e.t0 === "LoopCond" ? 33 : e.t0 === "Switch" ? 35 : e.t0 === "Merge" ? 46 : e.t0 === "Enter" ? 51 : e.t0 === "Exit" ? 55 : e.t0 === "NextIteration" ? 58 : e.t0 === "TensorArrayV3" ? 61 : e.t0 === "TensorArrayWriteV3" ? 71 : e.t0 === "TensorArrayReadV3" ? 77 : e.t0 === "TensorArrayGatherV3" ? 81 : e.t0 === "TensorArrayScatterV3" ? 86 : e.t0 === "TensorArrayConcatV3" ? 92 : e.t0 === "TensorArraySplitV3" ? 96 : e.t0 === "TensorArraySizeV3" ? 102 : e.t0 === "TensorArrayCloseV3" ? 105 : e.t0 === "TensorListSetItem" ? 109 : e.t0 === "TensorListGetItem" ? 115 : e.t0 === "TensorListScatterV2" || e.t0 === "TensorListScatter" ? 121 : e.t0 === "TensorListReserve" || e.t0 === "EmptyTensorList" ? 128 : e.t0 === "TensorListGather" ? 136 : e.t0 === "TensorListStack" ? 142 : e.t0 === "TensorListFromTensor" ? 148 : e.t0 === "TensorListConcat" || e.t0 === "TensorListConcatV2" ? 154 : e.t0 === "TensorListPushBack" ? 159 : e.t0 === "TensorListPopBack" ? 164 : e.t0 === "TensorListSplit" ? 169 : e.t0 === "TensorListLength" ? 175 : e.t0 === "TensorListResize" ? 178 : 184;
              break;
            case 3:
              a = ude("thenBranch", t, n, r);
              i = ude("elseBranch", t, n, r);
              s = ude("cond", t, n, r);
              u = ude("args", t, n, r);
              e.next = 9;
              return s.data();
            case 9:
              if (!e.sent[0]) {
                e.next = 14;
                break;
              }
              return e.abrupt("return", r.functionMap[a].executeFunctionAsync(u, r.tensorArrayMap, r.tensorListMap));
            case 14:
              return e.abrupt("return", r.functionMap[i].executeFunctionAsync(u, r.tensorArrayMap, r.tensorListMap));
            case 15:
              c = ude("body", t, n, r);
              l = ude("cond", t, n, r);
              h = ude("args", t, n, r);
              e.next = 20;
              return r.functionMap[l].executeFunctionAsync(h, r.tensorArrayMap, r.tensorListMap);
            case 20:
              p = e.sent;
              f = h.map(function (e) {
                return e.id;
              });
              e.next = 24;
              return p[0].data();
            case 24:
              d = e.sent;
              p.forEach(function (e) {
                if (!e.kept && f.indexOf(e.id) === -1) {
                  e.dispose();
                }
              });
              v = h;
              m = o().mark(function e() {
                var t;
                var n;
                var a;
                return o().wrap(function (e) {
                  while (true) {
                    switch (e.prev = e.next) {
                      case 0:
                        t = v;
                        e.next = 3;
                        return r.functionMap[c].executeFunctionAsync(v, r.tensorArrayMap, r.tensorListMap);
                      case 3:
                        v = e.sent;
                        n = v.map(function (e) {
                          return e.id;
                        });
                        t.forEach(function (e) {
                          if (!e.kept && f.indexOf(e.id) === -1 && n.indexOf(e.id) === -1) {
                            e.dispose();
                          }
                        });
                        e.next = 8;
                        return r.functionMap[l].executeFunctionAsync(v, r.tensorArrayMap, r.tensorListMap);
                      case 8:
                        a = e.sent;
                        e.next = 11;
                        return a[0].data();
                      case 11:
                        d = e.sent;
                        a.forEach(function (e) {
                          if (!e.kept && f.indexOf(e.id) === -1 && n.indexOf(e.id) === -1) {
                            e.dispose();
                          }
                        });
                      case 13:
                      case "end":
                        return e.stop();
                    }
                  }
                }, e);
              });
            case 28:
              if (!d[0]) {
                e.next = 32;
                break;
              }
              return e.delegateYield(m(), "t1", 30);
            case 30:
              e.next = 28;
              break;
            case 32:
              return e.abrupt("return", v);
            case 33:
              g = ude("pred", t, n, r);
              return e.abrupt("return", [vde(g)]);
            case 35:
              y = ude("pred", t, n, r);
              if (!(b = ude("data", t, n, r)).kept) {
                b = vde(b);
              }
              e.next = 40;
              return y.data();
            case 40:
              if (!e.sent[0]) {
                e.next = 44;
                break;
              }
              e.t2 = [undefined, b];
              e.next = 45;
              break;
            case 44:
              e.t2 = [b, undefined];
            case 45:
              return e.abrupt("return", e.t2);
            case 46:
              x = t.inputNames.find(function (e) {
                return cde(e, n, r) !== undefined;
              });
              if (!x) {
                e.next = 50;
                break;
              }
              k = cde(x, n, r);
              return e.abrupt("return", [vde(k)]);
            case 50:
              return e.abrupt("return", undefined);
            case 51:
              w = ude("frameName", t, n, r);
              I = ude("tensor", t, n, r);
              r.enterFrame(w);
              return e.abrupt("return", [vde(I)]);
            case 55:
              N = ude("tensor", t, n, r);
              r.exitFrame();
              return e.abrupt("return", [vde(N)]);
            case 58:
              S = ude("tensor", t, n, r);
              r.nextIteration();
              return e.abrupt("return", [vde(S)]);
            case 61:
              T = ude("size", t, n, r);
              E = ude("dtype", t, n, r);
              C = ude("elementShape", t, n, r);
              A = ude("dynamicSize", t, n, r);
              R = ude("clearAfterRead", t, n, r);
              _ = ude("identicalElementShapes", t, n, r);
              O = ude("name", t, n, r);
              F = new ave(O, E, T, C, _, A, R);
              r.addTensorArray(F);
              return e.abrupt("return", [F.idTensor, i9(1)]);
            case 71:
              D = ude("tensorArrayId", t, n, r);
              M = ude("index", t, n, r);
              L = ude("tensor", t, n, r);
              (z = r.getTensorArray(D.id)).write(M, L);
              return e.abrupt("return", [z.idTensor]);
            case 77:
              P = ude("tensorArrayId", t, n, r);
              B = ude("index", t, n, r);
              W = r.getTensorArray(P.id);
              return e.abrupt("return", [W.read(B)]);
            case 81:
              U = ude("tensorArrayId", t, n, r);
              V = ude("indices", t, n, r);
              G = ude("dtype", t, n, r);
              j = r.getTensorArray(U.id);
              return e.abrupt("return", [j.gather(V, G)]);
            case 86:
              H = ude("tensorArrayId", t, n, r);
              q = ude("indices", t, n, r);
              K = ude("tensor", t, n, r);
              (X = r.getTensorArray(H.id)).scatter(q, K);
              return e.abrupt("return", [X.idTensor]);
            case 92:
              Y = ude("tensorArrayId", t, n, r);
              J = r.getTensorArray(Y.id);
              Z = ude("dtype", t, n, r);
              return e.abrupt("return", [J.concat(Z)]);
            case 96:
              Q = ude("tensorArrayId", t, n, r);
              $ = ude("tensor", t, n, r);
              ee = ude("lengths", t, n, r);
              (te = r.getTensorArray(Q.id)).split(ee, $);
              return e.abrupt("return", [te.idTensor]);
            case 102:
              ne = ude("tensorArrayId", t, n, r);
              re = r.getTensorArray(ne.id);
              return e.abrupt("return", [i9(re.size(), "int32")]);
            case 105:
              ae = ude("tensorArrayId", t, n, r);
              (ie = r.getTensorArray(ae.id)).clearAndClose();
              return e.abrupt("return", [ie.idTensor]);
            case 109:
              oe = ude("tensorListId", t, n, r);
              se = ude("index", t, n, r);
              ue = ude("tensor", t, n, r);
              (ce = r.getTensorList(oe.id)).setItem(se, ue);
              return e.abrupt("return", [ce.idTensor]);
            case 115:
              le = ude("tensorListId", t, n, r);
              he = ude("index", t, n, r);
              pe = ude("elementShape", t, n, r);
              fe = ude("elementDType", t, n, r);
              de = r.getTensorList(le.id);
              return e.abrupt("return", [de.getItem(he, pe, fe)]);
            case 121:
              ve = ude("indices", t, n, r);
              me = ude("tensor", t, n, r);
              ge = ude("elementShape", t, n, r);
              ye = ude("numElements", t, n, r);
              be = uve(me, ve, ge, ye);
              r.addTensorList(be);
              return e.abrupt("return", [be.idTensor]);
            case 128:
              xe = ude("elementShape", t, n, r);
              ke = ude("elementDType", t, n, r);
              we = t.op === "TensorListReserve" ? "numElements" : "maxNumElements";
              Ie = ude(we, t, n, r);
              Ne = t.op === "TensorListReserve" ? -1 : Ie;
              Se = sve(xe, ke, 0, Ne);
              r.addTensorList(Se);
              return e.abrupt("return", [Se.idTensor]);
            case 136:
              Te = ude("tensorListId", t, n, r);
              Ee = ude("indices", t, n, r);
              Ce = ude("elementShape", t, n, r);
              Ae = ude("elementDType", t, n, r);
              Re = r.getTensorList(Te.id);
              return e.abrupt("return", [Re.gather(Ee, Ae, Ce)]);
            case 142:
              _e = ude("tensorListId", t, n, r);
              Oe = ude("elementShape", t, n, r);
              Fe = ude("elementDType", t, n, r);
              De = ude("numElements", t, n, r);
              Me = r.getTensorList(_e.id);
              return e.abrupt("return", [Me.stack(Oe, Fe, De)]);
            case 148:
              Le = ude("tensor", t, n, r);
              ze = ude("elementShape", t, n, r);
              Pe = ude("elementDType", t, n, r);
              Be = ove(Le, ze, Pe);
              r.addTensorList(Be);
              return e.abrupt("return", [Be.idTensor]);
            case 154:
              We = ude("tensorListId", t, n, r);
              Ue = r.getTensorList(We.id);
              Ve = ude("dtype", t, n, r);
              Ge = ude("elementShape", t, n, r);
              return e.abrupt("return", [Ue.concat(Ve, Ge)]);
            case 159:
              je = ude("tensorListId", t, n, r);
              He = ude("tensor", t, n, r);
              (qe = r.getTensorList(je.id)).pushBack(He);
              return e.abrupt("return", [qe.idTensor]);
            case 164:
              Ke = ude("tensorListId", t, n, r);
              Xe = ude("elementShape", t, n, r);
              Ye = ude("elementDType", t, n, r);
              Je = r.getTensorList(Ke.id);
              return e.abrupt("return", [Je.popBack(Xe, Ye)]);
            case 169:
              Ze = ude("tensor", t, n, r);
              Qe = ude("elementShape", t, n, r);
              $e = ude("lengths", t, n, r);
              et = cve(Ze, $e, Qe);
              r.addTensorList(et);
              return e.abrupt("return", [et.idTensor]);
            case 175:
              tt = ude("tensorListId", t, n, r);
              nt = r.getTensorList(tt.id);
              return e.abrupt("return", [i9(nt.size(), "int32")]);
            case 178:
              rt = ude("tensorListId", t, n, r);
              at = ude("size", t, n, r);
              it = r.getTensorList(rt.id);
              ot = it.resize(at);
              r.addTensorList(ot);
              return e.abrupt("return", [ot.idTensor]);
            case 184:
              throw TypeError(`Node type ${t.op} is not implemented`);
            case 185:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return function (t, n, r) {
      return e.apply(this, arguments);
    };
  }();
  function hve(e, t, n) {
    var r = S(ude("fusedOps", e, t, n), 2);
    var a = r[0];
    var i = r[1];
    var o = a === "biasadd";
    var s = !o;
    var u = i === "prelu";
    var c = a === "fusedbatchnorm";
    var l = ude("numArgs", e, t, n);
    if (o) {
      if (u && l !== 2) {
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
      }
      if (!u && o && l !== 1) {
        throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
      }
    }
    if (c) {
      throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
    }
    var h = ude("strides", e, t, n);
    var p = dde(e, t, n);
    var f = ude("dataFormat", e, t, n).toUpperCase();
    var d = ude("dilations", e, t, n);
    var v = S(ude("args", e, t, n), 2);
    var m = v[0];
    var g = v[1];
    if (s) {
      g = m;
      m = undefined;
    }
    return {
      stride: h,
      pad: p,
      dataFormat: f,
      dilations: d,
      biasArg: m,
      preluArg: g,
      activationFunc: i,
      leakyreluAlpha: ude("leakyreluAlpha", e, t, n)
    };
  }
  function pve(e, t, n, r = Zde) {
    switch (e.op) {
      case "Conv1D":
        var a = ude("stride", e, t, n);
        var i = ude("pad", e, t, n);
        var o = ude("dataFormat", e, t, n).toUpperCase();
        var s = ude("dilation", e, t, n);
        return [r.conv1d(ude("x", e, t, n), ude("filter", e, t, n), a, i, o, s)];
      case "Conv2D":
        var u = ude("strides", e, t, n);
        var c = dde(e, t, n);
        var l = ude("dataFormat", e, t, n).toUpperCase();
        var h = ude("dilations", e, t, n);
        return [r.conv2d(ude("x", e, t, n), ude("filter", e, t, n), [u[1], u[2]], c, l, [h[1], h[2]])];
      case "_FusedConv2D":
        var p = hve(e, t, n);
        var f = p.stride;
        var d = p.pad;
        var v = p.dataFormat;
        var m = p.dilations;
        var g = p.biasArg;
        var y = p.preluArg;
        var b = p.activationFunc;
        var x = p.leakyreluAlpha;
        return [r.fused.conv2d({
          x: ude("x", e, t, n),
          filter: ude("filter", e, t, n),
          strides: [f[1], f[2]],
          pad: d,
          dataFormat: v,
          dilations: [m[1], m[2]],
          bias: g,
          activation: b,
          preluActivationWeights: y,
          leakyreluAlpha: x
        })];
      case "FusedDepthwiseConv2dNative":
        var k = hve(e, t, n);
        var w = k.stride;
        var I = k.pad;
        var N = k.dataFormat;
        var S = k.dilations;
        var T = k.biasArg;
        var E = k.preluArg;
        var C = k.activationFunc;
        var A = k.leakyreluAlpha;
        return [r.fused.depthwiseConv2d({
          x: ude("x", e, t, n),
          filter: ude("filter", e, t, n),
          strides: [w[1], w[2]],
          pad: I,
          dataFormat: N,
          dilations: [S[1], S[2]],
          bias: T,
          activation: C,
          preluActivationWeights: E,
          leakyreluAlpha: A
        })];
      case "Conv2DBackpropInput":
      case "Conv2dTranspose":
        var R = ude("outputShape", e, t, n);
        var _ = ude("strides", e, t, n);
        var O = dde(e, t, n);
        return [r.conv2dTranspose(ude("x", e, t, n), ude("filter", e, t, n), R, [_[1], _[2]], O)];
      case "DepthwiseConv2dNative":
      case "DepthwiseConv2d":
        var F = ude("strides", e, t, n);
        var D = dde(e, t, n);
        var M = ude("dilations", e, t, n);
        var L = ude("dataFormat", e, t, n).toUpperCase();
        return [r.depthwiseConv2d(ude("input", e, t, n), ude("filter", e, t, n), [F[1], F[2]], D, L, [M[1], M[2]])];
      case "Conv3D":
        var z = ude("strides", e, t, n);
        var P = ude("pad", e, t, n);
        var B = ude("dataFormat", e, t, n).toUpperCase();
        var W = ude("dilations", e, t, n);
        return [r.conv3d(ude("x", e, t, n), ude("filter", e, t, n), [z[1], z[2], z[3]], P, B, [W[1], W[2], W[3]])];
      case "AvgPool":
        var U = ude("strides", e, t, n);
        var V = ude("pad", e, t, n);
        var G = ude("kernelSize", e, t, n);
        return [r.avgPool(ude("x", e, t, n), [G[1], G[2]], [U[1], U[2]], V)];
      case "MaxPool":
        var j = ude("strides", e, t, n);
        var H = ude("pad", e, t, n);
        var q = ude("kernelSize", e, t, n);
        return [r.maxPool(ude("x", e, t, n), [q[1], q[2]], [j[1], j[2]], H)];
      case "MaxPoolWithArgmax":
        var K = ude("strides", e, t, n);
        var X = ude("pad", e, t, n);
        var Y = ude("kernelSize", e, t, n);
        var J = ude("includeBatchInIndex", e, t, n);
        var Z = r.maxPoolWithArgmax(ude("x", e, t, n), [Y[1], Y[2]], [K[1], K[2]], X, J);
        var Q = Z.result;
        var $ = Z.indexes;
        return [Q, $];
      case "AvgPool3D":
        var ee = ude("strides", e, t, n);
        var te = ude("pad", e, t, n);
        var ne = ude("kernelSize", e, t, n);
        return [r.avgPool3d(ude("x", e, t, n), [ne[1], ne[2], ne[3]], [ee[1], ee[2], ee[3]], te)];
      case "MaxPool3D":
        var re = ude("strides", e, t, n);
        var ae = ude("pad", e, t, n);
        var ie = ude("kernelSize", e, t, n);
        return [r.maxPool3d(ude("x", e, t, n), [ie[1], ie[2], ie[3]], [re[1], re[2], re[3]], ae)];
      case "Dilation2D":
        var oe = ude("strides", e, t, n);
        var se = ude("pad", e, t, n);
        var ue = ude("dilations", e, t, n);
        var ce = oe[1];
        var le = oe[2];
        var he = ue[1];
        var pe = ue[2];
        return [r.dilation2d(ude("x", e, t, n), ude("filter", e, t, n), [ce, le], se, [he, pe], "NHWC")];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function fve(e, t, n, r = Zde) {
    switch (e.op) {
      case "Fill":
        var a = ude("shape", e, t, n);
        var i = ude("dtype", e, t, n);
        var o = ude("value", e, t, n);
        return [r.fill(a, o, i)];
      case "LinSpace":
        var s = ude("start", e, t, n);
        var u = ude("stop", e, t, n);
        var c = ude("num", e, t, n);
        return [r.linspace(s, u, c)];
      case "Multinomial":
        var l = ude("logits", e, t, n);
        var h = ude("numSamples", e, t, n);
        var p = ude("seed", e, t, n);
        return [r.multinomial(l, h, p)];
      case "OneHot":
        var f = ude("indices", e, t, n);
        var d = ude("depth", e, t, n);
        var v = ude("onValue", e, t, n);
        var m = ude("offValue", e, t, n);
        var g = ude("dtype", e, t, n);
        return [r.oneHot(f, d, v, m, g)];
      case "Ones":
        return [r.ones(ude("shape", e, t, n), ude("dtype", e, t, n))];
      case "OnesLike":
        return [r.onesLike(ude("x", e, t, n))];
      case "RandomStandardNormal":
        return [r.randomStandardNormal(ude("shape", e, t, n), ude("dtype", e, t, n), ude("seed", e, t, n))];
      case "RandomUniform":
        return [r.randomUniform(ude("shape", e, t, n), ude("minval", e, t, n), ude("maxval", e, t, n), ude("dtype", e, t, n))];
      case "RandomUniformInt":
        return [r.randomUniformInt(ude("shape", e, t, n), ude("minval", e, t, n), ude("maxval", e, t, n), ude("seed", e, t, n))];
      case "Range":
        var y = ude("start", e, t, n);
        var b = ude("stop", e, t, n);
        var x = ude("step", e, t, n);
        return [r.range(y, b, x, ude("dtype", e, t, n))];
      case "TruncatedNormal":
        var k = ude("shape", e, t, n);
        var w = ude("mean", e, t, n);
        var I = ude("stdDev", e, t, n);
        var N = ude("seed", e, t, n);
        return [r.truncatedNormal(k, w, I, ude("dtype", e, t, n), N)];
      case "Zeros":
        return [r.zeros(ude("shape", e, t, n), ude("dtype", e, t, n))];
      case "ZerosLike":
        return [r.zerosLike(ude("x", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function dve(e, t, n) {
    return {
      boxes: ude("boxes", e, t, n),
      scores: ude("scores", e, t, n),
      maxOutputSize: ude("maxOutputSize", e, t, n),
      iouThreshold: ude("iouThreshold", e, t, n),
      scoreThreshold: ude("scoreThreshold", e, t, n),
      softNmsSigma: ude("softNmsSigma", e, t, n)
    };
  }
  var vve = function () {
    var e = c(o().mark(function e(t, n, r, a) {
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      var y;
      var b;
      var x;
      var k;
      var w;
      var I;
      var N;
      var S;
      var T;
      var E;
      var C;
      var A;
      var R;
      var _ = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              i = _.length > 4 && _[4] !== undefined ? _[4] : Zde;
              e.t0 = t.op;
              e.next = e.t0 === "NonMaxSuppressionV5" ? 4 : e.t0 === "NonMaxSuppressionV4" ? 9 : e.t0 === "NonMaxSuppressionV3" || e.t0 === "NonMaxSuppressionV2" ? 15 : e.t0 === "Where" ? 20 : e.t0 === "ListDiff" ? 27 : 28;
              break;
            case 4:
              s = dve(t, n, r);
              u = s.boxes;
              c = s.scores;
              l = s.maxOutputSize;
              h = s.iouThreshold;
              p = s.scoreThreshold;
              f = s.softNmsSigma;
              e.next = 7;
              return i.image.nonMaxSuppressionWithScoreAsync(u, c, l, h, p, f);
            case 7:
              d = e.sent;
              return e.abrupt("return", [d.selectedIndices, d.selectedScores]);
            case 9:
              v = dve(t, n, r);
              m = v.boxes;
              g = v.scores;
              y = v.maxOutputSize;
              b = v.iouThreshold;
              x = v.scoreThreshold;
              k = ude("padToMaxOutputSize", t, n, r);
              e.next = 13;
              return i.image.nonMaxSuppressionPaddedAsync(m, g, y, b, x, k);
            case 13:
              w = e.sent;
              return e.abrupt("return", [w.selectedIndices, w.validOutputs]);
            case 15:
              I = dve(t, n, r);
              N = I.boxes;
              S = I.scores;
              T = I.maxOutputSize;
              E = I.iouThreshold;
              C = I.scoreThreshold;
              e.next = 18;
              return i.image.nonMaxSuppressionAsync(N, S, T, E, C);
            case 18:
              e.t1 = e.sent;
              return e.abrupt("return", [e.t1]);
            case 20:
              A = i.cast(ude("condition", t, n, r), "bool");
              e.next = 23;
              return i.whereAsync(A);
            case 23:
              e.t2 = e.sent;
              R = [e.t2];
              A.dispose();
              return e.abrupt("return", R);
            case 27:
              return e.abrupt("return", i.setdiff1dAsync(ude("x", t, n, r), ude("y", t, n, r)));
            case 28:
              throw TypeError(`Node type ${t.op} is not implemented`);
            case 29:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return function (t, n, r, a) {
      return e.apply(this, arguments);
    };
  }();
  function mve(e, t, n, r = Zde) {
    switch (e.op) {
      case "LowerBound":
        var a = ude("sortedSequence", e, t, n);
        var i = ude("values", e, t, n);
        return [r.lowerBound(a, i)];
      case "TopKV2":
        var o = ude("x", e, t, n);
        var s = ude("k", e, t, n);
        var u = ude("sorted", e, t, n);
        var c = r.topk(o, s, u);
        return [c.values, c.indices];
      case "UpperBound":
        var l = ude("sortedSequence", e, t, n);
        var h = ude("values", e, t, n);
        return [r.upperBound(l, h)];
      case "Unique":
        var p = ude("x", e, t, n);
        var f = r.unique(p);
        return [f.values, f.indices];
      case "UniqueV2":
        var d = ude("x", e, t, n);
        var v = ude("axis", e, t, n);
        var m = r.unique(d, v);
        return [m.values, m.indices];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function gve(e, t, n, r = Zde) {
    switch (e.op) {
      case "Const":
        return t[e.name];
      case "PlaceholderWithDefault":
        var a = ude("default", e, t, n);
        return [cde(e.name, t, n) || a];
      case "Placeholder":
        return [cde(e.name, t, n)];
      case "Identity":
      case "StopGradient":
      case "FakeQuantWithMinMaxVars":
        var i = ude("x", e, t, n);
        return [vde(i)];
      case "IdentityN":
        return ude("x", e, t, n).map(function (e) {
          return vde(e);
        });
      case "Snapshot":
        var o = ude("x", e, t, n);
        return [vde(o)];
      case "Shape":
        return [r.tensor1d(ude("x", e, t, n).shape, "int32")];
      case "ShapeN":
        return ude("x", e, t, n).map(function (e) {
          return r.tensor1d(e.shape);
        });
      case "Size":
        return [r.scalar(ude("x", e, t, n).size, "int32")];
      case "Rank":
        return [r.scalar(ude("x", e, t, n).rank, "int32")];
      case "NoOp":
        return [r.scalar(1)];
      case "Print":
        var s = ude("x", e, t, n);
        var u = ude("data", e, t, n);
        var c = ude("message", e, t, n);
        var l = ude("summarize", e, t, n);
        console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");
        console.log(c);
        for (var h = 0; h < u.length; h++) {
          console.log(Array.prototype.slice.call(u[h].dataSync()).slice(0, l));
        }
        return [s];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  var yve = function () {
    function e(t, n) {
      l(this, e);
      this.keyDType = t;
      this.valueDType = n;
      this.handle = i9(0);
      this.tensorMap = new Map();
      J5(this.handle);
    }
    var t;
    var n;
    p(e, [{
      key: "id",
      get: function () {
        return this.handle.id;
      }
    }, {
      key: "clearAndClose",
      value: function () {
        this.tensorMap.forEach(function (e) {
          return e.dispose();
        });
        this.tensorMap.clear();
        this.handle.dispose();
      }
    }, {
      key: "size",
      value: function () {
        return this.tensorMap.size;
      }
    }, {
      key: "tensorSize",
      value: function () {
        return i9(this.size(), "int32");
      }
    }, {
      key: "import",
      value: (n = c(o().mark(function e(t, n) {
        var r;
        var a = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.checkKeyAndValueTensor(t, n);
                e.next = 3;
                return t.data();
              case 3:
                r = e.sent;
                this.tensorMap.forEach(function (e) {
                  return e.dispose();
                });
                this.tensorMap.clear();
                return e.abrupt("return", X5(function () {
                  var e = rne(n);
                  var t = r.length;
                  var i = e.length;
                  F$(t === i, function () {
                    return `The number of elements doesn't match, keys has ${t} elements, the values has ${i} elements.`;
                  });
                  for (var o = 0; o < t; o++) {
                    var s = r[o];
                    var u = e[o];
                    J5(u);
                    a.tensorMap.set(s, u);
                  }
                  return a.handle;
                }));
              case 7:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return n.apply(this, arguments);
      })
    }, {
      key: "find",
      value: (t = c(o().mark(function e(t, n) {
        var r;
        var a = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.checkKeyAndValueTensor(t, n);
                e.next = 3;
                return t.data();
              case 3:
                r = e.sent;
                return e.abrupt("return", X5(function () {
                  var e = [];
                  for (var t = 0; t < r.length; t++) {
                    var i = r[t];
                    var o = a.findWithDefault(i, n);
                    e.push(o);
                  }
                  return Pte(e);
                }));
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, n) {
        return t.apply(this, arguments);
      })
    }, {
      key: "findWithDefault",
      value: function (e, t) {
        var n = this.tensorMap.get(e);
        return n ?? t;
      }
    }, {
      key: "checkKeyAndValueTensor",
      value: function (e, t) {
        if (e.dtype !== this.keyDType) {
          throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);
        }
        if (t.dtype !== this.valueDType) {
          throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`);
        }
      }
    }]);
    return e;
  }();
  var bve = function () {
    var e = c(o().mark(function e(t, n, r, a) {
      var i;
      var s;
      var u;
      var c;
      var l;
      var h;
      var p;
      var f;
      var d;
      var v;
      var m;
      var g;
      var y;
      var b;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              e.t0 = t.op;
              e.next = e.t0 === "HashTable" || e.t0 === "HashTableV2" ? 3 : e.t0 === "InitializeTable" || e.t0 === "InitializeTableV2" || e.t0 === "LookupTableImport" || e.t0 === "LookupTableImportV2" ? 13 : e.t0 === "LookupTableFind" || e.t0 === "LookupTableFindV2" ? 21 : e.t0 === "LookupTableSize" || e.t0 === "LookupTableSizeV2" ? 29 : 32;
              break;
            case 3:
              if ((i = a.getHashTableHandleByName(t.name)) == null) {
                e.next = 8;
                break;
              }
              return e.abrupt("return", [i]);
            case 8:
              s = ude("keyDType", t, n, r);
              u = ude("valueDType", t, n, r);
              c = new yve(s, u);
              a.addHashTable(t.name, c);
              return e.abrupt("return", [c.handle]);
            case 13:
              l = ude("tableHandle", t, n, r, a);
              h = ude("keys", t, n, r);
              p = ude("values", t, n, r);
              f = a.getHashTableById(l.id);
              e.next = 19;
              return f.import(h, p);
            case 19:
              e.t1 = e.sent;
              return e.abrupt("return", [e.t1]);
            case 21:
              d = ude("tableHandle", t, n, r, a);
              v = ude("keys", t, n, r);
              m = ude("defaultValue", t, n, r);
              g = a.getHashTableById(d.id);
              e.next = 27;
              return g.find(v, m);
            case 27:
              e.t2 = e.sent;
              return e.abrupt("return", [e.t2]);
            case 29:
              y = ude("tableHandle", t, n, r, a);
              b = a.getHashTableById(y.id);
              return e.abrupt("return", [b.tensorSize()]);
            case 32:
              throw TypeError(`Node type ${t.op} is not implemented`);
            case 33:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return function (t, n, r, a) {
      return e.apply(this, arguments);
    };
  }();
  function xve(e, t, n, r = Zde) {
    switch (e.op) {
      case "ResizeBilinear":
        var a = ude("images", e, t, n);
        var i = ude("size", e, t, n);
        var o = ude("alignCorners", e, t, n);
        var s = ude("halfPixelCenters", e, t, n);
        return [r.image.resizeBilinear(a, [i[0], i[1]], o, s)];
      case "ResizeNearestNeighbor":
        var u = ude("images", e, t, n);
        var c = ude("size", e, t, n);
        var l = ude("alignCorners", e, t, n);
        var h = ude("halfPixelCenters", e, t, n);
        return [r.image.resizeNearestNeighbor(u, [c[0], c[1]], l, h)];
      case "CropAndResize":
        var p = ude("image", e, t, n);
        var f = ude("boxes", e, t, n);
        var d = ude("boxInd", e, t, n);
        var v = ude("cropSize", e, t, n);
        var m = ude("method", e, t, n);
        var g = ude("extrapolationValue", e, t, n);
        return [r.image.cropAndResize(p, f, d, v, m, g)];
      case "ImageProjectiveTransformV3":
        var y = ude("images", e, t, n);
        var b = ude("transforms", e, t, n);
        var x = ude("outputShape", e, t, n);
        var k = ude("fillValue", e, t, n);
        var w = ude("interpolation", e, t, n);
        var I = ude("fillMode", e, t, n);
        return [r.image.transform(y, b, w.toLowerCase(), I.toLowerCase(), k, x)];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function kve(e, t, n, r = Zde) {
    switch (e.op) {
      case "Equal":
        return [r.equal(ude("a", e, t, n), ude("b", e, t, n))];
      case "NotEqual":
        return [r.notEqual(ude("a", e, t, n), ude("b", e, t, n))];
      case "Greater":
        return [r.greater(ude("a", e, t, n), ude("b", e, t, n))];
      case "GreaterEqual":
        return [r.greaterEqual(ude("a", e, t, n), ude("b", e, t, n))];
      case "Less":
        return [r.less(ude("a", e, t, n), ude("b", e, t, n))];
      case "LessEqual":
        return [r.lessEqual(ude("a", e, t, n), ude("b", e, t, n))];
      case "LogicalAnd":
        return [r.logicalAnd(ude("a", e, t, n), ude("b", e, t, n))];
      case "LogicalNot":
        return [r.logicalNot(ude("a", e, t, n))];
      case "LogicalOr":
        return [r.logicalOr(ude("a", e, t, n), ude("b", e, t, n))];
      case "Select":
      case "SelectV2":
        return [r.where(ude("condition", e, t, n), ude("a", e, t, n), ude("b", e, t, n))];
      case "BitwiseAnd":
        return [r.bitwiseAnd(ude("a", e, t, n), ude("b", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function wve(e, t, n, r = Zde) {
    switch (e.op) {
      case "BatchMatMul":
      case "BatchMatMulV2":
      case "MatMul":
        return [r.matMul(ude("a", e, t, n), ude("b", e, t, n), ude("transposeA", e, t, n), ude("transposeB", e, t, n))];
      case "Einsum":
        return [r.einsum.apply(r, [ude("equation", e, t, n)].concat(T(ude("tensors", e, t, n))))];
      case "Transpose":
        return [r.transpose(ude("x", e, t, n), ude("perm", e, t, n))];
      case "_FusedMatMul":
        var a = ude("fusedOps", e, t, n);
        var i = S(a, 2);
        var o = i[0];
        var s = i[1];
        var u = o === "biasadd";
        var c = s === "prelu";
        var l = ude("numArgs", e, t, n);
        var h = ude("leakyreluAlpha", e, t, n);
        if (u) {
          if (c && l !== 2) {
            throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          }
          if (!c && l !== 1) {
            throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
          }
        }
        var p = ude("args", e, t, n);
        var f = S(p, 2);
        var d = f[0];
        var v = f[1];
        return [r.fused.matMul({
          a: ude("a", e, t, n),
          b: ude("b", e, t, n),
          transposeA: ude("transposeA", e, t, n),
          transposeB: ude("transposeB", e, t, n),
          bias: d,
          activation: s,
          preluActivationWeights: v,
          leakyreluAlpha: h
        })];
      case "MatrixBandPart":
        return [r.linalg.bandPart(ude("a", e, t, n), ude("numLower", e, t, n), ude("numUpper", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Ive(e, t, n, r = Zde) {
    switch (e.op) {
      case "EuclideanNorm":
        return [r.euclideanNorm(ude("x", e, t, n), ude("axis", e, t, n), ude("keepDims", e, t, n))];
      case "FusedBatchNorm":
      case "FusedBatchNormV2":
      case "FusedBatchNormV3":
        return [r.batchNorm(ude("x", e, t, n), ude("mean", e, t, n), ude("variance", e, t, n), ude("offset", e, t, n), ude("scale", e, t, n), ude("epsilon", e, t, n))];
      case "LRN":
        return [r.localResponseNormalization(ude("x", e, t, n), ude("radius", e, t, n), ude("bias", e, t, n), ude("alpha", e, t, n), ude("beta", e, t, n))];
      case "Softmax":
        return [r.softmax(ude("x", e, t, n))];
      case "LogSoftmax":
        return [r.logSoftmax(ude("x", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Nve(e, t, n, r = Zde) {
    switch (e.op) {
      case "RaggedGather":
        var a = r.raggedGather(ude("paramsNestedSplits", e, t, n), ude("paramsDenseValues", e, t, n), ude("indices", e, t, n), ude("outputRaggedRank", e, t, n));
        var i = a.outputNestedSplits;
        var o = a.outputDenseValues;
        return i.concat(o);
      case "RaggedRange":
        var s = r.raggedRange(ude("starts", e, t, n), ude("limits", e, t, n), ude("splits", e, t, n));
        var u = s.rtNestedSplits;
        var c = s.rtDenseValues;
        return [u, c];
      case "RaggedTensorToTensor":
        return [r.raggedTensorToTensor(ude("shape", e, t, n), ude("values", e, t, n), ude("defaultValue", e, t, n), ude("rowPartitionTensors", e, t, n), ude("rowPartitionTypes", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Sve(e, t, n, r = Zde) {
    switch (e.op) {
      case "Max":
        var a = ude("axis", e, t, n);
        var i = ude("keepDims", e, t, n);
        return [r.max(ude("x", e, t, n), a, i)];
      case "Mean":
        var o = ude("axis", e, t, n);
        var s = ude("keepDims", e, t, n);
        return [r.mean(ude("x", e, t, n), o, s)];
      case "Min":
        var u = ude("axis", e, t, n);
        var c = ude("keepDims", e, t, n);
        return [r.min(ude("x", e, t, n), u, c)];
      case "Sum":
        var l = ude("axis", e, t, n);
        var h = ude("keepDims", e, t, n);
        return [r.sum(ude("x", e, t, n), l, h)];
      case "All":
        var p = ude("axis", e, t, n);
        var f = ude("keepDims", e, t, n);
        return [r.all(ude("x", e, t, n), p, f)];
      case "Any":
        var d = ude("axis", e, t, n);
        var v = ude("keepDims", e, t, n);
        return [r.any(ude("x", e, t, n), d, v)];
      case "ArgMax":
        var m = ude("axis", e, t, n);
        return [r.argMax(ude("x", e, t, n), m)];
      case "ArgMin":
        var g = ude("axis", e, t, n);
        return [r.argMin(ude("x", e, t, n), g)];
      case "Prod":
        var y = ude("axis", e, t, n);
        var b = ude("keepDims", e, t, n);
        return [r.prod(ude("x", e, t, n), y, b)];
      case "Cumprod":
        var x = ude("axis", e, t, n);
        var k = ude("exclusive", e, t, n);
        var w = ude("reverse", e, t, n);
        return [r.cumprod(ude("x", e, t, n), x, k, w)];
      case "Cumsum":
        var I = ude("axis", e, t, n);
        var N = ude("exclusive", e, t, n);
        var S = ude("reverse", e, t, n);
        return [r.cumsum(ude("x", e, t, n), I, N, S)];
      case "Bincount":
        var T = ude("x", e, t, n);
        var E = ude("weights", e, t, n);
        var C = ude("size", e, t, n);
        return [r.bincount(T, E, C)];
      case "DenseBincount":
        var A = ude("x", e, t, n);
        var R = ude("weights", e, t, n);
        var _ = ude("size", e, t, n);
        var O = ude("binaryOutput", e, t, n);
        return [r.denseBincount(A, R, _, O)];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Tve(e, t, n, r = Zde) {
    switch (e.op) {
      case "ConcatV2":
      case "Concat":
        var a = ude("n", e, t, n);
        var i = ude("axis", e, t, n);
        var o = ude("tensors", e, t, n);
        o = o.slice(0, a);
        return [r.concat(o, i)];
      case "Gather":
        var s = ude("x", e, t, n);
        var u = ude("indices", e, t, n);
        return [r.gather(s, r.cast(u, "int32"), 0)];
      case "GatherV2":
        var c = ude("axis", e, t, n);
        var l = ude("batchDims", e, t, n);
        var h = ude("x", e, t, n);
        var p = ude("indices", e, t, n);
        return [r.gather(h, r.cast(p, "int32"), c, l)];
      case "Reverse":
        for (var f = ude("dims", e, t, n), d = [], v = 0; v < f.length; v++) {
          if (f[v]) {
            d.push(v);
          }
        }
        var m = ude("x", e, t, n);
        return [r.reverse(m, d)];
      case "ReverseV2":
        var g = ude("axis", e, t, n);
        var y = ude("x", e, t, n);
        return [r.reverse(y, g)];
      case "Slice":
        var b = ude("begin", e, t, n);
        var x = ude("size", e, t, n);
        return [r.slice(ude("x", e, t, n), b, x)];
      case "StridedSlice":
        var k = ude("begin", e, t, n);
        var w = ude("end", e, t, n);
        var I = ude("strides", e, t, n);
        var N = ude("beginMask", e, t, n);
        var S = ude("endMask", e, t, n);
        var T = ude("ellipsisMask", e, t, n);
        var E = ude("newAxisMask", e, t, n);
        var C = ude("shrinkAxisMask", e, t, n);
        var A = ude("x", e, t, n);
        return [r.stridedSlice(A, k, w, I, N, S, T, E, C)];
      case "Pack":
        return X5(function () {
          var a = ude("axis", e, t, n);
          var i = ude("tensors", e, t, n);
          var o = i[0].shape;
          var s = r.squeeze(i[0]).shape;
          var u = i.map(function (e) {
            var t = P$(e.shape, o);
            if (!t && !P$(r.squeeze(e).shape, s)) {
              throw new Error("the input tensors shape does not match");
            }
            if (t) {
              return e;
            } else {
              return r.reshape(e, o);
            }
          });
          return [r.stack(u, a)];
        });
      case "Unpack":
        var R = ude("axis", e, t, n);
        var _ = ude("tensor", e, t, n);
        return r.unstack(_, R);
      case "Tile":
        var O = ude("reps", e, t, n);
        return [r.tile(ude("x", e, t, n), O)];
      case "Split":
      case "SplitV":
        var F = ude("axis", e, t, n);
        var D = ude("numOrSizeSplits", e, t, n);
        var M = ude("x", e, t, n);
        return r.split(M, D, F);
      case "ScatterNd":
        var L = ude("indices", e, t, n);
        var z = ude("values", e, t, n);
        var P = ude("shape", e, t, n);
        return [r.scatterND(L, z, P)];
      case "GatherNd":
        var B = ude("x", e, t, n);
        var W = ude("indices", e, t, n);
        return [r.gatherND(B, W)];
      case "SparseToDense":
        var U = ude("sparseIndices", e, t, n);
        var V = ude("outputShape", e, t, n);
        var G = ude("sparseValues", e, t, n);
        var j = ude("defaultValue", e, t, n);
        return [r.sparseToDense(U, G, V, G.dtype === j.dtype ? j : r.cast(j, G.dtype))];
      case "TensorScatterUpdate":
        var H = ude("indices", e, t, n);
        var q = ude("values", e, t, n);
        var K = ude("tensor", e, t, n);
        return [r.tensorScatterUpdate(K, H, q)];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Eve(e, t, n, r = Zde) {
    switch (e.op) {
      case "SparseFillEmptyRows":
        var a = r.sparse.sparseFillEmptyRows(ude("indices", e, t, n), ude("values", e, t, n), ude("denseShape", e, t, n), ude("defaultValue", e, t, n));
        var i = a.outputIndices;
        var o = a.outputValues;
        var s = a.emptyRowIndicator;
        var u = a.reverseIndexMap;
        return [i, o, s, u];
      case "SparseReshape":
        var c = r.sparse.sparseReshape(ude("inputIndices", e, t, n), ude("inputShape", e, t, n), ude("newShape", e, t, n));
        var l = c.outputIndices;
        var h = c.outputShape;
        return [l, h];
      case "SparseSegmentMean":
        var p = r.sparse.sparseSegmentMean(ude("data", e, t, n), ude("indices", e, t, n), ude("segmentIds", e, t, n));
        return [p];
      case "SparseSegmentSum":
        var f = r.sparse.sparseSegmentSum(ude("data", e, t, n), ude("indices", e, t, n), ude("segmentIds", e, t, n));
        return [f];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Cve(e, t, n, r = Zde) {
    switch (e.op) {
      case "FFT":
        return [r.fft(ude("x", e, t, n))];
      case "IFFT":
        return [r.ifft(ude("x", e, t, n))];
      case "RFFT":
        return [r.rfft(ude("x", e, t, n))];
      case "IRFFT":
        return [r.irfft(ude("x", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Ave(e, t, n, r = Zde) {
    switch (e.op) {
      case "StaticRegexReplace":
        return [r.string.staticRegexReplace(ude("input", e, t, n), ude("pattern", e, t, n), ude("rewrite", e, t, n), ude("replaceGlobal", e, t, n))];
      case "StringNGrams":
        var a = r.string.stringNGrams(ude("data", e, t, n), ude("dataSplits", e, t, n), ude("separator", e, t, n), ude("nGramWidths", e, t, n), ude("leftPad", e, t, n), ude("rightPad", e, t, n), ude("padWidth", e, t, n), ude("preserveShortSequences", e, t, n));
        var i = a.nGrams;
        var o = a.nGramsSplits;
        return [i, o];
      case "StringSplit":
        var s = r.string.stringSplit(ude("input", e, t, n), ude("delimiter", e, t, n), ude("skipEmpty", e, t, n));
        var u = s.indices;
        var c = s.values;
        var l = s.shape;
        return [u, c, l];
      case "StringToHashBucketFast":
        var h = r.string.stringToHashBucketFast(ude("input", e, t, n), ude("numBuckets", e, t, n));
        return [h];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function Rve(e, t, n, r = Zde) {
    switch (e.op) {
      case "Cast":
        return [r.cast(ude("x", e, t, n), ude("dtype", e, t, n))];
      case "ExpandDims":
        var a = ude("axis", e, t, n);
        return [r.expandDims(ude("x", e, t, n), a)];
      case "Squeeze":
        var i = ude("axis", e, t, n);
        return [r.squeeze(ude("x", e, t, n), i)];
      case "Reshape":
        return [r.reshape(ude("x", e, t, n), ude("shape", e, t, n))];
      case "EnsureShape":
        return [r.ensureShape(ude("x", e, t, n), ude("shape", e, t, n))];
      case "MirrorPad":
        return [r.mirrorPad(ude("x", e, t, n), ude("padding", e, t, n), ude("mode", e, t, n))];
      case "PadV2":
      case "Pad":
        return [r.pad(ude("x", e, t, n), ude("padding", e, t, n), ude("constantValue", e, t, n))];
      case "SpaceToBatchND":
        var o = ude("blockShape", e, t, n);
        var s = ude("paddings", e, t, n);
        return [r.spaceToBatchND(ude("x", e, t, n), o, s)];
      case "BatchToSpaceND":
        var u = ude("blockShape", e, t, n);
        var c = ude("crops", e, t, n);
        return [r.batchToSpaceND(ude("x", e, t, n), u, c)];
      case "DepthToSpace":
        var l = ude("blockSize", e, t, n);
        var h = ude("dataFormat", e, t, n).toUpperCase();
        return [r.depthToSpace(ude("x", e, t, n), l, h)];
      case "BroadcastTo":
        return [r.broadcastTo(ude("x", e, t, n), ude("shape", e, t, n))];
      case "BroadcastArgs":
        return [r.broadcastArgs(ude("s0", e, t, n), ude("s1", e, t, n))];
      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
  }
  function _ve(e, t, n, r, a = X5) {
    var i = function (e, t, n) {
      switch (e.category) {
        case "arithmetic":
          return a(function () {
            return Qde(e, t, n);
          });
        case "basic_math":
          return a(function () {
            return $de(e, t, n);
          });
        case "control":
          return lve(e, t, n);
        case "convolution":
          return a(function () {
            return pve(e, t, n);
          });
        case "creation":
          return a(function () {
            return fve(e, t, n);
          });
        case "dynamic":
          return vve(e, t, n);
        case "evaluation":
          return a(function () {
            return mve(e, t, n);
          });
        case "image":
          return a(function () {
            return xve(e, t, n);
          });
        case "graph":
          return a(function () {
            return gve(e, t, n);
          });
        case "logical":
          return a(function () {
            return kve(e, t, n);
          });
        case "matrices":
          return a(function () {
            return wve(e, t, n);
          });
        case "normalization":
          return a(function () {
            return Ive(e, t, n);
          });
        case "ragged":
          return a(function () {
            return Nve(e, t, n);
          });
        case "reduction":
          return a(function () {
            return Sve(e, t, n);
          });
        case "slice_join":
          return a(function () {
            return Tve(e, t, n);
          });
        case "sparse":
          return a(function () {
            return Eve(e, t, n);
          });
        case "spectral":
          return a(function () {
            return Cve(e, t, n);
          });
        case "string":
          return a(function () {
            return Ave(e, t, n);
          });
        case "transformation":
          return a(function () {
            return Rve(e, t, n);
          });
        case "hash_table":
          return bve(e, t, n, r);
        case "custom":
          var i = sde(e.op);
          if (i && i.customExecutor) {
            return i.customExecutor(new Jde(e, t, n));
          }
          throw TypeError(`Custom op ${e.op} is not registered.`);
        default:
          throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
      }
    }(e, t, n);
    if (v0(i)) {
      return i.then(function (e) {
        return [].concat(e);
      });
    } else {
      return [].concat(i);
    }
  }
  var Ove = function () {
    function e(t = {}, n = {}, r = {}, a = {}, i) {
      l(this, e);
      this.weightMap = t;
      this.tensorArrayMap = n;
      this.tensorListMap = r;
      this.functionMap = a;
      this.parseNodeNameCache = i;
      this.rootContext = {
        id: 0,
        frameName: "",
        iterationId: 0
      };
      this.contexts = [this.rootContext];
      this.lastId = 0;
      this.generateCurrentContextIds();
    }
    p(e, [{
      key: "newFrame",
      value: function (e, t) {
        return {
          id: e,
          frameName: t,
          iterationId: 0
        };
      }
    }, {
      key: "currentContext",
      get: function () {
        return this.contexts;
      },
      set: function (e) {
        if (this.contexts !== e) {
          this.contexts = e;
          this.generateCurrentContextIds();
        }
      }
    }, {
      key: "currentContextId",
      get: function () {
        return this._currentContextIds[0];
      }
    }, {
      key: "currentContextIds",
      get: function () {
        return this._currentContextIds;
      }
    }, {
      key: "generateCurrentContextIds",
      value: function () {
        var e = [];
        for (var t = 0; t < this.contexts.length - 1; t++) {
          var n = this.contexts.slice(0, this.contexts.length - t);
          e.push(this.contextIdforContexts(n));
        }
        e.push("");
        this._currentContextIds = e;
      }
    }, {
      key: "contextIdforContexts",
      value: function (e) {
        if (e) {
          return e.map(function (e) {
            if (e.id === 0 && e.iterationId === 0) {
              return "";
            } else {
              return `${e.frameName}-${e.iterationId}`;
            }
          }).join("/");
        } else {
          return "";
        }
      }
    }, {
      key: "enterFrame",
      value: function (e) {
        if (this.contexts) {
          this.lastId++;
          this.contexts = this.contexts.slice();
          this.contexts.push(this.newFrame(this.lastId, e));
          this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
        }
      }
    }, {
      key: "exitFrame",
      value: function () {
        if (!this.contexts || !(this.contexts.length > 1)) {
          throw new Error("Cannot exit frame, the context is empty");
        }
        this.contexts = this.contexts.slice();
        this.contexts.splice(-1);
        this.currentContextIds.shift();
      }
    }, {
      key: "nextIteration",
      value: function () {
        if (!this.contexts || !(this.contexts.length > 0)) {
          throw new Error("Cannot increase frame iteration, the context is empty");
        }
        this.contexts = this.contexts.slice();
        this.lastId++;
        var e = Object.assign({}, this.contexts[this.contexts.length - 1]);
        e.iterationId += 1;
        e.id = this.lastId;
        this.contexts.splice(-1, 1, e);
        this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
      }
    }, {
      key: "getWeight",
      value: function (e) {
        return this.weightMap[e];
      }
    }, {
      key: "addTensorArray",
      value: function (e) {
        this.tensorArrayMap[e.id] = e;
      }
    }, {
      key: "getTensorArray",
      value: function (e) {
        return this.tensorArrayMap[e];
      }
    }, {
      key: "addTensorList",
      value: function (e) {
        this.tensorListMap[e.id] = e;
      }
    }, {
      key: "getTensorList",
      value: function (e) {
        return this.tensorListMap[e];
      }
    }, {
      key: "dispose",
      value: function (e) {
        for (var t in this.tensorArrayMap) {
          this.tensorArrayMap[t].clearAndClose(e);
        }
        for (var n in this.tensorListMap) {
          this.tensorListMap[n].clearAndClose(e);
        }
      }
    }]);
    return e;
  }();
  function Fve(e, t, n, r) {
    var a = new Set();
    var i = [];
    var o = null;
    var s = null;
    var u = new Set();
    var c = new Set(Object.keys(e).map(function (e) {
      return fde(e)[0];
    }));
    r = r || [];
    var l = new Set(r.map(function (e) {
      return fde(e.name)[0];
    }));
    for (var h = T(t); h.length > 0;) {
      var p = h.pop();
      if ((Bve(p) || Wve(p) || Uve(p)) && o == null) {
        s = (o = p).children.map(function (e) {
          return e.name;
        }).filter(function (e) {
          return a.has(e);
        });
      }
      a.add(p.name);
      if (n[p.name] == null) {
        if (!c.has(p.name) && !l.has(p.name)) {
          if (p.inputs.length !== 0) {
            p.inputs.forEach(function (e) {
              if (!u.has(e.name)) {
                u.add(e.name);
                h.push(e);
              }
            });
          } else {
            i.push(p.name);
          }
        }
      }
    }
    return {
      inputs: e,
      outputs: t,
      usedNodes: a,
      missingInputs: i,
      dynamicNode: o,
      syncInputs: s
    };
  }
  function Dve(e, t) {
    var n = t.usedNodes;
    var r = t.inputs;
    var a = Object.keys(r).map(function (e) {
      return fde(e)[0];
    }).map(function (t) {
      return e.nodes[t];
    });
    var i = e.initNodes || [];
    function o(e) {
      return n.has(typeof e == "string" ? e : e.name);
    }
    function s(e) {
      return T(new Map(e.map(function (e) {
        return [e.name, e];
      })).values());
    }
    var u;
    var c = s([].concat(T(a), T(e.weights), T(i))).filter(o);
    var l = s([].concat(T(c), T(Object.values(e.nodes)))).filter(o);
    var h = new Map(l.map(function (e) {
      return [e.name, e];
    }));
    var p = {};
    var f = O(l);
    try {
      for (f.s(); !(u = f.n()).done;) {
        var d = u.value;
        p[d.name] = p[d.name] || 0;
        var v;
        var m = O(d.children);
        try {
          for (m.s(); !(v = m.n()).done;) {
            var g = v.value;
            if (!o(g)) {
              p[g.name] = Number.POSITIVE_INFINITY;
            }
            p[g.name] = (p[g.name] || 0) + 1;
          }
        } catch (e) {
          m.e(e);
        } finally {
          m.f();
        }
      }
    } catch (e) {
      f.e(e);
    } finally {
      f.f();
    }
    for (var y = Object.entries(p).filter(function (e) {
        return S(e, 2)[1] === 0;
      }).map(function (e) {
        return S(e, 1)[0];
      }), b = T(y); y.length > 0;) {
      var x;
      var k = y.pop();
      var w = O(h.get(k).children.filter(o));
      try {
        for (w.s(); !(x = w.n()).done;) {
          var I = x.value;
          if (--p[I.name] == 0) {
            b.push(I.name);
            y.push(I.name);
          }
        }
      } catch (e) {
        w.e(e);
      } finally {
        w.f();
      }
    }
    var N = function (e, t) {
      var n = new Map(e.map(function (e) {
        return [e.name, e];
      }));
      var r = t.map(function (e) {
        return e.name;
      });
      var a = new Set(r);
      while (r.length > 0) {
        var i;
        var o = r.pop();
        var s = O(n.get(o).children);
        try {
          for (s.s(); !(i = s.n()).done;) {
            var u = i.value;
            if (n.has(u.name) && !a.has(u.name)) {
              a.add(u.name);
              r.push(u.name);
            }
          }
        } catch (e) {
          s.e(e);
        } finally {
          s.f();
        }
      }
      var c = e.filter(function (e) {
        return a.has(e.name);
      });
      return c;
    }(b.map(function (e) {
      return h.get(e);
    }), c);
    (function (e, t) {
      var n;
      var r = new Map(e.map(function (e, t) {
        return [e.name, t];
      }));
      var a = new Set(t.map(function (e) {
        return e.name;
      }));
      function i(e) {
        return a.has(typeof e == "string" ? e : e.name);
      }
      var o = new Set(e.map(function (e) {
        return e.name;
      }));
      function s(e) {
        return o.has(typeof e == "string" ? e : e.name);
      }
      var u = O(e);
      try {
        for (u.s(); !(n = u.n()).done;) {
          var c;
          var l = n.value;
          var h = O(l.children.filter(s));
          try {
            for (h.s(); !(c = h.n()).done;) {
              var p = c.value;
              if (!r.has(p.name)) {
                throw new Mve(`Child ${p.name} of node ${l.name} is unreachable.`);
              }
              if (r.get(l.name) > r.get(p.name)) {
                throw new Mve(`Node ${l.name} is scheduled to run after its child ${p.name}.`);
              }
            }
          } catch (e) {
            h.e(e);
          } finally {
            h.f();
          }
          if (!i(l)) {
            var f;
            var d = O(l.inputs);
            try {
              for (d.s(); !(f = d.n()).done;) {
                var v = f.value;
                if (!r.has(v.name)) {
                  throw new Mve(`Input ${v.name} of node ${l.name} is unreachable.`);
                }
                if (r.get(v.name) > r.get(l.name)) {
                  throw new Mve(`Node ${l.name} is scheduled to run before its input ${v.name}.`);
                }
              }
            } catch (e) {
              d.e(e);
            } finally {
              d.f();
            }
          }
        }
      } catch (e) {
        u.e(e);
      } finally {
        u.f();
      }
    })(N, c);
    return N;
  }
  var Mve = function (e) {
    d(n, e);
    var t = w(n);
    function n(e) {
      l(this, n);
      return t.call(this, `NodesExecutionOrderError: ${e}`);
    }
    return p(n);
  }(b(Error));
  var Lve = new Set(["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"]);
  var zve = new Set(["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"]);
  var Pve = new Set(["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"]);
  function Bve(e) {
    return Lve.has(e.op);
  }
  function Wve(e) {
    return zve.has(e.op);
  }
  function Uve(e) {
    return Pve.has(e.op);
  }
  var Vve = function () {
    function e(t, n) {
      var r = this;
      l(this, e);
      this.graph = t;
      this.parent = n;
      this.compiledMap = new Map();
      this.parseNodeNameCache = new Map();
      this._weightMap = {};
      this.SEPARATOR = ",";
      this._functions = {};
      this._functionExecutorMap = {};
      this.keepIntermediateTensors = false;
      this._outputs = t.outputs;
      this._inputs = t.inputs;
      this._initNodes = t.initNodes;
      this._signature = t.signature;
      this._functions = t.functions;
      if (t.functions != null) {
        Object.keys(t.functions).forEach(function (n) {
          r._functionExecutorMap[n] = new e(t.functions[n], r);
        });
      }
    }
    var t;
    var n;
    var r;
    var a;
    p(e, [{
      key: "weightIds",
      get: function () {
        if (this.parent) {
          return this.parent.weightIds;
        } else {
          return this._weightIds;
        }
      }
    }, {
      key: "functionExecutorMap",
      get: function () {
        if (this.parent) {
          return this.parent.functionExecutorMap;
        } else {
          return this._functionExecutorMap;
        }
      }
    }, {
      key: "weightMap",
      get: function () {
        if (this.parent) {
          return this.parent.weightMap;
        } else {
          return this._weightMap;
        }
      },
      set: function (e) {
        var t;
        var n = Object.keys(e).map(function (t) {
          return e[t].map(function (e) {
            return e.id;
          });
        });
        this._weightIds = (t = []).concat.apply(t, T(n));
        this._weightMap = e;
      }
    }, {
      key: "resourceManager",
      set: function (e) {
        this._resourceManager = e;
      }
    }, {
      key: "inputs",
      get: function () {
        return this._inputs.map(function (e) {
          return {
            name: e.name,
            shape: e.attrParams.shape ? e.attrParams.shape.value : undefined,
            dtype: e.attrParams.dtype ? e.attrParams.dtype.value : undefined
          };
        });
      }
    }, {
      key: "outputs",
      get: function () {
        return this._outputs.map(function (e) {
          return {
            name: e.name,
            shape: e.attrParams.shape ? e.attrParams.shape.value : undefined,
            dtype: e.attrParams.dtype ? e.attrParams.dtype.value : undefined
          };
        });
      }
    }, {
      key: "inputNodes",
      get: function () {
        return this._inputs.map(function (e) {
          return e.signatureKey || e.name;
        });
      }
    }, {
      key: "outputNodes",
      get: function () {
        return this._outputs.map(function (e) {
          var t = e.signatureKey || e.name;
          if (e.defaultOutput) {
            return `${t}:${e.defaultOutput}`;
          } else {
            return t;
          }
        });
      }
    }, {
      key: "functions",
      get: function () {
        var e = this;
        return Object.keys(this._functions).reduce(function (t, n) {
          t[n] = e._functions[n].signature;
          return t;
        }, {});
      }
    }, {
      key: "getCompilationKey",
      value: function (e, t) {
        var n = e.map(function (e) {
          return e.name;
        }).sort();
        var r = t.map(function (e) {
          return e.name;
        }).sort();
        return n.join(this.SEPARATOR) + "--" + r.join(this.SEPARATOR);
      }
    }, {
      key: "compile",
      value: function (e, t) {
        var n = Fve(e, t, this.weightMap, this._initNodes);
        var r = n.missingInputs;
        var a = n.dynamicNode;
        var i = n.syncInputs;
        if (a != null) {
          throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);
        }
        if (r.length > 0) {
          var o = t.map(function (e) {
            return e.name;
          });
          var s = Object.keys(e);
          throw new Error(`Cannot compute the outputs [${o}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`);
        }
        var u = Dve(this.graph, n);
        var c = function (e) {
          var t = new Map(e.map(function (e, t) {
            return [e.name, t];
          }));
          var n = Number.MAX_SAFE_INTEGER;
          var r = e.map(function (e, t) {
            if (Bve(e)) {
              return n;
            } else {
              return t;
            }
          });
          var a = function (e) {
            var n = r[t.get(e.name)];
            if (n == null) {
              return -1;
            } else {
              return n;
            }
          };
          var i = e.map(function (e, t) {
            return e.children.map(a).reduce(function (e, t) {
              return Math.max(e, t);
            }, r[t]);
          });
          var o = new Map();
          for (var s = 0; s < e.length; ++s) {
            var u = i[s];
            if (u !== n) {
              var c = e[s];
              var l = e[u];
              if (!o.has(l.name)) {
                o.set(l.name, []);
              }
              o.get(l.name).push(c);
            }
          }
          return o;
        }(u);
        return {
          orderedNodes: u,
          nodeLiveUntilMap: c
        };
      }
    }, {
      key: "cloneAndKeepTensor",
      value: function (e) {
        if (e == null) {
          return null;
        }
        var t = e.clone();
        J5(t);
        return t;
      }
    }, {
      key: "cloneTensorList",
      value: function (e) {
        var t = this;
        if (!e) {
          return null;
        }
        var n = e.map(function (e) {
          return t.cloneAndKeepTensor(e);
        });
        return n;
      }
    }, {
      key: "cloneTensorMap",
      value: function (e) {
        var t = this;
        return Object.fromEntries(Object.entries(e).map(function (e) {
          var n = S(e, 2);
          var r = n[0];
          var a = n[1];
          return [r, t.cloneTensorList(a)];
        }));
      }
    }, {
      key: "execute",
      value: function (e, t) {
        var n = this;
        this.disposeIntermediateTensors();
        e = this.mapInputs(e);
        var r = Object.keys(e).sort();
        this.checkInputs(e);
        this.checkInputShapeAndType(e);
        t = this.mapOutputs(t);
        this.checkOutputs(t);
        var a = r.map(function (e) {
          return n.graph.nodes[fde(e)[0]];
        });
        var i = t.map(function (e) {
          return fde(e)[0];
        });
        var o = new Set(i);
        var s = i.map(function (e) {
          return n.graph.nodes[e];
        });
        if (s.length === 0) {
          s = this._outputs;
        }
        var u = this.getCompilationKey(a, s);
        var c = this.compiledMap.get(u);
        if (c == null) {
          c = this.compile(e, s);
          this.compiledMap.set(u, c);
        }
        try {
          this.keepIntermediateTensors = k0().getBool("KEEP_INTERMEDIATE_TENSORS");
        } catch (e) {
          this.keepIntermediateTensors = false;
          console.warn(e.message);
        }
        var l = {};
        var h = {};
        return X5(function () {
          var r = new Ove(n.weightMap, l, h, n.functionExecutorMap, n.parseNodeNameCache);
          var a = Object.assign({}, n.weightMap);
          if (n.keepIntermediateTensors) {
            n.clonedTensorsMap = n.cloneTensorMap(n.weightMap);
          }
          Object.keys(e).forEach(function (t) {
            var i = S(fde(t, r), 2);
            var o = i[0];
            var s = [];
            s[i[1]] = e[t];
            a[o] = s;
            if (n.keepIntermediateTensors) {
              n.clonedTensorsMap[o] = n.cloneTensorList(s);
            }
          });
          var i;
          var s = n.getFrozenTensorIds(a);
          var u = c;
          var p = u.orderedNodes;
          var f = u.nodeLiveUntilMap;
          var d = O(p);
          try {
            for (d.s(); !(i = d.n()).done;) {
              var v = i.value;
              if (!a[v.name]) {
                var m = _ve(v, a, r, n._resourceManager);
                if (v0(m)) {
                  throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);
                }
                a[v.name] = m;
                if (n.keepIntermediateTensors) {
                  n.clonedTensorsMap[v.name] = n.cloneTensorList(m);
                }
                n.checkTensorForDisposalWithNodeLiveUntilInfo(v, a, r, s, o, f.get(v.name));
              }
            }
          } catch (e) {
            d.e(e);
          } finally {
            d.f();
          }
          if (n.parent == null) {
            r.dispose(s);
          }
          return t.map(function (e) {
            return cde(e, a, r);
          });
        });
      }
    }, {
      key: "getFrozenTensorIds",
      value: function (e) {
        var t = [].concat.apply([], Object.keys(e).map(function (t) {
          return e[t];
        }).map(function (e) {
          return e.map(function (e) {
            return e.id;
          });
        }));
        return new Set(t);
      }
    }, {
      key: "checkTensorForDisposal",
      value: function (e, t, n, r, a, i, o) {
        if (!Bve(t) && !i.has(e)) {
          var s;
          var u = O(n[e]);
          try {
            for (u.s(); !(s = u.n()).done;) {
              var c = s.value;
              if (c != null) {
                o[c.id] = (o[c.id] || 0) + t.children.length;
              }
            }
          } catch (e) {
            u.e(e);
          } finally {
            u.f();
          }
          var l;
          var h = O(t.inputs);
          try {
            for (h.s(); !(l = h.n()).done;) {
              var p = l.value;
              if (!Bve(p)) {
                var f = lde(p.name, n, r);
                if (f != null) {
                  var d;
                  var v = O(f);
                  try {
                    for (v.s(); !(d = v.n()).done;) {
                      var m = d.value;
                      if (m && !m.kept && !a.has(m.id)) {
                        var g = o[m.id];
                        if (g === 1) {
                          m.dispose();
                          delete o[m.id];
                        } else if (g != null) {
                          o[m.id]--;
                        }
                      }
                    }
                  } catch (e) {
                    v.e(e);
                  } finally {
                    v.f();
                  }
                }
              }
            }
          } catch (e) {
            h.e(e);
          } finally {
            h.f();
          }
        }
      }
    }, {
      key: "checkTensorForDisposalWithNodeLiveUntilInfo",
      value: function (e, t, n, r, a, i) {
        function o(e) {
          return Bve(e) || a.has(e.name);
        }
        if (!Bve(e) && i != null) {
          var s;
          var u = O(i);
          try {
            for (u.s(); !(s = u.n()).done;) {
              var c = s.value;
              if (!o(c)) {
                var l;
                var h = O(lde(c.name, t, n));
                try {
                  for (h.s(); !(l = h.n()).done;) {
                    var p = l.value;
                    if (!!p && !p.kept && !r.has(p.id)) {
                      p.dispose();
                    }
                  }
                } catch (e) {
                  h.e(e);
                } finally {
                  h.f();
                }
              }
            }
          } catch (e) {
            u.e(e);
          } finally {
            u.f();
          }
        }
      }
    }, {
      key: "executeAsync",
      value: (a = c(o().mark(function e(t, n) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this._executeAsync(t, n));
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return a.apply(this, arguments);
      })
    }, {
      key: "disposeIntermediateTensors",
      value: function () {
        if (this.clonedTensorsMap) {
          Object.values(this.clonedTensorsMap).forEach(function (e) {
            var t;
            var n = O(e);
            try {
              for (n.s(); !(t = n.n()).done;) {
                var r = t.value;
                if (r && !r.isDisposed) {
                  r.dispose();
                }
              }
            } catch (e) {
              n.e(e);
            } finally {
              n.f();
            }
          });
          this.clonedTensorsMap = null;
        }
      }
    }, {
      key: "getIntermediateTensors",
      value: function () {
        return this.clonedTensorsMap;
      }
    }, {
      key: "_executeAsync",
      value: (r = c(o().mark(function e(t, n) {
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f = arguments;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                r = f.length > 2 && f[2] !== undefined && f[2];
                a = f.length > 3 && f[3] !== undefined ? f[3] : {};
                i = f.length > 4 && f[4] !== undefined ? f[4] : {};
                this.disposeIntermediateTensors();
                if (!r) {
                  t = this.mapInputs(t);
                  this.checkInputs(t);
                  this.checkInputShapeAndType(t);
                  n = this.mapOutputs(n);
                  this.checkOutputs(n);
                }
                try {
                  this.keepIntermediateTensors = k0().getBool("KEEP_INTERMEDIATE_TENSORS");
                } catch (e) {
                  this.keepIntermediateTensors = false;
                  console.warn(e.message);
                }
                s = new Ove(this.weightMap, a, i, this.functionExecutorMap, this.parseNodeNameCache);
                if (this.keepIntermediateTensors) {
                  this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
                }
                e.next = 10;
                return this.executeWithControlFlow(t, s, n, r);
              case 10:
                u = e.sent;
                c = n.map(function (e) {
                  return cde(e, u, s);
                });
                l = c.map(function (e) {
                  return e.id;
                });
                h = Object.keys(t).map(function (e) {
                  return t[e].id;
                });
                p = new Set([].concat(T(l), T(h), T(this.weightIds)));
                Object.values(u).forEach(function (e) {
                  e.forEach(function (e) {
                    if (!!e && !e.isDisposed && !p.has(e.id)) {
                      e.dispose();
                    }
                  });
                });
                if (this.parent == null) {
                  s.dispose(p);
                }
                return e.abrupt("return", c);
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return r.apply(this, arguments);
      })
    }, {
      key: "executeFunctionAsync",
      value: (n = c(o().mark(function e(t, n, r) {
        var a;
        var i = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                a = t.reduce(function (e, t, n) {
                  e[i.inputs[n].name] = t;
                  return e;
                }, {});
                return e.abrupt("return", this._executeAsync(a, this.outputNodes, true, n, r));
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t, r) {
        return n.apply(this, arguments);
      })
    }, {
      key: "executeWithControlFlow",
      value: (t = c(o().mark(function e(t, n, r, a) {
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f;
        var d;
        var v;
        var m;
        var g;
        var y;
        var b;
        var x;
        var k;
        var w;
        var I;
        var N = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                i = Object.keys(t);
                s = i.map(function (e) {
                  return N.graph.nodes[fde(e)[0]];
                });
                u = r.map(function (e) {
                  return fde(e)[0];
                });
                c = new Set(u);
                if ((l = u.map(function (e) {
                  return N.graph.nodes[e];
                })).length === 0) {
                  l = this._outputs;
                }
                h = Fve(t, l, this.weightMap, this._initNodes);
                p = h.usedNodes;
                f = h.missingInputs;
                d = h.dynamicNode;
                v = h.syncInputs;
                m = [].concat(T(s), T(this.graph.weights), T(this._initNodes || [])).map(function (e) {
                  return {
                    node: e,
                    contexts: n.currentContext
                  };
                });
                g = Object.assign({}, this.weightMap);
                Object.keys(t).forEach(function (e) {
                  var n = S(fde(e), 2);
                  var r = n[0];
                  var a = [];
                  a[n[1]] = t[e];
                  g[r] = a;
                });
                y = {};
                b = this.getFrozenTensorIds(g);
                x = {};
              case 13:
                if (!(m.length > 0)) {
                  e.next = 19;
                  break;
                }
                k = this.processStack(s, m, n, g, x, b, c, y, p);
                e.next = 17;
                return Promise.all(k);
              case 17:
                e.next = 13;
                break;
              case 19:
                if (d == null && !a) {
                  console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
                }
                w = l.filter(function (e) {
                  return !Bve(e) && !cde(e.name, g, n);
                }).map(function (e) {
                  return e.name;
                });
                if (!(w.length > 0)) {
                  e.next = 25;
                  break;
                }
                I = "";
                if (d != null) {
                  I = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${v}]`;
                }
                throw new Error(`Cannot compute the outputs [${w}] from the provided inputs [${i}]. Consider providing the following inputs: [${f}]. ${I}`);
              case 25:
                return e.abrupt("return", g);
              case 26:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, n, r, a) {
        return t.apply(this, arguments);
      })
    }, {
      key: "processStack",
      value: function (e, t, n, r, a, i, o, s, u) {
        var c = this;
        var l = [];
        var h = function () {
          var e = t.pop();
          n.currentContext = e.contexts;
          var h = "";
          if (e.node.op === "Enter" && ude("isConstant", e.node, r, n)) {
            var p = S(hde(e.node.name, n), 1);
            h = p[0];
          }
          if (r[e.node.name] == null) {
            var f = _ve(e.node, r, n, c._resourceManager);
            if (!h) {
              var d = S(hde(e.node.name, n), 1);
              h = d[0];
            }
            var v = n.currentContext;
            if (v0(f)) {
              l.push(f.then(function (l) {
                r[h] = l;
                if (c.keepIntermediateTensors) {
                  c.clonedTensorsMap[h] = c.cloneTensorList(l);
                }
                n.currentContext = v;
                c.checkTensorForDisposal(h, e.node, r, n, i, o, s);
                c.processChildNodes(e.node, t, n, r, a, u);
                return l;
              }));
            } else {
              r[h] = f;
              if (c.keepIntermediateTensors) {
                c.clonedTensorsMap[h] = c.cloneTensorList(f);
              }
              c.checkTensorForDisposal(h, e.node, r, n, i, o, s);
              c.processChildNodes(e.node, t, n, r, a, u);
            }
          } else {
            c.processChildNodes(e.node, t, n, r, a, u);
          }
        };
        while (t.length > 0) {
          h();
        }
        return l;
      }
    }, {
      key: "processChildNodes",
      value: function (e, t, n, r, a, i) {
        e.children.forEach(function (e) {
          var o = S(hde(e.name, n), 1)[0];
          if (!a[o] && i.has(e.name)) {
            if (e.op === "Merge") {
              if (e.inputNames.some(function (e) {
                return !!cde(e, r, n);
              })) {
                a[o] = true;
                t.push({
                  contexts: n.currentContext,
                  node: e
                });
              }
            } else if (e.inputNames.every(function (e) {
              return !!cde(e, r, n);
            })) {
              a[o] = true;
              t.push({
                contexts: n.currentContext,
                node: e
              });
            }
          }
        });
      }
    }, {
      key: "dispose",
      value: function () {
        var e = this;
        Object.keys(this.weightMap).forEach(function (t) {
          return e.weightMap[t].forEach(function (e) {
            return e.dispose();
          });
        });
      }
    }, {
      key: "checkInputShapeAndType",
      value: function (e) {
        var t = this;
        Object.keys(e).forEach(function (n) {
          var r = e[n];
          var a = S(fde(n), 1)[0];
          var i = t.graph.nodes[a];
          if (i.attrParams.shape && i.attrParams.shape.value) {
            var o = i.attrParams.shape.value;
            var s = o.length === r.shape.length && r.shape.every(function (e, t) {
              return o[t] === -1 || o[t] === e;
            });
            F$(s, function () {
              return `The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`;
            });
          }
          if (i.attrParams.dtype && i.attrParams.dtype.value) {
            F$(r.dtype === i.attrParams.dtype.value, function () {
              return `The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`;
            });
          }
        });
      }
    }, {
      key: "mapInputs",
      value: function (e) {
        var r = {};
        for (var a in e) {
          var i = this._signature?.inputs?.[a];
          if (i != null) {
            r[i.name] = e[a];
          } else {
            r[a] = e[a];
          }
        }
        return r;
      }
    }, {
      key: "checkInputs",
      value: function (e) {
        var t = this;
        var n = Object.keys(e).filter(function (e) {
          var n = S(fde(e), 1)[0];
          return t.graph.nodes[n] == null;
        });
        if (n.length > 0) {
          throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`);
        }
      }
    }, {
      key: "mapOutputs",
      value: function (e) {
        var t = this;
        return e.map(function (e) {
          var a = t._signature?.outputs?.[e];
          if (a != null) {
            return a.name;
          } else {
            return e;
          }
        }, {});
      }
    }, {
      key: "checkOutputs",
      value: function (e) {
        var t = this;
        e.forEach(function (e) {
          var n = S(fde(e), 1)[0];
          if (!t.graph.nodes[n]) {
            throw new Error(`The output '${e}' is not found in the graph`);
          }
        });
      }
    }]);
    return e;
  }();
  var Gve = function () {
    function e(t = {}, n = {}) {
      l(this, e);
      this.hashTableNameToHandle = t;
      this.hashTableMap = n;
    }
    p(e, [{
      key: "addHashTable",
      value: function (e, t) {
        this.hashTableNameToHandle[e] = t.handle;
        this.hashTableMap[t.id] = t;
      }
    }, {
      key: "getHashTableHandleByName",
      value: function (e) {
        return this.hashTableNameToHandle[e];
      }
    }, {
      key: "getHashTableById",
      value: function (e) {
        return this.hashTableMap[e];
      }
    }, {
      key: "dispose",
      value: function () {
        for (var e in this.hashTableMap) {
          this.hashTableMap[e].clearAndClose();
          delete this.hashTableMap[e];
        }
        for (var t in this.hashTableNameToHandle) {
          this.hashTableNameToHandle[t].dispose();
          delete this.hashTableNameToHandle[t];
        }
      }
    }]);
    return e;
  }();
  var jve = function () {
    function e(t, n = {}, r = Nae) {
      l(this, e);
      this.modelUrl = t;
      this.loadOptions = n;
      this.version = "n/a";
      this.io = r;
      if (n == null) {
        this.loadOptions = {};
      }
      this.resourceManager = new Gve();
    }
    var t;
    var n;
    var r;
    var a;
    var i;
    p(e, [{
      key: "modelVersion",
      get: function () {
        return this.version;
      }
    }, {
      key: "inputNodes",
      get: function () {
        return this.executor.inputNodes;
      }
    }, {
      key: "outputNodes",
      get: function () {
        return this.executor.outputNodes;
      }
    }, {
      key: "inputs",
      get: function () {
        return this.executor.inputs;
      }
    }, {
      key: "outputs",
      get: function () {
        return this.executor.outputs;
      }
    }, {
      key: "weights",
      get: function () {
        return this.executor.weightMap;
      }
    }, {
      key: "metadata",
      get: function () {
        return this.artifacts.userDefinedMetadata;
      }
    }, {
      key: "modelSignature",
      get: function () {
        return this.signature;
      }
    }, {
      key: "modelStructuredOutputKeys",
      get: function () {
        return this.structuredOutputKeys;
      }
    }, {
      key: "findIOHandler",
      value: function () {
        var e = this.modelUrl;
        if (e.load != null) {
          this.handler = e;
        } else if (this.loadOptions.requestInit != null) {
          this.handler = this.io.browserHTTPRequest(e, this.loadOptions);
        } else {
          var t = this.io.getLoadHandlers(e, this.loadOptions);
          if (t.length === 0) {
            t.push(this.io.browserHTTPRequest(e, this.loadOptions));
          } else if (t.length > 1) {
            throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);
          }
          this.handler = t[0];
        }
      }
    }, {
      key: "load",
      value: function () {
        var e = this;
        this.findIOHandler();
        if (this.handler.load == null) {
          throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
        }
        var t = this.handler.load();
        if (v0(t)) {
          return t.then(function (t) {
            if (t.getWeightStream == null) {
              return e.loadSync(t);
            } else {
              return e.loadStreaming(t);
            }
          });
        } else {
          return this.loadSync(t);
        }
      }
    }, {
      key: "loadSync",
      value: function (e) {
        var t = this.io.decodeWeights(e.weightData, e.weightSpecs);
        return this.loadWithWeightMap(e, t);
      }
    }, {
      key: "loadStreaming",
      value: (i = c(o().mark(function e(t) {
        var n;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (t.getWeightStream != null) {
                  e.next = 2;
                  break;
                }
                throw new Error("Model artifacts missing streamWeights function");
              case 2:
                e.next = 4;
                return l6(t.getWeightStream(), t.weightSpecs);
              case 4:
                n = e.sent;
                return e.abrupt("return", this.loadWithWeightMap(t, n));
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return i.apply(this, arguments);
      })
    }, {
      key: "loadWithWeightMap",
      value: function (e, t) {
        this.artifacts = e;
        var n = this.artifacts.modelTopology;
        var r = this.artifacts.signature;
        if (this.artifacts.userDefinedMetadata != null) {
          var a = this.artifacts.userDefinedMetadata;
          if (a.signature != null) {
            r = a.signature;
          }
          if (a.structuredOutputKeys != null) {
            this.structuredOutputKeys = a.structuredOutputKeys;
          }
        }
        this.signature = r;
        this.version = `${n.versions.producer}.${n.versions.minConsumer}`;
        this.executor = new Vve(Mde.Instance.transformGraph(n, this.signature));
        this.executor.weightMap = this.convertTensorMapToTensorsMap(t);
        this.executor.resourceManager = this.resourceManager;
        if (e.modelInitializer != null && e.modelInitializer.node != null) {
          var i = Mde.Instance.transformGraph(e.modelInitializer);
          this.initializer = new Vve(i);
          this.initializer.weightMap = this.executor.weightMap;
          this.initializer.resourceManager = this.resourceManager;
          this.initializerSignature = e.initializerSignature;
        }
        return true;
      }
    }, {
      key: "save",
      value: (a = c(o().mark(function e(t, n) {
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (typeof t != "string") {
                  e.next = 9;
                  break;
                }
                if ((r = this.io.getSaveHandlers(t)).length !== 0) {
                  e.next = 6;
                  break;
                }
                throw new Error(`Cannot find any save handlers for URL '${t}'`);
              case 6:
                if (!(r.length > 1)) {
                  e.next = 8;
                  break;
                }
                throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);
              case 8:
                t = r[0];
              case 9:
                if (t.save != null) {
                  e.next = 11;
                  break;
                }
                throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
              case 11:
                return e.abrupt("return", t.save(this.artifacts));
              case 12:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return a.apply(this, arguments);
      })
    }, {
      key: "addStructuredOutputNames",
      value: function (e) {
        var t = this;
        if (this.structuredOutputKeys) {
          var n = {};
          (e instanceof n5 ? [e] : e).forEach(function (e, r) {
            return n[t.structuredOutputKeys[r]] = e;
          });
          return n;
        }
        return e;
      }
    }, {
      key: "predict",
      value: function (e, t) {
        var n = this.execute(e, this.outputNodes);
        return this.addStructuredOutputNames(n);
      }
    }, {
      key: "predictAsync",
      value: (r = c(o().mark(function e(t, n) {
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.executeAsync(t, this.outputNodes);
              case 2:
                r = e.sent;
                return e.abrupt("return", this.addStructuredOutputNames(r));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, t) {
        return r.apply(this, arguments);
      })
    }, {
      key: "normalizeInputs",
      value: function (e) {
        var n = this;
        if (!(e instanceof n5) && !Array.isArray(e)) {
          var r = this.signature?.inputs;
          if (r != null) {
            for (var a in r) {
              var i = r[a];
              if (i.resourceId != null) {
                e[a] = this.resourceIdToCapturedInput[i.resourceId];
              }
            }
          }
          return e;
        }
        e = Array.isArray(e) ? e : [e];
        var o = Object.keys(this.resourceIdToCapturedInput).length;
        if (e.length + o !== this.inputNodes.length) {
          throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - o} non-resource placeholders, while there are ${e.length} input tensors provided.`);
        }
        var s = 0;
        return this.inputNodes.reduce(function (t, r) {
          var u = n.signature?.inputs?.[r]?.resourceId;
          t[r] = u != null ? n.resourceIdToCapturedInput[u] : e[s++];
          return t;
        }, {});
      }
    }, {
      key: "normalizeOutputs",
      value: function (e) {
        e = e || this.outputNodes;
        if (Array.isArray(e)) {
          return e;
        } else {
          return [e];
        }
      }
    }, {
      key: "executeInitializerGraph",
      value: function () {
        if (this.initializer == null) {
          return [];
        } else if (this.initializerSignature == null) {
          return this.initializer.execute({}, []);
        } else {
          return this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
        }
      }
    }, {
      key: "executeInitializerGraphAsync",
      value: (n = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.initializer != null) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", []);
              case 2:
                if (this.initializerSignature != null) {
                  e.next = 6;
                  break;
                }
                return e.abrupt("return", this.initializer.executeAsync({}, []));
              case 6:
                return e.abrupt("return", this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs)));
              case 7:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "setResourceIdToCapturedInput",
      value: function (e) {
        this.resourceIdToCapturedInput = {};
        if (this.initializerSignature) {
          var t = this.initializerSignature.outputs;
          for (var n = Object.keys(t), r = 0; r < n.length; r++) {
            var a = t[n[r]];
            this.resourceIdToCapturedInput[a.resourceId] = e[r];
          }
        }
      }
    }, {
      key: "execute",
      value: function (e, t) {
        if (this.resourceIdToCapturedInput == null) {
          this.setResourceIdToCapturedInput(this.executeInitializerGraph());
        }
        e = this.normalizeInputs(e);
        t = this.normalizeOutputs(t);
        var n = this.executor.execute(e, t);
        if (n.length > 1) {
          return n;
        } else {
          return n[0];
        }
      }
    }, {
      key: "executeAsync",
      value: (t = c(o().mark(function e(t, n) {
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.resourceIdToCapturedInput != null) {
                  e.next = 6;
                  break;
                }
                e.t0 = this;
                e.next = 4;
                return this.executeInitializerGraphAsync();
              case 4:
                e.t1 = e.sent;
                e.t0.setResourceIdToCapturedInput.call(e.t0, e.t1);
              case 6:
                t = this.normalizeInputs(t);
                n = this.normalizeOutputs(n);
                e.next = 10;
                return this.executor.executeAsync(t, n);
              case 10:
                r = e.sent;
                return e.abrupt("return", r.length > 1 ? r : r[0]);
              case 12:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e, n) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getIntermediateTensors",
      value: function () {
        return this.executor.getIntermediateTensors();
      }
    }, {
      key: "disposeIntermediateTensors",
      value: function () {
        this.executor.disposeIntermediateTensors();
      }
    }, {
      key: "convertTensorMapToTensorsMap",
      value: function (e) {
        return Object.keys(e).reduce(function (t, n) {
          t[n] = [e[n]];
          return t;
        }, {});
      }
    }, {
      key: "dispose",
      value: function () {
        this.executor.dispose();
        if (this.initializer) {
          this.initializer.dispose();
          if (this.resourceIdToCapturedInput) {
            Y5(this.resourceIdToCapturedInput);
          }
        }
        this.resourceManager.dispose();
      }
    }]);
    return e;
  }();
  function Hve() {
    Hve = c(o().mark(function e(t) {
      var n;
      var r;
      var a;
      var i = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              n = i.length > 1 && i[1] !== undefined ? i[1] : {};
              r = i.length > 2 && i[2] !== undefined ? i[2] : Nae;
              if (t != null) {
                e.next = 4;
                break;
              }
              throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
            case 4:
              if (n == null) {
                n = {};
              }
              if (n.fromTFHub && typeof t == "string") {
                t = qve(t);
              }
              a = new jve(t, n, r);
              e.next = 9;
              return a.load();
            case 9:
              return e.abrupt("return", a);
            case 10:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return Hve.apply(this, arguments);
  }
  function qve(e) {
    if (!e.endsWith("/")) {
      e += "/";
    }
    return `${e}model.json?tfjs-format=file`;
  }
  var Kve = "4.15.0";
  function Xve(e, t, n = new Map(), r = new Set()) {
    if (e == null) {
      return null;
    }
    if (typeof Blob == "function" && e instanceof Blob) {
      return e.slice();
    }
    if (r.has(e)) {
      throw new Error("Circular references are not supported.");
    }
    if (n.has(e)) {
      return n.get(e);
    }
    var a = t(e);
    if (a.recurse && a.value !== null) {
      throw new Error("A deep map function may not return both a value and recurse=true.");
    }
    if (a.recurse) {
      if (eme(e)) {
        var i = Array.isArray(e) ? [] : {};
        r.add(e);
        for (var o in e) {
          var s = e[o];
          var u = Xve(s, t, n, r);
          i[o] = u;
        }
        r.delete(e);
        if (e.__proto__) {
          i.__proto__ = e.__proto__;
        }
        return i;
      }
      throw new Error(`Can't recurse into non-iterable type: ${e}`);
    }
    n.set(e, a.value);
    return a.value;
  }
  function Yve(e, t = Zve) {
    return Jve(e, t);
  }
  function Jve(e, t, n = new Set()) {
    var r = e[0];
    if (n.has(r)) {
      throw new Error("Circular references are not supported.");
    }
    var a = t(e);
    if (a.recurse && a.value !== null) {
      throw new Error("A deep zip function may not return both a value and recurse=true.");
    }
    if (a.recurse) {
      if (eme(r)) {
        var i = Array.isArray(r) ? [] : {};
        n.add(r);
        function o(r) {
          var a = Jve(e.map(function (e) {
            return e[r];
          }), t, n);
          i[r] = a;
        }
        for (var s in r) {
          o(s);
        }
        n.delete(r);
        return i;
      }
      throw new Error(`Can't recurse into non-iterable type: ${r}`);
    }
    return a.value;
  }
  function Zve(e) {
    if (e === null) {
      return null;
    } else if (eme(e[0])) {
      return {
        value: null,
        recurse: true
      };
    } else {
      return {
        value: e,
        recurse: false
      };
    }
  }
  function Qve(e, t) {
    return $ve.apply(this, arguments);
  }
  function $ve() {
    $ve = c(o().mark(function e(t, n) {
      var r;
      var a;
      var i;
      var s;
      var u;
      var c;
      var l;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              r = new Map();
              Xve(t, n, r);
              a = 0;
              i = Array.from(r.keys());
            case 3:
              if (!(a < i.length)) {
                e.next = 14;
                break;
              }
              s = i[a];
              if (!v0(u = r.get(s))) {
                e.next = 11;
                break;
              }
              e.next = 9;
              return u;
            case 9:
              c = e.sent;
              r.set(s, c);
            case 11:
              a++;
              e.next = 3;
              break;
            case 14:
              l = Xve(t, n, r);
              return e.abrupt("return", l);
            case 16:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return $ve.apply(this, arguments);
  }
  function eme(e) {
    var t = false;
    if (k0().get("IS_BROWSER")) {
      t = e instanceof TextDecoder;
    } else {
      t = e instanceof require("string_decoder").StringDecoder;
    }
    return e != null && !ArrayBuffer.isView(e) && (Array.isArray(e) || s(e) === "object" && !(e instanceof n5) && !(e instanceof Promise) && !t);
  }
  function tme(e) {
    return e == null || (t = e) === null || s(t) !== "object" && typeof t != "function" || Array.isArray(e) || s(e) === "object" && e instanceof n5 || U4(e);
    var t;
  }
  function nme(e) {
    return function (e, t) {
      return Xve(e, t);
    }(e, rme);
  }
  function rme(e) {
    if (e instanceof n5) {
      return {
        value: e.clone(),
        recurse: false
      };
    } else if (eme(e)) {
      return {
        value: null,
        recurse: true
      };
    } else {
      return {
        value: e,
        recurse: false
      };
    }
  }
  var ame = function () {
    function e(t) {
      l(this, e);
      this.capacity = t;
      this.begin = 0;
      this.end = 0;
      if (t == null) {
        throw new RangeError("Can't create a ring buffer of unknown capacity.");
      }
      if (t < 1) {
        throw new RangeError("Can't create ring buffer of capacity < 1.");
      }
      this.data = new Array(t);
      this.doubledCapacity = t * 2;
    }
    p(e, [{
      key: "wrap",
      value: function (e) {
        while (e < 0) {
          e += this.doubledCapacity;
        }
        return e % this.doubledCapacity;
      }
    }, {
      key: "get",
      value: function (e) {
        if (e < 0) {
          throw new RangeError("Can't get item at a negative index.");
        }
        return this.data[e % this.capacity];
      }
    }, {
      key: "set",
      value: function (e, t) {
        if (e < 0) {
          throw new RangeError("Can't set item at a negative index.");
        }
        this.data[e % this.capacity] = t;
      }
    }, {
      key: "length",
      value: function () {
        var e = this.end - this.begin;
        if (e < 0) {
          e = this.doubledCapacity + e;
        }
        return e;
      }
    }, {
      key: "isFull",
      value: function () {
        return this.length() === this.capacity;
      }
    }, {
      key: "isEmpty",
      value: function () {
        return this.length() === 0;
      }
    }, {
      key: "push",
      value: function (e) {
        if (this.isFull()) {
          throw new RangeError("Ring buffer is full.");
        }
        this.set(this.end, e);
        this.end = this.wrap(this.end + 1);
      }
    }, {
      key: "pushAll",
      value: function (e) {
        var t;
        var n = O(e);
        try {
          for (n.s(); !(t = n.n()).done;) {
            var r = t.value;
            this.push(r);
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }
      }
    }, {
      key: "pop",
      value: function () {
        if (this.isEmpty()) {
          throw new RangeError("Ring buffer is empty.");
        }
        this.end = this.wrap(this.end - 1);
        var e = this.get(this.end);
        this.set(this.end, undefined);
        return e;
      }
    }, {
      key: "unshift",
      value: function (e) {
        if (this.isFull()) {
          throw new RangeError("Ring buffer is full.");
        }
        this.begin = this.wrap(this.begin - 1);
        this.set(this.begin, e);
      }
    }, {
      key: "shift",
      value: function () {
        if (this.isEmpty()) {
          throw new RangeError("Ring buffer is empty.");
        }
        var e = this.get(this.begin);
        this.set(this.begin, undefined);
        this.begin = this.wrap(this.begin + 1);
        return e;
      }
    }, {
      key: "shuffleExcise",
      value: function (e) {
        if (this.isEmpty()) {
          throw new RangeError("Ring buffer is empty.");
        }
        var t = this.wrap(this.begin + e);
        var n = this.get(t);
        this.set(t, this.pop());
        return n;
      }
    }]);
    return e;
  }();
  var ime = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.call(this, n.INITIAL_CAPACITY);
    }
    p(n, [{
      key: "isFull",
      value: function () {
        return false;
      }
    }, {
      key: "push",
      value: function (e) {
        if (N(v(n.prototype), "isFull", this).call(this)) {
          this.expand();
        }
        N(v(n.prototype), "push", this).call(this, e);
      }
    }, {
      key: "unshift",
      value: function (e) {
        if (N(v(n.prototype), "isFull", this).call(this)) {
          this.expand();
        }
        N(v(n.prototype), "unshift", this).call(this, e);
      }
    }, {
      key: "expand",
      value: function () {
        var e = this.capacity * 2;
        var t = new Array(e);
        for (var n = this.length(), r = 0; r < n; r++) {
          t[r] = this.get(this.wrap(this.begin + r));
        }
        this.data = t;
        this.capacity = e;
        this.doubledCapacity = this.capacity * 2;
        this.begin = 0;
        this.end = n;
      }
    }]);
    return n;
  }(ame);
  function ome(e) {
    return new pme(e);
  }
  function sme(e) {
    return new fme(e);
  }
  function ume(e, t) {
    return new Nme(e, t);
  }
  function cme(e, t = lme.FAIL) {
    return new Sme(e, t);
  }
  ime.INITIAL_CAPACITY = 32;
  var lme;
  var hme = function () {
    function e() {
      l(this, e);
    }
    var t;
    var n;
    var r;
    var a;
    var i;
    p(e, [{
      key: "toArray",
      value: function () {
        var e = c(o().mark(function e() {
          var t;
          var n;
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  t = [];
                  e.next = 3;
                  return this.next();
                case 3:
                  n = e.sent;
                case 4:
                  if (n.done) {
                    e.next = 11;
                    break;
                  }
                  t.push(n.value);
                  e.next = 8;
                  return this.next();
                case 8:
                  n = e.sent;
                  e.next = 4;
                  break;
                case 11:
                  return e.abrupt("return", t);
                case 12:
                case "end":
                  return e.stop();
              }
            }
          }, e, this);
        }));
        return function () {
          return e.apply(this, arguments);
        };
      }()
    }, {
      key: "toArrayForTest",
      value: (i = c(o().mark(function e() {
        var t;
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = this.prefetch(100);
                n = [];
                e.next = 4;
                return t.next();
              case 4:
                r = e.sent;
              case 5:
                if (r.done) {
                  e.next = 12;
                  break;
                }
                n.push(r.value);
                e.next = 9;
                return t.next();
              case 9:
                r = e.sent;
                e.next = 5;
                break;
              case 12:
                return e.abrupt("return", n);
              case 13:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return i.apply(this, arguments);
      })
    }, {
      key: "resolveFully",
      value: (a = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.next();
              case 2:
                t = e.sent;
              case 3:
                if (t.done) {
                  e.next = 9;
                  break;
                }
                e.next = 6;
                return this.next();
              case 6:
                t = e.sent;
                e.next = 3;
                break;
              case 9:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "resolveWhile",
      value: (r = c(o().mark(function e(t) {
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.next();
              case 2:
                n = e.sent;
                r = t(n.value);
              case 4:
                if (n.done || !r) {
                  e.next = 11;
                  break;
                }
                e.next = 7;
                return this.next();
              case 7:
                n = e.sent;
                r = t(n.value);
                e.next = 4;
                break;
              case 11:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return r.apply(this, arguments);
      })
    }, {
      key: "handleErrors",
      value: function (e) {
        return new xme(this, e);
      }
    }, {
      key: "filter",
      value: function (e) {
        return new yme(this, e);
      }
    }, {
      key: "map",
      value: function (e) {
        return new bme(this, e);
      }
    }, {
      key: "mapAsync",
      value: function (e) {
        return new kme(this, e);
      }
    }, {
      key: "serialMapAsync",
      value: function (e) {
        return new kme(this, e).serial();
      }
    }, {
      key: "flatmap",
      value: function (e) {
        return new Ime(this, e);
      }
    }, {
      key: "forEachAsync",
      value: (n = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.map(t).resolveFully());
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "serialForEach",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.serialMapAsync(t).resolveWhile(function (e) {
                  return e === true;
                }));
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "rowMajorBatch",
      value: function (e) {
        var t = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
        return new gme(this, e, t);
      }
    }, {
      key: "columnMajorBatch",
      value: function (e) {
        var t = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
        var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Zve;
        var r = this.rowMajorBatch(e, t);
        return r.map(function (e) {
          return Yve(e, n);
        });
      }
    }, {
      key: "concatenate",
      value: function (e, t) {
        return new Nme(ome([this, e]), t);
      }
    }, {
      key: "take",
      value: function (e) {
        if (e < 0 || e == null) {
          return this;
        } else {
          return new mme(this, e);
        }
      }
    }, {
      key: "skip",
      value: function (e) {
        if (e < 0 || e == null) {
          return this;
        } else {
          return new vme(this, e);
        }
      }
    }, {
      key: "prefetch",
      value: function (e) {
        return new Tme(this, e);
      }
    }, {
      key: "shuffle",
      value: function (e, t) {
        return new Eme(this, e, t);
      }
    }, {
      key: "serial",
      value: function () {
        return new dme(this);
      }
    }]);
    return e;
  }();
  var pme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      l(this, r);
      (t = n.call(this)).items = e;
      t.trav = 0;
      return t;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `Array of ${this.items.length} items`;
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(this.trav >= this.items.length)) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 2:
                t = this.items[this.trav];
                this.trav++;
                return e.abrupt("return", {
                  value: nme(t),
                  done: false
                });
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(hme);
  var fme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      l(this, r);
      (t = n.call(this)).nextFn = e;
      return t;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return "Function call";
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.prev = 0;
                return e.abrupt("return", this.nextFn());
              case 4:
                e.prev = 4;
                e.t0 = e.catch(0);
                e.t0.message = `Error thrown while iterating through a dataset: ${e.t0.message}`;
                throw e.t0;
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[0, 4]]);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(hme);
  var dme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e) {
      var t;
      l(this, a);
      (t = r.call(this)).upstream = e;
      t.lastRead = Promise.resolve({
        value: null,
        done: false
      });
      return t;
    }
    p(a, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Serial`;
      }
    }, {
      key: "next",
      value: (n = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.lastRead.then(function () {
                  return t.serialNext();
                });
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "serialNext",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.upstream.next());
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  var vme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t) {
      var n;
      l(this, a);
      (n = r.call(this)).upstream = e;
      n.maxCount = t;
      n.count = 0;
      n.lastRead = Promise.resolve({
        value: null,
        done: false
      });
      return n;
    }
    p(a, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Skip`;
      }
    }, {
      key: "next",
      value: (n = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.lastRead.then(function () {
                  return t.serialNext();
                });
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "serialNext",
      value: (t = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(this.count++ < this.maxCount)) {
                  e.next = 9;
                  break;
                }
                e.next = 3;
                return this.upstream.next();
              case 3:
                if (!(t = e.sent).done) {
                  e.next = 6;
                  break;
                }
                return e.abrupt("return", t);
              case 6:
                Y5(t.value);
                e.next = 0;
                break;
              case 9:
                return e.abrupt("return", this.upstream.next());
              case 10:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  var mme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e, t) {
      var a;
      l(this, r);
      (a = n.call(this)).upstream = e;
      a.maxCount = t;
      a.count = 0;
      return a;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Take`;
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(this.count++ >= this.maxCount)) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 2:
                return e.abrupt("return", this.upstream.next());
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(hme);
  var gme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t) {
      var n;
      var i = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
      l(this, a);
      (n = r.call(this)).upstream = e;
      n.batchSize = t;
      n.enableSmallLastBatch = i;
      n.lastRead = Promise.resolve({
        value: null,
        done: false
      });
      return n;
    }
    p(a, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> RowMajorBatch`;
      }
    }, {
      key: "next",
      value: (n = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.lastRead.then(function () {
                  return t.serialNext();
                });
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "serialNext",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = [];
              case 1:
                if (!(t.length < this.batchSize)) {
                  e.next = 12;
                  break;
                }
                e.next = 4;
                return this.upstream.next();
              case 4:
                if (!(n = e.sent).done) {
                  e.next = 9;
                  break;
                }
                if (!this.enableSmallLastBatch || !(t.length > 0)) {
                  e.next = 8;
                  break;
                }
                return e.abrupt("return", {
                  value: t,
                  done: false
                });
              case 8:
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 9:
                t.push(n.value);
                e.next = 1;
                break;
              case 12:
                return e.abrupt("return", {
                  value: t,
                  done: false
                });
              case 13:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  var yme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t) {
      var n;
      l(this, a);
      (n = r.call(this)).upstream = e;
      n.predicate = t;
      n.lastRead = Promise.resolve({
        value: null,
        done: false
      });
      return n;
    }
    p(a, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Filter`;
      }
    }, {
      key: "next",
      value: (n = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.lastRead.then(function () {
                  return t.serialNext();
                });
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "serialNext",
      value: (t = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 3;
                return this.upstream.next();
              case 3:
                if (!(t = e.sent).done && !this.predicate(t.value)) {
                  e.next = 6;
                  break;
                }
                return e.abrupt("return", t);
              case 6:
                Y5(t.value);
                e.next = 0;
                break;
              case 9:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  var bme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e, t) {
      var a;
      l(this, r);
      (a = n.call(this)).upstream = e;
      a.transform = t;
      return a;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Map`;
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.upstream.next();
              case 2:
                if (!(t = e.sent).done) {
                  e.next = 5;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 5:
                n = y5(t.value);
                r = this.transform(t.value);
                a = y5(r);
                i = O(n);
                try {
                  for (i.s(); !(s = i.n()).done;) {
                    if (!g5(u = s.value, a)) {
                      u.dispose();
                    }
                  }
                } catch (e) {
                  i.e(e);
                } finally {
                  i.f();
                }
                return e.abrupt("return", {
                  value: r,
                  done: false
                });
              case 11:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(hme);
  var xme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t) {
      var n;
      l(this, a);
      (n = r.call(this)).upstream = e;
      n.handler = t;
      n.count = 0;
      n.lastRead = Promise.resolve({
        value: null,
        done: false
      });
      return n;
    }
    p(a, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> handleErrors`;
      }
    }, {
      key: "next",
      value: (n = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.lastRead.then(function () {
                  return t.serialNext();
                });
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "serialNext",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.prev = 1;
                e.next = 4;
                return this.upstream.next();
              case 4:
                return e.abrupt("return", e.sent);
              case 7:
                e.prev = 7;
                e.t0 = e.catch(1);
                if (this.handler(e.t0)) {
                  e.next = 11;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 11:
                e.next = 0;
                break;
              case 13:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[1, 7]]);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  var kme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e, t) {
      var a;
      l(this, r);
      (a = n.call(this)).upstream = e;
      a.transform = t;
      return a;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> AsyncMap`;
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.upstream.next();
              case 2:
                if (!(t = e.sent).done) {
                  e.next = 5;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 5:
                n = y5(t.value);
                e.next = 8;
                return this.transform(t.value);
              case 8:
                r = e.sent;
                a = y5(r);
                i = O(n);
                try {
                  for (i.s(); !(s = i.n()).done;) {
                    if (!g5(u = s.value, a)) {
                      u.dispose();
                    }
                  }
                } catch (e) {
                  i.e(e);
                } finally {
                  i.f();
                }
                return e.abrupt("return", {
                  value: r,
                  done: false
                });
              case 13:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(hme);
  var wme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a() {
      var e;
      l(this, a);
      (e = r.call(this)).outputQueue = new ime();
      e.lastRead = Promise.resolve({
        value: null,
        done: false
      });
      return e;
    }
    p(a, [{
      key: "next",
      value: (n = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.lastRead.then(function () {
                  return t.serialNext();
                });
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "serialNext",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.outputQueue.length() !== 0) {
                  e.next = 7;
                  break;
                }
                e.next = 3;
                return this.pump();
              case 3:
                if (e.sent) {
                  e.next = 5;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 5:
                e.next = 0;
                break;
              case 7:
                return e.abrupt("return", {
                  value: this.outputQueue.shift(),
                  done: false
                });
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  var Ime = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e, t) {
      var a;
      l(this, r);
      (a = n.call(this)).upstream = e;
      a.transform = t;
      return a;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Flatmap`;
      }
    }, {
      key: "pump",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.upstream.next();
              case 2:
                if (!(t = e.sent).done) {
                  e.next = 5;
                  break;
                }
                return e.abrupt("return", false);
              case 5:
                n = y5(t.value);
                r = this.transform(t.value);
                a = y5(r);
                this.outputQueue.pushAll(r);
                i = O(n);
                try {
                  for (i.s(); !(s = i.n()).done;) {
                    if (!g5(u = s.value, a)) {
                      u.dispose();
                    }
                  }
                } catch (e) {
                  i.e(e);
                } finally {
                  i.f();
                }
                return e.abrupt("return", true);
              case 12:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(wme);
  var Nme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t) {
      var n;
      l(this, a);
      (n = r.call(this)).baseErrorHandler = t;
      n.lastRead = null;
      n.iterator = null;
      n.moreIterators = e;
      return n;
    }
    p(a, [{
      key: "summary",
      value: function () {
        return `TODO: fill in upstream of chained summaries -> Chained`;
      }
    }, {
      key: "next",
      value: (n = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.readFromChain(this.lastRead);
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "readFromChain",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return t;
              case 2:
                if (this.iterator != null) {
                  e.next = 10;
                  break;
                }
                e.next = 5;
                return this.moreIterators.next();
              case 5:
                if (!(n = e.sent).done) {
                  e.next = 8;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 8:
                this.iterator = n.value;
                if (this.baseErrorHandler != null) {
                  this.iterator = this.iterator.handleErrors(this.baseErrorHandler);
                }
              case 10:
                e.next = 12;
                return this.iterator.next();
              case 12:
                if (!(r = e.sent).done) {
                  e.next = 16;
                  break;
                }
                this.iterator = null;
                return e.abrupt("return", this.readFromChain(t));
              case 16:
                return e.abrupt("return", r);
              case 17:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  (function (e) {
    e[e.FAIL = 0] = "FAIL";
    e[e.SHORTEST = 1] = "SHORTEST";
    e[e.LONGEST = 2] = "LONGEST";
  })(lme ||= {});
  var Sme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e) {
      var t;
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lme.FAIL;
      l(this, a);
      (t = r.call(this)).iterators = e;
      t.mismatchMode = n;
      t.count = 0;
      t.currentPromise = null;
      return t;
    }
    p(a, [{
      key: "summary",
      value: function () {
        return `{TODO: fill in upstream of zip summaries} -> Zip`;
      }
    }, {
      key: "nextState",
      value: (n = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                a = function (e) {
                  if (e instanceof hme) {
                    return {
                      value: e.next().then(function (e) {
                        n++;
                        if (e.done) {
                          r++;
                        }
                        return e.value;
                      }),
                      recurse: false
                    };
                  } else {
                    return {
                      value: null,
                      recurse: true
                    };
                  }
                };
                e.next = 3;
                return t;
              case 3:
                n = 0;
                r = 0;
                e.next = 7;
                return Qve(this.iterators, a);
              case 7:
                i = e.sent;
                if (n !== r) {
                  e.next = 10;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 10:
                if (!(r > 0)) {
                  e.next = 16;
                  break;
                }
                e.t0 = this.mismatchMode;
                e.next = e.t0 === lme.FAIL ? 14 : e.t0 === lme.SHORTEST ? 15 : (e.t0, lme.LONGEST, 16);
                break;
              case 14:
                throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);
              case 15:
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 16:
                this.count++;
                return e.abrupt("return", {
                  value: i,
                  done: false
                });
              case 18:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.currentPromise = this.nextState(this.currentPromise);
                return e.abrupt("return", this.currentPromise);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(hme);
  var Tme = function (e) {
    d(n, e);
    var t = w(n);
    function n(e, r) {
      var a;
      l(this, n);
      (a = t.call(this)).upstream = e;
      a.bufferSize = r;
      a.buffer = new ame(r);
      return a;
    }
    p(n, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Prefetch`;
      }
    }, {
      key: "refill",
      value: function () {
        while (!this.buffer.isFull()) {
          var e = this.upstream.next();
          this.buffer.push(e);
        }
      }
    }, {
      key: "next",
      value: function () {
        this.refill();
        return this.buffer.shift();
      }
    }]);
    return n;
  }(hme);
  var Eme = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a(e, t, n) {
      var i;
      l(this, a);
      (i = r.call(this, e, t)).upstream = e;
      i.windowSize = t;
      i.upstreamExhausted = false;
      i.random = qee.alea(n || z4().toString());
      i.lastRead = Promise.resolve({
        value: null,
        done: false
      });
      return i;
    }
    p(a, [{
      key: "next",
      value: (n = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                this.lastRead = this.lastRead.then(function () {
                  return t.serialNext();
                });
                return e.abrupt("return", this.lastRead);
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "randomInt",
      value: function (e) {
        return Math.floor(this.random() * e);
      }
    }, {
      key: "chooseIndex",
      value: function () {
        return this.randomInt(this.buffer.length());
      }
    }, {
      key: "serialNext",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!this.upstreamExhausted) {
                  this.refill();
                }
              case 1:
                if (this.buffer.isEmpty()) {
                  e.next = 14;
                  break;
                }
                t = this.chooseIndex();
                e.next = 5;
                return this.buffer.shuffleExcise(t);
              case 5:
                if (!(n = e.sent).done) {
                  e.next = 10;
                  break;
                }
                this.upstreamExhausted = true;
                e.next = 12;
                break;
              case 10:
                this.refill();
                return e.abrupt("return", n);
              case 12:
                e.next = 1;
                break;
              case 14:
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 15:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return a;
  }(Tme);
  var Cme = function () {
    function e() {
      l(this, e);
      this.size = null;
    }
    var t;
    var n;
    p(e, [{
      key: "batch",
      value: function (e) {
        var t;
        var n = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
        var r = this;
        F$(e > 0, function () {
          return `batchSize needs to be positive, but it is
      ${e}`;
        });
        t = this.size === Infinity || this.size == null ? this.size : n ? Math.ceil(this.size / e) : Math.floor(this.size / e);
        return Ame(c(o().mark(function t() {
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  t.next = 2;
                  return r.iterator();
                case 2:
                  return t.abrupt("return", t.sent.columnMajorBatch(e, n, Rme));
                case 3:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), t);
      }
    }, {
      key: "concatenate",
      value: function (e) {
        var t;
        var n = this;
        t = this.size === Infinity || e.size === Infinity ? Infinity : this.size != null && e.size != null ? this.size + e.size : null;
        return Ame(c(o().mark(function t() {
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  t.next = 2;
                  return n.iterator();
                case 2:
                  t.t0 = t.sent;
                  t.next = 5;
                  return e.iterator();
                case 5:
                  t.t1 = t.sent;
                  return t.abrupt("return", t.t0.concatenate.call(t.t0, t.t1));
                case 7:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), t);
      }
    }, {
      key: "filter",
      value: function (e) {
        var t;
        var n = this;
        t = this.size === Infinity ? Infinity : null;
        return Ame(c(o().mark(function t() {
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  t.next = 2;
                  return n.iterator();
                case 2:
                  return t.abrupt("return", t.sent.filter(function (t) {
                    return X5(function () {
                      return e(t);
                    });
                  }));
                case 3:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), t);
      }
    }, {
      key: "forEachAsync",
      value: (n = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.iterator();
              case 2:
                return e.abrupt("return", e.sent.forEachAsync(t));
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "map",
      value: function (e) {
        var t = this;
        return Ame(c(o().mark(function n() {
          return o().wrap(function (n) {
            while (true) {
              switch (n.prev = n.next) {
                case 0:
                  n.next = 2;
                  return t.iterator();
                case 2:
                  return n.abrupt("return", n.sent.map(function (t) {
                    return X5(function () {
                      return e(t);
                    });
                  }));
                case 3:
                case "end":
                  return n.stop();
              }
            }
          }, n);
        })), this.size);
      }
    }, {
      key: "mapAsync",
      value: function (e) {
        var t = this;
        return Ame(c(o().mark(function n() {
          return o().wrap(function (n) {
            while (true) {
              switch (n.prev = n.next) {
                case 0:
                  n.next = 2;
                  return t.iterator();
                case 2:
                  return n.abrupt("return", n.sent.mapAsync(e));
                case 3:
                case "end":
                  return n.stop();
              }
            }
          }, n);
        })), this.size);
      }
    }, {
      key: "prefetch",
      value: function (e) {
        if (e == null) {
          throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
        }
        var t = this;
        return Ame(c(o().mark(function n() {
          return o().wrap(function (n) {
            while (true) {
              switch (n.prev = n.next) {
                case 0:
                  n.next = 2;
                  return t.iterator();
                case 2:
                  return n.abrupt("return", n.sent.prefetch(e));
                case 3:
                case "end":
                  return n.stop();
              }
            }
          }, n);
        })), this.size);
      }
    }, {
      key: "repeat",
      value: function (e) {
        var t;
        var n = this;
        t = this.size != null && e > 0 ? this.size * e : e === 0 ? 0 : this.size != null && (e === undefined || e < 0) ? Infinity : null;
        return Ame(c(o().mark(function t() {
          var r;
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  r = sme(c(o().mark(function e() {
                    return o().wrap(function (e) {
                      while (true) {
                        switch (e.prev = e.next) {
                          case 0:
                            e.next = 2;
                            return n.iterator();
                          case 2:
                            e.t0 = e.sent;
                            return e.abrupt("return", {
                              value: e.t0,
                              done: false
                            });
                          case 4:
                          case "end":
                            return e.stop();
                        }
                      }
                    }, e);
                  })));
                  return t.abrupt("return", ume(r.take(e)));
                case 2:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), t);
      }
    }, {
      key: "skip",
      value: function (e) {
        var t;
        var n = this;
        t = this.size != null && e >= 0 && this.size >= e ? this.size - e : this.size != null && (this.size < e || e === undefined || e < 0) ? 0 : null;
        return Ame(c(o().mark(function t() {
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  t.next = 2;
                  return n.iterator();
                case 2:
                  return t.abrupt("return", t.sent.skip(e));
                case 3:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), t);
      }
    }, {
      key: "shuffle",
      value: function (e, t) {
        var n = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
        if (e == null || e < 0) {
          throw this.size == null ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
        }
        var r = this;
        var a = qee.alea(t || z4().toString());
        return Ame(c(o().mark(function t() {
          var i;
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  i = a.int32();
                  if (n) {
                    i += a.int32();
                  }
                  t.next = 4;
                  return r.iterator();
                case 4:
                  return t.abrupt("return", t.sent.shuffle(e, i.toString()));
                case 5:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), this.size);
      }
    }, {
      key: "take",
      value: function (e) {
        var t;
        var n = this;
        t = this.size != null && this.size > e ? e : this.size != null && this.size <= e ? this.size : null;
        return Ame(c(o().mark(function t() {
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  t.next = 2;
                  return n.iterator();
                case 2:
                  return t.abrupt("return", t.sent.take(e));
                case 3:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), t);
      }
    }, {
      key: "toArray",
      value: function () {
        var e = c(o().mark(function e() {
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  if (this.size !== Infinity) {
                    e.next = 2;
                    break;
                  }
                  throw new Error("Can not convert infinite data stream to array.");
                case 2:
                  e.next = 4;
                  return this.iterator();
                case 4:
                  return e.abrupt("return", e.sent.toArray());
                case 5:
                case "end":
                  return e.stop();
              }
            }
          }, e, this);
        }));
        return function () {
          return e.apply(this, arguments);
        };
      }()
    }, {
      key: "toArrayForTest",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.size !== Infinity) {
                  e.next = 2;
                  break;
                }
                throw new Error("Can not convert infinite data stream to array.");
              case 2:
                e.next = 4;
                return this.iterator();
              case 4:
                return e.abrupt("return", e.sent.toArrayForTest());
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return e;
  }();
  function Ame(e, t = null) {
    return new (function (n) {
      d(i, n);
      var r;
      var a = w(i);
      function i() {
        var e;
        l(this, i);
        (e = a.apply(this, arguments)).size = t;
        return e;
      }
      p(i, [{
        key: "iterator",
        value: (r = c(o().mark(function t() {
          return o().wrap(function (t) {
            while (true) {
              switch (t.prev = t.next) {
                case 0:
                  return t.abrupt("return", e());
                case 1:
                case "end":
                  return t.stop();
              }
            }
          }, t);
        })), function () {
          return r.apply(this, arguments);
        })
      }]);
      return i;
    }(Cme))();
  }
  function Rme(e) {
    if (e === null) {
      return null;
    } else if (tme(e[0])) {
      return {
        value: function (e) {
          if (e.length === 0) {
            throw new Error("Can't make a batch of zero elements.");
          }
          if (e[0] instanceof n5) {
            return Pte(e);
          } else {
            return V5(e);
          }
        }(e),
        recurse: false
      };
    } else {
      return {
        value: null,
        recurse: true
      };
    }
  }
  Cme.MAX_BUFFER_SIZE = 10000;
  var _me = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      l(this, r);
      (t = n.call(this)).input = e;
      return t;
    }
    p(r, [{
      key: "iterator",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.input.iterator();
              case 2:
                t = e.sent;
                n = t.decodeUTF8();
                r = n.split("\n").map(function (e) {
                  if (e.endsWith("\r")) {
                    e = e.slice(0, -1);
                  }
                  return e;
                });
                return e.abrupt("return", r);
              case 6:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(Cme);
  var Ome = "\"";
  var Fme = Symbol("out");
  var Dme = Symbol("field");
  var Mme = Symbol("quote");
  var Lme = Symbol("quoteafterquote");
  var zme = Symbol("quoteinquote");
  var Pme = function (e) {
    d(s, e);
    var t;
    var n;
    var r;
    var a;
    var i = w(s);
    function s(e, t) {
      var n;
      l(this, s);
      (n = i.call(this)).input = e;
      n.hasHeader = true;
      n.fullColumnNames = null;
      n.columnNamesValidated = false;
      n.columnConfigs = null;
      n.configuredColumnsOnly = false;
      n.delimiter = ",";
      n.delimWhitespace = false;
      n.base = new _me(e);
      t ||= {};
      n.hasHeader = t.hasHeader !== false;
      n.fullColumnNames = t.columnNames;
      n.columnConfigs = t.columnConfigs;
      n.configuredColumnsOnly = t.configuredColumnsOnly;
      if (t.delimWhitespace) {
        F$(t.delimiter == null, function () {
          return "Delimiter should not be provided when delimWhitespace is true.";
        });
        n.delimWhitespace = true;
        n.delimiter = " ";
      } else {
        n.delimiter = t.delimiter ? t.delimiter : ",";
      }
      return n;
    }
    p(s, [{
      key: "columnNames",
      value: (a = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.columnNamesValidated) {
                  e.next = 3;
                  break;
                }
                e.next = 3;
                return this.setColumnNames();
              case 3:
                return e.abrupt("return", this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames);
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "setColumnNames",
      value: (r = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        var s;
        var u = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.maybeReadHeaderLine();
              case 2:
                t = e.sent;
                if (this.fullColumnNames || t) {
                  e.next = 7;
                  break;
                }
                throw new Error("Column names must be provided if there is no header line.");
              case 7:
                if (this.fullColumnNames && t) {
                  F$(t.length === this.fullColumnNames.length, function () {
                    return "The length of provided columnNames (" + u.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t.length.toString() + ").";
                  });
                }
              case 8:
                this.fullColumnNames ||= t;
                n = this.fullColumnNames.reduce(function (e, t) {
                  e[t] = e[t] + 1 || 1;
                  return e;
                }, {});
                F$((r = Object.keys(n).filter(function (e) {
                  return n[e] > 1;
                })).length === 0, function () {
                  return "Duplicate column names found: " + r.toString();
                });
                if (!this.columnConfigs) {
                  e.next = 22;
                  break;
                }
                a = 0;
                i = Object.keys(this.columnConfigs);
              case 14:
                if (!(a < i.length)) {
                  e.next = 22;
                  break;
                }
                s = i[a];
                if (this.fullColumnNames.indexOf(s) !== -1) {
                  e.next = 19;
                  break;
                }
                throw new Error("The key \"" + s + "\" provided in columnConfigs does not match any of the column names (" + this.fullColumnNames.toString() + ").");
              case 19:
                a++;
                e.next = 14;
                break;
              case 22:
                this.columnNamesValidated = true;
              case 23:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return r.apply(this, arguments);
      })
    }, {
      key: "maybeReadHeaderLine",
      value: (n = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!this.hasHeader) {
                  e.next = 14;
                  break;
                }
                e.next = 3;
                return this.base.iterator();
              case 3:
                t = e.sent;
                e.next = 6;
                return t.next();
              case 6:
                if (!(n = e.sent).done) {
                  e.next = 9;
                  break;
                }
                throw new Error("No data was found for CSV parsing.");
              case 9:
                r = n.value;
                a = this.parseRow(r, false);
                return e.abrupt("return", a);
              case 14:
                return e.abrupt("return", null);
              case 15:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "iterator",
      value: (t = c(o().mark(function e() {
        var t;
        var n = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.columnNamesValidated) {
                  e.next = 3;
                  break;
                }
                e.next = 3;
                return this.setColumnNames();
              case 3:
                e.next = 5;
                return this.base.iterator();
              case 5:
                t = e.sent;
                if (this.hasHeader) {
                  t = t.skip(1);
                }
                return e.abrupt("return", t.map(function (e) {
                  return n.makeDataElement(e);
                }));
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }, {
      key: "makeDataElement",
      value: function (e) {
        var t = this.parseRow(e);
        var n = {};
        var r = {};
        for (var a = 0; a < this.fullColumnNames.length; a++) {
          var i = this.fullColumnNames[a];
          var o = this.columnConfigs ? this.columnConfigs[i] : null;
          if (!this.configuredColumnsOnly || o) {
            var s = t[a];
            var u = null;
            if (s === "") {
              if (o && o.default !== undefined) {
                u = o.default;
              } else {
                if (o && (o.required || o.isLabel)) {
                  throw new Error(`Required column ${i} is empty in this line: ${e}`);
                }
                u = undefined;
              }
            } else {
              var c = Number(s);
              if (isNaN(c)) {
                u = o && o.dtype === "bool" ? this.getBoolean(s) : s;
              } else if (o && o.dtype) {
                switch (o.dtype) {
                  case "float32":
                  default:
                    u = c;
                    break;
                  case "int32":
                    u = Math.floor(c);
                    break;
                  case "bool":
                    u = this.getBoolean(s);
                }
              } else {
                u = c;
              }
            }
            if (o && o.isLabel) {
              r[i] = u;
            } else {
              n[i] = u;
            }
          }
        }
        if (Object.keys(r).length === 0) {
          return n;
        } else {
          return {
            xs: n,
            ys: r
          };
        }
      }
    }, {
      key: "getBoolean",
      value: function (e) {
        if (e === "1" || e.toLowerCase() === "true") {
          return 1;
        } else {
          return 0;
        }
      }
    }, {
      key: "parseRow",
      value: function (e) {
        var t = !(arguments.length > 1) || arguments[1] === undefined || arguments[1];
        var n = [];
        var r = 0;
        for (var a = e.length, i = Fme, o = 0; o < a; o++) {
          switch (i) {
            case Fme:
              switch (e.charAt(o)) {
                case Ome:
                  r = o + 1;
                  i = Mme;
                  break;
                case this.delimiter:
                  r = o + 1;
                  if (this.delimiter === " " && this.delimWhitespace) {
                    break;
                  }
                  n.push("");
                  i = Fme;
                  break;
                default:
                  i = Dme;
                  r = o;
              }
              break;
            case Dme:
              if (e.charAt(o) === this.delimiter) {
                n.push(e.substring(r, o));
                i = Fme;
                r = o + 1;
              }
              break;
            case Mme:
              if (e.charAt(o) === Ome) {
                i = Lme;
              }
              break;
            case Lme:
              switch (e.charAt(o)) {
                case this.delimiter:
                  n.push(e.substring(r, o - 1));
                  i = Fme;
                  r = o + 1;
                  break;
                case Ome:
                  i = Mme;
                  break;
                default:
                  i = zme;
              }
              break;
            case zme:
              if (e.charAt(o) === Ome) {
                i = Mme;
              }
          }
        }
        if (i === Lme) {
          n.push(e.substring(r, a - 1));
        } else {
          n.push(e.substring(r));
        }
        if (t && n.length !== this.fullColumnNames.length) {
          throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);
        }
        return n;
      }
    }]);
    return s;
  }(Cme);
  var Bme = function (e) {
    d(u, e);
    var t;
    var n;
    var r;
    var a;
    var i;
    var s = w(u);
    function u(e) {
      var t;
      l(this, u);
      (t = s.call(this)).microphoneConfig = e;
      t.isClosed = false;
      t.fftSize = e.fftSize || 1024;
      var n = Math.log2(t.fftSize);
      if (t.fftSize < 0 || n < 4 || n > 14 || !Number.isInteger(n)) {
        throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${t.fftSize}`);
      }
      t.numFrames = e.numFramesPerSpectrogram || 43;
      t.sampleRateHz = e.sampleRateHz;
      t.columnTruncateLength = e.columnTruncateLength || t.fftSize;
      t.audioTrackConstraints = e.audioTrackConstraints;
      t.smoothingTimeConstant = e.smoothingTimeConstant || 0;
      t.includeSpectrogram = e.includeSpectrogram !== false;
      t.includeWaveform = e.includeWaveform === true;
      if (!t.includeSpectrogram && !t.includeWaveform) {
        throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
      }
      return t;
    }
    p(u, [{
      key: "summary",
      value: function () {
        return "microphone";
      }
    }, {
      key: "start",
      value: (i = c(o().mark(function e() {
        var t;
        var n;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.prev = 0;
                e.next = 3;
                return navigator.mediaDevices.getUserMedia({
                  audio: this.audioTrackConstraints == null || this.audioTrackConstraints,
                  video: false
                });
              case 3:
                this.stream = e.sent;
                e.next = 9;
                break;
              case 6:
                e.prev = 6;
                e.t0 = e.catch(0);
                throw new Error(`Error thrown while initializing video stream: ${e.t0.message}`);
              case 9:
                if (this.stream) {
                  e.next = 11;
                  break;
                }
                throw new Error("Could not obtain audio from microphone.");
              case 11:
                t = window.AudioContext || window.webkitAudioContext;
                this.audioContext = new t();
                if (this.sampleRateHz) {
                  e.next = 17;
                  break;
                }
                this.sampleRateHz = this.audioContext.sampleRate;
                e.next = 19;
                break;
              case 17:
                if (this.audioContext.sampleRate === this.sampleRateHz) {
                  e.next = 19;
                  break;
                }
                throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);
              case 19:
                n = this.audioContext.createMediaStreamSource(this.stream);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = this.fftSize * 2;
                this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;
                n.connect(this.analyser);
                this.freqData = new Float32Array(this.fftSize);
                this.timeData = new Float32Array(this.fftSize);
                return e.abrupt("return");
              case 27:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[0, 6]]);
      })), function () {
        return i.apply(this, arguments);
      })
    }, {
      key: "next",
      value: (a = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!this.isClosed) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 2:
                e.next = 4;
                return this.getAudioData();
              case 4:
                r = e.sent;
                if (this.includeSpectrogram) {
                  a = this.flattenQueue(r.freqDataQueue);
                  t = this.getTensorFromAudioDataArray(a, [this.numFrames, this.columnTruncateLength, 1]);
                }
                if (this.includeWaveform) {
                  i = this.flattenQueue(r.timeDataQueue);
                  n = this.getTensorFromAudioDataArray(i, [this.numFrames * this.fftSize, 1]);
                }
                return e.abrupt("return", {
                  value: {
                    spectrogram: t,
                    waveform: n
                  },
                  done: false
                });
              case 8:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "capture",
      value: (r = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.next();
              case 2:
                return e.abrupt("return", e.sent.value);
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return r.apply(this, arguments);
      })
    }, {
      key: "getAudioData",
      value: (n = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = [];
                n = [];
                r = 0;
                return e.abrupt("return", new Promise(function (e) {
                  var i = setInterval(function () {
                    if (a.includeSpectrogram) {
                      a.analyser.getFloatFrequencyData(a.freqData);
                      if (a.freqData[0] === -Infinity) {
                        e({
                          freqDataQueue: t,
                          timeDataQueue: n
                        });
                      }
                      t.push(a.freqData.slice(0, a.columnTruncateLength));
                    }
                    if (a.includeWaveform) {
                      a.analyser.getFloatTimeDomainData(a.timeData);
                      n.push(a.timeData.slice());
                    }
                    if (++r === a.numFrames) {
                      clearInterval(i);
                      e({
                        freqDataQueue: t,
                        timeDataQueue: n
                      });
                    }
                  }, a.fftSize / a.sampleRateHz * 1000);
                }));
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "stop",
      value: function () {
        if (!this.isClosed) {
          this.isClosed = true;
          this.analyser.disconnect();
          this.audioContext.close();
          if (this.stream != null && this.stream.getTracks().length > 0) {
            this.stream.getTracks()[0].stop();
          }
        }
      }
    }, {
      key: "toArray",
      value: function () {
        throw new Error("Can not convert infinite audio stream to array.");
      }
    }, {
      key: "getSampleRate",
      value: function () {
        return this.sampleRateHz;
      }
    }, {
      key: "flattenQueue",
      value: function (e) {
        var t = e[0].length;
        var n = new Float32Array(e.length * t);
        e.forEach(function (e, r) {
          return n.set(e, r * t);
        });
        return n;
      }
    }, {
      key: "getTensorFromAudioDataArray",
      value: function (e, t) {
        var n = new Float32Array(L$(t));
        n.set(e, n.length - e.length);
        return V5(n, t);
      }
    }], [{
      key: "create",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r = arguments;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = r.length > 0 && r[0] !== undefined ? r[0] : {};
                if (k0().get("IS_BROWSER")) {
                  e.next = 3;
                  break;
                }
                throw new Error("microphone API is only supported in browser environment.");
              case 3:
                n = new u(t);
                e.next = 6;
                return n.start();
              case 6:
                return e.abrupt("return", n);
              case 7:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return u;
  }(hme);
  var Wme = function (e) {
    d(s, e);
    var t;
    var n;
    var r;
    var a;
    var i = w(s);
    function s(e, t) {
      var n;
      l(this, s);
      (n = i.call(this)).webcamVideoElement = e;
      n.webcamConfig = t;
      n.isClosed = true;
      n.resize = false;
      if (n.needToResize()) {
        n.resize = true;
        n.cropSize = [n.webcamConfig.resizeHeight, n.webcamConfig.resizeWidth];
        n.cropBoxInd = Vte([0], "int32");
        if (n.webcamConfig.centerCrop) {
          var r = n.webcamConfig.resizeWidth * 1 / n.webcamVideoElement.width;
          var a = n.webcamConfig.resizeHeight * 1 / n.webcamVideoElement.height;
          var o = (1 - r) / 2;
          var u = (1 - a) / 2;
          var c = o + r;
          var h = a + u;
          n.cropBox = Gte([u, o, h, c], [1, 4]);
        } else {
          n.cropBox = Gte([0, 0, 1, 1], [1, 4]);
        }
      }
      return n;
    }
    p(s, [{
      key: "summary",
      value: function () {
        return "webcam";
      }
    }, {
      key: "start",
      value: (a = c(o().mark(function e() {
        var t = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (this.webcamConfig.facingMode) {
                  F$(this.webcamConfig.facingMode === "user" || this.webcamConfig.facingMode === "environment", function () {
                    return `Invalid webcam facing mode: ${t.webcamConfig.facingMode}. Please provide 'user' or 'environment'`;
                  });
                }
                e.prev = 1;
                e.next = 4;
                return navigator.mediaDevices.getUserMedia({
                  video: {
                    deviceId: this.webcamConfig.deviceId,
                    facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
                    width: this.webcamVideoElement.width,
                    height: this.webcamVideoElement.height
                  }
                });
              case 4:
                this.stream = e.sent;
                e.next = 11;
                break;
              case 7:
                e.prev = 7;
                e.t0 = e.catch(1);
                e.t0.message = `Error thrown while initializing video stream: ${e.t0.message}`;
                throw e.t0;
              case 11:
                if (this.stream) {
                  e.next = 13;
                  break;
                }
                throw new Error("Could not obtain video from webcam.");
              case 13:
                try {
                  this.webcamVideoElement.srcObject = this.stream;
                } catch (e) {
                  console.log(e);
                  this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
                }
                this.webcamVideoElement.play();
                this.isClosed = false;
                return e.abrupt("return", new Promise(function (e) {
                  t.webcamVideoElement.onloadedmetadata = function () {
                    e();
                  };
                }));
              case 17:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[1, 7]]);
      })), function () {
        return a.apply(this, arguments);
      })
    }, {
      key: "next",
      value: (r = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!this.isClosed) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 2:
                e.prev = 2;
                t = Fae(this.webcamVideoElement);
                e.next = 9;
                break;
              case 6:
                e.prev = 6;
                e.t0 = e.catch(2);
                throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e.t0)}`);
              case 9:
                if (!this.resize) {
                  e.next = 22;
                  break;
                }
                e.prev = 10;
                return e.abrupt("return", {
                  value: this.cropAndResizeFrame(t),
                  done: false
                });
              case 14:
                e.prev = 14;
                e.t1 = e.catch(10);
                throw new Error(`Error thrown cropping the video: ${e.t1.message}`);
              case 17:
                e.prev = 17;
                t.dispose();
                return e.finish(17);
              case 20:
                e.next = 23;
                break;
              case 22:
                return e.abrupt("return", {
                  value: t,
                  done: false
                });
              case 23:
              case "end":
                return e.stop();
            }
          }
        }, e, this, [[2, 6], [10, 14, 17, 20]]);
      })), function () {
        return r.apply(this, arguments);
      })
    }, {
      key: "needToResize",
      value: function () {
        return !!this.webcamConfig.resizeWidth && !!this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight);
      }
    }, {
      key: "cropAndResizeFrame",
      value: function (e) {
        var t = this;
        return X5(function () {
          var n;
          var r = f9(h8(e, "float32"), 0);
          var a = (n = Pre.cropAndResize(r, t.cropBox, t.cropBoxInd, t.cropSize, "bilinear")).shape;
          return X8(n, a.slice(1));
        });
      }
    }, {
      key: "capture",
      value: (n = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.next();
              case 2:
                return e.abrupt("return", e.sent.value);
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "stop",
      value: function () {
        this.stream.getTracks().forEach(function (e) {
          return e.stop();
        });
        try {
          this.webcamVideoElement.srcObject = null;
        } catch (e) {
          console.log(e);
          this.webcamVideoElement.src = null;
        }
        this.isClosed = true;
      }
    }, {
      key: "toArray",
      value: function () {
        throw new Error("Can not convert infinite video stream to array.");
      }
    }], [{
      key: "create",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        var a = arguments;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                n = a.length > 1 && a[1] !== undefined ? a[1] : {};
                if (k0().get("IS_BROWSER")) {
                  e.next = 3;
                  break;
                }
                throw new Error("tf.data.webcam is only supported in browser environment.");
              case 3:
                if (t) {
                  e.next = 9;
                  break;
                }
                t = document.createElement("video");
                if (n.resizeWidth && n.resizeHeight) {
                  e.next = 7;
                  break;
                }
                throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
              case 7:
                t.width = n.resizeWidth;
                t.height = n.resizeHeight;
              case 9:
                r = new s(t, n);
                e.next = 12;
                return r.start();
              case 12:
                return e.abrupt("return", r);
              case 13:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }]);
    return s;
  }(hme);
  var Ume = p(function e() {
    l(this, e);
  });
  var Vme = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "split",
      value: function (e) {
        return new Gme(this, e);
      }
    }]);
    return n;
  }(hme);
  var Gme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e, t) {
      var a;
      l(this, r);
      (a = n.call(this)).upstream = e;
      a.impl = new jme(e, t);
      return a;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return this.impl.summary();
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.impl.next());
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(Vme);
  var jme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e, t) {
      var a;
      l(this, r);
      (a = n.call(this)).upstream = e;
      a.separator = t;
      a.carryover = "";
      return a;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Split('${this.separator}')`;
      }
    }, {
      key: "pump",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.upstream.next();
              case 2:
                if (!(t = e.sent).done) {
                  e.next = 9;
                  break;
                }
                if (this.carryover !== "") {
                  e.next = 6;
                  break;
                }
                return e.abrupt("return", false);
              case 6:
                this.outputQueue.push(this.carryover);
                this.carryover = "";
                return e.abrupt("return", true);
              case 9:
                (n = t.value.split(this.separator))[0] = this.carryover + n[0];
                r = O(n.slice(0, -1));
                try {
                  for (r.s(); !(a = r.n()).done;) {
                    i = a.value;
                    this.outputQueue.push(i);
                  }
                } catch (e) {
                  r.e(e);
                } finally {
                  r.f();
                }
                this.carryover = n[n.length - 1];
                return e.abrupt("return", true);
              case 15:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(wme);
  var Hme = function (e) {
    d(n, e);
    var t = w(n);
    function n() {
      l(this, n);
      return t.apply(this, arguments);
    }
    p(n, [{
      key: "decodeUTF8",
      value: function () {
        return new qme(this);
      }
    }]);
    return n;
  }(hme);
  var qme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      l(this, r);
      (t = n.call(this)).upstream = e;
      t.impl = new Kme(e);
      return t;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return this.impl.summary();
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.impl.next());
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(Vme);
  var Kme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      l(this, r);
      (t = n.call(this)).upstream = e;
      if (k0().get("IS_BROWSER")) {
        t.decoder = new TextDecoder("utf-8");
      } else {
        var a = require("string_decoder").StringDecoder;
        t.decoder = new a("utf8");
      }
      return t;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `${this.upstream.summary()} -> Utf8`;
      }
    }, {
      key: "pump",
      value: (t = c(o().mark(function e() {
        var t;
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return this.upstream.next();
              case 2:
                if (!(t = e.sent).done) {
                  e.next = 7;
                  break;
                }
                return e.abrupt("return", false);
              case 7:
                n = t.value;
              case 8:
                r = k0().get("IS_BROWSER") ? this.decoder.decode(n, {
                  stream: true
                }) : this.decoder.write(Buffer.from(n.buffer));
                this.outputQueue.push(r);
                return e.abrupt("return", true);
              case 11:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(wme);
  var Xme = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      l(this, r);
      (t = n.call(this)).file = e;
      t.options = a;
      F$(e instanceof Uint8Array || !!k0().get("IS_BROWSER") && (e instanceof File || e instanceof Blob), function () {
        return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
      });
      t.offset = a.offset || 0;
      t.chunkSize = a.chunkSize || 1048576;
      return t;
    }
    p(r, [{
      key: "summary",
      value: function () {
        return `FileChunks ${this.file}`;
      }
    }, {
      key: "next",
      value: (t = c(o().mark(function e() {
        var t;
        var n = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size))) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", {
                  value: null,
                  done: true
                });
              case 2:
                t = new Promise(function (e, t) {
                  var r = n.offset + n.chunkSize;
                  if (n.file instanceof Uint8Array) {
                    e(new Uint8Array(n.file.slice(n.offset, r)));
                  } else {
                    var a = new FileReader();
                    a.onload = function (n) {
                      var r = a.result;
                      if (r instanceof ArrayBuffer) {
                        r = new Uint8Array(r);
                      }
                      if (!(r instanceof Uint8Array)) {
                        return t(new TypeError("FileReader returned unknown type."));
                      }
                      e(r);
                    };
                    a.onabort = function (e) {
                      return t(new Error("Aborted"));
                    };
                    a.onerror = function (e) {
                      return t(new Error(e.type));
                    };
                    var i = n.file.slice(n.offset, r);
                    a.readAsArrayBuffer(i);
                  }
                  n.offset = r;
                });
                e.next = 5;
                return t;
              case 5:
                e.t0 = e.sent;
                return e.abrupt("return", {
                  value: e.t0,
                  done: false
                });
              case 7:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(Hme);
  function Yme(e) {
    return Jme.apply(this, arguments);
  }
  function Jme() {
    Jme = c(o().mark(function e(t) {
      var n;
      var r;
      var a;
      var i;
      var s;
      var u;
      var c = arguments;
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              n = c.length > 1 && c[1] !== undefined ? c[1] : {};
              r = c.length > 2 ? c[2] : undefined;
              if (typeof t == "string") {
                a = t;
              } else {
                a = t.url;
                i = Zme(t);
              }
              e.next = 5;
              return (r || P4)(a, i);
            case 5:
              if (!(s = e.sent).ok) {
                e.next = 15;
                break;
              }
              e.t0 = Uint8Array;
              e.next = 10;
              return s.arrayBuffer();
            case 10:
              e.t1 = e.sent;
              u = new e.t0(e.t1);
              return e.abrupt("return", new Xme(u, n));
            case 15:
              throw new Error(s.statusText);
            case 16:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }));
    return Jme.apply(this, arguments);
  }
  function Zme(e) {
    return {
      method: e.method,
      headers: e.headers,
      body: e.body,
      mode: e.mode,
      credentials: e.credentials,
      cache: e.cache,
      redirect: e.redirect,
      referrer: e.referrer,
      integrity: e.integrity
    };
  }
  function Qme(e) {
    return typeof e == "string" && e.slice(0, 7) === "file://";
  }
  var $me = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      l(this, r);
      (t = n.call(this)).input = e;
      t.options = a;
      return t;
    }
    p(r, [{
      key: "iterator",
      value: (t = c(o().mark(function e() {
        var t;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (Qme(this.input) && k0().get("IS_NODE")) {
                  t = require("fs");
                  this.input = t.readFileSync(this.input.slice(7));
                }
                return e.abrupt("return", new Xme(this.input, this.options));
              case 2:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(Ume);
  var ege = function (e) {
    d(r, e);
    var t;
    var n = w(r);
    function r(e) {
      var t;
      var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      l(this, r);
      (t = n.call(this)).url = e;
      t.fileOptions = a;
      return t;
    }
    p(r, [{
      key: "iterator",
      value: (t = c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!Qme(this.url)) {
                  e.next = 4;
                  break;
                }
                return e.abrupt("return", new $me(this.url, this.fileOptions).iterator());
              case 4:
                return e.abrupt("return", Yme(this.url, this.fileOptions));
              case 5:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return t.apply(this, arguments);
      })
    }]);
    return r;
  }(Ume);
  function tge() {
    return (tge = c(o().mark(function e(t, n) {
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              return e.abrupt("return", Wme.create(t, n));
            case 1:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  function nge() {
    return (nge = c(o().mark(function e(t) {
      return o().wrap(function (e) {
        while (true) {
          switch (e.prev = e.next) {
            case 0:
              return e.abrupt("return", Bme.create(t));
            case 1:
            case "end":
              return e.stop();
          }
        }
      }, e);
    }))).apply(this, arguments);
  }
  var rge = "4.15.0";
  var age = {
    __proto__: null,
    CSVDataset: Pme,
    Dataset: Cme,
    FileDataSource: $me,
    TextLineDataset: _me,
    URLDataSource: ege,
    array: function (e) {
      return Ame(c(o().mark(function t() {
        return o().wrap(function (t) {
          while (true) {
            switch (t.prev = t.next) {
              case 0:
                return t.abrupt("return", ome(e));
              case 1:
              case "end":
                return t.stop();
            }
          }
        }, t);
      })), e.length);
    },
    csv: function (e, t = {}) {
      return new Pme(new ege(e), t);
    },
    func: function (e) {
      var t = sme(e);
      return Ame(c(o().mark(function e() {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", t);
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })));
    },
    generator: function (e) {
      return Ame(c(o().mark(function t() {
        var n;
        return o().wrap(function (t) {
          while (true) {
            switch (t.prev = t.next) {
              case 0:
                t.next = 2;
                return e();
              case 2:
                n = t.sent;
                return t.abrupt("return", sme(function () {
                  return n.next();
                }));
              case 4:
              case "end":
                return t.stop();
            }
          }
        }, t);
      })));
    },
    microphone: function (e) {
      return nge.apply(this, arguments);
    },
    version_data: rge,
    webcam: function (e, t) {
      return tge.apply(this, arguments);
    },
    zip: function (e) {
      if (!eme(e)) {
        throw new Error("The argument to zip() must be an object or array.");
      }
      var t;
      if (Array.isArray(e)) {
        for (var n = 0; n < e.length; n++) {
          t = t == null ? e[n].size : Math.min(t, e[n].size);
        }
      } else if (e instanceof Object) {
        for (var r in e) {
          t = t == null ? e[r].size : Math.min(t, e[r].size);
        }
      }
      return Ame(c(o().mark(function t() {
        var n;
        return o().wrap(function (t) {
          while (true) {
            switch (t.prev = t.next) {
              case 0:
                t.next = 2;
                return Qve(e, function (e) {
                  if (e instanceof Cme) {
                    return {
                      value: e.iterator(),
                      recurse: false
                    };
                  }
                  if (eme(e)) {
                    return {
                      value: null,
                      recurse: true
                    };
                  }
                  throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
                });
              case 2:
                n = t.sent;
                return t.abrupt("return", cme(n, lme.SHORTEST));
              case 4:
              case "end":
                return t.stop();
            }
          }
        }, t);
      })), t);
    }
  };
  function ige(e, t) {
    if (!Array.isArray(e)) {
      e = [e];
    }
    e.forEach(function (e) {
      if (e != null) {
        F$(e.dtype !== "complex64", function () {
          return `${t} does not support complex64 tensors in the CPU backend.`;
        });
      }
    });
  }
  var oge = one;
  var sge = function (e) {
    d(a, e);
    var t;
    var n;
    var r = w(a);
    function a() {
      var e;
      l(this, a);
      (e = r.call(this)).blockSize = 48;
      e.firstUse = true;
      e.data = new S$(x(e), q5());
      return e;
    }
    p(a, [{
      key: "nextDataId",
      value: function () {
        return a.nextDataId++;
      }
    }, {
      key: "write",
      value: function (e, t, n) {
        if (this.firstUse) {
          this.firstUse = false;
          if (k0().get("IS_NODE")) {
            z3("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================");
          }
        }
        var r = {
          id: this.nextDataId()
        };
        this.data.set(r, {
          values: e,
          dtype: n,
          refCount: 1
        });
        return r;
      }
    }, {
      key: "makeTensorInfo",
      value: function (e, t, n) {
        var r;
        if (t === "string" && n != null && n.length > 0 && $$(n[0])) {
          var a = n.map(function (e) {
            return B4(e);
          });
          r = this.write(a, e, t);
        } else {
          r = this.write(n, e, t);
        }
        return {
          dataId: r,
          shape: e,
          dtype: t
        };
      }
    }, {
      key: "refCount",
      value: function (e) {
        if (this.data.has(e)) {
          return this.data.get(e).refCount;
        } else {
          return 0;
        }
      }
    }, {
      key: "incRef",
      value: function (e) {
        this.data.get(e).refCount++;
      }
    }, {
      key: "decRef",
      value: function (e) {
        if (this.data.has(e)) {
          this.data.get(e).refCount--;
        }
      }
    }, {
      key: "move",
      value: function (e, t, n, r, a) {
        this.data.set(e, {
          values: t,
          dtype: r,
          refCount: a
        });
      }
    }, {
      key: "numDataIds",
      value: function () {
        return this.data.numDataIds();
      }
    }, {
      key: "read",
      value: (n = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                return e.abrupt("return", this.readSync(t));
              case 1:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return n.apply(this, arguments);
      })
    }, {
      key: "readSync",
      value: function (e) {
        var t = this.data.get(e);
        var n = t.dtype;
        var r = t.complexTensorInfos;
        if (n === "complex64") {
          return Tie(this.readSync(r.real.dataId), this.readSync(r.imag.dataId));
        } else {
          return u0(this.data.get(e).values, n);
        }
      }
    }, {
      key: "bufferSync",
      value: function (e) {
        var t = this.readSync(e.dataId);
        if (e.dtype === "string") {
          try {
            var n = t.map(function (e) {
              return W4(e);
            });
            return l8(e.shape, e.dtype, n);
          } catch (e) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
          }
        }
        return l8(e.shape, e.dtype, t);
      }
    }, {
      key: "makeOutput",
      value: function (e, t, n) {
        return q5().makeTensorFromTensorInfo(this.makeTensorInfo(t, n, e), this);
      }
    }, {
      key: "disposeData",
      value: function (e, t = false) {
        if (this.data.has(e)) {
          this.data.get(e).refCount--;
          if (!t && this.data.get(e).refCount > 0) {
            return false;
          }
          var n = this.data.get(e);
          var r = n.complexTensorInfos;
          if (r != null) {
            this.disposeData(r.real.dataId, true);
            this.disposeData(r.imag.dataId, true);
          }
          this.data.delete(e);
        }
        return true;
      }
    }, {
      key: "disposeIntermediateTensorInfo",
      value: function (e) {
        this.disposeData(e.dataId);
      }
    }, {
      key: "time",
      value: (t = c(o().mark(function e(t) {
        var n;
        var r;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                n = z4();
                t();
                r = z4() - n;
                return e.abrupt("return", {
                  kernelMs: r
                });
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "memory",
      value: function () {
        return {
          unreliable: true,
          reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
        };
      }
    }, {
      key: "where",
      value: function (e) {
        ige([e], "where");
        var t = this.readSync(e.dataId);
        return oge(e.shape, t);
      }
    }, {
      key: "dispose",
      value: function () {}
    }, {
      key: "floatPrecision",
      value: function () {
        return 32;
      }
    }, {
      key: "epsilon",
      value: function () {
        return N(v(a.prototype), "epsilon", this).call(this);
      }
    }]);
    return a;
  }(T$);
  function uge(e) {
    var t = new Float32Array(e.length);
    for (var n = 0; n < e.length; ++n) {
      t[n] = Math.abs(e[n]);
    }
    return t;
  }
  sge.nextDataId = 0;
  var cge = {
    kernelName: N0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs.x;
      var n = e.backend;
      ige(t, "abs");
      var r = new Float32Array(L$(t.shape));
      r = uge(n.data.get(t.dataId).values);
      return n.makeOutput(r, t.shape, t.dtype);
    }
  };
  function lge(e) {
    return function (t, n, r, a, i) {
      var o = z7(t, n);
      var s = o.length;
      var u = i0(o);
      var c = q$(i, L$(o));
      var l = t.length;
      var h = n.length;
      var p = i0(t);
      var f = i0(n);
      var d = M7(t, o);
      var v = M7(n, o);
      if (d.length + v.length === 0) {
        for (var m = 0; m < c.length; ++m) {
          c[m] = e(r[m % r.length], a[m % a.length]);
        }
      } else {
        var g = function () {
          var t = d0(y, s, u);
          var n = t.slice(-l);
          d.forEach(function (e) {
            return n[e] = 0;
          });
          var i = f0(n, l, p);
          var o = t.slice(-h);
          v.forEach(function (e) {
            return o[e] = 0;
          });
          var m = f0(o, h, f);
          c[y] = e(r[i], a[m]);
        };
        for (var y = 0; y < c.length; ++y) {
          g();
        }
      }
      return [c, o];
    };
  }
  function hge(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.real;
    var a = t.imag;
    var i = n.data.get(r.dataId).values;
    var o = n.data.get(a.dataId).values;
    var s = n.makeTensorInfo(r.shape, "complex64");
    n.data.get(s.dataId).complexTensorInfos = {
      real: n.makeTensorInfo(r.shape, "float32", i),
      imag: n.makeTensorInfo(a.shape, "float32", o)
    };
    return s;
  }
  var pge = {
    kernelName: Z0,
    backendName: "cpu",
    kernelFunc: hge
  };
  function fge(e, t, n = "float32") {
    if (n === "complex64") {
      var r = fge(e, t, "float32");
      var a = fge(e, t, "float32");
      return hge({
        inputs: {
          real: r,
          imag: a
        },
        backend: e
      });
    }
    var i = l0(L$(t), n);
    return e.makeTensorInfo(t, n, i);
  }
  function dge(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.x;
    n.incRef(r.dataId);
    return {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  var vge = {
    kernelName: W1,
    backendName: "cpu",
    kernelFunc: dge
  };
  function mge(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.input;
    var a = n.data.get(r.dataId).complexTensorInfos.real;
    var i = n.data.get(a.dataId).values;
    return n.makeTensorInfo(a.shape, a.dtype, i);
  }
  var gge = {
    kernelName: D2,
    backendName: "cpu",
    kernelFunc: mge
  };
  function yge(e, t, n, r) {
    if (r === "int32") {
      return [t, "int32", Int32Array.from(e)];
    }
    if (r === "bool") {
      var a = L4([0], n);
      var i = S(lge(function (e, t) {
        if (e !== t) {
          return 1;
        } else {
          return 0;
        }
      })(t, [], e, a, "bool"), 2);
      var o = i[0];
      return [i[1], "bool", o];
    }
    throw new Error(`Error in Cast: failed to cast ${n} to ${r}`);
  }
  function bge(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.dtype;
    if (i === "complex64") {
      if (a.dtype === "complex64") {
        return dge({
          inputs: {
            x: a
          },
          backend: n
        });
      }
      var o = fge(n, a.shape, a.dtype);
      var s = bge({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          dtype: "float32"
        }
      });
      var u = hge({
        inputs: {
          real: s,
          imag: o
        },
        backend: n
      });
      n.disposeIntermediateTensorInfo(o);
      n.disposeIntermediateTensorInfo(s);
      return u;
    }
    if (a.dtype === "complex64") {
      var c = mge({
        inputs: {
          input: a
        },
        backend: n
      });
      var l = bge({
        inputs: {
          x: c
        },
        backend: n,
        attrs: {
          dtype: i
        }
      });
      n.disposeIntermediateTensorInfo(c);
      return l;
    }
    if (!J$(a.dtype, i)) {
      var h = dge({
        inputs: {
          x: a
        },
        backend: n
      });
      return {
        dataId: h.dataId,
        shape: h.shape,
        dtype: i
      };
    }
    var p = S(yge(n.data.get(a.dataId).values, a.shape, a.dtype, i), 3);
    var f = p[0];
    var d = p[1];
    var v = p[2];
    return n.makeTensorInfo(f, d, v);
  }
  var xge = {
    kernelName: X0,
    backendName: "cpu",
    kernelFunc: bge
  };
  function kge(e, t, n, r) {
    if (n == null) {
      return function (n) {
        var a = n.inputs;
        var i = n.backend;
        var o = a.a;
        var s = a.b;
        var u = i;
        ige([o, s], e);
        var c = u.data.get(o.dataId).values;
        var l = u.data.get(s.dataId).values;
        var h = o.dtype === "string" ? aoe(c) : c;
        var p = o.dtype === "string" ? aoe(l) : l;
        var f = r || o.dtype;
        var d = S(t(o.shape, s.shape, h, p, f), 2);
        var v = d[0];
        var m = d[1];
        return u.makeTensorInfo(m, f, v);
      };
    } else {
      return function (e) {
        var a = e.inputs;
        var i = e.backend;
        var o = a.a;
        var s = a.b;
        var u = i;
        if (o.dtype === "complex64" || s.dtype === "complex64") {
          var c = bge({
            inputs: {
              x: o
            },
            backend: u,
            attrs: {
              dtype: "complex64"
            }
          });
          var l = u.data.get(c.dataId);
          var h = l.complexTensorInfos.real;
          var p = l.complexTensorInfos.imag;
          var f = u.data.get(h.dataId).values;
          var d = u.data.get(p.dataId).values;
          var v = bge({
            inputs: {
              x: s
            },
            backend: u,
            attrs: {
              dtype: "complex64"
            }
          });
          var m = u.data.get(v.dataId);
          var g = m.complexTensorInfos.real;
          var y = m.complexTensorInfos.imag;
          var b = u.data.get(g.dataId).values;
          var x = u.data.get(y.dataId).values;
          var k = S(n(o.shape, s.shape, f, d, b, x), 3);
          var w = k[0];
          var I = k[1];
          var N = k[2];
          var T = u.makeTensorInfo(N, "float32", w);
          var E = u.makeTensorInfo(N, "float32", I);
          var C = hge({
            inputs: {
              real: T,
              imag: E
            },
            backend: u
          });
          u.disposeIntermediateTensorInfo(c);
          u.disposeIntermediateTensorInfo(v);
          u.disposeIntermediateTensorInfo(T);
          u.disposeIntermediateTensorInfo(E);
          return C;
        }
        var A = u.data.get(o.dataId).values;
        var R = u.data.get(s.dataId).values;
        var _ = r || o.dtype;
        var O = S(t(o.shape, s.shape, A, R, _), 2);
        var F = O[0];
        var D = O[1];
        return u.makeTensorInfo(D, _, F);
      };
    }
  }
  function wge(e) {
    return function (t, n, r, a, i, o) {
      var s = z7(t, n);
      var u = L$(s);
      var c = s.length;
      var l = i0(s);
      var h = q$("float32", u);
      var p = q$("float32", u);
      var f = M7(t, s);
      var d = M7(n, s);
      var v = Tie(r, a);
      var m = Tie(i, o);
      var g = t.length;
      var y = i0(t);
      var b = n.length;
      var x = i0(n);
      if (f.length + d.length === 0) {
        for (var k = 0; k < h.length; k++) {
          var w = k % v.length;
          var I = k % m.length;
          var N = e(v[w * 2], v[w * 2 + 1], m[I * 2], m[I * 2 + 1]);
          h[k] = N.real;
          p[k] = N.imag;
        }
      } else {
        var S = function () {
          var t = d0(T, c, l);
          var n = t.slice(-g);
          f.forEach(function (e) {
            return n[e] = 0;
          });
          var r = f0(n, g, y);
          var a = t.slice(-b);
          d.forEach(function (e) {
            return a[e] = 0;
          });
          var i = f0(a, b, x);
          var o = e(v[r * 2], v[r * 2 + 1], m[i * 2], m[i * 2 + 1]);
          h[T] = o.real;
          p[T] = o.imag;
        };
        for (var T = 0; T < h.length; T++) {
          S();
        }
      }
      return [h, p, s];
    };
  }
  var Ige = lge(function (e, t) {
    return e + t;
  });
  var Nge = wge(function (e, t, n, r) {
    return {
      real: e + n,
      imag: t + r
    };
  });
  var Sge = kge(E0, Ige, Nge);
  var Tge = {
    kernelName: E0,
    backendName: "cpu",
    kernelFunc: Sge
  };
  function Ege(e, t, n, r, a) {
    var i = L$(r);
    var o = l0(a, n);
    for (var s = 0; s < e.length; s++) {
      var u = e[s];
      if (u < 0) {
        throw new Error("Input x must be non-negative!");
      }
      if (!(u >= a)) {
        o[u] += i > 0 ? t[s] : 1;
      }
    }
    return o;
  }
  function Cge(e, t, n, r = false) {
    for (var a = e.shape[0], i = e.shape[1], o = l8([a, n], t.dtype), s = 0; s < a; s++) {
      for (var u = 0; u < i; u++) {
        var c = e.get(s, u);
        if (c < 0) {
          throw new Error("Input x must be non-negative!");
        }
        if (!(c >= n)) {
          if (r) {
            o.set(1, s, c);
          } else if (t.size > 0) {
            o.set(o.get(s, c) + t.get(s, u), s, c);
          } else {
            o.set(o.get(s, c) + 1, s, c);
          }
        }
      }
    }
    return o;
  }
  var Age = lge(function (e, t) {
    return e & t;
  });
  var Rge = kge(H0, Age);
  var _ge = {
    kernelName: H0,
    backendName: "cpu",
    kernelFunc: Rge
  };
  function Oge(e) {
    return function (t, n, r) {
      var a = K$(n, t.length);
      for (var i = 0; i < t.length; ++i) {
        a[i] = e(t[i], r);
      }
      return a;
    };
  }
  function Fge(e, t, n) {
    return Dge(e, Oge(t), n);
  }
  function Dge(e, t, n) {
    return function (r) {
      var a = r.inputs;
      var i = r.attrs;
      var o = r.backend;
      var s = a.x;
      ige(s, e);
      var u;
      var c = o;
      var l = c.data.get(s.dataId).values;
      if (s.dtype === "string") {
        if (!Array.isArray(l)) {
          throw new Error("String tensor's value was not an instance of Array");
        }
        u = aoe(l);
      } else {
        u = l;
      }
      var h = n || s.dtype;
      var p = t(u, h, i);
      return c.makeTensorInfo(s.shape, h, p);
    };
  }
  var Mge = Oge(function (e) {
    return Math.ceil(e);
  });
  var Lge = Dge(Y0, Mge);
  var zge = {
    kernelName: Y0,
    backendName: "cpu",
    kernelFunc: Lge
  };
  function Pge(e, t, n, r) {
    var a = K$(n, L$(t));
    if (r && n !== "string") {
      var i = 0;
      e.forEach(function (e) {
        var t = L$(e.shape);
        a.set(e.vals, i);
        i += t;
      });
    } else {
      var o = 0;
      e.forEach(function (e) {
        var r = n === "string" ? aoe(e.vals) : e.vals;
        var i = 0;
        for (var s = 0; s < e.shape[0]; ++s) {
          var u = s * t[1] + o;
          for (var c = 0; c < e.shape[1]; ++c) {
            a[u + c] = r[i++];
          }
        }
        o += e.shape[1];
      });
    }
    return a;
  }
  var Bge = lge(function (e, t) {
    if (e === t) {
      return 1;
    } else {
      return 0;
    }
  });
  var Wge = kge(T1, Bge, null, "bool");
  var Uge = {
    kernelName: T1,
    backendName: "cpu",
    kernelFunc: Wge
  };
  var Vge = Oge(function (e) {
    return Math.exp(e);
  });
  var Gge = Dge(E1, Vge, "float32");
  var jge = {
    kernelName: E1,
    backendName: "cpu",
    kernelFunc: Gge
  };
  var Hge = Oge(function (e) {
    return Math.expm1(e);
  });
  var qge = Dge(A1, Hge);
  var Kge = {
    kernelName: A1,
    backendName: "cpu",
    kernelFunc: qge
  };
  var Xge = Oge(function (e) {
    return Math.floor(e);
  });
  var Yge = Dge(F1, Xge);
  var Jge = {
    kernelName: F1,
    backendName: "cpu",
    kernelFunc: Yge
  };
  var Zge = lge(function (e, t) {
    return Math.floor(e / t);
  });
  var Qge = kge(D1, Zge, null, "int32");
  var $ge = {
    kernelName: D1,
    backendName: "cpu",
    kernelFunc: Qge
  };
  function eye(e, t, n, r, a, i, o, s, u) {
    var c = l8([r, i], n);
    for (var l = 0; l < r; l++) {
      var h = [];
      var p = 0;
      for (var f = 0; f < a; f++) {
        var d = e[l * a + f];
        p += d * o[f];
        h.push(d);
      }
      if (p < 0 || p >= u / i) {
        throw new Error(`Invalid indices: ${h} does not index into ${s}`);
      }
      for (var v = 0; v < i; v++) {
        c.values[l * i + v] = t.get.apply(t, T(t.indexToLoc(p * i + v)));
      }
    }
    return c;
  }
  function tye(e, t, n) {
    for (var r = l8(n, e.dtype), a = 0; a < r.size; ++a) {
      var i = r.indexToLoc(a).slice();
      var o = i[0];
      var s = i[2];
      var u = t.locToIndex([o, s]);
      i[2] = t.values[u];
      var c = e.locToIndex(i);
      if (c >= 0 && c < e.values.length) {
        r.values[a] = e.values[c];
      }
    }
    return r;
  }
  var nye = lge(function (e, t) {
    if (e > t) {
      return 1;
    } else {
      return 0;
    }
  });
  var rye = kge(P1, nye, null, "bool");
  var aye = {
    kernelName: P1,
    backendName: "cpu",
    kernelFunc: rye
  };
  var iye = lge(function (e, t) {
    if (e >= t) {
      return 1;
    } else {
      return 0;
    }
  });
  var oye = kge(B1, iye, null, "bool");
  var sye = {
    kernelName: B1,
    backendName: "cpu",
    kernelFunc: oye
  };
  var uye = lge(function (e, t) {
    if (e < t) {
      return 1;
    } else {
      return 0;
    }
  });
  var cye = kge(K1, uye, null, "bool");
  var lye = {
    kernelName: K1,
    backendName: "cpu",
    kernelFunc: cye
  };
  var hye = lge(function (e, t) {
    if (e <= t) {
      return 1;
    } else {
      return 0;
    }
  });
  var pye = kge(X1, hye, null, "bool");
  var fye = {
    kernelName: X1,
    backendName: "cpu",
    kernelFunc: pye
  };
  function dye(e, t, n) {
    var r = (t - e) / (n - 1);
    var a = l0(n, "float32");
    a[0] = e;
    for (var i = 1; i < a.length; i++) {
      a[i] = a[i - 1] + r;
    }
    return a;
  }
  var vye = Oge(function (e) {
    return Math.log(e);
  });
  var mye = Dge(J1, vye);
  var gye = {
    kernelName: J1,
    backendName: "cpu",
    kernelFunc: mye
  };
  function yye(e, t, n, r) {
    for (var a = q$(r, L$(n)), i = 0; i < a.length; ++i) {
      var o = i * t;
      var s = e[o];
      for (var u = 0; u < t; ++u) {
        var c = e[o + u];
        if (Number.isNaN(c) || c > s) {
          s = c;
        }
      }
      a[i] = s;
    }
    return a;
  }
  var bye = lge(function (e, t) {
    return Math.max(e, t);
  });
  var xye = kge(i2, bye);
  var kye = {
    kernelName: i2,
    backendName: "cpu",
    kernelFunc: xye
  };
  var wye = lge(function (e, t) {
    return Math.min(e, t);
  });
  var Iye = kge(f2, wye);
  var Nye = {
    kernelName: f2,
    backendName: "cpu",
    kernelFunc: Iye
  };
  var Sye = lge(function (e, t) {
    return e * t;
  });
  var Tye = wge(function (e, t, n, r) {
    return {
      real: e * n - t * r,
      imag: e * r + t * n
    };
  });
  var Eye = kge(g2, Sye, Tye);
  var Cye = {
    kernelName: g2,
    backendName: "cpu",
    kernelFunc: Eye
  };
  function Aye(e, t, n) {
    var r = M4(-1, n);
    return Sye([], t, r, e, n);
  }
  var Rye = {
    kernelName: y2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.x;
      ige(r, "neg");
      var a = S(Aye(n.data.get(r.dataId).values, r.shape, r.dtype), 2);
      var i = a[0];
      var o = a[1];
      return n.makeTensorInfo(o, r.dtype, i);
    }
  };
  var _ye = lge(function (e, t) {
    if (e !== t) {
      return 1;
    } else {
      return 0;
    }
  });
  var Oye = kge(b2, _ye, null, "bool");
  var Fye = {
    kernelName: b2,
    backendName: "cpu",
    kernelFunc: Oye
  };
  function Dye(e, t, n, r, a) {
    var i = t.length;
    for (var o = L$(t), s = i0(t), u = i0(a), c = q$(n, L$(a)), l = 0; l < o; ++l) {
      var h = d0(l, i, s);
      for (var p = new Array(h.length), f = 0; f < p.length; f++) {
        p[f] = h[r[f]];
      }
      c[f0(p, i, u)] = e[l];
    }
    return c;
  }
  function Mye(e) {
    var t = e.inputs;
    var n = e.attrs;
    var r = e.backend;
    var a = t.x;
    var i = n.perm;
    ige(a, "transpose");
    var o = a.shape.length;
    for (var s = new Array(o), u = 0; u < s.length; u++) {
      s[u] = a.shape[i[u]];
    }
    var c = Dye(r.data.get(a.dataId).values, a.shape, a.dtype, i, s);
    return {
      dataId: r.write(c, s, a.dtype),
      shape: s,
      dtype: a.dtype
    };
  }
  var Lye = {
    kernelName: T3,
    backendName: "cpu",
    kernelFunc: Mye
  };
  function zye(e, t, n, r) {
    var a = S(J7(e, r), 2);
    var i = a[0];
    var o = a[1];
    var s = h5(t, "int32");
    for (var u = l0(L$(i), s), c = L$(o), l = 0; l < u.length; ++l) {
      var h = l * c;
      var p = 1;
      for (var f = 0; f < c; ++f) {
        p *= n[h + f];
      }
      u[l] = p;
    }
    return {
      outVals: u,
      outShape: i,
      outDtype: s
    };
  }
  var Pye = {
    kernelName: A2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      ige(a, "prod");
      var s = a.shape.length;
      var u = j$(i, a.shape);
      var c = $7(u, s);
      var l = u;
      var h = a;
      var p = [];
      if (c != null) {
        h = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: c
          }
        });
        p.push(h);
        l = t9(l.length, s);
      }
      var f = n.data.get(h.dataId).values;
      var d = zye(h.shape, h.dtype, f, l);
      var v = d.outVals;
      var m = d.outShape;
      var g = d.outDtype;
      var y = m;
      if (o) {
        y = Z7(m, u);
      }
      p.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return n.makeTensorInfo(y, g, v);
    }
  };
  function Bye(e, t, n, r) {
    var a = [];
    var i = 0;
    var o = t.length - 1 + n.length;
    var s = new Array(o).fill(null).map(function () {
      return [0];
    });
    (function (e, t) {
      for (var n = 0; n < e.length; ++n) {
        var r = e[n];
        var a = n === e.length - 1 ? t : e[n + 1].length;
        if (r.length === 0) {
          throw new Error("Ragged splits may not be empty");
        }
        if (r[0] < 0) {
          throw new Error("Ragged splits must be non-negative");
        }
        if (r[r.length - 1] > a) {
          throw new Error("Ragged splits must not point past values");
        }
        for (var i = 1; i < r.length; ++i) {
          if (r[i - 1] > r[i]) {
            throw new Error("Ragged splits must be sorted in ascending order");
          }
        }
      }
    })(n, r);
    var u = 1;
    for (var c = 0; c < t.length - 1; ++c) {
      u *= t[c];
      var l = t[c + 1];
      for (var h = 1; h < u + 1; ++h) {
        s[c].push(h * l);
      }
    }
    for (var p = 0; p < e.length; ++p) {
      var f = e[p];
      var d = e[p] + 1;
      for (var v = 0; v < n.length; ++v) {
        var m = n[v];
        var g = v + t.length - 1;
        if (g >= 0) {
          var y = s[g];
          var b = y[y.length - 1] - m[f];
          for (var x = f; x < d; ++x) {
            s[g].push(m[x + 1] + b);
          }
        }
        f = m[f];
        d = m[d];
      }
      if (d !== f) {
        a.push([f, d]);
        i += d - f;
      }
    }
    return {
      outSplits: s,
      valueSlices: a,
      numValues: i
    };
  }
  function Wye(e, t) {
    for (var n = e.slice(0, t); n.length < t;) {
      n.push(1);
    }
    for (var r = t; r < e.length; r++) {
      n[t - 1] *= e[r];
    }
    return n;
  }
  function Uye(e, t, n, r, a) {
    var i = t.slice();
    i[0] = a;
    var o = K$(n, L$(i));
    var s = e.length;
    (function (e, t, n, r, a, i) {
      var o;
      var s = Wye(t, 2)[1];
      var u = Wye(i, 2)[1];
      var c = 0;
      var l = O(n);
      try {
        for (l.s(); !(o = l.n()).done;) {
          for (var h = o.value, p = h[0]; p < h[1]; ++p) {
            for (var f = 0; f < r; ++f) {
              a[c * u + f] = e[p * s + f];
            }
            ++c;
          }
        }
      } catch (e) {
        l.e(e);
      } finally {
        l.f();
      }
    })(e, t, r, s === 0 ? 0 : s / t[0], o, i);
    return [o, i];
  }
  function Vye(e, t, n, r, a, i, o, s) {
    if (e.length === 0) {
      throw new Error("paramsNestedSplits must be non empty");
    }
    if (t[0].length === 0) {
      throw new Error("Split tensors must not be scalars");
    }
    (function (e, t, n) {
      e.forEach(function (e, r) {
        if (e < 0 || e >= n) {
          var a = d0(r, t.length, i0(t)).join(",");
          throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`);
        }
      });
    })(i, o, t[0][0] - 1);
    if (r.length === 0) {
      throw new Error("params.rank must be nonzero");
    }
    var u = Bye(i, o, e, r[0]);
    var c = u.outSplits;
    var l = u.valueSlices;
    var h = u.numValues;
    var p = function (e) {
      var t = [];
      var n = function () {
        var n = K$("int32", e[r].length);
        t.push(n);
        e[r].forEach(function (e, t) {
          return n[t] = e;
        });
      };
      for (var r = 0; r < e.length; ++r) {
        n();
      }
      return t;
    }(c);
    var f = Uye(n, r, a, l, h);
    return [p, f[0], f[1]];
  }
  var Gye = 2147483647;
  function jye(e, t, n, r, a, i, o) {
    if (t.length > 1) {
      throw new Error("starts must be a scalar or vector");
    }
    if (a.length > 1) {
      throw new Error("limits must be a scalar or vector");
    }
    if (o.length > 1) {
      throw new Error("deltas must be a scalar or vector");
    }
    var s = t.length === 0;
    var u = a.length === 0;
    var c = o.length === 0;
    var l = [];
    if (!s) {
      l.push(t[0]);
    }
    if (!u) {
      l.push(a[0]);
    }
    if (!c) {
      l.push(o[0]);
    }
    for (var h = 1; h < l.length; ++h) {
      if (l[h] !== l[h - 1]) {
        throw new Error("starts, limits, and deltas must have the same shape");
      }
    }
    var p = l.length === 0 ? 1 : l[0];
    var f = K$("int32", p + 1);
    f[0] = 0;
    for (var d = 0; d < p; ++d) {
      var v = s ? e[0] : e[d];
      var m = u ? r[0] : r[d];
      var g = c ? i[0] : i[d];
      if (g === 0) {
        throw new Error("Requires delta != 0");
      }
      var y = undefined;
      if (g > 0 && m < v || g < 0 && m > v) {
        y = 0;
      } else if ((y = Math.ceil(Math.abs((m - v) / g))) > Gye) {
        throw new Error(`Requires ((limit - start) / delta) <= ${Gye}`);
      }
      f[d + 1] = f[d] + y;
    }
    var b = K$(n, f[p]);
    var x = 0;
    for (var k = 0; k < p; ++k) {
      for (var w = f[k + 1] - f[k], I = s ? e[0] : e[k], N = c ? i[0] : i[k], S = 0; S < w; ++S) {
        b[x++] = I;
        I += N;
      }
    }
    return [f, b];
  }
  var Hye = Qae;
  var qye = function () {
    function e(t, n, r, a, i, o, s, u, c, h) {
      l(this, e);
      this.shape = t;
      this.shapeShape = n;
      this.values = r;
      this.valuesShape = a;
      this.valuesDType = i;
      this.defaultValue = o;
      this.defaultValueShape = s;
      this.rowPartitionValues = u;
      this.rowPartitionValuesShapes = c;
      this.rowPartitionTypes = uie(h);
      this.raggedRank = cie(this.rowPartitionTypes);
    }
    p(e, [{
      key: "getRowPartitionTypeByDimension",
      value: function (e) {
        if (this.rowPartitionTypes[0] === Hye.FIRST_DIM_SIZE) {
          return this.rowPartitionTypes[e + 1];
        } else {
          return this.rowPartitionTypes[e];
        }
      }
    }, {
      key: "getRowPartitionTensor",
      value: function (e) {
        if (this.rowPartitionTypes[0] === Hye.FIRST_DIM_SIZE) {
          return this.rowPartitionValues[e + 1];
        } else {
          return this.rowPartitionValues[e];
        }
      }
    }, {
      key: "getMaxWidth",
      value: function (t) {
        var n = this.getRowPartitionTensor(t - 1);
        switch (this.getRowPartitionTypeByDimension(t - 1)) {
          case Hye.VALUE_ROWIDS:
            return e.getMaxWidthValueRowID(n);
          case Hye.ROW_SPLITS:
            return e.getMaxWidthRowSplit(n);
          default:
            throw new Error(`Cannot handle partition type ${Hye[this.getRowPartitionTypeByDimension(t - 1)]}`);
        }
      }
    }, {
      key: "tensorShapeFromTensor",
      value: function (e, t) {
        var n = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
        if (t.length === 0) {
          if (e[0] === -1) {
            return [];
          }
          throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
        }
        return Xye(e, n);
      }
    }, {
      key: "calculateOutputSize",
      value: function (e) {
        var t = this.valuesShape;
        lie(this.defaultValueShape, t);
        var n = this.tensorShapeFromTensor(this.shape, this.shapeShape);
        var r = sie(this.raggedRank, n, t);
        if (r[0] < 0) {
          r[0] = e;
        }
        for (var a = 1; a <= this.raggedRank; ++a) {
          if (r[a] < 0) {
            r[a] = this.getMaxWidth(a);
          }
        }
        return r;
      }
    }, {
      key: "calculateFirstParentOutputIndex",
      value: function (e, t, n) {
        for (var r = Math.min(e, n), a = [], i = 0, o = 0; o < r; ++o, i += t) {
          a.push(i);
        }
        for (var s = r; s < e; ++s) {
          a.push(-1);
        }
        F$(a.length === e, function () {
          return "Final length of result must be equal to firstDimension.";
        });
        return a;
      }
    }, {
      key: "calculateOutputIndexRowSplit",
      value: function (e, t, n, r) {
        for (var a = e.length, i = [], o = 0; o < a - 1; ++o) {
          var s = e[o + 1] - e[o];
          var u = Math.min(r, s);
          var c = t[o];
          if (c === -1) {
            u = 0;
          }
          for (var l = 0; l < u; ++l) {
            i.push(c);
            c += n;
          }
          for (var h = 0; h < s - u; ++h) {
            i.push(-1);
          }
        }
        if (a > 0 && i.length !== e[a - 1]) {
          throw new Error("Invalid row split size.");
        }
        return i;
      }
    }, {
      key: "calculateOutputIndexValueRowID",
      value: function (e, t, n, r) {
        var a = e.length;
        var i = [];
        if (a === 0) {
          return [];
        }
        var o = 0;
        var s = e[0];
        if (s >= t.length) {
          throw new Error(`Got currentValueRowId=${s}, which is not less than ${t.length}`);
        }
        var u = t[s];
        i.push(u);
        for (var c = 1; c < a; ++c) {
          var l = e[c];
          if (l === s) {
            if (u >= 0) {
              if (++o < r) {
                u += n;
              } else {
                u = -1;
              }
            }
          } else {
            o = 0;
            s = l;
            if (l >= t.length) {
              throw new Error(`Got nextValueRowId=${l} which is not less than ${t.length}`);
            }
            u = t[l];
          }
          i.push(u);
        }
        if (i.length !== e.length) {
          throw new Error("Invalid row ids.");
        }
        return i;
      }
    }, {
      key: "calculateOutputIndex",
      value: function (e, t, n, r) {
        var a = this.getRowPartitionTensor(e);
        var i = this.getRowPartitionTypeByDimension(e);
        switch (i) {
          case Hye.VALUE_ROWIDS:
            return this.calculateOutputIndexValueRowID(a, t, n, r);
          case Hye.ROW_SPLITS:
            if (a.length - 1 > t.length) {
              throw new Error(`Row partition size is greater than output size: ${a.length - 1} > ${t.length}`);
            }
            return this.calculateOutputIndexRowSplit(a, t, n, r);
          default:
            throw new Error(`Unsupported partition type: ${Hye[i]}`);
        }
      }
    }, {
      key: "getFirstDimensionSize",
      value: function () {
        var e = this.rowPartitionValues[0];
        if (this.rowPartitionTypes.length === 0) {
          throw new Error("No row_partition_types given.");
        }
        var t = this.rowPartitionTypes[0];
        switch (t) {
          case Hye.FIRST_DIM_SIZE:
            return e[0];
          case Hye.VALUE_ROWIDS:
            throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
          case Hye.ROW_SPLITS:
            return this.rowPartitionValuesShapes[0][0] - 1;
          default:
            throw new Error(`Cannot handle type ${Hye[t]}`);
        }
      }
    }, {
      key: "compute",
      value: function () {
        if (this.rowPartitionValues[0].length <= 0) {
          throw new Error("Invalid first partition input. Tensor requires at least one element.");
        }
        var e = this.getFirstDimensionSize();
        var t = this.calculateOutputSize(e);
        var n = new Array(this.raggedRank + 1);
        n[n.length - 1] = 1;
        for (var r = n.length - 2; r >= 0; --r) {
          n[r] = n[r + 1] * t[r + 1];
        }
        var a = Xye(t, false);
        var i = K$(this.valuesDType, L$(a));
        if (n[0] * t[0] > 0) {
          var o = this.calculateFirstParentOutputIndex(e, n[0], t[0]);
          for (var s = 1; s <= this.raggedRank; ++s) {
            o = this.calculateOutputIndex(s - 1, o, n[s], t[s]);
          }
          this.setOutput(this.raggedRank, o, i, a);
        }
        return [a, i];
      }
    }, {
      key: "setOutput",
      value: function (e, t, n, r) {
        if (n.length !== 0) {
          var a = this.values;
          var i = n;
          var o = r.slice();
          var s = L$(o = o.slice(e + 1));
          var u = t.length;
          var c = this.defaultValue;
          if (c.length !== s && c.length !== 1) {
            var l = this.defaultValueShape;
            X5(function () {
              var e = X8(c, l);
              var t = h7(e, o);
              c = t.dataSync();
            });
          }
          var h = 0;
          var p = 0;
          var f = 0;
          for (var d = 0; d <= u; ++d) {
            var v = d < u ? t[d] : -1;
            if (v !== f) {
              if (p < f) {
                var m = a.subarray(h * s);
                Kye(i.subarray(p * s), m, (f - p) * s);
              }
              if (d >= u) {
                var g = n.length;
                v = Math.floor(g / s);
              }
              if (v > f) {
                if (this.defaultValue.length === 1) {
                  i.subarray(f * s, v * s).fill(this.defaultValue[0]);
                  f = v;
                } else {
                  while (v > f) {
                    Kye(i.slice(f * s), c, s);
                    ++f;
                  }
                }
              }
              if (v < 0) {
                h = d + 1;
                p = f;
              } else {
                h = d;
                f = (p = f) + 1;
              }
            } else {
              ++f;
            }
          }
        }
      }
    }], [{
      key: "getMaxWidthRowSplit",
      value: function (e) {
        var t = e.length;
        if (t === 0 || t === 1) {
          return 0;
        }
        var n = 0;
        for (var r = 0; r < t - 1; ++r) {
          var a = e[r + 1] - e[r];
          if (a > n) {
            n = a;
          }
        }
        return n;
      }
    }, {
      key: "getMaxWidthValueRowID",
      value: function (e) {
        var t = e.length;
        if (t === 0) {
          return 0;
        }
        var n = 0;
        var r = e[0];
        var a = 0;
        for (var i = 1; i < t; ++i) {
          var o = e[i];
          if (o !== r) {
            r = o;
            a = Math.max(i - n, a);
            n = i;
          }
        }
        return Math.max(t - n, a);
      }
    }]);
    return e;
  }();
  function Kye(e, t, n) {
    for (var r = 0; r < n; r++) {
      e[r] = t[r];
    }
  }
  function Xye(e, t) {
    var n;
    var r = [];
    var a = O(e);
    try {
      for (a.s(); !(n = a.n()).done;) {
        var i = n.value;
        if (i < 0) {
          if (!t) {
            throw new Error(`Dimension ${i} must be >= 0`);
          }
          if (i < -1) {
            throw new Error(`Dimension ${i} must be >= -1`);
          }
          i = -1;
        }
        r.push(i);
      }
    } catch (e) {
      a.e(e);
    } finally {
      a.f();
    }
    return r;
  }
  function Yye(e, t, n, r, a, i, o, s, u, c) {
    return new qye(e, t, n, r, a, i, o, s, u, c).compute();
  }
  function Jye(e, t, n, r) {
    if (e === t || e < t && n < 0 || t < e && n > 1) {
      return l0(0, r);
    }
    var a = l0(Math.abs(Math.ceil((t - e) / n)), r);
    if (t < e && n === 1) {
      n = -1;
    }
    a[0] = e;
    for (var i = 1; i < a.length; i++) {
      a[i] = a[i - 1] + n;
    }
    return a;
  }
  var Zye = Oge(function (e) {
    return 1 / Math.sqrt(e);
  });
  var Qye = Dge(H2, Zye);
  var $ye = {
    kernelName: H2,
    backendName: "cpu",
    kernelFunc: Qye
  };
  function ebe(e, t, n, r, a, i, o, s, u, c) {
    var l = [r / a, a];
    var h = e.values;
    var p = t.values;
    if (r === 0) {
      return l8(n, t.dtype);
    }
    var f = u instanceof $4 ? u : l8(l, t.dtype);
    if (typeof u == "string" || typeof u == "number") {
      f.values.fill(u);
    } else if (typeof u == "boolean") {
      f.values.fill(+u);
    }
    for (var d = 0; d < i; d++) {
      var v = [];
      var m = 0;
      for (var g = 0; g < o; g++) {
        var y = h[d * o + g];
        v.push(y);
        m += y * s[g];
      }
      if (m < 0 || m >= r / a) {
        throw new Error(`Invalid indices: ${v} does not index into ${n}`);
      }
      for (var b = 0; b < a; b++) {
        if (c) {
          f.values[m * a + b] += p[d * a + b];
        } else {
          f.values[m * a + b] = t.rank === 0 ? p[0] : p[d * a + b];
        }
      }
    }
    return f;
  }
  var tbe = Oge(function (e) {
    return 1 / (1 + Math.exp(-e));
  });
  var nbe = Fge(t3, function (e) {
    return 1 / (1 + Math.exp(-e));
  });
  var rbe = {
    kernelName: t3,
    backendName: "cpu",
    kernelFunc: nbe
  };
  function abe(e, t, n, r, a) {
    var i = Kae(r, t, n);
    var o = L$(n);
    var s = i0(r);
    if (i) {
      var u = Xae(t, s);
      if (a === "string") {
        return e.slice(u, u + o);
      } else {
        return e.subarray(u, u + o);
      }
    }
    var c = l8(r, a, a === "string" ? aoe(e) : e);
    for (var l = l8(n, a), h = 0; h < l.size; ++h) {
      var p = l.indexToLoc(h);
      var f = p.map(function (e, n) {
        return e + t[n];
      });
      l.set.apply(l, [c.get.apply(c, T(f))].concat(T(p)));
    }
    if (a === "string") {
      return ioe(l.values);
    } else {
      return l.values;
    }
  }
  function ibe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.begin;
    var o = r.size;
    ige(a, "slice");
    var s = S(Yae(a, i, o), 2);
    var u = s[0];
    var c = s[1];
    zae(a, u, c);
    var l = abe(n.data.get(a.dataId).values, u, c, a.shape, a.dtype);
    return n.makeTensorInfo(c, a.dtype, l);
  }
  var obe = {
    kernelName: Z2,
    backendName: "cpu",
    kernelFunc: ibe
  };
  function sbe(e, t, n, r, a, i, o) {
    var s = t[0];
    var u = i[0];
    var c = new Array(u);
    var l = new Array(s);
    var h = t[1];
    if (u === 0) {
      if (s !== 0) {
        throw new Error(Gie(s));
      }
      return [K$(n, 0), [0, h], K$(a, 0), c, l];
    }
    var p = true;
    var f = 0;
    var d = new Array(u).fill(0);
    for (var v = 0; v < s; ++v) {
      var m = e[v * h];
      if (m < 0) {
        throw new Error(jie(v, m));
      }
      if (m >= u) {
        throw new Error(Hie(v, m, u));
      }
      ++d[m];
      p = p && m >= f;
      f = m;
    }
    var g = true;
    for (var y = 0; y < u; ++y) {
      var b = d[y] === 0;
      c[y] = b;
      g = g && !b;
      d[y] = Math.max(d[y], 1);
      if (y > 0) {
        d[y] += d[y - 1];
      }
    }
    if (g && p) {
      var x = e;
      var k = r;
      for (var w = 0; w < s; ++w) {
        l[w] = w;
      }
      return [x, [s, h], k, c, l];
    }
    var I = d[u - 1];
    var N = K$(n, I * h);
    var S = K$(a, I);
    var T = new Array(u).fill(0);
    for (var E = 0; E < s; ++E) {
      var C = e[E * h];
      var A = T[C];
      var R = (C === 0 ? 0 : d[C - 1]) + A;
      T[C]++;
      for (var _ = 0; _ < h; ++_) {
        N[R * h + _] = e[E * h + _];
      }
      S[R] = r[E];
      l[E] = R;
    }
    for (var O = 0; O < u; ++O) {
      if (T[O] === 0) {
        var F = O === 0 ? 0 : d[O - 1];
        N[F * h + 0] = O;
        for (var D = 1; D < h; ++D) {
          N[F * h + D] = 0;
        }
        S[F] = o;
      }
    }
    return [N, [I, h], S, c, l];
  }
  function ube(e, t, n, r, a) {
    var i = L$(r);
    var o = t[0];
    for (var s = a.length, u = [], c = 1, l = -1, h = 0; h < s; ++h) {
      var p = a[h];
      if (p === -1) {
        if (l !== -1) {
          throw new Error(qie(l, h));
        }
        l = h;
        u.push(1);
      } else {
        if (p < 0) {
          throw new Error(Kie(h, p));
        }
        c *= p;
        u.push(p);
      }
    }
    if (l !== -1) {
      if (c <= 0) {
        throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
      }
      var f = Math.trunc(i / c);
      if (c * f !== i) {
        throw new Error(Yie(r, u));
      }
      u[l] = f;
    }
    if (L$(u) !== i) {
      throw new Error(Jie(r, u));
    }
    var d = r.length;
    var v = [];
    if (d > 0) {
      v[d - 1] = 1;
      for (var m = d - 2; m >= 0; --m) {
        v[m] = v[m + 1] * r[m + 1];
      }
    }
    var g = [];
    if (s > 0) {
      g[s - 1] = 1;
      for (var y = s - 2; y >= 0; --y) {
        g[y] = g[y + 1] * u[y + 1];
      }
    }
    var b = K$(n, o * s);
    for (var x = 0; x < o; ++x) {
      var k = 0;
      for (var w = 0; w < d; ++w) {
        k += e[x * d + w] * v[w];
      }
      for (var I = 0; I < s; ++I) {
        b[x * s + I] = Math.trunc(k / g[I]);
        k %= g[I];
      }
    }
    return [b, [o, s], u];
  }
  function cbe(e, t, n, r, a, i = false, o = 0) {
    var s = r.length;
    var u = [t[0], e.length / t[0]];
    var c = u[1];
    var l = s > 0 ? a[s - 1] + 1 : 0;
    var h = l;
    if (h < 0) {
      throw new Error("segment ids must be >= 0");
    }
    var p = t.slice();
    p[0] = h;
    var f = p.reduce(function (e, t) {
      return e * t;
    }, 1);
    var d = K$(n, f);
    if (s === 0) {
      if (h > 0) {
        d.fill(o);
      }
      return [d, p];
    }
    if (h <= 0) {
      throw new Error("segment ids must be >= 0");
    }
    var v = 0;
    var m = 1;
    var g = 0;
    var y = a[v];
    while (true) {
      var b = 0;
      if (m < s) {
        if (y === (b = a[m])) {
          ++m;
          continue;
        }
        if (y >= b) {
          throw new Error("segment ids are not increasing");
        }
      }
      if (y < 0 || y >= h) {
        throw new Error($ie(y, h));
      }
      if (y > g) {
        d.fill(o, g * c, y * c);
      }
      for (var x = v; x < m; ++x) {
        var k = r[x];
        if (k < 0 || k >= u[0]) {
          throw new Error(eoe(x, r[x], u[0]));
        }
        for (var w = 0; w < c; w++) {
          d[y * c + w] += e[k * c + w];
        }
      }
      if (i) {
        for (var I = 0; I < c; I++) {
          d[y * c + I] /= m - v;
        }
      }
      v = m;
      g = y + 1;
      y = b;
      if (++m > s) {
        break;
      }
    }
    if (g < h) {
      d.fill(o, g * c, h * c);
    }
    return [d, p];
  }
  var lbe = Oge(function (e) {
    return Math.sqrt(e);
  });
  var hbe = Fge(r3, function (e) {
    return Math.sqrt(e);
  });
  var pbe = {
    kernelName: r3,
    backendName: "cpu",
    kernelFunc: hbe
  };
  var fbe = lge(function (e, t) {
    var n = e - t;
    return n * n;
  });
  var dbe = kge(f3, fbe);
  var vbe = {
    kernelName: f3,
    backendName: "cpu",
    kernelFunc: dbe
  };
  var mbe = Oge(function (e, t) {
    var n = t.pattern;
    var r = t.replaceGlobal;
    var a = t.rewrite;
    return e.replace(new RegExp(n, r ? "g" : ""), a);
  });
  var gbe = Dge(v3, mbe);
  var ybe = {
    kernelName: v3,
    backendName: "cpu",
    kernelFunc: gbe
  };
  function bbe(e, t, n, r) {
    for (var a = l8(e, t.dtype), i = 0; i < a.size; i++) {
      var o = a.indexToLoc(i);
      for (var s = new Array(o.length), u = 0; u < s.length; u++) {
        s[u] = o[u] * n[u] + r[u];
      }
      a.set.apply(a, [t.get.apply(t, s)].concat(T(o)));
    }
    return a;
  }
  var xbe = function () {
    function e(t, n, r, a, i, o) {
      l(this, e);
      this.separator = B4(t);
      this.nGramWidths = n;
      this.leftPad = B4(r);
      this.rightPad = B4(a);
      this.padWidth = i;
      this.preserveShort = o;
    }
    p(e, [{
      key: "getPadWidth",
      value: function (e) {
        return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
      }
    }, {
      key: "getNumNGrams",
      value: function (e, t) {
        var n = this.getPadWidth(t);
        return Math.max(0, e + n * 2 - t + 1);
      }
    }, {
      key: "createNGrams",
      value: function (e, t, n, r, a, i) {
        var o = this;
        var s = function () {
          var s = o.getPadWidth(i);
          var c = Math.max(0, s - u);
          var l = Math.max(0, s - (a - (u + 1)));
          var h = i - (c + l);
          var p = t + (c > 0 ? 0 : u - s);
          var f = 0;
          f += c * o.leftPad.length;
          for (var d = 0; d < h; ++d) {
            f += e[p + d].length;
          }
          f += l * o.rightPad.length;
          f += (c + l + h - 1) * o.separator.length;
          n[r + u] = new Uint8Array(f);
          var v = n[r + u];
          var m = 0;
          var g = function (e) {
            return e.forEach(function (e) {
              return v[m++] = e;
            });
          };
          for (var y = 0; y < c; ++y) {
            g(o.leftPad);
            g(o.separator);
          }
          for (var b = 0; b < h - 1; ++b) {
            g(e[p + b]);
            g(o.separator);
          }
          if (h > 0) {
            g(e[p + h - 1]);
            for (var x = 0; x < l; ++x) {
              g(o.separator);
              g(o.rightPad);
            }
          } else {
            for (var k = 0; k < l - 1; ++k) {
              g(o.rightPad);
              g(o.separator);
            }
            g(o.rightPad);
          }
        };
        for (var u = 0; u < a; ++u) {
          s();
        }
      }
    }, {
      key: "compute",
      value: function (e, t) {
        var n = this;
        var r = e.length;
        var a = t.length;
        if (a > 0) {
          var i = t[0];
          if (i !== 0) {
            throw new Error(`First split value must be 0, got ${i}`);
          }
          for (var o = 1; o < a; ++o) {
            var s = t[o] >= i;
            if (!(s = s && t[o] <= r)) {
              throw new Error(`Invalid split value ${t[o]}, must be in [${i}, ${r}]`);
            }
            i = t[o];
          }
          if (i !== r) {
            throw new Error(`Last split value must be data size. Expected ${r}, got ${i}`);
          }
        }
        var u = a - 1;
        var c = K$("int32", a);
        if (r === 0 || a === 0) {
          var l = new Array(r);
          for (var h = 0; h <= u; ++h) {
            c[h] = 0;
          }
          return [l, c];
        }
        c[0] = 0;
        var p = function () {
          var e = t[f] - t[f - 1];
          var r = 0;
          n.nGramWidths.forEach(function (t) {
            r += n.getNumNGrams(e, t);
          });
          if (n.preserveShort && e > 0 && r === 0) {
            r = 1;
          }
          c[f] = c[f - 1] + r;
        };
        for (var f = 1; f <= u; ++f) {
          p();
        }
        var d = new Array(c[u]);
        var v = function (r) {
          var a = t[r];
          var i = c[r];
          n.nGramWidths.forEach(function (o) {
            var s = t[r + 1] - t[r];
            var u = n.getNumNGrams(s, o);
            n.createNGrams(e, a, d, i, u, o);
            i += u;
          });
          if (n.preserveShort && i === c[r]) {
            var o = t[r + 1] - t[r];
            if (o === 0) {
              return "continue";
            }
            var s = o + n.padWidth * 2;
            n.createNGrams(e, a, d, i, 1, s);
          }
        };
        for (var m = 0; m < u; ++m) {
          v(m);
        }
        return [d, c];
      }
    }]);
    return e;
  }();
  function kbe(e, t, n, r, a, i, o, s) {
    return new xbe(n, r, a, i, o, s).compute(e, t);
  }
  function wbe(e, t, n, r) {
    if (e.length) {
      if (t.length !== 0) {
        if (t.length !== 1) {
          var a = 0;
          for (var i = 0; i < e.length + 1; i++) {
            if (i === e.length || t.indexOf(e[i]) !== -1) {
              var o = e.subarray(a, i);
              if (!n || o.length !== 0) {
                r.push(o);
              }
              a = i + 1;
            }
          }
        } else {
          var s = t[0];
          for (var u = e.indexOf(s); u !== -1;) {
            var c = e.subarray(0, u);
            if (!n || c.length !== 0) {
              r.push(c);
            }
            u = (e = e.subarray(u + 1)).indexOf(s);
          }
          if (!n || e.length !== 0) {
            r.push(e);
          }
        }
      } else {
        for (var l = 0; l < e.length; ++l) {
          r.push(e.subarray(l, l + 1));
        }
      }
    }
  }
  function Ibe(e, t, n) {
    for (var r = e.length, a = [], i = 0, o = 0, s = new Array(r), u = 0; u < r; ++u) {
      var c = a.length;
      wbe(e[u], t, n, a);
      var l = a.length - c;
      s[u] = l;
      i += l;
      o = Math.max(o, l);
    }
    var h = K$("int32", i * 2);
    var p = new Array(i);
    var f = [r, o];
    var d = 0;
    for (var v = 0; v < r; ++v) {
      for (var m = 0; m < s[v]; ++m) {
        h[d * 2] = v;
        h[d * 2 + 1] = m;
        p[d] = a[d];
        ++d;
      }
    }
    return [h, p, f];
  }
  function Nbe(e, t) {
    var n = K$("int32", e.length);
    for (var r = 0; r < e.length; ++r) {
      n[r] = D4(e[r]).modulo(t).getLowBitsUnsigned();
    }
    return n;
  }
  var Sbe = lge(function (e, t) {
    return e - t;
  });
  var Tbe = wge(function (e, t, n, r) {
    return {
      real: e - n,
      imag: t - r
    };
  });
  var Ebe = kge(x3, Sbe, Tbe);
  var Cbe = {
    kernelName: x3,
    backendName: "cpu",
    kernelFunc: Ebe
  };
  function Abe(e, t) {
    for (var n = new Array(e.rank), r = 0; r < n.length; r++) {
      n[r] = e.shape[r] * t[r];
    }
    for (var a = l8(n, e.dtype), i = 0; i < a.values.length; ++i) {
      var o = a.indexToLoc(i);
      for (var s = new Array(e.rank), u = 0; u < s.length; u++) {
        s[u] = o[u] % e.shape[u];
      }
      var c = e.locToIndex(s);
      a.values[i] = e.values[c];
    }
    return a;
  }
  function Rbe(e, t) {
    var n = t.value - e.value;
    if (n === 0) {
      return e.index - t.index;
    } else {
      return n;
    }
  }
  function _be(e, t) {
    for (var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.length - 1; r > n;) {
      if (r - n > 600) {
        var a = r - n + 1;
        var i = t - n + 1;
        var o = Math.log(a);
        var s = Math.exp(o * 2 / 3) * 0.5;
        var u = Math.sqrt(o * s * (a - s) / a) * 0.5 * Math.sign(i - a / 2);
        var c = Math.max(n, Math.floor(t - i * s / a + u));
        var l = Math.min(r, Math.floor(t + (a - i) * s / a + u));
        _be(e, t, c, l);
      }
      var h = e[t];
      var p = n;
      var f = r;
      _$(e, n, t);
      if (Rbe(e[r], h) > 0) {
        _$(e, n, r);
      }
      while (p < f) {
        _$(e, p, f);
        p++;
        f--;
        while (Rbe(e[p], h) < 0) {
          p += 1;
        }
        while (Rbe(e[f], h) > 0) {
          f -= 1;
        }
      }
      if (Rbe(e[n], h) === 0) {
        _$(e, n, f);
      } else {
        _$(e, f += 1, r);
      }
      if (f <= t) {
        n = f + 1;
      }
      if (t <= f) {
        r = f - 1;
      }
    }
  }
  function Obe(e, t, n, r, a) {
    var i = t[t.length - 1];
    for (var o = e.length / i, s = i, u = q$(n, o * r), c = q$("int32", o * r), l = function () {
        var t = h * s;
        var n = e.subarray(t, t + s);
        var i = new Array(n.length);
        n.forEach(function (e, t) {
          return i[t] = {
            value: e,
            index: t
          };
        });
        if (r < i.length) {
          _be(i, r);
          i = i.slice(0, r);
        }
        if (a) {
          i.sort(Rbe);
        }
        var o = h * r;
        var l = u.subarray(o, o + r);
        var p = c.subarray(o, o + r);
        for (var f = 0; f < r; f++) {
          l[f] = i[f].value;
          p[f] = i[f].index;
        }
      }, h = 0; h < o; h++) {
      l();
    }
    var p = t.slice();
    p[p.length - 1] = r;
    return [l8(p, n, u), l8(p, "int32", c)];
  }
  function Fbe(e, t, n, r) {
    for (var a = j$(t, n)[0], i = [1, n[0], 1], o = 0; o < a; o++) {
      i[0] *= n[o];
    }
    i[1] = n[a];
    for (var s = a + 1; s < n.length; s++) {
      i[2] *= n[s];
    }
    var u = new Map();
    var c = new Int32Array(n[a]);
    var l = new $4(i, r, e);
    var h = [];
    var p = i[0] === 1 && i[2] === 1;
    for (var f = 0; f < n[a]; f++) {
      var d = undefined;
      if (p) {
        d = e[f].toString();
      } else {
        var v = [];
        for (var m = 0; m < i[0]; m++) {
          for (var g = 0; g < i[2]; g++) {
            v.push(l.get(m, f, g));
          }
        }
        d = v.join(",");
      }
      var y = u.get(d);
      if (y != null) {
        c[f] = y;
      } else {
        var b = u.size;
        u.set(d, b);
        c[f] = b;
        h.push(f);
      }
    }
    var x = i.slice();
    x[1] = u.size;
    var k = new $4(x, r);
    h.forEach(function (e, t) {
      for (var n = 0; n < i[0]; n++) {
        for (var r = 0; r < i[2]; r++) {
          k.set(l.get(n, e, r), n, t, r);
        }
      }
    });
    var w = n.slice();
    w[a] = x[1];
    return {
      outputValues: k.values,
      outputShape: w,
      indices: c
    };
  }
  var Dbe = {
    __proto__: null,
    addImpl: Ige,
    bincountImpl: Ege,
    bincountReduceImpl: Cge,
    bitwiseAndImpl: Age,
    castImpl: yge,
    ceilImpl: Mge,
    concatImpl: Pge,
    equalImpl: Bge,
    expImpl: Vge,
    expm1Impl: Hge,
    floorDivImpl: Zge,
    floorImpl: Xge,
    gatherNdImpl: eye,
    gatherV2Impl: tye,
    greaterEqualImpl: iye,
    greaterImpl: nye,
    lessEqualImpl: hye,
    lessImpl: uye,
    linSpaceImpl: dye,
    logImpl: vye,
    maxImpl: yye,
    maximumImpl: bye,
    minimumImpl: wye,
    multiplyImpl: Sye,
    negImpl: Aye,
    notEqualImpl: _ye,
    prodImpl: zye,
    raggedGatherImpl: Vye,
    raggedRangeImpl: jye,
    raggedTensorToTensorImpl: Yye,
    rangeImpl: Jye,
    rsqrtImpl: Zye,
    scatterImpl: ebe,
    sigmoidImpl: tbe,
    simpleAbsImpl: uge,
    sliceImpl: abe,
    sparseFillEmptyRowsImpl: sbe,
    sparseReshapeImpl: ube,
    sparseSegmentReductionImpl: cbe,
    sqrtImpl: lbe,
    squaredDifferenceImpl: fbe,
    staticRegexReplaceImpl: mbe,
    stridedSliceImpl: bbe,
    stringNGramsImpl: kbe,
    stringSplitImpl: Ibe,
    stringToHashBucketFastImpl: Nbe,
    subImpl: Sbe,
    tileImpl: Abe,
    topKImpl: Obe,
    transposeImpl: Dye,
    uniqueImpl: Fbe
  };
  var Mbe = "4.15.0";
  $5("cpu", function () {
    return new sge();
  }, 1);
  var Lbe = Fge(I1, function (e) {
    if (e >= 0) {
      return e;
    } else {
      return Math.exp(e) - 1;
    }
  });
  var zbe = {
    kernelName: I1,
    backendName: "cpu",
    kernelFunc: Lbe
  };
  function Pbe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.alpha;
    ige([a], "leakyRelu");
    var o = L$(a.shape);
    for (var s = n.data.get(a.dataId).values, u = q$("float32", o), c = 0; c < s.length; c++) {
      u[c] = s[c] < 0 ? i * s[c] : s[c];
    }
    return n.makeTensorInfo(a.shape, "float32", u);
  }
  var Bbe = {
    kernelName: q1,
    backendName: "cpu",
    kernelFunc: Pbe
  };
  var Wbe = lge(function (e, t) {
    if (e < 0) {
      return t * e;
    } else {
      return e;
    }
  });
  function Ube(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.x;
    var a = t.alpha;
    ige([r, a], "prelu");
    var i = n.data.get(r.dataId).values;
    var o = n.data.get(a.dataId).values;
    var s = S(Wbe(r.shape, a.shape, i, o, "float32"), 2);
    var u = s[0];
    var c = s[1];
    return n.makeTensorInfo(c, "float32", u);
  }
  var Vbe = {
    kernelName: C2,
    backendName: "cpu",
    kernelFunc: Ube
  };
  var Gbe = Fge(L2, function (e) {
    return Math.max(0, e);
  });
  var jbe = {
    kernelName: L2,
    backendName: "cpu",
    kernelFunc: Gbe
  };
  var Hbe = Fge(V2, function (e) {
    return Math.min(Math.max(0, e), 6);
  });
  var qbe = {
    kernelName: V2,
    backendName: "cpu",
    kernelFunc: Hbe
  };
  function Kbe(e, t, n, r, a) {
    if (n === "linear") {
      return dge({
        inputs: {
          x: t
        },
        backend: e
      });
    }
    if (n === "relu") {
      return Gbe({
        inputs: {
          x: t
        },
        backend: e
      });
    }
    if (n === "elu") {
      return Lbe({
        inputs: {
          x: t
        },
        backend: e
      });
    }
    if (n === "relu6") {
      return Hbe({
        inputs: {
          x: t
        },
        backend: e
      });
    }
    if (n === "prelu") {
      return Ube({
        inputs: {
          x: t,
          alpha: r
        },
        backend: e
      });
    }
    if (n === "leakyrelu") {
      return Pbe({
        inputs: {
          x: t
        },
        backend: e,
        attrs: {
          alpha: a
        }
      });
    }
    if (n === "sigmoid") {
      return nbe({
        inputs: {
          x: t
        },
        backend: e
      });
    }
    throw new Error(`Activation ${n} has not been implemented for the CPU backend.`);
  }
  function Xbe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.shape;
    var o = L$(a.shape);
    var s = G$(i, o);
    var u = L$(s);
    F$(o === u, function () {
      return `The new shape (${s}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`;
    });
    n.incRef(a.dataId);
    var c = n.data.get(a.dataId);
    if (c.complexTensorInfos != null) {
      var l = c.complexTensorInfos.real;
      var h = c.complexTensorInfos.imag;
      l.shape = s;
      h.shape = s;
    }
    return {
      dataId: a.dataId,
      shape: s,
      dtype: a.dtype
    };
  }
  var Ybe = {
    kernelName: z2,
    backendName: "cpu",
    kernelFunc: Xbe
  };
  function Jbe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.a;
    var i = t.b;
    var o = r.transposeA;
    var s = r.transposeB;
    ige([a, i], "matMul");
    var u = a.shape.length;
    var c = i.shape.length;
    var l = o ? a.shape[u - 2] : a.shape[u - 1];
    var h = s ? i.shape[c - 1] : i.shape[c - 2];
    var p = o ? a.shape[u - 1] : a.shape[u - 2];
    var f = s ? i.shape[c - 2] : i.shape[c - 1];
    var d = a.shape.slice(0, -2);
    var v = i.shape.slice(0, -2);
    var m = L$(d);
    var g = L$(v);
    var y = z7(a.shape.slice(0, -2), i.shape.slice(0, -2)).concat([p, f]);
    F$(l === h, function () {
      return `Error in matMul: inner shapes (${l}) and (${h}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${o} and transposeB=${s} must match.`;
    });
    var b = s ? [g, f, h] : [g, h, f];
    var x = Xbe({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: o ? [m, l, p] : [m, p, l]
      }
    });
    var k = Xbe({
      inputs: {
        x: i
      },
      backend: n,
      attrs: {
        shape: b
      }
    });
    var w = o ? x.shape[1] : x.shape[2];
    var I = o ? x.shape[2] : x.shape[1];
    var N = s ? k.shape[1] : k.shape[2];
    for (var T = Math.max(m, g), E = n.data.get(x.dataId).values, C = n.data.get(k.dataId).values, A = i0(x.shape), R = i0(k.shape), _ = S(o ? [A[0], 1, A[1]] : [A[0], A[1], 1], 3), O = _[0], F = _[1], D = _[2], M = S(s ? [1, R[1], R[0]] : [R[1], 1, R[0]], 3), L = M[0], z = M[1], P = M[2], B = I * N, W = l8([T, I, N], x.dtype), U = W.values, V = n.blockSize, G = 0; G < T; G++) {
      var j = G % m;
      var H = G % g;
      for (var q = 0; q < I; q += V) {
        var K = Math.min(q + V, I);
        for (var X = 0; X < N; X += V) {
          var Y = Math.min(X + V, N);
          for (var J = 0; J < w; J += V) {
            var Z = Math.min(J + V, w);
            for (var Q = q; Q < K; Q++) {
              for (var $ = X; $ < Y; $++) {
                var ee = 0;
                for (var te = J; te < Z; te++) {
                  ee += E[j * O + Q * F + te * D] * C[te * L + $ * z + H * P];
                }
                U[G * B + (Q * N + $)] += ee;
              }
            }
          }
        }
      }
    }
    n.disposeIntermediateTensorInfo(x);
    n.disposeIntermediateTensorInfo(k);
    return n.makeTensorInfo(y, W.dtype, W.values);
  }
  var Zbe = {
    kernelName: V0,
    backendName: "cpu",
    kernelFunc: Jbe
  };
  var Qbe = {
    kernelName: D3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t;
      var n;
      var r;
      var a = e.inputs;
      var i = e.backend;
      var o = e.attrs;
      var s = a.a;
      var u = a.b;
      var c = a.bias;
      var l = a.preluActivationWeights;
      var h = o.transposeA;
      var p = o.transposeB;
      var f = o.activation;
      var d = o.leakyreluAlpha;
      var v = [];
      t = Jbe({
        inputs: {
          a: s,
          b: u
        },
        attrs: {
          transposeA: h,
          transposeB: p
        },
        backend: i
      });
      if (c) {
        n = Sge({
          inputs: {
            a: t,
            b: c
          },
          backend: i
        });
        v.push(t);
        t = n;
      }
      if (f) {
        r = Kbe(i, t, f, l, d);
        v.push(t);
        t = r;
      }
      for (var m = 0, g = v; m < g.length; m++) {
        var y = g[m];
        i.disposeIntermediateTensorInfo(y);
      }
      return t;
    }
  };
  var $be = Fge(S0, function (e) {
    return Math.acos(e);
  });
  var exe = {
    kernelName: S0,
    backendName: "cpu",
    kernelFunc: $be
  };
  var txe = Fge(T0, function (e) {
    return Math.acosh(e);
  });
  var nxe = {
    kernelName: T0,
    backendName: "cpu",
    kernelFunc: txe
  };
  var rxe = {
    kernelName: C0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t;
      ige(t, "addN");
      var a = r.map(function (e) {
        return n.data.get(e.dataId).values;
      });
      var i = l8(r[0].shape, r[0].dtype);
      var o = i.values;
      for (var s = 0; s < r.length; s++) {
        var u = a[s];
        for (var c = 0; c < o.length; c++) {
          o[c] += u[c];
        }
      }
      return n.makeTensorInfo(i.shape, i.dtype, i.values);
    }
  };
  var axe = {
    kernelName: A0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      ige(a, "all");
      var s = j$(i, a.shape);
      var u = s;
      var c = $7(u, a.shape.length);
      var l = a;
      if (c != null) {
        l = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: c
          }
        });
        u = t9(u.length, a.shape.length);
      }
      Q7("all", u, l.shape.length);
      var h = S(J7(l.shape, u), 2);
      var p = h[0];
      var f = L$(h[1]);
      for (var d = l0(L$(p), l.dtype), v = n.data.get(l.dataId).values, m = 0; m < d.length; ++m) {
        var g = m * f;
        var y = v[g];
        for (var b = 0; b < f; ++b) {
          var x = v[g + b];
          y = y && x;
        }
        d[m] = y;
      }
      if (c != null) {
        n.disposeIntermediateTensorInfo(l);
      }
      var k = n.makeTensorInfo(p, l.dtype, d);
      if (o) {
        var w = Xbe({
          inputs: {
            x: k
          },
          backend: n,
          attrs: {
            shape: Z7(p, s)
          }
        });
        n.disposeIntermediateTensorInfo(k);
        return w;
      }
      return k;
    }
  };
  var ixe = {
    kernelName: R0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      ige(a, "any");
      var s = j$(i, a.shape);
      var u = s;
      var c = $7(u, a.shape.length);
      var l = a;
      if (c != null) {
        l = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: c
          }
        });
        u = t9(u.length, a.shape.length);
      }
      Q7("any", u, l.shape.length);
      var h = S(J7(l.shape, u), 2);
      var p = h[0];
      var f = L$(h[1]);
      for (var d = l0(L$(p), l.dtype), v = n.data.get(l.dataId).values, m = 0; m < d.length; ++m) {
        var g = m * f;
        var y = v[g];
        for (var b = 0; b < f; ++b) {
          var x = v[g + b];
          y = y || x;
        }
        d[m] = y;
      }
      if (c != null) {
        n.disposeIntermediateTensorInfo(l);
      }
      var k = n.makeTensorInfo(p, l.dtype, d);
      if (o) {
        var w = Xbe({
          inputs: {
            x: k
          },
          backend: n,
          attrs: {
            shape: Z7(p, s)
          }
        });
        n.disposeIntermediateTensorInfo(k);
        return w;
      }
      return k;
    }
  };
  var oxe = {
    kernelName: _0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      ige(a, "argMax");
      var o = j$(i, a.shape);
      var s = $7(o, a.shape.length);
      var u = a;
      var c = [];
      if (s != null) {
        u = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: s
          }
        });
        c.push(u);
        o = t9(o.length, u.shape.length);
      }
      Q7("argMax", o = [o[0]], u.shape.length);
      var l = S(J7(u.shape, o), 2);
      var h = l[0];
      var p = l[1];
      for (var f = l0(L$(h), "int32"), d = L$(p), v = n.data.get(u.dataId).values, m = 0; m < f.length; ++m) {
        var g = m * d;
        var y = v[g];
        var b = 0;
        for (var x = 0; x < d; ++x) {
          var k = v[g + x];
          if (k > y) {
            y = k;
            b = x;
          }
        }
        f[m] = b;
      }
      c.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return n.makeTensorInfo(h, "int32", f);
    }
  };
  var sxe = {
    kernelName: O0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      ige(a, "argMin");
      var o = j$(i, a.shape);
      var s = $7(o, a.shape.length);
      var u = a;
      var c = [];
      if (s != null) {
        u = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: s
          }
        });
        c.push(u);
        o = t9(o.length, u.shape.length);
      }
      Q7("argMin", o = [o[0]], u.shape.length);
      var l = S(J7(u.shape, o), 2);
      var h = l[0];
      var p = l[1];
      for (var f = l0(L$(h), "int32"), d = L$(p), v = n.data.get(u.dataId).values, m = 0; m < f.length; ++m) {
        var g = m * d;
        var y = v[g];
        var b = 0;
        for (var x = 0; x < d; ++x) {
          var k = v[g + x];
          if (k < y) {
            y = k;
            b = x;
          }
        }
        f[m] = b;
      }
      c.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return n.makeTensorInfo(h, "int32", f);
    }
  };
  var uxe = Fge(F0, function (e) {
    return Math.asin(e);
  });
  var cxe = {
    kernelName: F0,
    backendName: "cpu",
    kernelFunc: uxe
  };
  var lxe = Fge(D0, function (e) {
    return Math.asinh(e);
  });
  var hxe = {
    kernelName: D0,
    backendName: "cpu",
    kernelFunc: lxe
  };
  var pxe = Fge(M0, function (e) {
    return Math.atan(e);
  });
  var fxe = {
    kernelName: M0,
    backendName: "cpu",
    kernelFunc: pxe
  };
  var dxe = lge(function (e, t) {
    return Math.atan2(e, t);
  });
  var vxe = kge(z0, dxe);
  var mxe = {
    kernelName: z0,
    backendName: "cpu",
    kernelFunc: vxe
  };
  var gxe = Fge(L0, function (e) {
    return Math.atanh(e);
  });
  var yxe = {
    kernelName: L0,
    backendName: "cpu",
    kernelFunc: gxe
  };
  function bxe(e, t, n, r, a, i) {
    var o = a.strideHeight;
    var s = a.strideWidth;
    var u = a.dilationHeight;
    var c = a.dilationWidth;
    var l = a.effectiveFilterHeight;
    var h = a.effectiveFilterWidth;
    var p = a.padInfo.top;
    var f = a.padInfo.left;
    var d = i === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    var v = l8(a.outShape, n);
    var m = v.values;
    var g = a.outShape[1] * a.outShape[2] * a.outShape[3];
    var y = a.outShape[2] * a.outShape[3];
    var b = a.outShape[3];
    for (var x = 0; x < a.batchSize; ++x) {
      var k = x * g;
      var w = x * r[0];
      for (var I = 0; I < a.inChannels; ++I) {
        for (var N = 0; N < a.outHeight; ++N) {
          var S = N * o - p;
          var T = Math.max(0, S);
          var E = Math.min(a.inHeight, l + S);
          var C = k + N * y;
          for (var A = 0; A < a.outWidth; ++A) {
            var R = A * s - f;
            var _ = Math.max(0, R);
            var O = Math.min(a.inWidth, h + R);
            var F = d;
            var D = 0;
            var M = 0;
            for (var L = T; L < E; L += u) {
              var z = w + L * r[1];
              for (var P = _; P < O; P += c) {
                var B = e[z + P * r[2] + I];
                if (i === "max" && B > F) {
                  F = B;
                } else if (i === "avg") {
                  D += B;
                  M++;
                }
              }
              if (isNaN(F)) {
                break;
              }
            }
            m[C + A * b + I] = i === "avg" ? D / M : F;
          }
        }
      }
    }
    return v;
  }
  function xxe(e, t, n, r, a = false, i = false) {
    var o = l8(r.outShape, "int32");
    var s = r.strideHeight;
    var u = r.strideWidth;
    var c = r.dilationHeight;
    var l = r.dilationWidth;
    var h = r.effectiveFilterHeight;
    var p = r.effectiveFilterWidth;
    var f = r.padInfo.top;
    var d = r.padInfo.left;
    var v = l8(t, n, e);
    for (var m = 0; m < r.batchSize; ++m) {
      for (var g = 0; g < r.inChannels; ++g) {
        for (var y = 0; y < r.outHeight; ++y) {
          var b = y * s - f;
          for (var x = b; x < 0;) {
            x += c;
          }
          var k = Math.min(r.inHeight, h + b);
          for (var w = 0; w < r.outWidth; ++w) {
            var I = w * u - d;
            for (var N = I; N < 0;) {
              N += l;
            }
            var S = Math.min(r.inWidth, p + I);
            var T = Number.NEGATIVE_INFINITY;
            var E = -1;
            for (var C = x; C < k; C += c) {
              var A = C - b;
              for (var R = N; R < S; R += l) {
                var _ = R - I;
                var O = v.get(m, C, R, g);
                if (O > T) {
                  T = O;
                  E = a ? i ? ((m * r.inHeight + C) * r.inWidth + R) * r.inChannels + g : (C * r.inWidth + R) * r.inChannels + g : A * p + _;
                }
              }
            }
            o.set(E, m, y, w, g);
          }
        }
      }
    }
    return o;
  }
  function kxe(e, t, n, r, a, i) {
    var o = a.strideDepth;
    var s = a.strideHeight;
    var u = a.strideWidth;
    var c = a.dilationDepth;
    var l = a.dilationHeight;
    var h = a.dilationWidth;
    var p = a.effectiveFilterDepth;
    var f = a.effectiveFilterHeight;
    var d = a.effectiveFilterWidth;
    var v = a.padInfo.front;
    var m = a.padInfo.top;
    var g = a.padInfo.left;
    var y = i === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    var b = l8(a.outShape, n);
    var x = b.values;
    var k = a.outShape[1] * a.outShape[2] * a.outShape[3] * a.outShape[4];
    var w = a.outShape[2] * a.outShape[3] * a.outShape[4];
    var I = a.outShape[3] * a.outShape[4];
    var N = a.outShape[4];
    for (var S = 0; S < a.batchSize; ++S) {
      var T = S * k;
      var E = S * r[0];
      for (var C = 0; C < a.inChannels; ++C) {
        for (var A = 0; A < a.outDepth; ++A) {
          var R = A * o - v;
          for (var _ = R; _ < 0;) {
            _ += c;
          }
          var O = Math.min(a.inDepth, p + R);
          var F = T + A * w;
          for (var D = 0; D < a.outHeight; ++D) {
            var M = D * s - m;
            for (var L = M; L < 0;) {
              L += l;
            }
            var z = Math.min(a.inHeight, f + M);
            var P = F + D * I;
            for (var B = 0; B < a.outWidth; ++B) {
              var W = B * u - g;
              for (var U = W; U < 0;) {
                U += h;
              }
              var V = Math.min(a.inWidth, d + W);
              var G = P + B * N;
              var j = y;
              var H = 0;
              var q = 0;
              for (var K = _; K < O; K += c) {
                var X = E + K * r[1];
                for (var Y = L; Y < z; Y += l) {
                  var J = X + Y * r[2];
                  for (var Z = U; Z < V; Z += h) {
                    var Q = e[J + Z * r[3] + C];
                    if (i === "max" && Q > j) {
                      j = Q;
                    } else if (i === "avg") {
                      H += Q;
                      q++;
                    }
                    if (isNaN(j)) {
                      break;
                    }
                  }
                  if (isNaN(j)) {
                    break;
                  }
                }
                if (isNaN(j)) {
                  break;
                }
              }
              x[G + C] = i === "avg" ? H / Math.max(q, 1) : j;
            }
          }
        }
      }
    }
    return b;
  }
  var wxe = {
    kernelName: P0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      ige(a, "avgPool");
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dimRoundingMode;
      F$(j8(o, 1), function () {
        return `Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${1}'`;
      });
      var c;
      var l = O8(a.shape, i, o, 1, s, u);
      if (l.filterWidth === 1 && l.filterHeight === 1 && P$(l.inShape, l.outShape)) {
        c = dge({
          inputs: {
            x: a
          },
          backend: n
        });
      } else {
        var h = n.data.get(a.dataId).values;
        var p = i0(a.shape);
        var f = bxe(h, a.shape, a.dtype, p, l, "avg");
        c = n.makeTensorInfo(l.outShape, a.dtype, f.values);
      }
      return c;
    }
  };
  var Ixe = {
    kernelName: W0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dimRoundingMode;
      var c = r.dataFormat;
      ige(a, "avgPool3d");
      var l = F8(a.shape, i, o, 1, s, u, c);
      var h = kxe(n.data.get(a.dataId).values, a.shape, a.dtype, i0(a.shape), l, "avg");
      return n.makeTensorInfo(h.shape, "float32", h.values);
    }
  };
  var Nxe = {
    kernelName: U0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = r.filterSize;
      var s = r.strides;
      var u = r.pad;
      var c = r.dimRoundingMode;
      ige([a, i], "avgPool3DGrad");
      for (var l = F8(i.shape, o, s, 1, u, c), h = l.strideDepth, p = l.strideHeight, f = l.strideWidth, d = l.filterDepth, v = l.filterHeight, m = l.filterWidth, g = l.dilationDepth, y = l.dilationHeight, b = l.dilationWidth, x = l.effectiveFilterDepth, k = l.effectiveFilterHeight, w = l.effectiveFilterWidth, I = x - 1 - l.padInfo.front, N = w - 1 - l.padInfo.left, S = k - 1 - l.padInfo.top, T = l8(i.shape, "float32"), E = 1 / (d * v * m), C = n.bufferSync(a), A = 0; A < l.batchSize; ++A) {
        for (var R = 0; R < l.inChannels; ++R) {
          for (var _ = 0; _ < l.inDepth; ++_) {
            for (var O = 0; O < l.inHeight; ++O) {
              for (var F = 0; F < l.inWidth; ++F) {
                var D = _ - I;
                var M = O - S;
                var L = F - N;
                var z = 0;
                for (var P = 0; P < x; P += g) {
                  var B = (D + P) / h;
                  if (!(B < 0) && !(B >= l.outDepth) && Math.floor(B) === B) {
                    for (var W = 0; W < k; W += y) {
                      var U = (M + W) / p;
                      if (!(U < 0) && !(U >= l.outHeight) && Math.floor(U) === U) {
                        for (var V = 0; V < w; V += b) {
                          var G = (L + V) / f;
                          if (!(G < 0) && !(G >= l.outWidth) && Math.floor(G) === G) {
                            z += C.get(A, B, U, G, R);
                          }
                        }
                      }
                    }
                  }
                }
                T.set(z * E, A, _, O, F, R);
              }
            }
          }
        }
      }
      return n.makeTensorInfo(T.shape, T.dtype, T.values);
    }
  };
  var Sxe = {
    kernelName: B0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = i;
      ige([a, i], "avgPoolGrad");
      var s = r.filterSize;
      var u = r.strides;
      var c = r.pad;
      for (var l = O8(o.shape, s, u, 1, c), h = l.strideHeight, p = l.strideWidth, f = l.filterHeight, d = l.filterWidth, v = l.dilationHeight, m = l.dilationWidth, g = l.effectiveFilterHeight, y = l.effectiveFilterWidth, b = y - 1 - l.padInfo.left, x = g - 1 - l.padInfo.top, k = l8(o.shape, "float32"), w = 1 / (f * d), I = n.data.get(a.dataId).values, N = l8(a.shape, "float32", I), S = 0; S < l.batchSize; ++S) {
        for (var T = 0; T < l.inChannels; ++T) {
          for (var E = 0; E < l.inHeight; ++E) {
            for (var C = 0; C < l.inWidth; ++C) {
              var A = E - x;
              var R = C - b;
              var _ = 0;
              for (var O = 0; O < g; O += v) {
                var F = (A + O) / h;
                if (!(F < 0) && !(F >= l.outHeight) && Math.floor(F) === F) {
                  for (var D = 0; D < y; D += m) {
                    var M = (R + D) / p;
                    if (!(M < 0) && !(M >= l.outWidth) && Math.floor(M) === M) {
                      _ += N.get(S, F, M, T);
                    }
                  }
                }
              }
              k.set(_ * w, S, E, C, T);
            }
          }
        }
      }
      return n.makeTensorInfo(k.shape, k.dtype, k.values);
    }
  };
  var Txe = {
    kernelName: M1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.scale;
      var o = t.offset;
      var s = t.mean;
      var u = t.variance;
      F$(s.shape.length === u.shape.length, function () {
        return "Batch normalization gradient requires mean and variance to have equal ranks.";
      });
      F$(o == null || s.shape.length === o.shape.length, function () {
        return "Batch normalization gradient requires mean and offset to have equal ranks.";
      });
      F$(i == null || s.shape.length === i.shape.length, function () {
        return "Batch normalization gradient requires mean and scale to have equal ranks.";
      });
      ige([a, s, u, i, o], "batchNorm");
      var c = r.varianceEpsilon;
      if (c == null) {
        c = 0.001;
      }
      for (var l = n.data.get(a.dataId).values, h = n.data.get(s.dataId).values, p = n.data.get(u.dataId).values, f = i ? n.data.get(i.dataId).values : new Float32Array([1]), d = o ? n.data.get(o.dataId).values : new Float32Array([0]), v = new Float32Array(l.length), m = d.length, g = f.length, y = p.length, b = h.length, x = 0, k = 0, w = 0, I = 0, N = 0; N < l.length; ++N) {
        v[N] = d[x++] + (l[N] - h[k++]) * f[w++] / Math.sqrt(p[I++] + c);
        if (x >= m) {
          x = 0;
        }
        if (k >= b) {
          k = 0;
        }
        if (w >= g) {
          w = 0;
        }
        if (I >= y) {
          I = 0;
        }
      }
      return n.makeTensorInfo(a.shape, a.dtype, v);
    }
  };
  var Exe = {
    kernelName: G0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.blockShape;
      var o = r.crops;
      ige([a], "batchToSpaceND");
      var s = i.reduce(function (e, t) {
        return e * t;
      });
      var u = fie(a.shape, i, s);
      var c = die(u.length, i.length);
      var l = vie(a.shape, i, s);
      var h = mie(o, i.length);
      var p = gie(l, o, i.length);
      var f = Xbe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: u
        }
      });
      var d = Mye({
        inputs: {
          x: f
        },
        backend: n,
        attrs: {
          perm: c
        }
      });
      var v = Xbe({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          shape: l
        }
      });
      var m = ibe({
        inputs: {
          x: v
        },
        backend: n,
        attrs: {
          begin: h,
          size: p
        }
      });
      n.disposeIntermediateTensorInfo(f);
      n.disposeIntermediateTensorInfo(d);
      n.disposeIntermediateTensorInfo(v);
      return m;
    }
  };
  var Cxe = {
    kernelName: j0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.weights;
      var o = r.size;
      var s = Ege(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
      return n.makeTensorInfo([o], i.dtype, s);
    }
  };
  var Axe = {
    kernelName: K0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.s0;
      var a = t.s1;
      var i = n.data.get(r.dataId).values;
      var o = n.data.get(a.dataId).values;
      var s = z7(Array.from(i), Array.from(o));
      return n.makeTensorInfo([s.length], "int32", Int32Array.from(s));
    }
  };
  var Rxe = Fge(J0, function (e, t) {
    var n = t;
    if (e > n.clipValueMax) {
      return n.clipValueMax;
    } else if (e < n.clipValueMin) {
      return n.clipValueMin;
    } else {
      return e;
    }
  });
  var _xe = {
    kernelName: J0,
    backendName: "cpu",
    kernelFunc: Rxe
  };
  var Oxe = {
    kernelName: Q0,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs.x;
      var n = e.backend;
      var r = new Float32Array(L$(t.shape));
      var a = n.data.get(t.dataId);
      var i = a.complexTensorInfos.real;
      var o = a.complexTensorInfos.imag;
      for (var s = n.data.get(i.dataId).values, u = n.data.get(o.dataId).values, c = 0; c < s.length; c++) {
        var l = s[c];
        var h = u[c];
        r[c] = Math.hypot(l, h);
      }
      return n.makeOutput(r, t.shape, "float32");
    }
  };
  function Fxe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.input;
    var a = n.data.get(r.dataId).complexTensorInfos.imag;
    var i = n.data.get(a.dataId).values;
    return n.makeTensorInfo(a.shape, a.dtype, i);
  }
  var Dxe = {
    kernelName: V1,
    backendName: "cpu",
    kernelFunc: Fxe
  };
  function Mxe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = j$(e.attrs.axis, t[0].shape)[0];
    iie(t.map(function (e) {
      return e.shape;
    }), r);
    var a = oie(t.map(function (e) {
      return e.shape;
    }), r);
    if (L$(a) === 0) {
      return n.makeTensorInfo(a, t[0].dtype, []);
    }
    var i = t.filter(function (e) {
      return L$(e.shape) > 0;
    });
    if (i.length === 1) {
      return dge({
        inputs: {
          x: i[0]
        },
        backend: n
      });
    }
    if (i[0].dtype === "complex64") {
      var o = i.map(function (e) {
        return mge({
          inputs: {
            input: e
          },
          backend: n
        });
      });
      var s = i.map(function (e) {
        return Fxe({
          inputs: {
            input: e
          },
          backend: n
        });
      });
      var u = Mxe({
        inputs: o,
        backend: n,
        attrs: {
          axis: r
        }
      });
      var c = Mxe({
        inputs: s,
        backend: n,
        attrs: {
          axis: r
        }
      });
      var l = hge({
        inputs: {
          real: u,
          imag: c
        },
        backend: n
      });
      o.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      s.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      n.disposeIntermediateTensorInfo(u);
      n.disposeIntermediateTensorInfo(c);
      return l;
    }
    var h = i.map(function (e) {
      var t = L$(e.shape.slice(r));
      return Xbe({
        inputs: {
          x: e
        },
        backend: n,
        attrs: {
          shape: [-1, t]
        }
      });
    });
    var p = h.map(function (e) {
      return {
        vals: n.data.get(e.dataId).values,
        shape: e.shape
      };
    });
    a = oie(h.map(function (e) {
      return e.shape;
    }), 1);
    var f = h[0].shape[0] === 1;
    var d = Pge(p, a, t[0].dtype, f);
    var v = oie(i.map(function (e) {
      return e.shape;
    }), r);
    var m = n.makeTensorInfo(v, t[0].dtype, d);
    h.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    });
    return m;
  }
  var Lxe = {
    kernelName: $0,
    backendName: "cpu",
    kernelFunc: Mxe
  };
  function zxe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = t.filter;
    var o = r.strides;
    var s = r.pad;
    var u = r.dataFormat;
    var c = r.dilations;
    var l = r.dimRoundingMode;
    ige([a, i], "conv2d");
    var h = q8(u);
    for (var p = D8(a.shape, i.shape, o, c, s, l, false, h), f = p.filterHeight, d = p.filterWidth, v = p.dilationHeight, m = p.dilationWidth, g = p.padInfo.left, y = p.padInfo.top, b = p.dataFormat === "channelsLast", x = new $4(p.outShape, a.dtype), k = i0(a.shape), w = i0(i.shape), I = k[0], N = b ? k[1] : k[2], S = b ? k[2] : 1, T = b ? 1 : k[1], E = x.strides[0], C = b ? x.strides[1] : x.strides[2], A = b ? x.strides[2] : 1, R = b ? 1 : x.strides[1], _ = n.data.get(a.dataId).values, O = n.data.get(i.dataId).values, F = x.values, D = 0; D < p.batchSize; ++D) {
      var M = D * I;
      var L = D * E;
      for (var z = 0; z < p.outHeight; ++z) {
        var P = L + z * C;
        var B = z * p.strideHeight - y;
        for (var W = 0; W < f; ++W) {
          var U = B + W * v;
          if (!(U < 0) && !(U >= p.inHeight)) {
            var V = W * w[0];
            var G = M + U * N;
            for (var j = 0; j < p.outWidth; ++j) {
              var H = P + j * A;
              var q = j * p.strideWidth - g;
              for (var K = 0; K < d; ++K) {
                var X = q + K * m;
                if (!(X < 0) && !(X >= p.inWidth)) {
                  var Y = G + X * S;
                  var J = V + K * w[1];
                  for (var Z = 0; Z < p.inChannels; ++Z) {
                    var Q = _[Y + Z * T];
                    for (var $ = 0; $ < p.outChannels; ++$) {
                      F[H + $ * R] += Q * O[J + $];
                    }
                    J += p.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }
    return n.makeTensorInfo(x.shape, x.dtype, F);
  }
  var Pxe = {
    kernelName: e1,
    backendName: "cpu",
    kernelFunc: zxe
  };
  var Bxe = {
    kernelName: t1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.dy;
      var o = r.strides;
      var s = r.pad;
      var u = r.dataFormat;
      var c = r.dimRoundingMode;
      var l = r.filterShape;
      ige([a, i], "conv2dBackpropFilter");
      var h = q8(u);
      var p = D8(a.shape, l, o, 1, s, c, false, h);
      var f = p.strideHeight;
      var d = p.strideWidth;
      for (var v = p.filterHeight, m = p.filterWidth, g = p.dataFormat === "channelsLast", y = new $4(p.filterShape, "float32"), b = p.padInfo.left, x = p.padInfo.top, k = n.data.get(a.dataId).values, w = n.data.get(i.dataId).values, I = new $4(a.shape, a.dtype, k), N = new $4(i.shape, i.dtype, w), S = 0; S < v; ++S) {
        var T = Math.max(0, Math.ceil((x - S) / f));
        var E = Math.min(p.outHeight, (p.inHeight + x - S) / f);
        for (var C = 0; C < m; ++C) {
          var A = Math.max(0, Math.ceil((b - C) / d));
          var R = Math.min(p.outWidth, (p.inWidth + b - C) / d);
          for (var _ = 0; _ < p.inChannels; ++_) {
            for (var O = 0; O < p.outChannels; ++O) {
              var F = 0;
              for (var D = 0; D < p.batchSize; ++D) {
                for (var M = T; M < E; ++M) {
                  var L = S + M * f - x;
                  for (var z = A; z < R; ++z) {
                    var P = C + z * d - b;
                    F += g ? I.get(D, L, P, _) * N.get(D, M, z, O) : I.get(D, _, L, P) * N.get(D, O, M, z);
                  }
                }
              }
              y.set(F, S, C, _, O);
            }
          }
        }
      }
      return n.makeTensorInfo(y.shape, y.dtype, y.values);
    }
  };
  var Wxe = {
    kernelName: n1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.filter;
      var o = r.inputShape;
      var s = r.strides;
      var u = r.pad;
      var c = r.dataFormat;
      var l = r.dimRoundingMode;
      ige([a, i], "conv2dBackpropInput");
      var h = i0(i.shape);
      var p = i0(a.shape);
      var f = q8(c);
      var d = D8(o, i.shape, s, 1, u, l, false, f);
      var v = new $4(d.inShape, "float32");
      var m = v.values;
      var g = n.data.get(a.dataId).values;
      var y = n.data.get(i.dataId).values;
      var b = S(h, 3);
      var x = b[0];
      var k = b[1];
      var w = b[2];
      var I = d.batchSize;
      var N = d.filterHeight;
      var T = d.filterWidth;
      var E = d.inChannels;
      var C = d.inHeight;
      var A = d.inWidth;
      var R = d.outChannels;
      var _ = d.outHeight;
      var O = d.outWidth;
      var F = d.strideHeight;
      var D = d.strideWidth;
      f = d.dataFormat;
      var M = N - 1 - d.padInfo.top;
      var L = T - 1 - d.padInfo.left;
      var z = f === "channelsLast";
      var P = v.strides[0];
      var B = z ? v.strides[1] : v.strides[2];
      var W = z ? v.strides[2] : 1;
      var U = z ? 1 : v.strides[1];
      var V = p[0];
      var G = z ? p[1] : p[2];
      var j = z ? p[2] : 1;
      var H = z ? 1 : p[1];
      for (var q = 0; q < I; ++q) {
        for (var K = 0; K < E; ++K) {
          for (var X = 0; X < C; ++X) {
            var Y = X - M;
            var J = Math.max(0, Math.ceil(Y / F));
            var Z = Math.min(_, (N + Y) / F);
            for (var Q = 0; Q < A; ++Q) {
              var $ = Q - L;
              var ee = Math.max(0, Math.ceil($ / D));
              var te = Math.min(O, (T + $) / D);
              var ne = 0;
              for (var re = J; re < Z; ++re) {
                var ae = re * F - Y;
                for (var ie = ee; ie < te; ++ie) {
                  var oe = V * q + G * re + j * ie;
                  var se = x * (N - 1 - ae) + k * (T - 1 - (ie * D - $)) + w * K;
                  for (var ue = 0; ue < R; ++ue) {
                    ne += g[oe + H * ue] * y[se + ue];
                  }
                }
              }
              m[P * q + B * X + W * Q + U * K] = ne;
            }
          }
        }
      }
      return n.makeTensorInfo(v.shape, v.dtype, v.values);
    }
  };
  var Uxe = {
    kernelName: r1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = r.strides;
      var s = r.pad;
      var u = r.dilations;
      ige([a, i], "conv3d");
      for (var c = M8(a.shape, i.shape, o, u, s), l = c.filterDepth, h = c.filterHeight, p = c.filterWidth, f = c.dilationDepth, d = c.dilationHeight, v = c.dilationWidth, m = c.padInfo, g = m.front, y = m.left, b = m.top, x = new $4(c.outShape, a.dtype), k = n.data.get(a.dataId).values, w = n.data.get(i.dataId).values, I = x.values, N = i0(a.shape), S = i0(i.shape), T = 0; T < c.batchSize; ++T) {
        var E = T * N[0];
        var C = T * x.strides[0];
        for (var A = 0; A < c.outDepth; ++A) {
          var R = C + A * x.strides[1];
          var _ = A * c.strideDepth - g;
          for (var O = 0; O < l; ++O) {
            var F = _ + O * f;
            if (!(F < 0) && !(F >= c.inDepth)) {
              var D = O * S[0];
              var M = E + F * N[1];
              for (var L = 0; L < c.outHeight; ++L) {
                var z = R + L * x.strides[2];
                var P = L * c.strideHeight - b;
                for (var B = 0; B < h; ++B) {
                  var W = P + B * d;
                  if (!(W < 0) && !(W >= c.inHeight)) {
                    var U = D + B * S[1];
                    var V = M + W * N[2];
                    for (var G = 0; G < c.outWidth; ++G) {
                      var j = z + G * c.outChannels;
                      var H = G * c.strideWidth - y;
                      for (var q = 0; q < p; ++q) {
                        var K = H + q * v;
                        if (!(K < 0) && !(K >= c.inWidth)) {
                          var X = U + q * S[2];
                          var Y = V + K * c.inChannels;
                          var J = X;
                          for (var Z = 0; Z < c.inChannels; ++Z) {
                            var Q = k[Y + Z];
                            for (var $ = 0; $ < c.outChannels; ++$) {
                              I[j + $] += Q * w[J + $];
                            }
                            J += c.outChannels;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return n.makeTensorInfo(x.shape, x.dtype, x.values);
    }
  };
  var Vxe = {
    kernelName: a1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.dy;
      var o = r.strides;
      var s = r.pad;
      var u = r.filterShape;
      ige([a, i], "conv3dBackpropFilterV2");
      var c = i0(a.shape);
      var l = i0(i.shape);
      var h = M8(a.shape, u, o, 1, s);
      var p = h.strideDepth;
      var f = h.strideHeight;
      var d = h.strideWidth;
      for (var v = h.filterDepth, m = h.filterHeight, g = h.filterWidth, y = new $4(h.filterShape, "float32"), b = y.values, x = S(y.strides, 4), k = x[0], w = x[1], I = x[2], N = x[3], T = n.data.get(i.dataId).values, E = S(l, 4), C = E[0], A = E[1], R = E[2], _ = E[3], O = n.data.get(a.dataId).values, F = S(c, 4), D = F[0], M = F[1], L = F[2], z = F[3], P = h.padInfo.front, B = h.padInfo.left, W = h.padInfo.top, U = 0; U < v; ++U) {
        var V = Math.max(0, Math.ceil((P - U) / p));
        var G = Math.min(h.outDepth, (h.inDepth + P - U) / p);
        var j = U * k;
        for (var H = 0; H < m; ++H) {
          var q = Math.max(0, Math.ceil((W - H) / f));
          var K = Math.min(h.outHeight, (h.inHeight + W - H) / f);
          var X = H * w + j;
          for (var Y = 0; Y < g; ++Y) {
            var J = Math.max(0, Math.ceil((B - Y) / d));
            var Z = Math.min(h.outWidth, (h.inWidth + B - Y) / d);
            var Q = Y * I + X;
            for (var $ = 0; $ < h.inChannels; ++$) {
              var ee = $ * N + Q;
              for (var te = 0; te < h.outChannels; ++te) {
                var ne = 0;
                for (var re = 0; re < h.batchSize; ++re) {
                  var ae = re * D;
                  var ie = re * C;
                  for (var oe = V; oe < G; ++oe) {
                    var se = (U + oe * p - P) * M + ae;
                    var ue = oe * A + ie;
                    for (var ce = q; ce < K; ++ce) {
                      var le = (H + ce * f - W) * L + se;
                      var he = ce * R + ue;
                      for (var pe = J; pe < Z; ++pe) {
                        var fe = pe * _ + he;
                        ne += O[(Y + pe * d - B) * z + le + $] * T[fe + te];
                      }
                    }
                  }
                }
                b[ee + te] = ne;
              }
            }
          }
        }
      }
      return n.makeTensorInfo(y.shape, y.dtype, y.values);
    }
  };
  var Gxe = {
    kernelName: i1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.filter;
      var o = r.pad;
      var s = r.strides;
      var u = r.inputShape;
      ige([a], "conv3dBackpropInputV2");
      var c = i0(a.shape);
      var l = i0(i.shape);
      var h = M8(u, i.shape, s, 1, o);
      var p = new $4(h.inShape, "float32");
      var f = p.values;
      var d = S(p.strides, 4);
      var v = d[0];
      var m = d[1];
      var g = d[2];
      var y = d[3];
      var b = n.data.get(a.dataId).values;
      var x = S(c, 4);
      var k = x[0];
      var w = x[1];
      var I = x[2];
      var N = x[3];
      var T = n.data.get(i.dataId).values;
      var E = S(l, 4);
      var C = E[0];
      var A = E[1];
      var R = E[2];
      var _ = E[3];
      for (var O = h.batchSize, F = h.filterDepth, D = h.filterHeight, M = h.filterWidth, L = h.inChannels, z = h.inDepth, P = h.inHeight, B = h.inWidth, W = h.outChannels, U = h.outDepth, V = h.outHeight, G = h.outWidth, j = h.strideDepth, H = h.strideHeight, q = h.strideWidth, K = F - 1 - h.padInfo.front, X = D - 1 - h.padInfo.top, Y = M - 1 - h.padInfo.left, J = 0; J < O; ++J) {
        for (var Z = 0; Z < L; ++Z) {
          for (var Q = 0; Q < z; ++Q) {
            var $ = Q - K;
            var ee = Math.max(0, Math.ceil($ / j));
            var te = Math.min(U, (F + $) / j);
            for (var ne = 0; ne < P; ++ne) {
              var re = ne - X;
              var ae = Math.max(0, Math.ceil(re / H));
              var ie = Math.min(V, (D + re) / H);
              for (var oe = 0; oe < B; ++oe) {
                var se = oe - Y;
                var ue = Math.max(0, Math.ceil(se / q));
                var ce = Math.min(G, (M + se) / q);
                var le = 0;
                for (var he = ee; he < te; ++he) {
                  var pe = he * j - $;
                  for (var fe = ae; fe < ie; ++fe) {
                    var de = fe * H - re;
                    for (var ve = ue; ve < ce; ++ve) {
                      var me = k * J + w * he + I * fe + N * ve;
                      var ge = C * (F - 1 - pe) + A * (D - 1 - de) + R * (M - 1 - (ve * q - se)) + _ * Z;
                      for (var ye = 0; ye < W; ++ye) {
                        le += b[me + ye] * T[ge + ye];
                      }
                    }
                  }
                }
                f[v * J + m * Q + g * ne + y * oe + Z] = le;
              }
            }
          }
        }
      }
      return n.makeTensorInfo(p.shape, p.dtype, p.values);
    }
  };
  var jxe = Fge(o1, function (e) {
    return Math.cos(e);
  });
  var Hxe = {
    kernelName: o1,
    backendName: "cpu",
    kernelFunc: jxe
  };
  var qxe = Fge(s1, function (e) {
    return Math.cosh(e);
  });
  var Kxe = {
    kernelName: s1,
    backendName: "cpu",
    kernelFunc: qxe
  };
  var Xxe = {
    kernelName: l1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.image;
      var i = t.boxes;
      var o = t.boxInd;
      var s = r.cropSize;
      var u = r.method;
      var c = r.extrapolationValue;
      var l = S(a.shape, 4);
      var h = l[0];
      var p = l[1];
      var f = l[2];
      var d = l[3];
      for (var v = i.shape[0], m = S(s, 2), g = m[0], y = m[1], b = l8([v, g, y, d], "float32"), x = n.data.get(i.dataId).values, k = n.data.get(o.dataId).values, w = n.data.get(a.dataId).values, I = i0(a.shape), N = i0(b.shape), T = 0; T < v; T++) {
        var E = T * 4;
        var C = x[E];
        var A = x[E + 1];
        var R = x[E + 2];
        var _ = x[E + 3];
        var O = k[T];
        if (!(O >= h)) {
          var F = g > 1 ? (R - C) * (p - 1) / (g - 1) : 0;
          var D = y > 1 ? (_ - A) * (f - 1) / (y - 1) : 0;
          for (var M = 0; M < g; M++) {
            var L = g > 1 ? C * (p - 1) + M * F : (C + R) * 0.5 * (p - 1);
            if (L < 0 || L > p - 1) {
              for (var z = 0; z < y; z++) {
                for (var P = 0; P < d; P++) {
                  var B = P + z * N[2] + M * N[1] + T * N[0];
                  b.values[B] = c;
                }
              }
            } else if (u === "bilinear") {
              var W = Math.floor(L);
              var U = Math.ceil(L);
              var V = L - W;
              for (var G = 0; G < y; G++) {
                var j = y > 1 ? A * (f - 1) + G * D : (A + _) * 0.5 * (f - 1);
                if (j < 0 || j > f - 1) {
                  for (var H = 0; H < d; H++) {
                    var q = H + G * N[2] + M * N[1] + T * N[0];
                    b.values[q] = c;
                  }
                } else {
                  var K = Math.floor(j);
                  var X = Math.ceil(j);
                  var Y = j - K;
                  for (var J = 0; J < d; J++) {
                    var Z = J + K * I[2] + W * I[1] + O * I[0];
                    var Q = w[Z];
                    var $ = w[Z = J + X * I[2] + W * I[1] + O * I[0]];
                    var ee = w[Z = J + K * I[2] + U * I[1] + O * I[0]];
                    var te = Q + ($ - Q) * Y;
                    var ne = ee + (w[Z = J + X * I[2] + U * I[1] + O * I[0]] - ee) * Y;
                    Z = J + G * N[2] + M * N[1] + T * N[0];
                    b.values[Z] = te + (ne - te) * V;
                  }
                }
              }
            } else {
              for (var re = 0; re < y; ++re) {
                var ae = y > 1 ? A * (f - 1) + re * D : (A + _) * 0.5 * (f - 1);
                if (ae < 0 || ae > f - 1) {
                  for (var ie = 0; ie < d; ie++) {
                    var oe = ie + re * N[2] + M * N[1] + T * N[0];
                    b.values[oe] = c;
                  }
                } else {
                  var se = Math.round(ae);
                  var ue = Math.round(L);
                  for (var ce = 0; ce < d; ce++) {
                    var le = ce + se * I[2] + ue * I[1] + O * I[0];
                    var he = ce + re * N[2] + M * N[1] + T * N[0];
                    b.values[he] = w[le];
                  }
                }
              }
            }
          }
        }
      }
      return n.makeTensorInfo(b.shape, b.dtype, b.values);
    }
  };
  var Yxe = {
    kernelName: u1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.exclusive;
      var s = r.reverse;
      ige(a, "cumprod");
      var u = $7([i], a.shape.length);
      var c = a;
      if (u != null) {
        c = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: u
          }
        });
      }
      var l = t9(1, a.shape.length)[0];
      if (l !== c.shape.length - 1) {
        throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length - 1} but got axis=${l}`);
      }
      var h = h5(c.dtype, "int32");
      var p = c0(L$(c.shape), h);
      for (var f = n.data.get(c.dataId).values, d = c.shape[c.shape.length - 1], v = s ? function (e, t) {
          return e + d - t - 1;
        } : function (e, t) {
          return e + t;
        }, m = 0; m < f.length; m += d) {
        for (var g = 0; g < d; g++) {
          var y = v(m, g);
          if (g === 0) {
            p[y] = o ? 1 : f[y];
          } else {
            var b = v(m, g - 1);
            p[y] = o ? f[b] * p[b] : f[y] * p[b];
          }
        }
      }
      var x = n.makeTensorInfo(c.shape, h, p);
      if (u != null) {
        var k = Mye({
          inputs: {
            x: x
          },
          backend: n,
          attrs: {
            perm: e9(u)
          }
        });
        n.disposeIntermediateTensorInfo(x);
        n.disposeIntermediateTensorInfo(c);
        return k;
      }
      return x;
    }
  };
  var Jxe = {
    kernelName: c1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.exclusive;
      var s = r.reverse;
      ige(a, "cumsum");
      var u = $7([i], a.shape.length);
      var c = a;
      if (u != null) {
        c = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: u
          }
        });
      }
      var l = t9(1, a.shape.length)[0];
      if (l !== c.shape.length - 1) {
        throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length - 1} but got axis=${l}`);
      }
      var h = h5(c.dtype, "int32");
      var p = l0(L$(c.shape), h);
      for (var f = n.data.get(c.dataId).values, d = c.shape[c.shape.length - 1], v = s ? function (e, t) {
          return e + d - t - 1;
        } : function (e, t) {
          return e + t;
        }, m = 0; m < f.length; m += d) {
        for (var g = 0; g < d; g++) {
          var y = v(m, g);
          if (g === 0) {
            p[y] = o ? 0 : f[y];
          } else {
            var b = v(m, g - 1);
            p[y] = o ? f[b] + p[b] : f[y] + p[b];
          }
        }
      }
      var x = n.makeTensorInfo(c.shape, h, p);
      if (u != null) {
        var k = Mye({
          inputs: {
            x: x
          },
          backend: n,
          attrs: {
            perm: e9(u)
          }
        });
        n.disposeIntermediateTensorInfo(x);
        n.disposeIntermediateTensorInfo(c);
        return k;
      }
      return x;
    }
  };
  var Zxe = {
    kernelName: h1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.weights;
      var o = r.size;
      var s = r.binaryOutput;
      if (a.shape.length === 1) {
        var u = Ege(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
        return n.makeTensorInfo([o], i.dtype, u);
      }
      if (a.shape.length === 2) {
        var c = Cge(n.bufferSync(a), n.bufferSync(i), o, s);
        return n.makeTensorInfo(c.shape, i.dtype, c.values);
      }
      throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`);
    }
  };
  var Qxe = {
    kernelName: p1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.blockSize;
      var o = r.dataFormat;
      F$(o === "NHWC", function () {
        return `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`;
      });
      for (var s = a.shape[0], u = a.shape[1], c = a.shape[2], l = a.shape[3], h = u * i, p = c * i, f = l / (i * i), d = n.data.get(a.dataId).values, v = new Float32Array(s * h * p * f), m = 0, g = 0; g < s; ++g) {
        for (var y = 0; y < h; ++y) {
          var b = Math.floor(y / i);
          var x = y % i;
          for (var k = 0; k < p; ++k) {
            var w = Math.floor(k / i);
            var I = (x * i + k % i) * f;
            for (var N = 0; N < f; ++N) {
              var S = N + I + l * (w + c * (b + u * g));
              v[m++] = d[S];
            }
          }
        }
      }
      return n.makeTensorInfo([s, h, p, f], a.dtype, v);
    }
  };
  function $xe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = t.filter;
    var o = r.strides;
    var s = r.pad;
    var u = r.dilations;
    var c = r.dimRoundingMode;
    ige([a, i], "depthwiseConv2DNative");
    var l = i0(a.shape);
    var h = i0(i.shape);
    var p = u;
    if (p == null) {
      p = [1, 1];
    }
    F$(j8(o, p), function () {
      return `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`;
    });
    for (var f = D8(a.shape, i.shape, o, p, s, c, true), d = f.filterHeight, v = f.filterWidth, m = f.dilationHeight, g = f.dilationWidth, y = f.padInfo, b = y.left, x = y.top, k = f.outChannels / f.inChannels, w = new $4(f.outShape, a.dtype), I = n.data.get(a.dataId).values, N = n.data.get(i.dataId).values, S = w.values, T = 0; T < f.batchSize; ++T) {
      var E = T * l[0];
      var C = T * w.strides[0];
      for (var A = 0; A < f.outHeight; ++A) {
        var R = C + A * w.strides[1];
        var _ = A * f.strideHeight - x;
        for (var O = 0; O < d; ++O) {
          var F = _ + O * m;
          if (!(F < 0) && !(F >= f.inHeight)) {
            var D = O * h[0];
            var M = E + F * l[1];
            for (var L = 0; L < f.outWidth; ++L) {
              var z = R + L * w.strides[2];
              var P = L * f.strideWidth - b;
              for (var B = 0; B < v; ++B) {
                var W = P + B * g;
                if (!(W < 0) && !(W >= f.inWidth)) {
                  var U = D + B * h[1];
                  var V = M + W * f.inChannels;
                  var G = z;
                  var j = U;
                  for (var H = 0; H < f.inChannels; ++H) {
                    var q = I[V + H];
                    for (var K = 0; K < k; ++K) {
                      S[G + K] += q * N[j + K];
                    }
                    G += k;
                    j += k;
                  }
                }
              }
            }
          }
        }
      }
    }
    return n.makeTensorInfo(w.shape, w.dtype, w.values);
  }
  var eke = {
    kernelName: f1,
    backendName: "cpu",
    kernelFunc: $xe
  };
  var tke = {
    kernelName: d1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.dy;
      var o = r.strides;
      var s = r.dilations;
      var u = r.pad;
      var c = r.dimRoundingMode;
      var l = r.filterShape;
      ige([a, i], "depthwiseConv2dNativeBackpropFilter");
      var h = D8(a.shape, l, o, s, u, c, true);
      var p = h.strideHeight;
      var f = h.strideWidth;
      for (var d = h.filterHeight, v = h.filterWidth, m = new $4(h.filterShape, "float32"), g = h.padInfo.left, y = h.padInfo.top, b = h.outChannels / h.inChannels, x = n.data.get(a.dataId).values, k = new $4(a.shape, a.dtype, x), w = n.data.get(i.dataId).values, I = new $4(i.shape, i.dtype, w), N = 0; N < d; ++N) {
        var S = Math.max(0, Math.ceil((y - N) / p));
        var T = Math.min(h.outHeight, (h.inHeight + y - N) / p);
        for (var E = 0; E < v; ++E) {
          var C = Math.max(0, Math.ceil((g - E) / f));
          var A = Math.min(h.outWidth, (h.inWidth + g - E) / f);
          for (var R = 0; R < h.outChannels; ++R) {
            var _ = Math.trunc(R / b);
            var O = R % b;
            var F = 0;
            for (var D = 0; D < h.batchSize; ++D) {
              for (var M = S; M < T; ++M) {
                var L = N + M * p - y;
                for (var z = C; z < A; ++z) {
                  var P = E + z * f - g;
                  F += k.get(D, L, P, _) * I.get(D, M, z, R);
                }
              }
            }
            m.set(F, N, E, _, O);
          }
        }
      }
      return n.makeTensorInfo(m.shape, m.dtype, m.values);
    }
  };
  var nke = {
    kernelName: v1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.filter;
      var o = r.strides;
      var s = r.dilations;
      var u = r.pad;
      var c = r.dimRoundingMode;
      var l = r.inputShape;
      ige([a, i], "depthwiseConv2DNativeBackpropInput");
      var h = i0(a.shape);
      var p = i0(i.shape);
      var f = D8(l, i.shape, o, s, u, c, true);
      var d = new $4(f.inShape, "float32");
      var v = d.values;
      var m = S(d.strides, 3);
      var g = m[0];
      var y = m[1];
      var b = m[2];
      var x = n.data.get(a.dataId).values;
      var k = S(h, 3);
      var w = k[0];
      var I = k[1];
      var N = k[2];
      var T = n.data.get(i.dataId).values;
      var E = S(p, 3);
      var C = E[0];
      var A = E[1];
      var R = E[2];
      for (var _ = f.batchSize, O = f.filterHeight, F = f.filterWidth, D = f.inChannels, M = f.inHeight, L = f.inWidth, z = f.outChannels, P = f.outHeight, B = f.outWidth, W = f.strideHeight, U = f.strideWidth, V = O - 1 - f.padInfo.top, G = F - 1 - f.padInfo.left, j = z / D, H = 0; H < _; ++H) {
        for (var q = 0; q < D; ++q) {
          for (var K = 0; K < M; ++K) {
            var X = K - V;
            var Y = Math.max(0, Math.ceil(X / W));
            var J = Math.min(P, (O + X) / W);
            for (var Z = 0; Z < L; ++Z) {
              var Q = Z - G;
              var $ = Math.max(0, Math.ceil(Q / U));
              var ee = Math.min(B, (F + Q) / U);
              var te = 0;
              for (var ne = Y; ne < J; ++ne) {
                var re = ne * W - X;
                for (var ae = $; ae < ee; ++ae) {
                  var ie = w * H + I * ne + N * ae;
                  var oe = C * (O - 1 - re) + A * (F - 1 - (ae * U - Q)) + R * q;
                  for (var se = 0; se < j; ++se) {
                    te += x[ie + (q * j + se)] * T[oe + se];
                  }
                }
              }
              v[g * H + y * K + b * Z + q] = te;
            }
          }
        }
      }
      return n.makeTensorInfo(d.shape, d.dtype, d.values);
    }
  };
  var rke = {
    kernelName: m1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.x;
      var a = L$(r.shape);
      for (var i = n.data.get(r.dataId).values, o = l8([a, a], r.dtype), s = o.values, u = 0; u < i.length; u++) {
        s[u * a + u] = i[u];
      }
      var c = [].concat(T(r.shape), T(r.shape));
      return n.makeTensorInfo(c, o.dtype, o.values);
    }
  };
  var ake = {
    kernelName: g1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = r.strides;
      var s = r.pad;
      var u = r.dilations;
      var c = n;
      var l = c.data.get(a.dataId).values;
      var h = a.shape.length;
      var p = c.data.get(i.dataId).values;
      var f = i.shape.length;
      var d = _8(a.shape, i.shape, o, s, "NHWC", u);
      for (var v = d.batchSize, m = d.inHeight, g = d.inWidth, y = d.inChannels, b = d.outHeight, x = d.outWidth, k = d.padInfo, w = d.strideHeight, I = d.strideWidth, N = d.filterHeight, S = d.filterWidth, T = d.dilationHeight, E = d.dilationWidth, C = d.outShape, A = L$(C), R = C.length, _ = K$(a.dtype, A), O = 0; O < v; ++O) {
        for (var F = 0; F < b; ++F) {
          var D = F * w - k.top;
          for (var M = 0; M < x; ++M) {
            var L = M * I - k.left;
            for (var z = 0; z < y; ++z) {
              var P = Number.MIN_SAFE_INTEGER;
              for (var B = 0; B < N; ++B) {
                var W = D + B * T;
                if (W >= 0 && W < m) {
                  for (var U = 0; U < S; ++U) {
                    var V = L + U * E;
                    if (V >= 0 && V < g) {
                      var G = f0([O, W, V, z], h, i0(a.shape));
                      var j = f0([B, U, z], f, i0(i.shape));
                      var H = l[G] + p[j];
                      if (H > P) {
                        P = H;
                      }
                    }
                  }
                }
              }
              _[f0([O, F, M, z], R, i0(C))] = P;
            }
          }
        }
      }
      return {
        dataId: c.write(L4(_, a.dtype), C, a.dtype),
        shape: C,
        dtype: a.dtype
      };
    }
  };
  var ike = {
    kernelName: b1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = t.dy;
      var s = r.strides;
      var u = r.pad;
      var c = r.dilations;
      var l = n;
      var h = s0(a.shape, l.data.get(a.dataId).values);
      var p = s0(i.shape, l.data.get(i.dataId).values);
      var f = _8(a.shape, i.shape, s, u, "NHWC", c);
      var d = f.batchSize;
      var v = f.inHeight;
      var m = f.inWidth;
      var g = f.inChannels;
      var y = f.outHeight;
      var b = f.outWidth;
      var x = f.padInfo;
      var k = f.strideHeight;
      var w = f.strideWidth;
      var I = f.filterHeight;
      var N = f.filterWidth;
      var S = f.dilationHeight;
      var T = f.dilationWidth;
      var E = f.outShape;
      F$(o.rank === E.length, function () {
        return `Error in ${b1}, dy must have the same rank as output ${E.length}, but got ${o.rank}`;
      });
      var C = s0(E, l.data.get(o.dataId).values);
      var A = h0(i.shape, i.dtype);
      for (var R = 0; R < d; ++R) {
        for (var _ = 0; _ < y; ++_) {
          var O = _ * k - x.top;
          for (var F = 0; F < b; ++F) {
            var D = F * w - x.left;
            for (var M = 0; M < g; ++M) {
              var L = Number.MIN_SAFE_INTEGER;
              var z = 0;
              var P = 0;
              for (var B = 0; B < I; ++B) {
                var W = O + B * S;
                if (W >= 0 && W < v) {
                  for (var U = 0; U < N; ++U) {
                    var V = D + U * T;
                    if (V >= 0 && V < m) {
                      var G = h[R][W][V][M] + p[B][U][M];
                      if (G > L) {
                        L = G;
                        z = B;
                        P = U;
                      }
                    }
                  }
                }
              }
              A[z][P][M] += C[R][_][F][M];
            }
          }
        }
      }
      return {
        dataId: l.write(L4(A, a.dtype), i.shape, i.dtype),
        shape: i.shape,
        dtype: i.dtype
      };
    }
  };
  var oke = {
    kernelName: y1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = t.dy;
      var s = r.strides;
      var u = r.pad;
      var c = r.dilations;
      var l = n;
      var h = s0(a.shape, l.data.get(a.dataId).values);
      var p = s0(i.shape, l.data.get(i.dataId).values);
      var f = _8(a.shape, i.shape, s, u, "NHWC", c);
      var d = f.batchSize;
      var v = f.inHeight;
      var m = f.inWidth;
      var g = f.inChannels;
      var y = f.outHeight;
      var b = f.outWidth;
      var x = f.padInfo;
      var k = f.strideHeight;
      var w = f.strideWidth;
      var I = f.filterHeight;
      var N = f.filterWidth;
      var S = f.dilationHeight;
      var T = f.dilationWidth;
      var E = f.outShape;
      F$(o.rank === E.length, function () {
        return `Error in ${y1}, dy must have the same rank as output ${E.length}, but got ${o.rank}`;
      });
      var C = s0(E, l.data.get(o.dataId).values);
      var A = h0(a.shape, a.dtype);
      for (var R = 0; R < d; ++R) {
        for (var _ = 0; _ < y; ++_) {
          var O = _ * k - x.top;
          for (var F = 0; F < b; ++F) {
            var D = F * w - x.left;
            for (var M = 0; M < g; ++M) {
              var L = Number.MIN_SAFE_INTEGER;
              var z = O < 0 ? 0 : O;
              var P = D < 0 ? 0 : D;
              for (var B = 0; B < I; ++B) {
                var W = O + B * S;
                if (W >= 0 && W < v) {
                  for (var U = 0; U < N; ++U) {
                    var V = D + U * T;
                    if (V >= 0 && V < m) {
                      var G = h[R][W][V][M] + p[B][U][M];
                      if (G > L) {
                        L = G;
                        z = W;
                        P = V;
                      }
                    }
                  }
                }
              }
              A[R][z][P][M] += C[R][_][F][M];
            }
          }
        }
      }
      return {
        dataId: l.write(L4(A, a.dtype), a.shape, a.dtype),
        shape: a.shape,
        dtype: a.dtype
      };
    }
  };
  var ske = {
    kernelName: x1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.image;
      var i = r.canvas;
      var o = r.options || {};
      var s = o.contextOptions;
      var u = o.imageOptions;
      var c = (u == null ? undefined : u.alpha) || 1;
      var l = (s == null ? undefined : s.contextType) || "2d";
      if (l !== "2d") {
        throw new Error(`Context type ${s.contextType} is not supported by the CPU backend.`);
      }
      var h = i.getContext(l, (s == null ? undefined : s.contextAttributes) || {});
      if (h == null) {
        throw new Error(`Could not get the context with ${l} type.`);
      }
      var p = S(a.shape.slice(0, 2), 2);
      for (var f = p[0], d = p[1], v = a.shape.length === 2 ? 1 : a.shape[2], m = n.data.get(a.dataId).values, g = a.dtype === "float32" ? 255 : 1, y = new Uint8ClampedArray(d * f * 4), b = 0; b < f * d; ++b) {
        var x = [0, 0, 0, c * 255];
        for (var k = 0; k < v; k++) {
          var w = m[b * v + k];
          if (a.dtype === "float32") {
            if (w < 0 || w > 1) {
              throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${w}.`);
            }
          } else if (a.dtype === "int32" && (w < 0 || w > 255)) {
            throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${w}.`);
          }
          if (v === 1) {
            x[0] = w * g;
            x[1] = w * g;
            x[2] = w * g;
          } else {
            x[k] = w * g;
          }
        }
        var I = b * 4;
        y[I + 0] = Math.round(x[0]);
        y[I + 1] = Math.round(x[1]);
        y[I + 2] = Math.round(x[2]);
        y[I + 3] = Math.round(x[3]);
      }
      i.width = d;
      i.height = f;
      var N = new ImageData(y, d, f);
      h.putImageData(N, 0, 0);
      return a;
    }
  };
  function uke(e) {
    var t;
    var n = e.inputs;
    var r = e.backend;
    var a = e.attrs;
    var i = n.x;
    var o = a.axis;
    var s = a.keepDims;
    ige(i, "sum");
    var u = (t = i.dtype === "bool" ? bge({
      inputs: {
        x: i
      },
      backend: r,
      attrs: {
        dtype: "int32"
      }
    }) : dge({
      inputs: {
        x: i
      },
      backend: r
    })).shape.length;
    var c = j$(o, t.shape);
    var l = $7(c, u);
    var h = c;
    var p = t;
    if (l != null) {
      p = Mye({
        inputs: {
          x: t
        },
        backend: r,
        attrs: {
          perm: l
        }
      });
      h = t9(h.length, u);
    }
    Q7("sum", h, p.shape.length);
    var f = S(J7(p.shape, h), 2);
    var d = f[0];
    var v = f[1];
    var m = fge(r, d, h5(p.dtype, "int32"));
    var g = L$(v);
    for (var y = r.data.get(m.dataId).values, b = r.data.get(p.dataId).values, x = 0; x < y.length; ++x) {
      var k = x * g;
      var w = 0;
      for (var I = 0; I < g; ++I) {
        w += b[k + I];
      }
      y[x] = w;
    }
    if (s) {
      var N = m;
      m = Xbe({
        inputs: {
          x: m
        },
        backend: r,
        attrs: {
          shape: Z7(m.shape, c)
        }
      });
      r.disposeIntermediateTensorInfo(N);
    }
    r.disposeIntermediateTensorInfo(t);
    if (l != null) {
      r.disposeIntermediateTensorInfo(p);
    }
    return m;
  }
  var cke = {
    kernelName: a3,
    backendName: "cpu",
    kernelFunc: uke
  };
  var lke = {
    kernelName: w1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t;
      var a = Lie(e.attrs.equation, r.length);
      var i = a.allDims;
      var o = a.summedDims;
      var s = a.idDims;
      Pie(i.length, s, r);
      var u = Bie(o, s);
      var c = u.path;
      var l = u.steps;
      for (var h = l.length, p = null, f = i.length, d = [], v = 0; v < h; ++v) {
        var m;
        var g = O(l[v]);
        try {
          for (g.s(); !(m = g.n()).done;) {
            var y = m.value;
            var b = zie(f, s[y]);
            var x = b.permutationIndices;
            var k = b.expandDims;
            var w = undefined;
            if (Wie(x)) {
              w = r[y];
            } else {
              w = Mye({
                inputs: {
                  x: r[y]
                },
                backend: n,
                attrs: {
                  perm: x
                }
              });
              d.push(w);
            }
            var I = w.shape.slice();
            for (var N = 0; N < k.length; ++N) {
              I.splice(k[N], 0, 1);
            }
            if (!P$(w.shape, I)) {
              w = Xbe({
                inputs: {
                  x: w
                },
                backend: n,
                attrs: {
                  shape: I
                }
              });
              d.push(w);
            }
            if (p === null) {
              p = w;
            } else {
              p = Eye({
                inputs: {
                  a: w,
                  b: p
                },
                backend: n
              });
              d.push(p);
            }
          }
        } catch (e) {
          g.e(e);
        } finally {
          g.f();
        }
        if (v < h - 1) {
          if (c[v] >= 0) {
            p = uke({
              inputs: {
                x: p
              },
              backend: n,
              attrs: {
                axis: c[v] - (i.length - f),
                keepDims: false
              }
            });
            d.push(p);
          }
          f--;
        }
      }
      for (var S = 0, T = d; S < T.length; S++) {
        var E = T[S];
        if (E !== p) {
          n.disposeIntermediateTensorInfo(E);
        }
      }
      return p;
    }
  };
  var hke = {
    kernelName: N1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.dy;
      var a = t.y;
      ige([r, a], "eluGrad");
      var i = new Float32Array(L$(a.shape));
      for (var o = n.data.get(a.dataId).values, s = n.data.get(r.dataId).values, u = 0; u < o.length; ++u) {
        var c = o[u];
        i[u] = c >= 0 ? s[u] : s[u] * (c + 1);
      }
      return n.makeTensorInfo(a.shape, "float32", i);
    }
  };
  var pke = Fge(S1, function (e) {
    var t = Math.sign(e);
    var n = Math.abs(e);
    var r = 1 / (1 + n * 0.3275911);
    return t * (1 - ((((r * 1.061405429 - 1.453152027) * r + 1.421413741) * r - 0.284496736) * r + 0.254829592) * r * Math.exp(-n * n));
  });
  var fke = {
    kernelName: S1,
    backendName: "cpu",
    kernelFunc: pke
  };
  function dke(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.input;
    var i = r.dim;
    var o = a.shape.length;
    var s = a.shape.slice();
    var u = i;
    if (i < 0) {
      F$(-(o + 1) <= i, function () {
        return `Axis must be in the interval [${-(o + 1)}, ${o}]`;
      });
      u = o + i + 1;
    }
    s.splice(u, 0, 1);
    return Xbe({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: s
      }
    });
  }
  var vke = {
    kernelName: C1,
    backendName: "cpu",
    kernelFunc: dke
  };
  var mke = lge(function (e, t) {
    return e / t;
  });
  var gke = kge(k1, mke);
  var yke = {
    kernelName: k1,
    backendName: "cpu",
    kernelFunc: gke
  };
  function bke(e, t, n) {
    var r = e.shape;
    for (var a = r[0], i = r[1], o = n.data.get(e.dataId), s = o.complexTensorInfos.real, u = o.complexTensorInfos.imag, c = [a, i], l = L$(c), h = q$("float32", l), p = q$("float32", l), f = 0; f < a; f++) {
      var d = ibe({
        inputs: {
          x: s
        },
        backend: n,
        attrs: {
          begin: [f, 0],
          size: [1, i]
        }
      });
      var v = ibe({
        inputs: {
          x: u
        },
        backend: n,
        attrs: {
          begin: [f, 0],
          size: [1, i]
        }
      });
      var m = hge({
        inputs: {
          real: d,
          imag: v
        },
        backend: n
      });
      var g = xke(m, t, n);
      var y = Tie(g.real, g.imag);
      for (var b = 0; b < i; b++) {
        var x = Rie(y, b);
        h[f * i + b] = x.real;
        p[f * i + b] = x.imag;
      }
      n.disposeIntermediateTensorInfo(d);
      n.disposeIntermediateTensorInfo(v);
      n.disposeIntermediateTensorInfo(m);
    }
    var k = n.makeTensorInfo(c, "float32", h);
    var w = n.makeTensorInfo(c, "float32", p);
    var I = hge({
      inputs: {
        real: k,
        imag: w
      },
      backend: n
    });
    n.disposeIntermediateTensorInfo(k);
    n.disposeIntermediateTensorInfo(w);
    return I;
  }
  function xke(e, t, n) {
    var r = L$(e.shape);
    var a = n.data.get(e.dataId);
    var i = n.data.get(a.complexTensorInfos.real.dataId).values;
    var o = n.data.get(a.complexTensorInfos.imag.dataId).values;
    if (((g = r) & g - 1) == 0) {
      var s = kke(i, o, r, t, n);
      var u = [e.shape[0], e.shape[1]];
      if (t) {
        var c = n.makeTensorInfo(u, "float32", s.real);
        var l = n.makeTensorInfo(u, "float32", s.imag);
        var h = n.makeTensorInfo([], "float32", M4(r, "float32"));
        var p = dge({
          inputs: {
            x: h
          },
          backend: n
        });
        var f = yke.kernelFunc({
          inputs: {
            a: c,
            b: h
          },
          backend: n
        });
        var d = yke.kernelFunc({
          inputs: {
            a: l,
            b: p
          },
          backend: n
        });
        var v = n.data.get(f.dataId).values;
        var m = n.data.get(d.dataId).values;
        n.disposeIntermediateTensorInfo(c);
        n.disposeIntermediateTensorInfo(l);
        n.disposeIntermediateTensorInfo(h);
        n.disposeIntermediateTensorInfo(p);
        n.disposeIntermediateTensorInfo(f);
        n.disposeIntermediateTensorInfo(d);
        return {
          real: v,
          imag: m
        };
      }
      return s;
    }
    var g;
    var y = function (e, t, n) {
      var r = new Float32Array(t * 2);
      for (var a = 0; a < t; a++) {
        var i = 0;
        var o = 0;
        for (var s = 0; s < t; s++) {
          var u = Fie(a * s, t, n);
          var c = Rie(e, s);
          i += c.real * u.real - c.imag * u.imag;
          o += c.real * u.imag + c.imag * u.real;
        }
        if (n) {
          i /= t;
          o /= t;
        }
        _ie(r, i, o, a);
      }
      return r;
    }(Tie(i, o), r, t);
    return Eie(y);
  }
  function kke(e, t, n, r, a) {
    if (n === 1) {
      return {
        real: e,
        imag: t
      };
    }
    var i = Tie(e, t);
    var o = n / 2;
    var s = Cie(i);
    var u = s.real;
    var c = s.imag;
    var l = [u.length];
    var h = a.makeTensorInfo(l, "float32", u);
    var p = a.makeTensorInfo(l, "float32", c);
    var f = hge({
      inputs: {
        real: h,
        imag: p
      },
      backend: a
    });
    var d = Aie(i);
    var v = d.real;
    var m = d.imag;
    var g = [v.length];
    var y = a.makeTensorInfo(g, "float32", v);
    var b = a.makeTensorInfo(g, "float32", m);
    var x = hge({
      inputs: {
        real: y,
        imag: b
      },
      backend: a
    });
    var k = kke(u, c, o, r, a);
    var w = k.real;
    var I = k.imag;
    var N = [w.length];
    var S = a.makeTensorInfo(N, "float32", w);
    var T = a.makeTensorInfo(N, "float32", I);
    var E = hge({
      inputs: {
        real: S,
        imag: T
      },
      backend: a
    });
    var C = kke(v, m, o, r, a);
    var A = C.real;
    var R = C.imag;
    var _ = [A.length];
    var O = a.makeTensorInfo(_, "float32", A);
    var F = a.makeTensorInfo(_, "float32", R);
    var D = hge({
      inputs: {
        real: O,
        imag: F
      },
      backend: a
    });
    var M = Oie(n, r);
    var L = [M.real.length];
    var z = a.makeTensorInfo(L, "float32", M.real);
    var P = a.makeTensorInfo(L, "float32", M.imag);
    var B = hge({
      inputs: {
        real: z,
        imag: P
      },
      backend: a
    });
    var W = Eye({
      inputs: {
        a: B,
        b: D
      },
      backend: a
    });
    var U = Sge({
      inputs: {
        a: E,
        b: W
      },
      backend: a
    });
    var V = Ebe({
      inputs: {
        a: E,
        b: W
      },
      backend: a
    });
    var G = mge({
      inputs: {
        input: U
      },
      backend: a
    });
    var j = mge({
      inputs: {
        input: V
      },
      backend: a
    });
    var H = Fxe({
      inputs: {
        input: U
      },
      backend: a
    });
    var q = Fxe({
      inputs: {
        input: V
      },
      backend: a
    });
    var K = Mxe({
      inputs: [G, j],
      backend: a,
      attrs: {
        axis: 0
      }
    });
    var X = Mxe({
      inputs: [H, q],
      backend: a,
      attrs: {
        axis: 0
      }
    });
    var Y = a.data.get(K.dataId).values;
    var J = a.data.get(X.dataId).values;
    a.disposeIntermediateTensorInfo(h);
    a.disposeIntermediateTensorInfo(p);
    a.disposeIntermediateTensorInfo(f);
    a.disposeIntermediateTensorInfo(y);
    a.disposeIntermediateTensorInfo(b);
    a.disposeIntermediateTensorInfo(x);
    a.disposeIntermediateTensorInfo(S);
    a.disposeIntermediateTensorInfo(T);
    a.disposeIntermediateTensorInfo(E);
    a.disposeIntermediateTensorInfo(O);
    a.disposeIntermediateTensorInfo(F);
    a.disposeIntermediateTensorInfo(D);
    a.disposeIntermediateTensorInfo(z);
    a.disposeIntermediateTensorInfo(P);
    a.disposeIntermediateTensorInfo(B);
    a.disposeIntermediateTensorInfo(W);
    a.disposeIntermediateTensorInfo(U);
    a.disposeIntermediateTensorInfo(V);
    a.disposeIntermediateTensorInfo(G);
    a.disposeIntermediateTensorInfo(H);
    a.disposeIntermediateTensorInfo(j);
    a.disposeIntermediateTensorInfo(q);
    a.disposeIntermediateTensorInfo(K);
    a.disposeIntermediateTensorInfo(X);
    return {
      real: Y,
      imag: J
    };
  }
  var wke = {
    kernelName: R1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.input;
      var a = L$(r.shape);
      var i = r.shape[r.shape.length - 1];
      var o = Xbe({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          shape: [a / i, i]
        }
      });
      var s = bke(o, false, n);
      var u = Xbe({
        inputs: {
          x: s
        },
        backend: n,
        attrs: {
          shape: r.shape
        }
      });
      n.disposeIntermediateTensorInfo(o);
      n.disposeIntermediateTensorInfo(s);
      return u;
    }
  };
  function Ike(e) {
    var t = e.backend;
    var n = e.attrs;
    var r = n.shape;
    var a = n.value;
    var i = n.dtype || n0(a);
    var o = K$(i, L$(r));
    (function (e, t, n) {
      e.fill(t);
    })(o, a);
    return t.makeTensorInfo(r, i, o);
  }
  var Nke = {
    kernelName: _1,
    backendName: "cpu",
    kernelFunc: Ike
  };
  var Ske = {
    kernelName: O1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      e.attrs;
      var n = e.backend;
      var r = t.image;
      var a = n;
      var i = q$(r.dtype, L$(r.shape));
      var o = S(r.shape, 4);
      for (var s = o[0], u = o[1], c = o[2], l = o[3], h = a.data.get(r.dataId).values, p = 0; p < s; p++) {
        var f = p * c * u * l;
        for (var d = 0; d < u; d++) {
          var v = d * (c * l);
          for (var m = 0; m < c; m++) {
            var g = m * l;
            for (var y = 0; y < l; y++) {
              var b = Math.round(c - m - 1);
              var x = f + v + g + y;
              var k = h[x];
              if (b >= 0 && b < c) {
                k = h[f + v + b * l + y];
              }
              i[x] = k;
            }
          }
        }
      }
      return {
        dataId: a.write(i, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  var Tke = {
    kernelName: M3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = t.bias;
      var s = t.preluActivationWeights;
      var u = r.strides;
      var c = r.pad;
      var l = r.dataFormat;
      var h = r.dilations;
      var p = r.dimRoundingMode;
      var f = r.activation;
      var d = r.leakyreluAlpha;
      var v = zxe({
        inputs: {
          x: a,
          filter: i
        },
        backend: n,
        attrs: {
          strides: u,
          pad: c,
          dataFormat: l,
          dilations: h,
          dimRoundingMode: p
        }
      });
      if (o) {
        var m = v;
        if (l === "NCHW" && o.shape.length === 1 && o.shape[0] !== 1) {
          var g = Xbe({
            inputs: {
              x: o
            },
            backend: n,
            attrs: {
              shape: [o.shape[0], 1, 1]
            }
          });
          v = Sge({
            inputs: {
              a: v,
              b: g
            },
            backend: n
          });
          n.disposeIntermediateTensorInfo(g);
        } else {
          v = Sge({
            inputs: {
              a: v,
              b: o
            },
            backend: n
          });
        }
        n.disposeIntermediateTensorInfo(m);
      }
      if (f) {
        var y = v;
        if (l === "NCHW" && f === "prelu" && s.shape.length === 1 && s.shape[0] !== 1) {
          var b = Xbe({
            inputs: {
              x: s
            },
            backend: n,
            attrs: {
              shape: [s.shape[0], 1, 1]
            }
          });
          v = Kbe(n, v, f, b, d);
          n.disposeIntermediateTensorInfo(b);
        } else {
          v = Kbe(n, v, f, s, d);
        }
        n.disposeIntermediateTensorInfo(y);
      }
      return v;
    }
  };
  var Eke = {
    kernelName: L3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = t.bias;
      var s = t.preluActivationWeights;
      var u = r.strides;
      var c = r.pad;
      var l = r.dataFormat;
      var h = r.dilations;
      var p = r.dimRoundingMode;
      var f = r.activation;
      var d = r.leakyreluAlpha;
      var v = $xe({
        inputs: {
          x: a,
          filter: i
        },
        backend: n,
        attrs: {
          strides: u,
          pad: c,
          dataFormat: l,
          dilations: h,
          dimRoundingMode: p
        }
      });
      if (o) {
        var m = v;
        v = Sge({
          inputs: {
            a: v,
            b: o
          },
          backend: n
        });
        n.disposeIntermediateTensorInfo(m);
      }
      if (f) {
        var g = v;
        v = Kbe(n, v, f, s, d);
        n.disposeIntermediateTensorInfo(g);
      }
      return v;
    }
  };
  var Cke = {
    kernelName: z1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.params;
      var a = t.indices;
      var i = L$(r.shape);
      var o = a.shape;
      var s = o[o.length - 1];
      var u = S(Mae(r, a), 4);
      var c = u[0];
      var l = u[1];
      var h = u[2];
      var p = u[3];
      if (l === 0) {
        return n.makeTensorInfo(c, r.dtype, []);
      }
      var f = eye(n.data.get(a.dataId).values, n.bufferSync(r), r.dtype, l, s, h, p, r.shape, i);
      return n.makeTensorInfo(c, r.dtype, f.values);
    }
  };
  var Ake = {
    kernelName: L1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.indices;
      var o = r.axis;
      var s = r.batchDims;
      ige([a, i], "gatherV2");
      var u = j$(o, a.shape)[0];
      for (var c = n.data.get(i.dataId).values, l = a.shape[u], h = function () {
          var e = c[p];
          F$(e <= l - 1 && e >= 0, function () {
            return `GatherV2: the index value ${e} is not in [0, ${l - 1}]`;
          });
        }, p = 0; p < c.length; ++p) {
        h();
      }
      var f = s;
      if (s == null) {
        f = 0;
      }
      var d = L$(i.shape);
      var v = roe(a, i, u, f);
      var m = Xbe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: [v.batchSize, v.outerSize, v.dimSize, v.sliceSize]
        }
      });
      var g = Xbe({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          shape: [v.batchSize, d / v.batchSize]
        }
      });
      var y = [v.batchSize, v.outerSize, d / v.batchSize, v.sliceSize];
      var b = n.bufferSync(g);
      var x = tye(n.bufferSync(m), b, y);
      n.disposeIntermediateTensorInfo(m);
      n.disposeIntermediateTensorInfo(g);
      return n.makeTensorInfo(v.outputShape, x.dtype, x.values);
    }
  };
  var Rke = {
    kernelName: U1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.input;
      var a = L$(r.shape);
      var i = r.shape[r.shape.length - 1];
      var o = Xbe({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          shape: [a / i, i]
        }
      });
      var s = bke(o, true, n);
      var u = Xbe({
        inputs: {
          x: s
        },
        backend: n,
        attrs: {
          shape: r.shape
        }
      });
      n.disposeIntermediateTensorInfo(o);
      n.disposeIntermediateTensorInfo(s);
      return u;
    }
  };
  var _ke = Fge(G1, function (e) {
    if (Number.isFinite(e)) {
      return 1;
    } else {
      return 0;
    }
  }, "bool");
  var Oke = {
    kernelName: G1,
    backendName: "cpu",
    kernelFunc: _ke
  };
  var Fke = Fge(j1, function (e) {
    if (Math.abs(e) === Infinity) {
      return 1;
    } else {
      return 0;
    }
  }, "bool");
  var Dke = {
    kernelName: j1,
    backendName: "cpu",
    kernelFunc: Fke
  };
  var Mke = Fge(H1, function (e) {
    if (Number.isNaN(e)) {
      return 1;
    } else {
      return 0;
    }
  }, "bool");
  var Lke = {
    kernelName: H1,
    backendName: "cpu",
    kernelFunc: Mke
  };
  var zke = {
    kernelName: Y1,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.backend;
      var n = e.attrs;
      var r = dye(n.start, n.stop, n.num);
      return t.makeTensorInfo([r.length], "float32", r);
    }
  };
  var Pke = Fge(Z1, function (e) {
    return Math.log1p(e);
  });
  var Bke = {
    kernelName: Z1,
    backendName: "cpu",
    kernelFunc: Pke
  };
  var Wke = lge(function (e, t) {
    return e && t;
  });
  var Uke = kge(Q1, Wke, null, "bool");
  var Vke = {
    kernelName: Q1,
    backendName: "cpu",
    kernelFunc: Uke
  };
  var Gke = Fge($1, function (e) {
    if (e) {
      return 0;
    } else {
      return 1;
    }
  }, "bool");
  var jke = {
    kernelName: $1,
    backendName: "cpu",
    kernelFunc: Gke
  };
  var Hke = lge(function (e, t) {
    return e || t;
  });
  var qke = kge(e2, Hke, null, "bool");
  var Kke = {
    kernelName: e2,
    backendName: "cpu",
    kernelFunc: qke
  };
  var Xke = {
    kernelName: n2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.depthRadius;
      var o = r.bias;
      var s = r.alpha;
      var u = r.beta;
      ige(a, "LRN");
      var c = a.shape[3];
      var l = c - 1;
      var h = n.data.get(a.dataId).values;
      var p = L$(a.shape);
      var f = new Float32Array(p);
      function d(e) {
        var t = e % c;
        for (var n = e - t + Math.max(0, t - i), r = e - t + Math.min(t + i, l), a = 0; n <= r; n++) {
          var o = h[n];
          a += o * o;
        }
        return a;
      }
      for (var v = 0; v < p; v++) {
        var m = d(v);
        var g = h[v] * Math.pow(o + s * m, -u);
        f[v] = g;
      }
      return n.makeTensorInfo(a.shape, a.dtype, f);
    }
  };
  var Yke = {
    kernelName: r2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.y;
      var o = t.dy;
      var s = r.depthRadius;
      var u = r.bias;
      var c = r.alpha;
      var l = r.beta;
      ige(o, "LRNGrad");
      var h = L$(o.shape);
      var p = o.shape[3];
      var f = n.data.get(o.dataId).values;
      var d = n.data.get(a.dataId).values;
      var v = n.data.get(i.dataId).values;
      var m = new Float32Array(h);
      for (var g = h, y = 0; y < g; y++) {
        var b = y % p;
        var x = y - b + Math.max(0, b - s);
        for (var k = y - b + Math.min(p, b + s + 1), w = 0, I = x; I < k; I++) {
          w += Math.pow(d[I], 2);
        }
        w = c * w + u;
        for (var N = x; N < k; N++) {
          var S = c * -2 * l * d[N] * v[y] / w;
          if (y === N) {
            S += Math.pow(w, -l);
          }
          S *= f[y];
          m[N] += S;
        }
      }
      return n.makeTensorInfo(o.shape, a.dtype, m);
    }
  };
  function Jke(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.reductionIndices;
    var o = r.keepDims;
    var s = n;
    var u = a.shape;
    var c = u.length;
    var l = j$(i, u);
    var h = l;
    var p = $7(h, c);
    var f = s.data.get(a.dataId).values;
    if (p != null) {
      for (var d = new Array(c), v = 0; v < d.length; v++) {
        d[v] = u[p[v]];
      }
      f = Dye(f, u, a.dtype, p, d);
      h = t9(h.length, c);
      u = d;
    }
    ige(a, "max");
    Q7("max", h, c);
    var m = S(J7(u, h), 2);
    var g = m[0];
    var y = yye(f, L$(m[1]), g, a.dtype);
    var b = s.write(y, g, a.dtype);
    var x = g;
    if (o) {
      x = Z7(g, l);
    }
    return {
      dataId: b,
      shape: x,
      dtype: a.dtype
    };
  }
  var Zke = {
    kernelName: a2,
    backendName: "cpu",
    kernelFunc: Jke
  };
  var Qke = {
    kernelName: o2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      ige(a, "maxPool");
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dimRoundingMode;
      F$(j8(o, 1), function () {
        return `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${1}'`;
      });
      var c;
      var l = O8(a.shape, i, o, 1, s, u);
      if (l.filterWidth === 1 && l.filterHeight === 1 && P$(l.inShape, l.outShape)) {
        c = dge({
          inputs: {
            x: a
          },
          backend: n
        });
      } else {
        var h = n.data.get(a.dataId).values;
        var p = i0(a.shape);
        var f = bxe(h, a.shape, a.dtype, p, l, "max");
        c = n.makeTensorInfo(l.outShape, a.dtype, f.values);
      }
      return c;
    }
  };
  var $ke = {
    kernelName: u2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dimRoundingMode;
      var c = r.dataFormat;
      ige(a, "maxPool3d");
      var l = F8(a.shape, i, o, 1, s, u, c);
      var h = kxe(n.data.get(a.dataId).values, a.shape, a.dtype, i0(a.shape), l, "max");
      return n.makeTensorInfo(h.shape, "float32", h.values);
    }
  };
  var ewe = {
    kernelName: c2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = r.filterSize;
      var s = r.strides;
      var u = r.pad;
      var c = r.dimRoundingMode;
      ige([a, i], "maxPool3DGrad");
      for (var l = F8(i.shape, o, s, 1, u, c), h = function (e, t) {
          var n = l8(t.outShape, "int32");
          var r = t.strideDepth;
          var a = t.strideHeight;
          var i = t.strideWidth;
          var o = t.dilationDepth;
          var s = t.dilationHeight;
          var u = t.dilationWidth;
          var c = t.effectiveFilterDepth;
          var l = t.effectiveFilterHeight;
          var h = t.effectiveFilterWidth;
          var p = t.padInfo.front;
          var f = t.padInfo.top;
          var d = t.padInfo.left;
          for (var v = 0; v < t.batchSize; ++v) {
            for (var m = 0; m < t.inChannels; ++m) {
              for (var g = 0; g < t.outDepth; ++g) {
                var y = g * r - p;
                for (var b = y; b < 0;) {
                  b += o;
                }
                var x = Math.min(t.inDepth, c + y);
                for (var k = 0; k < t.outHeight; ++k) {
                  var w = k * a - f;
                  for (var I = w; I < 0;) {
                    I += s;
                  }
                  var N = Math.min(t.inHeight, l + w);
                  for (var S = 0; S < t.outWidth; ++S) {
                    var T = S * i - d;
                    for (var E = T; E < 0;) {
                      E += u;
                    }
                    var C = Math.min(t.inWidth, h + T);
                    var A = Number.NEGATIVE_INFINITY;
                    var R = -1;
                    for (var _ = b; _ < x; _ += o) {
                      var O = _ - y;
                      for (var F = I; F < N; F += s) {
                        var D = F - w;
                        for (var M = E; M < C; M += u) {
                          var L = M - T;
                          var z = e.get(v, _, F, M, m);
                          if (z >= A) {
                            A = z;
                            R = O * l * h + D * l + L;
                          }
                        }
                      }
                    }
                    n.set(R, v, g, k, S, m);
                  }
                }
              }
            }
          }
          return n;
        }(n.bufferSync(i), l), p = l.strideDepth, f = l.strideHeight, d = l.strideWidth, v = l.dilationDepth, m = l.dilationHeight, g = l.dilationWidth, y = l.effectiveFilterDepth, b = l.effectiveFilterHeight, x = l.effectiveFilterWidth, k = y - 1 - l.padInfo.front, w = x - 1 - l.padInfo.left, I = b - 1 - l.padInfo.top, N = l8(i.shape, "float32"), S = n.bufferSync(a), T = 0; T < l.batchSize; ++T) {
        for (var E = 0; E < l.inChannels; ++E) {
          for (var C = 0; C < l.inDepth; ++C) {
            for (var A = 0; A < l.inHeight; ++A) {
              for (var R = 0; R < l.inWidth; ++R) {
                var _ = C - k;
                var O = A - I;
                var F = R - w;
                var D = 0;
                for (var M = 0; M < y; M += v) {
                  var L = (_ + M) / p;
                  if (!(L < 0) && !(L >= l.outDepth) && Math.floor(L) === L) {
                    for (var z = 0; z < b; z += m) {
                      var P = (O + z) / f;
                      if (!(P < 0) && !(P >= l.outHeight) && Math.floor(P) === P) {
                        for (var B = 0; B < x; B += g) {
                          var W = (F + B) / d;
                          if (!(W < 0) && !(W >= l.outWidth) && Math.floor(W) === W) {
                            var U = y * b * x - 1 - h.get(T, L, P, W, E) === M * b * x + z * x + B ? 1 : 0;
                            if (U !== 0) {
                              D += S.get(T, L, P, W, E) * U;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                N.set(D, T, C, A, R, E);
              }
            }
          }
        }
      }
      return n.makeTensorInfo(N.shape, N.dtype, N.values);
    }
  };
  var twe = {
    kernelName: s2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = i;
      ige([i, t.output], "maxPoolGrad");
      var s = r.filterSize;
      var u = r.strides;
      var c = r.pad;
      var l = r.dimRoundingMode;
      for (var h = O8(o.shape, s, u, 1, c, l), p = n.data.get(o.dataId).values, f = l8(h.outShape, o.dtype, xxe(p, o.shape, o.dtype, h).values), d = h.strideHeight, v = h.strideWidth, m = h.dilationHeight, g = h.dilationWidth, y = h.effectiveFilterHeight, b = h.effectiveFilterWidth, x = b - 1 - h.padInfo.left, k = y - 1 - h.padInfo.top, w = l8(o.shape, "float32"), I = n.data.get(a.dataId).values, N = l8(a.shape, "float32", I), S = 0; S < h.batchSize; ++S) {
        for (var T = 0; T < h.inChannels; ++T) {
          for (var E = 0; E < h.inHeight; ++E) {
            for (var C = 0; C < h.inWidth; ++C) {
              var A = E - k;
              var R = C - x;
              var _ = 0;
              for (var O = 0; O < y; O += m) {
                var F = (A + O) / d;
                if (!(F < 0) && !(F >= h.outHeight) && Math.floor(F) === F) {
                  for (var D = 0; D < b; D += g) {
                    var M = (R + D) / v;
                    if (!(M < 0) && !(M >= h.outWidth) && Math.floor(M) === M) {
                      var L = y * b - 1 - f.get(S, F, M, T) === O * b + D ? 1 : 0;
                      if (L !== 0) {
                        _ += N.get(S, F, M, T) * L;
                      }
                    }
                  }
                }
              }
              w.set(_, S, E, C, T);
            }
          }
        }
      }
      return n.makeTensorInfo(w.shape, w.dtype, w.values);
    }
  };
  var nwe = {
    kernelName: l2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = t.x;
      var i = n.filterSize;
      var o = n.strides;
      var s = n.pad;
      var u = n.includeBatchInIndex;
      var c = r;
      ige(a, "MaxPoolWithArgmax");
      var l = c.data.get(a.dataId).values;
      var h = O8(a.shape, i, o, [1, 1], s);
      var p = function (e, t, n, r, a) {
        var i = bxe(e, 0, n, i0(t), a, "max");
        var o = xxe(e, t, n, a, true, r);
        return [i.values, o.values];
      }(l, a.shape, a.dtype, u, h);
      var f = S(p, 2);
      var d = f[0];
      var v = f[1];
      var m = c.write(d, h.outShape, a.dtype);
      var g = c.write(v, h.outShape, a.dtype);
      return [{
        dataId: m,
        shape: h.outShape,
        dtype: a.dtype
      }, {
        dataId: g,
        shape: h.outShape,
        dtype: "int32"
      }];
    }
  };
  var rwe = {
    kernelName: h2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      var s = j$(i, a.shape);
      var u = L$(J7(a.shape, s)[1]);
      var c = [];
      var l = n.makeTensorInfo([], "float32", new Float32Array([u]));
      c.push(l);
      var h = bge({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          dtype: "float32"
        }
      });
      c.push(h);
      var p = gke({
        inputs: {
          a: h,
          b: l
        },
        backend: n
      });
      c.push(p);
      var f = uke({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          axis: i,
          keepDims: o
        }
      });
      c.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return f;
    }
  };
  var awe = {
    kernelName: p2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      ige(a, "min");
      var s = j$(i, a.shape);
      var u = s;
      var c = $7(u, a.shape.length);
      var l = a;
      if (c != null) {
        l = Mye({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: c
          }
        });
        u = t9(u.length, a.shape.length);
      }
      Q7("min", u, l.shape.length);
      var h = S(J7(l.shape, u), 2);
      var p = h[0];
      var f = L$(h[1]);
      for (var d = l0(L$(p), l.dtype), v = n.data.get(l.dataId).values, m = 0; m < d.length; ++m) {
        var g = m * f;
        var y = v[g];
        for (var b = 0; b < f; ++b) {
          var x = v[g + b];
          if (Number.isNaN(x) || x < y) {
            y = x;
          }
        }
        d[m] = y;
      }
      if (c != null) {
        n.disposeIntermediateTensorInfo(l);
      }
      var k = n.makeTensorInfo(p, l.dtype, d);
      if (o) {
        var w = Xbe({
          inputs: {
            x: k
          },
          backend: n,
          attrs: {
            shape: Z7(p, s)
          }
        });
        n.disposeIntermediateTensorInfo(k);
        return w;
      }
      return k;
    }
  };
  var iwe = {
    kernelName: d2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.paddings;
      var o = r.mode;
      ige(a, "mirrorPad");
      var s = i.map(function (e, t) {
        return e[0] + a.shape[t] + e[1];
      });
      var u = i.map(function (e) {
        return e[0];
      });
      var c = i.map(function (e, t) {
        return e[0] + a.shape[t];
      });
      var l = o === "reflect" ? 0 : 1;
      var h = n.data.get(a.dataId).values;
      var p = a.shape.length;
      var f = i0(a.shape);
      for (var d = L$(s), v = s.length, m = i0(s), g = q$(a.dtype, d), y = 0; y < d; y++) {
        var b = d0(y, v, m);
        for (var x = 0; x < v; x++) {
          if (b[x] < u[x]) {
            b[x] = u[x] * 2 - b[x] - l;
          } else if (b[x] >= c[x]) {
            b[x] = (c[x] - 1) * 2 - b[x] + l;
          }
        }
        b = b.map(function (e, t) {
          return e - u[t];
        });
        var k = f0(b, p, f);
        g[y] = h[k];
      }
      return {
        dataId: n.write(g, s, a.dtype),
        shape: s,
        dtype: a.dtype
      };
    }
  };
  var owe = lge(function (e, t) {
    var n = e % t;
    if (e < 0 && t < 0 || e >= 0 && t >= 0) {
      return n;
    } else {
      return (n + t) % t;
    }
  });
  var swe = kge(v2, owe);
  var uwe = {
    kernelName: v2,
    backendName: "cpu",
    kernelFunc: swe
  };
  function cwe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.logits;
    var i = r.dim;
    var o = a.shape.length;
    var s = i;
    if (s === -1) {
      s = o - 1;
    }
    if (s !== o - 1) {
      throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${s}`);
    }
    var u = j$([s], a.shape);
    var c = Jke({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        reductionIndices: u,
        keepDims: false
      }
    });
    var l = Z7(c.shape, u);
    var h = Xbe({
      inputs: {
        x: c
      },
      backend: n,
      attrs: {
        shape: l
      }
    });
    var p = Ebe({
      inputs: {
        a: a,
        b: h
      },
      backend: n
    });
    var f = Gge({
      inputs: {
        x: p
      },
      backend: n
    });
    var d = uke({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        axis: u,
        keepDims: false
      }
    });
    var v = Xbe({
      inputs: {
        x: d
      },
      backend: n,
      attrs: {
        shape: l
      }
    });
    var m = gke({
      inputs: {
        a: f,
        b: v
      },
      backend: n
    });
    n.disposeIntermediateTensorInfo(c);
    n.disposeIntermediateTensorInfo(h);
    n.disposeIntermediateTensorInfo(p);
    n.disposeIntermediateTensorInfo(f);
    n.disposeIntermediateTensorInfo(d);
    n.disposeIntermediateTensorInfo(v);
    return m;
  }
  var lwe = {
    kernelName: s3,
    backendName: "cpu",
    kernelFunc: cwe
  };
  var hwe = {
    kernelName: m2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.logits;
      var i = r.numSamples;
      var o = r.seed;
      var s = r.normalized;
      ige(a, "multinomial");
      var u = s ? a : cwe({
        inputs: {
          logits: a
        },
        backend: n,
        attrs: {
          dim: -1
        }
      });
      for (var c = u.shape[0], l = u.shape[1], h = n.data.get(u.dataId).values, p = [c, i], f = l0(L$(p), "int32"), d = 0; d < c; ++d) {
        var v = d * l;
        var m = new Float32Array(l - 1);
        m[0] = h[v];
        for (var g = 1; g < m.length; ++g) {
          m[g] = m[g - 1] + h[v + g];
        }
        var y = qee.alea(o.toString());
        var b = d * i;
        for (var x = 0; x < i; ++x) {
          var k = y();
          f[b + x] = m.length;
          for (var w = 0; w < m.length; w++) {
            if (k < m[w]) {
              f[b + x] = w;
              break;
            }
          }
        }
      }
      if (!s) {
        n.disposeIntermediateTensorInfo(u);
      }
      return n.makeTensorInfo(p, "int32", f);
    }
  };
  var pwe = qne;
  var fwe = {
    kernelName: x2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.boxes;
      var i = t.scores;
      var o = r.maxOutputSize;
      var s = r.iouThreshold;
      var u = r.scoreThreshold;
      ige(a, "NonMaxSuppression");
      var c = n.data.get(a.dataId).values;
      var l = n.data.get(i.dataId).values;
      var h = pwe(c, l, o, s, u).selectedIndices;
      return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
    }
  };
  var dwe = Kne;
  var vwe = {
    kernelName: k2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.boxes;
      var i = t.scores;
      var o = r.maxOutputSize;
      var s = r.iouThreshold;
      var u = r.scoreThreshold;
      var c = r.padToMaxOutputSize;
      ige(a, "NonMaxSuppressionPadded");
      var l = n.data.get(a.dataId).values;
      var h = n.data.get(i.dataId).values;
      var p = dwe(l, h, o, s, u, c);
      var f = p.selectedIndices;
      var d = p.validOutputs;
      return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([], "int32", new Int32Array([d]))];
    }
  };
  var mwe = Xne;
  var gwe = {
    kernelName: w2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.boxes;
      var i = t.scores;
      var o = r.maxOutputSize;
      var s = r.iouThreshold;
      var u = r.scoreThreshold;
      var c = r.softNmsSigma;
      ige(a, "NonMaxSuppressionWithScore");
      var l = n.data.get(a.dataId).values;
      var h = n.data.get(i.dataId).values;
      var p = mwe(l, h, o, s, u, c);
      var f = p.selectedIndices;
      var d = p.selectedScores;
      return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([d.length], "float32", new Float32Array(d))];
    }
  };
  var ywe = {
    kernelName: N2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.indices;
      var i = r.dtype;
      var o = r.depth;
      var s = r.onValue;
      var u = r.offValue;
      ige(a, "oneHot");
      var c = L$(a.shape);
      var l = new Float32Array(c * o);
      l.fill(u);
      var h = n.data.get(a.dataId).values;
      for (var p = 0; p < c; ++p) {
        if (h[p] >= 0 && h[p] < o) {
          l[p * o + h[p]] = s;
        }
      }
      return n.makeTensorInfo([].concat(T(a.shape), [o]), i, l);
    }
  };
  function bwe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.x;
    if (r.dtype === "string") {
      throw new Error("zerosLike is not supported for string tensors");
    }
    if (r.dtype === "complex64") {
      var a = mge({
        inputs: {
          input: r
        },
        backend: n
      });
      var i = bwe({
        inputs: {
          x: a
        },
        backend: n
      });
      var o = Fxe({
        inputs: {
          input: r
        },
        backend: n
      });
      var s = bwe({
        inputs: {
          x: o
        },
        backend: n
      });
      var u = hge({
        inputs: {
          real: i,
          imag: s
        },
        backend: n
      });
      n.disposeIntermediateTensorInfo(a);
      n.disposeIntermediateTensorInfo(i);
      n.disposeIntermediateTensorInfo(o);
      n.disposeIntermediateTensorInfo(s);
      return u;
    }
    return Ike({
      backend: n,
      attrs: {
        shape: r.shape,
        value: 0,
        dtype: r.dtype
      }
    });
  }
  var xwe = {
    kernelName: R3,
    backendName: "cpu",
    kernelFunc: bwe
  };
  var kwe = {
    kernelName: I2,
    backendName: "cpu",
    kernelFunc: function e(t) {
      var n = t.inputs;
      var r = t.backend;
      var a = n.x;
      if (a.dtype === "string") {
        throw new Error("onesLike is not supported for string tensors");
      }
      if (a.dtype === "complex64") {
        var i = mge({
          inputs: {
            input: a
          },
          backend: r
        });
        var o = e({
          inputs: {
            x: i
          },
          backend: r
        });
        var s = Fxe({
          inputs: {
            input: a
          },
          backend: r
        });
        var u = bwe({
          inputs: {
            x: s
          },
          backend: r
        });
        var c = hge({
          inputs: {
            real: o,
            imag: u
          },
          backend: r
        });
        r.disposeIntermediateTensorInfo(i);
        r.disposeIntermediateTensorInfo(o);
        r.disposeIntermediateTensorInfo(s);
        r.disposeIntermediateTensorInfo(u);
        return c;
      }
      return Ike({
        backend: r,
        attrs: {
          shape: a.shape,
          value: 1,
          dtype: a.dtype
        }
      });
    }
  };
  function wwe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs.axis;
    if (t.length === 1) {
      return dke({
        inputs: {
          input: t[0]
        },
        backend: n,
        attrs: {
          dim: r
        }
      });
    }
    var a = t[0].shape;
    var i = t[0].dtype;
    t.forEach(function (e) {
      D$(a, e.shape, "All tensors passed to stack must have matching shapes");
      F$(i === e.dtype, function () {
        return "All tensors passed to stack must have matching dtypes";
      });
    });
    var o = [];
    var s = Mxe({
      inputs: t.map(function (e) {
        var t = dke({
          inputs: {
            input: e
          },
          backend: n,
          attrs: {
            dim: r
          }
        });
        o.push(t);
        return t;
      }),
      backend: n,
      attrs: {
        axis: r
      }
    });
    o.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    });
    return s;
  }
  var Iwe = {
    kernelName: S2,
    backendName: "cpu",
    kernelFunc: wwe
  };
  var Nwe = {
    kernelName: T2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.paddings;
      var o = r.constantValue;
      ige(a, "pad");
      var s = i.map(function (e, t) {
        return e[0] + a.shape[t] + e[1];
      });
      var u = i.map(function (e) {
        return e[0];
      });
      var c = n.data.get(a.dataId).values;
      var l = L$(a.shape);
      var h = a.shape.length;
      var p = i0(a.shape);
      var f = L$(s);
      var d = s.length;
      var v = i0(s);
      var m = q$(a.dtype, f);
      if (o !== 0) {
        m.fill(o);
      }
      for (var g = 0; g < l; g++) {
        m[f0(d0(g, h, p).map(function (e, t) {
          return e + u[t];
        }), d, v)] = c[g];
      }
      return {
        dataId: n.write(m, s, a.dtype),
        shape: s,
        dtype: a.dtype
      };
    }
  };
  var Swe = lge(function (e, t) {
    return Math.pow(e, t);
  });
  var Twe = kge(E2, Swe);
  var Ewe = {
    kernelName: E2,
    backendName: "cpu",
    kernelFunc: Twe
  };
  var Cwe = {
    kernelName: R2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.paramsNestedSplits;
      var i = t.paramsDenseValues;
      var o = t.indices;
      r.outputRaggedRank;
      var s = a.map(function (e) {
        return n.data.get(e.dataId).values;
      });
      var u = a.map(function (e) {
        return e.shape;
      });
      var c = n.data.get(i.dataId).values;
      var l = n.data.get(o.dataId).values;
      var h = S(Vye(s, u, c, i.shape, i.dtype, l, o.shape), 3);
      var p = h[0];
      var f = h[1];
      var d = h[2];
      var v = p.map(function (e) {
        return n.makeTensorInfo([e.length], "int32", e);
      });
      var m = n.makeTensorInfo(d, i.dtype, f);
      return v.concat([m]);
    }
  };
  var Awe = {
    kernelName: _2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.starts;
      var a = t.limits;
      var i = t.deltas;
      var o = n.data.get(r.dataId).values;
      var s = n.data.get(a.dataId).values;
      var u = n.data.get(i.dataId).values;
      var c = S(jye(o, r.shape, r.dtype, s, a.shape, u, i.shape), 2);
      var l = c[0];
      var h = c[1];
      return [n.makeTensorInfo([l.length], "int32", l), n.makeTensorInfo([h.length], r.dtype, h)];
    }
  };
  var Rwe = {
    kernelName: O2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.shape;
      var i = t.values;
      var o = t.defaultValue;
      var s = t.rowPartitionTensors;
      var u = r.rowPartitionTypes;
      var c = n.data.get(a.dataId).values;
      var l = n.data.get(i.dataId).values;
      var h = n.data.get(o.dataId).values;
      var p = s.map(function (e) {
        return n.data.get(e.dataId).values;
      });
      var f = s.map(function (e) {
        return e.shape;
      });
      var d = S(Yye(c, a.shape, l, i.shape, i.dtype, h, o.shape, p, f, u), 2);
      var v = d[0];
      var m = d[1];
      return n.makeTensorInfo(v, i.dtype, m);
    }
  };
  var _we = {
    kernelName: F2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.backend;
      var n = e.attrs;
      var r = n.start;
      var a = n.stop;
      var i = n.dtype;
      var o = Jye(r, a, n.step, i);
      return t.makeTensorInfo([o.length], i, o);
    }
  };
  var Owe = Fge(M2, function (e) {
    return 1 / e;
  });
  var Fwe = {
    kernelName: M2,
    backendName: "cpu",
    kernelFunc: Owe
  };
  var Dwe = {
    kernelName: W2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = r.alignCorners;
      var o = r.halfPixelCenters;
      var s = r.size;
      ige(a, "resizeBilinear");
      var u = i0(a.shape);
      var c = S(s, 2);
      var l = c[0];
      var h = c[1];
      var p = S(a.shape, 4);
      for (var f = p[0], d = p[1], v = p[2], m = p[3], g = n.data.get(a.dataId).values, y = new Float32Array(L$([f, l, h, m])), b = [i && l > 1 ? d - 1 : d, i && h > 1 ? v - 1 : v], x = [i && l > 1 ? l - 1 : l, i && h > 1 ? h - 1 : h], k = 0, w = b[0] / x[0], I = b[1] / x[1], N = 0; N < f; N++) {
        for (var T = 0; T < l; T++) {
          var E = undefined;
          E = o ? w * (T + 0.5) - 0.5 : w * T;
          var C = Math.max(0, Math.floor(E));
          var A = E - C;
          var R = Math.min(d - 1, Math.ceil(E));
          var _ = N * u[0] + C * u[1];
          var O = N * u[0] + R * u[1];
          for (var F = 0; F < h; F++) {
            var D = undefined;
            D = o ? I * (F + 0.5) - 0.5 : I * F;
            var M = Math.max(0, Math.floor(D));
            var L = D - M;
            var z = Math.min(v - 1, Math.ceil(D));
            var P = _ + M * u[2];
            var B = O + M * u[2];
            var W = _ + z * u[2];
            var U = O + z * u[2];
            for (var V = 0; V < m; V++) {
              var G = g[P + V];
              var j = g[B + V];
              var H = G + (g[W + V] - G) * L;
              var q = H + (j + (g[U + V] - j) * L - H) * A;
              y[k++] = q;
            }
          }
        }
      }
      return n.makeTensorInfo([f, l, h, m], "float32", y);
    }
  };
  var Mwe = {
    kernelName: U2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = t.dy;
      var o = r.alignCorners;
      ige([i, a], "resizeBilinearGrad");
      var s = i0(a.shape);
      var u = S(a.shape, 4);
      for (var c = u[0], l = u[1], h = u[2], p = u[3], f = S(i.shape, 3), d = f[1], v = f[2], m = new Float32Array(c * l * h * p), g = [o && d > 1 ? l - 1 : l, o && v > 1 ? h - 1 : h], y = [o && d > 1 ? d - 1 : d, o && v > 1 ? v - 1 : v], b = g[0] / y[0], x = g[1] / y[1], k = n.data.get(i.dataId).values, w = 0, I = 0; I < c; I++) {
        var N = I * s[0];
        for (var T = 0; T < d; T++) {
          var E = T * b;
          var C = Math.floor(E);
          var A = Math.min(Math.ceil(E), l - 1);
          var R = N + C * s[1];
          var _ = N + A * s[1];
          var O = E - C;
          var F = 1 - O;
          for (var D = 0; D < v; D++) {
            var M = D * x;
            var L = Math.floor(M);
            var z = Math.min(Math.ceil(M), h - 1);
            var P = M - L;
            var B = 1 - P;
            var W = R + L * s[2];
            var U = R + z * s[2];
            var V = _ + L * s[2];
            var G = _ + z * s[2];
            var j = F * B;
            var H = F * P;
            var q = O * B;
            var K = O * P;
            for (var X = 0; X < p; X++) {
              var Y = k[w++];
              m[W + X] += Y * j;
              m[U + X] += Y * H;
              m[V + X] += Y * q;
              m[G + X] += Y * K;
            }
          }
        }
      }
      return n.makeTensorInfo([c, h, l, p], "float32", m);
    }
  };
  var Lwe = {
    kernelName: P2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = r.alignCorners;
      var o = r.halfPixelCenters;
      var s = r.size;
      ige(a, "resizeNearestNeighbor");
      var u = i0(a.shape);
      var c = S(s, 2);
      var l = c[0];
      var h = c[1];
      var p = S(a.shape, 4);
      for (var f = p[0], d = p[1], v = p[2], m = p[3], g = n.data.get(a.dataId).values, y = new Float32Array(f * l * h * m), b = [i && l > 1 ? d - 1 : d, i && h > 1 ? v - 1 : v], x = [i && l > 1 ? l - 1 : l, i && h > 1 ? h - 1 : h], k = b[0] / x[0], w = b[1] / x[1], I = 0, N = 0; N < f; N++) {
        var T = N * u[0];
        for (var E = 0; E < l; E++) {
          var C = o ? k * (E + 0.5) : k * E;
          var A = Math.min(d - 1, i ? Math.round(C) : Math.floor(C));
          if (o) {
            A = Math.max(0, A);
          }
          var R = T + A * u[1];
          for (var _ = 0; _ < h; _++) {
            var O = o ? w * (_ + 0.5) : w * _;
            var F = Math.min(v - 1, i ? Math.round(O) : Math.floor(O));
            if (o) {
              F = Math.max(0, F);
            }
            var D = R + F * u[2];
            for (var M = 0; M < m; M++) {
              var L = g[D + M];
              y[I++] = L;
            }
          }
        }
      }
      return n.makeTensorInfo([f, l, h, m], a.dtype, y);
    }
  };
  var zwe = {
    kernelName: B2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = t.dy;
      var o = r.alignCorners;
      ige([i, a], "resizeNearestNeighborGrad");
      var s = i0(a.shape);
      var u = i0(i.shape);
      var c = S(a.shape, 4);
      for (var l = c[0], h = c[1], p = c[2], f = c[3], d = S(i.shape, 3), v = d[1], m = d[2], g = new Float32Array(l * h * p * f), y = n.data.get(i.dataId).values, b = [o && v > 1 ? h - 1 : h, o && m > 1 ? p - 1 : p], x = [o && v > 1 ? v - 1 : v, o && m > 1 ? m - 1 : m], k = b[0] / x[0], w = b[1] / x[1], I = 1 / k, N = 1 / w, T = Math.ceil(I) * 2 + 2, E = Math.ceil(N) * 2 + 2, C = 0; C < l; C++) {
        var A = C * s[0];
        for (var R = 0; R < h; R++) {
          var _ = A + R * s[1];
          var O = Math.floor(R * I);
          var F = Math.floor(O - T / 2);
          for (var D = 0; D < p; D++) {
            var M = _ + D * s[2];
            var L = Math.floor(D * N);
            var z = Math.floor(L - E / 2);
            for (var P = 0; P < f; P++) {
              var B = 0;
              for (var W = 0; W < T; W++) {
                var U = W + F;
                if (!(U < 0) && !(U >= v)) {
                  var V = A + U * u[1];
                  var G = U * k;
                  if (R === Math.min(h - 1, o ? Math.round(G) : Math.floor(G))) {
                    for (var j = 0; j < E; j++) {
                      var H = j + z;
                      if (!(H < 0) && !(H >= m)) {
                        var q = V + H * u[2];
                        var K = H * w;
                        if (D === Math.min(p - 1, o ? Math.round(K) : Math.floor(K))) {
                          B += y[q + P];
                        }
                      }
                    }
                  }
                }
              }
              g[M + P] = B;
            }
          }
        }
      }
      return n.makeTensorInfo(a.shape, a.dtype, g);
    }
  };
  var Pwe = {
    kernelName: G2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.dims;
      ige(a, "reverse");
      var o = a.shape.length;
      var s = j$(i, a.shape);
      if (o === 0) {
        return dge({
          inputs: {
            x: a
          },
          backend: n
        });
      }
      for (var u = new $4(a.shape, a.dtype), c = n.bufferSync(a), l = function () {
          var e = u.indexToLoc(h);
          var t = e.slice();
          s.forEach(function (e) {
            return t[e] = a.shape[e] - 1 - t[e];
          });
          u.set.apply(u, [c.get.apply(c, T(t))].concat(T(e)));
        }, h = 0; h < u.size; h++) {
        l();
      }
      return n.makeTensorInfo(u.shape, u.dtype, u.values);
    }
  };
  var Bwe = {
    kernelName: F3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = t.image;
      var i = n.radians;
      var o = n.fillValue;
      var s = n.center;
      var u = r;
      var c = q$(a.dtype, L$(a.shape));
      var l = S(a.shape, 4);
      for (var h = l[0], p = l[1], f = l[2], d = l[3], v = S(pie(s, p, f), 2), m = v[0], g = v[1], y = Math.sin(i), b = Math.cos(i), x = u.data.get(a.dataId).values, k = 0; k < h; k++) {
        var w = k * f * p * d;
        for (var I = 0; I < p; I++) {
          var N = I * (f * d);
          for (var T = 0; T < f; T++) {
            var E = T * d;
            for (var C = 0; C < d; C++) {
              var A = [h, I, T, C];
              var R = A[2];
              var _ = A[1];
              var O = (R - m) * b - (_ - g) * y;
              var F = (R - m) * y + (_ - g) * b;
              O = Math.round(O + m);
              F = Math.round(F + g);
              var D = o;
              if (typeof o != "number") {
                D = C === 3 ? 255 : o[C];
              }
              if (O >= 0 && O < f && F >= 0 && F < p) {
                D = x[w + F * (f * d) + O * d + C];
              }
              c[w + N + E + C] = D;
            }
          }
        }
      }
      return {
        dataId: u.write(c, a.shape, a.dtype),
        shape: a.shape,
        dtype: a.dtype
      };
    }
  };
  var Wwe = Fge(j2, function (e) {
    var t = Math.floor(e);
    if (e - t < 0.5) {
      return Math.floor(e);
    } else if (e - t > 0.5) {
      return Math.ceil(e);
    } else if (t % 2 == 0) {
      return t;
    } else {
      return t + 1;
    }
  });
  var Uwe = {
    kernelName: j2,
    backendName: "cpu",
    kernelFunc: Wwe
  };
  var Vwe = {
    kernelName: q2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.indices;
      var i = t.updates;
      var o = r.shape;
      var s = Jte(0, a, o);
      var u = s.sliceRank;
      var c = s.numUpdates;
      var l = s.sliceSize;
      var h = s.strides;
      var p = s.outputSize;
      var f = ebe(n.bufferSync(a), n.bufferSync(i), o, p, l, c, u, h, 0, true);
      return n.makeTensorInfo(o, f.dtype, f.values);
    }
  };
  function Gwe(e, t) {
    for (var n = 0, r = e.length, a = 0; n < r;) {
      if (e[a = Math.floor((n + r) / 2)] < t) {
        n = a + 1;
      } else {
        r = a;
      }
    }
    return r;
  }
  function jwe(e, t) {
    for (var n = 0, r = e.length, a = 0; n < r;) {
      if (e[a = Math.floor((n + r) / 2)] <= t) {
        n = a + 1;
      } else {
        r = a;
      }
    }
    return r;
  }
  var Hwe = {
    kernelName: X2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.sortedSequence;
      var i = t.values;
      var o = r.side;
      var s = function (e, t, n, r, a, i) {
        var o = K$("int32", n * a);
        for (var s = 0; s < n; ++s) {
          var u = e.slice(s * r, (s + 1) * r);
          var c = s * a;
          for (var l = 0; l < a; ++l) {
            o[c + l] = i === "left" ? Gwe(u, t[l + c]) : jwe(u, t[l + c]);
          }
        }
        return o;
      }(n.data.get(a.dataId).values, n.data.get(i.dataId).values, a.shape[0], a.shape[1], i.shape[1], o);
      return n.makeTensorInfo(i.shape, "int32", s);
    }
  };
  var qwe = {
    kernelName: Y2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.condition;
      var a = t.t;
      var i = t.e;
      ige([r, a, i], "select");
      var o = r.shape.length;
      for (var s = n.data.get(r.dataId).values, u = n.data.get(a.dataId).values, c = n.data.get(i.dataId).values, l = h5(a.dtype, i.dtype), h = l0(L$(a.shape), l), p = 0, f = o === 0 || o > 1 || a.shape.length === 1 ? 1 : L$(a.shape.slice(1)), d = 0; d < s.length; d++) {
        for (var v = 0; v < f; v++) {
          if (s[d] === 1) {
            h[p++] = u[d];
          } else {
            h[p++] = c[d];
          }
        }
      }
      return n.makeTensorInfo(a.shape, l, h);
    }
  };
  var Kwe = Fge(J2, function (e) {
    if (e >= 0) {
      return e * 1.0507009873554805;
    } else {
      return (Math.exp(e) - 1) * 1.7580993408473768;
    }
  });
  var Xwe = {
    kernelName: J2,
    backendName: "cpu",
    kernelFunc: Kwe
  };
  var Ywe = Fge(e3, function (e) {
    if (e < 0) {
      return -1;
    } else if (e > 0) {
      return 1;
    } else {
      return 0;
    }
  });
  var Jwe = {
    kernelName: e3,
    backendName: "cpu",
    kernelFunc: Ywe
  };
  var Zwe = Fge(Q2, function (e) {
    return Math.sin(e);
  });
  var Qwe = {
    kernelName: Q2,
    backendName: "cpu",
    kernelFunc: Zwe
  };
  var $we = Fge($2, function (e) {
    return Math.sinh(e);
  });
  var eIe = {
    kernelName: $2,
    backendName: "cpu",
    kernelFunc: $we
  };
  var tIe = Math.log(1.1920928955078125e-7) + 2;
  var nIe = Fge(n3, function (e) {
    var t = e > -tIe;
    var n = e < tIe;
    var r = Math.exp(e);
    if (n) {
      return r;
    } else if (t) {
      return e;
    } else {
      return Math.log(1 + r);
    }
  });
  var rIe = {
    kernelName: n3,
    backendName: "cpu",
    kernelFunc: nIe
  };
  var aIe = {
    kernelName: i3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.blockShape;
      var o = r.paddings;
      ige([a], "spaceToBatchND");
      var s = L$(i);
      var u = [[0, 0]];
      u.push.apply(u, T(o));
      for (var c = 1 + i.length; c < a.shape.length; ++c) {
        u.push([0, 0]);
      }
      var l = Nwe.kernelFunc({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          paddings: u,
          constantValue: 0
        }
      });
      var h = fie(l.shape, i, s, false);
      var p = die(h.length, i.length, false);
      var f = vie(l.shape, i, s, false);
      var d = Xbe({
        inputs: {
          x: l
        },
        backend: n,
        attrs: {
          shape: h
        }
      });
      var v = Mye({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          perm: p
        }
      });
      var m = Xbe({
        inputs: {
          x: v
        },
        backend: n,
        attrs: {
          shape: f
        }
      });
      n.disposeIntermediateTensorInfo(l);
      n.disposeIntermediateTensorInfo(d);
      n.disposeIntermediateTensorInfo(v);
      return m;
    }
  };
  var iIe = {
    kernelName: u3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.indices;
      var a = t.values;
      var i = t.denseShape;
      var o = t.defaultValue;
      if (i.shape.length !== 1) {
        throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);
      }
      if (r.shape.length !== 2) {
        throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);
      }
      if (a.shape.length !== 1) {
        throw new Error(`Values must be a vector, saw:
        ${a.shape}`);
      }
      if (o.shape.length !== 0) {
        throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);
      }
      var s = n.data.get(r.dataId).values;
      var u = n.data.get(a.dataId).values;
      var c = n.data.get(i.dataId).values;
      var l = n.data.get(o.dataId).values[0];
      var h = S(sbe(s, r.shape, r.dtype, u, a.dtype, c, l), 5);
      var p = h[0];
      var f = h[1];
      var d = h[2];
      var v = h[3];
      var m = h[4];
      return [n.makeTensorInfo(f, r.dtype, p), n.makeTensorInfo([f[0]], a.dtype, d), n.makeTensorInfo([v.length], "bool", new Uint8Array(v.map(function (e) {
        return Number(e);
      }))), n.makeTensorInfo([m.length], r.dtype, new Int32Array(m))];
    }
  };
  var oIe = {
    kernelName: c3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.inputIndices;
      var a = t.inputShape;
      var i = t.newShape;
      if (r.shape.length !== 2) {
        throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);
      }
      if (a.shape.length !== 1) {
        throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);
      }
      if (i.shape.length !== 1) {
        throw new Error(`Target shape should be a vector but received shape ${i.shape}`);
      }
      var o = Array.from(n.data.get(a.dataId).values);
      var s = n.data.get(r.dataId).values;
      var u = Array.from(n.data.get(i.dataId).values);
      var c = S(ube(s, r.shape, r.dtype, o, u), 3);
      var l = c[0];
      var h = c[1];
      var p = c[2];
      return [n.makeTensorInfo(h, r.dtype, l), n.makeTensorInfo([p.length], i.dtype, new Int32Array(p))];
    }
  };
  var sIe = {
    kernelName: l3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.data;
      var a = t.indices;
      var i = t.segmentIds;
      if (r.shape.length < 1) {
        throw new Error("Data should be at least 1 dimensional but received scalar");
      }
      if (a.shape.length !== 1) {
        throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);
      }
      if (i.shape.length !== 1) {
        throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);
      }
      if (a.shape[0] !== i.shape[0]) {
        throw new Error("segmentIds and indices should have same size.");
      }
      var o = n.data.get(r.dataId).values;
      var s = n.data.get(a.dataId).values;
      var u = n.data.get(i.dataId).values;
      var c = S(cbe(o, r.shape, r.dtype, s, u, true), 2);
      var l = c[0];
      var h = c[1];
      return n.makeTensorInfo(h, r.dtype, l);
    }
  };
  var uIe = {
    kernelName: h3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.data;
      var a = t.indices;
      var i = t.segmentIds;
      if (r.shape.length < 1) {
        throw new Error("Data should be at least 1 dimensional but received scalar");
      }
      if (a.shape.length !== 1) {
        throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);
      }
      if (i.shape.length !== 1) {
        throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);
      }
      if (a.shape[0] !== i.shape[0]) {
        throw new Error("segmentIds and indices should have same size.");
      }
      var o = n.data.get(r.dataId).values;
      var s = n.data.get(a.dataId).values;
      var u = n.data.get(i.dataId).values;
      var c = S(cbe(o, r.shape, r.dtype, s, u), 2);
      var l = c[0];
      var h = c[1];
      return n.makeTensorInfo(h, r.dtype, l);
    }
  };
  var cIe = {
    kernelName: p3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = e.attrs;
      var i = n.sparseIndices;
      var o = n.sparseValues;
      var s = n.defaultValue;
      var u = a.outputShape;
      var c = Jte(0, i, u);
      var l = c.sliceRank;
      var h = c.numUpdates;
      var p = c.sliceSize;
      var f = c.strides;
      var d = c.outputSize;
      var v = false;
      var m = r.bufferSync(i);
      switch (o.dtype) {
        case "bool":
          t = ebe(m, r.bufferSync(o), u, d, p, h, l, f, Boolean(r.data.get(s.dataId).values[0]), v);
          break;
        case "float32":
          t = ebe(m, r.bufferSync(o), u, d, p, h, l, f, r.data.get(s.dataId).values[0], v);
          break;
        case "int32":
          t = ebe(m, r.bufferSync(o), u, d, p, h, l, f, r.data.get(s.dataId).values[0], v);
          break;
        case "string":
          t = ebe(m, r.bufferSync(o), u, d, p, h, l, f, W4(r.data.get(s.dataId).values[0]), v);
          break;
        default:
          throw new Error(`Unsupported type ${o.dtype}`);
      }
      return r.makeTensorInfo(u, t.dtype, t.values);
    }
  };
  var lIe = {
    kernelName: o3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.numOrSizeSplits;
      var o = j$(r.axis, a.shape)[0];
      var s = Vie(a, i, o);
      var u = new Array(a.shape.length).fill(0);
      var c = a.shape.slice();
      return s.map(function (e) {
        var t = T(c);
        t[o] = e;
        var r = ibe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            begin: u,
            size: t
          }
        });
        u[o] += e;
        return r;
      });
    }
  };
  var hIe = {
    kernelName: d3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.x;
      var a = n;
      ige(r, "square");
      for (var i = a.data.get(r.dataId).values, o = new Float32Array(i.length), s = 0; s < i.length; ++s) {
        var u = i[s];
        o[s] = u * u;
      }
      return {
        dataId: a.write(o, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  var pIe = Fge(_3, function (e, t) {
    var n = t;
    if (isNaN(e)) {
      return NaN;
    } else if (e > 0) {
      return 1;
    } else {
      return n.alpha;
    }
  });
  var fIe = {
    kernelName: _3,
    backendName: "cpu",
    kernelFunc: pIe
  };
  var dIe = {
    kernelName: m3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.begin;
      var o = r.end;
      var s = r.strides;
      var u = r.beginMask;
      var c = r.endMask;
      var l = r.ellipsisMask;
      var h = r.newAxisMask;
      var p = r.shrinkAxisMask;
      ige(a, "stridedSlice");
      var f;
      var d = Jae(a.shape, i, o, s, u, c, l, h, p);
      var v = d.finalShapeSparse;
      var m = d.finalShape;
      var g = d.isIdentity;
      var y = d.sliceDim0;
      var b = d.isSimpleSlice;
      var x = d.begin;
      var k = d.end;
      var w = d.strides;
      if (g) {
        f = Xbe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            shape: m
          }
        });
      } else if (y || b) {
        F$(a.shape.length >= 1, function () {
          return `Input must have rank at least 1, got: ${a.shape.length}`;
        });
        var I = Pae(x, k, w);
        var N = ibe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            begin: x,
            size: I
          }
        });
        f = Xbe({
          inputs: {
            x: N
          },
          backend: n,
          attrs: {
            shape: m
          }
        });
        n.disposeIntermediateTensorInfo(N);
      } else {
        var S = bbe(v, n.bufferSync(a), w, x);
        f = n.makeTensorInfo(m, S.dtype, S.values);
      }
      return f;
    }
  };
  var vIe = {
    kernelName: g3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = r.separator;
      var i = r.nGramWidths;
      var o = r.leftPad;
      var s = r.rightPad;
      var u = r.padWidth;
      var c = r.preserveShortSequences;
      var l = t.data;
      var h = t.dataSplits;
      var p = S(kbe(n.data.get(l.dataId).values, n.data.get(h.dataId).values, a, i, o, s, u, c), 2);
      var f = p[0];
      var d = p[1];
      return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", d)];
    }
  };
  var mIe = {
    kernelName: y3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs.skipEmpty;
      var a = t.input;
      var i = t.delimiter;
      if (a.dtype !== "string") {
        throw new Error("Input must be of datatype string");
      }
      if (a.shape.length !== 1) {
        throw new Error(`Input must be a vector, got shape: ${a.shape}`);
      }
      if (i.shape.length !== 0) {
        throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
      }
      var o = S(Ibe(n.data.get(a.dataId).values, n.data.get(i.dataId).values[0], r), 3);
      var s = o[0];
      var u = o[1];
      var c = o[2];
      var l = u.length;
      return [n.makeTensorInfo([l, 2], "int32", s), n.makeTensorInfo([l], "string", u), n.makeTensorInfo([2], "int32", new Int32Array(c))];
    }
  };
  var gIe = {
    kernelName: b3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs.numBuckets;
      var a = t.input;
      if (a.dtype !== "string") {
        throw new Error("Input must be of datatype string");
      }
      if (r <= 0) {
        throw new Error("Number of buckets must be at least 1");
      }
      var i = Nbe(n.data.get(a.dataId).values, r);
      return n.makeTensorInfo(a.shape, "int32", i);
    }
  };
  var yIe = Fge(k3, function (e) {
    return Math.tan(e);
  });
  var bIe = {
    kernelName: k3,
    backendName: "cpu",
    kernelFunc: yIe
  };
  var xIe = Fge(w3, function (e) {
    return Math.tanh(e);
  });
  var kIe = {
    kernelName: K2,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.tensor;
      var a = t.indices;
      var i = t.updates;
      var o = Jte(0, a, r.shape);
      var s = o.sliceRank;
      var u = o.numUpdates;
      var c = o.sliceSize;
      var l = o.strides;
      var h = o.outputSize;
      var p = n.bufferSync(a);
      var f = n.bufferSync(i);
      var d = n.bufferSync(r);
      var v = ebe(p, f, r.shape, h, c, u, s, l, d, false);
      return n.makeTensorInfo(r.shape, v.dtype, v.values);
    }
  };
  var wIe = {
    kernelName: I3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.reps;
      ige(a, "tile");
      var o = Abe(n.bufferSync(a), i);
      return n.makeTensorInfo(o.shape, o.dtype, o.values);
    }
  };
  var IIe = {
    kernelName: N3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.k;
      var o = r.sorted;
      ige(a, "topk");
      var s = S(Obe(n.data.get(a.dataId).values, a.shape, a.dtype, i, o), 2);
      var u = s[0];
      var c = s[1];
      return [n.makeTensorInfo(u.shape, u.dtype, u.values), n.makeTensorInfo(c.shape, c.dtype, c.values)];
    }
  };
  var NIe = {
    kernelName: S3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = t.image;
      var i = t.transforms;
      var o = n.interpolation;
      var s = n.fillMode;
      var u = n.fillValue;
      var c = n.outputShape;
      var l = S(a.shape, 4);
      var h = l[0];
      var p = l[1];
      var f = l[2];
      var d = l[3];
      var v = S(c ?? [p, f], 2);
      var m = v[0];
      var g = v[1];
      var y = [h, m, g, d];
      var b = i0(a.shape);
      var x = b[0];
      var k = b[1];
      var w = b[2];
      var I = i0(y);
      var N = I[0];
      var T = I[1];
      var E = I[2];
      var C = q$(a.dtype, L$(y));
      C.fill(u);
      var A = r.data.get(a.dataId).values;
      var R = r.data.get(i.dataId).values;
      for (var _ = 0; _ < h; ++_) {
        var O = i.shape[0] === 1 ? R : R.subarray(_ * 8, _ * 8 + 8);
        for (var F = 0; F < m; ++F) {
          for (var D = 0; D < g; ++D) {
            for (var M = 0; M < d; ++M) {
              var L = undefined;
              var z = O[6] * D + O[7] * F + 1;
              if (z !== 0) {
                var P = (O[0] * D + O[1] * F + O[2]) / z;
                var B = (O[3] * D + O[4] * F + O[5]) / z;
                var W = SIe(P, f, s);
                var U = SIe(B, p, s);
                switch (o) {
                  case "nearest":
                    L = EIe(A, p, f, x, k, w, _, U, W, M, u);
                    break;
                  case "bilinear":
                    L = CIe(A, p, f, x, k, w, _, U, W, M, u);
                    break;
                  default:
                    throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`);
                }
                C[_ * N + F * T + D * E + M] = L;
              }
            }
          }
        }
        return r.makeTensorInfo(y, a.dtype, C);
      }
      return {
        dataId: r.write(C, y, a.dtype),
        shape: a.shape,
        dtype: a.dtype
      };
    }
  };
  function SIe(e, t, n) {
    switch (n) {
      case "reflect":
        return function (e, t) {
          var n = e;
          if (n < 0) {
            if (t <= 1) {
              n = 0;
            } else {
              var r = t * 2;
              if (n < r) {
                n = r * Math.trunc(-n / r) + n;
              }
              n = n < -t ? n + r : -n - 1;
            }
          } else if (n > t - 1) {
            if (t <= 1) {
              n = 0;
            } else {
              var a = t * 2;
              if ((n -= a * Math.trunc(n / a)) >= t) {
                n = a - n - 1;
              }
            }
          }
          return A$(0, n, t - 1);
        }(e, t);
      case "wrap":
        return function (e, t) {
          var n = e;
          if (n < 0) {
            if (t <= 1) {
              n = 0;
            } else {
              var r = t - 1;
              n += t * (Math.trunc(-n / r) + 1);
            }
          } else if (n > t - 1) {
            if (t <= 1) {
              n = 0;
            } else {
              var a = t - 1;
              n -= t * Math.trunc(n / a);
            }
          }
          return A$(0, n, t - 1);
        }(e, t);
      case "nearest":
        return function (e, t) {
          return A$(0, e, t - 1);
        }(e, t);
      default:
        return function (e, t) {
          return e;
        }(e);
    }
  }
  function TIe(e, t, n, r, a, i, o, s, u, c, l) {
    if (s >= 0 && s < t && u >= 0 && u < n) {
      return e[o * r + s * a + u * i + c];
    } else {
      return l;
    }
  }
  function EIe(e, t, n, r, a, i, o, s, u, c, l) {
    return TIe(e, t, n, r, a, i, o, Math.round(s), Math.round(u), c, l);
  }
  function CIe(e, t, n, r, a, i, o, s, u, c, l) {
    var h = Math.floor(s);
    var p = Math.floor(u);
    var f = h + 1;
    var d = p + 1;
    return (f - s) * ((d - u) * TIe(e, t, n, r, a, i, o, h, p, c, l) + (u - p) * TIe(e, t, n, r, a, i, o, h, d, c, l)) + (s - h) * ((d - u) * TIe(e, t, n, r, a, i, o, f, p, c, l) + (u - p) * TIe(e, t, n, r, a, i, o, f, d, c, l));
  }
  var AIe = {
    kernelName: E3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = n.axis;
      var i = t.x;
      ige(i, "unique");
      var o = Fbe(r.data.get(i.dataId).values, a, i.shape, i.dtype);
      var s = o.outputValues;
      var u = o.outputShape;
      var c = o.indices;
      return [r.makeTensorInfo(u, i.dtype, s), r.makeTensorInfo([c.length], "int32", c)];
    }
  };
  var RIe = {
    kernelName: C3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.value;
      var i = r.axis;
      if (i < 0) {
        i += a.shape.length;
      }
      for (var o = a.shape.length, s = a.shape[i], u = new Array(o - 1), c = 0, l = 0; l < o; l++) {
        if (l !== i) {
          u[c++] = a.shape[l];
        }
      }
      var h = new Array(o).fill(0);
      var p = a.shape.slice();
      p[i] = 1;
      for (var f = new Array(s), d = 0; d < f.length; d++) {
        h[i] = d;
        var v = ibe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            begin: h,
            size: p
          }
        });
        f[d] = Xbe({
          inputs: {
            x: v
          },
          backend: n,
          attrs: {
            shape: u
          }
        });
        n.disposeIntermediateTensorInfo(v);
      }
      return f;
    }
  };
  var _Ie = {
    kernelName: A3,
    backendName: "cpu",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.segmentIds;
      var o = r.numSegments;
      ige(a, "unsortedSegmentSum");
      var s = [];
      var u = [];
      for (var c = a.shape.length - i.shape.length, l = i, h = 0; h < c; ++h) {
        var p = dke({
          inputs: {
            input: l
          },
          backend: n,
          attrs: {
            dim: h + 1
          }
        });
        l = p;
        u.push(p);
      }
      for (var f = 0; f < o; ++f) {
        var d = M4(f, "int32");
        var v = n.makeTensorInfo([], "int32", d);
        var m = Wge({
          inputs: {
            a: v,
            b: l
          },
          backend: n
        });
        var g = bge({
          inputs: {
            x: m
          },
          backend: n,
          attrs: {
            dtype: "float32"
          }
        });
        var y = Eye({
          inputs: {
            a: g,
            b: a
          },
          backend: n
        });
        var b = uke({
          inputs: {
            x: y
          },
          backend: n,
          attrs: {
            axis: 0,
            keepDims: false
          }
        });
        s.push(b);
        u.push(v);
        u.push(m);
        u.push(g);
        u.push(y);
        u.push(b);
      }
      var x = wwe({
        inputs: s,
        backend: n,
        attrs: {
          axis: 0
        }
      });
      u.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return x;
    }
  };
  for (var OIe = 0, FIe = [Qbe, cge, exe, nxe, Tge, rxe, axe, ixe, oxe, sxe, cxe, hxe, fxe, mxe, yxe, wxe, Ixe, Nxe, Sxe, Zbe, Txe, Exe, Cxe, _ge, Axe, xge, zge, _xe, pge, Oxe, Lxe, Pxe, Bxe, Wxe, Uxe, Vxe, Gxe, Hxe, Kxe, Xxe, Yxe, Jxe, Zxe, Qxe, eke, tke, nke, rke, ake, ike, oke, ske, lke, zbe, hke, Uge, fke, jge, vke, Kge, wke, Nke, Ske, Jge, $ge, Tke, Eke, Cke, Ake, aye, sye, vge, Rke, Dxe, Oke, Dke, Lke, Bbe, lye, fye, zke, gye, Bke, Vke, jke, Kke, Xke, Yke, Zke, kye, Qke, $ke, ewe, twe, nwe, rwe, awe, Nye, iwe, uwe, hwe, Cye, Rye, fwe, vwe, gwe, Fye, ywe, kwe, Iwe, Nwe, Ewe, Vbe, Pye, Cwe, Awe, Rwe, _we, gge, yke, Fwe, jbe, qbe, Ybe, Dwe, Mwe, Lwe, zwe, Pwe, Bwe, Uwe, $ye, Vwe, Hwe, qwe, Xwe, rbe, Jwe, Qwe, eIe, obe, lwe, rIe, aIe, iIe, oIe, sIe, uIe, cIe, lIe, pbe, hIe, vbe, ybe, fIe, dIe, vIe, mIe, gIe, Cbe, cke, bIe, {
      kernelName: w3,
      backendName: "cpu",
      kernelFunc: xIe
    }, kIe, wIe, IIe, NIe, Lye, AIe, RIe, _Ie, xwe]; OIe < FIe.length; OIe++) {
    G3(FIe[OIe]);
  }
  var DIe;
  var MIe;
  var LIe;
  var zIe = {};
  var PIe = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
  };
  function BIe(e, t) {
    zIe[e] = t;
  }
  function WIe(e, t) {
    if (!(e in zIe) || t != null) {
      var n = function (e, t) {
        if (e !== 1 && e !== 2) {
          throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
        }
        var n = t == null ? function (e) {
          if (k0().getBool("IS_SAFARI") || typeof OffscreenCanvas == "undefined" || e !== 2) {
            if (typeof document != "undefined") {
              return document.createElement("canvas");
            }
            throw new Error("Cannot create a canvas in this context");
          }
          return new OffscreenCanvas(300, 150);
        }(e) : t;
        n.addEventListener("webglcontextlost", function (t) {
          t.preventDefault();
          delete zIe[e];
        }, false);
        if (k0().getBool("SOFTWARE_WEBGL_ENABLED")) {
          PIe.failIfMajorPerformanceCaveat = false;
        }
        if (e === 1) {
          return n.getContext("webgl", PIe) || n.getContext("experimental-webgl", PIe);
        }
        return n.getContext("webgl2", PIe);
      }(e, t);
      if (n === null) {
        console.log("Could not get context for WebGL version", e);
        return null;
      }
      zIe[e] = n;
    }
    var r = zIe[e];
    if (r == null || r.isContextLost()) {
      delete zIe[e];
      return WIe(e);
    } else {
      r.disable(r.DEPTH_TEST);
      r.disable(r.STENCIL_TEST);
      r.disable(r.BLEND);
      r.disable(r.DITHER);
      r.disable(r.POLYGON_OFFSET_FILL);
      r.disable(r.SAMPLE_COVERAGE);
      r.enable(r.SCISSOR_TEST);
      r.enable(r.CULL_FACE);
      r.cullFace(r.BACK);
      return zIe[e];
    }
  }
  function UIe(e, t) {
    return [t, e];
  }
  function VIe(e) {
    var t = L$(e);
    return W$(Math.ceil(t / 4));
  }
  function GIe(e, t) {
    return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))];
  }
  function jIe(e, t) {
    var n;
    var r;
    var a;
    var i;
    var o;
    var s;
    var u;
    var c;
    var l;
    var h;
    var p = e;
    if (k0().getNumber("WEBGL_VERSION") === 2) {
      n = p.R32F;
      r = p.R16F;
      a = p.RGBA16F;
      i = p.RGBA32F;
      o = p.RED;
      u = 4;
      c = 1;
      l = p.HALF_FLOAT;
      h = p.FLOAT;
      s = p.RGBA8;
    } else {
      n = e.RGBA;
      r = e.RGBA;
      a = e.RGBA;
      i = p.RGBA;
      o = e.RGBA;
      u = 4;
      c = 4;
      l = t != null ? t.HALF_FLOAT_OES : null;
      h = e.FLOAT;
      s = e.RGBA;
    }
    return {
      internalFormatFloat: n,
      internalFormatHalfFloat: r,
      internalFormatPackedHalfFloat: a,
      internalFormatPackedFloat: i,
      textureFormatFloat: o,
      downloadTextureFormat: s,
      downloadUnpackNumChannels: u,
      defaultNumChannels: c,
      textureTypeHalfFloat: l,
      textureTypeFloat: h
    };
  }
  function HIe(e, t) {
    var n = t();
    if (k0().getBool("DEBUG")) {
      (function (e) {
        var t = e.getError();
        if (t !== e.NO_ERROR) {
          throw new Error("WebGL Error: " + KIe(e, t));
        }
      })(e);
    }
    return n;
  }
  (function (e) {
    e[e.DENSE = 0] = "DENSE";
    e[e.SHARED_BATCH = 1] = "SHARED_BATCH";
  })(DIe ||= {});
  (function (e) {
    e[e.RENDER = 0] = "RENDER";
    e[e.UPLOAD = 1] = "UPLOAD";
    e[e.PIXELS = 2] = "PIXELS";
    e[e.DOWNLOAD = 3] = "DOWNLOAD";
  })(MIe ||= {});
  (function (e) {
    e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16";
    e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32";
    e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32";
    e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
  })(LIe ||= {});
  function qIe(e) {
    return !!k0().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || e === 0 || !!(Math.abs(e) > 5.96e-8) && !!(Math.abs(e) < 65504);
  }
  function KIe(e, t) {
    switch (t) {
      case e.NO_ERROR:
        return "NO_ERROR";
      case e.INVALID_ENUM:
        return "INVALID_ENUM";
      case e.INVALID_VALUE:
        return "INVALID_VALUE";
      case e.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case e.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case e.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case e.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${t}`;
    }
  }
  function XIe(e, t) {
    return yNe(e, function () {
      return e.getExtension(t);
    }, "Extension \"" + t + "\" not supported on this browser.");
  }
  function YIe(e, t) {
    var n = yNe(e, function () {
      return e.createShader(e.VERTEX_SHADER);
    }, "Unable to create vertex WebGLShader.");
    HIe(e, function () {
      return e.shaderSource(n, t);
    });
    HIe(e, function () {
      return e.compileShader(n);
    });
    if (e.getShaderParameter(n, e.COMPILE_STATUS) === false) {
      console.log(e.getShaderInfoLog(n));
      throw new Error("Failed to compile vertex shader.");
    }
    return n;
  }
  function JIe(e, t) {
    var n = yNe(e, function () {
      return e.createShader(e.FRAGMENT_SHADER);
    }, "Unable to create fragment WebGLShader.");
    HIe(e, function () {
      return e.shaderSource(n, t);
    });
    HIe(e, function () {
      return e.compileShader(n);
    });
    if (k0().get("ENGINE_COMPILE_ONLY")) {
      return n;
    }
    if (e.getShaderParameter(n, e.COMPILE_STATUS) === false) {
      eNe(t, e.getShaderInfoLog(n));
      throw new Error("Failed to compile fragment shader.");
    }
    return n;
  }
  var ZIe;
  var QIe;
  var $Ie = /ERROR: [0-9]+:([0-9]+):/g;
  function eNe(e, t) {
    var n = $Ie.exec(t);
    if (n == null) {
      console.log(`Couldn't parse line number in error: ${t}`);
      console.log(e);
      return;
    }
    var r = +n[1];
    var a = e.split("\n");
    var i = a.length.toString().length + 2;
    for (var o = a.map(function (e, t) {
        return U$((t + 1).toString(), i) + e;
      }), s = 0, u = 0; u < o.length; u++) {
      s = Math.max(o[u].length, s);
    }
    var c = o.slice(0, r - 1);
    var l = o.slice(r - 1, r);
    var h = o.slice(r);
    console.log(c.join("\n"));
    console.log(t.split("\n")[0]);
    console.log(`%c ${U$(l[0], s)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
    console.log(h.join("\n"));
  }
  function tNe(e) {
    return yNe(e, function () {
      return e.createProgram();
    }, "Unable to create WebGLProgram.");
  }
  function nNe(e, t) {
    HIe(e, function () {
      return e.linkProgram(t);
    });
    if (!k0().get("ENGINE_COMPILE_ONLY") && e.getProgramParameter(t, e.LINK_STATUS) === false) {
      console.log(e.getProgramInfoLog(t));
      throw new Error("Failed to link vertex and fragment shaders.");
    }
  }
  function rNe(e, t) {
    HIe(e, function () {
      return e.validateProgram(t);
    });
    if (e.getProgramParameter(t, e.VALIDATE_STATUS) === false) {
      console.log(e.getProgramInfoLog(t));
      throw new Error("Shader program validation failed.");
    }
  }
  function aNe(e, t) {
    var n = yNe(e, function () {
      return e.createBuffer();
    }, "Unable to create WebGLBuffer");
    HIe(e, function () {
      return e.bindBuffer(e.ARRAY_BUFFER, n);
    });
    HIe(e, function () {
      return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
    });
    return n;
  }
  function iNe(e, t) {
    var n = yNe(e, function () {
      return e.createBuffer();
    }, "Unable to create WebGLBuffer");
    HIe(e, function () {
      return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n);
    });
    HIe(e, function () {
      return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW);
    });
    return n;
  }
  function oNe(e) {
    return yNe(e, function () {
      return e.createTexture();
    }, "Unable to create WebGLTexture.");
  }
  function sNe(e, t) {
    var n = k0().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e <= 0 || t <= 0) {
      var r = `[${e}x${t}]`;
      throw new Error("Requested texture size " + r + " is invalid.");
    }
    if (e > n || t > n) {
      var a = `[${e}x${t}]`;
      var i = `[${n}x${n}]`;
      throw new Error("Requested texture size " + a + " greater than WebGL maximum on this browser / GPU " + i + ".");
    }
  }
  function uNe(e) {
    return yNe(e, function () {
      return e.createFramebuffer();
    }, "Unable to create WebGLFramebuffer.");
  }
  function cNe(e, t, n, r, a, i, o) {
    var s = e.getAttribLocation(t, n);
    return s !== -1 && (HIe(e, function () {
      return e.bindBuffer(e.ARRAY_BUFFER, r);
    }), HIe(e, function () {
      return e.vertexAttribPointer(s, a, e.FLOAT, false, i, o);
    }), HIe(e, function () {
      return e.enableVertexAttribArray(s);
    }), true);
  }
  function lNe(e, t, n) {
    bNe(e, n);
    HIe(e, function () {
      return e.activeTexture(e.TEXTURE0 + n);
    });
    HIe(e, function () {
      return e.bindTexture(e.TEXTURE_2D, t);
    });
  }
  function hNe(e, t, n) {
    return yNe(e, function () {
      return e.getUniformLocation(t, n);
    }, "uniform \"" + n + "\" not present in program.");
  }
  function pNe(e, t, n) {
    return e.getUniformLocation(t, n);
  }
  function fNe(e, t, n, r) {
    HIe(e, function () {
      return lNe(e, t, r);
    });
    HIe(e, function () {
      return e.uniform1i(n, r);
    });
  }
  function dNe(e, t, n) {
    HIe(e, function () {
      return e.bindFramebuffer(e.FRAMEBUFFER, n);
    });
    HIe(e, function () {
      return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
    });
  }
  function vNe(e, t) {
    HIe(e, function () {
      return e.bindFramebuffer(e.FRAMEBUFFER, t);
    });
    HIe(e, function () {
      return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0);
    });
  }
  function mNe(e) {
    var t = e.checkFramebufferStatus(e.FRAMEBUFFER);
    if (t !== e.FRAMEBUFFER_COMPLETE) {
      throw new Error("Error binding framebuffer: " + gNe(e, t));
    }
  }
  function gNe(e, t) {
    switch (t) {
      case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case e.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${t}`;
    }
  }
  function yNe(e, t, n) {
    var r = HIe(e, function () {
      return t();
    });
    if (r == null) {
      throw new Error(n);
    }
    return r;
  }
  function bNe(e, t) {
    var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var r = t + e.TEXTURE0;
    if (r < e.TEXTURE0 || r > n) {
      var a = `[gl.TEXTURE0, gl.TEXTURE${n}]`;
      throw new Error(`textureUnit must be in ${a}.`);
    }
  }
  function xNe(e, t = 2) {
    return L$(e.slice(0, e.length - t));
  }
  function kNe(e) {
    if (e.length === 0) {
      throw Error("Cannot get rows and columns of an empty shape array.");
    }
    return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];
  }
  function wNe(e) {
    var t = [1, 1, 1];
    if (e.length !== 0 && (e.length !== 1 || e[0] !== 1)) {
      t = [xNe(e)].concat(T(kNe(e)));
    }
    return t;
  }
  function INe(e, t = false) {
    var n = k0().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    var r = k0().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    if (r === Infinity && k0().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")) {
      r = n / 2;
    }
    if (t) {
      n *= 2;
      r *= 2;
      if ((e = e.map(function (t, n) {
        if (n >= e.length - 2) {
          return R$(e[n]);
        } else {
          return e[n];
        }
      })).length === 1) {
        e = [2, e[0]];
      }
    }
    if (e.length !== 2) {
      var a = H$(e);
      e = a.newShape;
    }
    var i = L$(e);
    var o = null;
    if (e.length <= 1 && i <= n) {
      o = [1, i];
    } else if (e.length === 2 && e[0] <= n && e[1] <= n) {
      o = e;
    } else if (e.length === 3 && e[0] * e[1] <= n && e[2] <= n) {
      o = [e[0] * e[1], e[2]];
    } else if (e.length === 3 && e[0] <= n && e[1] * e[2] <= n) {
      o = [e[0], e[1] * e[2]];
    } else if (e.length === 4 && e[0] * e[1] * e[2] <= n && e[3] <= n) {
      o = [e[0] * e[1] * e[2], e[3]];
    } else if (e.length === 4 && e[0] <= n && e[1] * e[2] * e[3] <= n) {
      o = [e[0], e[1] * e[2] * e[3]];
    }
    var s = o != null && Math.max.apply(Math, T(o)) > r && Math.min.apply(Math, T(o)) <= (t ? 2 : 1) && Math.min.apply(Math, T(o)) > 0;
    if (o == null || s) {
      if (t) {
        var u = xNe(e);
        var c = 2;
        var l = 2;
        if (e.length) {
          var h = kNe(e);
          var p = S(h, 2);
          c = p[0];
          l = p[1];
        }
        o = W$(i = u * (c / 2) * (l / 2)).map(function (e) {
          return e * 2;
        });
      } else {
        o = W$(i);
      }
    }
    return o;
  }
  function NNe(e) {
    return e % 2 == 0;
  }
  function SNe(e, t) {
    if (P$(e = e.slice(-2), t = t.slice(-2))) {
      return true;
    }
    if (!e.length || !t.length) {
      return true;
    }
    if (e[0] === 0 || e[1] === 0 || t[0] === 0 || t[1] === 0) {
      return true;
    }
    if (e.length !== t.length) {
      var n = e[e.length - 1];
      var r = t[t.length - 1];
      if (n === r) {
        return true;
      }
      if (NNe(n) && NNe(r) && (e[0] === 1 || t[0] === 1)) {
        return true;
      }
    }
    return e[1] === t[1] && NNe(e[0]) && NNe(t[0]);
  }
  function TNe(e) {
    if (ZIe == null) {
      var t = WIe(e);
      ZIe = t.getParameter(t.MAX_TEXTURE_SIZE);
    }
    return ZIe;
  }
  function ENe(e) {
    if (QIe == null) {
      var t = WIe(e);
      QIe = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, QIe);
  }
  function CNe(e) {
    if (e === 0) {
      return 0;
    }
    var t = WIe(e);
    if (ANe(t, "EXT_disjoint_timer_query_webgl2") && e === 2) {
      return 2;
    } else if (ANe(t, "EXT_disjoint_timer_query")) {
      return 1;
    } else {
      return 0;
    }
  }
  function ANe(e, t) {
    return e.getExtension(t) != null;
  }
  function RNe(e) {
    try {
      if (WIe(e) != null) {
        return true;
      }
    } catch (e) {
      console.log("Error when getting WebGL context: ", e);
      return false;
    }
    return false;
  }
  function _Ne(e) {
    if (e === 0) {
      return false;
    }
    var t = WIe(e);
    if (e === 1) {
      if (!ANe(t, "OES_texture_float")) {
        return false;
      }
    } else if (!ANe(t, "EXT_color_buffer_float")) {
      return false;
    }
    return FNe(t);
  }
  function ONe(e) {
    if (e === 0) {
      return false;
    }
    var t = WIe(e);
    if (e !== 1) {
      if (ANe(t, "EXT_color_buffer_float")) {
        return FNe(t);
      }
      var n = "EXT_color_buffer_half_float";
      if (ANe(t, n)) {
        var r = t.getExtension(n);
        return function (e, t) {
          var n = jIe(e, t);
          var r = e.createTexture();
          e.bindTexture(e.TEXTURE_2D, r);
          var a = 1;
          var i = 1;
          e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, a, i, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
          var o = e.createFramebuffer();
          e.bindFramebuffer(e.FRAMEBUFFER, o);
          e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0);
          var s = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
          e.bindTexture(e.TEXTURE_2D, null);
          e.bindFramebuffer(e.FRAMEBUFFER, null);
          e.deleteTexture(r);
          e.deleteFramebuffer(o);
          return s;
        }(t, r);
      }
      return false;
    }
    return !!ANe(t, "OES_texture_float") && !!ANe(t, "WEBGL_color_buffer_float") && FNe(t);
  }
  function FNe(e) {
    var t = jIe(e);
    var n = e.createTexture();
    e.bindTexture(e.TEXTURE_2D, n);
    e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
    var r = e.createFramebuffer();
    e.bindFramebuffer(e.FRAMEBUFFER, r);
    e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
    var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
    e.bindTexture(e.TEXTURE_2D, null);
    e.bindFramebuffer(e.FRAMEBUFFER, null);
    e.deleteTexture(n);
    e.deleteFramebuffer(r);
    return a;
  }
  function DNe(e) {
    return e === 2 && WIe(e).fenceSync != null;
  }
  function MNe(e, t) {
    if (!Array.isArray(e)) {
      e = [e];
    }
    e.forEach(function (e) {
      if (e != null) {
        F$(e.dtype !== "complex64", function () {
          return `${t} does not support complex64 tensors in the WebGL backend.`;
        });
      }
    });
  }
  var LNe = {
    __proto__: null,
    assertNotComplex: MNe,
    bindCanvasToFramebuffer: function (e) {
      HIe(e, function () {
        return e.bindFramebuffer(e.FRAMEBUFFER, null);
      });
      HIe(e, function () {
        return e.viewport(0, 0, e.canvas.width, e.canvas.height);
      });
      HIe(e, function () {
        return e.scissor(0, 0, e.canvas.width, e.canvas.height);
      });
    },
    bindColorTextureToFramebuffer: dNe,
    bindTextureToProgramUniformSampler: fNe,
    bindTextureUnit: lNe,
    bindVertexBufferToProgramAttribute: cNe,
    callAndCheck: HIe,
    canBeRepresented: qIe,
    createFragmentShader: JIe,
    createFramebuffer: uNe,
    createProgram: tNe,
    createStaticIndexBuffer: iNe,
    createStaticVertexBuffer: aNe,
    createTexture: oNe,
    createVertexShader: YIe,
    getBatchDim: xNe,
    getExtensionOrThrow: XIe,
    getFramebufferErrorMessage: gNe,
    getMaxTexturesInShader: ENe,
    getNumChannels: function () {
      if (k0().getNumber("WEBGL_VERSION") === 2) {
        return 1;
      } else {
        return 4;
      }
    },
    getProgramUniformLocation: pNe,
    getProgramUniformLocationOrThrow: hNe,
    getRowsCols: kNe,
    getShapeAs3D: wNe,
    getTextureShapeFromLogicalShape: INe,
    getWebGLDisjointQueryTimerVersion: CNe,
    getWebGLErrorMessage: KIe,
    getWebGLMaxTextureSize: TNe,
    hasExtension: ANe,
    isCapableOfRenderingToFloatTexture: _Ne,
    isDownloadFloatTextureEnabled: ONe,
    isReshapeFree: SNe,
    isWebGLFenceEnabled: DNe,
    isWebGLVersionEnabled: RNe,
    linkProgram: nNe,
    logShaderSourceAndInfoLog: eNe,
    resetMaxTextureSize: function () {
      ZIe = null;
    },
    resetMaxTexturesInShader: function () {
      QIe = null;
    },
    unbindColorTextureFromFramebuffer: vNe,
    unbindTextureUnit: function (e, t) {
      bNe(e, t);
      HIe(e, function () {
        return e.activeTexture(e.TEXTURE0 + t);
      });
      HIe(e, function () {
        return e.bindTexture(e.TEXTURE_2D, null);
      });
    },
    validateFramebuffer: mNe,
    validateProgram: rNe,
    validateTextureSize: sNe
  };
  var zNe = k0();
  function PNe() {
    var e;
    var t;
    var n;
    var r;
    var a;
    var i;
    var o;
    var s;
    var u;
    var c;
    if (k0().getNumber("WEBGL_VERSION") === 2) {
      e = "#version 300 es";
      t = "in";
      n = "out";
      r = "in";
      a = "texture";
      i = "outputColor";
      o = "out vec4 outputColor;";
      s = k0().getBool("WEBGL2_ISNAN_CUSTOM") ? "\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    " : "";
      u = "";
      c = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ";
    } else {
      e = "";
      t = "attribute";
      n = "varying";
      r = "varying";
      a = "texture2D";
      i = "gl_FragColor";
      o = "";
      s = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ";
      u = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ";
      c = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ";
    }
    return {
      version: e,
      attribute: t,
      varyingVs: n,
      varyingFs: r,
      texture2D: a,
      output: i,
      defineOutput: o,
      defineSpecialNaN: s,
      defineSpecialInf: u,
      defineRound: c
    };
  }
  function BNe(e, t, n = "index") {
    var r = i0(t);
    return r.map(function (t, a) {
      var i = `int ${e[a]} = ${n} / ${t}`;
      var o = a === r.length - 1 ? `int ${e[a + 1]} = ${n} - ${e[a]} * ${t}` : `index -= ${e[a]} * ${t}`;
      return `${i}; ${o};`;
    }).join("");
  }
  function WNe(e, t, n = "index") {
    var r = i0(t);
    return r.map(function (t, a) {
      var i = `int ${e[a]} = ${n} / outShapeStrides[${a}]`;
      var o = a === r.length - 1 ? `int ${e[a + 1]} = ${n} - ${e[a]} * outShapeStrides[${a}]` : `index -= ${e[a]} * outShapeStrides[${a}]`;
      return `${i}; ${o};`;
    }).join("");
  }
  function UNe(e, t) {
    var n = e.length;
    var r = e.map(function (e) {
      return `${t}[${e}]`;
    });
    var a = new Array(n - 1);
    a[n - 2] = r[n - 1];
    for (var i = n - 3; i >= 0; --i) {
      a[i] = `(${a[i + 1]} * ${r[i + 1]})`;
    }
    return a;
  }
  function VNe(e) {
    var t = i0(e).map(function (e) {
      return e.toString();
    });
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`;
  }
  zNe.registerFlag("HAS_WEBGL", function () {
    return zNe.getNumber("WEBGL_VERSION") > 0;
  });
  zNe.registerFlag("WEBGL_VERSION", function () {
    if (RNe(2)) {
      return 2;
    } else if (RNe(1)) {
      return 1;
    } else {
      return 0;
    }
  });
  zNe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", function () {
    return false;
  });
  zNe.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
    return zNe.get("WEBGL_VERSION") === 2;
  });
  zNe.registerFlag("WEBGL_CPU_FORWARD", function () {
    return true;
  });
  zNe.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
    return false;
  });
  zNe.registerFlag("WEBGL_PACK", function () {
    return zNe.getBool("HAS_WEBGL");
  });
  zNe.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_CLIP", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_REDUCE", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_LAZILY_UNPACK", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_CONV_IM2COL", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", function () {
    return zNe.getBool("WEBGL_PACK");
  });
  zNe.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
    return TNe(zNe.getNumber("WEBGL_VERSION"));
  });
  zNe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
    return ENe(zNe.getNumber("WEBGL_VERSION"));
  });
  zNe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
    var e = zNe.getNumber("WEBGL_VERSION");
    if (e === 0) {
      return 0;
    } else {
      return CNe(e);
    }
  });
  zNe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
    return zNe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !A5();
  });
  zNe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
    return _Ne(zNe.getNumber("WEBGL_VERSION"));
  });
  zNe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
    return !zNe.getBool("WEBGL_FORCE_F16_TEXTURES") && zNe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
  });
  zNe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
    return ONe(zNe.getNumber("WEBGL_VERSION"));
  });
  zNe.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
    return DNe(zNe.getNumber("WEBGL_VERSION"));
  });
  zNe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
    if (zNe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
      return 4;
    } else {
      return 0;
    }
  });
  zNe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", function () {
    return -1;
  }, function (e) {
    if (typeof e != "number") {
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);
    }
    if (e < 0 && e !== -1) {
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`);
    }
  });
  zNe.registerFlag("WEBGL_FLUSH_THRESHOLD", function () {
    if (A5()) {
      return 1;
    } else {
      return -1;
    }
  }, function (e) {
    if (typeof e != "number") {
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);
    }
    if (e < 0 && e !== -1) {
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`);
    }
  });
  zNe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", function () {
    return 128;
  });
  zNe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", function () {
    return false;
  });
  zNe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", function () {
    return 100000;
  });
  zNe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", function () {
    return 128;
  });
  zNe.registerFlag("WEBGL_EXP_CONV", function () {
    return false;
  });
  zNe.registerFlag("SOFTWARE_WEBGL_ENABLED", function () {
    return zNe.getBool("IS_TEST");
  });
  zNe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", function () {
    return Infinity;
  });
  zNe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", function () {
    return false;
  });
  zNe.registerFlag("WEBGL2_ISNAN_CUSTOM", function () {
    return false;
  });
  zNe.registerFlag("ENGINE_COMPILE_ONLY", function () {
    return false;
  });
  var GNe = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
  var jNe = M7;
  function HNe(e, t, n) {
    var r = [];
    e.forEach(function (e) {
      var t = L$(e.shapeInfo.logicalShape);
      if (e.shapeInfo.isUniform) {
        r.push(`uniform float ${e.name}${t > 1 ? `[${t}]` : ""};`);
      } else {
        r.push(`uniform sampler2D ${e.name};`);
        r.push(`uniform int offset${e.name};`);
      }
      if (n.enableShapeUniforms) {
        switch (lSe(n.packedInputs, e.shapeInfo.logicalShape, e.shapeInfo.texShape).uniformShape.length) {
          case 1:
            r.push(`uniform int ${e.name}Shape;`);
            break;
          case 2:
            r.push(`uniform ivec2 ${e.name}Shape;`);
            break;
          case 3:
            r.push(`uniform ivec3 ${e.name}Shape;`);
            break;
          case 4:
            r.push(`uniform ivec4 ${e.name}Shape;`);
        }
        r.push(`uniform ivec2 ${e.name}TexShape;`);
      }
    });
    if (n.enableShapeUniforms) {
      switch (t.logicalShape.length) {
        case 1:
          r.push("uniform int outShape;");
          break;
        case 2:
          r.push("uniform ivec2 outShape;");
          r.push("uniform int outShapeStrides;");
          break;
        case 3:
          r.push("uniform ivec3 outShape;");
          r.push("uniform ivec2 outShapeStrides;");
          break;
        case 4:
          r.push("uniform ivec4 outShape;");
          r.push("uniform ivec3 outShapeStrides;");
      }
      r.push("uniform ivec2 outTexShape;");
    }
    if (n.customUniforms) {
      n.customUniforms.forEach(function (e) {
        r.push(`uniform ${e.type} ${e.name}${e.arrayIndex ? `[${e.arrayIndex}]` : ""};`);
      });
    }
    var a;
    var i;
    var o = r.join("\n");
    var s = e.map(function (e) {
      return function (e, t, n = false, r) {
        var a = "";
        a += n ? KNe(e, r) : qNe(e, r);
        var i = e.shapeInfo.logicalShape;
        var o = t.logicalShape;
        if (i.length <= o.length) {
          a += n ? sSe(e, t) : uSe(e, t);
        }
        return a;
      }(e, t, n.packedInputs, n.enableShapeUniforms);
    }).join("\n");
    var u = t.texShape;
    var c = PNe();
    var l = function (e) {
      return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `;
    }(c);
    var h = function (e) {
      return `${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${XNe}
    ${YNe}
    ${JNe}
  `;
    }(c);
    if (t.isPacked) {
      a = function (e, t, n) {
        switch (e.length) {
          case 0:
            return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
          case 1:
            return function (e, t, n) {
              var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
              if (r[0] === 1) {
                if (n) {
                  return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ";
                } else {
                  return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `;
                }
              }
              if (r[1] === 1) {
                if (n) {
                  return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ";
                } else {
                  return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `;
                }
              }
              if (n) {
                return "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";
              }
              return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `;
            }(0, t, n);
          case 2:
            return function (e, t, n) {
              var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
              if (P$(e, t)) {
                if (n) {
                  return "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ";
                } else {
                  return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;
                }
              }
              var a = Math.ceil(e[1] / 2);
              if (n) {
                return "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";
              }
              return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec2(r, c);
    }
  `;
            }(e, t, n);
          case 3:
            return function (e, t, n) {
              if (n) {
                return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
              }
              var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
              var a = Math.ceil(e[2] / 2);
              var i = a * Math.ceil(e[1] / 2);
              return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec3(b, r, c);
    }
  `;
            }(e, t, n);
          default:
            return function (e, t, n) {
              if (n) {
                return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
              }
              var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
              var a = Math.ceil(e[e.length - 1] / 2);
              var i = a * Math.ceil(e[e.length - 2] / 2);
              var o = i;
              var s = "";
              var u = "b, r, c";
              for (var c = 2; c < e.length - 1; c++) {
                o *= e[e.length - c - 1];
                s = `
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    ${s}`;
                u = `b${c}, ${u}`;
              }
              return `
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${s}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${u});
    }
  `;
            }(e, t, n);
        }
      }(t.logicalShape, u, n.enableShapeUniforms);
      i = function (e) {
        return `
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `;
      }(c);
    } else {
      a = function (e, t, n) {
        switch (e.length) {
          case 0:
            return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
          case 1:
            return function (e, t, n) {
              if (t[0] === 1) {
                if (n) {
                  return "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ";
                } else {
                  return `
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `;
                }
              }
              if (t[1] === 1) {
                if (n) {
                  return "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ";
                } else {
                  return `
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `;
                }
              }
              if (n) {
                return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";
              }
              return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `;
            }(0, t, n);
          case 2:
            return function (e, t, n) {
              if (P$(e, t)) {
                if (n) {
                  return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ";
                } else {
                  return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `;
                }
              }
              if (e[1] === 1) {
                if (n) {
                  return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
                } else {
                  return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
                }
              }
              if (e[0] === 1) {
                if (n) {
                  return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
                } else {
                  return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
                }
              }
              if (n) {
                return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";
              }
              return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `;
            }(e, t, n);
          case 3:
            return function (e, t, n) {
              if (n) {
                var r = WNe(["r", "c", "d"], e);
                return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${r}
    return ivec3(r, c, d);
  }
`;
              }
              var a = BNe(["r", "c", "d"], e);
              return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec3(r, c, d);
    }
  `;
            }(e, t, n);
          case 4:
            return function (e, t, n) {
              if (n) {
                var r = WNe(["r", "c", "d", "d2"], e);
                return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `;
              }
              var a = BNe(["r", "c", "d", "d2"], e);
              return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `;
            }(e, t, n);
          case 5:
            r = t;
            a = BNe(["r", "c", "d", "d2", "d3"], e);
            return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${r[0]},
                             ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
          case 6:
            return function (e, t) {
              var n = BNe(["r", "c", "d", "d2", "d3", "d4"], e);
              return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
            }(e, t);
          default:
            throw new Error(`${e.length}-D output sampling is not yet supported`);
        }
        var r;
        var a;
      }(t.logicalShape, u, n.enableShapeUniforms);
      i = function (e) {
        return `
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `;
      }(c);
    }
    if (n.packedInputs) {
      h += ZNe;
    }
    return [h, l, i, o, a, s, n.userCode].join("\n");
  }
  function qNe(e, t = false) {
    var n = e.shapeInfo.logicalShape;
    switch (n.length) {
      case 0:
        return $Ne(e, t);
      case 1:
        return eSe(e, t);
      case 2:
        return tSe(e, t);
      case 3:
        return nSe(e, t);
      case 4:
        return rSe(e, t);
      case 5:
        return aSe(e);
      case 6:
        return iSe(e);
      default:
        throw new Error(`${n.length}-D input sampling is not yet supported`);
    }
  }
  function KNe(e, t) {
    var n;
    var r;
    var a;
    switch (e.shapeInfo.logicalShape.length) {
      case 0:
        n = e.name;
        r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        a = PNe();
        return `
    vec4 ${r}() {
      return ${a.texture2D}(${n}, halfCR);
    }
  `;
      case 1:
        return function (e, t) {
          var n = e.name;
          var r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
          var a = e.shapeInfo.texShape;
          var i = PNe();
          if (t) {
            return `
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${n}, uv);
    }
  `;
          }
          var o = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
          return `
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }
  `;
        }(e, t);
      case 2:
        return function (e, t) {
          var n = e.shapeInfo.logicalShape;
          var r = e.name;
          var a = "get" + r.charAt(0).toUpperCase() + r.slice(1);
          var i = e.shapeInfo.texShape;
          var o = i[0];
          var s = i[1];
          var u = PNe();
          if (i != null && P$(n, i)) {
            if (t) {
              return `
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `;
            } else {
              return `
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}.0, ${o}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;
            }
          }
          if (t) {
            return `
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;
          }
          var c = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
          var l = Math.ceil(n[1] / 2);
          return `
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;
        }(e, t);
      case 3:
        return function (e, t) {
          var n = e.shapeInfo.logicalShape;
          var r = e.name;
          var a = "get" + r.charAt(0).toUpperCase() + r.slice(1);
          var i = e.shapeInfo.texShape;
          var o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
          if (n[0] === 1) {
            var s = [1, 2];
            var u = hSe(e, n.slice(1));
            var c = ["b", "row", "col"];
            return `
        ${KNe(u, t)}
        vec4 ${a}(int b, int row, int col) {
          return ${a}(${pSe(c, s)});
        }
      `;
          }
          var l = PNe();
          if (t) {
            return `
    vec4 ${a}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;
          }
          var h = o[0];
          var p = o[1];
          var f = Math.ceil(n[2] / 2);
          var d = f * Math.ceil(n[1] / 2);
          return `
    vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${h}, ${p}, ${d}, ${f}, b, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;
        }(e, t);
      default:
        return function (e, t) {
          var n = e.name;
          var r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
          var a = PNe();
          if (t) {
            return `
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);
    }
  `;
          }
          var i = e.shapeInfo.logicalShape;
          for (var o = i.length, s = e.shapeInfo.texShape, u = [Math.ceil(s[0] / 2), Math.ceil(s[1] / 2)], c = u[0], l = u[1], h = Math.ceil(i[o - 1] / 2), p = h * Math.ceil(i[o - 2] / 2), f = "int b, int row, int col", d = `b * ${p} + (row / 2) * ${h} + (col / 2)`, v = 2; v < o - 1; v++) {
            f = `int b${v}, ${f}`;
            p *= i[o - v - 1];
            d = `b${v} * ${p} + ${d}`;
          }
          return `
    vec4 ${r}(${f}) {
      int index = ${d};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${c});
      return ${a.texture2D}(${n}, uv);
    }
  `;
        }(e, t);
    }
  }
  var XNe = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
  var YNe = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
  var JNe = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
  var ZNe = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
  function QNe(e) {
    return `offset${e}`;
  }
  function $Ne(e, t) {
    var n = e.name;
    var r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
    if (e.shapeInfo.isUniform) {
      return `float ${r}() {return ${n};}`;
    }
    var a = S(e.shapeInfo.texShape, 2);
    var i = a[0];
    var o = a[1];
    if (i === 1 && o === 1) {
      return `
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;
    }
    var s = QNe(n);
    if (t) {
      return `
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${s});
      return sampleTexture(${n}, uv);
    }
  `;
    }
    var u = S(e.shapeInfo.texShape, 2);
    var c = u[0];
    var l = u[1];
    return `
    float ${r}() {
      vec2 uv = uvFromFlat(${c}, ${l}, ${s});
      return sampleTexture(${n}, uv);
    }
  `;
  }
  function eSe(e, t) {
    var n = e.name;
    var r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
    if (e.shapeInfo.isUniform) {
      return `
      float ${r}(int index) {
        ${oSe(e)}
      }
    `;
    }
    var a = e.shapeInfo.texShape;
    var i = a[0];
    var o = a[1];
    if (o === 1 && i === 1) {
      return `
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;
    }
    var s = QNe(n);
    if (o === 1) {
      if (t) {
        return `
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `;
      } else {
        return `
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${i}.0);
        return sampleTexture(${n}, uv);
      }
    `;
      }
    } else if (i === 1) {
      if (t) {
        return `
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${s}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `;
      } else {
        return `
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `;
      }
    } else if (t) {
      return `
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${s});
      return sampleTexture(${n}, uv);
    }
  `;
    } else {
      return `
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${s});
      return sampleTexture(${n}, uv);
    }
  `;
    }
  }
  function tSe(e, t) {
    var n = e.shapeInfo.logicalShape;
    var r = e.name;
    var a = "get" + r.charAt(0).toUpperCase() + r.slice(1);
    var i = e.shapeInfo.texShape;
    if (i != null && P$(n, i)) {
      if (t) {
        return `
      float ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;
      }
      var o = i[0];
      var s = i[1];
      return `
    float ${a}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}.0, ${o}.0);
      return sampleTexture(${r}, uv);
    }
  `;
    }
    var u = H$(n);
    var c = u.newShape;
    var l = u.keptDims;
    var h = c;
    if (h.length < n.length) {
      var p = hSe(e, h);
      return `
      ${qNe(p, t)}
      float ${a}(int row, int col) {
        return ${a}(${pSe(["row", "col"], l)});
      }
    `;
    }
    if (e.shapeInfo.isUniform) {
      return `
      float ${a}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${oSe(e)}
      }
    `;
    }
    var f = i[0];
    var d = i[1];
    var v = QNe(r);
    if (d === 1) {
      if (t) {
        return `
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${v}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `;
      } else {
        return `
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${v}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `;
      }
    } else if (f === 1) {
      if (t) {
        return `
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${v}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `;
      } else {
        return `
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${v}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `;
      }
    } else if (t) {
      return `
      float ${a}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${v};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `;
    } else {
      return `
  float ${a}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${v};
    vec2 uv = uvFromFlat(${f}, ${d}, index);
    return sampleTexture(${r}, uv);
  }
`;
    }
  }
  function nSe(e, t) {
    var n = e.shapeInfo.logicalShape;
    var r = e.name;
    var a = "get" + r.charAt(0).toUpperCase() + r.slice(1);
    var i = n[1] * n[2];
    var o = n[2];
    var s = H$(n);
    var u = s.newShape;
    var c = s.keptDims;
    var l = u;
    if (l.length < n.length) {
      var h = hSe(e, l);
      return `
        ${qNe(h, t)}
        float ${a}(int row, int col, int depth) {
          return ${a}(${pSe(["row", "col", "depth"], c)});
        }
      `;
    }
    if (e.shapeInfo.isUniform) {
      return `
      float ${a}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${oSe(e)}
      }
    `;
    }
    var p = e.shapeInfo.texShape;
    var f = p[0];
    var d = p[1];
    var v = e.shapeInfo.flatOffset;
    if (d === i && v == null) {
      if (t) {
        return `
      float ${a}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;
      } else {
        return `
        float ${a}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${f}.0);
          return sampleTexture(${r}, uv);
        }
      `;
      }
    }
    if (d === o && v == null) {
      if (t) {
        return `
      float ${a}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;
      } else {
        return `
    float ${a}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `;
      }
    }
    var m = QNe(r);
    if (t) {
      return `
    float ${a}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `;
    } else {
      return `
      float ${a}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${m};
        vec2 uv = uvFromFlat(${f}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `;
    }
  }
  function rSe(e, t) {
    var n = e.shapeInfo.logicalShape;
    var r = e.name;
    var a = "get" + r.charAt(0).toUpperCase() + r.slice(1);
    var i = n[3];
    var o = n[2] * i;
    var s = n[1] * o;
    var u = H$(n);
    var c = u.newShape;
    var l = u.keptDims;
    if (c.length < n.length) {
      var h = hSe(e, c);
      return `
      ${qNe(h, t)}
      float ${a}(int row, int col, int depth, int depth2) {
        return ${a}(${pSe(["row", "col", "depth", "depth2"], l)});
      }
    `;
    }
    if (e.shapeInfo.isUniform) {
      return `
      float ${a}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${s}, ${o}, ${i}, 1)));
        ${oSe(e)}
      }
    `;
    }
    var p = e.shapeInfo.flatOffset;
    var f = e.shapeInfo.texShape;
    var d = f[0];
    var v = f[1];
    var m = `int stride2 = ${r}Shape[3];`;
    var g = `int stride1 = ${r}Shape[2] * stride2;`;
    var y = `int stride0 = ${r}Shape[1] * stride1;`;
    if (v === s && p == null) {
      if (t) {
        return `
      float ${a}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;
      } else {
        return `
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${v}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;
      }
    }
    if (v === i && p == null) {
      if (t) {
        return `
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;
      } else {
        return `
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1] * n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${v}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;
      }
    }
    var b = QNe(r);
    if (t) {
      return `
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});
      return sampleTexture(${r}, uv);
    }
  `;
    } else {
      return `
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${s} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${d}, ${v}, index + ${b});
      return sampleTexture(${r}, uv);
    }
  `;
    }
  }
  function aSe(e) {
    var t = e.shapeInfo.logicalShape;
    var n = e.name;
    var r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
    var a = t[4];
    var i = t[3] * a;
    var o = t[2] * i;
    var s = t[1] * o;
    var u = H$(t);
    var c = u.newShape;
    var l = u.keptDims;
    if (c.length < t.length) {
      var h = hSe(e, c);
      return `
      ${qNe(h)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${pSe(["row", "col", "depth", "depth2", "depth3"], l)});
      }
    `;
    }
    if (e.shapeInfo.isUniform) {
      return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${s}, ${o}, ${i}, ${a})) +
          depth3;
        ${oSe(e)}
      }
    `;
    }
    var p = e.shapeInfo.flatOffset;
    var f = e.shapeInfo.texShape;
    var d = f[0];
    var v = f[1];
    if (v === s && p == null) {
      return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${v}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;
    }
    if (v === a && p == null) {
      return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3]},
               ${t[2] * t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${v}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;
    }
    var m = QNe(n);
    return `
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${s} + col * ${o} + depth * ${i} +
          depth2 * ${a} + depth3 + ${m};
      vec2 uv = uvFromFlat(${d}, ${v}, index);
      return sampleTexture(${n}, uv);
    }
  `;
  }
  function iSe(e) {
    var t = e.shapeInfo.logicalShape;
    var n = e.name;
    var r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
    var a = H$(t);
    var i = a.newShape;
    var o = a.keptDims;
    if (i.length < t.length) {
      var s = hSe(e, i);
      return `
      ${qNe(s)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${pSe(["row", "col", "depth", "depth2", "depth3", "depth4"], o)});
      }
    `;
    }
    var u = t[5];
    var c = t[4] * u;
    var l = t[3] * c;
    var h = t[2] * l;
    var p = t[1] * h;
    if (e.shapeInfo.isUniform) {
      return `
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${h}, ${l}, ${c})) +
          dot(
            vec2(depth3, depth4),
            vec2(${u}, 1)));
        ${oSe(e)}
      }
    `;
    }
    var f = e.shapeInfo.flatOffset;
    var d = e.shapeInfo.texShape;
    var v = d[0];
    var m = d[1];
    if (m === p && f == null) {
      return `
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${l}, ${c}, ${u})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${v}.0);
        return sampleTexture(${n}, uv);
      }
    `;
    }
    if (m === u && f == null) {
      return `
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1] * t[2] * t[3] * t[4]},
               ${t[2] * t[3] * t[4]},
               ${t[3] * t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${v}.0);
        return sampleTexture(${n}, uv);
      }
    `;
    }
    var g = QNe(n);
    return `
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${h} + depth * ${l} +
          depth2 * ${c} + depth3 * ${u} + depth4 + ${g};
      vec2 uv = uvFromFlat(${v}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `;
  }
  function oSe(e) {
    var t = e.name;
    var n = L$(e.shapeInfo.logicalShape);
    if (n < 2) {
      return `return ${t};`;
    } else {
      return `
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `;
    }
  }
  function sSe(e, t) {
    var n;
    var r = e.name;
    var a = r.charAt(0).toUpperCase() + r.slice(1);
    var i = "get" + a + "AtOutCoords";
    var o = e.shapeInfo.logicalShape.length;
    var s = t.logicalShape.length;
    var u = jNe(e.shapeInfo.logicalShape, t.logicalShape);
    var c = cSe(s);
    var l = s - o;
    var h = ["x", "y", "z", "w", "u", "v"];
    n = o === 0 ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map(function (e) {
      return `coords.${h[e + l]} = 0;`;
    }).join("\n");
    var p = "";
    p = s < 2 && o > 0 ? "coords" : e.shapeInfo.logicalShape.map(function (e, t) {
      return `coords.${h[t + l]}`;
    }).join(", ");
    var f = "return outputValue;";
    var d = L$(e.shapeInfo.logicalShape) === 1;
    var v = L$(t.logicalShape) === 1;
    if (o !== 1 || d || v) {
      if (d && !v) {
        f = s === 1 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
      } else if (u.length) {
        var m = o - 2;
        var g = o - 1;
        if (u.indexOf(m) > -1 && u.indexOf(g) > -1) {
          f = "return vec4(outputValue.x);";
        } else if (u.indexOf(m) > -1) {
          f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);";
        } else if (u.indexOf(g) > -1) {
          f = "return vec4(outputValue.xx, outputValue.zz);";
        }
      }
    } else {
      f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
    }
    return `
    vec4 ${i}() {
      ${c} coords = getOutputCoords();
      ${n}
      vec4 outputValue = get${a}(${p});
      ${f}
    }
  `;
  }
  function uSe(e, t) {
    var n = e.name;
    var r = n.charAt(0).toUpperCase() + n.slice(1);
    var a = "get" + r + "AtOutCoords";
    var i = t.texShape;
    var o = e.shapeInfo.texShape;
    var s = e.shapeInfo.logicalShape.length;
    var u = t.logicalShape.length;
    if (!e.shapeInfo.isUniform && s === u && e.shapeInfo.flatOffset == null && P$(o, i)) {
      return `
      float ${a}() {
        return sampleTexture(${n}, resultUV);
      }
    `;
    }
    var c;
    var l = cSe(u);
    var h = jNe(e.shapeInfo.logicalShape, t.logicalShape);
    var p = u - s;
    var f = ["x", "y", "z", "w", "u", "v"];
    c = s === 0 ? "" : u < 2 && h.length >= 1 ? "coords = 0;" : h.map(function (e) {
      return `coords.${f[e + p]} = 0;`;
    }).join("\n");
    var d = "";
    d = u < 2 && s > 0 ? "coords" : e.shapeInfo.logicalShape.map(function (e, t) {
      return `coords.${f[t + p]}`;
    }).join(", ");
    return `
    float ${a}() {
      ${l} coords = getOutputCoords();
      ${c}
      return get${r}(${d});
    }
  `;
  }
  function cSe(e) {
    if (e <= 1) {
      return "int";
    }
    if (e === 2) {
      return "ivec2";
    }
    if (e === 3) {
      return "ivec3";
    }
    if (e === 4) {
      return "ivec4";
    }
    if (e === 5) {
      return "ivec5";
    }
    if (e === 6) {
      return "ivec6";
    }
    throw Error(`GPU for rank ${e} is not yet supported`);
  }
  function lSe(e, t, n) {
    var r = H$(t);
    var a = r.newShape;
    var i = r.keptDims;
    var o = t.length;
    var s = e && o === 3 && t[0] === 1;
    var u = s ? t.slice(1) : a;
    var c = !e && o > 1 && !P$(t, n) && a.length < o || s;
    return {
      useSqueezeShape: c,
      uniformShape: c ? u : t,
      keptDims: i
    };
  }
  function hSe(e, t) {
    var n = JSON.parse(JSON.stringify(e));
    n.shapeInfo.logicalShape = t;
    return n;
  }
  function pSe(e, t) {
    return t.map(function (t) {
      return e[t];
    }).join(", ");
  }
  function fSe(e, t, n, r) {
    var a = n.map(function (e, n) {
      var r = {
        logicalShape: e.shape,
        texShape: e.isUniform ? null : e.texData.texShape,
        isUniform: e.isUniform,
        isPacked: !e.isUniform && e.texData.isPacked,
        flatOffset: null
      };
      if (e.texData != null && e.texData.slice != null && e.texData.slice.flatOffset > 0) {
        r.flatOffset = e.texData.slice.flatOffset;
      }
      return {
        name: t.variableNames[n],
        shapeInfo: r
      };
    });
    var i = a.map(function (e) {
      return e.shapeInfo;
    });
    var o = {
      logicalShape: r.shape,
      texShape: r.texData.texShape,
      isUniform: false,
      isPacked: r.texData.isPacked,
      flatOffset: null
    };
    var s = HNe(a, o, t);
    var u = JIe(e.gl, s);
    var c = e.createProgram(u);
    if (k0().get("ENGINE_COMPILE_ONLY")) {
      return {
        program: t,
        fragmentShader: u,
        source: s,
        webGLProgram: c,
        inShapeInfos: i,
        outShapeInfo: o,
        variablesLocations: null,
        customUniformLocations: null,
        infLoc: null,
        nanLoc: null,
        outShapeLocation: null,
        outShapeStridesLocation: null,
        outTexShapeLocation: null
      };
    } else {
      e.buildVao(c);
      return Object.assign({
        program: t,
        fragmentShader: u,
        source: s,
        webGLProgram: c,
        inShapeInfos: i,
        outShapeInfo: o
      }, dSe(e, t, c));
    }
  }
  function dSe(e, t, n) {
    var r;
    var a;
    var i;
    var o;
    var s = [];
    var u = [];
    var c = null;
    o = e.getUniformLocation(n, "NAN", false);
    if (k0().getNumber("WEBGL_VERSION") === 1) {
      c = e.getUniformLocation(n, "INFINITY", false);
    }
    var l;
    var h = false;
    var p = O(t.variableNames);
    try {
      for (p.s(); !(l = p.n()).done;) {
        var f = l.value;
        var d = {
          name: f,
          uniform: e.getUniformLocation(n, f, h),
          offset: e.getUniformLocation(n, `offset${f}`, h)
        };
        if (t.enableShapeUniforms) {
          d.shape = e.getUniformLocation(n, `${f}Shape`, h);
          d.texShape = e.getUniformLocation(n, `${f}TexShape`, h);
        }
        s.push(d);
      }
    } catch (e) {
      p.e(e);
    } finally {
      p.f();
    }
    if (t.enableShapeUniforms) {
      r = e.getUniformLocation(n, "outShape", h);
      i = e.getUniformLocation(n, "outShapeStrides", h);
      a = e.getUniformLocation(n, "outTexShape", h);
    }
    if (t.customUniforms) {
      var v;
      var m = O(t.customUniforms);
      try {
        for (m.s(); !(v = m.n()).done;) {
          var g = v.value;
          u.push(e.getUniformLocation(n, g.name, h));
        }
      } catch (e) {
        m.e(e);
      } finally {
        m.f();
      }
    }
    return {
      variablesLocations: s,
      customUniformLocations: u,
      infLoc: c,
      nanLoc: o,
      outShapeLocation: r,
      outShapeStridesLocation: i,
      outTexShapeLocation: a
    };
  }
  function vSe(e, t) {
    if (e.length !== t.length) {
      throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);
    }
    e.forEach(function (e, n) {
      var r = e.logicalShape;
      var a = t[n];
      var i = a.shape;
      if (!P$(r, i)) {
        throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);
      }
      if (!e.isUniform || !a.isUniform) {
        var o = e.texShape;
        var s = a.isUniform ? null : a.texData.texShape;
        if (!P$(o, s)) {
          throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${s} must match`);
        }
      }
    });
  }
  function mSe(e, t, n, r, a) {
    if (!t.program.enableShapeUniforms) {
      vSe(t.inShapeInfos, n);
      vSe([t.outShapeInfo], [r]);
    }
    var i = r.texData.texture;
    var o = r.texData.texShape;
    if (r.texData.isPacked) {
      e.setOutputPackedMatrixTexture(i.texture, o[0], o[1]);
    } else {
      e.setOutputMatrixTexture(i.texture, o[0], o[1]);
    }
    e.setProgram(t.webGLProgram);
    e.bindVertexArray(t.webGLProgram.vao);
    if (k0().getNumber("WEBGL_VERSION") === 1 && t.infLoc !== null) {
      e.gl.uniform1f(t.infLoc, Infinity);
    }
    if (t.nanLoc !== null) {
      e.gl.uniform1f(t.nanLoc, NaN);
    }
    for (var s = 0; s < n.length; ++s) {
      var u = n[s];
      var c = t.variablesLocations[s];
      var l = c.uniform;
      var h = c.offset;
      var p = c.shape;
      var f = c.texShape;
      if (p) {
        var d = lSe(t.program.packedInputs, u.shape, u.texData.texShape).uniformShape;
        switch (d.length) {
          case 1:
            e.gl.uniform1iv(p, new Int32Array(d));
            break;
          case 2:
            e.gl.uniform2iv(p, new Int32Array(d));
            break;
          case 3:
            e.gl.uniform3iv(p, new Int32Array(d));
            break;
          case 4:
            e.gl.uniform4iv(p, new Int32Array(d));
        }
      }
      if (f) {
        e.gl.uniform2i(f, u.texData.texShape[0], u.texData.texShape[1]);
      }
      if (l != null) {
        if (u.isUniform) {
          if (L$(u.shape) < 2) {
            e.gl.uniform1f(l, u.uniformValues[0]);
          } else {
            var v = u.uniformValues;
            if (!(v instanceof Float32Array)) {
              v = new Float32Array(v);
            }
            e.gl.uniform1fv(l, v);
          }
        } else {
          if (u.texData.slice != null && h != null) {
            e.gl.uniform1i(h, u.texData.slice.flatOffset);
          }
          e.setInputMatrixTexture(u.texData.texture.texture, l, s);
        }
      }
    }
    var m = t.outShapeLocation;
    if (m) {
      switch (r.shape.length) {
        case 1:
          e.gl.uniform1iv(m, new Int32Array(r.shape));
          break;
        case 2:
          e.gl.uniform2iv(m, new Int32Array(r.shape));
          break;
        case 3:
          e.gl.uniform3iv(m, new Int32Array(r.shape));
          break;
        case 4:
          e.gl.uniform4iv(m, new Int32Array(r.shape));
      }
    }
    if (t.outShapeStridesLocation) {
      var g = i0(r.shape);
      switch (r.shape.length) {
        case 2:
          e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(g));
          break;
        case 3:
          e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(g));
          break;
        case 4:
          e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(g));
      }
    }
    if (t.outTexShapeLocation) {
      e.gl.uniform2i(t.outTexShapeLocation, r.texData.texShape[0], r.texData.texShape[1]);
    }
    if (t.program.customUniforms && a) {
      for (var y = 0; y < t.program.customUniforms.length; ++y) {
        var b = t.program.customUniforms[y];
        var x = t.customUniformLocations[y];
        var k = a[y];
        if (b.type === "float") {
          e.gl.uniform1fv(x, k);
        } else if (b.type === "vec2") {
          e.gl.uniform2fv(x, k);
        } else if (b.type === "vec3") {
          e.gl.uniform3fv(x, k);
        } else if (b.type === "vec4") {
          e.gl.uniform4fv(x, k);
        } else if (b.type === "int") {
          e.gl.uniform1iv(x, k);
        } else if (b.type === "ivec2") {
          e.gl.uniform2iv(x, k);
        } else if (b.type === "ivec3") {
          e.gl.uniform3iv(x, k);
        } else {
          if (b.type !== "ivec4") {
            throw Error(`uniform type ${b.type} is not supported yet.`);
          }
          e.gl.uniform4iv(x, k);
        }
      }
    }
    e.executeProgram();
  }
  function gSe(e, t, n) {
    var r = "";
    t.concat(n).forEach(function (t) {
      var a = t.texData != null && t.texData.slice != null && t.texData.slice.flatOffset > 0;
      if (e.enableShapeUniforms && !t.isUniform) {
        var i = t.texData.texShape;
        var o = lSe(e.packedInputs, t.shape, i);
        var s = o.useSqueezeShape;
        var u = o.uniformShape;
        var c = o.keptDims;
        var l = "";
        var h = "";
        var p = "";
        if (u.length === 1 && e.packedInputs) {
          var f = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
          l = `${f[0] > 1}_${f[1] > 1}`;
        } else if (u.length !== 2 || e.packedInputs) {
          if (u.length > 2 && !e.packedInputs) {
            var d = i0(u);
            p = `${d[0] === i[1]}_${d[d.length - 1] === i[1]}`;
          }
        } else {
          h = `${u[0] > 1}_${u[1] > 1}`;
        }
        var v = t.shape.length;
        var m = u.length === 2 && P$(t.shape, i);
        var g = L$(t.shape) === 1;
        var y = M7(t.shape, n.shape);
        var b = !e.packedInputs && v === n.shape.length && P$(i, n.texData.texShape);
        var x = e.packedInputs || u.length > 2 ? "" : `${i[0] > 1}_${i[1] > 1}`;
        r += `${v}_${b}_${s ? c : ""}_${u.length}_${g}_${y}_${m}_${l}_${h}_${p}_${x}_${a}`;
      } else {
        var k = t.isUniform ? "uniform" : t.texData.texShape;
        r += `${t.shape}_${k}_${a}`;
      }
    });
    var a = e.userCode;
    var i = e.constructor.name;
    return i += `${"_" + r + "_" + a}${k0().getNumber("WEBGL_VERSION")}`;
  }
  function ySe(e) {
    return k0().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4;
  }
  var bSe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.outPackingScheme = DIe.DENSE;
    this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var n = PNe();
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? WNe(["r", "c", "d"], t) : BNe(["r", "c", "d"], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `;
  });
  var xSe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outPackingScheme = DIe.DENSE;
    this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var n = PNe();
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? WNe(["r", "c", "d"], t) : BNe(["r", "c", "d"], t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `;
  });
  var kSe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.outTexUsage = MIe.DOWNLOAD;
    var n = PNe();
    this.outputShape = t;
    this.userCode = `
      ${GNe}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `;
  });
  var wSe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = false;
    this.outTexUsage = MIe.DOWNLOAD;
    var n = PNe();
    this.outputShape = t;
    this.userCode = `
      ${GNe}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `;
  });
  var ISe = {
    R: 0,
    G: 1,
    B: 2,
    A: 3
  };
  var NSe = p(function e(t, n = false, r = "RGBA") {
    l(this, e);
    this.variableNames = ["A"];
    this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var a = PNe();
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var i = "result";
    if (n) {
      i = "floor(result * 255. + 0.5)";
    }
    var o = "";
    for (var s = 0; s < r.length; s++) {
      var u = r[s];
      o += `
          if(offset == ${s}) {
            result = values[${ISe[u]}];
          }`;
    }
    this.userCode = `
      ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : VNe(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${a.texture2D}(A, uv);
          ${o}
        }
        ${a.output} = vec4(${i}, 0., 0., 0.);
      }
    `;
  });
  var SSe = p(function e(t, n = false) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "texShape",
      type: "ivec2"
    }];
    var r = PNe();
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var a = "";
    var i = "result";
    if (n) {
      i = "floor(result * 255. + 0.5)";
    }
    for (var o = 0; o <= 1; o++) {
      for (var s = 0; s <= 1; s++) {
        var u = o * 2 + s;
        a += `
          localCoords = coords;
          if(localCoords[2] + ${s} < ${this.enableShapeUniforms ? "outShape[2]" : `${t[2]}`}) {
          localCoords[2] += ${s};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms ? "outShape[1]" : `${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `;
      }
    }
    this.userCode = `
        ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : VNe(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${a}

          ${r.output} = ${i};
        }
    `;
  });
  function TSe(e) {
    var t = PNe();
    return YIe(e, `${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`);
  }
  function ESe(e) {
    return aNe(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
  }
  function CSe(e) {
    return iNe(e, new Uint16Array([0, 1, 2, 2, 1, 3]));
  }
  function ASe(e, t, n, r, a, i) {
    sNe(t, n);
    var o = oNe(e);
    var s = e.TEXTURE_2D;
    HIe(e, function () {
      return e.bindTexture(s, o);
    });
    HIe(e, function () {
      return e.texParameteri(s, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);
    });
    HIe(e, function () {
      return e.texParameteri(s, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
    });
    HIe(e, function () {
      return e.texParameteri(s, e.TEXTURE_MIN_FILTER, e.NEAREST);
    });
    HIe(e, function () {
      return e.texParameteri(s, e.TEXTURE_MAG_FILTER, e.NEAREST);
    });
    if (k0().getNumber("WEBGL_VERSION") === 1) {
      HIe(e, function () {
        return e.texImage2D(s, 0, r, t, n, 0, a, i, null);
      });
    } else {
      HIe(e, function () {
        return e.texStorage2D(s, 1, r, t, n);
      });
    }
    HIe(e, function () {
      return e.bindTexture(e.TEXTURE_2D, null);
    });
    return {
      texture: o,
      texShape: [n, t]
    };
  }
  function RSe(e) {
    return e.internalFormatFloat;
  }
  function _Se(e, t, n, r) {
    var a = S(UIe(t, n), 2);
    return ASe(e, a[0], a[1], RSe(r), r.textureFormatFloat, e.FLOAT);
  }
  function OSe(e) {
    return e.internalFormatHalfFloat;
  }
  function FSe(e, t, n, r) {
    var a = S(UIe(t, n), 2);
    return ASe(e, a[0], a[1], OSe(r), r.textureFormatFloat, r.textureTypeHalfFloat);
  }
  function DSe(e) {
    return e.downloadTextureFormat;
  }
  function MSe(e, t, n, r) {
    var a = S(UIe(t, n), 2);
    return ASe(e, a[0], a[1], DSe(r), e.RGBA, e.UNSIGNED_BYTE);
  }
  function LSe(e) {
    return e.internalFormatPackedFloat;
  }
  function zSe(e, t, n, r) {
    var a = S(GIe(t, n), 2);
    return ASe(e, a[0], a[1], LSe(r), e.RGBA, e.FLOAT);
  }
  function PSe(e) {
    return e.internalFormatPackedHalfFloat;
  }
  function BSe(e, t, n, r) {
    var a = S(GIe(t, n), 2);
    return ASe(e, a[0], a[1], PSe(r), e.RGBA, r.textureTypeHalfFloat);
  }
  function WSe(e, t, n) {
    HIe(e, function () {
      return e.bindBuffer(e.ARRAY_BUFFER, n);
    });
    return cNe(e, t, "clipSpacePos", n, 3, 20, 0) && cNe(e, t, "uv", n, 2, 20, 12);
  }
  function USe(e, t, n, r, a, i) {
    var o;
    var s;
    var u;
    HIe(e, function () {
      return e.bindTexture(e.TEXTURE_2D, t);
    });
    if (a instanceof Uint8Array) {
      o = new Uint8Array(n * r * 4);
      s = e.UNSIGNED_BYTE;
      u = e.RGBA;
    } else {
      o = new Float32Array(n * r * 4);
      s = e.FLOAT;
      u = i.internalFormatPackedFloat;
    }
    o.set(a);
    if (k0().getNumber("WEBGL_VERSION") === 2) {
      HIe(e, function () {
        return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n, r, e.RGBA, s, o);
      });
    } else {
      HIe(e, function () {
        return e.texImage2D(e.TEXTURE_2D, 0, u, n, r, 0, e.RGBA, s, o);
      });
    }
    HIe(e, function () {
      return e.bindTexture(e.TEXTURE_2D, null);
    });
  }
  function VSe(e, t, n) {
    HIe(e, function () {
      return e.bindTexture(e.TEXTURE_2D, t);
    });
    if (n.data instanceof Uint8Array) {
      if (k0().getNumber("WEBGL_VERSION") === 2) {
        HIe(e, function () {
          return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n.width, n.height, e.RGBA, e.UNSIGNED_BYTE, n.data);
        });
      } else {
        HIe(e, function () {
          return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data);
        });
      }
    } else if (k0().getNumber("WEBGL_VERSION") === 2) {
      HIe(e, function () {
        return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, e.RGBA, e.UNSIGNED_BYTE, n);
      });
    } else {
      HIe(e, function () {
        return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n);
      });
    }
    HIe(e, function () {
      return e.bindTexture(e.TEXTURE_2D, null);
    });
  }
  function GSe(e, t, n, r) {
    var a = e.createBuffer();
    HIe(e, function () {
      return e.bindBuffer(e.PIXEL_PACK_BUFFER, a);
    });
    var i = t * 16 * n;
    HIe(e, function () {
      return e.bufferData(e.PIXEL_PACK_BUFFER, i, e.STREAM_READ);
    });
    HIe(e, function () {
      return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0);
    });
    HIe(e, function () {
      return e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
    });
    return a;
  }
  function jSe(e, t, n) {
    var r = e;
    var a = new Float32Array(n);
    r.bindBuffer(r.PIXEL_PACK_BUFFER, t);
    r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, a);
    r.bindBuffer(r.PIXEL_PACK_BUFFER, null);
    return a;
  }
  function HSe(e, t, n, r) {
    var a = S(UIe(t, n), 2);
    var i = a[0];
    var o = a[1];
    var s = new Uint8Array(t * n * 4);
    HIe(e, function () {
      return e.readPixels(0, 0, i, o, r.downloadTextureFormat, e.UNSIGNED_BYTE, s);
    });
    return new Float32Array(s.buffer);
  }
  function qSe(e, t, n, r, a, i, o, s) {
    var u = e;
    var c = new Float32Array(function (e, t) {
      var n = S(GIe(e, t), 2);
      return n[0] * n[1] * 4;
    }(i, o));
    u.bindBuffer(u.PIXEL_PACK_BUFFER, t);
    u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c);
    u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
    return c;
  }
  function KSe(e, t, n) {
    var r = new Float32Array(t * n * 4);
    HIe(e, function () {
      return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, r);
    });
    return r;
  }
  var XSe = {
    __proto__: null,
    bindVertexProgramAttributeStreams: WSe,
    createBufferFromOutputTexture: GSe,
    createFloat16MatrixTexture: FSe,
    createFloat16PackedMatrixTexture: BSe,
    createFloat32MatrixTexture: _Se,
    createIndexBuffer: CSe,
    createPackedMatrixTexture: zSe,
    createUnsignedBytesMatrixTexture: MSe,
    createVertexBuffer: ESe,
    createVertexShader: TSe,
    downloadByteEncodedFloatMatrixFromOutputTexture: HSe,
    downloadFloat32MatrixFromBuffer: jSe,
    downloadMatrixFromPackedOutputTexture: KSe,
    downloadPackedMatrixFromBuffer: qSe,
    getInternalFormatForFloat16MatrixTexture: OSe,
    getInternalFormatForFloat16PackedMatrixTexture: PSe,
    getInternalFormatForFloat32MatrixTexture: RSe,
    getInternalFormatForPackedMatrixTexture: LSe,
    getInternalFormatForUnsignedBytesMatrixTexture: DSe,
    uploadDenseMatrixToTexture: USe,
    uploadPixelDataToTexture: VSe
  };
  var YSe = function () {
    function e(t) {
      l(this, e);
      this.outputTexture = null;
      this.program = null;
      this.disposed = false;
      this.itemsToPoll = [];
      var n = k0().getNumber("WEBGL_VERSION");
      if (t != null) {
        this.gl = t;
        BIe(n, t);
      } else {
        this.gl = WIe(n);
      }
      t = this.gl;
      if (k0().getNumber("WEBGL_VERSION") === 2) {
        var r = t;
        this.createVertexArray = function () {
          return HIe(r, function () {
            return r.createVertexArray();
          });
        };
        this.bindVertexArray = function (e) {
          return HIe(r, function () {
            return r.bindVertexArray(e);
          });
        };
        this.deleteVertexArray = function (e) {
          return HIe(r, function () {
            return r.deleteVertexArray(e);
          });
        };
        this.getVertexArray = function () {
          return HIe(r, function () {
            return r.getParameter(r.VERTEX_ARRAY_BINDING);
          });
        };
      } else if (t != null) {
        var a = t.getExtension("OES_vertex_array_object");
        if (a == null) {
          throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        }
        this.createVertexArray = function () {
          return HIe(t, function () {
            return a.createVertexArrayOES();
          });
        };
        this.bindVertexArray = function (e) {
          return HIe(t, function () {
            return a.bindVertexArrayOES(e);
          });
        };
        this.deleteVertexArray = function (e) {
          return HIe(t, function () {
            return a.deleteVertexArrayOES(e);
          });
        };
        this.getVertexArray = function () {
          return HIe(t, function () {
            return t.getParameter(a.VERTEX_ARRAY_BINDING_OES);
          });
        };
      }
      var i = "WEBGL_color_buffer_float";
      var o = "EXT_color_buffer_half_float";
      this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile");
      if (k0().getNumber("WEBGL_VERSION") === 1) {
        var s = "OES_texture_half_float";
        this.textureFloatExtension = XIe(this.gl, "OES_texture_float");
        if (ANe(this.gl, s)) {
          this.textureHalfFloatExtension = XIe(this.gl, s);
        } else if (k0().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
        this.colorBufferFloatExtension = this.gl.getExtension(i);
        if (ANe(this.gl, o)) {
          this.colorBufferHalfFloatExtension = XIe(this.gl, o);
        } else if (k0().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
      } else {
        i = "EXT_color_buffer_float";
        if (ANe(this.gl, i)) {
          this.colorBufferFloatExtension = this.gl.getExtension(i);
        } else {
          if (!ANe(this.gl, o)) {
            throw new Error("GL context does not support color renderable floats");
          }
          this.colorBufferHalfFloatExtension = this.gl.getExtension(o);
        }
      }
      this.vertexBuffer = ESe(this.gl);
      this.indexBuffer = CSe(this.gl);
      this.framebuffer = uNe(this.gl);
      this.textureConfig = jIe(this.gl, this.textureHalfFloatExtension);
    }
    var t;
    p(e, [{
      key: "debug",
      get: function () {
        return k0().getBool("DEBUG");
      }
    }, {
      key: "dispose",
      value: function () {
        var e = this;
        if (!this.disposed) {
          if (this.program != null) {
            console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
          }
          if (this.outputTexture != null) {
            console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
          }
          var t = this.gl;
          HIe(t, function () {
            return t.finish();
          });
          HIe(t, function () {
            return t.bindFramebuffer(t.FRAMEBUFFER, null);
          });
          HIe(t, function () {
            return t.deleteFramebuffer(e.framebuffer);
          });
          HIe(t, function () {
            return t.bindBuffer(t.ARRAY_BUFFER, null);
          });
          HIe(t, function () {
            return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null);
          });
          HIe(t, function () {
            return t.deleteBuffer(e.indexBuffer);
          });
          this.disposed = true;
        }
      }
    }, {
      key: "createFloat32MatrixTexture",
      value: function (e, t) {
        this.throwIfDisposed();
        return _Se(this.gl, e, t, this.textureConfig);
      }
    }, {
      key: "createFloat16MatrixTexture",
      value: function (e, t) {
        this.throwIfDisposed();
        return FSe(this.gl, e, t, this.textureConfig);
      }
    }, {
      key: "createUnsignedBytesMatrixTexture",
      value: function (e, t) {
        this.throwIfDisposed();
        return MSe(this.gl, e, t, this.textureConfig);
      }
    }, {
      key: "uploadPixelDataToTexture",
      value: function (e, t) {
        this.throwIfDisposed();
        VSe(this.gl, e, t);
      }
    }, {
      key: "uploadDenseMatrixToTexture",
      value: function (e, t, n, r) {
        this.throwIfDisposed();
        USe(this.gl, e, t, n, r, this.textureConfig);
      }
    }, {
      key: "createFloat16PackedMatrixTexture",
      value: function (e, t) {
        this.throwIfDisposed();
        return BSe(this.gl, e, t, this.textureConfig);
      }
    }, {
      key: "createPackedMatrixTexture",
      value: function (e, t) {
        this.throwIfDisposed();
        return zSe(this.gl, e, t, this.textureConfig);
      }
    }, {
      key: "deleteMatrixTexture",
      value: function (e) {
        var t = this;
        this.throwIfDisposed();
        if (this.outputTexture === e) {
          vNe(this.gl, this.framebuffer);
          this.outputTexture = null;
        }
        HIe(this.gl, function () {
          return t.gl.deleteTexture(e);
        });
      }
    }, {
      key: "downloadByteEncodedFloatMatrixFromOutputTexture",
      value: function (e, t, n) {
        var r = this;
        return this.downloadMatrixDriver(e, function () {
          return HSe(r.gl, t, n, r.textureConfig);
        });
      }
    }, {
      key: "downloadPackedMatrixFromBuffer",
      value: function (e, t, n, r, a, i) {
        return qSe(this.gl, e, 0, 0, 0, a, i, this.textureConfig);
      }
    }, {
      key: "downloadFloat32MatrixFromBuffer",
      value: function (e, t) {
        return jSe(this.gl, e, t);
      }
    }, {
      key: "createBufferFromTexture",
      value: function (e, t, n) {
        this.bindTextureToFrameBuffer(e);
        var r = GSe(this.gl, t, n, this.textureConfig);
        this.unbindTextureToFrameBuffer();
        return r;
      }
    }, {
      key: "createAndWaitForFence",
      value: function () {
        var e = this.createFence(this.gl);
        return this.pollFence(e);
      }
    }, {
      key: "createFence",
      value: function (e) {
        var t;
        var n;
        var r = this;
        if (k0().getBool("WEBGL_FENCE_API_ENABLED")) {
          var a = e;
          var i = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
          e.flush();
          n = function () {
            var e = a.clientWaitSync(i, 0, 0);
            return e === a.ALREADY_SIGNALED || e === a.CONDITION_SATISFIED;
          };
          t = i;
        } else if (k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
          t = this.beginQuery();
          this.endQuery();
          n = function () {
            return r.isQueryAvailable(t, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
          };
        } else {
          n = function () {
            return true;
          };
        }
        return {
          query: t,
          isFencePassed: n
        };
      }
    }, {
      key: "downloadMatrixFromPackedTexture",
      value: function (e, t, n) {
        var r = this;
        return this.downloadMatrixDriver(e, function () {
          return KSe(r.gl, t, n);
        });
      }
    }, {
      key: "createProgram",
      value: function (e) {
        var t = this;
        this.throwIfDisposed();
        var n = this.gl;
        if (this.vertexShader == null) {
          this.vertexShader = TSe(n);
        }
        var r = tNe(n);
        HIe(n, function () {
          return n.attachShader(r, t.vertexShader);
        });
        HIe(n, function () {
          return n.attachShader(r, e);
        });
        nNe(n, r);
        var a = Object.assign(r, {
          vao: this.createVertexArray()
        });
        if (this.debug) {
          rNe(n, a);
        }
        return a;
      }
    }, {
      key: "buildVao",
      value: function (e) {
        var t = this;
        this.setProgram(e);
        this.bindVertexArray(e.vao);
        var n = this.gl;
        HIe(n, function () {
          return n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.indexBuffer);
        });
        WSe(n, e, this.vertexBuffer);
      }
    }, {
      key: "deleteProgram",
      value: function (e) {
        var t = this;
        this.throwIfDisposed();
        if (e === this.program) {
          this.program = null;
        }
        if (e != null) {
          HIe(this.gl, function () {
            return t.gl.deleteProgram(e);
          });
          this.deleteVertexArray(e.vao);
        }
      }
    }, {
      key: "setProgram",
      value: function (e) {
        var t = this;
        this.throwIfDisposed();
        this.program = e;
        if (this.program != null && this.debug) {
          rNe(this.gl, this.program);
        }
        HIe(this.gl, function () {
          return t.gl.useProgram(e);
        });
      }
    }, {
      key: "getUniformLocation",
      value: function (e, t) {
        var n = !(arguments.length > 2) || arguments[2] === undefined || arguments[2];
        this.throwIfDisposed();
        if (n) {
          return hNe(this.gl, e, t);
        } else {
          return pNe(this.gl, e, t);
        }
      }
    }, {
      key: "getAttributeLocation",
      value: function (e, t) {
        var n = this;
        this.throwIfDisposed();
        return HIe(this.gl, function () {
          return n.gl.getAttribLocation(e, t);
        });
      }
    }, {
      key: "getUniformLocationNoThrow",
      value: function (e, t) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(e, t);
      }
    }, {
      key: "setInputMatrixTexture",
      value: function (e, t, n) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        fNe(this.gl, e, t, n);
      }
    }, {
      key: "setOutputMatrixTexture",
      value: function (e, t, n) {
        this.setOutputMatrixTextureDriver(e, n, t);
      }
    }, {
      key: "setOutputPackedMatrixTexture",
      value: function (e, t, n) {
        this.throwIfDisposed();
        var r = S(GIe(t, n), 2);
        var a = r[0];
        var i = r[1];
        this.setOutputMatrixTextureDriver(e, a, i);
      }
    }, {
      key: "setOutputMatrixWriteRegion",
      value: function (e, t, n, r) {
        this.setOutputMatrixWriteRegionDriver(n, e, r, t);
      }
    }, {
      key: "setOutputPackedMatrixWriteRegion",
      value: function (e, t, n, r) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
      }
    }, {
      key: "debugValidate",
      value: function () {
        if (this.program != null) {
          rNe(this.gl, this.program);
        }
        mNe(this.gl);
      }
    }, {
      key: "executeProgram",
      value: function () {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var e = this.gl;
        if (this.debug) {
          var t = this.getVertexArray();
          console.assert(t === this.program.vao, "VAO changed between setProgram and executeProgram!");
          this.debugValidate();
        }
        HIe(e, function () {
          return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0);
        });
      }
    }, {
      key: "blockUntilAllProgramsCompleted",
      value: function () {
        var e = this;
        this.throwIfDisposed();
        HIe(this.gl, function () {
          return e.gl.finish();
        });
      }
    }, {
      key: "getQueryTimerExtension",
      value: function () {
        if (this.disjointQueryTimerExtension == null) {
          this.disjointQueryTimerExtension = XIe(this.gl, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
        }
        return this.disjointQueryTimerExtension;
      }
    }, {
      key: "getQueryTimerExtensionWebGL2",
      value: function () {
        return this.getQueryTimerExtension();
      }
    }, {
      key: "getQueryTimerExtensionWebGL1",
      value: function () {
        return this.getQueryTimerExtension();
      }
    }, {
      key: "beginQuery",
      value: function () {
        if (k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
          var e = this.gl;
          var t = this.getQueryTimerExtensionWebGL2();
          var n = e.createQuery();
          e.beginQuery(t.TIME_ELAPSED_EXT, n);
          return n;
        }
        var r = this.getQueryTimerExtensionWebGL1();
        var a = r.createQueryEXT();
        r.beginQueryEXT(r.TIME_ELAPSED_EXT, a);
        return a;
      }
    }, {
      key: "endQuery",
      value: function () {
        if (k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") !== 2) {
          var e = this.getQueryTimerExtensionWebGL1();
          e.endQueryEXT(e.TIME_ELAPSED_EXT);
        } else {
          var t = this.gl;
          var n = this.getQueryTimerExtensionWebGL2();
          t.endQuery(n.TIME_ELAPSED_EXT);
        }
      }
    }, {
      key: "waitForQueryAndGetTime",
      value: (t = c(o().mark(function e(t) {
        var n = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                e.next = 2;
                return V$(function () {
                  return n.disposed || n.isQueryAvailable(t, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
                });
              case 2:
                return e.abrupt("return", this.getQueryTime(t, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
              case 3:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "getQueryTime",
      value: function (e, t) {
        if (t === 0) {
          return null;
        }
        if (t === 2) {
          var n = this.gl;
          return n.getQueryParameter(e, n.QUERY_RESULT) / 1000000;
        }
        var r = this.getQueryTimerExtensionWebGL1();
        return r.getQueryObjectEXT(e, r.QUERY_RESULT_EXT) / 1000000;
      }
    }, {
      key: "isQueryAvailable",
      value: function (e, t) {
        if (t === 0) {
          return true;
        }
        if (t === 2) {
          var n = this.gl;
          var r = this.getQueryTimerExtensionWebGL2();
          var a = n.getQueryParameter(e, n.QUERY_RESULT_AVAILABLE);
          if (this.disjoint == null) {
            this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT);
          }
          return a && !this.disjoint;
        }
        var i = this.getQueryTimerExtensionWebGL1();
        var o = i.getQueryObjectEXT(e, i.QUERY_RESULT_AVAILABLE_EXT);
        if (this.disjoint == null) {
          this.disjoint = this.gl.getParameter(i.GPU_DISJOINT_EXT);
        }
        return o && !this.disjoint;
      }
    }, {
      key: "pollFence",
      value: function (e) {
        var t = this;
        return new Promise(function (n) {
          t.addItemToPoll(function () {
            return e.isFencePassed();
          }, function () {
            return n();
          });
        });
      }
    }, {
      key: "pollItems",
      value: function () {
        for (var e = function (e) {
            for (var t = 0; t < e.length; ++t) {
              if (!e[t]()) {
                break;
              }
            }
            return t - 1;
          }(this.itemsToPoll.map(function (e) {
            return e.isDoneFn;
          })), t = 0; t <= e; ++t) {
          (0, this.itemsToPoll[t].resolveFn)();
        }
        this.itemsToPoll = this.itemsToPoll.slice(e + 1);
      }
    }, {
      key: "addItemToPoll",
      value: function (e, t) {
        var n = this;
        this.itemsToPoll.push({
          isDoneFn: e,
          resolveFn: t
        });
        if (!(this.itemsToPoll.length > 1)) {
          var r = undefined;
          if ("setTimeoutCustom" in k0().platform) {
            r = k0().platform.setTimeoutCustom.bind(k0().platform);
          }
          V$(function () {
            n.pollItems();
            return n.itemsToPoll.length === 0;
          }, function () {
            return 0;
          }, null, r);
        }
      }
    }, {
      key: "bindTextureToFrameBuffer",
      value: function (e) {
        this.throwIfDisposed();
        dNe(this.gl, e, this.framebuffer);
        if (this.debug) {
          mNe(this.gl);
        }
      }
    }, {
      key: "unbindTextureToFrameBuffer",
      value: function () {
        if (this.outputTexture != null) {
          dNe(this.gl, this.outputTexture, this.framebuffer);
          if (this.debug) {
            mNe(this.gl);
          }
        } else {
          vNe(this.gl, this.framebuffer);
        }
      }
    }, {
      key: "downloadMatrixDriver",
      value: function (e, t) {
        this.bindTextureToFrameBuffer(e);
        var n = t();
        this.unbindTextureToFrameBuffer();
        return n;
      }
    }, {
      key: "setOutputMatrixTextureDriver",
      value: function (e, t, n) {
        this.throwIfDisposed();
        var r = this.gl;
        dNe(r, e, this.framebuffer);
        if (this.debug) {
          mNe(r);
        }
        this.outputTexture = e;
        HIe(r, function () {
          return r.viewport(0, 0, t, n);
        });
        HIe(r, function () {
          return r.scissor(0, 0, t, n);
        });
      }
    }, {
      key: "setOutputMatrixWriteRegionDriver",
      value: function (e, t, n, r) {
        var a = this;
        this.throwIfDisposed();
        HIe(this.gl, function () {
          return a.gl.scissor(e, t, n, r);
        });
      }
    }, {
      key: "throwIfDisposed",
      value: function () {
        if (this.disposed) {
          throw new Error("Attempted to use disposed GPGPUContext.");
        }
      }
    }, {
      key: "throwIfNoProgram",
      value: function () {
        if (this.program == null) {
          throw new Error("No GPU program is currently set.");
        }
      }
    }]);
    return e;
  }();
  var JSe = Ige;
  var ZSe = Ege;
  var QSe = Cge;
  var $Se = Age;
  var eTe = yge;
  var tTe = Mge;
  var nTe = Pge;
  var rTe = Bge;
  var aTe = Vge;
  var iTe = Hge;
  var oTe = Xge;
  var sTe = eye;
  var uTe = tye;
  var cTe = nye;
  var lTe = iye;
  var hTe = uye;
  var pTe = hye;
  var fTe = dye;
  var dTe = vye;
  var vTe = yye;
  var mTe = bye;
  var gTe = wye;
  var yTe = Sye;
  var bTe = Aye;
  var xTe = _ye;
  var kTe = zye;
  var wTe = Vye;
  var ITe = jye;
  var NTe = Yye;
  var STe = Jye;
  var TTe = Zye;
  var ETe = ebe;
  var CTe = tbe;
  var ATe = uge;
  var RTe = abe;
  var _Te = sbe;
  var OTe = ube;
  var FTe = cbe;
  var DTe = lbe;
  var MTe = mbe;
  var LTe = bbe;
  var zTe = kbe;
  var PTe = Ibe;
  var BTe = Nbe;
  var WTe = Sbe;
  var UTe = Abe;
  var VTe = Obe;
  var GTe = Dye;
  var jTe = Fbe;
  function HTe(e, t) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, t).map(function (t) {
      return `${e}.${t}`;
    });
  }
  function qTe(e, t) {
    if (t === 1) {
      return [e];
    } else {
      return HTe(e, t);
    }
  }
  var KTe = function () {
    function e(t) {
      l(this, e);
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.outputShape = t;
      this.rank = t.length;
      this.enableShapeUniforms = ySe(this.outputShape.length);
      if (this.rank === 0) {
        this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
      } else {
        var n = qTe("rc", this.rank);
        var r = cSe(this.rank);
        var a = this.getOutOfBoundsCondition(n);
        var i = this.getSetup(n);
        var o = this.getOutput(n);
        this.userCode = `
        void main() {
          ${r} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `;
      }
    }
    p(e, [{
      key: "getSourceCoordsArr",
      value: function (e) {
        var t = [];
        for (var n = 0; n <= 1; n++) {
          for (var r = 0; r <= 1; r++) {
            var a = `${n === 0 ? "r" : "rp1"}, ${r === 0 ? "c" : "cp1"}`;
            for (var i = 2; i < this.rank; i++) {
              a = `${e[e.length - 1 - i]},${a}`;
            }
            t.push(a);
          }
        }
        return t;
      }
    }, {
      key: "getOutOfBoundsCondition",
      value: function (e) {
        if (this.rank === 1) {
          return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
        }
        var t = "";
        for (var n = this.rank - 2; n < this.rank; n++) {
          t += `${e[n]} >= ${this.enableShapeUniforms ? `outShape[${n}]` : this.outputShape[n]}`;
          if (n < this.rank - 1) {
            t += "||";
          }
        }
        return t;
      }
    }, {
      key: "getSetup",
      value: function (e) {
        if (this.rank === 1) {
          return "";
        }
        var t = e.slice(-2);
        var n = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1];
        var r = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
        return `
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `;
      }
    }, {
      key: "getOutput",
      value: function (e) {
        var t = this.getSourceCoordsArr(e);
        if (this.rank === 1) {
          var n = this.enableShapeUniforms ? "outShape" : this.outputShape[0];
          return `getA(rc), (rc + 1 >= ${n} ? 0. : getA(rc + 1)), 0, 0`;
        }
        return `getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`;
      }
    }]);
    return e;
  }();
  var XTe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "inputShape",
      type: "ivec3"
    }];
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var r;
    var a;
    var i;
    var o = "";
    for (var s = 0; s < 4; s++) {
      var u = "thisRC = rc;";
      if (s % 2 == 1) {
        u += "thisRC.z += 1;";
      }
      if (s > 1) {
        u += "thisRC.y += 1;";
      }
      o += `
        ${u}
        ${s > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s > 0 ? "}" : ""}
      `;
    }
    this.userCode = `
      ${r = n, a = this.enableShapeUniforms, i = a ? function (e, t, n = "index") {
      var r = e.map(function (e, t) {
        return t;
      });
      var a = UNe(r, t);
      return a.map(function (t, r) {
        var i = `int ${e[r]} = ${n} / ${a[r]}`;
        var o = r === a.length - 1 ? `int ${e[r + 1]} = ${n} - ${e[r]} * ${a[r]}` : `index -= ${e[r]} * ${a[r]}`;
        return `${i}; ${o};`;
      }).join("");
    }(["r", "c", "d"], "inputShape") : BNe(["r", "c", "d"], r), `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${i}
      return ivec3(r, c, d);
    }
  `}
      ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : VNe(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : t[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : t[2]};

        ${o}

        setOutput(result);
      }
    `;
  });
  var YTe = function () {
    function e(t) {
      l(this, e);
      this.gpgpu = t;
      this.numUsedTextures = 0;
      this.numFreeTextures = 0;
      this._numBytesAllocated = 0;
      this._numBytesFree = 0;
      this.freeTextures = {};
      this.usedTextures = {};
      this.logEnabled = false;
    }
    p(e, [{
      key: "acquireTexture",
      value: function (e, t, n) {
        var r = ZTe(t, n);
        var a = QTe(e, r, n);
        if (!(a in this.freeTextures)) {
          this.freeTextures[a] = [];
        }
        if (!(a in this.usedTextures)) {
          this.usedTextures[a] = [];
        }
        var i;
        var o = JTe(e, r, this.gpgpu.gl, this.gpgpu.textureConfig, n);
        if (this.freeTextures[a].length > 0) {
          this.numFreeTextures--;
          this.numUsedTextures++;
          this._numBytesFree -= o;
          this.log();
          var s = this.freeTextures[a].pop();
          this.usedTextures[a].push(s);
          return s;
        }
        if (r === LIe.PACKED_2X2_FLOAT32) {
          i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]);
        } else if (r === LIe.PACKED_2X2_FLOAT16) {
          i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]);
        } else if (r === LIe.UNPACKED_FLOAT32) {
          i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]);
        } else if (r === LIe.UNPACKED_FLOAT16) {
          i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]);
        } else if (r === LIe.PACKED_4X1_UNSIGNED_BYTE) {
          i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1]);
        }
        this.usedTextures[a].push(i);
        this.numUsedTextures++;
        this._numBytesAllocated += o;
        this.log();
        return i;
      }
    }, {
      key: "releaseTexture",
      value: function (e, t, n, r) {
        if (this.freeTextures != null) {
          var a = ZTe(n, r);
          var i = QTe(t, a, r);
          if (!(i in this.freeTextures)) {
            this.freeTextures[i] = [];
          }
          var o = JTe(t, a, this.gpgpu.gl, this.gpgpu.textureConfig, r);
          var s = k0().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
          if (s !== -1 && this._numBytesAllocated > s) {
            this.gpgpu.deleteMatrixTexture(e.texture);
            this._numBytesAllocated -= o;
          } else {
            this.freeTextures[i].push(e);
            this.numFreeTextures++;
            this._numBytesFree += o;
          }
          this.numUsedTextures--;
          var u = this.usedTextures[i];
          var c = u && u.indexOf(e);
          if (c == null || c < 0) {
            throw new Error("Cannot release a texture that was never provided by this texture manager");
          }
          u[c] = u[u.length - 1];
          u.pop();
          this.log();
        }
      }
    }, {
      key: "log",
      value: function () {
        if (this.logEnabled) {
          var e = this.numFreeTextures + this.numUsedTextures;
          console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${e})`);
          var t = this._numBytesFree / this._numBytesAllocated;
          console.log(`Bytes allocated: ${this._numBytesAllocated}`);
          console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(t * 100)}%)`);
        }
      }
    }, {
      key: "numBytesAllocated",
      get: function () {
        return this._numBytesAllocated;
      }
    }, {
      key: "numBytesFree",
      get: function () {
        return this._numBytesFree;
      }
    }, {
      key: "getNumUsedTextures",
      value: function () {
        return this.numUsedTextures;
      }
    }, {
      key: "getNumFreeTextures",
      value: function () {
        return this.numFreeTextures;
      }
    }, {
      key: "dispose",
      value: function () {
        var e = this;
        if (this.freeTextures != null) {
          for (var t in this.freeTextures) {
            this.freeTextures[t].forEach(function (t) {
              e.gpgpu.deleteMatrixTexture(t.texture);
            });
          }
          for (var n in this.usedTextures) {
            this.usedTextures[n].forEach(function (t) {
              e.gpgpu.deleteMatrixTexture(t.texture);
            });
          }
          this.freeTextures = null;
          this.usedTextures = null;
          this.numUsedTextures = 0;
          this.numFreeTextures = 0;
          this._numBytesAllocated = 0;
          this._numBytesFree = 0;
        }
      }
    }]);
    return e;
  }();
  function JTe(e, t, n, r, a) {
    var i;
    var o = function (e, t) {
      switch (e) {
        case LIe.PACKED_2X2_FLOAT32:
          return LSe(t);
        case LIe.PACKED_2X2_FLOAT16:
          return PSe(t);
        case LIe.UNPACKED_FLOAT32:
          return RSe(t);
        case LIe.UNPACKED_FLOAT16:
          return OSe(t);
        case LIe.PACKED_4X1_UNSIGNED_BYTE:
          return DSe(t);
        default:
          throw new Error(`Unknown physical texture type ${e}`);
      }
    }(t, r);
    if (a) {
      var s = S(GIe(e[0], e[1]), 2);
      i = s[0] * s[1];
    } else {
      var u = S(UIe(e[0], e[1]), 2);
      i = u[0] * u[1];
    }
    var c = function (e, t) {
      var n = e;
      if (t === n.R32F) {
        return 4;
      }
      if (t === n.R16F) {
        return 2;
      }
      if (t === n.RGBA32F) {
        return 16;
      }
      if (t === e.RGBA) {
        return 16;
      }
      if (t === n.RGBA16F) {
        return 8;
      }
      if (t === n.RGBA8) {
        return 4;
      }
      throw new Error(`Unknown internal format ${t}`);
    }(n, o);
    return i * c;
  }
  function ZTe(e, t) {
    if (e === MIe.UPLOAD) {
      return LIe.PACKED_2X2_FLOAT32;
    }
    if (e === MIe.RENDER || e == null) {
      return function (e) {
        if (k0().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
          if (e) {
            return LIe.PACKED_2X2_FLOAT32;
          } else {
            return LIe.UNPACKED_FLOAT32;
          }
        } else if (e) {
          return LIe.PACKED_2X2_FLOAT16;
        } else {
          return LIe.UNPACKED_FLOAT16;
        }
      }(t);
    }
    if (e === MIe.DOWNLOAD || e === MIe.PIXELS) {
      return LIe.PACKED_4X1_UNSIGNED_BYTE;
    }
    throw new Error(`Unknown logical texture type ${e}`);
  }
  function QTe(e, t, n) {
    return `${e[0]}_${e[1]}_${t}_${n}`;
  }
  var $Te = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A"];
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    this.userCode = `
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
  });
  var eEe = "if (isnan(x)) return x;";
  var tEe = "return x;";
  var nEe = "return abs(x);";
  var rEe = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  var aEe = eEe + "\n  return (x < 0.0) ? 0.0 : x;\n";
  var iEe = eEe + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
  var oEe = "return x;";
  var sEe = "return 1.0 / (1.0 + exp(-1.0 * x));";
  var uEe = "return x;";
  var cEe = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";
  var lEe = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
  var hEe = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
  var pEe = "return 1.0 / (1.0 + exp(-1.0 * x));";
  var fEe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
  });
  var dEe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = false;
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var n = t.length;
    var r = qTe("rc", n);
    var a = cSe(n);
    var i = function (e, t) {
      if (e === 1) {
        return "rc";
      }
      var n = "";
      for (var r = 0; r < e; r++) {
        n += t[r];
        if (r < e - 1) {
          n += ",";
        }
      }
      return n;
    }(n, r);
    var o = r.slice(-2);
    var s = n <= 1 ? "rc" : `vec2(${o.join(",")})`;
    this.userCode = `
      void main() {
        ${a} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${s}));
      }
    `;
  });
  var vEe = one;
  var mEe = {};
  var gEe = k0().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
  var yEe = function (e) {
    d(s, e);
    var t;
    var n;
    var r;
    var a;
    var i = w(s);
    function s(e) {
      var t;
      var n;
      var r;
      l(this, s);
      (t = i.call(this)).pendingRead = new WeakMap();
      t.pendingDisposal = new WeakSet();
      t.dataRefCount = new WeakMap();
      t.numBytesInGPU = 0;
      t.uploadWaitMs = 0;
      t.downloadWaitMs = 0;
      t.lastGlFlushTime = 0;
      t.warnedAboutMemory = false;
      t.pendingDeletes = 0;
      t.disposed = false;
      if (!k0().getBool("HAS_WEBGL")) {
        throw new Error("WebGL is not supported on this device");
      }
      if (e != null) {
        if (e instanceof YSe) {
          n = e;
        } else {
          var a = WIe(k0().getNumber("WEBGL_VERSION"), e);
          n = new YSe(a);
        }
        t.binaryCache = {};
        t.gpgpuCreatedLocally = false;
      } else {
        var o = WIe(k0().getNumber("WEBGL_VERSION"));
        n = new YSe(o);
        if (!((r = k0().getNumber("WEBGL_VERSION")) in mEe)) {
          mEe[r] = {};
        }
        t.binaryCache = mEe[r];
        t.gpgpuCreatedLocally = true;
      }
      t.gpgpu = n;
      t.canvas = t.gpgpu.gl.canvas;
      t.textureManager = new YTe(t.gpgpu);
      t.numMBBeforeWarning = k0().global.screen == null ? 1024 : k0().global.screen.height * k0().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024;
      t.texData = new S$(x(t), q5());
      return t;
    }
    p(s, [{
      key: "nextDataId",
      value: function () {
        return s.nextDataId++;
      }
    }, {
      key: "numDataIds",
      value: function () {
        return this.texData.numDataIds() - this.pendingDeletes;
      }
    }, {
      key: "writeTexture",
      value: function (e, t, n, r, a, i) {
        var o = this.makeTensorInfo(t, n);
        var s = this.texData.get(o.dataId);
        s.isPacked = false;
        s.texture = {
          texture: e,
          texShape: [r, a]
        };
        s.texShape = [r, a];
        var u = wNe(t);
        var c = new NSe(u, false, i);
        var l = this.runWebGLProgram(c, [o], n, [[r, a]]);
        l.shape = t;
        s.texture = null;
        this.disposeIntermediateTensorInfo(o);
        return l.dataId;
      }
    }, {
      key: "write",
      value: function (e, t, n) {
        if (k0().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || k0().getBool("DEBUG")) {
          this.checkNumericalProblems(e);
        }
        if (n === "complex64" && e != null) {
          throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        }
        var r = {
          id: this.nextDataId()
        };
        this.texData.set(r, {
          shape: t,
          dtype: n,
          values: e,
          usage: MIe.UPLOAD,
          refCount: 1
        });
        return r;
      }
    }, {
      key: "refCount",
      value: function (e) {
        if (this.texData.has(e)) {
          return this.texData.get(e).refCount;
        } else {
          return 0;
        }
      }
    }, {
      key: "incRef",
      value: function (e) {
        this.texData.get(e).refCount++;
      }
    }, {
      key: "decRef",
      value: function (e) {
        if (this.texData.has(e)) {
          this.texData.get(e).refCount--;
        }
      }
    }, {
      key: "move",
      value: function (e, t, n, r, a) {
        if (k0().getBool("DEBUG")) {
          this.checkNumericalProblems(t);
        }
        if (r === "complex64") {
          throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        }
        this.texData.set(e, {
          shape: n,
          dtype: r,
          values: t,
          usage: MIe.UPLOAD,
          refCount: a
        });
      }
    }, {
      key: "disposeIntermediateTensorInfo",
      value: function (e) {
        this.disposeData(e.dataId);
      }
    }, {
      key: "readSync",
      value: function (e) {
        var t = this.texData.get(e);
        var n = t.values;
        var r = t.dtype;
        var a = t.complexTensorInfos;
        var i = t.slice;
        var o = t.shape;
        var s = t.isPacked;
        if (i != null) {
          var u;
          u = s ? new fEe(o, oEe) : new $Te(o, oEe);
          var c = this.runWebGLProgram(u, [{
            dataId: e,
            shape: o,
            dtype: r
          }], r);
          var l = this.readSync(c.dataId);
          this.disposeIntermediateTensorInfo(c);
          return l;
        }
        if (n != null) {
          return this.convertAndCacheOnCPU(e);
        }
        if (r === "string") {
          return n;
        }
        var h;
        var p;
        var f = this.activeTimers != null;
        if (f) {
          h = z4();
        }
        if (r === "complex64") {
          p = Tie(this.readSync(a.real.dataId), this.readSync(a.imag.dataId));
        } else {
          p = this.getValuesFromTexture(e);
        }
        if (f) {
          this.downloadWaitMs += z4() - h;
        }
        return this.convertAndCacheOnCPU(e, p);
      }
    }, {
      key: "read",
      value: (a = c(o().mark(function e(t) {
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l;
        var h;
        var p;
        var f;
        var d;
        var v;
        var m;
        var g;
        var y;
        var b;
        var x;
        var k;
        var w;
        var I;
        var N;
        var S;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!this.pendingRead.has(t)) {
                  e.next = 3;
                  break;
                }
                n = this.pendingRead.get(t);
                return e.abrupt("return", new Promise(function (e) {
                  return n.push(e);
                }));
              case 3:
                r = this.texData.get(t);
                a = r.values;
                i = r.shape;
                s = r.slice;
                u = r.dtype;
                c = r.complexTensorInfos;
                l = r.isPacked;
                if (s == null) {
                  e.next = 11;
                  break;
                }
                h = l ? new fEe(i, oEe) : new $Te(i, oEe);
                p = this.runWebGLProgram(h, [{
                  dataId: t,
                  shape: i,
                  dtype: u
                }], u);
                f = this.read(p.dataId);
                this.disposeIntermediateTensorInfo(p);
                return e.abrupt("return", f);
              case 11:
                if (a == null) {
                  e.next = 13;
                  break;
                }
                return e.abrupt("return", this.convertAndCacheOnCPU(t));
              case 13:
                if (!k0().getBool("DEBUG")) {
                  e.next = 16;
                  break;
                }
                if (k0().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") || k0().getNumber("WEBGL_VERSION") !== 2) {
                  e.next = 16;
                  break;
                }
                throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
              case 16:
                d = null;
                if (u !== "complex64" && k0().get("WEBGL_BUFFER_SUPPORTED")) {
                  v = this.decode(t);
                  g = this.texData.get(v.dataId);
                  d = (m = this.gpgpu).createBufferFromTexture.apply(m, [g.texture.texture].concat(T(VIe(i))));
                }
                this.pendingRead.set(t, []);
                if (u === "complex64") {
                  e.next = 22;
                  break;
                }
                e.next = 22;
                return this.gpgpu.createAndWaitForFence();
              case 22:
                if (u !== "complex64") {
                  e.next = 31;
                  break;
                }
                e.next = 25;
                return Promise.all([this.read(c.real.dataId), this.read(c.imag.dataId)]);
              case 25:
                b = e.sent;
                x = b[0];
                k = b[1];
                y = Tie(x, k);
                e.next = 32;
                break;
              case 31:
                if (d == null) {
                  y = this.getValuesFromTexture(t);
                } else {
                  w = L$(i);
                  y = this.gpgpu.downloadFloat32MatrixFromBuffer(d, w);
                }
              case 32:
                if (v != null) {
                  this.disposeIntermediateTensorInfo(v);
                }
                if (d != null) {
                  HIe(I = this.gpgpu.gl, function () {
                    return I.deleteBuffer(d);
                  });
                }
                N = this.convertAndCacheOnCPU(t, y);
                S = this.pendingRead.get(t);
                this.pendingRead.delete(t);
                S.forEach(function (e) {
                  return e(N);
                });
                if (this.pendingDisposal.has(t)) {
                  this.pendingDisposal.delete(t);
                  if (this.disposeData(t)) {
                    q5().removeDataId(t, this);
                  }
                  this.pendingDeletes--;
                }
                return e.abrupt("return", N);
              case 40:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return a.apply(this, arguments);
      })
    }, {
      key: "readToGPU",
      value: function (e, t = {}) {
        var n = this.texData.get(e);
        var r = n.values;
        var a = n.shape;
        var i = n.slice;
        var o = n.dtype;
        var s = n.isPacked;
        var u = n.texture;
        if (o === "complex64") {
          throw new Error("Does not support reading texture for complex64 dtype.");
        }
        if (i != null) {
          var c;
          c = s ? new fEe(a, oEe) : new $Te(a, oEe);
          var l = this.runWebGLProgram(c, [{
            dataId: e,
            shape: a,
            dtype: o
          }], o);
          var h = this.readToGPU(l, t);
          this.disposeIntermediateTensorInfo(l);
          return h;
        }
        if (u == null) {
          throw r != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
        }
        var p = this.decode(e, t.customTexShape);
        var f = q5().makeTensorFromTensorInfo(p);
        var d = this.texData.get(p.dataId);
        return Object.assign({
          tensorRef: f
        }, d.texture);
      }
    }, {
      key: "bufferSync",
      value: function (e) {
        var t = this.readSync(e.dataId);
        if (e.dtype === "string") {
          try {
            var n = t.map(function (e) {
              return W4(e);
            });
            return l8(e.shape, e.dtype, n);
          } catch (e) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
          }
        }
        return l8(e.shape, e.dtype, t);
      }
    }, {
      key: "checkNumericalProblems",
      value: function (e) {
        if (e != null) {
          for (var t = 0; t < e.length; t++) {
            var n = e[t];
            if (!qIe(n)) {
              if (k0().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
                throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
              }
              throw Error(`The value ${n} cannot be represented on this device.`);
            }
          }
        }
      }
    }, {
      key: "getValuesFromTexture",
      value: function (e) {
        var t = this.texData.get(e);
        var n = t.shape;
        var r = t.dtype;
        var a = t.isPacked;
        var i = L$(n);
        if (k0().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
          var o;
          var s = this.decode(e);
          var u = this.texData.get(s.dataId);
          var c = (o = this.gpgpu).downloadMatrixFromPackedTexture.apply(o, [u.texture.texture].concat(T(VIe(n)))).subarray(0, i);
          this.disposeIntermediateTensorInfo(s);
          return c;
        }
        var l = k0().getBool("WEBGL_PACK") && a === true;
        var h = l ? wNe(n) : n;
        var p = l ? new wSe(h) : new kSe(h);
        var f = this.runWebGLProgram(p, [{
          shape: h,
          dtype: r,
          dataId: e
        }], "float32");
        var d = this.texData.get(f.dataId);
        var v = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture, d.texShape[0], d.texShape[1]).subarray(0, i);
        this.disposeIntermediateTensorInfo(f);
        return v;
      }
    }, {
      key: "timerAvailable",
      value: function () {
        return k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
      }
    }, {
      key: "time",
      value: function (e) {
        var t = this;
        var n = this.activeTimers;
        var r = [];
        var a = false;
        if (this.programTimersStack == null) {
          this.programTimersStack = r;
          a = true;
        } else {
          this.activeTimers.push(r);
        }
        this.activeTimers = r;
        e();
        var i = V4(this.activeTimers.map(function (e) {
          return e.query;
        })).filter(function (e) {
          return e != null;
        });
        var s = V4(this.activeTimers.map(function (e) {
          return e.name;
        })).filter(function (e) {
          return e != null;
        });
        this.activeTimers = n;
        if (a) {
          this.programTimersStack = null;
        }
        var u = {
          uploadWaitMs: this.uploadWaitMs,
          downloadWaitMs: this.downloadWaitMs,
          kernelMs: null,
          wallMs: null
        };
        return c(o().mark(function e() {
          var n;
          return o().wrap(function (e) {
            while (true) {
              switch (e.prev = e.next) {
                case 0:
                  if (!(k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                    e.next = 8;
                    break;
                  }
                  e.next = 3;
                  return Promise.all(i);
                case 3:
                  n = e.sent;
                  u.kernelMs = O$(n);
                  u.getExtraProfileInfo = function () {
                    return n.map(function (e, t) {
                      return {
                        name: s[t],
                        ms: e
                      };
                    }).map(function (e) {
                      return `${e.name}: ${e.ms}`;
                    }).join(", ");
                  };
                  e.next = 9;
                  break;
                case 8:
                  u.kernelMs = {
                    error: "WebGL query timers are not supported in this environment."
                  };
                case 9:
                  t.uploadWaitMs = 0;
                  t.downloadWaitMs = 0;
                  return e.abrupt("return", u);
                case 12:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }))();
      }
    }, {
      key: "memory",
      value: function () {
        return {
          unreliable: false,
          numBytesInGPU: this.numBytesInGPU,
          numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
          numBytesInGPUFree: this.textureManager.numBytesFree
        };
      }
    }, {
      key: "startTimer",
      value: function () {
        if (k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          return this.gpgpu.beginQuery();
        } else {
          return {
            startMs: z4(),
            endMs: null
          };
        }
      }
    }, {
      key: "endTimer",
      value: function (e) {
        if (k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          this.gpgpu.endQuery();
          return e;
        } else {
          e.endMs = z4();
          return e;
        }
      }
    }, {
      key: "getQueryTime",
      value: (r = c(o().mark(function e(t) {
        var n;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!(k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                  e.next = 2;
                  break;
                }
                return e.abrupt("return", this.gpgpu.waitForQueryAndGetTime(t));
              case 2:
                n = t;
                return e.abrupt("return", n.endMs - n.startMs);
              case 4:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return r.apply(this, arguments);
      })
    }, {
      key: "disposeData",
      value: function (e, t = false) {
        if (this.pendingDisposal.has(e)) {
          return false;
        }
        if (!this.texData.has(e)) {
          return true;
        }
        if (t) {
          this.texData.get(e).refCount = 0;
        } else {
          this.texData.get(e).refCount--;
        }
        if (!t && this.texData.get(e).refCount > 0) {
          return false;
        }
        if (this.pendingRead.has(e)) {
          this.pendingDisposal.add(e);
          this.pendingDeletes++;
          return false;
        }
        this.releaseGPUData(e);
        var n = this.texData.get(e);
        var r = n.complexTensorInfos;
        if (r != null) {
          this.disposeData(r.real.dataId, t);
          this.disposeData(r.imag.dataId, t);
        }
        this.texData.delete(e);
        return true;
      }
    }, {
      key: "releaseGPUData",
      value: function (e) {
        var t = this.texData.get(e);
        var n = t.texture;
        var r = t.dtype;
        var a = t.texShape;
        var i = t.usage;
        var o = t.isPacked;
        var s = t.slice;
        var u = s && s.origDataId || e;
        var c = this.dataRefCount.get(u);
        if (c > 1) {
          this.dataRefCount.set(u, c - 1);
        } else {
          this.dataRefCount.delete(u);
          if (n != null) {
            this.numBytesInGPU -= this.computeBytes(a, r);
            this.textureManager.releaseTexture(n, a, i, o);
          }
        }
        var l = this.texData.get(e);
        l.texture = null;
        l.texShape = null;
        l.isPacked = false;
        l.slice = null;
      }
    }, {
      key: "getTexture",
      value: function (e) {
        this.uploadToGPU(e);
        return this.texData.get(e).texture.texture;
      }
    }, {
      key: "getDataInfo",
      value: function (e) {
        return this.texData.get(e);
      }
    }, {
      key: "shouldExecuteOnCPU",
      value: function (e) {
        var t = this;
        var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : gEe;
        return k0().getBool("WEBGL_CPU_FORWARD") && e.every(function (e) {
          return t.texData.get(e.dataId).texture == null && L$(e.shape) < n;
        });
      }
    }, {
      key: "getGPGPUContext",
      value: function () {
        return this.gpgpu;
      }
    }, {
      key: "where",
      value: function (e) {
        z3("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        var t = e.dataSync();
        return vEe(e.shape, t);
      }
    }, {
      key: "packedUnaryOp",
      value: function (e, t, n) {
        var r = new fEe(e.shape, t);
        var a = this.compileAndRun(r, [e], n);
        return q5().makeTensorFromTensorInfo(a);
      }
    }, {
      key: "abs",
      value: function (e) {
        if (this.shouldExecuteOnCPU([e]) && e.dtype !== "complex64") {
          var t = ATe(this.texData.get(e.dataId).values);
          return this.makeOutput(e.shape, e.dtype, t);
        }
        if (k0().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(e, nEe, e.dtype);
        }
        var n = new $Te(e.shape, nEe);
        var r = this.compileAndRun(n, [e]);
        return q5().makeTensorFromTensorInfo(r);
      }
    }, {
      key: "makeTensorInfo",
      value: function (e, t, n) {
        var r;
        if (t === "string" && n != null && n.length > 0 && $$(n[0])) {
          var a = n.map(function (e) {
            return B4(e);
          });
          r = this.write(a, e, t);
        } else {
          r = this.write(n, e, t);
        }
        this.texData.get(r).usage = null;
        return {
          dataId: r,
          shape: e,
          dtype: t
        };
      }
    }, {
      key: "makeOutput",
      value: function (e, t, n) {
        return q5().makeTensorFromTensorInfo(this.makeTensorInfo(e, t, n), this);
      }
    }, {
      key: "unpackTensor",
      value: function (e) {
        var t = new dEe(e.shape);
        return this.runWebGLProgram(t, [e], e.dtype);
      }
    }, {
      key: "packTensor",
      value: function (e) {
        var t = new KTe(e.shape);
        return this.runWebGLProgram(t, [e], e.dtype, null, true);
      }
    }, {
      key: "packedReshape",
      value: function (e, t) {
        var n = [xNe(e.shape)].concat(T(kNe(e.shape)));
        var r = {
          dtype: e.dtype,
          shape: n,
          dataId: e.dataId
        };
        var a = [xNe(t)].concat(T(kNe(t)));
        var i = new XTe(a, n);
        var o = [n];
        var s = this.runWebGLProgram(i, [r], e.dtype, o, true);
        return {
          dataId: s.dataId,
          shape: t,
          dtype: s.dtype
        };
      }
    }, {
      key: "decode",
      value: function (e, t) {
        var n = this.texData.get(e);
        var r = n.isPacked;
        var a = n.shape;
        var i = n.dtype;
        if (t != null) {
          F$(L$(a) <= t[0] * t[1] * 4, function () {
            return "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.";
          });
        }
        var o;
        var s = wNe(a);
        o = r ? new xSe(s) : new bSe(s);
        var u = [t ?? VIe(s)];
        return {
          dtype: i,
          shape: a,
          dataId: this.runWebGLProgram(o, [{
            shape: s,
            dtype: i,
            dataId: e
          }], i, u, true, t).dataId
        };
      }
    }, {
      key: "runWebGLProgram",
      value: function (e, t, n, r) {
        var a = this;
        var i = arguments.length > 4 && arguments[4] !== undefined && arguments[4];
        var o = arguments.length > 5 ? arguments[5] : undefined;
        var s = this.makeTensorInfo(e.outputShape, n);
        var u = this.texData.get(s.dataId);
        if (e.packedOutput) {
          u.isPacked = true;
        }
        if (e.outPackingScheme === DIe.DENSE) {
          var c = o ?? VIe(e.outputShape);
          u.texShape = c.map(function (e) {
            return e * 2;
          });
        }
        if (e.outTexUsage != null) {
          u.usage = e.outTexUsage;
        }
        if (L$(s.shape) === 0) {
          u.values = q$(s.dtype, 0);
          return s;
        }
        var l = [];
        var h = t.map(function (t) {
          if (t.dtype === "complex64") {
            throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
          }
          var n = a.texData.get(t.dataId);
          if (n.texture == null) {
            if (!e.packedInputs && L$(t.shape) <= k0().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
              return {
                shape: t.shape,
                texData: null,
                isUniform: true,
                uniformValues: n.values
              };
            }
            if (e.packedInputs) {
              n.isPacked = true;
              n.shape = t.shape;
            }
          }
          a.uploadToGPU(t.dataId);
          if (!!n.isPacked != !!e.packedInputs) {
            t = n.isPacked ? a.unpackTensor(t) : a.packTensor(t);
            l.push(t);
            n = a.texData.get(t.dataId);
          } else if (n.isPacked && !SNe(n.shape, t.shape)) {
            var r = t;
            var i = t.shape;
            t.shape = n.shape;
            t = a.packedReshape(t, i);
            l.push(t);
            n = a.texData.get(t.dataId);
            r.shape = i;
          }
          return {
            shape: t.shape,
            texData: n,
            isUniform: false
          };
        });
        this.uploadToGPU(s.dataId);
        var p;
        var f = {
          shape: s.shape,
          texData: u,
          isUniform: false
        };
        var d = gSe(e, h, f);
        var v = this.getAndSaveBinary(d, function () {
          return fSe(a.gpgpu, e, h, f);
        });
        var m = this.activeTimers != null;
        if (m) {
          p = this.startTimer();
        }
        if (!k0().get("ENGINE_COMPILE_ONLY")) {
          mSe(this.gpgpu, v, h, f, r);
        }
        l.forEach(function (e) {
          return a.disposeIntermediateTensorInfo(e);
        });
        if (m) {
          p = this.endTimer(p);
          this.activeTimers.push({
            name: e.constructor.name,
            query: this.getQueryTime(p)
          });
        }
        var g = k0().getNumber("WEBGL_FLUSH_THRESHOLD");
        if (g > 0) {
          var y = z4();
          if (y - this.lastGlFlushTime > g) {
            this.gpgpu.gl.flush();
            this.lastGlFlushTime = y;
          }
        }
        if (!k0().getBool("WEBGL_LAZILY_UNPACK") && u.isPacked && i === false) {
          var b = this.unpackTensor(s);
          this.disposeIntermediateTensorInfo(s);
          return b;
        }
        return s;
      }
    }, {
      key: "compileAndRun",
      value: function (e, t, n, r, a = false) {
        n = n || t[0].dtype;
        var i = this.runWebGLProgram(e, t, n, r, a);
        return i;
      }
    }, {
      key: "getAndSaveBinary",
      value: function (e, t) {
        if (!(e in this.binaryCache)) {
          this.binaryCache[e] = t();
        }
        return this.binaryCache[e];
      }
    }, {
      key: "getTextureManager",
      value: function () {
        return this.textureManager;
      }
    }, {
      key: "dispose",
      value: function () {
        var e = this;
        if (!this.disposed) {
          if (!k0().getBool("IS_TEST")) {
            Object.keys(this.binaryCache).forEach(function (t) {
              e.gpgpu.deleteProgram(e.binaryCache[t].webGLProgram);
              delete e.binaryCache[t];
            });
          }
          this.textureManager.dispose();
          if (this.canvas != null && typeof HTMLCanvasElement != "undefined" && this.canvas instanceof HTMLCanvasElement) {
            this.canvas.remove();
          } else {
            this.canvas = null;
          }
          if (this.gpgpuCreatedLocally) {
            this.gpgpu.program = null;
            this.gpgpu.dispose();
          }
          this.disposed = true;
        }
      }
    }, {
      key: "floatPrecision",
      value: function () {
        var e = this;
        if (this.floatPrecisionValue == null) {
          this.floatPrecisionValue = X5(function () {
            if (!k0().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
              var t = k0().getBool("DEBUG");
              k0().set("DEBUG", false);
              var n = e.abs(i9(1e-8)).dataSync()[0];
              k0().set("DEBUG", t);
              if (n > 0) {
                return 32;
              }
            }
            return 16;
          });
        }
        return this.floatPrecisionValue;
      }
    }, {
      key: "epsilon",
      value: function () {
        if (this.floatPrecision() === 32) {
          return 1e-7;
        } else {
          return 0.0001;
        }
      }
    }, {
      key: "uploadToGPU",
      value: function (e) {
        var t = this.texData.get(e);
        var n = t.shape;
        var r = t.dtype;
        var a = t.values;
        var i = t.texture;
        var o = t.usage;
        var s = t.isPacked;
        if (i == null) {
          var u;
          var c = this.activeTimers != null;
          if (c) {
            u = z4();
          }
          var l = t.texShape;
          if (l == null) {
            l = INe(n, s);
            t.texShape = l;
          }
          if (a != null) {
            var h;
            var p = wNe(n);
            var f = l[1];
            var d = l[0];
            var v = a instanceof Uint8Array || a instanceof Uint8ClampedArray;
            if (s || !v) {
              var m = S(GIe(l[0], l[1]), 2);
              f = m[0];
              d = m[1];
            }
            h = s ? new SSe(p, v) : new NSe(p, v);
            var g = v ? [d, f] : l;
            var y = this.makeTensorInfo(g, r);
            var b = this.texData.get(y.dataId);
            b.usage = v ? MIe.PIXELS : MIe.UPLOAD;
            b.texShape = g;
            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId), f, d, a);
            var x = [[d, f]];
            var k = this.runWebGLProgram(h, [y], r, x, true);
            var w = this.texData.get(k.dataId);
            t.texShape = w.texShape;
            t.isPacked = w.isPacked;
            t.usage = w.usage;
            if (k0().get("ENGINE_COMPILE_ONLY")) {
              this.disposeData(k.dataId);
            } else {
              t.texture = w.texture;
              t.values = null;
              this.texData.delete(k.dataId);
            }
            this.disposeIntermediateTensorInfo(y);
            if (c) {
              this.uploadWaitMs += z4() - u;
            }
          } else {
            var I = this.acquireTexture(l, o, r, s);
            t.texture = I;
          }
        }
      }
    }, {
      key: "convertAndCacheOnCPU",
      value: function (e, t) {
        var n = this.texData.get(e);
        var r = n.dtype;
        if (t != null) {
          n.values = function (e, t) {
            if (t === "float32" || t === "complex64") {
              return e;
            }
            if (t === "int32" || t === "bool") {
              for (var n = t === "int32" ? new Int32Array(e.length) : new Uint8Array(e.length), r = 0; r < n.length; ++r) {
                n[r] = Math.round(e[r]);
              }
              return n;
            }
            throw new Error(`Unknown dtype ${t}`);
          }(t, r);
        }
        return n.values;
      }
    }, {
      key: "acquireTexture",
      value: function (e, t, n, r) {
        this.numBytesInGPU += this.computeBytes(e, n);
        if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
          var a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
          this.warnedAboutMemory = true;
          console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`);
        }
        return this.textureManager.acquireTexture(e, t, r);
      }
    }, {
      key: "computeBytes",
      value: function (e, t) {
        return e[0] * e[1] * Z$(t);
      }
    }, {
      key: "checkCompileCompletion",
      value: function () {
        for (var e = 0, t = Object.entries(this.binaryCache); e < t.length; e++) {
          var n = S(t[e], 2)[1];
          this.checkCompletion_(n);
        }
      }
    }, {
      key: "checkCompileCompletionAsync",
      value: (n = c(o().mark(function e() {
        var t;
        var n;
        var r;
        var a;
        var i;
        var s;
        var u;
        var c;
        var l = this;
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                t = [];
                if (!this.gpgpu.parallelCompilationExtension) {
                  e.next = 6;
                  break;
                }
                n = 0;
                r = Object.entries(this.binaryCache);
                for (; n < r.length; n++) {
                  a = S(r[n], 2);
                  i = a[1];
                  t.push(this.checkCompletionAsync_(i));
                }
                return e.abrupt("return", Promise.all(t));
              case 6:
                s = o().mark(function e() {
                  var n;
                  var r;
                  var a;
                  return o().wrap(function (e) {
                    while (true) {
                      switch (e.prev = e.next) {
                        case 0:
                          n = S(c[u], 2);
                          r = n[1];
                          a = new Promise(function (e) {
                            try {
                              l.checkCompletion_(r);
                              e(true);
                            } catch (e) {
                              throw e;
                            }
                          });
                          t.push(a);
                        case 3:
                        case "end":
                          return e.stop();
                      }
                    }
                  }, e);
                });
                u = 0;
                c = Object.entries(this.binaryCache);
              case 8:
                if (!(u < c.length)) {
                  e.next = 13;
                  break;
                }
                return e.delegateYield(s(), "t0", 10);
              case 10:
                u++;
                e.next = 8;
                break;
              case 13:
                return e.abrupt("return", Promise.all(t));
              case 14:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function () {
        return n.apply(this, arguments);
      })
    }, {
      key: "checkCompletionAsync_",
      value: (t = c(o().mark(function e(t) {
        return o().wrap(function (e) {
          while (true) {
            switch (e.prev = e.next) {
              case 0:
                if (!this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {
                  e.next = 4;
                  break;
                }
                return e.abrupt("return", this.checkCompletion_(t));
              case 4:
                e.next = 6;
                return aie();
              case 6:
                return e.abrupt("return", this.checkCompletionAsync_(t));
              case 7:
              case "end":
                return e.stop();
            }
          }
        }, e, this);
      })), function (e) {
        return t.apply(this, arguments);
      })
    }, {
      key: "checkCompletion_",
      value: function (e) {
        if (this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {
          console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram));
          if (this.gpgpu.gl.getShaderParameter(e.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {
            eNe(e.source, this.gpgpu.gl.getShaderInfoLog(e.fragmentShader));
            throw new Error("Failed to compile fragment shader.");
          }
          throw new Error("Failed to link vertex and fragment shaders.");
        }
        return true;
      }
    }, {
      key: "getUniformLocations",
      value: function () {
        for (var e = 0, t = Object.values(this.binaryCache); e < t.length; e++) {
          var n = t[e];
          this.gpgpu.buildVao(n.webGLProgram);
          var r = dSe(this.gpgpu, n.program, n.webGLProgram);
          var a = r.variablesLocations;
          var i = r.customUniformLocations;
          var o = r.infLoc;
          var s = r.nanLoc;
          var u = r.outShapeLocation;
          var c = r.outShapeStridesLocation;
          var l = r.outTexShapeLocation;
          n.variablesLocations = a;
          n.customUniformLocations = i;
          n.infLoc = o;
          n.nanLoc = s;
          n.outShapeLocation = u;
          n.outShapeStridesLocation = c;
          n.outTexShapeLocation = l;
        }
      }
    }, {
      key: "createTensorFromGPUData",
      value: function (e, t, n) {
        e.channels = e.channels || "RGBA";
        var r = e.texture;
        var a = e.height;
        var i = e.width;
        var o = e.channels;
        var s = q5().backend;
        if (!s.gpgpu.gl.isTexture(r)) {
          throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
        }
        var u = s.writeTexture(r, t, n, a, i, o);
        return q5().makeTensorFromDataId(u, t, n, s);
      }
    }]);
    return s;
  }(T$);
  yEe.nextDataId = 0;
  var bEe = "4.15.0";
  function xEe() {
    k0().set("WEBGL_FORCE_F16_TEXTURES", true);
  }
  if (R5()) {
    $5("webgl", function () {
      return new yEe();
    }, 2);
  }
  var kEe = {
    forceHalfFloat: xEe
  };
  var wEe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["A", "B"];
    this.outputShape = z7(n, r);
    this.enableShapeUniforms = ySe(this.outputShape.length);
    this.userCode = `
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
  });
  var IEe = "\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";
  var NEe = p(function e(t, n, r, a = false) {
    l(this, e);
    this.variableNames = ["A", "B"];
    this.supportsBroadcasting = true;
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = z7(n, r);
    var i = this.outputShape.length;
    this.enableShapeUniforms = ySe(i);
    var o = "";
    if (a) {
      if (i === 0 || L$(this.outputShape) === 1) {
        o = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
      } else {
        var s = cSe(i);
        o = `
          ${s} coords = getOutputCoords();
        `;
        if (i === 1) {
          if (this.enableShapeUniforms) {
            o += "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
          } else {
            o += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
          }
        } else {
          var u = qTe("coords", i);
          if (this.enableShapeUniforms) {
            o += `
            bool nextRowOutOfBounds =
              (${u[i - 2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${u[i - 1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
          } else {
            o += `
            bool nextRowOutOfBounds =
              (${u[i - 2]} + 1) >= ${this.outputShape[i - 2]};
            bool nextColOutOfBounds =
              (${u[i - 1]} + 1) >= ${this.outputShape[i - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
          }
        }
      }
    }
    this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `;
  });
  function SEe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.x;
    n.incRef(r.dataId);
    return {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  var TEe = {
    kernelName: W1,
    backendName: "webgl",
    kernelFunc: SEe
  };
  function EEe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.real;
    var a = t.imag;
    var i = n.makeTensorInfo(r.shape, "complex64");
    var o = n.texData.get(i.dataId);
    var s = SEe({
      inputs: {
        x: r
      },
      backend: n
    });
    var u = SEe({
      inputs: {
        x: a
      },
      backend: n
    });
    o.complexTensorInfos = {
      real: s,
      imag: u
    };
    return i;
  }
  var CEe = {
    kernelName: Z0,
    backendName: "webgl",
    kernelFunc: EEe
  };
  var AEe = "return (a < 0.) ? b * a : a;";
  var REe = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
  var _Ee = {
    kernelName: q1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.alpha;
      var o = n.makeTensorInfo([], "float32", M4(i, "float32"));
      var s = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe(REe, a.shape, o.shape) : new wEe(AEe, a.shape, o.shape);
      var u = n.runWebGLProgram(s, [a, o], "float32");
      n.disposeIntermediateTensorInfo(o);
      return u;
    }
  };
  var OEe = "return (a < 0.) ? b * a : a;";
  var FEe = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
  var DEe = {
    kernelName: C2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.x;
      var a = t.alpha;
      var i = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe(FEe, r.shape, a.shape) : new wEe(OEe, r.shape, a.shape);
      return n.runWebGLProgram(i, [r, a], "float32");
    }
  };
  function MEe(e) {
    var t = e.opSnippet;
    var n = e.packedOpSnippet;
    var r = e.cpuKernelImpl;
    var a = e.dtype;
    return function (e) {
      var i;
      var o = e.inputs;
      var s = e.backend;
      var u = o.x;
      var c = s;
      var l = a || u.dtype;
      if (c.shouldExecuteOnCPU([u]) && r != null) {
        var h = c.texData.get(u.dataId);
        var p = r(h.values, l);
        return c.makeTensorInfo(u.shape, l, p);
      }
      i = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") && n != null ? new fEe(u.shape, n) : new $Te(u.shape, t);
      return c.runWebGLProgram(i, [u], l);
    };
  }
  function LEe(e) {
    var t = e.opSnippet;
    var n = e.packedOpSnippet;
    var r = e.checkOutOfBounds;
    var a = r !== undefined && r;
    var i = e.supportsComplex;
    var o = i !== undefined && i;
    var s = e.cpuKernelImpl;
    var u = e.dtype;
    return function (e) {
      var r = e.inputs;
      var i = e.backend;
      var c = r.a;
      var l = r.b;
      var h = i;
      if (o && c.dtype === "complex64") {
        var p = h.texData.get(c.dataId);
        var f = h.texData.get(l.dataId);
        var d = [[p.complexTensorInfos.real, f.complexTensorInfos.real], [p.complexTensorInfos.imag, f.complexTensorInfos.imag]].map(function (e) {
          var n = S(e, 2);
          var r = n[0];
          var a = n[1];
          var i = {
            dataId: r.dataId,
            dtype: r.dtype,
            shape: c.shape
          };
          var o = {
            dataId: a.dataId,
            dtype: a.dtype,
            shape: l.shape
          };
          var s = new wEe(t, c.shape, l.shape);
          return h.runWebGLProgram(s, [i, o], h5(r.dtype, a.dtype));
        });
        var v = S(d, 2);
        var m = v[0];
        var g = v[1];
        var y = EEe({
          inputs: {
            real: m,
            imag: g
          },
          backend: h
        });
        h.disposeIntermediateTensorInfo(m);
        h.disposeIntermediateTensorInfo(g);
        return y;
      }
      var b;
      var x = u || h5(c.dtype, l.dtype);
      if ((c.dtype === "string" || l.dtype === "string" || h.shouldExecuteOnCPU([c, l])) && s != null) {
        var k = h.texData.get(c.dataId).values;
        var w = h.texData.get(l.dataId).values;
        var I = c.dtype === "string" ? aoe(k) : k;
        var N = c.dtype === "string" ? aoe(w) : w;
        var T = S(s(c.shape, l.shape, I, N, x), 2);
        var E = T[0];
        var C = T[1];
        var A = h.makeTensorInfo(C, x);
        h.texData.get(A.dataId).values = E;
        return A;
      }
      b = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") && n != null ? new NEe(n, c.shape, l.shape, a) : new wEe(t, c.shape, l.shape);
      return h.runWebGLProgram(b, [c, l], x);
    };
  }
  function zEe(e, t = false) {
    if (e === "linear") {
      if (t) {
        return uEe;
      } else {
        return tEe;
      }
    }
    if (e === "relu") {
      if (t) {
        return lEe;
      } else {
        return aEe;
      }
    }
    if (e === "elu") {
      if (t) {
        return cEe;
      } else {
        return rEe;
      }
    }
    if (e === "relu6") {
      if (t) {
        return hEe;
      } else {
        return iEe;
      }
    }
    if (e === "prelu") {
      if (t) {
        return FEe;
      } else {
        return OEe;
      }
    }
    if (e === "leakyrelu") {
      if (t) {
        return REe;
      } else {
        return AEe;
      }
    }
    if (e === "sigmoid") {
      if (t) {
        return pEe;
      } else {
        return sEe;
      }
    }
    throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`);
  }
  var PEe = p(function e(t, n, r, a = false, i = false, o = false, s = null, u = false, c = false) {
    l(this, e);
    this.variableNames = ["matrixA", "matrixB"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = r;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var h = a ? t[1] : t[2];
    var p = Math.ceil(h / 2);
    var f = a ? "i * 2, rc.y" : "rc.y, i * 2";
    var d = i ? "rc.z, i * 2" : "i * 2, rc.z";
    var v = a ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
    var m = i ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    var g = "";
    var y = "";
    if (s) {
      g = u ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }` : c ? `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }` : `vec4 activation(vec4 x) {
          ${s}
        }`;
      y = "result = activation(result);";
    }
    var b = o ? "result += getBiasAtOutCoords();" : "";
    if (o) {
      this.variableNames.push("bias");
    }
    if (u) {
      this.variableNames.push("preluActivationWeights");
    }
    if (c) {
      this.variableNames.push("leakyreluAlpha");
    }
    var x = "rc.x";
    var k = "rc.x";
    if (t[0] < n[0]) {
      x = `imod(rc.x, ${t[0]})`;
    } else if (n[0] < t[0]) {
      k = `imod(rc.x, ${n[0]})`;
    }
    this.userCode = `
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${k};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${v[0]} * ${m[0]});
          result += (${v[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `;
  });
  var BEe = "return areal * breal - aimag * bimag;";
  var WEe = "return areal * bimag + aimag * breal;";
  var UEe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
    this.outputShape = z7(n, r);
    this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
  });
  var VEe = "return a * b;";
  function GEe(e) {
    var t;
    var n = e.inputs;
    var r = e.backend;
    var a = n.a;
    var i = n.b;
    var o = h5(a.dtype, i.dtype);
    if (a.dtype === "complex64") {
      var s = r.texData.get(a.dataId);
      var u = r.texData.get(i.dataId);
      var c = new UEe(BEe, a.shape, i.shape);
      var l = new UEe(WEe, a.shape, i.shape);
      var h = [{
        dataId: s.complexTensorInfos.real.dataId,
        dtype: s.complexTensorInfos.real.dtype,
        shape: a.shape
      }, {
        dataId: s.complexTensorInfos.imag.dataId,
        dtype: s.complexTensorInfos.imag.dtype,
        shape: a.shape
      }, {
        dataId: u.complexTensorInfos.real.dataId,
        dtype: u.complexTensorInfos.real.dtype,
        shape: i.shape
      }, {
        dataId: u.complexTensorInfos.imag.dataId,
        dtype: u.complexTensorInfos.imag.dtype,
        shape: i.shape
      }];
      var p = r.runWebGLProgram(c, h, "float32");
      var f = r.runWebGLProgram(l, h, "float32");
      var d = EEe({
        inputs: {
          real: p,
          imag: f
        },
        backend: r
      });
      r.disposeIntermediateTensorInfo(p);
      r.disposeIntermediateTensorInfo(f);
      return d;
    }
    if (r.shouldExecuteOnCPU([a, i])) {
      var v = r.texData.get(a.dataId);
      var m = r.texData.get(i.dataId);
      var g = S(yTe(a.shape, i.shape, v.values, m.values, o), 2);
      var y = g[0];
      var b = g[1];
      var x = r.makeTensorInfo(b, o);
      r.texData.get(x.dataId).values = y;
      return x;
    }
    t = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe(VEe, a.shape, i.shape) : new wEe(VEe, a.shape, i.shape);
    return r.runWebGLProgram(t, [a, i], o);
  }
  var jEe = {
    kernelName: g2,
    backendName: "webgl",
    kernelFunc: GEe
  };
  function HEe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.shape;
    var o = n;
    var s = L$(a.shape);
    var u = G$(i, s);
    var c = L$(u);
    F$(s === c, function () {
      return `The new shape (${u}) has ${c} elements and the old shape (${a.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`;
    });
    var l = o.texData.get(a.dataId);
    if (!l.isPacked || SNe(a.shape, u) || l.texture !== null && SNe(l.shape, u)) {
      o.incRef(a.dataId);
      return {
        dataId: a.dataId,
        shape: u,
        dtype: a.dtype
      };
    } else {
      return function (e, t, n) {
        var r = [xNe(e.shape)].concat(T(kNe(e.shape)));
        var a = {
          dtype: e.dtype,
          shape: r,
          dataId: e.dataId
        };
        var i = [xNe(t)].concat(T(kNe(t)));
        var o = new XTe(i, r);
        var s = [r];
        var u = n.runWebGLProgram(o, [a], e.dtype, s, true);
        return {
          dataId: u.dataId,
          shape: t,
          dtype: u.dtype
        };
      }(a, u, o);
    }
  }
  var qEe = {
    kernelName: z2,
    backendName: "webgl",
    kernelFunc: HEe
  };
  var KEe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["x"];
    var r = t.windowSize;
    var a = t.batchSize;
    var i = t.inSize;
    var o = t.outSize;
    this.outputShape = [a, o];
    var s = Math.floor(r / 4) * 4;
    var u = r % 4;
    var c = "sumValue += dot(values, ones);";
    if (n != null) {
      var h = 1 / n;
      c = `sumValue += dot(values * ${B$(h) ? h.toPrecision(2) : h}, ones);`;
    }
    var p = "";
    if (i % r > 0) {
      p = `
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `;
    }
    this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${s}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${s};
        if (${u === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${u === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${u === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `;
  });
  var XEe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["x"];
    var r = t.windowSize;
    var a = t.batchSize;
    var i = t.inSize;
    var o = t.outSize;
    this.outputShape = [a, o];
    var s = "0.0";
    var u = "";
    if (n === "prod") {
      s = "1.0";
    } else if (n === "min") {
      s = "1.0 / 1e-20";
      u = "min";
    } else if (n === "max") {
      s = "-1.0 / 1e-20";
      u = "max";
    }
    var c = `${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    if (n === "sum") {
      c = "sumValue";
    } else if (n === "prod") {
      c = "prodValue";
    } else if (n === "all") {
      c = "allValue";
    } else if (n === "any") {
      c = "anyValue";
    }
    var h = Math.floor(r / 4) * 4;
    var p = r % 4;
    var f = `
      if (${n === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${n === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${n === "min"} || ${n === "max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `;
    var d = "vec4";
    if (n === "all") {
      s = "1.0";
      f = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ";
      d = "bvec4";
    } else if (n === "any") {
      s = "0.0";
      f = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ";
      d = "bvec4";
    }
    var v = "";
    if (i % r > 0) {
      v = `
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `;
    }
    this.userCode = `
      const float initializationValue = ${s};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${v}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${s});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${h};
        if (${p === 1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p === 2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p === 3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `;
  });
  function YEe(e, t, n, r) {
    for (var a = function (e) {
        for (var t = []; t.length === 0 || t[t.length - 1].outSize !== 1;) {
          var n = t.length ? t[t.length - 1].outSize : e[1];
          var r = hie(n);
          t.push({
            inSize: n,
            windowSize: r,
            outSize: Math.ceil(n / r)
          });
        }
        return t;
      }(e.shape), i = e, o = 0; o < a.length; o++) {
      var s;
      var u = a[o];
      var c = u.inSize;
      var l = u.windowSize;
      var h = u.outSize;
      var p = undefined;
      p = n === "mean" ? o === 0 ? new KEe({
        windowSize: l,
        inSize: c,
        batchSize: e.shape[0],
        outSize: h
      }, c) : new KEe({
        windowSize: l,
        inSize: c,
        batchSize: e.shape[0],
        outSize: h
      }) : new XEe({
        windowSize: l,
        inSize: c,
        batchSize: e.shape[0],
        outSize: h
      }, n);
      s = i;
      i = r.runWebGLProgram(p, [i], t);
      if (s.dataId !== e.dataId) {
        r.disposeIntermediateTensorInfo(s);
      }
    }
    return i;
  }
  var JEe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A"];
    for (var r = new Array(t.length), a = 0; a < r.length; a++) {
      r[a] = t[n[a]];
    }
    this.outputShape = r;
    this.rank = r.length;
    var i = cSe(this.rank);
    var o = function (e) {
      var t = e.length;
      if (t > 6) {
        throw Error(`Transpose for rank ${t} is not yet supported`);
      }
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
      var r = new Array(t);
      for (var a = 0; a < e.length; a++) {
        r[e[a]] = n[a];
      }
      return r.join();
    }(n);
    this.userCode = `
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `;
  });
  var ZEe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    for (var r = new Array(t.length), a = 0; a < r.length; a++) {
      r[a] = t[n[a]];
    }
    this.outputShape = r;
    this.rank = r.length;
    if (this.rank > 6) {
      throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
    }
    var i = cSe(this.rank);
    var o = HTe("rc", this.rank);
    var s = new Array(this.rank);
    for (var u = 0; u < n.length; u++) {
      s[n[u]] = o[u];
    }
    var c = `vec2(${s.slice(-2).join()})`;
    var h = `++${o[this.rank - 1]} < ${r[this.rank - 1]}`;
    var p = `getChannel(getA(${s.join()}), ${c})`;
    this.userCode = `
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${p};
      if(${h}) {
        result[1] = ${p};
      }
      --${o[this.rank - 1]};
      if(++${o[this.rank - 2]} < ${r[this.rank - 2]}) {
        result[2] = ${p};
        if(${h}) {
          result[3] = ${p};
        }
      }
      setOutput(result);
    }
    `;
  });
  function QEe(e, t, n) {
    var r = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ZEe(e.shape, t) : new JEe(e.shape, t);
    return n.runWebGLProgram(r, [e], e.dtype);
  }
  function $Ee(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    return function (e, t, n, r) {
      var a = t;
      var i = e.shape.length;
      var o = j$(a, e.shape);
      var s = o;
      var u = $7(s, i);
      var c = u != null;
      var l = e;
      if (c) {
        l = QEe(e, u, r);
        s = t9(s.length, i);
      }
      Q7("sum", s, i);
      var h = S(J7(l.shape, s), 2);
      var p = h[0];
      var f = h[1];
      var d = p;
      if (n) {
        d = Z7(p, o);
      }
      var v = L$(f);
      var m = HEe({
        inputs: {
          x: l
        },
        attrs: {
          shape: [L$(e.shape) / v, v]
        },
        backend: r
      });
      var g = YEe(m, p5(e.dtype), "sum", r);
      var y = HEe({
        inputs: {
          x: g
        },
        attrs: {
          shape: d
        },
        backend: r
      });
      r.disposeIntermediateTensorInfo(m);
      r.disposeIntermediateTensorInfo(g);
      if (c) {
        r.disposeIntermediateTensorInfo(l);
      }
      return y;
    }(t.x, r.axis, r.keepDims, n);
  }
  var eCe = {
    kernelName: a3,
    backendName: "webgl",
    kernelFunc: $Ee
  };
  function tCe(e) {
    var t;
    var n = e.inputs;
    var r = e.backend;
    var a = e.attrs;
    var i = n.x;
    var o = a.perm;
    var s = r;
    var u = i.shape.length;
    for (var c = new Array(u), l = 0; l < c.length; l++) {
      c[l] = i.shape[o[l]];
    }
    if (s.shouldExecuteOnCPU([i])) {
      var h = s.texData.get(i.dataId).values;
      var p = GTe(h, i.shape, i.dtype, o, c);
      t = s.makeTensorInfo(c, i.dtype);
      s.texData.get(t.dataId).values = p;
    } else {
      t = QEe(i, o, s);
    }
    return t;
  }
  var nCe = {
    kernelName: T3,
    backendName: "webgl",
    kernelFunc: tCe
  };
  function rCe(e) {
    var t = e.a;
    var n = e.b;
    var r = e.transposeA;
    var a = e.transposeB;
    var i = e.backend;
    var o = e.bias;
    var s = o === undefined ? null : o;
    var u = e.preluActivationWeights;
    var c = u === undefined ? null : u;
    var l = e.leakyreluAlpha;
    var h = l === undefined ? 0 : l;
    var p = e.activation;
    var f = p === undefined ? null : p;
    var d = t.shape.length;
    var v = n.shape.length;
    var m = r ? t.shape[d - 2] : t.shape[d - 1];
    var g = a ? n.shape[v - 1] : n.shape[v - 2];
    var y = r ? t.shape[d - 1] : t.shape[d - 2];
    var b = a ? n.shape[v - 2] : n.shape[v - 1];
    var x = t.shape.slice(0, -2);
    var k = n.shape.slice(0, -2);
    var w = L$(x);
    var I = L$(k);
    var N = z7(t.shape.slice(0, -2), n.shape.slice(0, -2)).concat([y, b]);
    F$(m === g, function () {
      return `Error in matMul: inner shapes (${m}) and (${g}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`;
    });
    var S;
    var T = r ? [w, m, y] : [w, y, m];
    var E = a ? [I, b, g] : [I, g, b];
    var C = HEe({
      inputs: {
        x: t
      },
      backend: i,
      attrs: {
        shape: T
      }
    });
    var A = HEe({
      inputs: {
        x: n
      },
      backend: i,
      attrs: {
        shape: E
      }
    });
    var R = [C, A];
    var _ = Math.max(w, I);
    var O = r ? C.shape[1] : C.shape[2];
    var F = s != null;
    var D = c != null;
    var M = f === "leakyrelu";
    var L = f != null ? zEe(f, true) : null;
    if ((y === 1 || b === 1) && O > 1000 && (F || D || M || L != null) === false) {
      var z = C;
      var P = A;
      if (r) {
        z = tCe({
          inputs: {
            x: C
          },
          backend: i,
          attrs: {
            perm: [0, 2, 1]
          }
        });
        R.push(z);
      }
      if (a) {
        P = tCe({
          inputs: {
            x: A
          },
          backend: i,
          attrs: {
            perm: [0, 2, 1]
          }
        });
        R.push(P);
      }
      var B = b === 1;
      var W = z;
      if (b !== 1) {
        W = HEe({
          inputs: {
            x: z
          },
          backend: i,
          attrs: {
            shape: [_, O, 1]
          }
        });
        R.push(W);
      }
      var U = b === 1 ? 2 : 1;
      var V = P;
      if (B) {
        V = HEe({
          inputs: {
            x: P
          },
          backend: i,
          attrs: {
            shape: [_, 1, O]
          }
        });
        R.push(V);
      }
      var G = GEe({
        inputs: {
          a: W,
          b: V
        },
        backend: i
      });
      S = $Ee({
        inputs: {
          x: G
        },
        backend: i,
        attrs: {
          axis: U,
          keepDims: true
        }
      });
      R.push(G);
    } else {
      var j = h5(t.dtype, n.dtype);
      var H = new PEe(T, E, [_, y, b], r, a, F, L, D, M);
      var q = [C, A];
      if (s != null) {
        q.push(s);
      }
      if (D) {
        q.push(c);
      }
      if (M) {
        var K = i.makeTensorInfo([], "float32", M4(h, "float32"));
        q.push(K);
        R.push(K);
      }
      S = i.runWebGLProgram(H, q, j);
    }
    var X = HEe({
      inputs: {
        x: S
      },
      backend: i,
      attrs: {
        shape: N
      }
    });
    R.push(S);
    for (var Y = 0, J = R; Y < J.length; Y++) {
      var Z = J[Y];
      i.disposeIntermediateTensorInfo(Z);
    }
    return X;
  }
  var aCe = {
    kernelName: D3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.a;
      var i = t.b;
      var o = t.bias;
      var s = t.preluActivationWeights;
      var u = r.transposeA;
      var c = r.transposeB;
      var l = r.activation;
      return rCe({
        a: a,
        b: i,
        transposeA: u,
        transposeB: c,
        backend: n,
        bias: o,
        preluActivationWeights: s,
        leakyreluAlpha: r.leakyreluAlpha,
        activation: l
      });
    }
  };
  var iCe = "return abs(x);";
  var oCe = {
    kernelName: N0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = n.x;
      if (r.shouldExecuteOnCPU([a]) && a.dtype !== "complex64") {
        var i = r.texData.get(a.dataId);
        var o = ATe(i.values);
        return r.makeTensorInfo(a.shape, a.dtype, o);
      }
      t = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new fEe(a.shape, iCe) : new $Te(a.shape, iCe);
      return r.runWebGLProgram(t, [a], a.dtype);
    }
  };
  var sCe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
  });
  var uCe = {
    kernelName: S0,
    backendName: "webgl",
    kernelFunc: sCe
  };
  var cCe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
  });
  var lCe = {
    kernelName: T0,
    backendName: "webgl",
    kernelFunc: cCe
  };
  var hCe = "return a + b;";
  var pCe = LEe({
    opSnippet: hCe,
    packedOpSnippet: hCe,
    supportsComplex: true,
    cpuKernelImpl: JSe
  });
  var fCe = {
    kernelName: E0,
    backendName: "webgl",
    kernelFunc: pCe
  };
  var dCe = p(function e(t, n) {
    l(this, e);
    this.outputShape = [];
    this.outputShape = t;
    this.variableNames = n.map(function (e, t) {
      return `T${t}`;
    });
    var r = [];
    this.variableNames.forEach(function (e) {
      r.push(`float v${e} = get${e}AtOutCoords();`);
    });
    var a = this.variableNames.map(function (e) {
      return `v${e}`;
    }).join(" + ");
    this.userCode = `
      void main() {
        ${r.join("\n        ")}

        float result = ${a};
        setOutput(result);
      }
    `;
  });
  var vCe = p(function e(t, n) {
    l(this, e);
    this.outputShape = [];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = t;
    this.variableNames = n.map(function (e, t) {
      return `T${t}`;
    });
    var r = [];
    this.variableNames.forEach(function (e) {
      r.push(`vec4 v${e} = get${e}AtOutCoords();`);
    });
    var a = this.variableNames.map(function (e) {
      return `v${e}`;
    }).join(" + ");
    this.userCode = `
      void main() {
        ${r.join("\n        ")}

        vec4 result = ${a};
        setOutput(result);
      }
    `;
  });
  var mCe = {
    kernelName: C0,
    backendName: "webgl",
    kernelFunc: function e(t) {
      var n = t.inputs;
      var r = t.backend;
      var a = n;
      if (a.length === 1) {
        return SEe({
          inputs: {
            x: a[0]
          },
          backend: r
        });
      }
      if (a.length > k0().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
        var i = Math.floor(a.length / 2);
        var o = e({
          inputs: a.slice(0, i),
          backend: r
        });
        var s = e({
          inputs: a.slice(i),
          backend: r
        });
        return e({
          inputs: [o, s],
          backend: r
        });
      }
      var u = a.map(function (e) {
        return e.dtype;
      }).reduce(function (e, t) {
        return h5(e, t);
      });
      var c = a.map(function (e) {
        return e.shape;
      });
      var l = k0().getBool("WEBGL_PACK") ? new vCe(a[0].shape, c) : new dCe(a[0].shape, c);
      return r.runWebGLProgram(l, a, u);
    }
  };
  var gCe = {
    kernelName: A0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      var s = a.shape.length;
      var u = j$(i, a.shape);
      var c = u;
      var l = $7(c, s);
      var h = a;
      if (l != null) {
        h = tCe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: l
          }
        });
        c = t9(c.length, s);
      }
      Q7("all", c, s);
      var p;
      var f = S(J7(h.shape, c), 2);
      var d = f[0];
      var v = HEe({
        inputs: {
          x: h
        },
        backend: n,
        attrs: {
          shape: [-1, L$(f[1])]
        }
      });
      var m = YEe(v, v.dtype, "all", n);
      p = HEe(o ? {
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          shape: Z7(d, u)
        }
      } : {
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          shape: d
        }
      });
      n.disposeIntermediateTensorInfo(v);
      n.disposeIntermediateTensorInfo(m);
      if (l != null) {
        n.disposeIntermediateTensorInfo(h);
      }
      return p;
    }
  };
  var yCe = {
    kernelName: R0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      var s = a.shape.length;
      var u = j$(i, a.shape);
      var c = u;
      var l = $7(c, s);
      var h = a;
      if (l != null) {
        h = tCe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: l
          }
        });
        c = t9(c.length, s);
      }
      Q7("any", c, s);
      var p;
      var f = S(J7(h.shape, c), 2);
      var d = f[0];
      var v = HEe({
        inputs: {
          x: h
        },
        backend: n,
        attrs: {
          shape: [-1, L$(f[1])]
        }
      });
      var m = YEe(v, v.dtype, "any", n);
      p = HEe(o ? {
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          shape: Z7(d, u)
        }
      } : {
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          shape: d
        }
      });
      n.disposeIntermediateTensorInfo(v);
      n.disposeIntermediateTensorInfo(m);
      if (l != null) {
        n.disposeIntermediateTensorInfo(h);
      }
      return p;
    }
  };
  var bCe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["A"];
    var a = t.windowSize;
    var i = t.batchSize;
    var o = t.outSize;
    if (!r) {
      this.variableNames.push("bestIndicesA");
    }
    this.outputShape = [i, o];
    var s = n === "max" ? ">" : "<";
    var u = r ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${a}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${s} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
  });
  var xCe = p(function e(t, n, r, a) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    F$(t.length > 2, function () {
      return `Packed arg${r.charAt(0).toUpperCase() + r.slice(1)} supports only inputs with rank above 2.`;
    });
    var i = t[t.length - 1];
    var o = Math.ceil(i / n);
    this.outputShape = t.slice(0, -1);
    if (o > 1) {
      this.outputShape.push(o);
    }
    if (!a) {
      this.variableNames.push("bestIndicesA");
    }
    var s;
    var u;
    var c = this.outputShape;
    var h = c.length;
    var p = cSe(h);
    var f = qTe("coords", h);
    if (o === 1) {
      var d = cSe(u = h + 1);
      s = `
        ${d} sourceLocR = ${d}(${f.join()}, 0);
        ++${f[h - 1]};
        ${d} sourceLocG = ${d}(${f.join()}, 0);
        ++${f[h - 2]};
        ${d} sourceLocA = ${d}(${f.join()}, 0);
        --${f[h - 1]};
        ${d} sourceLocB = ${d}(${f.join()}, 0);
        --${f[h - 2]};`;
    } else {
      u = h;
      s = `
        ${p} sourceLocR = coords;
        ++${f[h - 1]};
        ${p} sourceLocG = coords;
        ++${f[h - 2]};
        ${p} sourceLocA = coords;
        --${f[h - 1]};
        ${p} sourceLocB = coords;
        --${f[h - 2]};`;
    }
    var v = ["x", "y", "z", "w", "u", "v"].slice(0, u);
    var m = "." + v[u - 1];
    var g = v.map(function (e) {
      return "int " + e;
    });
    var y = qTe("sourceLocR", u - 1).concat("inIdx.r");
    var b = qTe("sourceLocG", u - 1).concat("inIdx.g");
    var x = qTe("sourceLocB", u - 1).concat("inIdx.b");
    var k = qTe("sourceLocA", u - 1).concat("inIdx.a");
    var w = r === "max" ? "greaterThan" : "lessThan";
    var I = a ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${k.join()})));`;
    var N = `vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`;
    var S = a ? "" : `
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${v.join()}),
                                          vec2(${v.slice(-2).join()}));
      }`;
    this.userCode = `
      float getAChannel(${g.join()}) {
        return getChannel(getA(${v.join()}),
                               vec2(${v.slice(-2).join()}));
      }
      ${S}
      void main() {
        ${p} coords = getOutputCoords();
        bool hasNextCol = ${f[h - 1]} < ${c[h - 1] - 1};
        bool hasNextRow = ${f[h - 2]} < ${c[h - 2] - 1};
        ${s}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
  });
  function kCe(e, t, n, r = null) {
    var a = t.shape[0];
    var i = t.shape[1];
    if (r != null) {
      a = r.shape[0];
      i = r.shape[1];
    }
    var o = hie(i);
    var s = {
      windowSize: o,
      inSize: i,
      batchSize: a,
      outSize: Math.ceil(i / o)
    };
    var u = new bCe(s, n, r == null);
    var c = [t];
    if (r != null) {
      c.push(r);
    }
    var l = e.runWebGLProgram(u, c, "int32");
    if (l.shape[1] === 1) {
      return l;
    }
    var h = kCe(e, t, n, l);
    e.disposeIntermediateTensorInfo(l);
    return h;
  }
  function wCe(e, t, n, r = null) {
    var a = r != null ? r.shape : t.shape;
    var i = a[a.length - 1];
    var o = hie(i);
    var s = new xCe(a, o, n, r == null);
    var u = r == null ? [t] : [t, r];
    var c = e.runWebGLProgram(s, u, "int32");
    if (c.shape.length === t.shape.length) {
      var l = wCe(e, t, n, c);
      e.disposeIntermediateTensorInfo(c);
      return l;
    }
    return c;
  }
  function ICe(e, t, n, r) {
    var a = [n];
    Q7("arg" + r.charAt(0).toUpperCase() + r.slice(1), a, t.shape.length);
    if (!k0().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
      var i = [];
      var o = e.texData.get(t.dataId);
      var s = t;
      if (o !== null && o.isPacked) {
        s = e.unpackTensor(t);
        i.push(s);
      }
      var u = S(J7(s.shape, a), 2);
      var c = u[0];
      var l = L$(u[1]);
      var h = HEe({
        inputs: {
          x: s
        },
        backend: e,
        attrs: {
          shape: [-1, l]
        }
      });
      i.push(h);
      var p = kCe(e, h, r);
      i.push(p);
      var f = HEe({
        inputs: {
          x: p
        },
        backend: e,
        attrs: {
          shape: c
        }
      });
      i.forEach(function (t) {
        return e.disposeIntermediateTensorInfo(t);
      });
      return f;
    }
    return wCe(e, t, r);
  }
  var NCe = {
    kernelName: _0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = j$(r.axis, a.shape);
      var o = $7(i, a.shape.length);
      var s = a;
      var u = [];
      if (o != null) {
        s = tCe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: o
          }
        });
        u.push(s);
        i = t9(i.length, s.shape.length);
      }
      Q7("argMax", [i[0]], s.shape.length);
      var c = ICe(n, s, i[0], "max");
      u.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return c;
    }
  };
  var SCe = {
    kernelName: O0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = j$(r.axis, a.shape);
      var o = $7(i, a.shape.length);
      var s = a;
      var u = [];
      if (o != null) {
        s = tCe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: o
          }
        });
        u.push(s);
        i = t9(i.length, s.shape.length);
      }
      Q7("argMin", [i[0]], s.shape.length);
      var c = ICe(n, s, i[0], "min");
      u.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return c;
    }
  };
  var TCe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
  });
  var ECe = {
    kernelName: F0,
    backendName: "webgl",
    kernelFunc: TCe
  };
  var CCe = MEe({
    opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"
  });
  var ACe = {
    kernelName: D0,
    backendName: "webgl",
    kernelFunc: CCe
  };
  var RCe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n"
  });
  var _Ce = {
    kernelName: M0,
    backendName: "webgl",
    kernelFunc: RCe
  };
  var OCe = LEe({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
    packedOpSnippet: "\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"
  });
  var FCe = {
    kernelName: z0,
    backendName: "webgl",
    kernelFunc: OCe
  };
  var DCe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
  });
  var MCe = {
    kernelName: L0,
    backendName: "webgl",
    kernelFunc: DCe
  };
  var LCe = p(function e(t, n, r, a = false, i = false) {
    l(this, e);
    this.variableNames = ["x"];
    if (n === "avg" && r) {
      throw new Error("Cannot compute positions for average pool.");
    }
    var o = t.filterWidth;
    var s = t.strideHeight;
    var u = t.strideWidth;
    var c = t.dilationHeight;
    var h = t.dilationWidth;
    var p = t.effectiveFilterHeight;
    var f = t.effectiveFilterWidth;
    var d = t.padInfo.top;
    var v = t.padInfo.left;
    this.outputShape = t.outShape;
    var m = n === "avg";
    var g = `((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`;
    var y = `(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;
    var b = "0.0";
    if (!m) {
      b = "-1.0 / 1e-20";
    }
    if (r) {
      var x = ">=";
      this.userCode = `
        const ivec2 strides = ivec2(${s}, ${u});
        const ivec2 pads = ivec2(${d}, ${v});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${x} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${a ? i ? g : y : `wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
    } else {
      var k = "max";
      var w = `${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (n === "avg") {
        w = "avgValue / max(count, 1.0)";
      }
      var I = Math.floor(o / 4) * 4;
      var N = o % 4;
      var S = `
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${s}, ${u});
      const ivec2 pads = ivec2(${d}, ${v});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${S}
          }

          int xC = xCCorner + ${I};
          if (${N === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${N === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${N === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${S}
          }
        }
        setOutput(${w});
      }
    `;
    }
  });
  var zCe = p(function e(t, n, r, a = false, i = false) {
    l(this, e);
    this.variableNames = ["x"];
    if (n === "avg" && r) {
      throw new Error("Cannot compute positions for average pool.");
    }
    var o = t.filterWidth;
    var s = t.strideDepth;
    var u = t.strideHeight;
    var c = t.strideWidth;
    var h = t.dilationDepth;
    var p = t.dilationHeight;
    var f = t.dilationWidth;
    var d = t.effectiveFilterDepth;
    var v = t.effectiveFilterHeight;
    var m = t.effectiveFilterWidth;
    var g = t.padInfo.front;
    var y = t.padInfo.top;
    var b = t.padInfo.left;
    this.outputShape = t.outShape;
    var x = n === "avg";
    var k = "0.0";
    if (!x) {
      k = "-1.0 / 1e-20";
    }
    if (r) {
      var w = ">=";
      this.userCode = `
        const ivec3 strides =
            ivec3(${s}, ${u}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${v};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${w} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${a ? i ? `(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch` : `wD * ${v} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
    } else {
      var I = "max";
      var N = `${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (n === "avg") {
        N = "avgValue / max(count, 1.0)";
      }
      var S = Math.floor(o / 4) * 4;
      var T = o % 4;
      var E = `
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${s}, ${u}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${v};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${S}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${S};
            if (${T === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${T === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${N});
      }
    `;
    }
  });
  var PCe = {
    kernelName: P0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      MNe(a, "avgPool");
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dimRoundingMode;
      F$(j8(o, 1), function () {
        return `Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${1}'`;
      });
      var c = O8(a.shape, i, o, 1, s, u);
      if (c.filterWidth === 1 && c.filterHeight === 1 && P$(c.inShape, c.outShape)) {
        return SEe({
          inputs: {
            x: a
          },
          backend: n
        });
      }
      var l = new LCe(c, "avg", false);
      return n.runWebGLProgram(l, [a], "float32");
    }
  };
  var BCe = {
    kernelName: W0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dimRoundingMode;
      var c = r.dataFormat;
      var l = F8(a.shape, i, o, [1, 1, 1], s, u, c);
      var h = new zCe(l, "avg", false);
      return n.runWebGLProgram(h, [a], "float32");
    }
  };
  var WCe = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy"];
    this.outputShape = t.inShape;
    var n = t.filterHeight;
    var r = t.filterWidth;
    var a = t.strideHeight;
    var i = t.strideWidth;
    var o = t.dilationHeight;
    var s = t.dilationWidth;
    var u = t.effectiveFilterHeight;
    var c = t.effectiveFilterWidth;
    var h = u - 1 - t.padInfo.top;
    var p = c - 1 - t.padInfo.left;
    var f = 1 / (n * r);
    this.userCode = `
      const ivec2 pads = ivec2(${h}, ${p});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${s}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var UCe = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy"];
    this.outputShape = t.inShape;
    var n = t.filterDepth;
    var r = t.filterHeight;
    var a = t.filterWidth;
    var i = t.strideDepth;
    var o = t.strideHeight;
    var s = t.strideWidth;
    var u = t.dilationDepth;
    var c = t.dilationHeight;
    var h = t.dilationWidth;
    var p = t.effectiveFilterDepth;
    var f = t.effectiveFilterHeight;
    var d = t.effectiveFilterWidth;
    var v = p - 1 - t.padInfo.front;
    var m = f - 1 - t.padInfo.top;
    var g = d - 1 - t.padInfo.left;
    var y = 1 / (n * r * a);
    this.userCode = `
      const ivec3 pads = ivec3(${v}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var VCe = {
    kernelName: U0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = r.filterSize;
      var s = r.strides;
      var u = r.pad;
      var c = r.dimRoundingMode;
      var l = F8(i.shape, o, s, [1, 1, 1], u, c);
      var h = new UCe(l);
      return n.runWebGLProgram(h, [a], i.dtype);
    }
  };
  var GCe = {
    kernelName: B0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = i;
      MNe([a, i], "avgPoolGrad");
      var s = r.filterSize;
      var u = r.strides;
      var c = r.pad;
      var l = O8(o.shape, s, u, 1, c);
      var h = new WCe(l);
      return n.runWebGLProgram(h, [a], o.dtype);
    }
  };
  var jCe = {
    kernelName: V0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      return rCe({
        a: t.a,
        b: t.b,
        transposeA: r.transposeA,
        transposeB: r.transposeB,
        backend: n
      });
    }
  };
  var HCe = p(function e(t, n, r, a, i, o) {
    l(this, e);
    this.outputShape = [];
    this.variableNames = ["x", "mean", "variance"];
    z7(t, n);
    z7(t, r);
    var s = "0.0";
    if (a != null) {
      z7(t, a);
      this.variableNames.push("offset");
      s = "getOffsetAtOutCoords()";
    }
    var u = "1.0";
    if (i != null) {
      z7(t, i);
      this.variableNames.push("scale");
      u = "getScaleAtOutCoords()";
    }
    this.outputShape = t;
    this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${s};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
  });
  var qCe = p(function e(t, n, r, a, i, o) {
    l(this, e);
    this.packedInputs = true;
    this.packedOutput = true;
    this.variableNames = ["x", "mean", "variance"];
    z7(t, n);
    z7(t, r);
    var s = "vec4(0.0)";
    if (a != null) {
      z7(t, a);
      this.variableNames.push("offset");
      s = "getOffsetAtOutCoords()";
    }
    var u = "vec4(1.0)";
    if (i != null) {
      z7(t, i);
      this.variableNames.push("scale");
      u = "getScaleAtOutCoords()";
    }
    this.outputShape = t;
    this.userCode = `
      void main() {
        vec4 offset = ${s};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `;
  });
  var KCe = {
    kernelName: M1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.mean;
      var o = t.variance;
      var s = t.offset;
      var u = t.scale;
      F$(i.shape.length === o.shape.length, function () {
        return "Batch normalization gradient requires mean and variance to have equal ranks.";
      });
      F$(s == null || i.shape.length === s.shape.length, function () {
        return "Batch normalization gradient requires mean and offset to have equal ranks.";
      });
      F$(u == null || i.shape.length === u.shape.length, function () {
        return "Batch normalization gradient requires mean and scale to have equal ranks.";
      });
      var c = r.varianceEpsilon;
      if (c == null) {
        c = 0.001;
      }
      var l = [a, i, o];
      var h = null;
      if (s != null) {
        h = s.shape;
        l.push(s);
      }
      var p = null;
      if (u != null) {
        p = u.shape;
        l.push(u);
      }
      var f = k0().getBool("WEBGL_PACK_NORMALIZATION") ? new qCe(a.shape, i.shape, o.shape, h, p, c) : new HCe(a.shape, i.shape, o.shape, h, p, c);
      return n.runWebGLProgram(f, l, l[0].dtype);
    }
  };
  var XCe = p(function e(t) {
    l(this, e);
    this.variableNames = ["source"];
    this.outputShape = t;
    this.rank = t.length;
    var n = cSe(this.rank);
    this.customUniforms = [{
      name: "start",
      arrayIndex: this.rank,
      type: "int"
    }];
    var r;
    var a = function (e) {
      if (e === 1) {
        return "sourceLoc";
      }
      if (e <= 6) {
        return YCe.slice(0, e).map(function (e) {
          return "sourceLoc." + e;
        }).join(",");
      }
      throw Error(`Slicing for rank ${e} is not yet supported`);
    }(this.rank);
    var i = t.map(function (e, t) {
      return `sourceLoc.${YCe[t]} = start[${t}] + coords.${YCe[t]};`;
    });
    r = `
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${i.join("\n")}
      `;
    this.userCode = `
      void main() {
        ${r}
        setOutput(getSource(${a}));
      }
    `;
  });
  var YCe = ["x", "y", "z", "w", "u", "v"];
  var JCe = p(function e(t) {
    l(this, e);
    this.variableNames = ["source"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = t;
    this.rank = t.length;
    this.customUniforms = [{
      name: "start",
      arrayIndex: this.rank,
      type: "int"
    }];
    var n = cSe(this.rank);
    var r = qTe("coords", this.rank);
    var a = qTe("sourceLoc", this.rank);
    var i = this.rank === 1 ? "sourceLoc" : `vec2(${a.slice(-2).join()})`;
    var o = `getChannel(getSource(${a.join()}), ${i})`;
    var s = `
      result.x = ${o};
      if (++${r[this.rank - 1]} < ${t[this.rank - 1]}) {
        ++${a[this.rank - 1]};
        result.y = ${o};
        --${a[this.rank - 1]};
      }
    `;
    var u = this.rank === 1 ? "" : `
      --${r[this.rank - 1]};
      if (++${r[this.rank - 2]} < ${t[this.rank - 2]}) {
        ++${a[this.rank - 2]};
        result.z = ${o};
        if (++${r[this.rank - 1]} < ${t[this.rank - 1]}) {
          ++${a[this.rank - 1]};
          result.w = ${o};
        }
      }
    `;
    var c = this.rank <= 4 ? `sourceLoc = coords +
            ${n}(${t.map(function (e, t) {
      return `start[${t}]`;
    }).join()});` : t.map(function (e, t) {
      return `${a[t]} = ${r[t]} + start[${t}];`;
    }).join("\n");
    this.userCode = `
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${s}
        ${u}
        setOutput(result);
      }
    `;
  });
  function ZCe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = S(Yae(a, r.begin, r.size), 2);
    var o = i[0];
    var s = i[1];
    zae(a, o, s);
    if (L$(s) === 0) {
      return n.makeTensorInfo(s, a.dtype, []);
    }
    if (n.shouldExecuteOnCPU([a]) || a.dtype === "string") {
      var u = n.texData.get(a.dataId);
      var c = RTe(u.values, o, s, a.shape, a.dtype);
      return n.makeTensorInfo(s, a.dtype, c);
    }
    var l = n.texData.get(a.dataId).isPacked;
    var h = Kae(a.shape, o, s);
    if (l || !h) {
      var p = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new JCe(s) : new XCe(s);
      var f = [o];
      return n.runWebGLProgram(p, [a], a.dtype, f);
    }
    n.uploadToGPU(a.dataId);
    return function (e, t, n, r) {
      var a = r.texData.get(e.dataId);
      var i = r.makeTensorInfo(n, e.dtype);
      var o = r.texData.get(i.dataId);
      Object.assign(o, a);
      o.refCount = 1;
      o.shape = n;
      o.dtype = e.dtype;
      var s = Xae(t, i0(e.shape));
      if (a.slice) {
        s += a.slice.flatOffset;
      }
      o.slice = {
        flatOffset: s,
        origDataId: a.slice && a.slice.origDataId || e.dataId
      };
      var u = r.dataRefCount.get(o.slice.origDataId) || 1;
      r.dataRefCount.set(o.slice.origDataId, u + 1);
      return i;
    }(a, o, s, n);
  }
  var QCe = {
    kernelName: Z2,
    backendName: "webgl",
    kernelFunc: ZCe
  };
  var $Ce = {
    kernelName: G0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.blockShape;
      var o = r.crops;
      F$(a.shape.length <= 4, function () {
        return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
      });
      var s = i.reduce(function (e, t) {
        return e * t;
      });
      var u = fie(a.shape, i, s);
      var c = die(u.length, i.length);
      var l = vie(a.shape, i, s);
      var h = mie(o, i.length);
      var p = gie(l, o, i.length);
      var f = [];
      var d = HEe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: u
        }
      });
      var v = tCe({
        inputs: {
          x: d
        },
        backend: n,
        attrs: {
          perm: c
        }
      });
      var m = HEe({
        inputs: {
          x: v
        },
        backend: n,
        attrs: {
          shape: l
        }
      });
      var g = ZCe({
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          begin: h,
          size: p
        }
      });
      f.push(d);
      f.push(v);
      f.push(m);
      f.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return g;
    }
  };
  var eAe = {
    kernelName: j0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.weights;
      var o = r.size;
      var s = n.readSync(a.dataId);
      var u = n.readSync(i.dataId);
      var c = ZSe(s, u, i.dtype, i.shape, o);
      return n.makeTensorInfo([o], i.dtype, c);
    }
  };
  var tAe = {
    kernelName: H0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = n.a;
      var i = n.b;
      var o = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS");
      var s = k0().getNumber("WEBGL_VERSION");
      if (r.shouldExecuteOnCPU([a, i]) || s === 1) {
        var u = r.texData.get(a.dataId).values;
        var c = r.texData.get(i.dataId).values;
        var l = S($Se(a.shape, i.shape, u, c, a.dtype), 2);
        var h = l[0];
        var p = l[1];
        var f = r.makeTensorInfo(p, a.dtype);
        r.texData.get(f.dataId).values = h;
        return f;
      }
      t = o ? new NEe("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n", a.shape, i.shape, false) : new wEe("\n  return float(int(a.r) & int(b.r));\n", a.shape, i.shape);
      return r.runWebGLProgram(t, [a, i], a.dtype);
    }
  };
  var nAe = {
    kernelName: K0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.s0;
      var a = t.s1;
      var i = n.readSync(r.dataId);
      var o = n.readSync(a.dataId);
      var s = z7(Array.from(i), Array.from(o));
      return n.makeTensorInfo([s.length], "int32", Int32Array.from(s));
    }
  };
  var rAe = LEe({
    opSnippet: "return float(a != b);",
    cpuKernelImpl: xTe,
    dtype: "bool"
  });
  var aAe = {
    kernelName: b2,
    backendName: "webgl",
    kernelFunc: rAe
  };
  function iAe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.input;
    return SEe({
      inputs: {
        x: n.texData.get(r.dataId).complexTensorInfos.real
      },
      backend: n
    });
  }
  var oAe = {
    kernelName: D2,
    backendName: "webgl",
    kernelFunc: iAe
  };
  var sAe = {
    kernelName: X0,
    backendName: "webgl",
    kernelFunc: function e(t) {
      var n = t.inputs;
      var r = t.backend;
      var a = t.attrs;
      var i = n.x;
      var o = a.dtype;
      if (o === "complex64") {
        if (i.dtype === "complex64") {
          return SEe({
            inputs: {
              x: i
            },
            backend: r
          });
        }
        var s = $9(i.shape);
        var u = e({
          inputs: {
            x: i
          },
          backend: r,
          attrs: {
            dtype: "float32"
          }
        });
        var c = EEe({
          inputs: {
            real: u,
            imag: s
          },
          backend: r
        });
        s.dispose();
        r.disposeIntermediateTensorInfo(u);
        return c;
      }
      if (i.dtype === "complex64") {
        var l = iAe({
          inputs: {
            input: i
          },
          backend: r
        });
        var h = e({
          inputs: {
            x: l
          },
          backend: r,
          attrs: {
            dtype: o
          }
        });
        r.disposeIntermediateTensorInfo(l);
        return h;
      }
      if (!J$(i.dtype, o)) {
        var p = SEe({
          inputs: {
            x: i
          },
          backend: r
        });
        return {
          dataId: p.dataId,
          shape: p.shape,
          dtype: o
        };
      }
      if (r.shouldExecuteOnCPU([i])) {
        var f = r.texData.get(i.dataId).values;
        var d = S(eTe(f, i.shape, i.dtype, o), 3);
        var v = d[0];
        var m = d[1];
        var g = d[2];
        return r.makeTensorInfo(v, m, g);
      }
      if (o === "int32") {
        return function (e, t) {
          var n = new $Te(e.shape, "return float(int(x));");
          var r = t.runWebGLProgram(n, [e], "int32");
          return {
            dataId: r.dataId,
            shape: r.shape,
            dtype: r.dtype
          };
        }(i, r);
      }
      if (o === "bool") {
        var y = r.makeTensorInfo([], "bool", q$("bool", 1));
        var b = rAe({
          inputs: {
            a: i,
            b: y
          },
          backend: r
        });
        r.disposeIntermediateTensorInfo(y);
        return b;
      }
      throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`);
    }
  };
  var uAe = "return ceil(x);";
  var cAe = MEe({
    opSnippet: uAe,
    packedOpSnippet: uAe,
    cpuKernelImpl: tTe
  });
  var lAe = {
    kernelName: Y0,
    backendName: "webgl",
    kernelFunc: cAe
  };
  var hAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.customUniforms = [{
      name: "minVal",
      type: "float"
    }, {
      name: "maxVal",
      type: "float"
    }];
    this.outputShape = t;
    this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  });
  var pAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "minVal",
      type: "float"
    }, {
      name: "maxVal",
      type: "float"
    }];
    this.outputShape = t;
    this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  });
  var fAe = {
    kernelName: J0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = e.attrs;
      var i = n.x;
      var o = a.clipValueMin;
      var s = a.clipValueMax;
      t = k0().getBool("WEBGL_PACK_CLIP") ? new pAe(i.shape) : new hAe(i.shape);
      var u = [[o], [s]];
      return r.runWebGLProgram(t, [i], i.dtype, u);
    }
  };
  var dAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["real", "imag"];
    this.outputShape = t;
    this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
  });
  function vAe(e, t) {
    return {
      dataId: t.dataId,
      dtype: t.dtype,
      shape: e.shape
    };
  }
  var mAe = {
    kernelName: Q0,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.x;
      var a = n.texData.get(r.dataId);
      var i = new dAe(r.shape);
      var o = [vAe(r, a.complexTensorInfos.real), vAe(r, a.complexTensorInfos.imag)];
      return n.runWebGLProgram(i, o, o[0].dtype);
    }
  };
  var gAe = p(function e(t) {
    l(this, e);
    this.outputShape = [];
    this.outputShape = oie(t, 1);
    this.variableNames = t.map(function (e, t) {
      return `T${t}`;
    });
    var n = new Array(t.length - 1);
    n[0] = t[0][1];
    for (var r = 1; r < n.length; r++) {
      n[r] = n[r - 1] + t[r][1];
    }
    var a = [`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];
    for (var i = 1; i < n.length; i++) {
      var o = n[i - 1];
      a.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`);
    }
    var s = n.length;
    var u = n[n.length - 1];
    a.push(`else setOutput(getT${s}(yR, yC-${u}));`);
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${a.join("\n        ")}
      }
    `;
  });
  var yAe = p(function e(t, n) {
    l(this, e);
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    this.outputShape = oie(t, n);
    var r = this.outputShape;
    var a = r.length;
    var i = cSe(a);
    var o = qTe("coords", a);
    var s = ["x", "y", "z", "w", "u", "v"].slice(0, a);
    this.variableNames = t.map(function (e, t) {
      return `T${t}`;
    });
    var u = new Array(t.length - 1);
    u[0] = t[0][n];
    for (var c = 1; c < u.length; c++) {
      u[c] = u[c - 1] + t[c][n];
    }
    var h = s[n];
    var p = s.slice(-2);
    var f = s.join();
    var d = `if (${h} < ${u[0]}) {
        return getChannel(
            getT0(${f}), vec2(${p.join()}));
        }`;
    for (var v = 1; v < u.length; v++) {
      var m = u[v - 1];
      d += `
        if (${h} < ${u[v]}  && ${h} >= ${u[v - 1]}) {
          return getChannel(
            getT${v}(${bAe(s, h, m)}),
            vec2(${bAe(p, h, m)}));
        }`;
    }
    var g = u.length;
    var y = u[u.length - 1];
    d += `
        return getChannel(
          getT${g}(${bAe(s, h, y)}),
          vec2(${bAe(p, h, y)}));`;
    this.userCode = `
      float getValue(${s.map(function (e) {
      return "int " + e;
    })}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[a - 1]} = ${o[a - 1]} + 1;
        if (${o[a - 1]} < ${r[a - 1]}) {
          result.g = getValue(${o});
        }

        ${o[a - 2]} = ${o[a - 2]} + 1;
        if (${o[a - 2]} < ${r[a - 2]}) {
          result.a = getValue(${o});
        }

        ${o[a - 1]} = ${o[a - 1]} - 1;
        if (${o[a - 2]} < ${r[a - 2]} &&
            ${o[a - 1]} < ${r[a - 1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `;
  });
  function bAe(e, t, n) {
    var r = e.indexOf(t);
    return e.map(function (e, t) {
      if (t === r) {
        return `${e} - ${n}`;
      } else {
        return e;
      }
    }).join();
  }
  function xAe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.input;
    return SEe({
      inputs: {
        x: n.texData.get(r.dataId).complexTensorInfos.imag
      },
      backend: n
    });
  }
  var kAe = {
    kernelName: V1,
    backendName: "webgl",
    kernelFunc: xAe
  };
  function wAe(e, t, n) {
    var r = e[0].dtype;
    if (r === "complex64") {
      var a = e.map(function (e) {
        return iAe({
          inputs: {
            input: e
          },
          backend: n
        });
      });
      var i = e.map(function (e) {
        return xAe({
          inputs: {
            input: e
          },
          backend: n
        });
      });
      var o = wAe(a, t, n);
      var s = wAe(i, t, n);
      var u = EEe({
        inputs: {
          real: o,
          imag: s
        },
        backend: n
      });
      a.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      i.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      n.disposeIntermediateTensorInfo(o);
      n.disposeIntermediateTensorInfo(s);
      return u;
    }
    var c = n.shouldExecuteOnCPU(e);
    if (r === "string") {
      c = true;
    }
    if (c) {
      var l = e.map(function (e) {
        var r = L$(e.shape.slice(t));
        return HEe({
          inputs: {
            x: e
          },
          backend: n,
          attrs: {
            shape: [-1, r]
          }
        });
      });
      var h = l.map(function (e) {
        return {
          vals: n.readSync(e.dataId),
          shape: e.shape
        };
      });
      var p = oie(l.map(function (e) {
        return e.shape;
      }), 1);
      var f = l[0].shape[0] === 1;
      var d = nTe(h, p, r, f);
      var v = oie(e.map(function (e) {
        return e.shape;
      }), t);
      var m = n.makeTensorInfo(v, r, d);
      l.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return m;
    }
    var g = e.filter(function (e) {
      return L$(e.shape) > 0;
    });
    var y = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && g[0].shape.length > 1;
    if (g.length === 1) {
      var b = y ? new $Te(e[0].shape, oEe) : new fEe(e[0].shape, oEe);
      return n.runWebGLProgram(b, e, r);
    }
    var x = k0().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if (g.length > x) {
      var k = [];
      for (var w = 0; w < g.length; w += x) {
        var I = g.slice(w, w + x);
        k.push(wAe(I, t, n));
      }
      var N = wAe(k, t, n);
      for (var S = 0, T = k; S < T.length; S++) {
        var E = T[S];
        n.disposeIntermediateTensorInfo(E);
      }
      return N;
    }
    if (y) {
      var C = new yAe(g.map(function (e) {
        return e.shape;
      }), t);
      return n.runWebGLProgram(C, g, r);
    }
    var A = function (e, t, n) {
      var r = oie(e.map(function (e) {
        return e.shape;
      }), t);
      return {
        tensors2D: e.map(function (e) {
          return HEe({
            inputs: {
              x: e
            },
            attrs: {
              shape: [-1, L$(e.shape.slice(t))]
            },
            backend: n
          });
        }),
        outShape: r
      };
    }(g, t, n);
    var R = A.tensors2D;
    var _ = A.outShape;
    var O = new gAe(R.map(function (e) {
      return e.shape;
    }));
    var F = n.runWebGLProgram(O, R, r);
    R.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    });
    var D = HEe({
      inputs: {
        x: F
      },
      attrs: {
        shape: _
      },
      backend: n
    });
    n.disposeIntermediateTensorInfo(F);
    return D;
  }
  function IAe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = j$(e.attrs.axis, t[0].shape)[0];
    iie(t.map(function (e) {
      return e.shape;
    }), r);
    var a = oie(t.map(function (e) {
      return e.shape;
    }), r);
    if (L$(a) === 0) {
      return n.makeTensorInfo(a, t[0].dtype, []);
    }
    var i = t.filter(function (e) {
      return L$(e.shape) > 0;
    });
    if (i.length === 1) {
      return SEe({
        inputs: {
          x: i[0]
        },
        backend: n
      });
    } else {
      return wAe(i, r, n);
    }
  }
  var NAe = {
    kernelName: $0,
    backendName: "webgl",
    kernelFunc: IAe
  };
  var SAe = p(function e(t, n = false, r = null, a = false, i = false) {
    l(this, e);
    this.variableNames = ["x", "W"];
    this.outputShape = t.outShape;
    var o = t.padInfo.top;
    var s = t.padInfo.left;
    var u = t.strideHeight;
    var c = t.strideWidth;
    var h = t.dilationHeight;
    var p = t.dilationWidth;
    var f = t.filterHeight;
    var d = t.filterWidth;
    var v = Math.floor(t.inChannels / 4) * 4;
    var m = t.inChannels % 4;
    var g = t.dataFormat === "channelsLast";
    var y = g ? 1 : 2;
    var b = g ? 2 : 3;
    var x = g ? 3 : 1;
    var k = "";
    var w = "";
    if (r) {
      k = a ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : i ? `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : `
          float activation(float x) {
            ${r}
          }
        `;
      w = "result = activation(result);";
    }
    var I = n ? "result += getBiasAtOutCoords();" : "";
    if (n) {
      this.variableNames.push("bias");
    }
    if (a) {
      this.variableNames.push("preluActivationWeights");
    }
    if (i) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${k}

      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${v}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m === 1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${v}) *
                    getW(wR, wC, ${v}, d2);
              } else {
                dotProd +=
                    getX(batch, ${v}, xR, xC) *
                    getW(wR, wC, ${v}, d2);
              }

            } else if (${m === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2),
                getW(wR, wC, ${v} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1),
                  getX(batch, xR, xC, ${v} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC),
                  getX(batch, ${v} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${w}
        setOutput(result);
      }
    `;
  });
  var TAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["x", "W"];
    this.outputShape = t.outShape;
    var n = t.padInfo.front;
    var r = t.padInfo.top;
    var a = t.padInfo.left;
    var i = t.strideDepth;
    var o = t.strideHeight;
    var s = t.strideWidth;
    var u = t.dilationDepth;
    var c = t.dilationHeight;
    var h = t.dilationWidth;
    var p = t.filterDepth;
    var f = t.filterHeight;
    var d = t.filterWidth;
    var v = Math.floor(t.inChannels / 4) * 4;
    var m = t.inChannels % 4;
    this.userCode = `
      const ivec3 strides = ivec3(${i}, ${o}, ${s});
      const ivec3 pads = ivec3(${n}, ${r}, ${a});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${v}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${v}) *
                  getW(wF, wR, wC, ${v}, d2);
              } else if (${m === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1),
                  getX(batch, xF, xR, xC, ${v} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2),
                  getW(wF, wR, wC, ${v} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var EAe = p(function e(t, n = false, r = null, a = false, i = false) {
    l(this, e);
    this.variableNames = ["x", "W"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "pads",
      type: "ivec2"
    }, {
      name: "strides",
      type: "ivec2"
    }, {
      name: "dilations",
      type: "ivec2"
    }, {
      name: "inDims",
      type: "ivec2"
    }];
    this.outputShape = t.outShape;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var o = t.padInfo.left;
    var s = t.strideWidth;
    var u = t.dilationWidth;
    var c = t.filterHeight;
    for (var h = t.filterWidth, p = h, f = "\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;", d = 0; d < h; d++) {
      f += `
           vec4 xTexelC${d * 2};
           int xTexelC${d * 2}Ready;
           vec4 xTexelC${d * 2 + 1};
           int xTexelC${d * 2 + 1}Ready;
           vec4 xC${d};`;
    }
    f += `
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;
    for (var v = 0; v < h; v++) {
      f += `
           xTexelC${v * 2} = vec4(0.0);
           xTexelC${v * 2}Ready = 0;
           xTexelC${v * 2 + 1} = vec4(0.0);
           xTexelC${v * 2 + 1}Ready = 0;
           xC${v} = vec4(0.0);`;
    }
    f += "\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";
    for (var m = 0; m < (p + 1) / 2; m++) {
      var g = m * 2;
      f += `
           xC = xCCorner + ${g * u};
           `;
      if (s === 1) {
        if (g < h && (o % 2 == 1 ? (f += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `, f += u === 1 && g > 0 ? `
                 xC${g} = vec4(xTexelC${g - 2}.zw, xTexelC${g}.xy);
                 ` : `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `) : f += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `, g + 1 < h)) {
          var y = o % 2 == 0 ? R$(u) : u;
          if (u % 2 == 0 && o % 2 == 1 || u % 2 != 0 && o % 2 != 1) {
            f += `
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g + 1}Ready == 0) {
                     xTexelC${g + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g + 1}.zw = vec2(0.0);
                     }
                     xTexelC${g + 1}Ready = 1;
                   }
                   `;
            f += u > 1 ? `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g + 1} = vec4(previous.zw, xTexelC${g + 1}.xy);
                     } else {
                      xC${g + 1} = vec4(0.0, 0.0, xTexelC${g + 1}.xy);
                     }
                     ` : `
                     xC${g + 1} = vec4(xTexelC${g}.zw, xTexelC${g + 1}.xy);
                     `;
          } else {
            f += y === 1 ? `
                     xC${g + 1} = xTexelC${g};
                     ` : `
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g + 1}Ready == 0) {
                       xTexelC${g + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g + 1}.zw = vec2(0.0);
                       }
                       xTexelC${g + 1}Ready = 1;
                     }

                     xC${g + 1} = xTexelC${g + 1};
                     `;
          }
        }
      } else if (g < h) {
        if (o % 2 == 1) {
          f += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g + 1}Ready == 0) {
                   xTexelC${g + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g + 1}.zw = vec2(0.0);
                   }
                   xTexelC${g + 1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g + 1}.zw);
               `;
          if (g + 1 < h) {
            f += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g + 1} = vec4(xTexelC${g + 1}.xy, final.xy);
                 `;
          }
        } else {
          f += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g + 1}Ready == 0) {
                   xTexelC${g + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g + 1}.zw = vec2(0.);
                   }
                   xTexelC${g + 1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g + 1}.xy);
               `;
          if (g + 1 < h) {
            f += `
                   xC${g + 1} = vec4(xTexelC${g}.zw, xTexelC${g + 1}.zw);
                 `;
          }
        }
      }
      if (g < h) {
        f += `
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `;
        if (g + 1 < h) {
          f += `
               wTexel = getW(r, ${g + 1}, d1, d2);
               dotProd += xC${g + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${g + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `;
        }
      }
    }
    f += "\n     }\n   ";
    f += "\n     }\n   ";
    f += "\n     }\n   ";
    var b = "";
    var x = "";
    if (r) {
      b = a ? `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }` : i ? `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }` : `vec4 activation(vec4 x) {
           ${r}
         }`;
      x = "result = activation(result);";
    }
    var k = n ? "result += getBiasAtOutCoords();" : "";
    if (n) {
      this.variableNames.push("bias");
    }
    if (a) {
      this.variableNames.push("preluActivationWeights");
    }
    if (i) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
       ${b}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${k}
         ${x}
         setOutput(result);
       }
     `;
  });
  var CAe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "inputShape",
      type: "ivec4"
    }, {
      name: "pad",
      type: "ivec2"
    }, {
      name: "stride",
      type: "ivec2"
    }, {
      name: "dilation",
      type: "ivec2"
    }, {
      name: "inChannels",
      type: "int"
    }, {
      name: "itemsPerBlockRow",
      type: "int"
    }, {
      name: "outWidth",
      type: "int"
    }];
    this.outputShape = t;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var r = n.dataFormat;
    var a = PNe();
    var i = r === "channelsLast";
    var o = i ? 1 : 2;
    var s = i ? 2 : 3;
    var u = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;
    var c = "";
    for (var h = 0; h <= 1; h++) {
      for (var p = 0; p <= 1; p++) {
        c += `
          blockIndex = rc.z + ${p};
          pos = rc.y + ${h};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${s}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${h * 2 + p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h * 2 + p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
      }
    }
    this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${a.output} = result;
      }
    `;
  });
  function AAe(e, t) {
    var n = e.length;
    if (n >= 3) {
      return [].concat(T(e.slice(0, -3)), t ? [e[n - 3] * e[n - 2], e[n - 1]] : [e[n - 3], e[n - 2] * e[n - 1]]);
    } else if (!t && n === 1 && e[0] > 1) {
      return [e[0], 1];
    } else {
      return null;
    }
  }
  function RAe(e) {
    var t;
    var n = e.x;
    var r = e.filter;
    var a = e.convInfo;
    var i = e.backend;
    var o = e.bias;
    var s = o === undefined ? null : o;
    var u = e.preluActivationWeights;
    var c = u === undefined ? null : u;
    var l = e.leakyreluAlpha;
    var h = l === undefined ? 0 : l;
    var p = e.activation;
    var f = p === undefined ? null : p;
    var d = n.shape;
    var v = i.texData.get(n.dataId);
    var m = a.inChannels;
    var g = d[0] * d[1] * d[2];
    var y = a.outChannels;
    var b = a.dataFormat === "channelsLast";
    var x = [];
    if (c != null) {
      var k = AAe(c.shape, b);
      if (k != null) {
        c = HEe({
          inputs: {
            x: c
          },
          backend: i,
          attrs: {
            shape: k
          }
        });
        x.push(c);
      }
    }
    if (s != null) {
      var w = AAe(s.shape, b);
      if (w != null) {
        s = HEe({
          inputs: {
            x: s
          },
          backend: i,
          attrs: {
            shape: w
          }
        });
        x.push(s);
      }
    }
    if ((g !== 1 && y !== 1 || !(m > 1000)) && v.isPacked && b && v.texture != null && d[2] % 2 != 0 && P$(v.shape.slice(-3), d.slice(-3))) {
      var I = d[0] * d[1] * (d[2] + 1);
      var N = {
        dataId: n.dataId,
        shape: [1, I, a.inChannels],
        dtype: n.dtype
      };
      var S = v.shape;
      v.shape = v.shape.slice();
      v.shape[v.shape.length - 2]++;
      F$(SNe(v.shape, N.shape), function () {
        return `packed reshape ${v.shape} to ${N.shape} isn't free`;
      });
      var T = HEe({
        inputs: {
          x: r
        },
        backend: i,
        attrs: {
          shape: [1, a.inChannels, a.outChannels]
        }
      });
      x.push(T);
      var E = rCe({
        a: N,
        b: T,
        backend: i,
        transposeA: false,
        transposeB: false,
        bias: s,
        activation: f,
        preluActivationWeights: c,
        leakyreluAlpha: h
      });
      var C = i.texData.get(E.dataId);
      F$(C.isPacked, function () {
        return "batchMatMul result is expected to be packed";
      });
      v.shape = S;
      C.shape = a.outShape;
      (t = SEe({
        inputs: {
          x: E
        },
        backend: i
      })).shape = a.outShape;
      x.push(E);
    } else {
      var A = a.outHeight * a.outWidth;
      var R = HEe({
        inputs: {
          x: n
        },
        backend: i,
        attrs: {
          shape: b ? [a.batchSize, A, a.inChannels] : [a.batchSize, a.inChannels, A]
        }
      });
      var _ = HEe({
        inputs: {
          x: r
        },
        backend: i,
        attrs: {
          shape: [1, a.inChannels, a.outChannels]
        }
      });
      var O = rCe({
        a: b ? R : _,
        b: b ? _ : R,
        transposeA: !b,
        transposeB: false,
        backend: i,
        bias: s,
        activation: f,
        preluActivationWeights: c,
        leakyreluAlpha: h
      });
      t = HEe({
        inputs: {
          x: O
        },
        backend: i,
        attrs: {
          shape: a.outShape
        }
      });
      x.push(R);
      x.push(_);
      x.push(O);
    }
    for (var F = 0, D = x; F < D.length; F++) {
      var M = D[F];
      i.disposeIntermediateTensorInfo(M);
    }
    return t;
  }
  function _Ae(e) {
    var t = e.x;
    var n = e.filter;
    var r = e.convInfo;
    var a = e.backend;
    var i = e.bias;
    var o = i === undefined ? null : i;
    var s = e.preluActivationWeights;
    var u = s === undefined ? null : s;
    var c = e.leakyreluAlpha;
    var l = c === undefined ? 0 : c;
    var h = e.activation;
    var p = h === undefined ? null : h;
    var f = r.filterWidth;
    var d = r.filterHeight;
    var v = r.inChannels;
    var m = r.outWidth;
    var g = r.outHeight;
    var y = r.dataFormat === "channelsLast";
    var b = f * d * v;
    var x = g * m;
    var k = [r.batchSize, b, x];
    var w = [];
    if (u != null) {
      var I = AAe(u.shape, y);
      if (I != null) {
        u = HEe({
          inputs: {
            x: u
          },
          backend: a,
          attrs: {
            shape: I
          }
        });
        w.push(u);
      }
    }
    if (o != null) {
      var N = AAe(o.shape, y);
      if (N != null) {
        o = HEe({
          inputs: {
            x: o
          },
          backend: a,
          attrs: {
            shape: N
          }
        });
        w.push(o);
      }
    }
    var S = HEe({
      inputs: {
        x: n
      },
      backend: a,
      attrs: {
        shape: [1, b, L$(n.shape) / b]
      }
    });
    w.push(S);
    var T = new CAe(k, r);
    var E = [t.shape, [r.padInfo.top, r.padInfo.left], [r.strideHeight, r.strideWidth], [r.dilationHeight, r.dilationWidth], [r.inChannels], [r.filterWidth * r.inChannels], [r.outWidth]];
    var C = a.runWebGLProgram(T, [t], "float32", E);
    var A = HEe({
      inputs: {
        x: C
      },
      backend: a,
      attrs: {
        shape: k
      }
    });
    w.push(C);
    w.push(A);
    var R = o != null;
    var _ = u != null;
    var O = p === "leakyrelu";
    var F = p ? zEe(p, true) : null;
    var D = new PEe(y ? A.shape : S.shape, y ? S.shape : A.shape, y ? [r.batchSize, x, r.outChannels] : [r.batchSize, r.outChannels, x], true, false, R, F, _, O);
    var M = y ? [A, S] : [S, A];
    if (o) {
      M.push(o);
    }
    if (_) {
      M.push(u);
    }
    if (O) {
      var L = a.makeTensorInfo([], "float32", M4(l, "float32"));
      M.push(L);
      w.push(L);
    }
    var z = a.runWebGLProgram(D, M, "float32");
    var P = HEe({
      inputs: {
        x: z
      },
      backend: a,
      attrs: {
        shape: r.outShape
      }
    });
    w.push(z);
    for (var B = 0, W = w; B < W.length; B++) {
      var U = W[B];
      a.disposeIntermediateTensorInfo(U);
    }
    return P;
  }
  var OAe = {
    kernelName: e1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = e.attrs;
      var i = n.x;
      var o = n.filter;
      var s = a.strides;
      var u = a.pad;
      var c = a.dataFormat;
      var l = a.dilations;
      var h = a.dimRoundingMode;
      var p = q8(c);
      var f = D8(i.shape, o.shape, s, l, u, h, false, p);
      if (f.filterHeight !== 1 || f.filterWidth !== 1 || f.dilationHeight !== 1 || f.dilationWidth !== 1 || f.strideHeight !== 1 || f.strideWidth !== 1 || f.padInfo.type !== "SAME" && f.padInfo.type !== "VALID") {
        if (f.strideWidth <= 2 && p === "channelsLast" && k0().getBool("WEBGL_EXP_CONV")) {
          var d = new EAe(f);
          var v = [[f.padInfo.top, f.padInfo.left], [f.strideHeight, f.strideWidth], [f.dilationHeight, f.dilationWidth], [f.inHeight, f.inWidth]];
          t = r.runWebGLProgram(d, [i, o], "float32", v);
        } else if (k0().getBool("WEBGL_CONV_IM2COL")) {
          t = _Ae({
            x: i,
            filter: o,
            convInfo: f,
            backend: r
          });
        } else {
          var m = new SAe(f);
          t = r.runWebGLProgram(m, [i, o], "float32");
        }
      } else {
        t = RAe({
          x: i,
          filter: o,
          convInfo: f,
          backend: r
        });
      }
      var g = HEe({
        inputs: {
          x: t
        },
        backend: r,
        attrs: {
          shape: f.outShape
        }
      });
      r.disposeIntermediateTensorInfo(t);
      return g;
    }
  };
  var FAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["x", "dy"];
    this.outputShape = t.filterShape;
    var n = t.strideHeight;
    var r = t.strideWidth;
    var a = t.padInfo.top;
    var i = t.padInfo.left;
    var o = t.dataFormat === "channelsLast";
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${a};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o ? "float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);" : "float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var DAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy", "W"];
    this.outputShape = t.inShape;
    var n = t.filterHeight;
    var r = t.filterWidth;
    var a = t.strideHeight;
    var i = t.strideWidth;
    var o = t.dataFormat === "channelsLast";
    var s = n - 1 - t.padInfo.top;
    var u = r - 1 - t.padInfo.left;
    var c = o ? 1 : 2;
    var h = o ? 2 : 3;
    var p = o ? 3 : 1;
    this.userCode = `
      const ivec2 pads = ivec2(${s}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var MAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["x", "dy"];
    this.outputShape = t.filterShape;
    var n = t.strideDepth;
    var r = t.strideHeight;
    var a = t.strideWidth;
    var i = t.padInfo.front;
    var o = t.padInfo.top;
    var s = t.padInfo.left;
    this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${a} - ${s};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var LAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy", "W"];
    this.outputShape = t.inShape;
    var n = t.filterDepth;
    var r = t.filterHeight;
    var a = t.filterWidth;
    var i = t.strideDepth;
    var o = t.strideHeight;
    var s = t.strideWidth;
    var u = n - 1 - t.padInfo.front;
    var c = r - 1 - t.padInfo.top;
    var h = a - 1 - t.padInfo.left;
    this.userCode = `
      const ivec3 pads = ivec3(${u}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${a}; wC++) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${a} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var zAe = {
    kernelName: t1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.dy;
      var o = r.strides;
      var s = r.pad;
      var u = r.dataFormat;
      var c = r.dimRoundingMode;
      var l = r.filterShape;
      var h = q8(u);
      var p = D8(a.shape, l, o, 1, s, c, false, h);
      var f = new FAe(p);
      return n.runWebGLProgram(f, [a, i], "float32");
    }
  };
  var PAe = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy", "W"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "strides",
      type: "vec2"
    }];
    this.outputShape = t.inShape;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var n = t.filterHeight;
    var r = t.filterWidth;
    var a = n - 1 - t.padInfo.top;
    var i = r - 1 - t.padInfo.left;
    this.userCode = `
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
  });
  var BAe = {
    kernelName: n1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.filter;
      var o = r.inputShape;
      var s = r.strides;
      var u = r.pad;
      var c = r.dataFormat;
      var l = r.dimRoundingMode;
      var h = q8(c);
      var p = D8(o, i.shape, s, 1, u, l, false, h);
      if (k0().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && h === "channelsLast") {
        var f = [[p.strideHeight, p.strideWidth]];
        var d = new PAe(p);
        return n.runWebGLProgram(d, [a, i], "float32", f);
      }
      var v = new DAe(p);
      return n.runWebGLProgram(v, [a, i], "float32");
    }
  };
  var WAe = {
    kernelName: r1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = r.strides;
      var s = r.pad;
      var u = r.dilations;
      var c = M8(a.shape, i.shape, o, u, s);
      var l = new TAe(c);
      return n.runWebGLProgram(l, [a, i], "float32");
    }
  };
  var UAe = {
    kernelName: a1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.dy;
      var o = r.strides;
      var s = r.pad;
      var u = r.filterShape;
      var c = M8(a.shape, u, o, 1, s);
      var l = new MAe(c);
      return n.runWebGLProgram(l, [a, i], "float32");
    }
  };
  var VAe;
  var GAe = {
    kernelName: i1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.filter;
      var o = r.pad;
      var s = r.strides;
      var u = M8(r.inputShape, i.shape, s, 1, o);
      var c = new LAe(u);
      return n.runWebGLProgram(c, [a, i], "float32");
    }
  };
  var jAe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n",
    packedOpSnippet: `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${IEe}
  return result;
`
  });
  var HAe = {
    kernelName: o1,
    backendName: "webgl",
    kernelFunc: jAe
  };
  var qAe = MEe({
    opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
  });
  var KAe = {
    kernelName: s1,
    backendName: "webgl",
    kernelFunc: qAe
  };
  var XAe = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["Image", "Boxes", "BoxInd"];
    this.outputShape = [];
    var o = S(t, 4);
    var s = o[0];
    var u = o[1];
    var c = o[2];
    var h = o[3];
    var p = S(n, 1)[0];
    var f = S(r, 2);
    var d = f[0];
    var v = f[1];
    this.outputShape = [p, d, v, h];
    var m = a === "bilinear" ? 1 : 0;
    var g = `${u - 1}.0`;
    var y = `${c - 1}.0`;
    var b = S(d > 1 ? [`${(u - 1) / (d - 1)}`, "(y2-y1) * height_ratio", `y1*${g} + float(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${g}`], 3);
    var x = b[0];
    var k = b[1];
    var w = b[2];
    var I = S(v > 1 ? [`${(c - 1) / (v - 1)}`, "(x2-x1) * width_ratio", `x1*${y} + float(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${y}`], 3);
    var N = I[0];
    var T = I[1];
    var E = I[2];
    this.userCode = `
      const float height_ratio = float(${x});
      const float width_ratio = float(${N});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${k};
        float width_scale = ${T};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
  });
  var YAe = {
    kernelName: l1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.image;
      var i = t.boxes;
      var o = t.boxInd;
      var s = r.cropSize;
      var u = r.method;
      var c = r.extrapolationValue;
      var l = new XAe(a.shape, i.shape, s, u, c);
      return n.runWebGLProgram(l, [a, i, o], "float32");
    }
  };
  (function (e) {
    e.Prod = "*";
    e.Sum = "+";
  })(VAe ||= {});
  var JAe = p(function e(t, n, r, a) {
    l(this, e);
    this.op = t;
    this.outputShape = n;
    this.variableNames = ["x"];
    this.customUniforms = [{
      name: "index",
      type: "float"
    }];
    var i = this.outputShape.length;
    var o = this.op === VAe.Prod ? "1.0" : "0.0";
    var s = r ? o : `getX(${ZAe(i, "coords", this.op)})`;
    var u = this.outputShape[this.outputShape.length - 1];
    var c = "";
    var h = "";
    if (r) {
      c = a ? `end != ${u - 1}` : "end != 0";
      h = a ? "end + 1" : "end - 1";
    } else {
      c = a ? `end + pow2 < ${u}` : "end >= pow2";
      h = a ? "end + pow2" : "end - pow2";
    }
    this.userCode = `
      void main() {
        ${cSe(i)} coords = getOutputCoords();
        int end = ${QAe(i, "coords", this.op)};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${h};
          ${QAe(i, "coords", this.op)} = idx;
          val ${this.op}= getX(${ZAe(i, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
  });
  function ZAe(e, t, n) {
    if (e === 1) {
      return `${t}`;
    }
    if (e === 2) {
      return `${t}.x, ${t}.y`;
    }
    if (e === 3) {
      return `${t}.x, ${t}.y, ${t}.z`;
    }
    if (e === 4) {
      return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
    }
    throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`);
  }
  function QAe(e, t, n) {
    if (e === 1) {
      return `${t}`;
    }
    if (e === 2) {
      return `${t}.y`;
    }
    if (e === 3) {
      return `${t}.z`;
    }
    if (e === 4) {
      return `${t}.w`;
    }
    throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`);
  }
  function $Ae(e, t, n, r, a, i) {
    var o = t.shape.length;
    var s = $7([r], o);
    var u = t;
    if (s != null) {
      u = tCe({
        inputs: {
          x: t
        },
        backend: n,
        attrs: {
          perm: s
        }
      });
    }
    var c = t9(1, o)[0];
    if (c !== o - 1) {
      throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length - 1} but got axis=${r}`);
    }
    for (var l = u.shape[c], h = SEe({
        inputs: {
          x: u
        },
        backend: n
      }), p = 0; p <= Math.ceil(Math.log2(l)) - 1; p++) {
      var f = new JAe(e, u.shape, false, i);
      var d = [[p]];
      var v = h;
      h = n.runWebGLProgram(f, [h], h.dtype, d);
      n.disposeIntermediateTensorInfo(v);
    }
    if (a) {
      var m = new JAe(e, u.shape, a, i);
      var g = h;
      h = n.runWebGLProgram(m, [h], h.dtype);
      n.disposeIntermediateTensorInfo(g);
    }
    if (s != null) {
      var y = tCe({
        inputs: {
          x: h
        },
        backend: n,
        attrs: {
          perm: e9(s)
        }
      });
      n.disposeIntermediateTensorInfo(h);
      n.disposeIntermediateTensorInfo(u);
      return y;
    }
    return h;
  }
  var eRe = {
    kernelName: u1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.exclusive;
      var s = r.reverse;
      return $Ae(VAe.Prod, a, n, i, o, s);
    }
  };
  var tRe = {
    kernelName: c1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.exclusive;
      var s = r.reverse;
      return $Ae(VAe.Sum, a, n, i, o, s);
    }
  };
  var nRe = {
    kernelName: h1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.weights;
      var o = r.size;
      var s = r.binaryOutput;
      if (a.shape.length === 1) {
        var u = n.readSync(a.dataId);
        var c = n.readSync(i.dataId);
        var l = ZSe(u, c, i.dtype, i.shape, o);
        return n.makeTensorInfo([o], i.dtype, l);
      }
      if (a.shape.length === 2) {
        var h = n.bufferSync(a);
        var p = n.bufferSync(i);
        var f = QSe(h, p, o, s);
        return n.makeTensorInfo(f.shape, i.dtype, f.values);
      }
      throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`);
    }
  };
  var rRe = function () {
    function e(t, n, r) {
      l(this, e);
      this.variableNames = ["x"];
      this.outputShape = [];
      this.outputShape = t;
      this.blockSize = n;
      this.dataFormat = r;
      this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    p(e, [{
      key: "getHeightCoordString",
      value: function () {
        if (this.dataFormat === "NHWC") {
          return "coords[1]";
        } else {
          return "coords[2]";
        }
      }
    }, {
      key: "getWidthCoordString",
      value: function () {
        if (this.dataFormat === "NHWC") {
          return "coords[2]";
        } else {
          return "coords[3]";
        }
      }
    }, {
      key: "getDepthCoordString",
      value: function () {
        if (this.dataFormat === "NHWC") {
          return "coords[3]";
        } else {
          return "coords[1]";
        }
      }
    }, {
      key: "getOutputDepthSize",
      value: function () {
        if (this.dataFormat === "NHWC") {
          return this.outputShape[3];
        } else {
          return this.outputShape[1];
        }
      }
    }, {
      key: "getInputSamplingString",
      value: function () {
        if (this.dataFormat === "NHWC") {
          return "getX(b, in_h, in_w, in_d)";
        } else {
          return "getX(b, in_d, in_h, in_w)";
        }
      }
    }]);
    return e;
  }();
  var aRe = {
    kernelName: p1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.blockSize;
      var o = r.dataFormat;
      var s = a.shape[0];
      var u = (o === "NHWC" ? a.shape[1] : a.shape[2]) * i;
      var c = (o === "NHWC" ? a.shape[2] : a.shape[3]) * i;
      var l = (o === "NHWC" ? a.shape[3] : a.shape[1]) / (i * i);
      var h = new rRe(o === "NHWC" ? [s, u, c, l] : [s, l, u, c], i, o);
      return n.runWebGLProgram(h, [a], a.dtype);
    }
  };
  var iRe = p(function e(t, n = false, r = null, a = false, i = false) {
    l(this, e);
    this.variableNames = ["x", "W"];
    this.customUniforms = [{
      name: "pads",
      type: "ivec2"
    }, {
      name: "strides",
      type: "ivec2"
    }, {
      name: "dilations",
      type: "ivec2"
    }, {
      name: "inDims",
      type: "ivec2"
    }];
    this.outputShape = t.outShape;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var o = t.filterHeight;
    var s = t.filterWidth;
    var u = t.outChannels / t.inChannels;
    var c = "";
    var h = "";
    if (r) {
      c = a ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : i ? `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : `
          float activation(float x) {
            ${r}
          }
        `;
      h = "result = activation(result);";
    }
    var p = n ? "result += getBiasAtOutCoords();" : "";
    if (n) {
      this.variableNames.push("bias");
    }
    if (a) {
      this.variableNames.push("preluActivationWeights");
    }
    if (i) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${s}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${h}
        setOutput(result);
      }
    `;
  });
  var oRe = p(function e(t, n = false, r = null, a = false, i = false) {
    l(this, e);
    this.variableNames = ["x", "W"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "pads",
      type: "ivec2"
    }, {
      name: "strides",
      type: "ivec2"
    }, {
      name: "dilations",
      type: "ivec2"
    }, {
      name: "inDims",
      type: "ivec2"
    }];
    this.outputShape = t.outShape;
    this.enableShapeUniforms = ySe(this.outputShape.length);
    var o = t.outChannels / t.inChannels;
    var s = t.padInfo.left;
    var u = t.strideWidth;
    var c = t.dilationWidth;
    var h = t.filterHeight;
    for (var p = t.filterWidth, f = p, d = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;", v = 0; v < p; v++) {
      d += `
          vec4 xTexelC${v * 2};
          int xTexelC${v * 2}Ready;
          vec4 xTexelC${v * 2 + 1};
          int xTexelC${v * 2 + 1}Ready;
          vec4 xC${v};`;
    }
    d += `
    for (int r = 0; r < ${h}; r++) {
      `;
    for (var m = 0; m < p; m++) {
      d += `
          xTexelC${m * 2} = vec4(0.0);
          xTexelC${m * 2}Ready = 0;
          xTexelC${m * 2 + 1} = vec4(0.0);
          xTexelC${m * 2 + 1}Ready = 0;
          xC${m} = vec4(0.0);`;
    }
    d += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
    for (var g = 0; g < (f + 1) / 2; g++) {
      var y = g * 2;
      d += `
          xC = xCCorner + ${y * c};
          `;
      if (u === 1) {
        if (y < p && (s % 2 == 1 ? (d += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `, d += c === 1 && y > 0 ? `
                xC${y} = vec4(xTexelC${y - 2}.zw, xTexelC${y}.xy);
                ` : `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `) : d += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `, y + 1 < p)) {
          var b = s % 2 == 0 ? R$(c) : c;
          if (c % 2 == 0 && s % 2 == 1 || c % 2 != 0 && s % 2 != 1) {
            d += `
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                    xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y + 1}.zw = vec2(0.0);
                    }
                    xTexelC${y + 1}Ready = 1;
                  }
                  `;
            d += c > 1 ? `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y + 1} = vec4(previous.zw, xTexelC${y + 1}.xy);
                    } else {
                     xC${y + 1} = vec4(0.0, 0.0, xTexelC${y + 1}.xy);
                    }
                    ` : `
                    xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.xy);
                    `;
          } else {
            d += b === 1 ? `
                    xC${y + 1} = xTexelC${y};
                    ` : `
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                      xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y + 1}.zw = vec2(0.0);
                      }
                      xTexelC${y + 1}Ready = 1;
                    }

                    xC${y + 1} = xTexelC${y + 1};
                    `;
          }
        }
      } else if (y < p) {
        if (s % 2 == 1) {
          d += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.0);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
              `;
          if (y + 1 < p) {
            d += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y + 1} = vec4(xTexelC${y + 1}.xy, final.xy);
                `;
          }
        } else {
          d += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y + 1}.xy);
              `;
          if (y + 1 < p) {
            d += `
                  xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
                `;
          }
        }
      }
      if (y < p) {
        d += `
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `;
        if (y + 1 < p) {
          d += `
              wTexel = getW(r, ${y + 1}, d1, q);
              dotProd += xC${y + 1} * vec4(wTexel.xz, wTexel.xz);
            `;
        }
      }
    }
    d += "\n    }\n  ";
    d += "\n      }\n    ";
    var x = "";
    var k = "";
    if (r) {
      x = a ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : i ? `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : `vec4 activation(vec4 x) {
          ${r}
        }`;
      k = "result = activation(result);";
    }
    var w = n ? "result += getBiasAtOutCoords();" : "";
    if (n) {
      this.variableNames.push("bias");
    }
    if (a) {
      this.variableNames.push("preluActivationWeights");
    }
    if (i) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${x}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${k}
        setOutput(result);
      }
    `;
  });
  var sRe = {
    kernelName: f1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = r.strides;
      var s = r.pad;
      var u = r.dilations;
      var c = r.dimRoundingMode;
      var l = u;
      if (l == null) {
        l = [1, 1];
      }
      F$(j8(o, l), function () {
        return `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`;
      });
      var h;
      var p = D8(a.shape, i.shape, o, l, s, c, true);
      h = k0().getBool("WEBGL_PACK_DEPTHWISECONV") && p.strideWidth <= 2 && p.outChannels / p.inChannels == 1 ? new oRe(p) : new iRe(p);
      var f = [[p.padInfo.top, p.padInfo.left], [p.strideHeight, p.strideWidth], [p.dilationHeight, p.dilationWidth], [p.inHeight, p.inWidth]];
      return n.runWebGLProgram(h, [a, i], "float32", f);
    }
  };
  var uRe = p(function e(t) {
    l(this, e);
    this.variableNames = ["x", "dy"];
    this.outputShape = t.filterShape;
    var n = t.strideHeight;
    var r = t.strideWidth;
    var a = t.padInfo.top;
    var i = t.padInfo.left;
    var o = t.outChannels / t.inChannels;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${a};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var cRe = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy", "W"];
    this.outputShape = t.inShape;
    var n = t.filterHeight;
    var r = t.filterWidth;
    var a = t.strideHeight;
    var i = t.strideWidth;
    var o = n - 1 - t.padInfo.top;
    var s = r - 1 - t.padInfo.left;
    var u = t.outChannels / t.inChannels;
    this.userCode = `
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var lRe = {
    kernelName: d1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.dy;
      var o = r.strides;
      var s = r.dilations;
      var u = r.pad;
      var c = r.dimRoundingMode;
      var l = r.filterShape;
      var h = D8(a.shape, l, o, s, u, c, true);
      var p = new uRe(h);
      return n.runWebGLProgram(p, [a, i], "float32");
    }
  };
  var hRe = {
    kernelName: v1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.filter;
      var o = r.strides;
      var s = r.dilations;
      var u = r.pad;
      var c = r.dimRoundingMode;
      var l = D8(r.inputShape, i.shape, o, s, u, c, true);
      var h = new cRe(l);
      return n.runWebGLProgram(h, [a, i], "float32");
    }
  };
  var pRe = p(function e(t) {
    l(this, e);
    this.variableNames = ["X"];
    this.outputShape = [t, t];
    this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
  });
  var fRe = {
    kernelName: m1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.x;
      var a = [].concat(T(r.shape), T(r.shape));
      var i = L$(r.shape);
      var o = HEe({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          shape: [i]
        }
      });
      var s = new pRe(i);
      var u = n.runWebGLProgram(s, [o], o.dtype);
      var c = HEe({
        inputs: {
          x: u
        },
        backend: n,
        attrs: {
          shape: a
        }
      });
      n.disposeIntermediateTensorInfo(o);
      n.disposeIntermediateTensorInfo(u);
      return c;
    }
  };
  var dRe = p(function e(t) {
    l(this, e);
    this.variableNames = ["x", "W"];
    this.outputShape = t.outShape;
    var n = t.inHeight;
    var r = t.inWidth;
    var a = t.padInfo;
    var i = t.strideHeight;
    var o = t.strideWidth;
    var s = t.filterHeight;
    var u = t.filterWidth;
    var c = t.dilationHeight;
    var h = t.dilationWidth;
    var p = a.top;
    var f = a.left;
    this.userCode = `
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${p}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${s}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
  });
  var vRe = {
    kernelName: g1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = e.attrs;
      var i = n.x;
      var o = n.filter;
      var s = a.strides;
      var u = a.pad;
      var c = a.dilations;
      var l = _8(i.shape, o.shape, s, u, "NHWC", c);
      var h = new dRe(l);
      var p = HEe({
        inputs: {
          x: t = r.runWebGLProgram(h, [i, o], "float32")
        },
        backend: r,
        attrs: {
          shape: l.outShape
        }
      });
      r.disposeIntermediateTensorInfo(t);
      return p;
    }
  };
  var mRe = {
    kernelName: w1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t;
      var a = Lie(e.attrs.equation, r.length);
      var i = a.allDims;
      var o = a.summedDims;
      var s = a.idDims;
      Pie(i.length, s, r);
      var u = Bie(o, s);
      var c = u.path;
      var l = u.steps;
      for (var h = l.length, p = null, f = i.length, d = [], v = 0; v < h; ++v) {
        var m;
        var g = O(l[v]);
        try {
          for (g.s(); !(m = g.n()).done;) {
            var y = m.value;
            var b = zie(f, s[y]);
            var x = b.permutationIndices;
            var k = b.expandDims;
            var w = undefined;
            if (Wie(x)) {
              w = r[y];
            } else {
              w = tCe({
                inputs: {
                  x: r[y]
                },
                backend: n,
                attrs: {
                  perm: x
                }
              });
              d.push(w);
            }
            var I = w.shape.slice();
            for (var N = 0; N < k.length; ++N) {
              I.splice(k[N], 0, 1);
            }
            if (!P$(w.shape, I)) {
              w = HEe({
                inputs: {
                  x: w
                },
                backend: n,
                attrs: {
                  shape: I
                }
              });
              d.push(w);
            }
            if (p === null) {
              p = w;
            } else {
              p = GEe({
                inputs: {
                  a: w,
                  b: p
                },
                backend: n
              });
              d.push(p);
            }
          }
        } catch (e) {
          g.e(e);
        } finally {
          g.f();
        }
        if (v < h - 1) {
          if (c[v] >= 0) {
            p = $Ee({
              inputs: {
                x: p
              },
              backend: n,
              attrs: {
                axis: c[v] - (i.length - f),
                keepDims: false
              }
            });
            d.push(p);
          }
          f--;
        }
      }
      for (var S = 0, T = d; S < T.length; S++) {
        var E = T[S];
        if (E !== p) {
          n.disposeIntermediateTensorInfo(E);
        }
      }
      return p;
    }
  };
  var gRe = MEe({
    opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
  });
  var yRe = {
    kernelName: I1,
    backendName: "webgl",
    kernelFunc: gRe
  };
  var bRe = {
    kernelName: N1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.dy;
      var a = t.y;
      var i = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new NEe("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", r.shape, a.shape) : new wEe("return (b >= 0.0) ? a : a * (b + 1.0);", r.shape, a.shape);
      return n.runWebGLProgram(i, [r, a], r.dtype);
    }
  };
  var xRe = LEe({
    opSnippet: "return float(a == b);",
    packedOpSnippet: "\n  return vec4(equal(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: rTe
  });
  var kRe = {
    kernelName: T1,
    backendName: "webgl",
    kernelFunc: xRe
  };
  var wRe = MEe({
    opSnippet: `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${xie};
  float a1 = ${kie};
  float a2 = ${wie};
  float a3 = ${Iie};
  float a4 = ${Nie};
  float a5 = ${Sie};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`
  });
  var IRe = {
    kernelName: S1,
    backendName: "webgl",
    kernelFunc: wRe
  };
  var NRe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return exp(x);\n",
    packedOpSnippet: "\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    cpuKernelImpl: aTe,
    dtype: "float32"
  });
  var SRe = {
    kernelName: E1,
    backendName: "webgl",
    kernelFunc: NRe
  };
  function TRe(e) {
    var t = e.inputs;
    var n = e.attrs;
    var r = e.backend;
    var a = n.dim;
    var i = t.input;
    var o = i.shape.length;
    var s = i.shape.slice();
    var u = a;
    if (a < 0) {
      F$(-(o + 1) <= a, function () {
        return `Axis must be in the interval [${-(o + 1)}, ${o}]`;
      });
      u = o + a + 1;
    }
    s.splice(u, 0, 1);
    return HEe({
      inputs: {
        x: i
      },
      backend: r,
      attrs: {
        shape: s
      }
    });
  }
  var ERe = {
    kernelName: C1,
    backendName: "webgl",
    kernelFunc: TRe
  };
  var CRe = "return exp(x) - 1.0;";
  var ARe = MEe({
    opSnippet: CRe,
    packedOpSnippet: CRe,
    cpuKernelImpl: iTe
  });
  var RRe = {
    kernelName: A1,
    backendName: "webgl",
    kernelFunc: ARe
  };
  var _Re = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["real", "imag"];
    var a = n[1];
    this.outputShape = n;
    var i;
    var o = r ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
    var s = r ? `${a}.0` : "1.0";
    if (t === "real") {
      i = "return real * expR - imag * expI;";
    } else {
      if (t !== "imag") {
        throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);
      }
      i = "return real * expI + imag * expR;";
    }
    this.userCode = `
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
  });
  function ORe(e, t, n) {
    var r = n.texData.get(e.dataId);
    var a = L$(e.shape);
    var i = e.shape[e.shape.length - 1];
    var o = HEe({
      inputs: {
        x: e
      },
      backend: n,
      attrs: {
        shape: [a / i, i]
      }
    });
    var s = o.shape;
    var u = new _Re("real", s, t);
    var c = new _Re("imag", s, t);
    var l = [{
      dataId: r.complexTensorInfos.real.dataId,
      dtype: r.complexTensorInfos.real.dtype,
      shape: s
    }, {
      dataId: r.complexTensorInfos.imag.dataId,
      dtype: r.complexTensorInfos.imag.dtype,
      shape: s
    }];
    var h = n.runWebGLProgram(u, l, "float32");
    var p = n.runWebGLProgram(c, l, "float32");
    var f = EEe({
      inputs: {
        real: h,
        imag: p
      },
      backend: n
    });
    n.disposeIntermediateTensorInfo(h);
    n.disposeIntermediateTensorInfo(p);
    var d = HEe({
      inputs: {
        x: f
      },
      backend: n,
      attrs: {
        shape: e.shape
      }
    });
    n.disposeIntermediateTensorInfo(o);
    n.disposeIntermediateTensorInfo(f);
    return d;
  }
  var FRe = {
    kernelName: R1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      return ORe(t.input, false, n);
    }
  };
  var DRe = p(function e(t, n) {
    l(this, e);
    this.outputShape = [];
    this.customUniforms = [{
      name: "value",
      type: "float"
    }];
    this.variableNames = ["x"];
    this.outputShape = t;
    this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  });
  function MRe(e) {
    var t = e.backend;
    var n = e.attrs;
    var r = n.shape;
    var a = n.value;
    var i = n.dtype;
    if ((i = i || n0(a)) === "string") {
      var o = K$(i, L$(r));
      o.fill(a);
      return t.makeTensorInfo(r, i, o);
    }
    var s = new DRe(r, a);
    var u = [[a]];
    return t.runWebGLProgram(s, [], i, u);
  }
  var LRe;
  var zRe = {
    kernelName: _1,
    backendName: "webgl",
    kernelFunc: MRe
  };
  var PRe = p(function e(t) {
    l(this, e);
    this.variableNames = ["Image"];
    this.outputShape = [];
    var n = t[2];
    this.outputShape = t;
    this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  });
  var BRe = {
    kernelName: O1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.image;
      var a = n;
      var i = new PRe(r.shape);
      return a.runWebGLProgram(i, [r], r.dtype);
    }
  };
  var WRe = "return floor(x);";
  var URe = MEe({
    opSnippet: WRe,
    packedOpSnippet: WRe,
    cpuKernelImpl: oTe
  });
  var VRe = {
    kernelName: F1,
    backendName: "webgl",
    kernelFunc: URe
  };
  var GRe = LEe({
    opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
    packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
    dtype: "int32"
  });
  var jRe = {
    kernelName: D1,
    backendName: "webgl",
    kernelFunc: GRe
  };
  var HRe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    var n = PNe();
    var r = S(t, 2);
    var a = r[0];
    var i = r[1];
    this.outputShape = t;
    this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${a}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
  });
  var qRe = p(function e(t) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    var n = PNe();
    var r = S(t, 2);
    var a = r[0];
    var i = r[1];
    this.outputShape = t;
    this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${a}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `;
  });
  var KRe = {
    kernelName: O3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.pixels;
      var i = r.numChannels;
      var o = typeof HTMLVideoElement != "undefined" && a instanceof HTMLVideoElement;
      var s = typeof HTMLImageElement != "undefined" && a instanceof HTMLImageElement;
      var u = S(o ? [a.videoWidth, a.videoHeight] : [a.width, a.height], 2);
      var c = u[0];
      var l = u[1];
      var h = [l, c];
      var p = [l, c, i];
      if (s || o) {
        var f = k0().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
        if (LRe == null || f !== XRe) {
          XRe = f;
          LRe = document.createElement("canvas").getContext("2d", {
            willReadFrequently: XRe
          });
        }
        LRe.canvas.width = c;
        LRe.canvas.height = l;
        LRe.drawImage(a, 0, 0, c, l);
        a = LRe.canvas;
      }
      var d = n.makeTensorInfo(h, "int32");
      n.texData.get(d.dataId).usage = MIe.PIXELS;
      n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), a);
      var v = k0().getBool("WEBGL_PACK") ? new qRe(p) : new HRe(p);
      var m = n.runWebGLProgram(v, [d], "int32");
      n.disposeData(d.dataId);
      return m;
    }
  };
  var XRe = k0().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  var YRe = {
    kernelName: M3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = e.attrs;
      var i = n.x;
      var o = n.filter;
      var s = n.bias;
      var u = n.preluActivationWeights;
      var c = a.strides;
      var l = a.pad;
      var h = a.dataFormat;
      var p = a.dilations;
      var f = a.dimRoundingMode;
      var d = a.activation;
      var v = a.leakyreluAlpha;
      var m = q8(h);
      var g = D8(i.shape, o.shape, c, p, l, f, false, m);
      var y = [];
      var b = s != null;
      var x = u != null;
      var k = d === "leakyrelu";
      function w() {
        var e = [i, o];
        function t(e, t) {
          if (t === "NCHW" && e.shape.length === 1 && e.shape[0] !== 1) {
            var n = HEe({
              inputs: {
                x: e
              },
              backend: r,
              attrs: {
                shape: [e.shape[0], 1, 1]
              }
            });
            y.push(n);
            return n;
          }
          return e;
        }
        if (b) {
          e.push(t(s, h));
        }
        if (x) {
          e.push(t(u, h));
        }
        if (k) {
          var n = r.makeTensorInfo([], "float32", M4(v, "float32"));
          e.push(n);
          y.push(n);
        }
        return e;
      }
      if (g.filterHeight !== 1 || g.filterWidth !== 1 || g.dilationHeight !== 1 || g.dilationWidth !== 1 || g.strideHeight !== 1 || g.strideWidth !== 1 || g.padInfo.type !== "SAME" && g.padInfo.type !== "VALID") {
        if (g.strideWidth <= 2 && m === "channelsLast" && k0().getBool("WEBGL_EXP_CONV")) {
          var I = d ? zEe(d, true) : null;
          var N = new EAe(g, b, I, x, k);
          var S = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]];
          var T = w();
          t = r.runWebGLProgram(N, T, "float32", S);
        } else if (k0().getBool("WEBGL_CONV_IM2COL")) {
          t = _Ae({
            x: i,
            filter: o,
            convInfo: g,
            backend: r,
            bias: s,
            activation: d,
            preluActivationWeights: u,
            leakyreluAlpha: v
          });
        } else {
          var E = d ? zEe(d, false) : null;
          var C = new SAe(g, b, E, x, k);
          var A = w();
          t = r.runWebGLProgram(C, A, "float32");
        }
      } else {
        t = RAe({
          x: i,
          filter: o,
          convInfo: g,
          backend: r,
          bias: s,
          activation: d,
          preluActivationWeights: u,
          leakyreluAlpha: v
        });
      }
      var R = HEe({
        inputs: {
          x: t
        },
        backend: r,
        attrs: {
          shape: g.outShape
        }
      });
      y.push(t);
      y.forEach(function (e) {
        return r.disposeIntermediateTensorInfo(e);
      });
      return R;
    }
  };
  var JRe = {
    kernelName: L3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.filter;
      var o = t.bias;
      var s = t.preluActivationWeights;
      var u = r.strides;
      var c = r.pad;
      var l = r.dilations;
      var h = r.dimRoundingMode;
      var p = r.activation;
      var f = r.leakyreluAlpha;
      var d = [];
      var v = l;
      if (v == null) {
        v = [1, 1];
      }
      F$(j8(u, v), function () {
        return `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${v}'`;
      });
      var m;
      var g = D8(a.shape, i.shape, u, v, c, h, true);
      var y = k0().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels == 1;
      var b = p ? zEe(p, y) : null;
      var x = [a, i];
      var k = o != null;
      var w = s != null;
      var I = p === "leakyrelu";
      if (k) {
        x.push(o);
      }
      if (w) {
        x.push(s);
      }
      if (I) {
        var N = n.makeTensorInfo([], "float32", M4(f, "float32"));
        x.push(N);
        d.push(N);
      }
      m = y ? new oRe(g, k, b, w, I) : new iRe(g, k, b, w, I);
      var S = [[g.padInfo.top, g.padInfo.left], [g.strideHeight, g.strideWidth], [g.dilationHeight, g.dilationWidth], [g.inHeight, g.inWidth]];
      var T = n.runWebGLProgram(m, x, "float32", S);
      d.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return T;
    }
  };
  var ZRe = p(function e(t, n, r, a) {
    l(this, e);
    this.sliceDim = t;
    this.strides = n;
    this.paramsShape = a;
    this.variableNames = ["x", "indices"];
    this.outputShape = r;
    var i = cSe(r.length);
    var o = "\n    int index;";
    for (var s = 0; s < this.sliceDim; s++) {
      o += `
          index = round(getIndices(coords[0], ${s}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[s]};
          flattenIndex += index * ${this.strides[s]};`;
    }
    this.userCode = `
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
  });
  var QRe = {
    kernelName: z1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.params;
      var a = t.indices;
      var i = a.shape;
      var o = i[i.length - 1];
      var s = L$(r.shape);
      var u = S(Mae(r, a), 4);
      var c = u[0];
      var l = u[1];
      var h = u[2];
      var p = u[3];
      var f = HEe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: [l, o]
        }
      });
      var d = HEe({
        inputs: {
          x: r
        },
        backend: n,
        attrs: {
          shape: [L$(r.shape) / h, h]
        }
      });
      if (n.shouldExecuteOnCPU([r, a]) || r.dtype === "string") {
        var v = n.readSync(a.dataId);
        var m = n.bufferSync(r);
        var g = sTe(v, m, r.dtype, l, o, h, p, r.shape, s);
        return n.makeTensorInfo(c, r.dtype, g.values);
      }
      var y = new ZRe(o, p, [l, h], r.shape);
      var b = n.runWebGLProgram(y, [d, f], d.dtype);
      var x = HEe({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: c
        }
      });
      n.disposeIntermediateTensorInfo(f);
      n.disposeIntermediateTensorInfo(d);
      n.disposeIntermediateTensorInfo(b);
      return x;
    }
  };
  var $Re = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A", "indices"];
    this.outputShape = n;
    this.rank = n.length;
    var r = cSe(this.rank);
    var a = function (e, t) {
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      var r = [];
      for (var a = 0; a < e.length; a++) {
        if (a === 2) {
          r.push("index");
        } else {
          r.push(`${n[a]}`);
        }
      }
      return r.join();
    }(t);
    this.userCode = `
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${a}));
      }
    `;
  });
  function e_e(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = t.indices;
    var o = r.axis;
    var s = r.batchDims;
    var u = j$(o, a.shape)[0];
    if (k0().get("DEBUG")) {
      for (var c = n.readSync(i.dataId), l = a.shape[u], h = function () {
          var e = c[p];
          F$(e <= l - 1 && e >= 0, function () {
            return `GatherV2: the index value ${e} is not in [0, ${l - 1}]`;
          });
        }, p = 0; p < c.length; ++p) {
        h();
      }
    }
    var f = roe(a, i, u, s);
    var d = L$(i.shape);
    var v = [];
    var m = HEe({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        shape: [f.batchSize, f.outerSize, f.dimSize, f.sliceSize]
      }
    });
    var g = HEe({
      inputs: {
        x: i
      },
      backend: n,
      attrs: {
        shape: [f.batchSize, d / f.batchSize]
      }
    });
    v.push(m);
    v.push(g);
    var y = [f.batchSize, f.outerSize, d / f.batchSize, f.sliceSize];
    if (n.shouldExecuteOnCPU([a, i]) || a.dtype === "string") {
      var b = n.bufferSync(g);
      var x = n.bufferSync(m);
      var k = uTe(x, b, y);
      v.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return n.makeTensorInfo(f.outputShape, k.dtype, k.values);
    }
    var w = new $Re(m.shape, y);
    var I = n.runWebGLProgram(w, [m, g], m.dtype);
    v.push(I);
    var N = HEe({
      inputs: {
        x: I
      },
      backend: n,
      attrs: {
        shape: f.outputShape
      }
    });
    v.forEach(function (e) {
      return n.disposeIntermediateTensorInfo(e);
    });
    return N;
  }
  var t_e = {
    kernelName: L1,
    backendName: "webgl",
    kernelFunc: e_e
  };
  var n_e = LEe({
    opSnippet: "return float(a > b);",
    packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
    cpuKernelImpl: cTe,
    dtype: "bool"
  });
  var r_e = {
    kernelName: P1,
    backendName: "webgl",
    kernelFunc: n_e
  };
  var a_e = LEe({
    opSnippet: "return float(a >= b);",
    packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
    dtype: "bool",
    cpuKernelImpl: lTe
  });
  var i_e = {
    kernelName: B1,
    backendName: "webgl",
    kernelFunc: a_e
  };
  var o_e = {
    kernelName: U1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      return ORe(t.input, true, n);
    }
  };
  var s_e = MEe({
    opSnippet: "return float(!isnan(x) && !isinf(x));",
    dtype: "bool"
  });
  var u_e = {
    kernelName: G1,
    backendName: "webgl",
    kernelFunc: s_e
  };
  var c_e = MEe({
    opSnippet: "return float(isinf(x));",
    dtype: "bool"
  });
  var l_e = {
    kernelName: j1,
    backendName: "webgl",
    kernelFunc: c_e
  };
  var h_e = MEe({
    opSnippet: "return float(isnan(x));",
    dtype: "bool"
  });
  var p_e = {
    kernelName: H1,
    backendName: "webgl",
    kernelFunc: h_e
  };
  var f_e = LEe({
    opSnippet: "return float(a < b);",
    packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
    cpuKernelImpl: hTe,
    dtype: "bool"
  });
  var d_e = {
    kernelName: K1,
    backendName: "webgl",
    kernelFunc: f_e
  };
  var v_e = LEe({
    opSnippet: "return float(a <= b);",
    packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
    cpuKernelImpl: pTe,
    dtype: "bool"
  });
  var m_e = {
    kernelName: X1,
    backendName: "webgl",
    kernelFunc: v_e
  };
  var g_e = {
    kernelName: Y1,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.backend;
      var n = e.attrs;
      var r = n.start;
      var a = n.stop;
      var i = n.num;
      var o = fTe(r, a, i);
      return t.makeTensorInfo([o.length], "float32", o);
    }
  };
  var y_e = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",
    packedOpSnippet: "\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",
    cpuKernelImpl: dTe
  });
  var b_e = {
    kernelName: J1,
    backendName: "webgl",
    kernelFunc: y_e
  };
  var x_e = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return log(1.0 + x);\n"
  });
  var k_e = {
    kernelName: Z1,
    backendName: "webgl",
    kernelFunc: x_e
  };
  var w_e = LEe({
    opSnippet: "return float(a >= 1.0 && b >= 1.0);",
    packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
    dtype: "bool"
  });
  var I_e = {
    kernelName: Q1,
    backendName: "webgl",
    kernelFunc: w_e
  };
  var N_e = MEe({
    opSnippet: "return float(!(x >= 1.0));"
  });
  var S_e = {
    kernelName: $1,
    backendName: "webgl",
    kernelFunc: N_e
  };
  var T_e = LEe({
    opSnippet: "return float(a >= 1.0 || b >= 1.0);",
    packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
    dtype: "bool"
  });
  var E_e = {
    kernelName: e2,
    backendName: "webgl",
    kernelFunc: T_e
  };
  var C_e = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["x"];
    this.outputShape = [];
    var o;
    var s = n;
    var u = t[3] - 1;
    this.outputShape = t;
    var c = `float(${r}) + float(${a}) * sum`;
    o = i === 0.5 ? `inversesqrt(${c})` : i === 1 ? `1.0/(${c})` : `exp(log(${c}) * float(-${i}));`;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${u}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `;
  });
  var A_e = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["x"];
    this.outputShape = [];
    this.packedInputs = true;
    this.packedOutput = true;
    var o;
    var s = n;
    var u = t[3] - 1;
    this.outputShape = t;
    var c = `float(${r}) + float(${a}) * sum`;
    o = i === 0.5 ? `inversesqrt(${c})` : i === 1 ? `1.0/(${c})` : `exp(log(${c}) * float(-${i}));`;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${u}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `;
  });
  var R_e = {
    kernelName: n2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.depthRadius;
      var o = r.bias;
      var s = r.alpha;
      var u = r.beta;
      var c = k0().getBool("WEBGL_PACK_NORMALIZATION") ? new A_e(a.shape, i, o, s, u) : new C_e(a.shape, i, o, s, u);
      return n.runWebGLProgram(c, [a], a.dtype);
    }
  };
  var __e = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["inputImage", "outputImage", "dy"];
    this.outputShape = [];
    this.outputShape = t;
    this.depth = t[3];
    this.depthRadius = n;
    this.bias = r;
    this.alpha = a;
    this.beta = i;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${a}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${a})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
  });
  var O_e = {
    kernelName: r2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.y;
      var o = t.dy;
      var s = r.depthRadius;
      var u = r.bias;
      var c = r.alpha;
      var l = r.beta;
      var h = new __e(a.shape, s, u, c, l);
      return n.runWebGLProgram(h, [a, i, o], a.dtype);
    }
  };
  function F_e(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.reductionIndices;
    var o = r.keepDims;
    var s = a.shape.length;
    var u = j$(i, a.shape);
    var c = u;
    var l = $7(c, s);
    var h = l != null;
    var p = n.shouldExecuteOnCPU([a]);
    var f = a;
    if (h) {
      if (p) {
        var d = n.texData.get(f.dataId).values;
        for (var v = new Array(s), m = 0; m < v.length; m++) {
          v[m] = a.shape[l[m]];
        }
        var g = GTe(d, a.shape, a.dtype, l, v);
        f = n.makeTensorInfo(v, a.dtype);
        n.texData.get(f.dataId).values = g;
      } else {
        f = QEe(a, l, n);
      }
      c = t9(c.length, s);
    }
    Q7("max", c, s);
    var y;
    var b = S(J7(f.shape, c), 2);
    var x = b[0];
    var k = b[1];
    var w = x;
    if (o) {
      w = Z7(x, u);
    }
    if (p) {
      var I = n.texData.get(f.dataId).values;
      var N = vTe(I, L$(k), w, a.dtype);
      y = n.makeTensorInfo(w, a.dtype);
      n.texData.get(y.dataId).values = N;
    } else {
      y = function (e, t, n, r) {
        var a = L$(t);
        var i = HEe({
          inputs: {
            x: e
          },
          attrs: {
            shape: [L$(e.shape) / a, a]
          },
          backend: r
        });
        var o = YEe(i, e.dtype, "max", r);
        var s = HEe({
          inputs: {
            x: o
          },
          attrs: {
            shape: n
          },
          backend: r
        });
        r.disposeIntermediateTensorInfo(i);
        r.disposeIntermediateTensorInfo(o);
        return s;
      }(f, k, w, n);
    }
    if (h) {
      n.disposeIntermediateTensorInfo(f);
    }
    return y;
  }
  var D_e = {
    kernelName: a2,
    backendName: "webgl",
    kernelFunc: F_e
  };
  var M_e = LEe({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: mTe
  });
  var L_e = {
    kernelName: i2,
    backendName: "webgl",
    kernelFunc: M_e
  };
  var z_e = {
    kernelName: o2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      MNe(a, "maxPool");
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dimRoundingMode;
      F$(j8(o, 1), function () {
        return `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${1}'`;
      });
      var c = O8(a.shape, i, o, 1, s, u);
      if (c.filterWidth === 1 && c.filterHeight === 1 && P$(c.inShape, c.outShape)) {
        return SEe({
          inputs: {
            x: a
          },
          backend: n
        });
      }
      var l = new LCe(c, "max", false);
      return n.runWebGLProgram(l, [a], a.dtype);
    }
  };
  var P_e = {
    kernelName: u2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.filterSize;
      var o = r.strides;
      var s = r.pad;
      var u = r.dataFormat;
      var c = r.dimRoundingMode;
      var l = F8(a.shape, i, o, [1, 1, 1], s, c, u);
      var h = new zCe(l, "max", false);
      return n.runWebGLProgram(h, [a], a.dtype);
    }
  };
  var B_e = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy", "maxPos"];
    this.outputShape = t.inShape;
    var n = t.strideHeight;
    var r = t.strideWidth;
    var a = t.dilationHeight;
    var i = t.effectiveFilterHeight;
    var o = t.effectiveFilterWidth;
    var s = i - 1 - t.padInfo.top;
    var u = o - 1 - t.padInfo.left;
    var c = i * o - 1;
    this.userCode = `
      const ivec2 pads = ivec2(${s}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var W_e = p(function e(t) {
    l(this, e);
    this.variableNames = ["dy", "maxPos"];
    this.outputShape = t.inShape;
    var n = t.strideDepth;
    var r = t.strideHeight;
    var a = t.strideWidth;
    var i = t.dilationDepth;
    var o = t.dilationHeight;
    var s = t.dilationWidth;
    var u = t.effectiveFilterDepth;
    var c = t.effectiveFilterHeight;
    var h = t.effectiveFilterWidth;
    var p = u - 1 - t.padInfo.front;
    var f = c - 1 - t.padInfo.top;
    var d = h - 1 - t.padInfo.left;
    var v = u * c * h - 1;
    this.userCode = `
      const ivec3 pads = ivec3(${p}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${s}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${v} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  });
  var U_e = {
    kernelName: c2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = r.filterSize;
      var s = r.strides;
      var u = r.pad;
      var c = r.dimRoundingMode;
      var l = F8(i.shape, o, s, [1, 1, 1], u, c);
      var h = new zCe(l, "max", true);
      var p = n.runWebGLProgram(h, [i], i.dtype);
      var f = new W_e(l);
      var d = n.runWebGLProgram(f, [a, p], i.dtype);
      n.disposeIntermediateTensorInfo(p);
      return d;
    }
  };
  var V_e = {
    kernelName: s2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.dy;
      var i = t.input;
      var o = i;
      MNe([i, t.output], "maxPoolGrad");
      var s = r.filterSize;
      var u = r.strides;
      var c = r.pad;
      var l = r.dimRoundingMode;
      var h = O8(o.shape, s, u, 1, c, l);
      var p = new LCe(h, "max", true);
      var f = n.runWebGLProgram(p, [o], o.dtype);
      var d = new B_e(h);
      var v = n.runWebGLProgram(d, [a, f], o.dtype);
      n.disposeIntermediateTensorInfo(f);
      return v;
    }
  };
  var G_e = {
    kernelName: l2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = t.x;
      var i = n.filterSize;
      var o = n.strides;
      var s = n.pad;
      var u = n.includeBatchInIndex;
      var c = r;
      F$(a.shape.length === 4, function () {
        return `Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`;
      });
      var l = [1, 1];
      F$(j8(o, l), function () {
        return `Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`;
      });
      var h = O8(a.shape, i, o, l, s);
      var p = function (e, t, n, r) {
        var a = new LCe(n, "max", false);
        var i = r.runWebGLProgram(a, [e], "float32");
        a = new LCe(n, "max", true, true, t);
        return [i, r.runWebGLProgram(a, [e], "float32")];
      }(a, u, h, c);
      var f = S(p, 2);
      return [f[0], f[1]];
    }
  };
  var j_e = {
    kernelName: h2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = t.x;
      var i = n.keepDims;
      var o = n.axis;
      var s = r;
      var u = a.shape.length;
      var c = j$(o, a.shape);
      var l = c;
      var h = $7(l, u);
      var p = h != null;
      var f = s.shouldExecuteOnCPU([a]);
      var d = [];
      var v = a;
      if (p) {
        if (f) {
          var m = s.texData.get(v.dataId).values;
          for (var g = new Array(u), y = 0; y < g.length; y++) {
            g[y] = a.shape[h[y]];
          }
          var b = GTe(m, a.shape, a.dtype, h, g);
          v = s.makeTensorInfo(g, a.dtype);
          s.texData.get(v.dataId).values = b;
        } else {
          v = QEe(a, h, s);
        }
        d.push(v);
        l = t9(l.length, u);
      }
      Q7("sum", l, u);
      var x = S(J7(v.shape, l), 2);
      var k = x[0];
      var w = x[1];
      var I = k;
      if (i) {
        I = Z7(k, c);
      }
      var N = function (e, t, n, r) {
        var a = L$(t);
        var i = HEe({
          inputs: {
            x: e
          },
          attrs: {
            shape: [L$(e.shape) / a, a]
          },
          backend: r
        });
        var o = YEe(i, "float32", "mean", r);
        var s = HEe({
          inputs: {
            x: o
          },
          attrs: {
            shape: n
          },
          backend: r
        });
        r.disposeIntermediateTensorInfo(i);
        r.disposeIntermediateTensorInfo(o);
        return s;
      }(v, w, I, s);
      for (var T = 0, E = d; T < E.length; T++) {
        var C = E[T];
        s.disposeIntermediateTensorInfo(C);
      }
      return N;
    }
  };
  var H_e = {
    kernelName: p2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.axis;
      var o = r.keepDims;
      var s = a.shape.length;
      var u = j$(i, a.shape);
      var c = u;
      var l = $7(c, s);
      var h = a;
      if (l != null) {
        h = tCe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: l
          }
        });
        c = t9(c.length, a.shape.length);
      }
      Q7("min", c, s);
      var p;
      var f = S(J7(h.shape, c), 2);
      var d = f[0];
      var v = HEe({
        inputs: {
          x: h
        },
        backend: n,
        attrs: {
          shape: [-1, L$(f[1])]
        }
      });
      var m = YEe(v, v.dtype, "min", n);
      p = HEe(o ? {
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          shape: Z7(d, u)
        }
      } : {
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          shape: d
        }
      });
      n.disposeIntermediateTensorInfo(v);
      n.disposeIntermediateTensorInfo(m);
      if (l != null) {
        n.disposeIntermediateTensorInfo(h);
      }
      return p;
    }
  };
  var q_e = LEe({
    opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
    packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",
    cpuKernelImpl: gTe
  });
  var K_e = {
    kernelName: f2,
    backendName: "webgl",
    kernelFunc: q_e
  };
  var X_e = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["x"];
    this.outputShape = n.map(function (e, n) {
      return e[0] + t[n] + e[1];
    });
    var a = t.length;
    var i = cSe(a);
    var o = n.map(function (e) {
      return e[0];
    }).join(",");
    var s = n.map(function (e, n) {
      return e[0] + t[n];
    }).join(",");
    var u = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, a);
    var c = r === "reflect" ? 0 : 1;
    this.userCode = a !== 1 ? `
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${s});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${a}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${u}));
      }
    ` : `
        int start = ${o};
        int end = ${s};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;
  });
  var Y_e = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = n.map(function (e, n) {
      return e[0] + t[n] + e[1];
    });
    var a = t.length;
    var i = cSe(a);
    var o = n.map(function (e) {
      return e[0];
    }).join(",");
    var s = n.map(function (e, n) {
      return e[0] + t[n];
    }).join(",");
    var u = qTe("rc", a);
    var c = qTe("source", a);
    var h = `${u[a - 1]} < ${this.outputShape[a - 1]}`;
    var p = a === 1 ? "source" : `vec2(${c.slice(-2).join()})`;
    var f = r === "reflect" ? 0 : 1;
    var d = "";
    if (a === 1) {
      var v = `
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;
      d = `
        ${i} rc = outputLoc;
        ${v}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${u[a - 1]} += 1;
        if(${h}) {
          ${v}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
      `;
    } else {
      var m = `
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;
      d = `
        ${i} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${u[a - 1]} += 1;
        if(${h}) {
          ${m}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
        rc = outputLoc;
        ${u[a - 2]} += 1;
        if(${u[a - 2]} < ${this.outputShape[a - 2]}) {
          ${m}
          result[2] = getChannel(getX(${c.join()}), ${p});
          ${u[a - 1]} += 1;
          if(${h}) {
            ${m}
            result[3] = getChannel(getX(${c.join()}), ${p});
          }
        }
      `;
    }
    this.userCode = `
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${s});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `;
  });
  var J_e = {
    kernelName: d2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.paddings;
      var o = r.mode;
      var s = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Y_e(a.shape, i, o) : new X_e(a.shape, i, o);
      return n.runWebGLProgram(s, [a], a.dtype);
    }
  };
  var Z_e = LEe({
    opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
    packedOpSnippet: "\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"
  });
  var Q_e = {
    kernelName: v2,
    backendName: "webgl",
    kernelFunc: Z_e
  };
  var $_e = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["probs"];
    this.customUniforms = [{
      name: "seed",
      type: "float"
    }];
    this.outputShape = [t, r];
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n - 1}));
      }
    `;
  });
  var eOe = LEe({
    opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
    packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
    checkOutOfBounds: true
  });
  var tOe = {
    kernelName: k1,
    backendName: "webgl",
    kernelFunc: eOe
  };
  var nOe = "return a - b;";
  var rOe = LEe({
    opSnippet: nOe,
    packedOpSnippet: nOe,
    supportsComplex: true,
    cpuKernelImpl: WTe
  });
  var aOe = {
    kernelName: x3,
    backendName: "webgl",
    kernelFunc: rOe
  };
  function iOe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.logits;
    var i = j$([r.dim], a.shape);
    var o = F_e({
      inputs: {
        x: a
      },
      backend: n,
      attrs: {
        reductionIndices: i,
        keepDims: false
      }
    });
    var s = Z7(o.shape, i);
    var u = HEe({
      inputs: {
        x: o
      },
      backend: n,
      attrs: {
        shape: s
      }
    });
    var c = rOe({
      inputs: {
        a: a,
        b: u
      },
      backend: n
    });
    var l = NRe({
      inputs: {
        x: c
      },
      backend: n
    });
    var h = $Ee({
      inputs: {
        x: l
      },
      backend: n,
      attrs: {
        axis: i,
        keepDims: false
      }
    });
    var p = HEe({
      inputs: {
        x: h
      },
      backend: n,
      attrs: {
        shape: s
      }
    });
    var f = eOe({
      inputs: {
        a: l,
        b: p
      },
      backend: n
    });
    n.disposeIntermediateTensorInfo(o);
    n.disposeIntermediateTensorInfo(u);
    n.disposeIntermediateTensorInfo(c);
    n.disposeIntermediateTensorInfo(l);
    n.disposeIntermediateTensorInfo(h);
    n.disposeIntermediateTensorInfo(p);
    return f;
  }
  var oOe = {
    kernelName: s3,
    backendName: "webgl",
    kernelFunc: iOe
  };
  var sOe = {
    kernelName: m2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.logits;
      var i = r.numSamples;
      var o = r.seed;
      var s = r.normalized;
      var u = s ? a : iOe({
        inputs: {
          logits: a
        },
        backend: n,
        attrs: {
          dim: a.shape.length - 1
        }
      });
      var c = u.shape[0];
      var l = u.shape[1];
      var h = new $_e(c, l, i);
      var p = [[o]];
      var f = n.runWebGLProgram(h, [u], "int32", p);
      if (!s) {
        n.disposeIntermediateTensorInfo(u);
      }
      return f;
    }
  };
  var uOe = {
    kernelName: y2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = n.x;
      if (r.shouldExecuteOnCPU([a])) {
        var i = r.texData.get(a.dataId);
        var o = S(bTe(i.values, a.shape, a.dtype), 2);
        var s = o[0];
        var u = o[1];
        return r.makeTensorInfo(u, a.dtype, s);
      }
      t = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new fEe(a.shape, "\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n") : new $Te(a.shape, "if (isnan(x)) return x;\n  return -x;\n");
      return r.runWebGLProgram(t, [a], a.dtype);
    }
  };
  var cOe = qne;
  var lOe = {
    kernelName: x2,
    backendName: "webgl",
    kernelFunc: function (e) {
      z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.boxes;
      var i = t.scores;
      var o = r.maxOutputSize;
      var s = r.iouThreshold;
      var u = r.scoreThreshold;
      var c = n.readSync(a.dataId);
      var l = n.readSync(i.dataId);
      var h = cOe(c, l, o, s, u).selectedIndices;
      return n.makeTensorInfo([h.length], "int32", new Int32Array(h));
    }
  };
  var hOe = Kne;
  var pOe = {
    kernelName: k2,
    backendName: "webgl",
    kernelFunc: function (e) {
      z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.boxes;
      var i = t.scores;
      var o = r.maxOutputSize;
      var s = r.iouThreshold;
      var u = r.scoreThreshold;
      var c = r.padToMaxOutputSize;
      var l = n.readSync(a.dataId);
      var h = n.readSync(i.dataId);
      var p = hOe(l, h, o, s, u, c);
      var f = p.selectedIndices;
      var d = p.validOutputs;
      return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([], "int32", new Int32Array([d]))];
    }
  };
  var fOe = Xne;
  var dOe = {
    kernelName: w2,
    backendName: "webgl",
    kernelFunc: function (e) {
      z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.boxes;
      var i = t.scores;
      var o = r.maxOutputSize;
      var s = r.iouThreshold;
      var u = r.scoreThreshold;
      var c = r.softNmsSigma;
      var l = n.readSync(a.dataId);
      var h = n.readSync(i.dataId);
      var p = fOe(l, h, o, s, u, c);
      var f = p.selectedIndices;
      var d = p.selectedScores;
      return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([d.length], "float32", new Float32Array(d))];
    }
  };
  var vOe = p(function e(t, n, r, a) {
    l(this, e);
    this.variableNames = ["indices"];
    this.outputShape = [t, n];
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${a}), float(${r}),
                      float(index == coords.y)));
      }
    `;
  });
  var mOe = {
    kernelName: N2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.indices;
      var i = r.dtype;
      var o = r.depth;
      var s = r.onValue;
      var u = r.offValue;
      var c = L$(a.shape);
      var l = new vOe(c, o, s, u);
      var h = HEe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: [c]
        }
      });
      var p = n.runWebGLProgram(l, [h], i);
      n.disposeIntermediateTensorInfo(h);
      var f = HEe({
        inputs: {
          x: p
        },
        backend: n,
        attrs: {
          shape: [].concat(T(a.shape), [o])
        }
      });
      n.disposeIntermediateTensorInfo(p);
      return f;
    }
  };
  function gOe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = t.x;
    if (r.dtype === "complex64") {
      var a = iAe({
        inputs: {
          input: r
        },
        backend: n
      });
      var i = gOe({
        inputs: {
          x: a
        },
        backend: n
      });
      var o = xAe({
        inputs: {
          input: r
        },
        backend: n
      });
      var s = gOe({
        inputs: {
          x: o
        },
        backend: n
      });
      var u = EEe({
        inputs: {
          real: i,
          imag: s
        },
        backend: n
      });
      n.disposeIntermediateTensorInfo(a);
      n.disposeIntermediateTensorInfo(i);
      n.disposeIntermediateTensorInfo(o);
      n.disposeIntermediateTensorInfo(s);
      return u;
    }
    return MRe({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: r.dtype === "string" ? "" : 0
      },
      backend: n
    });
  }
  var yOe = {
    kernelName: R3,
    backendName: "webgl",
    kernelFunc: gOe
  };
  var bOe = {
    kernelName: I2,
    backendName: "webgl",
    kernelFunc: function e(t) {
      var n = t.inputs;
      var r = t.backend;
      var a = n.x;
      if (a.dtype === "string") {
        throw new Error("onesLike is not supported under string dtype");
      }
      if (a.dtype === "complex64") {
        var i = iAe({
          inputs: {
            input: a
          },
          backend: r
        });
        var o = e({
          inputs: {
            x: i
          },
          backend: r
        });
        var s = xAe({
          inputs: {
            input: a
          },
          backend: r
        });
        var u = gOe({
          inputs: {
            x: s
          },
          backend: r
        });
        var c = EEe({
          inputs: {
            real: o,
            imag: u
          },
          backend: r
        });
        r.disposeIntermediateTensorInfo(i);
        r.disposeIntermediateTensorInfo(o);
        r.disposeIntermediateTensorInfo(s);
        r.disposeIntermediateTensorInfo(u);
        return c;
      }
      return MRe({
        attrs: {
          shape: a.shape,
          dtype: a.dtype,
          value: 1
        },
        backend: r
      });
    }
  };
  var xOe = {
    kernelName: S2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs.axis;
      if (t.length === 1) {
        return TRe({
          inputs: {
            input: t[0]
          },
          backend: n,
          attrs: {
            dim: r
          }
        });
      }
      var a = t[0].shape;
      var i = t[0].dtype;
      t.forEach(function (e) {
        D$(a, e.shape, "All tensors passed to stack must have matching shapes");
        F$(i === e.dtype, function () {
          return "All tensors passed to stack must have matching dtypes";
        });
      });
      var o = [];
      var s = IAe({
        inputs: t.map(function (e) {
          var t = TRe({
            inputs: {
              input: e
            },
            backend: n,
            attrs: {
              dim: r
            }
          });
          o.push(t);
          return t;
        }),
        backend: n,
        attrs: {
          axis: r
        }
      });
      o.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return s;
    }
  };
  var kOe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["x"];
    this.customUniforms = [{
      name: "value",
      type: "float"
    }];
    this.outputShape = n.map(function (e, n) {
      return e[0] + t[n] + e[1];
    });
    var a = t.length;
    var i = cSe(a);
    var o = n.map(function (e) {
      return e[0];
    }).join(",");
    var s = n.map(function (e, n) {
      return e[0] + t[n];
    }).join(",");
    var u = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, a);
    this.userCode = a !== 1 ? `
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${s});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    ` : `
        int start = ${o};
        int end = ${s};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
  });
  var wOe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{
      name: "value",
      type: "float"
    }];
    this.outputShape = n.map(function (e, n) {
      return e[0] + t[n] + e[1];
    });
    var a = t.length;
    var i = cSe(a);
    var o = n.map(function (e) {
      return e[0];
    }).join(",");
    var s = n.map(function (e, n) {
      return e[0] + t[n];
    }).join(",");
    var u = qTe("rc", a);
    var c = qTe("source", a);
    var h = `${u[a - 1]} < ${this.outputShape[a - 1]}`;
    var p = a === 1 ? "source" : `vec2(${c.slice(-2).join()})`;
    var f = [`${i} rc = outputLoc;`, `${u[a - 1]} += 1;
       if(${h}) {
      `, a === 1 ? "" : `}
       rc = outputLoc;
       ${u[a - 2]} += 1;
       if(${u[a - 2]} < ${this.outputShape[a - 2]}) {`, a === 1 ? "" : `  ${u[a - 1]} += 1;
         if(${h}) {`];
    var d = a === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    var v = "";
    for (var m = 0, g = a === 1 ? 2 : 4; m < g; m++) {
      v += `
        ${f[m]}
        if (${d}) {
          result[${m}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${p});
        }
      `;
    }
    v += a === 1 ? "} " : "}}";
    this.userCode = `
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${s});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${v}
        setOutput(result);
      }
    `;
  });
  function IOe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.paddings;
    var o = r.constantValue;
    if (L$(a.shape) === 0) {
      var s = i.map(function (e, t) {
        return e[0] + a.shape[t] + e[1];
      });
      return MRe({
        backend: n,
        attrs: {
          shape: s,
          value: o,
          dtype: a.dtype
        }
      });
    }
    var u = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new wOe(a.shape, i, o) : new kOe(a.shape, i, o);
    var c = [[o]];
    return n.runWebGLProgram(u, [a], a.dtype, c);
  }
  var NOe = {
    kernelName: T2,
    backendName: "webgl",
    kernelFunc: IOe
  };
  var SOe = LEe({
    opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
    packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"
  });
  var TOe = {
    kernelName: E2,
    backendName: "webgl",
    kernelFunc: SOe
  };
  var EOe = {
    kernelName: A2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = e.attrs;
      var i = n.x;
      var o = a.axis;
      var s = a.keepDims;
      var u = i.shape.length;
      var c = [];
      var l = j$(o, i.shape);
      var h = l;
      var p = $7(h, u);
      var f = i;
      if (p != null) {
        f = tCe({
          inputs: {
            x: i
          },
          backend: r,
          attrs: {
            perm: p
          }
        });
        h = t9(h.length, u);
        c.push(f);
      }
      Q7("prod", h, u);
      if (r.shouldExecuteOnCPU([f])) {
        var d = r.texData.get(f.dataId).values;
        var v = kTe(f.shape, f.dtype, d, h);
        var m = v.outVals;
        var g = v.outShape;
        var y = v.outDtype;
        t = r.makeTensorInfo(g, y, m);
      } else {
        var b = S(J7(f.shape, h), 2);
        var x = b[0];
        var k = L$(b[1]);
        var w = HEe({
          inputs: {
            x: f
          },
          backend: r,
          attrs: {
            shape: [-1, k]
          }
        });
        var I = YEe(w, p5(i.dtype), "prod", r);
        t = HEe({
          inputs: {
            x: I
          },
          backend: r,
          attrs: {
            shape: x
          }
        });
        c.push(w);
        c.push(I);
      }
      if (s) {
        c.push(t);
        var N = Z7(t.shape, l);
        t = HEe({
          inputs: {
            x: t
          },
          backend: r,
          attrs: {
            shape: N
          }
        });
      }
      c.forEach(function (e) {
        return r.disposeIntermediateTensorInfo(e);
      });
      return t;
    }
  };
  var COe = {
    kernelName: R2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.paramsNestedSplits;
      var i = t.paramsDenseValues;
      var o = t.indices;
      var s = r.outputRaggedRank;
      var u = a.map(function (e) {
        return n.readSync(e.dataId);
      });
      var c = a.map(function (e) {
        return e.shape;
      });
      var l = n.readSync(i.dataId);
      var h = n.readSync(o.dataId);
      var p = S(wTe(u, c, l, i.shape, i.dtype, h, o.shape, s), 3);
      var f = p[0];
      var d = p[1];
      var v = p[2];
      var m = f.map(function (e) {
        return n.makeTensorInfo([e.length], "int32", e);
      });
      var g = n.makeTensorInfo(v, i.dtype, d);
      return m.concat([g]);
    }
  };
  var AOe = {
    kernelName: _2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.starts;
      var a = t.limits;
      var i = t.deltas;
      var o = n.readSync(r.dataId);
      var s = n.readSync(a.dataId);
      var u = n.readSync(i.dataId);
      var c = S(ITe(o, r.shape, r.dtype, s, a.shape, u, i.shape), 2);
      var l = c[0];
      var h = c[1];
      return [n.makeTensorInfo([l.length], "int32", l), n.makeTensorInfo([h.length], r.dtype, h)];
    }
  };
  var ROe = {
    kernelName: O2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.shape;
      var i = t.values;
      var o = t.defaultValue;
      var s = t.rowPartitionTensors;
      var u = r.rowPartitionTypes;
      var c = n.readSync(a.dataId);
      var l = n.readSync(i.dataId);
      var h = n.readSync(o.dataId);
      var p = s.map(function (e) {
        return n.readSync(e.dataId);
      });
      var f = s.map(function (e) {
        return e.shape;
      });
      var d = S(NTe(c, a.shape, l, i.shape, i.dtype, h, o.shape, p, f, u), 2);
      var v = d[0];
      var m = d[1];
      return n.makeTensorInfo(v, i.dtype, m);
    }
  };
  function _Oe(e) {
    var t = e.backend;
    var n = e.attrs;
    var r = n.start;
    var a = n.stop;
    var i = n.step;
    var o = n.dtype;
    var s = STe(r, a, i, o);
    return t.makeTensorInfo([s.length], o, s);
  }
  var OOe = {
    kernelName: F2,
    backendName: "webgl",
    kernelFunc: _Oe
  };
  var FOe = MEe({
    opSnippet: "return 1.0 / x;"
  });
  var DOe = {
    kernelName: M2,
    backendName: "webgl",
    kernelFunc: FOe
  };
  var MOe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",
    packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  });
  var LOe = {
    kernelName: L2,
    backendName: "webgl",
    kernelFunc: MOe
  };
  var zOe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
  });
  var POe = {
    kernelName: V2,
    backendName: "webgl",
    kernelFunc: zOe
  };
  var BOe = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["A"];
    this.outputShape = [];
    var o = S(t, 4);
    var s = o[0];
    var u = o[1];
    var c = o[2];
    var h = o[3];
    this.outputShape = [s, n, r, h];
    var p;
    var f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c];
    var d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r];
    p = i ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC";
    this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0] / d[0]},
          ${f[1] / d[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
  });
  var WOe = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    var o = S(t, 4);
    var s = o[0];
    var u = o[1];
    var c = o[2];
    var h = o[3];
    this.outputShape = [s, n, r, h];
    var p;
    var f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c];
    var d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r];
    p = i ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC";
    this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0] / d[0]},
          ${f[1] / d[1]},
          ${f[1] / d[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h - 1};
        bool hasNextRow = coords.z < ${r - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
  });
  var UOe = {
    kernelName: W2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = r.alignCorners;
      var o = r.halfPixelCenters;
      var s = S(r.size, 2);
      var u = s[0];
      var c = s[1];
      var l = k0().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new WOe(a.shape, u, c, i, o) : new BOe(a.shape, u, c, i, o);
      return n.runWebGLProgram(l, [a], "float32");
    }
  };
  var VOe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["dy"];
    this.outputShape = [];
    this.outputShape = n;
    var a = S(n, 3);
    var i = a[1];
    var o = a[2];
    var s = S(t, 3);
    var u = s[1];
    var c = s[2];
    var h = [r && u > 1 ? i - 1 : i, r && c > 1 ? o - 1 : o];
    var p = [r && u > 1 ? u - 1 : u, r && c > 1 ? c - 1 : c];
    var f = h[0] / p[0];
    var d = h[1] / p[1];
    var v = 1 / f;
    var m = 1 / d;
    var g = Math.ceil(v) * 2 + 2;
    var y = Math.ceil(m) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${d});

        const float invHeightScale = float(${v});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${u}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${c}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  });
  var GOe = {
    kernelName: U2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = t.dy;
      var o = r.alignCorners;
      var s = new VOe(i.shape, a.shape, o);
      return n.runWebGLProgram(s, [i], i.dtype);
    }
  };
  var jOe = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["A"];
    this.outputShape = [];
    var o = S(t, 4);
    var s = o[0];
    var u = o[1];
    var c = o[2];
    var h = o[3];
    this.outputShape = [s, n, r, h];
    var p;
    var f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c];
    var d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r];
    var v = a ? "0.5" : "0.0";
    p = i ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC";
    this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0] / d[0]},
          ${f[1] / d[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${v})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
  });
  var HOe = p(function e(t, n, r, a, i) {
    l(this, e);
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    var o = S(t, 4);
    var s = o[0];
    var u = o[1];
    var c = o[2];
    var h = o[3];
    this.outputShape = [s, n, r, h];
    var p;
    var f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c];
    var d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r];
    var v = a ? "0.5" : "0.0";
    p = i ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC";
    this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0] / d[0]},
          ${f[1] / d[1]},
          ${f[1] / d[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${v})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h - 1};
        bool hasNextRow = coords.z < ${r - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
  });
  var qOe = {
    kernelName: P2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = r.alignCorners;
      var o = r.halfPixelCenters;
      var s = S(r.size, 2);
      var u = s[0];
      var c = s[1];
      var l = k0().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new HOe(a.shape, u, c, i, o) : new jOe(a.shape, u, c, i, o);
      return n.runWebGLProgram(l, [a], a.dtype);
    }
  };
  var KOe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["dy"];
    this.outputShape = [];
    this.outputShape = n;
    var a = S(n, 3);
    var i = a[1];
    var o = a[2];
    var s = S(t, 3);
    var u = s[1];
    var c = s[2];
    var h = [r && u > 1 ? i - 1 : i, r && c > 1 ? o - 1 : o];
    var p = [r && u > 1 ? u - 1 : u, r && c > 1 ? c - 1 : c];
    var f = h[0] / p[0];
    var d = h[1] / p[1];
    var v = 1 / f;
    var m = 1 / d;
    var g = Math.ceil(v) * 2 + 2;
    var y = Math.ceil(m) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${d});

        const float invHeightScale = float(${v});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${u}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${c}) {
              continue;
            }

            float sourceFracRow =
              float(${h[0]}) *
                (float(dyR) / float(${p[0]}));

            float sourceFracCol =
                float(${h[1]}) *
                  (float(dyC) / float(${p[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  });
  var XOe = {
    kernelName: B2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.images;
      var i = t.dy;
      var o = r.alignCorners;
      var s = new KOe(i.shape, a.shape, o);
      return n.runWebGLProgram(s, [i], i.dtype);
    }
  };
  var YOe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["x"];
    var r = t.length;
    if (r > 4) {
      throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);
    }
    this.outputShape = t;
    if (r !== 1) {
      var a = t.map(function (e, r) {
        return function (e) {
          if (n.indexOf(e) !== -1 && t[e] !== 1) {
            return `${t[e]} - coords[${e}] - 1`;
          } else {
            return `coords[${e}]`;
          }
        }(r);
      }).join(",");
      var i = cSe(r);
      this.userCode = `
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `;
    } else {
      this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;
    }
  });
  var JOe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    var r = t.length;
    if (r > 4) {
      throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);
    }
    this.outputShape = t;
    var a = qTe("rc", r);
    var i = `${a[r - 1]} + 1 < ${this.outputShape[r - 1]}`;
    var o = `${a[r - 2]} + 1 < ${this.outputShape[r - 2]}`;
    var s = cSe(r);
    function u(e) {
      var r = t.map(function (r, a) {
        return function (e, r) {
          if (n.indexOf(e) !== -1 && t[e] !== 1) {
            return `${t[e]} - ${r[e]} - 1`;
          } else {
            return `${r[e]}`;
          }
        }(a, e);
      });
      var a = r.join(",");
      var i = r.slice(-2).join(",");
      return `getChannel(getX(${a}), vec2(${i}))`;
    }
    this.userCode = r === 1 ? `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : `
        void main() {
          ${s} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${function (e) {
      return u(e);
    }(a.slice())};
          if(${i}){
            result.g = ${function (e) {
      e[r - 1] = "(" + e[r - 1] + " + 1)";
      return u(e);
    }(a.slice())};
          }
          if(${o}) {
            result.b = ${function (e) {
      e[r - 2] = "(" + e[r - 2] + " + 1)";
      return u(e);
    }(a.slice())};
            if(${i}) {
              result.a = ${function (e) {
      e[r - 1] = "(" + e[r - 1] + " + 1)";
      e[r - 2] = "(" + e[r - 2] + " + 1)";
      return u(e);
    }(a.slice())};
            }
          }
          setOutput(result);
        }
    `;
  });
  var ZOe = {
    kernelName: G2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.dims;
      var o = a.shape.length;
      var s = j$(i, a.shape);
      if (o === 0) {
        return SEe({
          inputs: {
            x: a
          },
          backend: n
        });
      }
      var u = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new JOe(a.shape, s) : new YOe(a.shape, s);
      return n.runWebGLProgram(u, [a], a.dtype);
    }
  };
  var QOe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["Image"];
    this.outputShape = [];
    this.customUniforms = [{
      name: "params",
      type: "vec4"
    }];
    var r = t[1];
    var a = t[2];
    this.outputShape = t;
    var i = "";
    i = typeof n == "number" ? `float outputValue = ${n.toFixed(2)};` : `
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`;
    this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  });
  var $Oe = {
    kernelName: F3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = t.image;
      var i = n.radians;
      var o = n.fillValue;
      var s = n.center;
      var u = r;
      var c = new QOe(a.shape, o);
      var l = S(pie(s, a.shape[1], a.shape[2]), 2);
      var h = [[l[0], l[1], Math.sin(i), Math.cos(i)]];
      return u.runWebGLProgram(c, [a], a.dtype, h);
    }
  };
  var eFe = MEe({
    opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
  });
  var tFe = {
    kernelName: j2,
    backendName: "webgl",
    kernelFunc: eFe
  };
  var nFe = MEe({
    opSnippet: "return inversesqrt(x);",
    cpuKernelImpl: TTe
  });
  var rFe = {
    kernelName: H2,
    backendName: "webgl",
    kernelFunc: nFe
  };
  var aFe = p(function e(t, n, r, a, i, o, _param3, s = false) {
    l(this, e);
    this.variableNames = ["updates", "indices", "defaultValue"];
    this.outputShape = o;
    var u = cSe(i.length);
    var c = cSe(o.length);
    var h = "";
    if (r === 1) {
      h = "i";
    } else if (r === 2) {
      h = "i, j";
    }
    var p = `getIndices(${h})`;
    var f = "";
    if (a === 1) {
      f = "i";
    } else if (a === 2) {
      f = "i, coords[1]";
    }
    var d = `getUpdates(${f})`;
    var v = "";
    if (s) {
      v = "coords[0], coords[1]";
    }
    var m = `getDefaultValue(${v})`;
    var g = n > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `;
  });
  var iFe = p(function e(t, n, r, a, i, o, _param4, s = false) {
    l(this, e);
    this.variableNames = ["updates", "indices", "defaultValue"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = o;
    var u = cSe(i.length);
    var c = cSe(o.length);
    var h = "";
    if (r === 1) {
      h = "i";
    } else if (r === 2) {
      h = "i, j";
    }
    var p = `getIndices(${h})`;
    var f = "";
    if (a === 1) {
      f = "i";
    } else if (a === 2) {
      f = "i, coords[1]";
    }
    var d = `getUpdates(${f})`;
    var v = "";
    if (s) {
      v = "coords[0], coords[1]";
    }
    var m = `getDefaultValue(${v})`;
    var g = n > 1 ? "strides[j]" : "strides";
    var y = n > 1 ? "strides[j + 1]" : "strides";
    this.userCode = `
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${d};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `;
  });
  var oFe = {
    kernelName: q2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.indices;
      var i = t.updates;
      var o = r.shape;
      var s = Jte(0, a, o);
      var u = s.sliceRank;
      var c = s.numUpdates;
      var l = s.sliceSize;
      var h = s.strides;
      var p = s.outputSize;
      var f = [p / l, l];
      if (p === 0) {
        return n.makeTensorInfo(o, a.dtype);
      }
      var d;
      var v = HEe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: [c, u]
        }
      });
      var m = HEe({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          shape: [c, l]
        }
      });
      var g = n.makeTensorInfo([], "float32", new Float32Array([0]));
      d = k0().getBool("WEBGL_PACK") ? new iFe(c, u, v.shape.length, m.shape.length, h, f) : new aFe(c, u, v.shape.length, m.shape.length, h, f);
      var y = n.runWebGLProgram(d, [m, v, g], m.dtype);
      var b = HEe({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          shape: o
        }
      });
      n.disposeIntermediateTensorInfo(v);
      n.disposeIntermediateTensorInfo(m);
      n.disposeIntermediateTensorInfo(y);
      n.disposeIntermediateTensorInfo(g);
      return b;
    }
  };
  var sFe = p(function e(t, n, r, a) {
    l(this, e);
    this.variableNames = ["sortedSequence", "values"];
    this.customUniforms = [{
      name: "numInputs",
      type: "int"
    }];
    this.outputShape = [t, r];
    var i = `for (int i = 0; i < ${Math.ceil(Math.log2(n + 1))}; ++i) { if (left >= right) break;`;
    var o = k0().getNumber("WEBGL_VERSION") === 2 ? "while (left < right) {" : i;
    var s = a === "left" ? "<" : "<=";
    this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${s} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
  });
  var uFe = {
    kernelName: X2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.sortedSequence;
      var i = t.values;
      var o = r.side;
      var s = new sFe(a.shape[0], a.shape[1], i.shape[1], o);
      var u = [[a.shape[1]]];
      return n.runWebGLProgram(s, [a, i], "int32", u);
    }
  };
  var cFe = p(function e(t, n, r) {
    var a;
    var i;
    l(this, e);
    this.variableNames = ["c", "a", "b"];
    this.outputShape = n;
    if (r > 4) {
      throw Error(`Where for rank ${r} is not yet supported`);
    }
    if (r === 1) {
      i = "resRC";
      a = "resRC";
    } else {
      var o = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      var s = [];
      var u = [];
      for (var c = 0; c < n.length; c++) {
        u.push(`${o[c]}`);
        if (c < t) {
          s.push(`${o[c]}`);
        }
      }
      a = s.join();
      i = u.join();
    }
    var h = cSe(r);
    this.userCode = `
      void main() {
        ${h} resRC = getOutputCoords();
        float cVal = getC(${a});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `;
  });
  var lFe = {
    kernelName: Y2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.condition;
      var a = t.t;
      var i = t.e;
      var o = new cFe(r.shape.length, a.shape, a.shape.length);
      return n.runWebGLProgram(o, [r, a, i], h5(a.dtype, i.dtype));
    }
  };
  var hFe = MEe({
    opSnippet: `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${yie};
  float scale = ${bie};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`
  });
  var pFe = {
    kernelName: J2,
    backendName: "webgl",
    kernelFunc: hFe
  };
  var fFe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",
    packedOpSnippet: "\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    cpuKernelImpl: CTe
  });
  var dFe = {
    kernelName: t3,
    backendName: "webgl",
    kernelFunc: fFe
  };
  var vFe = MEe({
    opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
  });
  var mFe = {
    kernelName: e3,
    backendName: "webgl",
    kernelFunc: vFe
  };
  var gFe = MEe({
    opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n",
    packedOpSnippet: `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${IEe}
  return result;
`
  });
  var yFe = {
    kernelName: Q2,
    backendName: "webgl",
    kernelFunc: gFe
  };
  var bFe = MEe({
    opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
  });
  var xFe = {
    kernelName: $2,
    backendName: "webgl",
    kernelFunc: bFe
  };
  var kFe = MEe({
    opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
  });
  var wFe = {
    kernelName: n3,
    backendName: "webgl",
    kernelFunc: kFe
  };
  var IFe = {
    kernelName: i3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.blockShape;
      var o = r.paddings;
      F$(a.shape.length <= 4, function () {
        return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
      });
      var s = i.reduce(function (e, t) {
        return e * t;
      });
      var u = [[0, 0]];
      u.push.apply(u, T(o));
      for (var c = 1 + i.length; c < a.shape.length; ++c) {
        u.push([0, 0]);
      }
      var l = [];
      var h = IOe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          paddings: u,
          constantValue: 0
        }
      });
      var p = fie(h.shape, i, s, false);
      var f = die(p.length, i.length, false);
      var d = vie(h.shape, i, s, false);
      var v = HEe({
        inputs: {
          x: h
        },
        backend: n,
        attrs: {
          shape: p
        }
      });
      var m = tCe({
        inputs: {
          x: v
        },
        backend: n,
        attrs: {
          perm: f
        }
      });
      var g = HEe({
        inputs: {
          x: m
        },
        backend: n,
        attrs: {
          shape: d
        }
      });
      l.push(h);
      l.push(v);
      l.push(m);
      l.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return g;
    }
  };
  var NFe = {
    kernelName: u3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.indices;
      var a = t.values;
      var i = t.denseShape;
      var o = t.defaultValue;
      if (i.shape.length !== 1) {
        throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);
      }
      if (r.shape.length !== 2) {
        throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);
      }
      if (a.shape.length !== 1) {
        throw new Error(`Values must be a vector, saw:
         ${a.shape}`);
      }
      if (o.shape.length !== 0) {
        throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);
      }
      var s = n.readSync(r.dataId);
      var u = n.readSync(a.dataId);
      var c = n.readSync(i.dataId);
      var l = n.readSync(o.dataId)[0];
      var h = S(_Te(s, r.shape, r.dtype, u, a.dtype, c, l), 5);
      var p = h[0];
      var f = h[1];
      var d = h[2];
      var v = h[3];
      var m = h[4];
      return [n.makeTensorInfo(f, r.dtype, p), n.makeTensorInfo([f[0]], a.dtype, d), n.makeTensorInfo([v.length], "bool", new Uint8Array(v.map(function (e) {
        return Number(e);
      }))), n.makeTensorInfo([m.length], r.dtype, new Int32Array(m))];
    }
  };
  var SFe = {
    kernelName: c3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.inputIndices;
      var a = t.inputShape;
      var i = t.newShape;
      if (r.shape.length !== 2) {
        throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);
      }
      if (a.shape.length !== 1) {
        throw new Error(`Input shape should be a vector but received shape ${a.shape}`);
      }
      if (i.shape.length !== 1) {
        throw new Error(`Target shape should be a vector but received shape ${i.shape}`);
      }
      var o = Array.from(n.readSync(a.dataId));
      var s = n.readSync(r.dataId);
      var u = Array.from(n.readSync(i.dataId));
      var c = S(OTe(s, r.shape, r.dtype, o, u), 3);
      var l = c[0];
      var h = c[1];
      var p = c[2];
      return [n.makeTensorInfo(h, r.dtype, l), n.makeTensorInfo([p.length], i.dtype, new Int32Array(p))];
    }
  };
  var TFe = {
    kernelName: l3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.data;
      var a = t.indices;
      var i = t.segmentIds;
      if (r.shape.length < 1) {
        throw new Error("Data should be at least 1 dimensional but received scalar");
      }
      if (a.shape.length !== 1) {
        throw new Error(`Indices should be a vector but received shape
              ${a.shape}`);
      }
      if (i.shape.length !== 1) {
        throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);
      }
      var o = n.readSync(r.dataId);
      var s = n.readSync(a.dataId);
      var u = n.readSync(i.dataId);
      var c = S(FTe(o, r.shape, r.dtype, s, u, true), 2);
      var l = c[0];
      var h = c[1];
      return n.makeTensorInfo(h, r.dtype, l);
    }
  };
  var EFe = {
    kernelName: h3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = t.data;
      var a = t.indices;
      var i = t.segmentIds;
      if (r.shape.length < 1) {
        throw new Error("Data should be at least 1 dimensional but received scalar");
      }
      if (a.shape.length !== 1) {
        throw new Error(`Indices should be a vector but received shape
             ${a.shape}`);
      }
      if (i.shape.length !== 1) {
        throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);
      }
      var o = n.readSync(r.dataId);
      var s = n.readSync(a.dataId);
      var u = n.readSync(i.dataId);
      var c = S(FTe(o, r.shape, r.dtype, s, u), 2);
      var l = c[0];
      var h = c[1];
      return n.makeTensorInfo(h, r.dtype, l);
    }
  };
  var CFe = {
    kernelName: p3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.sparseIndices;
      var i = t.sparseValues;
      var o = t.defaultValue;
      var s = r.outputShape;
      var u = Jte(0, a, s);
      var c = u.sliceRank;
      var l = u.numUpdates;
      var h = u.sliceSize;
      var p = u.strides;
      var f = u.outputSize;
      if (i.dtype === "string") {
        var d = n.bufferSync(a);
        var v = n.bufferSync(i);
        var m = W4(n.readSync(o.dataId)[0]);
        var g = ETe(d, v, s, f, h, l, c, p, m, false);
        return n.makeTensorInfo(s, g.dtype, g.values);
      }
      var y = new aFe(l, c, a.shape.length, i.shape.length, p, [f, 1], false);
      var b = n.runWebGLProgram(y, [i, a, o], i.dtype);
      var x = HEe({
        inputs: {
          x: b
        },
        backend: n,
        attrs: {
          shape: s
        }
      });
      n.disposeIntermediateTensorInfo(b);
      return x;
    }
  };
  var AFe = {
    kernelName: o3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.numOrSizeSplits;
      var o = j$(r.axis, a.shape)[0];
      var s = Vie(a, i, o);
      var u = a.shape.length;
      var c = new Array(u).fill(0);
      var l = a.shape.slice();
      return s.map(function (e) {
        var t = T(l);
        t[o] = e;
        var r = ZCe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            begin: c,
            size: t
          }
        });
        c[o] += e;
        return r;
      });
    }
  };
  var RFe = "return sqrt(x);";
  var _Fe = MEe({
    opSnippet: RFe,
    packedOpSnippet: RFe,
    cpuKernelImpl: DTe
  });
  var OFe = {
    kernelName: r3,
    backendName: "webgl",
    kernelFunc: _Fe
  };
  var FFe = {
    kernelName: d3,
    backendName: "webgl",
    kernelFunc: MEe({
      opSnippet: "return x * x;"
    })
  };
  var DFe = "return (a - b) * (a - b);";
  var MFe = LEe({
    opSnippet: DFe,
    packedOpSnippet: DFe
  });
  var LFe = {
    kernelName: f3,
    backendName: "webgl",
    kernelFunc: MFe
  };
  var zFe = {
    kernelName: v3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      if (a.dtype !== "string") {
        throw new Error("Input must be of datatype string");
      }
      var i = aoe(n.readSync(a.dataId));
      var o = MTe(i, "string", r);
      return n.makeTensorInfo(a.shape, "string", o);
    }
  };
  var PFe = {
    kernelName: _3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = t.x;
      var i = `${eEe}
    return x > 0.0 ? 1.0 : float(${n.alpha});
  `;
      var o = new $Te(a.shape, i);
      return r.runWebGLProgram(o, [a], a.dtype);
    }
  };
  var BFe = p(function e(t, n, r) {
    l(this, e);
    this.variableNames = ["x"];
    this.outputShape = r;
    var a = r.length;
    var i = cSe(r.length);
    var o = cSe(r.length);
    var s = "";
    if (a === 1) {
      s = "coords * strides + begin";
    } else {
      var u = 0;
      s = r.map(function (e, t) {
        u++;
        if (r.length === 1) {
          return `coords * strides[${t}] + begin[${t}]`;
        } else {
          return `coords[${u - 1}] * strides[${t}] + begin[${t}]`;
        }
      }).join(",");
    }
    this.userCode = `
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${n});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `;
  });
  var WFe = {
    kernelName: m3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t;
      var n = e.inputs;
      var r = e.backend;
      var a = e.attrs;
      var i = n.x;
      var o = a.begin;
      var s = a.end;
      var u = a.strides;
      var c = a.beginMask;
      var l = a.endMask;
      var h = a.ellipsisMask;
      var p = a.newAxisMask;
      var f = a.shrinkAxisMask;
      var d = Jae(i.shape, o, s, u, c, l, h, p, f);
      var v = d.finalShapeSparse;
      var m = d.finalShape;
      var g = d.isIdentity;
      var y = d.sliceDim0;
      var b = d.isSimpleSlice;
      var x = d.begin;
      var k = d.end;
      var w = d.strides;
      if (g) {
        t = HEe({
          inputs: {
            x: i
          },
          backend: r,
          attrs: {
            shape: m
          }
        });
      } else if (y || b) {
        F$(i.shape.length >= 1, function () {
          return `Input must have rank at least 1, got: ${i.shape.length}`;
        });
        var I = Pae(x, k, w);
        var N = ZCe({
          inputs: {
            x: i
          },
          backend: r,
          attrs: {
            begin: x,
            size: I
          }
        });
        t = HEe({
          inputs: {
            x: N
          },
          backend: r,
          attrs: {
            shape: m
          }
        });
        r.disposeIntermediateTensorInfo(N);
      } else if (r.shouldExecuteOnCPU([i])) {
        var S = r.readSync(i.dataId);
        var T = l8(i.shape, i.dtype, S);
        var E = LTe(v, T, w, x);
        t = r.makeTensorInfo(m, i.dtype, E.values);
      } else {
        var C = new BFe(x, w, v);
        t = r.runWebGLProgram(C, [i], i.dtype);
      }
      var A = HEe({
        inputs: {
          x: t
        },
        backend: r,
        attrs: {
          shape: m
        }
      });
      r.disposeIntermediateTensorInfo(t);
      return A;
    }
  };
  var UFe = {
    kernelName: g3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = r.separator;
      var i = r.nGramWidths;
      var o = r.leftPad;
      var s = r.rightPad;
      var u = r.padWidth;
      var c = r.preserveShortSequences;
      var l = t.data;
      var h = t.dataSplits;
      var p = n.readSync(l.dataId);
      var f = n.readSync(h.dataId);
      var d = S(zTe(p, f, a, i, o, s, u, c), 2);
      var v = d[0];
      var m = d[1];
      return [n.makeTensorInfo([v.length], "string", v), n.makeTensorInfo(h.shape, "int32", m)];
    }
  };
  var VFe = {
    kernelName: y3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs.skipEmpty;
      var a = t.input;
      var i = t.delimiter;
      if (a.dtype !== "string") {
        throw new Error("Input must be of datatype string");
      }
      if (a.shape.length !== 1) {
        throw new Error(`Input must be a vector, got shape: ${a.shape}`);
      }
      if (i.shape.length !== 0) {
        throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
      }
      var o = n.readSync(a.dataId);
      var s = n.readSync(i.dataId)[0];
      var u = S(PTe(o, s, r), 3);
      var c = u[0];
      var l = u[1];
      var h = u[2];
      var p = l.length;
      return [n.makeTensorInfo([p, 2], "int32", c), n.makeTensorInfo([p], "string", l), n.makeTensorInfo([2], "int32", new Int32Array(h))];
    }
  };
  var GFe = {
    kernelName: b3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs.numBuckets;
      var a = t.input;
      if (a.dtype !== "string") {
        throw new Error("Input must be of datatype string");
      }
      if (r <= 0) {
        throw new Error("Number of buckets must be at least 1");
      }
      var i = n.readSync(a.dataId);
      var o = BTe(i, r);
      return n.makeTensorInfo(a.shape, "int32", o);
    }
  };
  var jFe = MEe({
    opSnippet: "return tan(x);"
  });
  var HFe = {
    kernelName: k3,
    backendName: "webgl",
    kernelFunc: jFe
  };
  var qFe = MEe({
    opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
  });
  var KFe = {
    kernelName: w3,
    backendName: "webgl",
    kernelFunc: qFe
  };
  var XFe = {
    kernelName: K2,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.tensor;
      var i = t.indices;
      var o = t.updates;
      (function (e) {
        if (e == null) {
          throw new TypeError("Cannot destructure " + e);
        }
      })(r);
      var s = Jte(0, i, a.shape);
      var u = s.sliceRank;
      var c = s.numUpdates;
      var l = s.sliceSize;
      var h = s.strides;
      var p = s.outputSize;
      var f = [p / l, l];
      if (p === 0) {
        return n.makeTensorInfo(a.shape, i.dtype);
      }
      var d = HEe({
        inputs: {
          x: i
        },
        backend: n,
        attrs: {
          shape: [c, u]
        }
      });
      var v = HEe({
        inputs: {
          x: o
        },
        backend: n,
        attrs: {
          shape: [c, l]
        }
      });
      var m = HEe({
        inputs: {
          x: a
        },
        backend: n,
        attrs: {
          shape: f
        }
      });
      var g = new aFe(c, u, d.shape.length, v.shape.length, h, f, false, true);
      var y = n.runWebGLProgram(g, [v, d, m], m.dtype);
      var b = HEe({
        inputs: {
          x: y
        },
        backend: n,
        attrs: {
          shape: a.shape
        }
      });
      n.disposeIntermediateTensorInfo(d);
      n.disposeIntermediateTensorInfo(v);
      n.disposeIntermediateTensorInfo(m);
      n.disposeIntermediateTensorInfo(y);
      return b;
    }
  };
  var YFe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["A"];
    for (var r = new Array(t.length), a = 0; a < r.length; a++) {
      r[a] = t[a] * n[a];
    }
    this.outputShape = r;
    this.rank = r.length;
    var i = cSe(this.rank);
    var o = function (e) {
      var t = e.length;
      if (t > 5) {
        throw Error(`Tile for rank ${t} is not yet supported`);
      }
      if (t === 1) {
        return `imod(resRC, ${e[0]})`;
      }
      var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
      var r = [];
      for (var a = 0; a < e.length; a++) {
        r.push(`imod(${n[a]}, ${e[a]})`);
      }
      return r.join();
    }(t);
    this.userCode = `
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `;
  });
  function JFe(e) {
    var t = e.inputs;
    var n = e.backend;
    var r = e.attrs;
    var a = t.x;
    var i = r.reps;
    if (a.dtype === "string" || a.shape.length > 5) {
      var o = n.readSync(a.dataId);
      var s = a.dtype === "string" ? o.map(function (e) {
        return W4(e);
      }) : o;
      var u = l8(a.shape, a.dtype, s);
      var c = UTe(u, i);
      return n.makeTensorInfo(c.shape, c.dtype, c.values);
    }
    var l = new YFe(a.shape, i);
    return n.runWebGLProgram(l, [a], a.dtype);
  }
  var ZFe = {
    kernelName: I3,
    backendName: "webgl",
    kernelFunc: JFe
  };
  var QFe = p(function e(t) {
    l(this, e);
    this.variableNames = ["x", "indices"];
    this.customUniforms = [{
      name: "n",
      type: "int"
    }, {
      name: "firstPass",
      type: "int"
    }, {
      name: "negativeInf",
      type: "float"
    }, {
      name: "dir",
      type: "int"
    }, {
      name: "inc",
      type: "int"
    }];
    this.outputShape = t;
    this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     ";
  });
  var $Fe = p(function e(t) {
    l(this, e);
    this.variableNames = ["x", "indices"];
    this.customUniforms = [{
      name: "n",
      type: "int"
    }, {
      name: "firstPass",
      type: "int"
    }, {
      name: "k",
      type: "int"
    }];
    this.outputShape = t;
    this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     ";
  });
  function eDe(e, t) {
    if (t !== null) {
      e.disposeIntermediateTensorInfo(t);
    }
  }
  function tDe(e) {
    for (var t = 1; t < e;) {
      t *= 2;
    }
    return t;
  }
  var nDe = {
    kernelName: N3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = r.k;
      var o = r.sorted;
      var s = k0().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");
      var u = k0().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");
      var c = a.shape;
      var l = c[c.length - 1];
      if (n.shouldExecuteOnCPU([a]) || l < s || i > u) {
        var h = n.readSync(a.dataId);
        var p = S(VTe(h, c, a.dtype, i, o), 2);
        var f = p[0];
        var d = p[1];
        return [n.makeTensorInfo(f.shape, f.dtype, f.values), n.makeTensorInfo(d.shape, d.dtype, d.values)];
      }
      if (i === 0) {
        c[c.length - 1] = 0;
        return [n.makeTensorInfo(c, a.dtype, []), n.makeTensorInfo(c, "int32", [])];
      }
      if (l === 1) {
        return [a, MRe({
          attrs: {
            shape: c,
            dtype: "int32",
            value: 0
          },
          backend: n
        })];
      }
      var v = n.texData.get(a.dataId);
      var m = v !== null && v.isPacked;
      var g = m ? n.unpackTensor(a) : a;
      var y = L$(c) / l;
      var b = HEe({
        inputs: {
          x: g
        },
        attrs: {
          shape: [y, l]
        },
        backend: n
      });
      if (m) {
        eDe(n, g);
      }
      for (var x = tDe(i), k = tDe(l), w = null, I = function () {
          if (w === null) {
            return [b, b];
          } else {
            return [b, w];
          }
        }, N = function (e, t, r) {
          var a = I();
          var i = new QFe(r);
          var o = [[l], [w === null ? 1 : 0], [Number.NEGATIVE_INFINITY], [e], [t]];
          var s = w;
          w = n.runWebGLProgram(i, a, "int32", o);
          eDe(n, s);
        }, T = 1; T < x; T *= 2) {
        var E = T * 2;
        for (var C = T; C >= 1; C /= 2) {
          N(E, C, [y, k]);
        }
      }
      for (var A = k; A > x; A /= 2) {
        var R = I();
        var _ = new $Fe([y, A / 2]);
        var O = [[l], [w === null ? 1 : 0], [x]];
        var F = w;
        w = n.runWebGLProgram(_, R, "int32", O);
        eDe(n, F);
        var D = x / 2;
        var M = D * 2;
        for (var L = D; L >= 1; L /= 2) {
          N(M, L, w.shape);
        }
      }
      var z = w;
      w = ZCe({
        inputs: {
          x: w
        },
        backend: n,
        attrs: {
          begin: 0,
          size: [y, i]
        }
      });
      eDe(n, z);
      var P = e_e({
        inputs: {
          x: b,
          indices: w
        },
        backend: n,
        attrs: {
          axis: 1,
          batchDims: 1
        }
      });
      eDe(n, b);
      var B = c.slice(0, -1);
      B.push(i);
      z = w;
      w = HEe({
        inputs: {
          x: w
        },
        attrs: {
          shape: B
        },
        backend: n
      });
      eDe(n, z);
      var W = P;
      P = HEe({
        inputs: {
          x: P
        },
        attrs: {
          shape: B
        },
        backend: n
      });
      eDe(n, W);
      return [P, w];
    }
  };
  var rDe = p(function e(t, n, r, a, i, o) {
    l(this, e);
    this.variableNames = ["Image", "Transforms"];
    this.outputShape = o;
    var s;
    var u = r === "nearest" ? 1 : 2;
    switch (a) {
      case "constant":
      default:
        s = 1;
        break;
      case "reflect":
        s = 2;
        break;
      case "wrap":
        s = 3;
        break;
      case "nearest":
        s = 4;
    }
    this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${s} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${s} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${s} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${u} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
  });
  var aDe = {
    kernelName: S3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.image;
      var i = t.transforms;
      var o = r.interpolation;
      var s = r.fillMode;
      var u = r.fillValue;
      var c = r.outputShape;
      var l = S(a.shape, 4);
      var h = l[0];
      var p = l[1];
      var f = l[2];
      var d = l[3];
      var v = S(c ?? [p, f], 2);
      var m = v[0];
      var g = v[1];
      var y = new rDe(p, f, o, s, u, [h, m, g, d]);
      return n.runWebGLProgram(y, [a, i], "float32");
    }
  };
  var iDe = {
    kernelName: E3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.attrs;
      var r = e.backend;
      var a = n.axis;
      var i = t.x;
      MNe(i, "unique");
      console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
      var o = r.readSync(i.dataId);
      var s = jTe(o, a, i.shape, i.dtype);
      var u = s.outputValues;
      var c = s.outputShape;
      var l = s.indices;
      return [r.makeTensorInfo(c, i.dtype, u), r.makeTensorInfo([l.length], "int32", l)];
    }
  };
  var oDe = {
    kernelName: C3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.value;
      var i = r.axis;
      if (i < 0) {
        i += a.shape.length;
      }
      var o = a;
      for (var s = o.shape.length, u = a.shape[i], c = new Array(s - 1), l = 0, h = 0; h < s; h++) {
        if (h !== i) {
          c[l++] = o.shape[h];
        }
      }
      var p = [];
      var f = new Array(s).fill(0);
      var d = o.shape.slice();
      d[i] = 1;
      for (var v = new Array(u), m = 0; m < v.length; m++) {
        f[i] = m;
        var g = ZCe({
          inputs: {
            x: o
          },
          backend: n,
          attrs: {
            begin: f,
            size: d
          }
        });
        var y = HEe({
          inputs: {
            x: g
          },
          backend: n,
          attrs: {
            shape: c
          }
        });
        v[m] = y;
        p.push(g);
      }
      p.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return v;
    }
  };
  var sDe = p(function e(t, n) {
    l(this, e);
    this.variableNames = ["x", "segmentIds"];
    var r = t.windowSize;
    var a = t.batchSize;
    var i = t.inSize;
    var o = t.numSegments;
    var s = o * Math.ceil(i / r);
    this.outputShape = [a, s];
    var u = Math.floor(r / 4) * 4;
    var c = r % 4;
    var h = "\n        sumValue += dot(values, segFilter);\n    ";
    var p = "";
    if (i % r > 0) {
      p = `
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `;
    }
    var f = "";
    if (i % r > 0) {
      f = `
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `;
    }
    this.userCode = `
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${c === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${c === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${c === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(sumValue);
      }
    `;
  });
  var uDe = {
    kernelName: A3,
    backendName: "webgl",
    kernelFunc: function (e) {
      var t = e.inputs;
      var n = e.backend;
      var r = e.attrs;
      var a = t.x;
      var i = t.segmentIds;
      var o = r.numSegments;
      var s = a.shape.length;
      var u = [];
      var c = 0;
      var l = $7([c], s);
      var h = a;
      if (l != null) {
        h = tCe({
          inputs: {
            x: a
          },
          backend: n,
          attrs: {
            perm: l
          }
        });
        u.push(h);
        c = t9(1, s)[0];
      }
      var p = noe(h.shape, c, o);
      var f = L$([h.shape[c]]);
      var d = HEe({
        inputs: {
          x: h
        },
        backend: n,
        attrs: {
          shape: [-1, f]
        }
      });
      u.push(d);
      var v = function e(t, r, a, i, o) {
        var s = t.shape[0];
        var c = t.shape[1];
        var l = toe(c, o);
        var h = new sDe({
          windowSize: l,
          inSize: c,
          batchSize: s,
          numSegments: o
        }, r);
        var p = n.compileAndRun(h, [t, a], i);
        u.push(p);
        if (p.shape[1] === o) {
          return p;
        }
        var f = _Oe({
          backend: n,
          attrs: {
            start: 0,
            stop: o,
            step: 1,
            dtype: "float32"
          }
        });
        var d = JFe({
          inputs: {
            x: f
          },
          backend: n,
          attrs: {
            reps: [c / l]
          }
        });
        u.push(f);
        u.push(d);
        return e(p, r, d, i, o);
      }(d, "unsortedSegmentSum", i, p5(a.dtype), o);
      var m = HEe({
        inputs: {
          x: v
        },
        backend: n,
        attrs: {
          shape: p
        }
      });
      var g = m;
      if (l != null) {
        u.push(m);
        var y = e9(l);
        g = tCe({
          inputs: {
            x: g
          },
          backend: n,
          attrs: {
            perm: y
          }
        });
      }
      u.forEach(function (e) {
        return n.disposeIntermediateTensorInfo(e);
      });
      return g;
    }
  };
  for (var cDe = 0, lDe = [aCe, oCe, uCe, lCe, fCe, mCe, gCe, yCe, NCe, SCe, ECe, ACe, _Ce, FCe, MCe, PCe, BCe, VCe, GCe, jCe, KCe, $Ce, eAe, tAe, nAe, sAe, lAe, fAe, CEe, mAe, NAe, OAe, zAe, BAe, WAe, UAe, GAe, HAe, KAe, YAe, eRe, tRe, nRe, aRe, sRe, lRe, hRe, fRe, vRe, mRe, yRe, bRe, kRe, IRe, SRe, ERe, RRe, FRe, zRe, BRe, VRe, jRe, KRe, YRe, JRe, QRe, t_e, r_e, i_e, TEe, o_e, kAe, u_e, l_e, p_e, _Ee, d_e, m_e, g_e, b_e, k_e, I_e, S_e, E_e, R_e, O_e, D_e, L_e, z_e, P_e, U_e, V_e, G_e, j_e, H_e, K_e, J_e, Q_e, sOe, jEe, uOe, lOe, pOe, dOe, aAe, mOe, bOe, xOe, NOe, TOe, DEe, EOe, COe, AOe, ROe, OOe, oAe, tOe, DOe, LOe, POe, qEe, UOe, GOe, qOe, XOe, ZOe, $Oe, tFe, rFe, oFe, uFe, lFe, pFe, dFe, mFe, yFe, xFe, QCe, oOe, wFe, IFe, NFe, SFe, TFe, EFe, CFe, AFe, OFe, FFe, LFe, zFe, PFe, WFe, UFe, VFe, GFe, aOe, eCe, HFe, KFe, XFe, ZFe, nDe, aDe, nCe, iDe, oDe, uDe, yOe]; cDe < lDe.length; cDe++) {
    G3(lDe[cDe]);
  }
  var hDe = {
    "tfjs-core": eie,
    "tfjs-backend-cpu": Mbe,
    "tfjs-backend-webgl": bEe,
    "tfjs-data": rge,
    "tfjs-layers": Ble,
    "tfjs-converter": Kve,
    tfjs: "4.15.0"
  };
  e.Abs = N0;
  e.Acos = S0;
  e.Acosh = T0;
  e.AdadeltaOptimizer = Jre;
  e.AdagradOptimizer = Zre;
  e.AdamOptimizer = Qre;
  e.AdamaxOptimizer = $re;
  e.Add = E0;
  e.AddN = C0;
  e.All = A0;
  e.Any = R0;
  e.ArgMax = _0;
  e.ArgMin = O0;
  e.Asin = F0;
  e.Asinh = D0;
  e.Atan = M0;
  e.Atan2 = z0;
  e.Atanh = L0;
  e.AvgPool = P0;
  e.AvgPool3D = W0;
  e.AvgPool3DGrad = U0;
  e.AvgPoolGrad = B0;
  e.BatchMatMul = V0;
  e.BatchToSpaceND = G0;
  e.Bincount = j0;
  e.BitwiseAnd = H0;
  e.BroadcastArgs = K0;
  e.BroadcastTo = q0;
  e.Callback = $fe;
  e.CallbackList = Jce;
  e.Cast = X0;
  e.Ceil = Y0;
  e.ClipByValue = J0;
  e.Complex = Z0;
  e.ComplexAbs = Q0;
  e.Concat = $0;
  e.Conv2D = e1;
  e.Conv2DBackpropFilter = t1;
  e.Conv2DBackpropInput = n1;
  e.Conv3D = r1;
  e.Conv3DBackpropFilterV2 = a1;
  e.Conv3DBackpropInputV2 = i1;
  e.Cos = o1;
  e.Cosh = s1;
  e.CropAndResize = l1;
  e.Cumprod = u1;
  e.Cumsum = c1;
  e.CustomCallback = $ce;
  e.DataStorage = S$;
  e.DenseBincount = h1;
  e.DepthToSpace = p1;
  e.DepthwiseConv2dNative = f1;
  e.DepthwiseConv2dNativeBackpropFilter = d1;
  e.DepthwiseConv2dNativeBackpropInput = v1;
  e.Diag = m1;
  e.Dilation2D = g1;
  e.Dilation2DBackpropFilter = b1;
  e.Dilation2DBackpropInput = y1;
  e.Draw = x1;
  e.EarlyStopping = nde;
  e.Einsum = w1;
  e.Elu = I1;
  e.EluGrad = N1;
  e.Environment = y0;
  e.Equal = T1;
  e.Erf = S1;
  e.Exp = E1;
  e.ExpandDims = C1;
  e.Expm1 = A1;
  e.FFT = R1;
  e.Fill = _1;
  e.FlipLeftRight = O1;
  e.Floor = F1;
  e.FloorDiv = D1;
  e.FromPixels = O3;
  e.FusedBatchNorm = M1;
  e.FusedConv2D = M3;
  e.FusedDepthwiseConv2D = L3;
  e.GPGPUContext = YSe;
  e.GatherNd = z1;
  e.GatherV2 = L1;
  e.GraphModel = jve;
  e.Greater = P1;
  e.GreaterEqual = B1;
  e.History = Qce;
  e.IFFT = U1;
  e.Identity = W1;
  e.Imag = V1;
  e.InputSpec = gce;
  e.IsFinite = G1;
  e.IsInf = j1;
  e.IsNan = H1;
  e.KernelBackend = T$;
  e.LRN = n2;
  e.LRNGrad = r2;
  e.LayerVariable = dce;
  e.LayersModel = vhe;
  e.LeakyRelu = q1;
  e.Less = K1;
  e.LessEqual = X1;
  e.LinSpace = Y1;
  e.Log = J1;
  e.Log1p = Z1;
  e.LogSoftmax = t2;
  e.LogicalAnd = Q1;
  e.LogicalNot = $1;
  e.LogicalOr = e2;
  e.LogicalXor = "LogicalXor";
  e.LowerBound = "LowerBound";
  e.MathBackendCPU = sge;
  e.MathBackendWebGL = yEe;
  e.MatrixBandPart = "MatrixBandPart";
  e.Max = a2;
  e.MaxPool = o2;
  e.MaxPool3D = u2;
  e.MaxPool3DGrad = c2;
  e.MaxPoolGrad = s2;
  e.MaxPoolWithArgmax = l2;
  e.Maximum = i2;
  e.Mean = h2;
  e.Min = p2;
  e.Minimum = f2;
  e.MirrorPad = d2;
  e.Mod = v2;
  e.MomentumOptimizer = tae;
  e.Multinomial = m2;
  e.Multiply = g2;
  e.Neg = y2;
  e.NonMaxSuppressionV3 = x2;
  e.NonMaxSuppressionV4 = k2;
  e.NonMaxSuppressionV5 = w2;
  e.NotEqual = b2;
  e.OP_SCOPE_SUFFIX = P5;
  e.OneHot = N2;
  e.OnesLike = I2;
  e.Optimizer = Yre;
  e.OptimizerConstructors = tie;
  e.Pack = S2;
  e.PadV2 = T2;
  e.Pool = "Pool";
  e.Pow = E2;
  e.Prelu = C2;
  e.Prod = A2;
  e.RMSPropOptimizer = nae;
  e.RNN = Ipe;
  e.RaggedGather = R2;
  e.RaggedRange = _2;
  e.RaggedTensorToTensor = O2;
  e.Range = F2;
  e.Real = D2;
  e.RealDiv = k1;
  e.Reciprocal = M2;
  e.Relu = L2;
  e.Relu6 = V2;
  e.Reshape = z2;
  e.ResizeBilinear = W2;
  e.ResizeBilinearGrad = U2;
  e.ResizeNearestNeighbor = P2;
  e.ResizeNearestNeighborGrad = B2;
  e.Reverse = G2;
  e.RotateWithOffset = F3;
  e.Round = j2;
  e.Rsqrt = H2;
  e.SGDOptimizer = eae;
  e.ScatterNd = q2;
  e.SearchSorted = X2;
  e.Select = Y2;
  e.Selu = J2;
  e.Sequential = whe;
  e.Sigmoid = t3;
  e.Sign = e3;
  e.Sin = Q2;
  e.Sinh = $2;
  e.Slice = Z2;
  e.Softmax = s3;
  e.Softplus = n3;
  e.SpaceToBatchND = i3;
  e.SparseFillEmptyRows = u3;
  e.SparseReshape = c3;
  e.SparseSegmentMean = l3;
  e.SparseSegmentSum = h3;
  e.SparseToDense = p3;
  e.SplitV = o3;
  e.Sqrt = r3;
  e.Square = d3;
  e.SquaredDifference = f3;
  e.StaticRegexReplace = v3;
  e.Step = _3;
  e.StridedSlice = m3;
  e.StringNGrams = g3;
  e.StringSplit = y3;
  e.StringToHashBucketFast = b3;
  e.Sub = x3;
  e.Sum = a3;
  e.SymbolicTensor = yce;
  e.Tan = k3;
  e.Tanh = w3;
  e.Tensor = n5;
  e.TensorBuffer = $4;
  e.TensorScatterUpdate = K2;
  e.Tile = I3;
  e.TopK = N3;
  e.Transform = S3;
  e.Transpose = T3;
  e.Unique = E3;
  e.Unpack = C3;
  e.UnsortedSegmentSum = A3;
  e.UpperBound = "UpperBound";
  e.Variable = c5;
  e.ZerosLike = R3;
  e._FusedMatMul = D3;
  e.abs = y8;
  e.acos = b8;
  e.acosh = x8;
  e.add = d8;
  e.addN = k8;
  e.all = w8;
  e.any = I8;
  e.argMax = N8;
  e.argMin = S8;
  e.asin = T8;
  e.asinh = E8;
  e.atan = C8;
  e.atan2 = A8;
  e.atanh = R8;
  e.avgPool = Y8;
  e.avgPool3d = J8;
  e.backend = e6;
  e.backend_util = ooe;
  e.basicLSTMCell = n7;
  e.batchNorm = a7;
  e.batchNorm2d = i7;
  e.batchNorm3d = o7;
  e.batchNorm4d = s7;
  e.batchToSpaceND = r7;
  e.bincount = u7;
  e.bitwiseAnd = c7;
  e.booleanMaskAsync = lne;
  e.broadcastArgs = l7;
  e.broadcastTo = h7;
  e.broadcast_util = P7;
  e.browser = Dae;
  e.buffer = l8;
  e.callbacks = ide;
  e.cast = h8;
  e.ceil = p7;
  e.clipByValue = d7;
  e.clone = p8;
  e.complex = W5;
  e.concat = Z8;
  e.concat1d = v7;
  e.concat2d = m7;
  e.concat3d = g7;
  e.concat4d = y7;
  e.constraints = Gce;
  e.conv1d = x7;
  e.conv2d = b7;
  e.conv2dTranspose = w7;
  e.conv3d = I7;
  e.conv3dTranspose = S7;
  e.copyRegisteredKernels = function (e, t) {
    V3(e).forEach(function (e) {
      G3(Object.assign({}, e, {
        backendName: t
      }));
    });
  };
  e.cos = T7;
  e.cosh = E7;
  e.cosineWindow = bne;
  e.cumprod = C7;
  e.cumsum = A7;
  e.customGrad = F9;
  e.data = age;
  e.denseBincount = R7;
  e.deprecationWarn = H5;
  e.depthToSpace = _7;
  e.depthwiseConv2d = O7;
  e.deregisterOp = function (e) {
    delete ode[e];
  };
  e.device_util = _5;
  e.diag = F7;
  e.dilation2d = D7;
  e.disableDeprecationWarnings = function () {
    k0().set("DEPRECATION_WARNINGS_ENABLED", false);
    console.warn("TensorFlow.js deprecation warnings have been disabled.");
  };
  e.dispose = Y5;
  e.disposeVariables = function () {
    E5.disposeVariables();
  };
  e.div = m8;
  e.divNoNan = V7;
  e.dot = G7;
  e.dropout = gne;
  e.einsum = j7;
  e.elu = H7;
  e.enableDebugMode = function () {
    k0().set("DEBUG", true);
  };
  e.enableProdMode = function () {
    k0().set("PROD", true);
  };
  e.enclosingPowerOfTwo = yne;
  e.engine = q5;
  e.ensureShape = q7;
  e.env = k0;
  e.equal = B7;
  e.erf = K7;
  e.euclideanNorm = h9;
  e.exp = p9;
  e.expandDims = f9;
  e.expm1 = d9;
  e.eye = m9;
  e.fft = _te;
  e.fill = f7;
  e.findBackend = function (e) {
    return E5.findBackend(e);
  };
  e.findBackendFactory = function (e) {
    return E5.findBackendFactory(e);
  };
  e.floor = g9;
  e.floorDiv = v8;
  e.forceHalfFloat = xEe;
  e.fused = One;
  e.gather = y9;
  e.gatherND = mne;
  e.gather_util = Lae;
  e.getBackend = Q5;
  e.getGradient = U3;
  e.getKernel = W3;
  e.getKernelsForBackend = V3;
  e.gpgpu_util = XSe;
  e.grad = function (e) {
    F$(r0(e), function () {
      return "The f passed in grad(f) must be a function";
    });
    return function (t, n) {
      var r = L5(t, "x", "tf.grad", "string_or_numeric");
      var a = n != null ? L5(n, "dy", "tf.grad") : null;
      return E5.tidy(function () {
        var t = E5.gradients(function () {
          return e(r);
        }, [r], a);
        var n = t.value;
        var i = t.grads;
        if (a != null) {
          D$(n.shape, a.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");
        }
        D9(i);
        return i[0];
      });
    };
  };
  e.grads = function (e) {
    F$(r0(e), function () {
      return "The f passed in grads(f) must be a function";
    });
    return function (t, n) {
      F$(Array.isArray(t), function () {
        return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
      });
      var r = z5(t, "args", "tf.grads", "string_or_numeric");
      var a = n != null ? L5(n, "dy", "tf.grads") : null;
      return E5.tidy(function () {
        var t = E5.gradients(function () {
          return e.apply(undefined, T(r));
        }, r, a);
        var n = t.value;
        var i = t.grads;
        if (a != null) {
          D$(n.shape, a.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
        }
        D9(i);
        return i;
      });
    };
  };
  e.greater = b9;
  e.greaterEqual = x9;
  e.ifft = Ote;
  e.imag = k9;
  e.image = Pre;
  e.inTopKAsync = kne;
  e.initializers = Hce;
  e.input = Ihe;
  e.io = Nae;
  e.irfft = Fte;
  e.isFinite = w9;
  e.isInf = I9;
  e.isNaN = N9;
  e.keep = J5;
  e.kernel_impls = soe;
  e.layers = Yfe;
  e.leakyRelu = S9;
  e.less = T9;
  e.lessEqual = E9;
  e.linalg = Bre;
  e.linspace = C9;
  e.loadGraphModel = function (e) {
    return Hve.apply(this, arguments);
  };
  e.loadGraphModelSync = function (e) {
    if (e == null) {
      throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");
    }
    var t;
    if (e instanceof Array) {
      var n = S(e, 2);
      var r = n[0];
      var a = n[1];
      if (!r) {
        throw new Error("modelJSON must be the first element of the array");
      }
      if (!a || !(a instanceof ArrayBuffer)) {
        throw new Error("An ArrayBuffer of weights must be the second element of the array");
      }
      if (!("modelTopology" in r)) {
        throw new Error("Model JSON is missing 'modelTopology'");
      }
      if (!("weightsManifest" in r)) {
        throw new Error("Model JSON is missing 'weightsManifest'");
      }
      t = Iae(x6(r, N6(r.weightsManifest), a));
    } else if ("load" in e) {
      t = e;
    } else {
      if (!("modelTopology" in e) || !("weightSpecs" in e) || !("weightData" in e)) {
        throw new Error("Unknown model format");
      }
      t = Iae(e);
    }
    var i = new jve(t);
    i.load();
    return i;
  };
  e.loadLayersModel = function (e, t) {
    return yhe.apply(this, arguments);
  };
  e.localResponseNormalization = A9;
  e.log = R9;
  e.log1p = _9;
  e.logSigmoid = z9;
  e.logSoftmax = B9;
  e.logSumExp = W9;
  e.logicalAnd = U9;
  e.logicalNot = V9;
  e.logicalOr = G9;
  e.logicalXor = j9;
  e.losses = Wre;
  e.lowerBound = K9;
  e.matMul = Q8;
  e.math = Tae;
  e.max = n9;
  e.maxPool = X9;
  e.maxPool3d = Y9;
  e.maxPoolWithArgmax = J9;
  e.maximum = Z9;
  e.mean = Q9;
  e.memory = K5;
  e.meshgrid = tee;
  e.metrics = Jfe;
  e.min = r9;
  e.minimum = nee;
  e.mirrorPad = ree;
  e.mod = aee;
  e.model = function (e) {
    return new vhe(e);
  };
  e.models = Zfe;
  e.moments = iee;
  e.movingAverage = pne;
  e.mul = g8;
  e.multiRNNCell = oee;
  e.multinomial = see;
  e.neg = M9;
  e.nextFrame = aie;
  e.norm = l9;
  e.notEqual = uee;
  e.oneHot = cee;
  e.ones = eee;
  e.onesLike = lee;
  e.op = B5;
  e.outerProduct = hee;
  e.pad = pee;
  e.pad1d = fee;
  e.pad2d = dee;
  e.pad3d = vee;
  e.pad4d = mee;
  e.pool = yee;
  e.pow = a9;
  e.prelu = bee;
  e.print = f8;
  e.prod = xee;
  e.profile = function (e) {
    return E5.profile(e);
  };
  e.raggedGather = kee;
  e.raggedRange = wee;
  e.raggedTensorToTensor = Iee;
  e.rand = Nee;
  e.randomGamma = nte;
  e.randomNormal = rte;
  e.randomStandardNormal = ate;
  e.randomUniform = ite;
  e.randomUniformInt = ote;
  e.range = ste;
  e.ready = function () {
    return E5.ready();
  };
  e.real = ute;
  e.reciprocal = cte;
  e.registerBackend = $5;
  e.registerCallbackConstructor = function (e, t) {
    tle.registerCallbackConstructor(e, t);
  };
  e.registerGradient = j3;
  e.registerKernel = G3;
  e.registerOp = function (e, t) {
    var n = {
      tfOpName: e,
      category: "custom",
      inputs: [],
      attrs: [],
      customExecutor: t
    };
    ode[e] = n;
  };
  e.regularizers = Qfe;
  e.relu = lte;
  e.relu6 = hte;
  e.removeBackend = function (e) {
    E5.removeBackend(e);
  };
  e.reshape = X8;
  e.reverse = pte;
  e.reverse1d = fte;
  e.reverse2d = dte;
  e.reverse3d = vte;
  e.reverse4d = mte;
  e.rfft = Mte;
  e.round = gte;
  e.rsqrt = yte;
  e.scalar = i9;
  e.scatterND = fne;
  e.scatter_util = Zte;
  e.searchSorted = q9;
  e.selu = bte;
  e.separableConv2d = xte;
  e.sequential = function (e) {
    return new whe(e);
  };
  e.serialization = Xre;
  e.setBackend = Z5;
  e.setPlatform = function (e, t) {
    k0().setPlatform(e, t);
  };
  e.setWebGLContext = BIe;
  e.setdiff1dAsync = wte;
  e.shared = Dbe;
  e.sigmoid = $8;
  e.sign = Ite;
  e.signal = zre;
  e.sin = Nte;
  e.sinh = Ste;
  e.slice = e7;
  e.slice1d = Tte;
  e.slice2d = Ete;
  e.slice3d = Cte;
  e.slice4d = Ate;
  e.slice_util = $ae;
  e.softmax = Rte;
  e.softplus = L9;
  e.spaceToBatchND = gee;
  e.sparse = Ure;
  e.sparseToDense = vne;
  e.spectral = Lre;
  e.split = Dte;
  e.sqrt = o9;
  e.square = s9;
  e.squaredDifference = Lte;
  e.squeeze = zte;
  e.stack = Pte;
  e.step = Bte;
  e.stridedSlice = Wte;
  e.string = Vre;
  e.sub = P9;
  e.sum = u9;
  e.sumOutType = p5;
  e.tan = Ute;
  e.tanh = t7;
  e.tensor = V5;
  e.tensor1d = Vte;
  e.tensor2d = Gte;
  e.tensor3d = jte;
  e.tensor4d = Hte;
  e.tensor5d = qte;
  e.tensor6d = Kte;
  e.tensorScatterUpdate = Qte;
  e.tensor_util = x5;
  e.test_util = Qee;
  e.tidy = X5;
  e.tile = v9;
  e.time = function (e) {
    return E5.time(e);
  };
  e.topk = $te;
  e.train = nie;
  e.transpose = hne;
  e.truncatedNormal = ene;
  e.unique = tne;
  e.unregisterGradient = function (e) {
    if (!B3.has(e)) {
      throw new Error(`The gradient '${e}' for backend is not registered`);
    }
    B3.delete(e);
  };
  e.unregisterKernel = function (e, t) {
    var n = H3(e, t);
    if (!P3.has(n)) {
      throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);
    }
    P3.delete(n);
  };
  e.unsortedSegmentSum = nne;
  e.unstack = rne;
  e.upcastType = h5;
  e.upperBound = ane;
  e.util = G4;
  e.valueAndGrad = function (e) {
    F$(r0(e), function () {
      return "The f passed in valueAndGrad(f) must be a function";
    });
    return function (t, n) {
      F$(t instanceof n5, function () {
        return "The x passed in valueAndGrad(f)(x) must be a tensor";
      });
      F$(n == null || n instanceof n5, function () {
        return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
      });
      var r = E5.gradients(function () {
        return e(t);
      }, [t], n);
      var a = r.grads;
      var i = r.value;
      D9(a);
      return {
        grad: a[0],
        value: i
      };
    };
  };
  e.valueAndGrads = function (e) {
    F$(r0(e), function () {
      return "The f passed in valueAndGrads(f) must be a function";
    });
    return function (t, n) {
      F$(Array.isArray(t) && t.every(function (e) {
        return e instanceof n5;
      }), function () {
        return "The args passed in valueAndGrads(f)(args) must be array of tensors";
      });
      F$(n == null || n instanceof n5, function () {
        return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
      });
      var r = E5.gradients(function () {
        return e.apply(undefined, T(t));
      }, t, n);
      if (n != null) {
        D$(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
      }
      D9(r.grads);
      return r;
    };
  };
  e.variable = ine;
  e.variableGrads = O9;
  e.version = hDe;
  e.version_converter = Kve;
  e.version_core = eie;
  e.version_cpu = Mbe;
  e.version_layers = Ble;
  e.version_webgl = bEe;
  e.webgl = kEe;
  e.webgl_util = LNe;
  e.where = W7;
  e.whereAsync = une;
  e.zeros = $9;
  e.zerosLike = U7;
}); //# sourceMappingURL=tf.min.js.map