{
  "version": "2.0.0",
  "timestamp": 1767082294783,
  "inputHash": "067fab107577d9d1",
  "completedBatches": 536,
  "totalBatches": 754,
  "renames": {
    "t": "________________________options",
    "e": "ticksZValue",
    "i": "metaIndexScale",
    "s": "visibleMetaGroups",
    "n": "_isStacked",
    "o": "stackedItemList",
    "a": "optionKey",
    "r": "cachedElementOptions",
    "h": "isOptionSharingEnabled",
    "l": "____________chartConfig",
    "c": "datasetElementScopeKeys",
    "d": "optionHoverData",
    "u": "halfSpacingPlusBorderWidth",
    "p": "_animationDurationKeys",
    "f": "resolvedOptions",
    "m": "dataPointMetrics",
    "x": "calculatedMinValue",
    "b": "shouldCreateDataPoint",
    "_": "drawLineSegment",
    "y": "_maxRotationExtent",
    "w": "__maxValue",
    "k": "_intervalCount",
    "S": "shapeRadiusDifference",
    "D": "arcMidpointAdjustment",
    "P": "_angleDifference",
    "A": "_innerArcTotalRadius",
    "L": "angleAdjustment",
    "O": "finalArcAngleAdjustment",
    "E": "chartUpdater",
    "tt": "requestAnimationFrame",
    "et": "animationTarget",
    "it": "animationQueue",
    "st": "animationStep",
    "nt": "_animationDuration",
    "ot": "animationItems",
    "at": "animationTask",
    "rt": "___requestAnimationFrameId",
    "ht": "chartAnimationItems",
    "lt": "lastTickValue",
    "dt": "lastUpdateDate",
    "ut": "animationController",
    "gt": "animationFrameRequestId",
    "ft": "animationFrameRequest",
    "mt": "minimizedTime",
    "xt": "_animationController",
    "_t": "animationRequestId",
    "yt": "__animationController",
    "vt": "animationManager",
    "Mt": "_animationManager",
    "St": "animationHandler",
    "Dt": "_animationStep",
    "Lt": "___animationController",
    "Ot": "animationState",
    "Et": "elementBorderRadius",
    "Tt": "_requestAnimationFrame",
    "Rt": "animationRefreshRate",
    "zt": "__animationManager",
    "It": "chartRequestAnimationFrame",
    "Ft": "framerate",
    "Vt": "chartAnimationController",
    "Bt": "__animationDuration",
    "Nt": "___animationDuration",
    "Wt": "width",
    "Ht": "_animationHandler",
    "jt": "__animationHandler",
    "$t": "__requestAnimationFrame",
    "Ut": "tooltipVisible",
    "Yt": "tooltipOptions",
    "Xt": "tooltipActiveElements",
    "Gt": "___animationManager",
    "Kt": "____animationController",
    "qt": "_chartAnimationQueue",
    "Jt": "_animationQueue",
    "te": "defaultColor",
    "Me": "isResetOrNone",
    "we": "isRequestActive",
    "li": "chartUpdateHandler",
    "Ci": "_____animationController",
    "Ai": "___animationHandler",
    "Li": "lastUpdateTimestamp",
    "Ei": "______animationController",
    "Bi": "____animationManager",
    "Ni": "activeChart",
    "ss": "_animationTask",
    "ns": "listenerMap",
    "os": "_animationRequestId",
    "Bs": "_____animationManager",
    "Ns": "chartsMap",
    "Xs": "chartAnimationList",
    "Gs": "__animationQueue",
    "tn": "currentStep",
    "Pn": "animationContext",
    "Path2D": "____requestAnimationFrameId",
    "jn": "chartAnimationContext",
    "Fo": "_chartUpdater",
    "Vo": "_______animationController",
    "Ko": "chartManager",
    "ba": "_animationItems",
    "Ja": "timeScaleConfig",
    "Animation": "______animationManager",
    "Animations": "_______animationManager",
    "ArcElement": "animationElement",
    "BarController": "ChartAnimationController",
    "BarElement": "barChartElement",
    "BasePlatform": "basePlatform",
    "BasicPlatform": "basicAnimationPlatform",
    "BubbleController": "________animationManager",
    "CategoryScale": "categoryScale",
    "Chart": "chartInstance",
    "Colors": "colorPalette",
    "DatasetController": "datasetAnimationController",
    "Decimation": "animationDecimation",
    "DomPlatform": "documentPlatform",
    "DoughnutController": "doughnutAnimationController",
    "Element": "htmlElement",
    "Filler": "fillerPlugin",
    "Interaction": "canvasInteractionHandler",
    "Legend": "chartLegend",
    "LineController": "________animationController",
    "LineElement": "LineChartElement",
    "LinearScale": "linearAnimationScale",
    "LogarithmicScale": "logarithmicScale",
    "PieController": "_________animationController",
    "PointElement": "PointAnimationElement",
    "PolarAreaController": "polarAreaAnimationController",
    "RadarController": "radarAnimationController",
    "RadialLinearScale": "radialLinearScale",
    "Scale": "animationScale",
    "ScatterController": "__________animationController",
    "SubTitle": "subTitle",
    "Ticks": "animationTicks",
    "TimeScale": "animationTimeScale",
    "TimeSeriesScale": "timeSeriesScale",
    "Title": "chartTitle",
    "Tooltip": "tooltipState",
    "_adapters": "_adapterFunctions",
    "_detectPlatform": "detectPlatformFlag",
    "animator": "___________animationController",
    "controllers": "animationControllers",
    "defaults": "defaultOptions",
    "elements": "animatedChartElements",
    "layouts": "chartLayouts",
    "plugins": "pluginList",
    "registerables": "registerableItems",
    "registry": "animationRegistry",
    "scales": "animationScales",
    "g": "__optionScopes",
    "v": "dataPointPixelValue",
    "M": "_basePixelValue",
    "to": "extractSamples",
    "gi": "processItems",
    "Ae": "calculatePixelAdjustment",
    "Di": "DeviceInteraction",
    "ve": "removeStackedValues",
    "ta": "getChartDetails",
    "rs": "calculateTickPosition",
    "yn": "calculateOverlap",
    "Le": "updateChartBounds",
    "vi": "calculatePadding",
    "Ds": "configurePlugin",
    "Ia": "calculateRange",
    "or": "calculateMajorIntervals",
    "vo": "getVisibleMetaDatasUntilIndex",
    "oe": "optionsHandler",
    "io": "processIo",
    "Ro": "clipRectangle",
    "ui": "sortByWeightAndIndex",
    "sn": "shiftedIndex",
    "ae": "_calculateRange",
    "pe": "getUserBoundsWithInfiniteFallback",
    "is": "isConstantDifference",
    "ne": "fetchActivePromises",
    "ts": "targetStep",
    "me": "getMatchingMetaIndex",
    "Wo": "getMaxTextWidth",
    "Cs": "getValueOrIndex",
    "le": "getDatasetIndices",
    "Ji": "calculateTickCount",
    "bi": "_____boundingBox",
    "Os": "_axisDirection",
    "as": "arraySliceByStep",
    "co": "arrayElementRetriever",
    "ua": "getTooltipWithCallbacks",
    "Qi": "findMajorIndices",
    "nn": "determineReturnValue",
    "$o": "eventHandler",
    "ks": "getResponseObject",
    "Qo": "splitStringByLine",
    "qs": "compareByField",
    "Ln": "isWithinHitRadius",
    "Ha": "getAlignmentPosition",
    "Do": "getDataset",
    "Jn": "hasBorderOrBackgroundColor",
    "$a": "adjustedValue",
    "Be": "getTaskState",
    "wi": "setBoundingBox",
    "mo": "operationResult",
    "va": "getLabelByIndex",
    "Ve": "returnValueBasedOnComparison",
    "ja": "_adjustedPosition",
    "Je": "throwErrorForUnimplementedMethod",
    "La": "calculateDifference",
    "ue": "isStackedOption",
    "Ii": "isElementPresent",
    "be": "getFirstMatchingScale",
    "Ne": "inflateAmountHandler",
    "Fs": "prepareChartOptions",
    "As": "compareValues",
    "on": "getValueBasedOnClip",
    "ls": "getTickLength",
    "Ts": "axisCheck",
    "Vn": "getCornerValues",
    "Te": "isBarRangeDefined",
    "xi": "_________________________________________index",
    "Ls": "validateCoordinateInput",
    "ge": "getFormattedId",
    "fe": "getOrCreateNestedObject",
    "Zn": "getBorderOrBackgroundColor",
    "jo": "textLengthMultiplier",
    "ci": "filterByPosition",
    "_s": "hasIdAndDefaults",
    "go": "shouldFill",
    "Qa": "subtractValues",
    "T": "_lastAnimationUpdateTimestamp",
    "R": "__animationElement",
    "N": "_____requestAnimationFrameId",
    "j": "__tooltipHandler",
    "Y": "chartAnimationState",
    "pt": "_animationFrameRequestId",
    "Ct": "_chartAnimationState",
    "At": "__animationStep",
    "ee": "animationFunctions",
    "ke": "getNormalizedAnimationData",
    "Hs": "isAnimationRunning",
    "Us": "___animationContext",
    "$n": "______requestAnimationFrameId",
    "ga": "chartUpdateState",
    "Pa": "animationProgressIndex",
    "Za": "timeScaleKeys",
    "eo": "processDataPoints",
    "ps": "calculateChartPositions",
    "_i": "updatePaddingDimensions",
    "tr": "transformInputValue",
    "xe": "processChartData",
    "Va": "adjustBoundingBox",
    "wo": "interpolationCheck",
    "es": "calculateAnimationIndex",
    "Ss": "initializePlugins",
    "xn": "updateCanvasBorderStyles",
    "po": "getFillColor",
    "pi": "processInputArray",
    "Fi": "createMutationObserver",
    "Vi": "setupMutationObserver",
    "Es": "determineAxisValue",
    "$s": "elementMap",
    "De": "getCachedBarChartData",
    "ar": "inputArrayElement",
    "Ce": "calculateBarDimensions",
    "he": "topBoundary",
    "bo": "calculateAnimationValue",
    "an": "calculateChartBounds",
    "bs": "animateProperty",
    "xo": "animationPixelValue",
    "Rs": "retrieveAxisData",
    "_o": "getChartAnimationOrigin",
    "sa": "isInputOverflowing",
    "ro": "getAnimationProperty",
    "ka": "calculateAnimation",
    "re": "calculateBoundingBox",
    "ye": "___tooltipHandler",
    "Wi": "updateActiveChartOnDeviceChange",
    "_a": "findFirstOccurrence",
    "Pi": "canvas2DContext",
    "_e": "____tooltipHandler",
    "aa": "calculateAdjustedX",
    "za": "getChartDimensions",
    "Ps": "getDatasetIndexAxis",
    "Zo": "updateTargetArray",
    "gs": "animatedTarget",
    "Oe": "handleChartData",
    "Ws": "getOrCreateAnimationInstance",
    "Ho": "elementText",
    "da": "tooltipHandlerFunction",
    "Ks": "isVerticalPosition",
    "Ka": "_tooltipHandlerFunction",
    "di": "_dataItem",
    "us": "_____tooltipHandler",
    "cn": "createAnimation",
    "Fe": "calculateTaskState",
    "ds": "__tooltipHandlerFunction",
    "so": "processDatasetItem",
    "Ri": "removeCanvasEventListener",
    "Ti": "addEventListenerToTarget",
    "Un": "getChartAnimationContext",
    "W": "_________animationManager",
    "H": "_currentFrameTimestamp",
    "U": "_______requestAnimationFrameId",
    "J": "__________animationManager",
    "ct": "_chartAnimationItems",
    "wt": "animationTaskId",
    "Pt": "___animationStep",
    "ya": "chartLabel",
    "Ca": "animationCounter",
    "wa": "calculateIntervalValues",
    "fi": "calculateBoxDimensions",
    "Pe": "calculateMinDistance",
    "mi": "processInputData",
    "na": "determinePositionAlignment",
    "ce": "updateCurrentValue",
    "dn": "animateBorderRadius",
    "Mo": "processInterpolation",
    "Ee": "_processChartData",
    "er": "getNextTimeScale",
    "fo": "chartAnimationHandler",
    "xs": "___animationSettings",
    "ir": "findMatchingTimeScale",
    "la": "calculateAlignmentOffset",
    "Ra": "calculateChartPadding",
    "Sn": "currentPath",
    "cs": "calculateChartSize",
    "Oa": "calculateIncrementalAdjustment",
    "pa": "invokePropertyMethod",
    "sr": "findNextCommonTimeScaleKey",
    "Re": "evaluatePathClosure",
    "No": "calculateItemDimensions",
    "Hi": "handleAnimation",
    "ji": "removeAnimationById",
    "Tn": "isValidAndProcessEvent",
    "Gn": "setElementBackgroundColor",
    "Aa": "isNumberAtAnimationProgress",
    "Yn": "getRequestAnimationFrameId",
    "ca": "processInputText",
    "V": "chartAnimationId",
    "X": "_____animationState",
    "K": "_chartUpdateInterval",
    "ms": "AnimationRegistry",
    "Ea": "calculateValueRange",
    "zn": "calculateBorderRadius",
    "Ys": "checkElementAnimation",
    "Zi": "calculateSequenceMax",
    "Rn": "calculateBorderAnimation",
    "Qs": "getElementFromSelector",
    "Ui": "uiHandler",
    "Xn": "updateElementStyles",
    "Kn": "colorFrameId",
    "B": "notificationCallback",
    "G": "__chartUpdateTrigger",
    "q": "__chartAnimationQueue",
    "en": "__notificationFunction",
    "Oi": "updateElementDimensions",
    "qi": "calculateChartTicks",
    "I": "_____animationIndex",
    "F": "requestAnimationFrameUniqueId",
    "z": "__lastDateUpdated",
    "$i": "resizeObserverCallback",
    "ea": "calculateTooltipDimensions",
    "hs": "handleDataCleanup",
    "bn": "defineLineToPoint",
    "_n": "getAnimationFunction",
    "Bn": "drawRectangle",
    "hn": "updateLastDate",
    "Vs": "___________chartOptions",
    "un": "calculateCoordinates",
    "gn": "drawShapeWithArcs",
    "C": "__chartUpdater",
    "zo": "drawLineIfInterpolated",
    "Is": "isChartDataValid",
    "Zs": "__processChartData",
    "Cn": "animateWithOptions",
    "Po": "___processChartData",
    "Js": "chartDataProcessingFunction",
    "lo": "findLastValidPointIndex",
    "ao": "mapAnimationSegmentsToTargets",
    "kt": "__chartUpdateInterval",
    "To": "drawPathSegments",
    "kn": "getAnimationHandler",
    "Xe": "PieChart",
    "Gi": "getCanvasContext",
    "OffscreenCanvas": "isUsingOffscreenCanvas",
    "oa": "alignElements",
    "Yi": "initializeCanvasAnimation",
    "Xi": "CanvasInteraction",
    "Xo": "createChartInstance",
    "Fn": "isAnimationRequired",
    "ia": "getVerticalPosition",
    "nr": "updateAnimationState",
    "yi": "adjustPadding",
    "ai": "areaCheckHandler",
    "bt": "animationIdentifier",
    "ra": "calculatePositionY",
    "Co": "createChartCoordinates",
    "zi": "___________eventHandler",
    "de": "transformDataToKeyValuePairs",
    "wn": "chartDataProcessor",
    "Dn": "drawSegments",
    "qn": "updateChartStyles",
    "Qn": "_animationTaskId",
    "ii": "calculateDistanceBasedOnAxes",
    "Na": "_________________________________chartData",
    "Zt": "AnimationController",
    "Qt": "animationControllerInstance",
    "Xa": "drawCircle",
    "Ga": "drawShapeWithStroke",
    "So": "processChartConfig",
    "uo": "createChartPoints",
    "Nn": "adjustRectanglePosition",
    "si": "findElementsInRange",
    "zs": "updateChartAnimation",
    "pn": "drawArcSegments",
    "ln": "lineMarginRatio",
    "ri": "isRangeMatched",
    "ei": "processVisibleDataset",
    "no": "calculateNotificationRange",
    "oo": "___isChartAnimationRunning",
    "Ze": "CustomClass",
    "Qe": "___animationInstance",
    "ze": "determineCoordinateOrientation",
    "Ie": "setChartBorderSkipped",
    "ws": "updateWorkspacePlugins",
    "ni": "visibleAnimatedElements",
    "yo": "_processInputData",
    "Lo": "_____processChartData",
    "Mi": "processDimensions",
    "Ba": "calculateDrawingPosition",
    "Wa": "calculateLabelPositions",
    "Ao": "animationPointsGenerator",
    "En": "calculateDiagramBounds",
    "Oo": "renderPlot",
    "hi": "____________animationController",
    "Jo": "_____________animationController",
    "ki": "layoutItems",
    "Mn": "drawLineToCanvas",
    "Fa": "generateChartPointLabels",
    "fn": "_drawShapeWithStroke",
    "je": "calculateAnimationRatios",
    "In": "borderAnimation",
    "ha": "calculateTooltipPosition",
    "Ua": "drawChartBackdrop",
    "oi": "findClosestDataPoints",
    "vn": "animateUsingCanvas",
    "Eo": "drawPathOnCanvas",
    "Ki": "_AnimationController",
    "ho": "coordinateOutput",
    "ko": "Circle",
    "Si": "___________animationIndex",
    "An": "LineAnimationController",
    "Wn": "BarAnimationController",
    "On": "__AnimationController",
    "hr": "calculateHorizontalRange",
    "ti": "getChartDataRange",
    "Io": "_animationControllerInstance",
    "Ya": "drawChartWithPointLabels",
    "ie": "___AnimationController",
    "js": "ChartConfiguration"
  },
  "partialCode": "import { r as notifyListeners, a as animationOptions, e as currentStepIndex, c as colorParser, i as currentAnimationIndex, d as animationDuration, b as animatedChartItems, v as chartAnimationRunning, u as requestAnimationFrameId, l as requestAnimationFrameID, f as _requestAnimationFrameId, g as chartUpdateTrigger, h as canvasContext, s as isPathClosed, j as tooltipHandler, k as chartUpdateInterval, _ as adapterFunctions, t as requestAnimation, m as minifiedVar, n as __requestAnimationFrameId, T as lastAnimationUpdateTimestamp, o as _isChartAnimationRunning, p as _animatedChartItems, H as currentFrameTimestamp, P as notificationListener, q as chartAnimationQueue, w as refreshIntervalId, x as requestId, y as __chartUpdater, z as lastDateUpdated, A as lastAnimationTimestamp, B as notificationFunction, C as chartUpdater, D as _lastAnimationUpdateTimestamp, E as __animationElement, F as __lastDateUpdated, G as _____animationIndex, I as requestAnimationFrameUniqueId, J as chartAnimationId, K as _notificationFunction, L as _____requestAnimationFrameId, M as _________animationManager, N as _currentFrameTimestamp, O as __tooltipHandler, Q as $, R as _______requestAnimationFrameId, S as chartAnimationState, U as _____animationState, V as __chartUpdateTrigger, W as _chartUpdateInterval, X as __chartAnimationQueue, Y as __________animationManager, Z, $ as Q, a0 as requestAnimationFrame, a1 as animationTarget, a2 as animationQueue, a3 as animationStep, a4 as _animationDuration, a5 as animationItems, a6 as animationTask, a7 as ___requestAnimationFrameId, a8 as chartAnimationItems, a9 as lastTickValue, aa as _chartAnimationItems, ab as lastUpdateDate, ac as animationController, ad as animationFrameRequestId, ae as _animationFrameRequestId, af as animationFrameRequest, ag as minimizedTime, ah as _animationController, ai as animationIdentifier, aj as animationRequestId, ak as __animationController, al as animationManager, am as _animationManager, an as animationTaskId, ao as __chartUpdateInterval, ap as animationHandler, aq as _animationStep, ar as ___animationStep, as as _chartAnimationState, at as __animationStep, au as ___animationController, av as animationState, aw as elementBorderRadius, ax as _requestAnimationFrame, ay as animationRefreshRate, az as __animationManager, aA as chartRequestAnimationFrame, aB as framerate, aC as chartAnimationController, aD as __animationDuration, aE as ___animationDuration, aF as width, aG as _animationHandler, aH as __animationHandler, aI as __requestAnimationFrame, aJ as tooltipVisible, aK as tooltipOptions, aL as tooltipActiveElements, aM as ___animationManager, aN as ____animationController, aO as _chartAnimationQueue, aP as _animationQueue } from \"./chunks/helpers.segment.js\";\nimport \"@kurkle/color\";\nclass AnimationController {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(____________________chartInstance, _______________________event, _currentStepIndex, listenerIndex) {\n    const eventListenersForStep = _______________________event.listeners[listenerIndex];\n    const eventDuration = _______________________event.duration;\n    eventListenersForStep.forEach(chartSetup => chartSetup({\n      chart: ____________________chartInstance,\n      initial: _______________________event.initial,\n      numSteps: eventDuration,\n      currentStep: Math.min(_currentStepIndex - _______________________event.start, eventDuration)\n    }));\n  }\n  _refresh() {\n    if (!this._request) {\n      this._running = true;\n      this._request = notifyListeners.call(window, () => {\n        this._update();\n        this._request = null;\n        if (this._running) {\n          this._refresh();\n        }\n      });\n    }\n  }\n  _update(currentTime = Date.now()) {\n    let inactiveItemsCount = 0;\n    this._charts.forEach((__animationContext, canvasRenderer) => {\n      if (!__animationContext.running || !__animationContext.items.length) {\n        return;\n      }\n      const itemsList = __animationContext.items;\n      let animationItem;\n      let lastIndex = itemsList.length - 1;\n      let hasActiveItems = false;\n      for (; lastIndex >= 0; --lastIndex) {\n        animationItem = itemsList[lastIndex];\n        if (animationItem._active) {\n          if (animationItem._total > __animationContext.duration) {\n            __animationContext.duration = animationItem._total;\n          }\n          animationItem.tick(currentTime);\n          hasActiveItems = true;\n        } else {\n          itemsList[lastIndex] = itemsList[itemsList.length - 1];\n          itemsList.pop();\n        }\n      }\n      if (hasActiveItems) {\n        canvasRenderer.draw();\n        this._notify(canvasRenderer, __animationContext, currentTime, \"progress\");\n      }\n      if (!itemsList.length) {\n        __animationContext.running = false;\n        this._notify(canvasRenderer, __animationContext, currentTime, \"complete\");\n        __animationContext.initial = false;\n      }\n      inactiveItemsCount += itemsList.length;\n    });\n    this._lastDate = currentTime;\n    if (inactiveItemsCount === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(___animationType) {\n    const _chartsMap = this._charts;\n    let _animationData = _chartsMap.get(___animationType);\n    if (!_animationData) {\n      _animationData = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      _chartsMap.set(___animationType, _animationData);\n    }\n    return _animationData;\n  }\n  listen(_animationType, eventIndex, animationListener) {\n    this._getAnims(_animationType).listeners[eventIndex].push(animationListener);\n  }\n  add(animationTimestamp, __animationItems) {\n    if (__animationItems && __animationItems.length) {\n      this._getAnims(animationTimestamp).items.push(...__animationItems);\n    }\n  }\n  has(animationType) {\n    return this._getAnims(animationType).items.length > 0;\n  }\n  start(__chartId) {\n    const ___chart = this._charts.get(__chartId);\n    if (___chart) {\n      ___chart.running = true;\n      ___chart.start = Date.now();\n      ___chart.duration = ___chart.items.reduce((maxDuration, elementDuration) => Math.max(maxDuration, elementDuration._duration), 0);\n      this._refresh();\n    }\n  }\n  running(_chartId) {\n    if (!this._running) {\n      return false;\n    }\n    const chartInfo = this._charts.get(_chartId);\n    return !!chartInfo && !!chartInfo.running && !!chartInfo.items.length;\n  }\n  stop(___chartId) {\n    const _______________________________chartData = this._charts.get(___chartId);\n    if (!_______________________________chartData || !_______________________________chartData.items.length) {\n      return;\n    }\n    const chartItems = _______________________________chartData.items;\n    let ________________________________________________index = chartItems.length - 1;\n    for (; ________________________________________________index >= 0; --________________________________________________index) {\n      chartItems[________________________________________________index].cancel();\n    }\n    _______________________________chartData.items = [];\n    this._notify(___chartId, _______________________________chartData, Date.now(), \"complete\");\n  }\n  remove(chartToRemove) {\n    return this._charts.delete(chartToRemove);\n  }\n}\nvar animationControllerInstance = new AnimationController();\nconst defaultColor = \"transparent\";\nconst animationFunctions = {\n  boolean: (__thresholdValue, ___thresholdValue, ____thresholdValue) => ____thresholdValue > 0.5 ? ___thresholdValue : __thresholdValue,\n  color(baseColor, secondaryColor, mixingRatio) {\n    const _baseColor = colorParser(baseColor || defaultColor);\n    const isSecondColorValid = _baseColor.valid && colorParser(secondaryColor || defaultColor);\n    if (isSecondColorValid && isSecondColorValid.valid) {\n      return isSecondColorValid.mix(_baseColor, mixingRatio).hexString();\n    } else {\n      return secondaryColor;\n    }\n  },\n  number: (initialValue, endTime, interpolationFactor) => initialValue + (endTime - initialValue) * interpolationFactor\n};\nclass ___AnimationController {\n  constructor(_animationConfig, animationSource, targetPropertyIndex, toAnimationOptions) {\n    const targetAnimationProperty = animationSource[targetPropertyIndex];\n    toAnimationOptions = animationOptions([_animationConfig.to, toAnimationOptions, targetAnimationProperty, _animationConfig.from]);\n    const fromAnimationOptions = animationOptions([_animationConfig.from, targetAnimationProperty, toAnimationOptions]);\n    this._active = true;\n    this._fn = _animationConfig.fn || animationFunctions[_animationConfig.type || typeof fromAnimationOptions];\n    this._easing = currentStepIndex[_animationConfig.easing] || currentStepIndex.linear;\n    this._start = Math.floor(Date.now() + (_animationConfig.delay || 0));\n    this._duration = this._total = Math.floor(_animationConfig.duration);\n    this._loop = !!_animationConfig.loop;\n    this._target = animationSource;\n    this._prop = targetPropertyIndex;\n    this._from = fromAnimationOptions;\n    this._to = toAnimationOptions;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(animationFrame, currentAnimationProgress, currentTimestamp) {\n    if (this._active) {\n      this._notify(false);\n      const targetPropertyValue = this._target[this._prop];\n      const _elapsedTime = currentTimestamp - this._start;\n      const remainingDuration = this._duration - _elapsedTime;\n      this._start = currentTimestamp;\n      this._duration = Math.floor(Math.max(remainingDuration, animationFrame.duration));\n      this._total += _elapsedTime;\n      this._loop = !!animationFrame.loop;\n      this._to = animationOptions([animationFrame.to, currentAnimationProgress, targetPropertyValue, animationFrame.from]);\n      this._from = animationOptions([animationFrame.from, targetPropertyValue, currentAnimationProgress]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(____elapsedTime) {\n    const _____elapsedTime = ____elapsedTime - this._start;\n    const duration = this._duration;\n    const _____propertyKey = this._prop;\n    const ___initialValue = this._from;\n    const _isLooping = this._loop;\n    const ________targetValue = this._to;\n    let normalizedElapsedTime;\n    this._active = ___initialValue !== ________targetValue && (_isLooping || _____elapsedTime < duration);\n    if (!this._active) {\n      this._target[_____propertyKey] = ________targetValue;\n      this._notify(true);\n      return;\n    }\n    if (_____elapsedTime < 0) {\n      this._target[_____propertyKey] = ___initialValue;\n    } else {\n      normalizedElapsedTime = _____elapsedTime / duration % 2;\n      if (_isLooping && normalizedElapsedTime > 1) {\n        normalizedElapsedTime = 2 - normalizedElapsedTime;\n      } else {\n        normalizedElapsedTime = normalizedElapsedTime;\n      }\n      normalizedElapsedTime = this._easing(Math.min(1, Math.max(0, normalizedElapsedTime)));\n      this._target[_____propertyKey] = this._fn(___initialValue, ________targetValue, normalizedElapsedTime);\n    }\n  }\n  wait() {\n    const promiseQueue = this._promises ||= [];\n    return new Promise((resolveFunction, rejectCallback) => {\n      promiseQueue.push({\n        res: resolveFunction,\n        rej: rejectCallback\n      });\n    });\n  }\n  _notify(_______________________________________________index) {\n    const responseStatus = _______________________________________________index ? \"res\" : \"rej\";\n    const promiseArray = this._promises || [];\n    for (let ______________________________________________index = 0; ______________________________________________index < promiseArray.length; ______________________________________________index++) {\n      promiseArray[______________________________________________index][responseStatus]();\n    }\n  }\n}\nclass se {\n  constructor(__________________chartInstance, __configOptions) {\n    this._chart = __________________chartInstance;\n    this._properties = new Map();\n    this.configure(__configOptions);\n  }\n  configure(_animationStates) {\n    if (!currentAnimationIndex(_animationStates)) {\n      return;\n    }\n    const animationDurationKeys = Object.keys(animationDuration.animation);\n    const propertiesMap = this._properties;\n    Object.getOwnPropertyNames(_animationStates).forEach(currentState => {\n      const animatedData = _animationStates[currentState];\n      if (!currentAnimationIndex(animatedData)) {\n        return;\n      }\n      const animationProperties = {};\n      for (const animationProperty of animationDurationKeys) {\n        animationProperties[animationProperty] = animatedData[animationProperty];\n      }\n      (animatedChartItems(animatedData.properties) && animatedData.properties || [currentState]).forEach(____animationState => {\n        if (____animationState === currentState || !propertiesMap.has(____animationState)) {\n          propertiesMap.set(____animationState, animationProperties);\n        }\n      });\n    });\n  }\n  _animateOptions(_animationTarget, _______animationOptions) {\n    const ________animationOptions = _______animationOptions.options;\n    const _________animationOptions = optionsHandler(_animationTarget, ________animationOptions);\n    if (!_________animationOptions) {\n      return [];\n    }\n    const animationsList = this._createAnimations(_________animationOptions, ________animationOptions);\n    if (________animationOptions.$shared) {\n      fetchActivePromises(_animationTarget.options.$animations, ________animationOptions).then(() => {\n        _animationTarget.options = ________animationOptions;\n      }, () => {});\n    }\n    return animationsList;\n  }\n  _createAnimations(t, e) {\n    const i = this._properties;\n    const s = [];\n    const n = t.$animations ||= {};\n    const o = Object.keys(e);\n    const a = Date.now();\n    let reverseIndex;\n    for (reverseIndex = o.length - 1; reverseIndex >= 0; --reverseIndex) {\n      const _item = o[reverseIndex];\n      if (_item.charAt(0) === \"$\") {\n        continue;\n      }\n      if (_item === \"options\") {\n        s.push(...this._animateOptions(t, e));\n        continue;\n      }\n      const valueForKey = e[_item];\n      let animationInstance = n[_item];\n      const animationDetails = i.get(_item);\n      if (animationInstance) {\n        if (animationDetails && animationInstance.active()) {\n          animationInstance.update(animationDetails, valueForKey, a);\n          continue;\n        }\n        animationInstance.cancel();\n      }\n      if (animationDetails && animationDetails.duration) {\n        n[_item] = animationInstance = new ___AnimationController(animationDetails, t, _item, valueForKey);\n        s.push(animationInstance);\n      } else {\n        t[_item] = valueForKey;\n      }\n    }\n    return s;\n  }\n  update(_____targetObject, ____animationProperties) {\n    if (this._properties.size === 0) {\n      Object.assign(_____targetObject, ____animationProperties);\n      return;\n    }\n    const createdAnimations = this._createAnimations(_____targetObject, ____animationProperties);\n    if (createdAnimations.length) {\n      animationControllerInstance.add(this._chart, createdAnimations);\n      return true;\n    } else {\n      return undefined;\n    }\n  }\n}\nfunction fetchActivePromises(_targetObject, itemObject) {\n  const activePromiseWaits = [];\n  const itemObjectKeys = Object.keys(itemObject);\n  for (let __itemIndex = 0; __itemIndex < itemObjectKeys.length; __itemIndex++) {\n    const targetObjectValue = _targetObject[itemObjectKeys[__itemIndex]];\n    if (targetObjectValue && targetObjectValue.active()) {\n      activePromiseWaits.push(targetObjectValue.wait());\n    }\n  }\n  return Promise.all(activePromiseWaits);\n}\nfunction optionsHandler(targetObject, userProvidedOptions) {\n  if (!userProvidedOptions) {\n    return;\n  }\n  let _currentOptions = targetObject.options;\n  if (_currentOptions) {\n    if (_currentOptions.$shared) {\n      targetObject.options = _currentOptions = Object.assign({}, _currentOptions, {\n        $shared: false,\n        $animations: {}\n      });\n    }\n    return _currentOptions;\n  }\n  targetObject.options = userProvidedOptions;\n}\nfunction _calculateRange(inputConfig, referenceValue) {\n  const inputOptions = inputConfig && inputConfig.options || {};\n  const isReversed = inputOptions.reverse;\n  const _minValue = inputOptions.min === undefined ? referenceValue : 0;\n  const maxRangeValue = inputOptions.max === undefined ? referenceValue : 0;\n  return {\n    start: isReversed ? maxRangeValue : _minValue,\n    end: isReversed ? _minValue : maxRangeValue\n  };\n}\nfunction calculateBoundingBox(__targetElement, referenceElement, isCalculationEnabled) {\n  if (isCalculationEnabled === false) {\n    return false;\n  }\n  const targetElementRange = _calculateRange(__targetElement, isCalculationEnabled);\n  const referenceRange = _calculateRange(referenceElement, isCalculationEnabled);\n  return {\n    top: referenceRange.end,\n    right: targetElementRange.end,\n    bottom: referenceRange.start,\n    left: targetElementRange.start\n  };\n}\nfunction topBoundary(animationBoundary) {\n  let topBoundaryValue;\n  let _rightBoundary;\n  let animationBoundaryBottom;\n  let leftBoundary;\n  if (currentAnimationIndex(animationBoundary)) {\n    topBoundaryValue = animationBoundary.top;\n    _rightBoundary = animationBoundary.right;\n    animationBoundaryBottom = animationBoundary.bottom;\n    leftBoundary = animationBoundary.left;\n  } else {\n    topBoundaryValue = _rightBoundary = animationBoundaryBottom = leftBoundary = animationBoundary;\n  }\n  return {\n    top: topBoundaryValue,\n    right: _rightBoundary,\n    bottom: animationBoundaryBottom,\n    left: leftBoundary,\n    disabled: animationBoundary === false\n  };\n}\nfunction getDatasetIndices(datasetMetas, _________datasetMeta) {\n  const datasetIndices = [];\n  const sortedDatasetMetas = datasetMetas._getSortedDatasetMetas(_________datasetMeta);\n  let ___________________________________________currentIndex;\n  let sortedDatasetMetaCount;\n  ___________________________________________currentIndex = 0;\n  sortedDatasetMetaCount = sortedDatasetMetas.length;\n  for (; ___________________________________________currentIndex < sortedDatasetMetaCount; ++___________________________________________currentIndex) {\n    datasetIndices.push(sortedDatasetMetas[___________________________________________currentIndex].index);\n  }\n  return datasetIndices;\n}\nfunction updateCurrentValue(data, currentValue, __________index, settings = {}) {\n  const dataKeys = data.keys;\n  const isSingleMode = settings.mode === \"single\";\n  let indexCounter;\n  let numKeys;\n  let numericKey;\n  let currentValueAdjustment;\n  if (currentValue !== null) {\n    indexCounter = 0;\n    numKeys = dataKeys.length;\n    for (; indexCounter < numKeys; ++indexCounter) {\n      numericKey = +dataKeys[indexCounter];\n      if (numericKey === __________index) {\n        if (settings.all) {\n          continue;\n        }\n        break;\n      }\n      currentValueAdjustment = data.values[numericKey];\n      if (chartUpdateTrigger(currentValueAdjustment) && (isSingleMode || currentValue === 0 || isPathClosed(currentValue) === isPathClosed(currentValueAdjustment))) {\n        currentValue += currentValueAdjustment;\n      }\n    }\n    return currentValue;\n  }\n}\nfunction transformDataToKeyValuePairs(_dataObject) {\n  const _dataKeys = Object.keys(_dataObject);\n  const keyValuePairArray = new Array(_dataKeys.length);\n  let _____________________________________________________________index;\n  let dataKeysCount;\n  let __key;\n  _____________________________________________________________index = 0;\n  dataKeysCount = _dataKeys.length;\n  for (; _____________________________________________________________index < dataKeysCount; ++_____________________________________________________________index) {\n    __key = _dataKeys[_____________________________________________________________index];\n    keyValuePairArray[_____________________________________________________________index] = {\n      x: __key,\n      y: _dataObject[__key]\n    };\n  }\n  return keyValuePairArray;\n}\nfunction isStackedOption(isStacked, stackedOption) {\n  const isStackedOptionEnabled = isStacked && isStacked.options.stacked;\n  return isStackedOptionEnabled || isStackedOptionEnabled === undefined && stackedOption.stack !== undefined;\n}\nfunction getFormattedId(____targetElement, __________element, _inputObject) {\n  return `${____targetElement.id}.${__________element.id}.${_inputObject.stack || _inputObject.type}`;\n}\nfunction getUserBoundsWithInfiniteFallback(userBounds) {\n  const {\n    min: minUserBound,\n    max: maxBound,\n    minDefined: __isMinDefined,\n    maxDefined: isMaxDefined\n  } = userBounds.getUserBounds();\n  return {\n    min: __isMinDefined ? minUserBound : Number.NEGATIVE_INFINITY,\n    max: isMaxDefined ? maxBound : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateNestedObject(__targetObject, _propertyKey, __propertyKey) {\n  const nestedObject = __targetObject[_propertyKey] ||= {};\n  return nestedObject[__propertyKey] ||= {};\n}\nfunction getMatchingMetaIndex(metaValues, visibleMeta, isPositiveCondition, visibleMetaSearch) {\n  for (const matchingMetaItem of visibleMeta.getMatchingVisibleMetas(visibleMetaSearch).reverse()) {\n    const metaValue = metaValues[matchingMetaItem.index];\n    if (isPositiveCondition && metaValue > 0 || !isPositiveCondition && metaValue < 0) {\n      return matchingMetaItem.index;\n    }\n  }\n  return null;\n}\nfunction processChartData(________chartData, dataArray) {\n  const {\n    chart: ______chartConfig,\n    _cachedMeta: cachedMetaData\n  } = ________chartData;\n  const stacksCache = ______chartConfig._stacks ||= {};\n  const {\n    iScale: _iScale,\n    vScale: verticalScale,\n    index: ____________dataIndex\n  } = cachedMetaData;\n  const horizontalAxis = _iScale.axis;\n  const _verticalScaleAxis = verticalScale.axis;\n  const formattedId = getFormattedId(_iScale, verticalScale, cachedMetaData);\n  const dataArrayLength = dataArray.length;\n  let stackedDataItem;\n  for (let _____________dataIndex = 0; _____________dataIndex < dataArrayLength; ++_____________dataIndex) {\n    const dataItem = dataArray[_____________dataIndex];\n    const {\n      [horizontalAxis]: valueForProcessing,\n      [_verticalScaleAxis]: dataValue\n    } = dataItem;\n    stackedDataItem = (dataItem._stacks ||= {})[_verticalScaleAxis] = getOrCreateNestedObject(stacksCache, formattedId, valueForProcessing);\n    stackedDataItem[____________dataIndex] = dataValue;\n    stackedDataItem._top = getMatchingMetaIndex(stackedDataItem, verticalScale, true, cachedMetaData.type);\n    stackedDataItem._bottom = getMatchingMetaIndex(stackedDataItem, verticalScale, false, cachedMetaData.type);\n    (stackedDataItem._visualValues ||= {})[____________dataIndex] = dataValue;\n  }\n}\nfunction getFirstMatchingScale(scaleKey, ____axisIdentifier) {\n  const scalesCollection = scaleKey.scales;\n  return Object.keys(scalesCollection).filter(axisScaleIndex => scalesCollection[axisScaleIndex].axis === ____axisIdentifier).shift();\n}\nfunction ____tooltipHandler(_tooltipData, __________________datasetIndex) {\n  return tooltipHandler(_tooltipData, {\n    active: false,\n    dataset: undefined,\n    datasetIndex: __________________datasetIndex,\n    index: __________________datasetIndex,\n    mode: \"default\",\n    type: \"dataset\"\n  });\n}\nfunction ___tooltipHandler(tooltipData, ________dataIndex, tooltipElement) {\n  return tooltipHandler(tooltipData, {\n    active: false,\n    dataIndex: ________dataIndex,\n    parsed: undefined,\n    raw: undefined,\n    element: tooltipElement,\n    index: ________dataIndex,\n    mode: \"default\",\n    type: \"data\"\n  });\n}\nfunction removeStackedValues(____________chartData, parsedDataArray) {\n  const controllerIndex = ____________chartData.controller.index;\n  const verticalScaleAxis = ____________chartData.vScale && ____________chartData.vScale.axis;\n  if (verticalScaleAxis) {\n    parsedDataArray = parsedDataArray || ____________chartData._parsed;\n    for (const stackItem of parsedDataArray) {\n      const stackData = stackItem._stacks;\n      if (!stackData || stackData[verticalScaleAxis] === undefined || stackData[verticalScaleAxis][controllerIndex] === undefined) {\n        return;\n      }\n      delete stackData[verticalScaleAxis][controllerIndex];\n      if (stackData[verticalScaleAxis]._visualValues !== undefined && stackData[verticalScaleAxis]._visualValues[controllerIndex] !== undefined) {\n        delete stackData[verticalScaleAxis]._visualValues[controllerIndex];\n      }\n    }\n  }\n}\nconst isResetOrNone = resetState => resetState === \"reset\" || resetState === \"none\";\nconst isRequestActive = (____targetObject, __isValid) => __isValid ? ____targetObject : Object.assign({}, ____targetObject);\nconst getNormalizedAnimationData = (__isVisible, _____dataset, __________________________________datasetIndex) => __isVisible && !_____dataset.hidden && _____dataset._stacked && {\n  keys: getDatasetIndices(__________________________________datasetIndex, true),\n  values: null\n};\nclass Se {\n  static defaults = {};\n  static datasetElementType = null;\n  static dataElementType = null;\n  constructor(t, e) {\n    this.chart = t;\n    this._ctx = t.ctx;\n    this.index = e;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n    this.initialize();\n  }\n  initialize() {\n    const ________________cachedMeta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    ________________cachedMeta._stacked = isStackedOption(________________cachedMeta.vScale, ________________cachedMeta);\n    this.addElements();\n    if (this.options.fill && !this.chart.isPluginEnabled(\"filler\")) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n  updateIndex(newIndex) {\n    if (this.index !== newIndex) {\n      removeStackedValues(this._cachedMeta);\n    }\n    this.index = newIndex;\n  }\n  linkScales() {\n    const ____________________________chartInstance = this.chart;\n    const _____________________cachedMeta = this._cachedMeta;\n    const ___________dataset = this.getDataset();\n    const retrieveAxisID = (typeIndicator, _result, defaultValue, _status) => typeIndicator === \"x\" ? _result : typeIndicator === \"r\" ? _status : defaultValue;\n    const xAxisID = _____________________cachedMeta.xAxisID = chartAnimationRunning(___________dataset.xAxisID, getFirstMatchingScale(____________________________chartInstance, \"x\"));\n    const yAxisID = _____________________cachedMeta.yAxisID = chartAnimationRunning(___________dataset.yAxisID, getFirstMatchingScale(____________________________chartInstance, \"y\"));\n    const radialAxisID = _____________________cachedMeta.rAxisID = chartAnimationRunning(___________dataset.rAxisID, getFirstMatchingScale(____________________________chartInstance, \"r\"));\n    const __indexAxis = _____________________cachedMeta.indexAxis;\n    const indexAxisID = _____________________cachedMeta.iAxisID = retrieveAxisID(__indexAxis, xAxisID, yAxisID, radialAxisID);\n    const verticalAxisID = _____________________cachedMeta.vAxisID = retrieveAxisID(__indexAxis, yAxisID, xAxisID, radialAxisID);\n    _____________________cachedMeta.xScale = this.getScaleForId(xAxisID);\n    _____________________cachedMeta.yScale = this.getScaleForId(yAxisID);\n    _____________________cachedMeta.rScale = this.getScaleForId(radialAxisID);\n    _____________________cachedMeta.iScale = this.getScaleForId(indexAxisID);\n    _____________________cachedMeta.vScale = this.getScaleForId(verticalAxisID);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleId) {\n    return this.chart.scales[scaleId];\n  }\n  _getOtherScale(_inputScale) {\n    const ___cachedMeta = this._cachedMeta;\n    if (_inputScale === ___cachedMeta.iScale) {\n      return ___cachedMeta.vScale;\n    } else {\n      return ___cachedMeta.iScale;\n    }\n  }\n  reset() {\n    this._update(\"reset\");\n  }\n  _destroy() {\n    const __cachedMeta = this._cachedMeta;\n    if (this._data) {\n      requestAnimationFrameId(this._data, this);\n    }\n    if (__cachedMeta._stacked) {\n      removeStackedValues(__cachedMeta);\n    }\n  }\n  _dataCheck() {\n    const ________dataset = this.getDataset();\n    const datasetData = ________dataset.data ||= [];\n    const previousData = this._data;\n    if (currentAnimationIndex(datasetData)) {\n      this._data = transformDataToKeyValuePairs(datasetData);\n    } else if (previousData !== datasetData) {\n      if (previousData) {\n        requestAnimationFrameId(previousData, this);\n        const ____dataset = this._cachedMeta;\n        removeStackedValues(____dataset);\n        ____dataset._parsed = [];\n      }\n      if (datasetData && Object.isExtensible(datasetData)) {\n        requestAnimationFrameID(datasetData, this);\n      }\n      this._syncList = [];\n      this._data = datasetData;\n    }\n  }\n  addElements() {\n    const ____cachedMeta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      ____cachedMeta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(elementsToUpdate) {\n    const _____________cachedMeta = this._cachedMeta;\n    const __currentDataset = this.getDataset();\n    let isStackedUpdated = false;\n    this._dataCheck();\n    const previousStackedValue = _____________cachedMeta._stacked;\n    _____________cachedMeta._stacked = isStackedOption(_____________cachedMeta.vScale, _____________cachedMeta);\n    if (_____________cachedMeta.stack !== __currentDataset.stack) {\n      isStackedUpdated = true;\n      removeStackedValues(_____________cachedMeta);\n      _____________cachedMeta.stack = __currentDataset.stack;\n    }\n    this._resyncElements(elementsToUpdate);\n    if (isStackedUpdated || previousStackedValue !== _____________cachedMeta._stacked) {\n      processChartData(this, _____________cachedMeta._parsed);\n    }\n  }\n  configure() {\n    const _________chartConfig = this.chart.config;\n    const datasetScopeKeys = _________chartConfig.datasetScopeKeys(this._type);\n    const _optionScopes = _________chartConfig.getOptionScopes(this.getDataset(), datasetScopeKeys, true);\n    this.options = _________chartConfig.createResolver(_optionScopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(t, e) {\n    const {\n      _cachedMeta: i,\n      _data: s\n    } = this;\n    const {\n      iScale: o,\n      _stacked: r\n    } = i;\n    const h = o.axis;\n    let __________________index;\n    let c;\n    let d;\n    let u = t === 0 && e === s.length || i._sorted;\n    let g = t > 0 && i._parsed[t - 1];\n    if (this._parsing === false) {\n      i._parsed = s;\n      i._sorted = true;\n      d = s;\n    } else {\n      if (animatedChartItems(s[t])) {\n        d = this.parseArrayData(i, s, t, e);\n      } else if (currentAnimationIndex(s[t])) {\n        d = this.parseObjectData(i, s, t, e);\n      } else {\n        d = this.parsePrimitiveData(i, s, t, e);\n      }\n      const iScale = () => c[h] === null || g && c[h] < g[h];\n      for (__________________index = 0; __________________index < e; ++__________________index) {\n        i._parsed[__________________index + t] = c = d[__________________index];\n        if (u) {\n          if (iScale()) {\n            u = false;\n          }\n          g = c;\n        }\n      }\n      i._sorted = u;\n    }\n    if (r) {\n      processChartData(this, d);\n    }\n  }\n  parsePrimitiveData(dataScales, _________________________inputValue, baseIndex, _____arrayLength) {\n    const {\n      iScale: ____iScale,\n      vScale: ____valueScale\n    } = dataScales;\n    const _inputAxis = ____iScale.axis;\n    const valueScaleAxis = ____valueScale.axis;\n    const iScaleLabels = ____iScale.getLabels();\n    const isSameScale = ____iScale === ____valueScale;\n    const ___parsedDataArray = new Array(_____arrayLength);\n    let ____________________________index;\n    let _______inputArrayLength;\n    let _dataArrayIndex;\n    ____________________________index = 0;\n    _______inputArrayLength = _____arrayLength;\n    for (; ____________________________index < _______inputArrayLength; ++____________________________index) {\n      _dataArrayIndex = ____________________________index + baseIndex;\n      ___parsedDataArray[____________________________index] = {\n        [_inputAxis]: isSameScale || ____iScale.parse(iScaleLabels[_dataArrayIndex], _dataArrayIndex),\n        [valueScaleAxis]: ____valueScale.parse(_________________________inputValue[_dataArrayIndex], _dataArrayIndex)\n      };\n    }\n    return ___parsedDataArray;\n  }\n  parseArrayData(_data, ____dataArray, dataArrayIndex, ___arrayLength) {\n    const {\n      xScale: xScaleParser,\n      yScale: yScaleParser\n    } = _data;\n    const __parsedDataArray = new Array(___arrayLength);\n    let _________________________index;\n    let ____arrayLength;\n    let dataArrayIndexAdjusted;\n    let _________dataPoint;\n    _________________________index = 0;\n    ____arrayLength = ___arrayLength;\n    for (; _________________________index < ____arrayLength; ++_________________________index) {\n      dataArrayIndexAdjusted = _________________________index + dataArrayIndex;\n      _________dataPoint = ____dataArray[dataArrayIndexAdjusted];\n      __parsedDataArray[_________________________index] = {\n        x: xScaleParser.parse(_________dataPoint[0], dataArrayIndexAdjusted),\n        y: yScaleParser.parse(_________dataPoint[1], dataArrayIndexAdjusted)\n      };\n    }\n    return __parsedDataArray;\n  }\n  parseObjectData(___dataObject, _____dataArray, _________startIndex, ______arrayLength) {\n    const {\n      xScale: _xScaleParser,\n      yScale: _yScaleParser\n    } = ___dataObject;\n    const {\n      xAxisKey = \"x\",\n      yAxisKey = \"y\"\n    } = this._parsing;\n    const ____parsedDataArray = new Array(______arrayLength);\n    let loopIndex;\n    let _______arrayLength;\n    let __dataArrayIndex;\n    let dataArrayElement;\n    loopIndex = 0;\n    _______arrayLength = ______arrayLength;\n    for (; loopIndex < _______arrayLength; ++loopIndex) {\n      __dataArrayIndex = loopIndex + _________startIndex;\n      dataArrayElement = _____dataArray[__dataArrayIndex];\n      ____parsedDataArray[loopIndex] = {\n        x: _xScaleParser.parse(_requestAnimationFrameId(dataArrayElement, xAxisKey), __dataArrayIndex),\n        y: _yScaleParser.parse(_requestAnimationFrameId(dataArrayElement, yAxisKey), __dataArrayIndex)\n      };\n    }\n    return ____parsedDataArray;\n  }\n  getParsed(_parsedDataIndex) {\n    return this._cachedMeta._parsed[_parsedDataIndex];\n  }\n  getDataElement(________________dataIndex) {\n    return this._cachedMeta.data[________________dataIndex];\n  }\n  applyStack(currentStackAxis, ______eventData, visualUpdateMode) {\n    const _______________________chartInstance = this.chart;\n    const ___cachedMetaData = this._cachedMeta;\n    const currentStackValue = ______eventData[currentStackAxis.axis];\n    return updateCurrentValue({\n      keys: getDatasetIndices(_______________________chartInstance, true),\n      values: ______eventData._stacks[currentStackAxis.axis]._visualValues\n    }, currentStackValue, ___cachedMetaData.index, {\n      mode: visualUpdateMode\n    });\n  }\n  updateRangeFromParsed(rangeUpdate, parsedInput, ___________inputData, _stackData) {\n    const parsedAxisValue = ___________inputData[parsedInput.axis];\n    let currentAxisValue = parsedAxisValue === null ? NaN : parsedAxisValue;\n    const stackDataForAxis = _stackData && ___________inputData._stacks[parsedInput.axis];\n    if (_stackData && stackDataForAxis) {\n      _stackData.values = stackDataForAxis;\n      currentAxisValue = updateCurrentValue(_stackData, parsedAxisValue, this._cachedMeta.index);\n    }\n    rangeUpdate.min = Math.min(rangeUpdate.min, currentAxisValue);\n    rangeUpdate.max = Math.max(rangeUpdate.max, currentAxisValue);\n  }\n  getMinMax(t, e) {\n    const i = this._cachedMeta;\n    const s = i._parsed;\n    const shouldContinueIteration = i._sorted && t === i.iScale;\n    const o = s.length;\n    const a = this._getOtherScale(t);\n    const r = getNormalizedAnimationData(e, i, this.chart);\n    const h = {\n      min: Number.POSITIVE_INFINITY,\n      max: Number.NEGATIVE_INFINITY\n    };\n    const {\n      min: l,\n      max: c\n    } = getUserBoundsWithInfiniteFallback(a);\n    let ___________________________index;\n    let g;\n    function isChartUpdateNeeded() {\n      g = s[___________________________index];\n      const __axisValue = g[a.axis];\n      return !chartUpdateTrigger(g[t.axis]) || l > __axisValue || c < __axisValue;\n    }\n    for (___________________________index = 0; ___________________________index < o && (isChartUpdateNeeded() || (this.updateRangeFromParsed(h, t, g, r), !shouldContinueIteration)); ++___________________________index) {\n      ;\n    }\n    if (shouldContinueIteration) {\n      for (___________________________index = o - 1; ___________________________index >= 0; --___________________________index) {\n        if (!isChartUpdateNeeded()) {\n          this.updateRangeFromParsed(h, t, g, r);\n          break;\n        }\n      }\n    }\n    return h;\n  }\n  getAllParsedValues(___axisValue) {\n    const parsedValues = this._cachedMeta._parsed;\n    const parsedValuesList = [];\n    let _______________________________________index;\n    let parsedValuesCount;\n    let parsedValueForAxis;\n    _______________________________________index = 0;\n    parsedValuesCount = parsedValues.length;\n    for (; _______________________________________index < parsedValuesCount; ++_______________________________________index) {\n      parsedValueForAxis = parsedValues[_______________________________________index][___axisValue.axis];\n      if (chartUpdateTrigger(parsedValueForAxis)) {\n        parsedValuesList.push(parsedValueForAxis);\n      }\n    }\n    return parsedValuesList;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(_______parsedData) {\n    const _____cachedMetadata = this._cachedMeta;\n    const __iScale = _____cachedMetadata.iScale;\n    const __valueScale = _____cachedMetadata.vScale;\n    const parsedDataValues = this.getParsed(_______parsedData);\n    return {\n      label: __iScale ? \"\" + __iScale.getLabelForValue(parsedDataValues[__iScale.axis]) : \"\",\n      value: __valueScale ? \"\" + __valueScale.getLabelForValue(parsedDataValues[__valueScale.axis]) : \"\"\n    };\n  }\n  _update(updateType) {\n    const _____cachedMeta = this._cachedMeta;\n    this.update(updateType || \"default\");\n    _____cachedMeta._clip = topBoundary(chartAnimationRunning(this.options.clip, calculateBoundingBox(_____cachedMeta.xScale, _____cachedMeta.yScale, this.getMaxOverflow())));\n  }\n  update(timeElapsed) {}\n  draw() {\n    const ______________________________canvasContext = this._ctx;\n    const _____________________________chartInstance = this.chart;\n    const drawIndex = this._cachedMeta;\n    const datasetItems = drawIndex.data || [];\n    const ____chartArea = _____________________________chartInstance.chartArea;\n    const ______activeElements = [];\n    const drawStartIndex = this._drawStart || 0;\n    const _drawCount = this._drawCount || datasetItems.length - drawStartIndex;\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let _________________index;\n    if (drawIndex.dataset) {\n      drawIndex.dataset.draw(______________________________canvasContext, ____chartArea, drawStartIndex, _drawCount);\n    }\n    _________________index = drawStartIndex;\n    for (; _________________index < drawStartIndex + _drawCount; ++_________________index) {\n      const _____element = datasetItems[_________________index];\n      if (!_____element.hidden) {\n        if (_____element.active && drawActiveElementsOnTop) {\n          ______activeElements.push(_____element);\n        } else {\n          _____element.draw(______________________________canvasContext, ____chartArea);\n        }\n      }\n    }\n    for (_________________index = 0; _________________index < ______activeElements.length; ++_________________index) {\n      ______activeElements[_________________index].draw(______________________________canvasContext, ____chartArea);\n    }\n  }\n  getStyle(___dataElementIndex, _isElementActive) {\n    const styleState = _isElementActive ? \"active\" : \"default\";\n    if (___dataElementIndex === undefined && this._cachedMeta.dataset) {\n      return this.resolveDatasetElementOptions(styleState);\n    } else {\n      return this.resolveDataElementOptions(___dataElementIndex || 0, styleState);\n    }\n  }\n  getContext(_______dataPointIndex, _isActive, tooltipMode) {\n    const __________dataset = this.getDataset();\n    let tooltipContext;\n    if (_______dataPointIndex >= 0 && _______dataPointIndex < this._cachedMeta.data.length) {\n      const ___dataPoint = this._cachedMeta.data[_______dataPointIndex];\n      tooltipContext = ___dataPoint.$context ||= ___tooltipHandler(this.getContext(), _______dataPointIndex, ___dataPoint);\n      tooltipContext.parsed = this.getParsed(_______dataPointIndex);\n      tooltipContext.raw = __________dataset.data[_______dataPointIndex];\n      tooltipContext.index = tooltipContext.dataIndex = _______dataPointIndex;\n    } else {\n      tooltipContext = this.$context ||= ____tooltipHandler(this.chart.getContext(), this.index);\n      tooltipContext.dataset = __________dataset;\n      tooltipContext.index = tooltipContext.datasetIndex = this.index;\n    }\n    tooltipContext.active = !!_isActive;\n    tooltipContext.mode = tooltipMode;\n    return tooltipContext;\n  }\n  resolveDatasetElementOptions(datasetElementOptions) {\n    return this._resolveElementOptions(this.datasetElementType.id, datasetElementOptions);\n  }\n  resolveDataElementOptions(__dataElementOptions, __elementOptions) {\n    return this._resolveElementOptions(this.dataElementType.id, __elementOptions, __dataElementOptions);\n  }\n  _resolveElementOptions(___elementId, optionState = \"default\", _________elementIndex) {\n    const isActiveOptionState = optionState === \"active\";\n    const __cachedDataOptions = this._cachedDataOpts;\n    const optionKey = ___elementId + \"-\" + optionState;\n    const cachedElementOptions = __cachedDataOptions[optionKey];\n    const isOptionSharingEnabled = this.enableOptionSharing && canvasContext(_________elementIndex);\n    if (cachedElementOptions) {\n      return isRequestActive(cachedElementOptions, isOptionSharingEnabled);\n    }\n    const ____________chartConfig = this.chart.config;\n    const datasetElementScopeKeys = ____________chartConfig.datasetElementScopeKeys(this._type, ___elementId);\n    const optionHoverData = isActiveOptionState ? [`${___elementId}Hover`, \"hover\", ___elementId, \"\"] : [___elementId, \"\"];\n    const __optionScopes = ____________chartConfig.getOptionScopes(this.getDataset(), datasetElementScopeKeys);\n    const _animationDurationKeys = Object.keys(animationDuration.elements[___elementId]);\n    const resolvedOptions = ____________chartConfig.resolveNamedOptions(__optionScopes, _animationDurationKeys, () => this.getContext(_________elementIndex, isActiveOptionState, optionState), optionHoverData);\n    if (resolvedOptions.$shared) {\n      resolvedOptions.$shared = isOptionSharingEnabled;\n      __cachedDataOptions[optionKey] = Object.freeze(isRequestActive(resolvedOptions, isOptionSharingEnabled));\n    }\n    return resolvedOptions;\n  }\n  _resolveAnimations(______animationContext, ___animationKey, _______animationContext) {\n    const ___________________________chartInstance = this.chart;\n    const _cachedDataOptions = this._cachedDataOpts;\n    const _animationOptionKey = `animation-${___animationKey}`;\n    const ____________animationOptions = _cachedDataOptions[_animationOptionKey];\n    if (____________animationOptions) {\n      return ____________animationOptions;\n    }\n    let ___animationResolver;\n    if (___________________________chartInstance.options.animation !== false) {\n      const ____chartInstance = this.chart.config;\n      const cachedDataOptions = ____chartInstance.datasetAnimationScopeKeys(this._type, ___animationKey);\n      const animationOptionKey = ____chartInstance.getOptionScopes(this.getDataset(), cachedDataOptions);\n      ___animationResolver = ____chartInstance.createResolver(animationOptionKey, this.getContext(______animationContext, _______animationContext, ___animationKey));\n    }\n    const ____animationResolver = new se(___________________________chartInstance, ___animationResolver && ___animationResolver.animations);\n    if (___animationResolver && ___animationResolver._cacheable) {\n      _cachedDataOptions[_animationOptionKey] = Object.freeze(____animationResolver);\n    }\n    return ____animationResolver;\n  }\n  getSharedOptions(sharedOptions) {\n    if (sharedOptions.$shared) {\n      return this._sharedOptions ||= Object.assign({}, sharedOptions);\n    }\n  }\n  includeOptions(optionParameter, ______options) {\n    return !______options || isResetOrNone(optionParameter) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(_______dataElement, _______________options) {\n    const resolvedDataOptions = this.resolveDataElementOptions(_______dataElement, _______________options);\n    const defaultSharedOptions = this._sharedOptions;\n    const resolvedSharedOptions = this.getSharedOptions(resolvedDataOptions);\n    const areOptionsIncluded = this.includeOptions(_______________options, resolvedSharedOptions) || resolvedSharedOptions !== defaultSharedOptions;\n    this.updateSharedOptions(resolvedSharedOptions, _______________options, resolvedDataOptions);\n    return {\n      sharedOptions: resolvedSharedOptions,\n      includeOptions: areOptionsIncluded\n    };\n  }\n  updateElement(_elementToUpdate, elementAnimations, elementUpdates, ______animationState) {\n    if (isResetOrNone(______animationState)) {\n      Object.assign(_elementToUpdate, elementUpdates);\n    } else {\n      this._resolveAnimations(elementAnimations, ______animationState).update(_elementToUpdate, elementUpdates);\n    }\n  }\n  updateSharedOptions(_sharedOptions, _________options, ________animationIndex) {\n    if (_sharedOptions && !isResetOrNone(_________options)) {\n      this._resolveAnimations(undefined, _________options).update(_sharedOptions, ________animationIndex);\n    }\n  }\n  _setStyle(styleObject, _elementStyle, _________animationIndex, isStyleActive) {\n    styleObject.active = isStyleActive;\n    const computedStyle = this.getStyle(_elementStyle, isStyleActive);\n    this._resolveAnimations(_elementStyle, _________animationIndex, isStyleActive).update(styleObject, {\n      options: !isStyleActive && this.getSharedOptions(computedStyle) || computedStyle\n    });\n  }\n  removeHoverStyle(__hoverElement, ___hoverElement, activeIndex) {\n    this._setStyle(__hoverElement, activeIndex, \"active\", false);\n  }\n  setHoverStyle(hoverElement, _hoverElement, hoverIndex) {\n    this._setStyle(hoverElement, hoverIndex, \"active\", true);\n  }\n  _removeDatasetHoverStyle() {\n    const cachedDataset = this._cachedMeta.dataset;\n    if (cachedDataset) {\n      this._setStyle(cachedDataset, undefined, \"active\", false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const ____________datasetMeta = this._cachedMeta.dataset;\n    if (____________datasetMeta) {\n      this._setStyle(____________datasetMeta, undefined, \"active\", true);\n    }\n  }\n  _resyncElements(_referenceElement) {\n    const dataCollection = this._data;\n    const _____cachedMetaData = this._cachedMeta.data;\n    for (const [syncItemKey, ___________event, callbackArgument] of this._syncList) {\n      this[syncItemKey](___________event, callbackArgument);\n    }\n    this._syncList = [];\n    const cachedMetaDataLength = _____cachedMetaData.length;\n    const dataCollectionLength = dataCollection.length;\n    const minElementCount = Math.min(dataCollectionLength, cachedMetaDataLength);\n    if (minElementCount) {\n      this.parse(0, minElementCount);\n    }\n    if (dataCollectionLength > cachedMetaDataLength) {\n      this._insertElements(cachedMetaDataLength, dataCollectionLength - cachedMetaDataLength, _referenceElement);\n    } else if (dataCollectionLength < cachedMetaDataLength) {\n      this._removeElements(dataCollectionLength, cachedMetaDataLength - dataCollectionLength);\n    }\n  }\n  _insertElements(startingIndex, numberOfElementsToInsert, shouldUpdateElements = true) {\n    const __________________cachedMeta = this._cachedMeta;\n    const _cachedDataArray = __________________cachedMeta.data;\n    const ________endIndex = startingIndex + numberOfElementsToInsert;\n    let ____________________________________________index;\n    const shiftElementsToRight = tempArray => {\n      tempArray.length += numberOfElementsToInsert;\n      ____________________________________________index = tempArray.length - 1;\n      for (; ____________________________________________index >= ________endIndex; ____________________________________________index--) {\n        tempArray[____________________________________________index] = tempArray[____________________________________________index - numberOfElementsToInsert];\n      }\n    };\n    shiftElementsToRight(_cachedDataArray);\n    ____________________________________________index = startingIndex;\n    for (; ____________________________________________index < ________endIndex; ++____________________________________________index) {\n      _cachedDataArray[____________________________________________index] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      shiftElementsToRight(__________________cachedMeta._parsed);\n    }\n    this.parse(startingIndex, numberOfElementsToInsert);\n    if (shouldUpdateElements) {\n      this.updateElements(_cachedDataArray, startingIndex, numberOfElementsToInsert, \"reset\");\n    }\n  }\n  updateElements(__time, elementToUpdate, ________________________________________________________index, elementStatus) {}\n  _removeElements(_______startIndex, _elementsToRemove) {\n    const ___cachedMetadata = this._cachedMeta;\n    if (this._parsing) {\n      const parsedElements = ___cachedMetadata._parsed.splice(_______startIndex, _elementsToRemove);\n      if (___cachedMetadata._stacked) {\n        removeStackedValues(___cachedMetadata, parsedElements);\n      }\n    }\n    ___cachedMetadata.data.splice(_______startIndex, _elementsToRemove);\n  }\n  _sync(_____eventData) {\n    if (this._parsing) {\n      this._syncList.push(_____eventData);\n    } else {\n      const [eventName, parsedItemIndex, dataField] = _____eventData;\n      this[eventName](parsedItemIndex, dataField);\n    }\n    this.chart._dataChanges.push([this.index, ..._____eventData]);\n  }\n  _onDataPush() {\n    const dataPushCount = arguments.length;\n    this._sync([\"_insertElements\", this.getDataset().data.length - dataPushCount, dataPushCount]);\n  }\n  _onDataPop() {\n    this._sync([\"_removeElements\", this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync([\"_removeElements\", 0, 1]);\n  }\n  _onDataSplice(dataSlice, ____eventData) {\n    if (____eventData) {\n      this._sync([\"_removeElements\", dataSlice, ____eventData]);\n    }\n    const argumentCount = arguments.length - 2;\n    if (argumentCount) {\n      this._sync([\"_insertElements\", dataSlice, argumentCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync([\"_insertElements\", 0, arguments.length]);\n  }\n}\nfunction getCachedBarChartData(_________chartInstance, metricKey) {\n  if (!_________chartInstance._cache.$bar) {\n    const _matchingVisibleMetas = _________chartInstance.getMatchingVisibleMetas(metricKey);\n    let parsedChartData = [];\n    for (let __________________________________index = 0, inputArrayLength = _matchingVisibleMetas.length; __________________________________index < inputArrayLength; __________________________________index++) {\n      parsedChartData = parsedChartData.concat(_matchingVisibleMetas[__________________________________index].controller.getAllParsedValues(_________chartInstance));\n    }\n    _________chartInstance._cache.$bar = adapterFunctions(parsedChartData.sort((_difference, valueToSubtract) => _difference - valueToSubtract));\n  }\n  return _________chartInstance._cache.$bar;\n}\nfunction calculateMinDistance(_chartOptions) {\n  const iScaleOptions = _chartOptions.iScale;\n  const cachedBarChartData = getCachedBarChartData(iScaleOptions, _chartOptions.type);\n  let distanceIndex;\n  let barChartDataCount;\n  let pixelValue;\n  let previousCanvasCoordinate;\n  let minimumDistance = iScaleOptions._length;\n  const updateMinimumDistance = () => {\n    if (pixelValue !== 32767 && pixelValue !== -32768) {\n      if (canvasContext(previousCanvasCoordinate)) {\n        minimumDistance = Math.min(minimumDistance, Math.abs(pixelValue - previousCanvasCoordinate) || minimumDistance);\n      }\n      previousCanvasCoordinate = pixelValue;\n    }\n  };\n  distanceIndex = 0;\n  barChartDataCount = cachedBarChartData.length;\n  for (; distanceIndex < barChartDataCount; ++distanceIndex) {\n    pixelValue = iScaleOptions.getPixelForValue(cachedBarChartData[distanceIndex]);\n    updateMinimumDistance();\n  }\n  previousCanvasCoordinate = undefined;\n  distanceIndex = 0;\n  barChartDataCount = iScaleOptions.ticks.length;\n  for (; distanceIndex < barChartDataCount; ++distanceIndex) {\n    pixelValue = iScaleOptions.getPixelForTick(distanceIndex);\n    updateMinimumDistance();\n  }\n  return minimumDistance;\n}\nfunction calculateBarDimensions(pixelIndex, minValue, ___chartOptions, scalingFactor) {\n  const barThickness = ___chartOptions.barThickness;\n  let barDimension;\n  let barPercentage;\n  if (chartUpdateInterval(barThickness)) {\n    barDimension = minValue.min * ___chartOptions.categoryPercentage;\n    barPercentage = ___chartOptions.barPercentage;\n  } else {\n    barDimension = barThickness * scalingFactor;\n    barPercentage = 1;\n  }\n  return {\n    chunk: barDimension / scalingFactor,\n    ratio: barPercentage,\n    start: minValue.pixels[pixelIndex] - barDimension / 2\n  };\n}\nfunction calculatePixelAdjustment(currentPixelIndex, imageData, categoryInfo, pixelCount) {\n  const pixelArray = imageData.pixels;\n  const currentPixelValue = pixelArray[currentPixelIndex];\n  let previousPixelValue = currentPixelIndex > 0 ? pixelArray[currentPixelIndex - 1] : null;\n  let nextPixelValue = currentPixelIndex < pixelArray.length - 1 ? pixelArray[currentPixelIndex + 1] : null;\n  const categoryPercentage = categoryInfo.categoryPercentage;\n  if (previousPixelValue === null) {\n    previousPixelValue = currentPixelValue - (nextPixelValue === null ? imageData.end - imageData.start : nextPixelValue - currentPixelValue);\n  }\n  if (nextPixelValue === null) {\n    nextPixelValue = currentPixelValue + currentPixelValue - previousPixelValue;\n  }\n  const adjustedPixelPosition = currentPixelValue - (currentPixelValue - Math.min(previousPixelValue, nextPixelValue)) / 2 * categoryPercentage;\n  return {\n    chunk: Math.abs(nextPixelValue - previousPixelValue) / 2 * categoryPercentage / pixelCount,\n    ratio: categoryInfo.barPercentage,\n    start: adjustedPixelPosition\n  };\n}\nfunction updateChartBounds(___dataPoints, _customData, parser, parseOptions) {\n  const firstDataPoint = parser.parse(___dataPoints[0], parseOptions);\n  const secondDataPointValue = parser.parse(___dataPoints[1], parseOptions);\n  const minDataPointValue = Math.min(firstDataPoint, secondDataPointValue);\n  const maxDataPointValue = Math.max(firstDataPoint, secondDataPointValue);\n  let barStartValue = minDataPointValue;\n  let _lowerBound = maxDataPointValue;\n  if (Math.abs(minDataPointValue) > Math.abs(maxDataPointValue)) {\n    barStartValue = maxDataPointValue;\n    _lowerBound = minDataPointValue;\n  }\n  _customData[parser.axis] = _lowerBound;\n  _customData._custom = {\n    barStart: barStartValue,\n    barEnd: _lowerBound,\n    start: firstDataPoint,\n    end: secondDataPointValue,\n    min: minDataPointValue,\n    max: maxDataPointValue\n  };\n}\nfunction handleChartData(_____________________chartData, ______________________chartData, _______________________chartData, _____dataPoint) {\n  if (animatedChartItems(_____________________chartData)) {\n    updateChartBounds(_____________________chartData, ______________________chartData, _______________________chartData, _____dataPoint);\n  } else {\n    ______________________chartData[_______________________chartData.axis] = _______________________chartData.parse(_____________________chartData, _____dataPoint);\n  }\n  return ______________________chartData;\n}\nfunction _processChartData(____inputData, _dataArray, _____startIndex, _endIndex) {\n  const inputScale = ____inputData.iScale;\n  const valueScale = ____inputData.vScale;\n  const labelArray = inputScale.getLabels();\n  const isInputScaleEqualToOutputScale = inputScale === valueScale;\n  const processedChartData = [];\n  let ___________________________________________________currentIndex;\n  let endProcessingIndex;\n  let chartDataObject;\n  let currentDataItem;\n  ___________________________________________________currentIndex = _____startIndex;\n  endProcessingIndex = _____startIndex + _endIndex;\n  for (; ___________________________________________________currentIndex < endProcessingIndex; ++___________________________________________________currentIndex) {\n    currentDataItem = _dataArray[___________________________________________________currentIndex];\n    chartDataObject = {};\n    chartDataObject[inputScale.axis] = isInputScaleEqualToOutputScale || inputScale.parse(labelArray[___________________________________________________currentIndex], ___________________________________________________currentIndex);\n    processedChartData.push(handleChartData(currentDataItem, chartDataObject, valueScale, ___________________________________________________currentIndex));\n  }\n  return processedChartData;\n}\nfunction isBarRangeDefined(timeRange) {\n  return timeRange && timeRange.barStart !== undefined && timeRange.barEnd !== undefined;\n}\nfunction evaluatePathClosure(pathValue, pathCoordinate, _referencePoint) {\n  if (pathValue !== 0) {\n    return isPathClosed(pathValue);\n  } else {\n    return (pathCoordinate.isHorizontal() ? 1 : -1) * (pathCoordinate.min >= _referencePoint ? 1 : -1);\n  }\n}\nfunction determineCoordinateOrientation(coordinateSettings) {\n  let isBaseGreater;\n  let orientationStart;\n  let oppositeDirection;\n  let topCoordinateOrientation;\n  let _startPosition;\n  if (coordinateSettings.horizontal) {\n    isBaseGreater = coordinateSettings.base > coordinateSettings.x;\n    orientationStart = \"left\";\n    oppositeDirection = \"right\";\n  } else {\n    isBaseGreater = coordinateSettings.base < coordinateSettings.y;\n    orientationStart = \"bottom\";\n    oppositeDirection = \"top\";\n  }\n  if (isBaseGreater) {\n    topCoordinateOrientation = \"end\";\n    _startPosition = \"start\";\n  } else {\n    topCoordinateOrientation = \"start\";\n    _startPosition = \"end\";\n  }\n  return {\n    start: orientationStart,\n    end: oppositeDirection,\n    reverse: isBaseGreater,\n    top: topCoordinateOrientation,\n    bottom: _startPosition\n  };\n}\nfunction setChartBorderSkipped(chartElement, borderSkipOption, borderRadiusCondition, borderSkippedPosition) {\n  let borderSkipValue = borderSkipOption.borderSkipped;\n  const borderSkipMap = {};\n  if (!borderSkipValue) {\n    chartElement.borderSkipped = borderSkipMap;\n    return;\n  }\n  if (borderSkipValue === true) {\n    chartElement.borderSkipped = {\n      top: true,\n      right: true,\n      bottom: true,\n      left: true\n    };\n    return;\n  }\n  const {\n    start: _startCoordinate,\n    end: __endCoordinate,\n    reverse: _isReversed,\n    top: topBorderCoordinate,\n    bottom: bottomBorderSkipped\n  } = determineCoordinateOrientation(chartElement);\n  if (borderSkipValue === \"middle\" && borderRadiusCondition) {\n    chartElement.enableBorderRadius = true;\n    if ((borderRadiusCondition._top || 0) === borderSkippedPosition) {\n      borderSkipValue = topBorderCoordinate;\n    } else if ((borderRadiusCondition._bottom || 0) === borderSkippedPosition) {\n      borderSkipValue = bottomBorderSkipped;\n    } else {\n      borderSkipMap[calculateTaskState(bottomBorderSkipped, _startCoordinate, __endCoordinate, _isReversed)] = true;\n      borderSkipValue = topBorderCoordinate;\n    }\n  }\n  borderSkipMap[calculateTaskState(borderSkipValue, _startCoordinate, __endCoordinate, _isReversed)] = true;\n  chartElement.borderSkipped = borderSkipMap;\n}\nfunction calculateTaskState(taskState, ___comparisonValue, ____comparisonValue, isTaskActive) {\n  return taskState = isTaskActive ? getTaskState(taskState = returnValueBasedOnComparison(taskState, ___comparisonValue, ____comparisonValue), ____comparisonValue, ___comparisonValue) : getTaskState(taskState, ___comparisonValue, ____comparisonValue);\n}\nfunction returnValueBasedOnComparison(firstValue, comparisonValue, _comparisonValue) {\n  if (firstValue === comparisonValue) {\n    return _comparisonValue;\n  } else if (firstValue === _comparisonValue) {\n    return comparisonValue;\n  } else {\n    return firstValue;\n  }\n}\nfunction getTaskState(actionType, eventParameter, ____endValue) {\n  if (actionType === \"start\") {\n    return eventParameter;\n  } else if (actionType === \"end\") {\n    return ____endValue;\n  } else {\n    return actionType;\n  }\n}\nfunction inflateAmountHandler(_inflateAmount, {\n  inflateAmount: inflateAmountValue\n}, inflateFactor) {\n  _inflateAmount.inflateAmount = inflateAmountValue === \"auto\" ? inflateFactor === 1 ? 0.33 : 0 : inflateAmountValue;\n}\nclass We extends Se {\n  static id = \"bar\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"bar\",\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"base\", \"width\", \"height\"]\n      }\n    }\n  };\n  static overrides = {\n    scales: {\n      _index_: {\n        type: \"category\",\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: \"linear\",\n        beginAtZero: true\n      }\n    }\n  };\n  parsePrimitiveData(primitiveData, _____dataElement, _________________dataIndex, dataSource) {\n    return _processChartData(primitiveData, _____dataElement, _________________dataIndex, dataSource);\n  }\n  parseArrayData(arrayData, errorData, _______________dataIndex, _____________________________chartData) {\n    return _processChartData(arrayData, errorData, _______________dataIndex, _____________________________chartData);\n  }\n  parseObjectData(_parsedObjectData, __________parsedData, ___________startIndex, endIndexOffset) {\n    const {\n      iScale: __inputScale,\n      vScale: _____valueScale\n    } = _parsedObjectData;\n    const {\n      xAxisKey: _xAxisKey = \"x\",\n      yAxisKey: _yAxisKey = \"y\"\n    } = this._parsing;\n    const selectedAxisKey = __inputScale.axis === \"x\" ? _xAxisKey : _yAxisKey;\n    const _valueScaleAxis = _____valueScale.axis === \"x\" ? _xAxisKey : _yAxisKey;\n    const _parsedChartData = [];\n    let _____________________________index;\n    let endIndexPosition;\n    let parsedPointData;\n    let _parsedDataItem;\n    _____________________________index = ___________startIndex;\n    endIndexPosition = ___________startIndex + endIndexOffset;\n    for (; _____________________________index < endIndexPosition; ++_____________________________index) {\n      _parsedDataItem = __________parsedData[_____________________________index];\n      parsedPointData = {};\n      parsedPointData[__inputScale.axis] = __inputScale.parse(_requestAnimationFrameId(_parsedDataItem, selectedAxisKey), _____________________________index);\n      _parsedChartData.push(handleChartData(_requestAnimationFrameId(_parsedDataItem, _valueScaleAxis), parsedPointData, _____valueScale, _____________________________index));\n    }\n    return _parsedChartData;\n  }\n  updateRangeFromParsed(rangeToUpdate, vScale, parsedRange, scale) {\n    super.updateRangeFromParsed(rangeToUpdate, vScale, parsedRange, scale);\n    const customRangeValues = parsedRange._custom;\n    if (customRangeValues && vScale === this._cachedMeta.vScale) {\n      rangeToUpdate.min = Math.min(rangeToUpdate.min, customRangeValues.min);\n      rangeToUpdate.max = Math.max(rangeToUpdate.max, customRangeValues.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(________parsedData) {\n    const __________cachedMeta = this._cachedMeta;\n    const {\n      iScale: ___iScale,\n      vScale: ___valueScale\n    } = __________cachedMeta;\n    const parsedDataItem = this.getParsed(________parsedData);\n    const __customData = parsedDataItem._custom;\n    const __formattedValue = isBarRangeDefined(__customData) ? \"[\" + __customData.start + \", \" + __customData.end + \"]\" : \"\" + ___valueScale.getLabelForValue(parsedDataItem[___valueScale.axis]);\n    return {\n      label: \"\" + ___iScale.getLabelForValue(parsedDataItem[___iScale.axis]),\n      value: __formattedValue\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    this._cachedMeta.stack = this.getDataset().stack;\n  }\n  update(_timestamp) {\n    const _cachedMetadata = this._cachedMeta;\n    this.updateElements(_cachedMetadata.data, 0, _cachedMetadata.data.length, _timestamp);\n  }\n  updateElements(t, e, i, s) {\n    const n = s === \"reset\";\n    const {\n      index: o,\n      _cachedMeta: {\n        vScale: a\n      }\n    } = this;\n    const r = a.getBasePixel();\n    const h = a.isHorizontal();\n    const l = this._getRuler();\n    const {\n      sharedOptions: c,\n      includeOptions: d\n    } = this._getSharedOptions(e, s);\n    for (let _currentIndex = e; _currentIndex < e + i; _currentIndex++) {\n      const ___currentIndex = this.getParsed(_currentIndex);\n      const chartUpdateDuration = n || chartUpdateInterval(___currentIndex[a.axis]) ? {\n        base: r,\n        head: r\n      } : this._calculateBarValuePixels(_currentIndex);\n      const barIndexPixels = this._calculateBarIndexPixels(_currentIndex, l);\n      const p = (___currentIndex._stacks || {})[a.axis];\n      const barElementProperties = {\n        horizontal: h,\n        base: chartUpdateDuration.base,\n        enableBorderRadius: !p || isBarRangeDefined(___currentIndex._custom) || o === p._top || o === p._bottom,\n        x: h ? chartUpdateDuration.head : barIndexPixels.center,\n        y: h ? barIndexPixels.center : chartUpdateDuration.head,\n        height: h ? barIndexPixels.size : Math.abs(chartUpdateDuration.size),\n        width: h ? Math.abs(chartUpdateDuration.size) : barIndexPixels.size\n      };\n      if (d) {\n        barElementProperties.options = c || this.resolveDataElementOptions(_currentIndex, t[_currentIndex].active ? \"active\" : s);\n      }\n      const elementOptions = barElementProperties.options || t[_currentIndex].options;\n      setChartBorderSkipped(barElementProperties, elementOptions, p, o);\n      inflateAmountHandler(barElementProperties, elementOptions, l.ratio);\n      this.updateElement(t[_currentIndex], _currentIndex, barElementProperties, s);\n    }\n  }\n  _getStacks(_targetIndex, parsedDataPointValue) {\n    const {\n      iScale: metaIndexScale\n    } = this._cachedMeta;\n    const visibleMetaGroups = metaIndexScale.getMatchingVisibleMetas(this._type).filter(groupedOptions => groupedOptions.controller.options.grouped);\n    const _isStacked = metaIndexScale.options.stacked;\n    const stackedItemList = [];\n    const shouldSkipParsedValue = ______dataPoint => {\n      const parsedControllerValue = ______dataPoint.controller.getParsed(parsedDataPointValue);\n      const __parsedValue = parsedControllerValue && parsedControllerValue[______dataPoint.vScale.axis];\n      if (chartUpdateInterval(__parsedValue) || isNaN(__parsedValue)) {\n        return true;\n      }\n    };\n    for (const __currentItem of visibleMetaGroups) {\n      if ((parsedDataPointValue === undefined || !shouldSkipParsedValue(__currentItem)) && ((_isStacked === false || stackedItemList.indexOf(__currentItem.stack) === -1 || _isStacked === undefined && __currentItem.stack === undefined) && stackedItemList.push(__currentItem.stack), __currentItem.index === _targetIndex)) {\n        break;\n      }\n    }\n    if (!stackedItemList.length) {\n      stackedItemList.push(undefined);\n    }\n    return stackedItemList;\n  }\n  _getStackCount(_stackIdentifier) {\n    return this._getStacks(undefined, _stackIdentifier).length;\n  }\n  _getStackIndex(__stackIdentifier, _elementToFind, _stackIndex) {\n    const stackArray = this._getStacks(__stackIdentifier, _stackIndex);\n    const _______elementIndex = _elementToFind !== undefined ? stackArray.indexOf(_elementToFind) : -1;\n    if (_______elementIndex === -1) {\n      return stackArray.length - 1;\n    } else {\n      return _______elementIndex;\n    }\n  }\n  _getRuler() {\n    const ______optionsConfig = this.options;\n    const ___________________cachedMeta = this._cachedMeta;\n    const _____iScale = ___________________cachedMeta.iScale;\n    const pixelValues = [];\n    let parsedDataIndex;\n    let _dataLength;\n    parsedDataIndex = 0;\n    _dataLength = ___________________cachedMeta.data.length;\n    for (; parsedDataIndex < _dataLength; ++parsedDataIndex) {\n      pixelValues.push(_____iScale.getPixelForValue(this.getParsed(parsedDataIndex)[_____iScale.axis], parsedDataIndex));\n    }\n    const _barThickness = ______optionsConfig.barThickness;\n    return {\n      min: _barThickness || calculateMinDistance(___________________cachedMeta),\n      pixels: pixelValues,\n      start: _____iScale._startPixel,\n      end: _____iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: _____iScale,\n      grouped: ______optionsConfig.grouped,\n      ratio: _barThickness ? 1 : ______optionsConfig.categoryPercentage * ______optionsConfig.barPercentage\n    };\n  }\n  _calculateBarValuePixels(t) {\n    const {\n      _cachedMeta: {\n        vScale: e,\n        _stacked: i,\n        index: s\n      },\n      options: {\n        base: n,\n        minBarLength: o\n      }\n    } = this;\n    const a = n || 0;\n    const r = this.getParsed(t);\n    const h = r._custom;\n    const barValueInPixels = isBarRangeDefined(h);\n    let c;\n    let d;\n    let u = r[e.axis];\n    let p = 0;\n    let m = i ? this.applyStack(e, r, i) : u;\n    if (m !== u) {\n      p = m - u;\n      m = u;\n    }\n    if (barValueInPixels) {\n      u = h.barStart;\n      m = h.barEnd - h.barStart;\n      if (u !== 0 && isPathClosed(u) !== isPathClosed(h.barEnd)) {\n        p = 0;\n      }\n      p += u;\n    }\n    const x = chartUpdateInterval(n) || barValueInPixels ? p : n;\n    let b = e.getPixelForValue(x);\n    if (this.chart.getDataVisibility(t)) {\n      c = e.getPixelForValue(p + m);\n    } else {\n      c = b;\n    }\n    d = c - b;\n    if (Math.abs(d) < o) {\n      d = evaluatePathClosure(d, e, a) * o;\n      if (u === a) {\n        b -= d / 2;\n      }\n      const dataPointIndex = e.getPixelForDecimal(0);\n      const barBaseValue = e.getPixelForDecimal(1);\n      const customData = Math.min(dataPointIndex, barBaseValue);\n      const isValueEqual = Math.max(dataPointIndex, barBaseValue);\n      b = Math.max(Math.min(b, isValueEqual), customData);\n      c = b + d;\n      if (i && !barValueInPixels) {\n        r._stacks[e.axis]._visualValues[s] = e.getValueForPixel(c) - e.getValueForPixel(b);\n      }\n    }\n    if (b === e.getPixelForValue(a)) {\n      const _dataPointIndex = isPathClosed(d) * e.getLineWidthForValue(a) / 2;\n      b += _dataPointIndex;\n      d -= _dataPointIndex;\n    }\n    return {\n      size: d,\n      base: b,\n      head: c,\n      center: c + d / 2\n    };\n  }\n  _calculateBarIndexPixels(t, e) {\n    const i = e.scale;\n    const s = this.options;\n    const n = s.skipNull;\n    const o = chartAnimationRunning(s.maxBarThickness, Infinity);\n    let a;\n    let h;\n    if (e.grouped) {\n      const scaleValue = n ? this._getStackCount(t) : e.stackCount;\n      const barThicknessCalculation = s.barThickness === \"flex\" ? calculatePixelAdjustment(t, e, s, scaleValue) : calculateBarDimensions(t, e, s, scaleValue);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, n ? t : undefined);\n      a = barThicknessCalculation.start + barThicknessCalculation.chunk * stackIndex + barThicknessCalculation.chunk / 2;\n      h = Math.min(o, barThicknessCalculation.chunk * barThicknessCalculation.ratio);\n    } else {\n      a = i.getPixelForValue(this.getParsed(t)[i.axis], t);\n      h = Math.min(o, e.min * e.ratio);\n    }\n    return {\n      base: a - h / 2,\n      head: a + h / 2,\n      center: a,\n      size: h\n    };\n  }\n  draw() {\n    const ________cachedMeta = this._cachedMeta;\n    const _valueScale = ________cachedMeta.vScale;\n    const ____dataPoints = ________cachedMeta.data;\n    const dataPointsCount = ____dataPoints.length;\n    let _________________________currentIndex = 0;\n    for (; _________________________currentIndex < dataPointsCount; ++_________________________currentIndex) {\n      if (this.getParsed(_________________________currentIndex)[_valueScale.axis] !== null) {\n        ____dataPoints[_________________________currentIndex].draw(this._ctx);\n      }\n    }\n  }\n}\nclass He extends Se {\n  static id = \"bubble\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"borderWidth\", \"radius\"]\n      }\n    }\n  };\n  static overrides = {\n    scales: {\n      x: {\n        type: \"linear\"\n      },\n      y: {\n        type: \"linear\"\n      }\n    }\n  };\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(____elementIndex, ______dataElement, elementOffset, ____dataElementOptions) {\n    const parsedDataElements = super.parsePrimitiveData(____elementIndex, ______dataElement, elementOffset, ____dataElementOptions);\n    for (let _________________________________index = 0; _________________________________index < parsedDataElements.length; _________________________________index++) {\n      parsedDataElements[_________________________________index]._custom = this.resolveDataElementOptions(_________________________________index + elementOffset).radius;\n    }\n    return parsedDataElements;\n  }\n  parseArrayData(________________________index, _dataElementArray, currentElementIndex, _dataSlice) {\n    const _parsedDataArray = super.parseArrayData(________________________index, _dataElementArray, currentElementIndex, _dataSlice);\n    for (let _______________________index = 0; _______________________index < _parsedDataArray.length; _______________________index++) {\n      const ___dataElement = _dataElementArray[currentElementIndex + _______________________index];\n      _parsedDataArray[_______________________index]._custom = chartAnimationRunning(___dataElement[2], this.resolveDataElementOptions(_______________________index + currentElementIndex).radius);\n    }\n    return _parsedDataArray;\n  }\n  parseObjectData(______________________index, __dataElementArray, _____dataElementIndex, sourceData) {\n    const parsedObjectData = super.parseObjectData(______________________index, __dataElementArray, _____dataElementIndex, sourceData);\n    for (let _____________________index = 0; _____________________index < parsedObjectData.length; _____________________index++) {\n      const __dataElement = __dataElementArray[_____dataElementIndex + _____________________index];\n      parsedObjectData[_____________________index]._custom = chartAnimationRunning(__dataElement && __dataElement.r && +__dataElement.r, this.resolveDataElementOptions(_____________________index + _____dataElementIndex).radius);\n    }\n    return parsedObjectData;\n  }\n  getMaxOverflow() {\n    const __cachedMetaData = this._cachedMeta.data;\n    let maxHalfSize = 0;\n    for (let _______________________________index = __cachedMetaData.length - 1; _______________________________index >= 0; --_______________________________index) {\n      maxHalfSize = Math.max(maxHalfSize, __cachedMetaData[_______________________________index].size(this.resolveDataElementOptions(_______________________________index)) / 2);\n    }\n    return maxHalfSize > 0 && maxHalfSize;\n  }\n  getLabelAndValue(_______________________dataIndex) {\n    const ______________cachedMeta = this._cachedMeta;\n    const dataLabels = this.chart.data.labels || [];\n    const {\n      xScale: __xScale,\n      yScale: _yScale\n    } = ______________cachedMeta;\n    const _parsedDataPoint = this.getParsed(_______________________dataIndex);\n    const _labelForXValue = __xScale.getLabelForValue(_parsedDataPoint.x);\n    const yScaleLabel = _yScale.getLabelForValue(_parsedDataPoint.y);\n    const customDataPointValue = _parsedDataPoint._custom;\n    return {\n      label: dataLabels[_______________________dataIndex] || \"\",\n      value: \"(\" + _labelForXValue + \", \" + yScaleLabel + (customDataPointValue ? \", \" + customDataPointValue : \"\") + \")\"\n    };\n  }\n  update(updateDelta) {\n    const _cachedMetaData = this._cachedMeta.data;\n    this.updateElements(_cachedMetaData, 0, _cachedMetaData.length, updateDelta);\n  }\n  updateElements(t, e, i, s) {\n    const isParsing = s === \"reset\";\n    const {\n      iScale: o,\n      vScale: a\n    } = this._cachedMeta;\n    const {\n      sharedOptions: r,\n      includeOptions: h\n    } = this._getSharedOptions(e, s);\n    const l = o.axis;\n    const c = a.axis;\n    for (let ______currentIndex = e; ______currentIndex < e + i; ______currentIndex++) {\n      const _currentElement = t[______currentIndex];\n      const _parsedData = !isParsing && this.getParsed(______currentIndex);\n      const elementData = {};\n      const elementPixelValue = elementData[l] = isParsing ? o.getPixelForDecimal(0.5) : o.getPixelForValue(_parsedData[l]);\n      const basePixelValue = elementData[c] = isParsing ? a.getBasePixel() : a.getPixelForValue(_parsedData[c]);\n      elementData.skip = isNaN(elementPixelValue) || isNaN(basePixelValue);\n      if (h) {\n        elementData.options = r || this.resolveDataElementOptions(______currentIndex, _currentElement.active ? \"active\" : s);\n        if (isParsing) {\n          elementData.options.radius = 0;\n        }\n      }\n      this.updateElement(_currentElement, ______currentIndex, elementData, s);\n    }\n  }\n  resolveDataElementOptions(________dataElement, dataElementStatus) {\n    const parsedDataElement = this.getParsed(________dataElement);\n    let resolvedDataElementOptions = super.resolveDataElementOptions(________dataElement, dataElementStatus);\n    if (resolvedDataElementOptions.$shared) {\n      resolvedDataElementOptions = Object.assign({}, resolvedDataElementOptions, {\n        $shared: false\n      });\n    }\n    const initialRadius = resolvedDataElementOptions.radius;\n    if (dataElementStatus !== \"active\") {\n      resolvedDataElementOptions.radius = 0;\n    }\n    resolvedDataElementOptions.radius += chartAnimationRunning(parsedDataElement && parsedDataElement._custom, initialRadius);\n    return resolvedDataElementOptions;\n  }\n}\nfunction calculateAnimationRatios(angle, elapsedTime, animationScaleFactor) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let _offsetY = 0;\n  if (elapsedTime < lastAnimationUpdateTimestamp) {\n    const currentAngle = angle;\n    const anglePlusElapsedTime = currentAngle + elapsedTime;\n    const cosineValue = Math.cos(currentAngle);\n    const sinAngle = Math.sin(currentAngle);\n    const cosineOfNextAngle = Math.cos(anglePlusElapsedTime);\n    const sinOfNextAngle = Math.sin(anglePlusElapsedTime);\n    const calculateAnimationRatio = (_________animationDuration, ___elapsedTime, animatedItemScale) => _animatedChartItems(_________animationDuration, currentAngle, anglePlusElapsedTime, true) ? 1 : Math.max(___elapsedTime, ___elapsedTime * animationScaleFactor, animatedItemScale, animatedItemScale * animationScaleFactor);\n    const calculateMinValue = (_animationTime, ___minValue, currentScaleValue) => _animatedChartItems(_animationTime, currentAngle, anglePlusElapsedTime, true) ? -1 : Math.min(___minValue, ___minValue * animationScaleFactor, currentScaleValue, currentScaleValue * animationScaleFactor);\n    const animationRatio = calculateAnimationRatio(0, cosineValue, cosineOfNextAngle);\n    const _animatedValue = calculateAnimationRatio(currentFrameTimestamp, sinAngle, sinOfNextAngle);\n    const calculatedMinValue = calculateMinValue(notificationListener, cosineValue, cosineOfNextAngle);\n    const minAnimatedValue = calculateMinValue(notificationListener + currentFrameTimestamp, sinAngle, sinOfNextAngle);\n    ratioX = (animationRatio - calculatedMinValue) / 2;\n    ratioY = (_animatedValue - minAnimatedValue) / 2;\n    offsetX = -(animationRatio + calculatedMinValue) / 2;\n    _offsetY = -(_animatedValue + minAnimatedValue) / 2;\n  }\n  return {\n    ratioX: ratioX,\n    ratioY: ratioY,\n    offsetX: offsetX,\n    offsetY: _offsetY\n  };\n}\nclass $e extends Se {\n  static id = \"doughnut\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"arc\",\n    animation: {\n      animateRotate: true,\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"circumference\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"x\", \"y\", \"offset\", \"borderWidth\", \"spacing\"]\n      }\n    },\n    cutout: \"50%\",\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\",\n    spacing: 0,\n    indexAxis: \"r\"\n  };\n  static descriptors = {\n    _scriptable: isNotSpacing => isNotSpacing !== \"spacing\",\n    _indexable: cssProperty => cssProperty !== \"spacing\" && !cssProperty.startsWith(\"borderDash\") && !cssProperty.startsWith(\"hoverBorderDash\")\n  };\n  static overrides = {\n    aspectRatio: 1,\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(t) {\n            const e = t.data;\n            if (e.labels.length && e.datasets.length) {\n              const {\n                labels: {\n                  pointStyle: _pointStyle,\n                  color: _fontColor\n                }\n              } = t.legend.options;\n              return e.labels.map((textValue, ____dataIndex) => {\n                const _styleProperties = t.getDatasetMeta(0).controller.getStyle(____dataIndex);\n                return {\n                  text: textValue,\n                  fillStyle: _styleProperties.backgroundColor,\n                  strokeStyle: _styleProperties.borderColor,\n                  fontColor: _fontColor,\n                  lineWidth: _styleProperties.borderWidth,\n                  pointStyle: _pointStyle,\n                  hidden: !t.getDataVisibility(____dataIndex),\n                  index: ____dataIndex\n                };\n              });\n            }\n            return [];\n          }\n        },\n        onClick(clickedItem, ___________________event, _chartController) {\n          _chartController.chart.toggleDataVisibility(___________________event.index);\n          _chartController.chart.update();\n        }\n      }\n    }\n  };\n  constructor(constructorParam1, parentConstructorArg) {\n    super(constructorParam1, parentConstructorArg);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(__________startIndex, dataChunkSize) {\n    const _datasetData = this.getDataset().data;\n    const _________________cachedMeta = this._cachedMeta;\n    if (this._parsing === false) {\n      _________________cachedMeta._parsed = _datasetData;\n    } else {\n      let ____startIndex;\n      let endIndex;\n      let parseDataValue = ______________________________________________________index => +_datasetData[______________________________________________________index];\n      if (currentAnimationIndex(_datasetData[__________startIndex])) {\n        const {\n          key: ___dataPointIndex = \"value\"\n        } = this._parsing;\n        parseDataValue = ____dataPointIndex => +_requestAnimationFrameId(_datasetData[____dataPointIndex], ___dataPointIndex);\n      }\n      ____startIndex = __________startIndex;\n      endIndex = __________startIndex + dataChunkSize;\n      for (; ____startIndex < endIndex; ++____startIndex) {\n        _________________cachedMeta._parsed[____startIndex] = parseDataValue(____startIndex);\n      }\n    }\n  }\n  _getRotation() {\n    return requestAnimation(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return requestAnimation(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let lastAnimationUpdateRotation = lastAnimationUpdateTimestamp;\n    let maxRotationExtent = -lastAnimationUpdateTimestamp;\n    for (let _______datasetIndex = 0; _______datasetIndex < this.chart.data.datasets.length; ++_______datasetIndex) {\n      if (this.chart.isDatasetVisible(_______datasetIndex) && this.chart.getDatasetMeta(_______datasetIndex).type === this._type) {\n        const datasetController = this.chart.getDatasetMeta(_______datasetIndex).controller;\n        const datasetRotation = datasetController._getRotation();\n        const circumference = datasetController._getCircumference();\n        lastAnimationUpdateRotation = Math.min(lastAnimationUpdateRotation, datasetRotation);\n        maxRotationExtent = Math.max(maxRotationExtent, datasetRotation + circumference);\n      }\n    }\n    return {\n      rotation: lastAnimationUpdateRotation,\n      circumference: maxRotationExtent - lastAnimationUpdateRotation\n    };\n  }\n  update(t) {\n    const e = this.chart;\n    const {\n      chartArea: i\n    } = e;\n    const s = this._cachedMeta;\n    const n = s.data;\n    const o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing;\n    const a = Math.max((Math.min(i.width, i.height) - o) / 2, 0);\n    const r = Math.min(minifiedVar(this.options.cutout, a), 1);\n    const h = this._getRingWeight(this.index);\n    const {\n      circumference: l,\n      rotation: c\n    } = this._getRotationExtents();\n    const {\n      ratioX: d,\n      ratioY: u,\n      offsetX: g,\n      offsetY: p\n    } = calculateAnimationRatios(c, l, r);\n    const f = (i.width - o) / d;\n    const m = (i.height - o) / u;\n    const x = Math.max(Math.min(f, m) / 2, 0);\n    const y = __requestAnimationFrameId(this.options.radius, x);\n    const v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = g * y;\n    this.offsetY = p * y;\n    s.total = this.calculateTotal();\n    this.outerRadius = y - v * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - v * h, 0);\n    this.updateElements(n, 0, n.length, t);\n  }\n  _circumference(______________________dataIndex, isRotateAnimationEnabled) {\n    const _____optionsConfig = this.options;\n    const ____cachedMetaData = this._cachedMeta;\n    const circumferenceValue = this._getCircumference();\n    if (isRotateAnimationEnabled && _____optionsConfig.animation.animateRotate || !this.chart.getDataVisibility(______________________dataIndex) || ____cachedMetaData._parsed[______________________dataIndex] === null || ____cachedMetaData.data[______________________dataIndex].hidden) {\n      return 0;\n    } else {\n      return this.calculateCircumference(____cachedMetaData._parsed[______________________dataIndex] * circumferenceValue / lastAnimationUpdateTimestamp);\n    }\n  }\n  updateElements(t, e, i, s) {\n    const n = s === \"reset\";\n    const o = this.chart;\n    const a = o.chartArea;\n    const r = o.options.animation;\n    const h = (a.left + a.right) / 2;\n    const l = (a.top + a.bottom) / 2;\n    const c = n && r.animateScale;\n    const d = c ? 0 : this.innerRadius;\n    const u = c ? 0 : this.outerRadius;\n    const {\n      sharedOptions: g,\n      includeOptions: p\n    } = this._getSharedOptions(e, s);\n    let ________currentIndex;\n    let m = this._getRotation();\n    for (________currentIndex = 0; ________currentIndex < e; ++________currentIndex) {\n      m += this._circumference(________currentIndex, n);\n    }\n    for (________currentIndex = e; ________currentIndex < e + i; ++________currentIndex) {\n      const currentCircumference = this._circumference(________currentIndex, n);\n      const _________currentIndex = t[________currentIndex];\n      const _elementData = {\n        x: h + this.offsetX,\n        y: l + this.offsetY,\n        startAngle: m,\n        endAngle: m + currentCircumference,\n        circumference: currentCircumference,\n        outerRadius: u,\n        innerRadius: d\n      };\n      if (p) {\n        _elementData.options = g || this.resolveDataElementOptions(________currentIndex, _________currentIndex.active ? \"active\" : s);\n      }\n      m += currentCircumference;\n      this.updateElement(_________currentIndex, ________currentIndex, _elementData, s);\n    }\n  }\n  calculateTotal() {\n    const _________cachedMeta = this._cachedMeta;\n    const _____dataPoints = _________cachedMeta.data;\n    let ________________index;\n    let totalDataValueSum = 0;\n    for (________________index = 0; ________________index < _____dataPoints.length; ________________index++) {\n      const parsedDataValue = _________cachedMeta._parsed[________________index];\n      if (parsedDataValue !== null && !isNaN(parsedDataValue) && !!this.chart.getDataVisibility(________________index) && !_____dataPoints[________________index].hidden) {\n        totalDataValueSum += Math.abs(parsedDataValue);\n      }\n    }\n    return totalDataValueSum;\n  }\n  calculateCircumference(timeValue) {\n    const totalCachedMeta = this._cachedMeta.total;\n    if (totalCachedMeta > 0 && !isNaN(timeValue)) {\n      return lastAnimationUpdateTimestamp * (Math.abs(timeValue) / totalCachedMeta);\n    } else {\n      return 0;\n    }\n  }\n  getLabelAndValue(_____labelIndex) {\n    const _______cachedMeta = this._cachedMeta;\n    const _____________________chartInstance = this.chart;\n    const _chartLabels = _____________________chartInstance.data.labels || [];\n    const _isAnimationRunning = _isChartAnimationRunning(_______cachedMeta._parsed[_____labelIndex], _____________________chartInstance.options.locale);\n    return {\n      label: _chartLabels[_____labelIndex] || \"\",\n      value: _isAnimationRunning\n    };\n  }\n  getMaxBorderWidth(__datasetData) {\n    let maxBorderWidth = 0;\n    const ______________________________chartInstance = this.chart;\n    let _dataElementIndex;\n    let ____datasetCount;\n    let ___________________datasetMeta;\n    let dataController;\n    let _____dataElementOptions;\n    if (!__datasetData) {\n      _dataElementIndex = 0;\n      ____datasetCount = ______________________________chartInstance.data.datasets.length;\n      for (; _dataElementIndex < ____datasetCount; ++_dataElementIndex) {\n        if (______________________________chartInstance.isDatasetVisible(_dataElementIndex)) {\n          ___________________datasetMeta = ______________________________chartInstance.getDatasetMeta(_dataElementIndex);\n          __datasetData = ___________________datasetMeta.data;\n          dataController = ___________________datasetMeta.controller;\n          break;\n        }\n      }\n    }\n    if (!__datasetData) {\n      return 0;\n    }\n    _dataElementIndex = 0;\n    ____datasetCount = __datasetData.length;\n    for (; _dataElementIndex < ____datasetCount; ++_dataElementIndex) {\n      _____dataElementOptions = dataController.resolveDataElementOptions(_dataElementIndex);\n      if (_____dataElementOptions.borderAlign !== \"inner\") {\n        maxBorderWidth = Math.max(maxBorderWidth, _____dataElementOptions.borderWidth || 0, _____dataElementOptions.hoverBorderWidth || 0);\n      }\n    }\n    return maxBorderWidth;\n  }\n  getMaxOffset(dataElementArray) {\n    let maxOffset = 0;\n    for (let __dataElementIndex = 0, dataElementCount = dataElementArray.length; __dataElementIndex < dataElementCount; ++__dataElementIndex) {\n      const _dataElementOptions = this.resolveDataElementOptions(__dataElementIndex);\n      maxOffset = Math.max(maxOffset, _dataElementOptions.offset || 0, _dataElementOptions.hoverOffset || 0);\n    }\n    return maxOffset;\n  }\n  _getRingWeightOffset(totalVisibleDatasets) {\n    let totalRingWeightOffset = 0;\n    for (let _______________________datasetIndex = 0; _______________________datasetIndex < totalVisibleDatasets; ++_______________________datasetIndex) {\n      if (this.chart.isDatasetVisible(_______________________datasetIndex)) {\n        totalRingWeightOffset += this._getRingWeight(_______________________datasetIndex);\n      }\n    }\n    return totalRingWeightOffset;\n  }\n  _getRingWeight(___________________________________datasetIndex) {\n    return Math.max(chartAnimationRunning(this.chart.data.datasets[___________________________________datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nclass Ue extends Se {\n  static id = \"line\";\n  static defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    showLine: true,\n    spanGaps: false\n  };\n  static overrides = {\n    scales: {\n      _index_: {\n        type: \"category\"\n      },\n      _value_: {\n        type: \"linear\"\n      }\n    }\n  };\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n  update(t) {\n    const e = this._cachedMeta;\n    const {\n      dataset: i,\n      data: s = [],\n      _dataset: n\n    } = e;\n    const o = this.chart._animationsDisabled;\n    let {\n      start: a,\n      count: r\n    } = chartAnimationQueue(e, s, o);\n    this._drawStart = a;\n    this._drawCount = r;\n    if (refreshIntervalId(e)) {\n      a = 0;\n      r = s.length;\n    }\n    i._chart = this.chart;\n    i._datasetIndex = this.index;\n    i._decimated = !!n._decimated;\n    i.points = s;\n    const h = this.resolveDatasetElementOptions(t);\n    if (!this.options.showLine) {\n      h.borderWidth = 0;\n    }\n    h.segment = this.options.segment;\n    this.updateElement(i, undefined, {\n      animated: !o,\n      options: h\n    }, t);\n    this.updateElements(s, a, r, t);\n  }\n  updateElements(t, e, __index, s) {\n    const n = s === \"reset\";\n    const {\n      iScale: o,\n      vScale: a,\n      _stacked: r,\n      _dataset: h\n    } = this._cachedMeta;\n    const {\n      sharedOptions: l,\n      includeOptions: c\n    } = this._getSharedOptions(e, s);\n    const d = o.axis;\n    const u = a.axis;\n    const {\n      spanGaps: g,\n      segment: p\n    } = this.options;\n    const m = requestId(g) ? g : Number.POSITIVE_INFINITY;\n    const isConditional = this.chart._animationsDisabled || n || s === \"none\";\n    const b = e + __index;\n    const _ = t.length;\n    let y = e > 0 && this.getParsed(e - 1);\n    for (let _index = 0; _index < _; ++_index) {\n      const ______currentItem = t[_index];\n      const currentElement = isConditional ? ______currentItem : {};\n      if (_index < e || _index >= b) {\n        currentElement.skip = true;\n        continue;\n      }\n      const ___parsedData = this.getParsed(_index);\n      const chartUpdateIntervalValue = chartUpdateInterval(___parsedData[u]);\n      const w = currentElement[d] = o.getPixelForValue(___parsedData[d], _index);\n      const k = currentElement[u] = n || chartUpdateIntervalValue ? a.getBasePixel() : a.getPixelForValue(r ? this.applyStack(a, ___parsedData, r) : ___parsedData[u], _index);\n      currentElement.skip = isNaN(w) || isNaN(k) || chartUpdateIntervalValue;\n      currentElement.stop = _index > 0 && Math.abs(___parsedData[d] - y[d]) > m;\n      if (p) {\n        currentElement.parsed = ___parsedData;\n        currentElement.raw = h.data[_index];\n      }\n      if (c) {\n        currentElement.options = l || this.resolveDataElementOptions(_index, ______currentItem.active ? \"active\" : s);\n      }\n      if (!isConditional) {\n        this.updateElement(______currentItem, _index, currentElement, s);\n      }\n      y = ___parsedData;\n    }\n  }\n  getMaxOverflow() {\n    const ____________cachedMeta = this._cachedMeta;\n    const datasetOptions = ____________cachedMeta.dataset;\n    const borderWidth = datasetOptions.options && datasetOptions.options.borderWidth || 0;\n    const cachedDataArray = ____________cachedMeta.data || [];\n    if (!cachedDataArray.length) {\n      return borderWidth;\n    }\n    const firstDataElementSize = cachedDataArray[0].size(this.resolveDataElementOptions(0));\n    const lastDataElementSize = cachedDataArray[cachedDataArray.length - 1].size(this.resolveDataElementOptions(cachedDataArray.length - 1));\n    return Math.max(borderWidth, firstDataElementSize, lastDataElementSize) / 2;\n  }\n  draw() {\n    const _cachedMeta = this._cachedMeta;\n    _cachedMeta.dataset.updateControlPoints(this.chart.chartArea, _cachedMeta.iScale.axis);\n    super.draw();\n  }\n}\nclass Ye extends Se {\n  static id = \"polarArea\";\n  static defaults = {\n    dataElementType: \"arc\",\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"]\n      }\n    },\n    indexAxis: \"r\",\n    startAngle: 0\n  };\n  static overrides = {\n    aspectRatio: 1,\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(t) {\n            const e = t.data;\n            if (e.labels.length && e.datasets.length) {\n              const {\n                labels: {\n                  pointStyle: __pointStyle,\n                  color: __fontColor\n                }\n              } = t.legend.options;\n              return e.labels.map((labelText, __dataPointIndex) => {\n                const styleOptions = t.getDatasetMeta(0).controller.getStyle(__dataPointIndex);\n                return {\n                  text: labelText,\n                  fillStyle: styleOptions.backgroundColor,\n                  strokeStyle: styleOptions.borderColor,\n                  fontColor: __fontColor,\n                  lineWidth: styleOptions.borderWidth,\n                  pointStyle: __pointStyle,\n                  hidden: !t.getDataVisibility(__dataPointIndex),\n                  index: __dataPointIndex\n                };\n              });\n            }\n            return [];\n          }\n        },\n        onClick(toggleVisibilityEvent, ____________________event, __chartController) {\n          __chartController.chart.toggleDataVisibility(____________________event.index);\n          __chartController.chart.update();\n        }\n      }\n    },\n    scales: {\n      r: {\n        type: \"radialLinear\",\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n  constructor(radiusConstructorParams, constructionParams) {\n    super(radiusConstructorParams, constructionParams);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(______labelIndex) {\n    const ____cachedMetadata = this._cachedMeta;\n    const ______________________chartInstance = this.chart;\n    const __chartLabels = ______________________chartInstance.data.labels || [];\n    const isChartAnimationActive = _isChartAnimationRunning(____cachedMetadata._parsed[______labelIndex].r, ______________________chartInstance.options.locale);\n    return {\n      label: __chartLabels[______labelIndex] || \"\",\n      value: isChartAnimationActive\n    };\n  }\n  parseObjectData(objectData, ____parsedData, ____________________________________________________________index, _dataSource) {\n    return __chartUpdater.bind(this)(objectData, ____parsedData, ____________________________________________________________index, _dataSource);\n  }\n  update(__timestamp) {\n    const __cachedMetadata = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(__cachedMetadata, 0, __cachedMetadata.length, __timestamp);\n  }\n  getMinMax() {\n    const _______________cachedMeta = this._cachedMeta;\n    const minMaxValues = {\n      min: Number.POSITIVE_INFINITY,\n      max: Number.NEGATIVE_INFINITY\n    };\n    _______________cachedMeta.data.forEach((_dataValue, _______dataIndex) => {\n      const parsedValue = this.getParsed(_______dataIndex).r;\n      if (!isNaN(parsedValue) && this.chart.getDataVisibility(_______dataIndex)) {\n        if (parsedValue < minMaxValues.min) {\n          minMaxValues.min = parsedValue;\n        }\n        if (parsedValue > minMaxValues.max) {\n          minMaxValues.max = parsedValue;\n        }\n      }\n    });\n    return minMaxValues;\n  }\n  _updateRadius() {\n    const _________________________chartInstance = this.chart;\n    const ___chartArea = _________________________chartInstance.chartArea;\n    const ________________chartOptions = _________________________chartInstance.options;\n    const minChartAreaDimension = Math.min(___chartArea.right - ___chartArea.left, ___chartArea.bottom - ___chartArea.top);\n    const ____radius = Math.max(minChartAreaDimension / 2, 0);\n    const cutoutRadiusAdjustment = (____radius - Math.max(________________chartOptions.cutoutPercentage ? ____radius / 100 * ________________chartOptions.cutoutPercentage : 1, 0)) / _________________________chartInstance.getVisibleDatasetCount();\n    this.outerRadius = ____radius - cutoutRadiusAdjustment * this.index;\n    this.innerRadius = this.outerRadius - cutoutRadiusAdjustment;\n  }\n  updateElements(t, e, i, s) {\n    const n = s === \"reset\";\n    const o = this.chart;\n    const a = o.options.animation;\n    const r = this._cachedMeta.rScale;\n    const h = r.xCenter;\n    const l = r.yCenter;\n    const c = r.getIndexAngle(0) - notificationListener * 0.5;\n    let dataIndex;\n    let u = c;\n    const g = 360 / this.countVisibleElements();\n    for (dataIndex = 0; dataIndex < e; ++dataIndex) {\n      u += this._computeAngle(dataIndex, s, g);\n    }\n    for (dataIndex = e; dataIndex < e + i; dataIndex++) {\n      const _dataIndex = t[dataIndex];\n      let angleIncrement = u;\n      let __currentAngle = u + this._computeAngle(dataIndex, s, g);\n      let __distanceFromCenter = o.getDataVisibility(dataIndex) ? r.getDistanceFromCenterForValue(this.getParsed(dataIndex).r) : 0;\n      u = __currentAngle;\n      if (n) {\n        if (a.animateScale) {\n          __distanceFromCenter = 0;\n        }\n        if (a.animateRotate) {\n          angleIncrement = __currentAngle = c;\n        }\n      }\n      const dataPointMetrics = {\n        x: h,\n        y: l,\n        innerRadius: 0,\n        outerRadius: __distanceFromCenter,\n        startAngle: angleIncrement,\n        endAngle: __currentAngle,\n        options: this.resolveDataElementOptions(dataIndex, _dataIndex.active ? \"active\" : s)\n      };\n      this.updateElement(_dataIndex, dataIndex, dataPointMetrics, s);\n    }\n  }\n  countVisibleElements() {\n    const ______cachedMeta = this._cachedMeta;\n    let parsedDataCount = 0;\n    ______cachedMeta.data.forEach((_parsedValue, __________dataIndex) => {\n      if (!isNaN(this.getParsed(__________dataIndex).r) && this.chart.getDataVisibility(__________dataIndex)) {\n        parsedDataCount++;\n      }\n    });\n    return parsedDataCount;\n  }\n  _computeAngle(_____dataPointIndex, ___dataElementOptions, defaultAngle) {\n    if (this.chart.getDataVisibility(_____dataPointIndex)) {\n      return requestAnimation(this.resolveDataElementOptions(_____dataPointIndex, ___dataElementOptions).angle || defaultAngle);\n    } else {\n      return 0;\n    }\n  }\n}\nclass PieChart extends $e {\n  static id = \"pie\";\n  static defaults = {\n    cutout: 0,\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\"\n  };\n}\nclass Ge extends Se {\n  static id = \"radar\";\n  static defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    indexAxis: \"r\",\n    showLine: true,\n    elements: {\n      line: {\n        fill: \"start\"\n      }\n    }\n  };\n  static overrides = {\n    aspectRatio: 1,\n    scales: {\n      r: {\n        type: \"radialLinear\"\n      }\n    }\n  };\n  getLabelAndValue(___________________dataIndex) {\n    const cachedMetaValueScale = this._cachedMeta.vScale;\n    const __parsedDataValue = this.getParsed(___________________dataIndex);\n    return {\n      label: cachedMetaValueScale.getLabels()[___________________dataIndex],\n      value: \"\" + cachedMetaValueScale.getLabelForValue(__parsedDataValue[cachedMetaValueScale.axis])\n    };\n  }\n  parseObjectData(_objectData, __objectData, __________________dataIndex, _____parsedData) {\n    return __chartUpdater.bind(this)(_objectData, __objectData, __________________dataIndex, _____parsedData);\n  }\n  update(_updateType) {\n    const ______cachedMetadata = this._cachedMeta;\n    const _cachedDataset = ______cachedMetadata.dataset;\n    const _cachedData = ______cachedMetadata.data || [];\n    const __labelList = ______cachedMetadata.iScale.getLabels();\n    _cachedDataset.points = _cachedData;\n    if (_updateType !== \"resize\") {\n      const cachedMetadata = this.resolveDatasetElementOptions(_updateType);\n      if (!this.options.showLine) {\n        cachedMetadata.borderWidth = 0;\n      }\n      const datasetUpdateOptions = {\n        _loop: true,\n        _fullLoop: __labelList.length === _cachedData.length,\n        options: cachedMetadata\n      };\n      this.updateElement(_cachedDataset, undefined, datasetUpdateOptions, _updateType);\n    }\n    this.updateElements(_cachedData, 0, _cachedData.length, _updateType);\n  }\n  updateElements(dataElements, ______________startIndex, ____elementCount, elementUpdateStatus) {\n    const cachedRScale = this._cachedMeta.rScale;\n    const isResetStatus = elementUpdateStatus === \"reset\";\n    for (let ________index = ______________startIndex; ________index < ______________startIndex + ____elementCount; ________index++) {\n      const dataElement = dataElements[________index];\n      const dataElementOptions = this.resolveDataElementOptions(________index, dataElement.active ? \"active\" : elementUpdateStatus);\n      const _pointPosition = cachedRScale.getPointPositionForValue(________index, this.getParsed(________index).r);\n      const _xCoordinate = isResetStatus ? cachedRScale.xCenter : _pointPosition.x;\n      const pointYCoordinate = isResetStatus ? cachedRScale.yCenter : _pointPosition.y;\n      const elementPosition = {\n        x: _xCoordinate,\n        y: pointYCoordinate,\n        angle: _pointPosition.angle,\n        skip: isNaN(_xCoordinate) || isNaN(pointYCoordinate),\n        options: dataElementOptions\n      };\n      this.updateElement(dataElement, ________index, elementPosition, elementUpdateStatus);\n    }\n  }\n}\nclass Ke extends Se {\n  static id = \"scatter\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    showLine: false,\n    fill: false\n  };\n  static overrides = {\n    interaction: {\n      mode: \"point\"\n    },\n    scales: {\n      x: {\n        type: \"linear\"\n      },\n      y: {\n        type: \"linear\"\n      }\n    }\n  };\n  getLabelAndValue(______dataPointIndex) {\n    const ___________cachedMeta = this._cachedMeta;\n    const _labelList = this.chart.data.labels || [];\n    const {\n      xScale: _xScale,\n      yScale: yScaleAxis\n    } = ___________cachedMeta;\n    const parsedDataPoint = this.getParsed(______dataPointIndex);\n    const labelForXValue = _xScale.getLabelForValue(parsedDataPoint.x);\n    const labelForYAxisValue = yScaleAxis.getLabelForValue(parsedDataPoint.y);\n    return {\n      label: _labelList[______dataPointIndex] || \"\",\n      value: \"(\" + labelForXValue + \", \" + labelForYAxisValue + \")\"\n    };\n  }\n  update(t) {\n    const e = this._cachedMeta;\n    const {\n      data: i = []\n    } = e;\n    const areAnimationsDisabled = this.chart._animationsDisabled;\n    let {\n      start: n,\n      count: o\n    } = chartAnimationQueue(e, i, areAnimationsDisabled);\n    this._drawStart = n;\n    this._drawCount = o;\n    if (refreshIntervalId(e)) {\n      n = 0;\n      o = i.length;\n    }\n    if (this.options.showLine) {\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {\n        dataset: drawStart,\n        _dataset: drawCount\n      } = e;\n      drawStart._chart = this.chart;\n      drawStart._datasetIndex = this.index;\n      drawStart._decimated = !!drawCount._decimated;\n      drawStart.points = i;\n      const resolvedDatasetElementOptions = this.resolveDatasetElementOptions(t);\n      resolvedDatasetElementOptions.segment = this.options.segment;\n      this.updateElement(drawStart, undefined, {\n        animated: !areAnimationsDisabled,\n        options: resolvedDatasetElementOptions\n      }, t);\n    } else if (this.datasetElementType) {\n      delete e.dataset;\n      this.datasetElementType = false;\n    }\n    this.updateElements(i, n, o, t);\n  }\n  addElements() {\n    const {\n      showLine: isLineVisible\n    } = this.options;\n    if (!this.datasetElementType && isLineVisible) {\n      this.datasetElementType = this.chart.registry.getElement(\"line\");\n    }\n    super.addElements();\n  }\n  updateElements(t, e, i, s) {\n    const n = s === \"reset\";\n    const {\n      iScale: o,\n      vScale: a,\n      _stacked: r,\n      _dataset: h\n    } = this._cachedMeta;\n    const ____currentIndex = this.resolveDataElementOptions(e, s);\n    const c = this.getSharedOptions(____currentIndex);\n    const d = this.includeOptions(s, c);\n    const u = o.axis;\n    const g = a.axis;\n    const {\n      spanGaps: p,\n      segment: m\n    } = this.options;\n    const x = requestId(p) ? p : Number.POSITIVE_INFINITY;\n    const shouldCreateDataPoint = this.chart._animationsDisabled || n || s === \"none\";\n    let _ = e > 0 && this.getParsed(e - 1);\n    for (let ___index = e; ___index < e + i; ++___index) {\n      const ___startIndex = t[___index];\n      const parsedData = this.getParsed(___index);\n      const dataPoint = shouldCreateDataPoint ? ___startIndex : {};\n      const _chartUpdateIntervalValue = chartUpdateInterval(parsedData[g]);\n      const dataPointPixelValue = dataPoint[u] = o.getPixelForValue(parsedData[u], ___index);\n      const _basePixelValue = dataPoint[g] = n || _chartUpdateIntervalValue ? a.getBasePixel() : a.getPixelForValue(r ? this.applyStack(a, parsedData, r) : parsedData[g], ___index);\n      dataPoint.skip = isNaN(dataPointPixelValue) || isNaN(_basePixelValue) || _chartUpdateIntervalValue;\n      dataPoint.stop = ___index > 0 && Math.abs(parsedData[u] - _[u]) > x;\n      if (m) {\n        dataPoint.parsed = parsedData;\n        dataPoint.raw = h.data[___index];\n      }\n      if (d) {\n        dataPoint.options = c || this.resolveDataElementOptions(___index, ___startIndex.active ? \"active\" : s);\n      }\n      if (!shouldCreateDataPoint) {\n        this.updateElement(___startIndex, ___index, dataPoint, s);\n      }\n      _ = parsedData;\n    }\n    this.updateSharedOptions(c, s, ____currentIndex);\n  }\n  getMaxOverflow() {\n    const ____________________cachedMeta = this._cachedMeta;\n    const __dataElements = ____________________cachedMeta.data || [];\n    if (!this.options.showLine) {\n      let cachedMeta = 0;\n      for (let ______________________________index = __dataElements.length - 1; ______________________________index >= 0; --______________________________index) {\n        cachedMeta = Math.max(cachedMeta, __dataElements[______________________________index].size(this.resolveDataElementOptions(______________________________index)) / 2);\n      }\n      return cachedMeta > 0 && cachedMeta;\n    }\n    const ___elementIndex = ____________________cachedMeta.dataset;\n    const ____borderWidth = ___elementIndex.options && ___elementIndex.options.borderWidth || 0;\n    if (!__dataElements.length) {\n      return ____borderWidth;\n    }\n    const firstElementSize = __dataElements[0].size(this.resolveDataElementOptions(0));\n    const _lastDataElementSize = __dataElements[__dataElements.length - 1].size(this.resolveDataElementOptions(__dataElements.length - 1));\n    return Math.max(____borderWidth, firstElementSize, _lastDataElementSize) / 2;\n  }\n}\nvar qe = Object.freeze({\n  __proto__: null,\n  BarController: We,\n  BubbleController: He,\n  DoughnutController: $e,\n  LineController: Ue,\n  PieController: PieChart,\n  PolarAreaController: Ye,\n  RadarController: Ge,\n  ScatterController: Ke\n});\nfunction throwErrorForUnimplementedMethod() {\n  throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nclass CustomClass {\n  static override(propertiesToAssign) {\n    Object.assign(CustomClass.prototype, propertiesToAssign);\n  }\n  options;\n  constructor(_____options) {\n    this.options = _____options || {};\n  }\n  init() {}\n  formats() {\n    return throwErrorForUnimplementedMethod();\n  }\n  parse() {\n    return throwErrorForUnimplementedMethod();\n  }\n  format() {\n    return throwErrorForUnimplementedMethod();\n  }\n  add() {\n    return throwErrorForUnimplementedMethod();\n  }\n  diff() {\n    return throwErrorForUnimplementedMethod();\n  }\n  startOf() {\n    return throwErrorForUnimplementedMethod();\n  }\n  endOf() {\n    return throwErrorForUnimplementedMethod();\n  }\n}\nvar ___animationInstance = {\n  _date: CustomClass\n};\nfunction getChartDataRange(_______chartData, axisIdentifier, __dataIndex, isAnimationInactive) {\n  const {\n    controller: ____chartController,\n    data: chartDataArray,\n    _sorted: _sortedData\n  } = _______chartData;\n  const cachedScaleMeta = ____chartController._cachedMeta.iScale;\n  if (cachedScaleMeta && axisIdentifier === cachedScaleMeta.axis && axisIdentifier !== \"r\" && _sortedData && chartDataArray.length) {\n    const dataTransformationFunction = cachedScaleMeta._reversePixels ? lastAnimationTimestamp : notificationFunction;\n    if (!isAnimationInactive) {\n      return dataTransformationFunction(chartDataArray, axisIdentifier, __dataIndex);\n    }\n    if (____chartController._sharedOptions) {\n      const isAnimationActive = chartDataArray[0];\n      const chartController = typeof isAnimationActive.getRange == \"function\" && isAnimationActive.getRange(axisIdentifier);\n      if (chartController) {\n        const _isAnimationActive = dataTransformationFunction(chartDataArray, axisIdentifier, __dataIndex - chartController);\n        const sortedData = dataTransformationFunction(chartDataArray, axisIdentifier, __dataIndex + chartController);\n        return {\n          lo: _isAnimationActive.lo,\n          hi: sortedData.hi\n        };\n      }\n    }\n  }\n  return {\n    lo: 0,\n    hi: chartDataArray.length - 1\n  };\n}\nfunction processVisibleDataset(____datasetIndex, _____datasetIndex, ______datasetIndex, callbackFunction, visibleDatasetIndex) {\n  const ____sortedVisibleDatasetMetas = ____datasetIndex.getSortedVisibleDatasetMetas();\n  const _currentDataset = ______datasetIndex[_____datasetIndex];\n  for (let ___________________________currentIndex = 0, __arrayLength = ____sortedVisibleDatasetMetas.length; ___________________________currentIndex < __arrayLength; ++___________________________currentIndex) {\n    const {\n      index: ______dataIndex,\n      data: __dataArray\n    } = ____sortedVisibleDatasetMetas[___________________________currentIndex];\n    const {\n      lo: lowerBound,\n      hi: highIndex\n    } = getChartDataRange(____sortedVisibleDatasetMetas[___________________________currentIndex], _____datasetIndex, _currentDataset, visibleDatasetIndex);\n    for (let ____________________________________index = lowerBound; ____________________________________index <= highIndex; ++____________________________________index) {\n      const ____dataElement = __dataArray[____________________________________index];\n      if (!____dataElement.skip) {\n        callbackFunction(____dataElement, ______dataIndex, ____________________________________index);\n      }\n    }\n  }\n}\nfunction calculateDistanceBasedOnAxes(inputString) {\n  const hasXCharacter = inputString.indexOf(\"x\") !== -1;\n  const isYPresent = inputString.indexOf(\"y\") !== -1;\n  return function (pointA, secondPoint) {\n    const horizontalDistance = hasXCharacter ? Math.abs(pointA.x - secondPoint.x) : 0;\n    const deltaY = isYPresent ? Math.abs(pointA.y - secondPoint.y) : 0;\n    return Math.sqrt(Math.pow(horizontalDistance, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction findElementsInRange(_targetElement, _pointCoordinates, _chartElement, __range, isPointInAreaCheck) {\n  const foundElements = [];\n  if (!isPointInAreaCheck && !_targetElement.isPointInArea(_pointCoordinates)) {\n    return foundElements;\n  }\n  processVisibleDataset(_targetElement, _chartElement, _pointCoordinates, function (___chartElement, ________________datasetIndex, _________dataIndex) {\n    if ((isPointInAreaCheck || chartUpdater(___chartElement, _targetElement.chartArea, 0)) && ___chartElement.inRange(_pointCoordinates.x, _pointCoordinates.y, __range)) {\n      foundElements.push({\n        element: ___chartElement,\n        datasetIndex: ________________datasetIndex,\n        index: _________dataIndex\n      });\n    }\n  }, true);\n  return foundElements;\n}\nfunction visibleAnimatedElements(___element, eventCoordinates, ___datasetIndex, propsContext) {\n  let visibleDatasetEntries = [];\n  processVisibleDataset(___element, ___datasetIndex, eventCoordinates, function (elementInstance, __________datasetIndex, elementIndex) {\n    const {\n      startAngle: __startAngle,\n      endAngle: ___endAngle\n    } = elementInstance.getProps([\"startAngle\", \"endAngle\"], propsContext);\n    const {\n      angle: currentAnimationAngle\n    } = _lastAnimationUpdateTimestamp(elementInstance, {\n      x: eventCoordinates.x,\n      y: eventCoordinates.y\n    });\n    if (_animatedChartItems(currentAnimationAngle, __startAngle, ___endAngle)) {\n      visibleDatasetEntries.push({\n        element: elementInstance,\n        datasetIndex: __________datasetIndex,\n        index: elementIndex\n      });\n    }\n  });\n  return visibleDatasetEntries;\n}\nfunction findClosestDataPoints(_dataPoint, targetElement, __dataPoint, isFiltered, searchRadius, isOutsideBoundary) {\n  let closestDataPoints = [];\n  const distanceCalculator = calculateDistanceBasedOnAxes(__dataPoint);\n  let __closestDistance = Number.POSITIVE_INFINITY;\n  processVisibleDataset(_dataPoint, __dataPoint, targetElement, function (__currentElement, __datasetIndex, ___dataIndex) {\n    const isInRange = __currentElement.inRange(targetElement.x, targetElement.y, searchRadius);\n    if (isFiltered && !isInRange) {\n      return;\n    }\n    const _centerPoint = __currentElement.getCenterPoint(searchRadius);\n    if (!isOutsideBoundary && !_dataPoint.isPointInArea(_centerPoint) && !isInRange) {\n      return;\n    }\n    const _distanceToTarget = distanceCalculator(targetElement, _centerPoint);\n    if (_distanceToTarget < __closestDistance) {\n      closestDataPoints = [{\n        element: __currentElement,\n        datasetIndex: __datasetIndex,\n        index: ___dataIndex\n      }];\n      __closestDistance = _distanceToTarget;\n    } else if (_distanceToTarget === __closestDistance) {\n      closestDataPoints.push({\n        element: __currentElement,\n        datasetIndex: __datasetIndex,\n        index: ___dataIndex\n      });\n    }\n  });\n  return closestDataPoints;\n}\nfunction areaCheckHandler(areaChecker, point, regionIdentifier, isValid, ___callbackFunction, isAreaVisible) {\n  if (isAreaVisible || areaChecker.isPointInArea(point)) {\n    if (regionIdentifier !== \"r\" || isValid) {\n      return findClosestDataPoints(areaChecker, point, regionIdentifier, isValid, ___callbackFunction, isAreaVisible);\n    } else {\n      return visibleAnimatedElements(areaChecker, point, regionIdentifier, ___callbackFunction);\n    }\n  } else {\n    return [];\n  }\n}\nfunction isRangeMatched(_dataElement, eventInstance, _axisIdentifier, isReturnEmpty, rangeValue) {\n  const matchedElements = [];\n  const rangeCheckProperty = _axisIdentifier === \"x\" ? \"inXRange\" : \"inYRange\";\n  let _isRangeMatched = false;\n  processVisibleDataset(_dataElement, _axisIdentifier, eventInstance, (__________targetElement, _____________________________________datasetIndex, targetElementIndex) => {\n    if (__________targetElement[rangeCheckProperty](eventInstance[_axisIdentifier], rangeValue)) {\n      matchedElements.push({\n        element: __________targetElement,\n        datasetIndex: _____________________________________datasetIndex,\n        index: targetElementIndex\n      });\n      _isRangeMatched = _isRangeMatched || __________targetElement.inRange(eventInstance.x, eventInstance.y, rangeValue);\n    }\n  });\n  if (isReturnEmpty && !_isRangeMatched) {\n    return [];\n  } else {\n    return matchedElements;\n  }\n}\nvar ____________animationController = {\n  evaluateInteractionItems: processVisibleDataset,\n  modes: {\n    index(dataTarget, lastDateUpdate, options, currentSelection) {\n      const lastDateUpdatedResult = lastDateUpdated(lastDateUpdate, dataTarget);\n      const axisDirection = options.axis || \"x\";\n      const includeInvisible = options.includeInvisible || false;\n      const intersectedDataPoints = options.intersect ? findElementsInRange(dataTarget, lastDateUpdatedResult, axisDirection, currentSelection, includeInvisible) : areaCheckHandler(dataTarget, lastDateUpdatedResult, axisDirection, false, currentSelection, includeInvisible);\n      const visibleDatasetElements = [];\n      if (intersectedDataPoints.length) {\n        dataTarget.getSortedVisibleDatasetMetas().forEach(_currentItem => {\n          const intersectedDataPointIndex = intersectedDataPoints[0].index;\n          const _currentDataPoint = _currentItem.data[intersectedDataPointIndex];\n          if (_currentDataPoint && !_currentDataPoint.skip) {\n            visibleDatasetElements.push({\n              element: _currentDataPoint,\n              datasetIndex: _currentItem.index,\n              index: intersectedDataPointIndex\n            });\n          }\n        });\n        return visibleDatasetElements;\n      } else {\n        return [];\n      }\n    },\n    dataset(currentData, eventObject, interactionOptions, intersectedData) {\n      const _lastDateUpdated = lastDateUpdated(eventObject, currentData);\n      const __axisType = interactionOptions.axis || \"xy\";\n      const _includeInvisible = interactionOptions.includeInvisible || false;\n      let intersectedElements = interactionOptions.intersect ? findElementsInRange(currentData, _lastDateUpdated, __axisType, intersectedData, _includeInvisible) : areaCheckHandler(currentData, _lastDateUpdated, __axisType, false, intersectedData, _includeInvisible);\n      if (intersectedElements.length > 0) {\n        const lastDatasetUpdated = intersectedElements[0].datasetIndex;\n        const _options = currentData.getDatasetMeta(lastDatasetUpdated).data;\n        intersectedElements = [];\n        for (let optionIndex = 0; optionIndex < _options.length; ++optionIndex) {\n          intersectedElements.push({\n            element: _options[optionIndex],\n            datasetIndex: lastDatasetUpdated,\n            index: optionIndex\n          });\n        }\n      }\n      return intersectedElements;\n    },\n    point: (___targetValue, lastEvent, ____axisType, isInvisible) => findElementsInRange(___targetValue, lastDateUpdated(lastEvent, ___targetValue), ____axisType.axis || \"xy\", isInvisible, ____axisType.includeInvisible || false),\n    nearest(timeStamp, ______element, ______chartOptions, intersectingValue) {\n      const _lastUpdateDate = lastDateUpdated(______element, timeStamp);\n      const ___axisType = ______chartOptions.axis || \"xy\";\n      const includeInvisibleInChartOptions = ______chartOptions.includeInvisible || false;\n      return areaCheckHandler(timeStamp, _lastUpdateDate, ___axisType, ______chartOptions.intersect, intersectingValue, includeInvisibleInChartOptions);\n    },\n    x: (____targetValue, lastUpdatedDate, intersectionValue, selectionState) => isRangeMatched(____targetValue, lastDateUpdated(lastUpdatedDate, ____targetValue), \"x\", intersectionValue.intersect, selectionState),\n    y: (_______inputData, lastDateInput, intersectData, status) => isRangeMatched(_______inputData, lastDateUpdated(lastDateInput, _______inputData), \"y\", intersectData.intersect, status)\n  }\n};\nconst chartUpdateHandler = [\"left\", \"top\", \"right\", \"bottom\"];\nfunction filterByPosition(itemsWithMatchingPosition, targetPosition) {\n  return itemsWithMatchingPosition.filter(currentTarget => currentTarget.pos === targetPosition);\n}\nfunction _dataItem(filteredData, _axisValue) {\n  return filteredData.filter(chartUpdateData => chartUpdateHandler.indexOf(chartUpdateData.pos) === -1 && chartUpdateData.box.axis === _axisValue);\n}\nfunction sortByWeightAndIndex(itemsToSort, isSortedAscending) {\n  return itemsToSort.sort((firstItem, secondarySortItem) => {\n    const sortedItem = isSortedAscending ? secondarySortItem : firstItem;\n    const unsortedItem = isSortedAscending ? firstItem : secondarySortItem;\n    if (sortedItem.weight === unsortedItem.weight) {\n      return sortedItem.index - unsortedItem.index;\n    } else {\n      return sortedItem.weight - unsortedItem.weight;\n    }\n  });\n}\nfunction processItems(inputArray) {\n  const processedItems = [];\n  let _itemIndex;\n  let _inputArrayLength;\n  let ___item;\n  let boxPosition;\n  let stackValue;\n  let stackWeight;\n  _itemIndex = 0;\n  _inputArrayLength = (inputArray || []).length;\n  for (; _itemIndex < _inputArrayLength; ++_itemIndex) {\n    ___item = inputArray[_itemIndex];\n    ({\n      position: boxPosition,\n      options: {\n        stack: stackValue,\n        stackWeight = 1\n      }\n    } = ___item);\n    processedItems.push({\n      index: _itemIndex,\n      box: ___item,\n      pos: boxPosition,\n      horizontal: ___item.isHorizontal(),\n      weight: ___item.weight,\n      stack: stackValue && boxPosition + stackValue,\n      stackWeight: stackWeight\n    });\n  }\n  return processedItems;\n}\nfunction processInputArray(_____inputArray) {\n  const stackStatusMap = {};\n  for (const currentStackItem of _____inputArray) {\n    const {\n      stack: _stackValue,\n      pos: _position,\n      stackWeight: _stackWeight\n    } = currentStackItem;\n    if (!_stackValue || !chartUpdateHandler.includes(_position)) {\n      continue;\n    }\n    const stackStatus = stackStatusMap[_stackValue] ||= {\n      count: 0,\n      placed: 0,\n      weight: 0,\n      size: 0\n    };\n    stackStatus.count++;\n    stackStatus.weight += _stackWeight;\n  }\n  return stackStatusMap;\n}\nfunction calculateBoxDimensions(itemsArray, boxDimensions) {\n  const processedInput = processInputArray(itemsArray);\n  const {\n    vBoxMaxWidth: vBoxMaxWidth,\n    hBoxMaxHeight: maxBoxHeight\n  } = boxDimensions;\n  let ____itemIndex;\n  let itemsCount;\n  let _______item;\n  ____itemIndex = 0;\n  itemsCount = itemsArray.length;\n  for (; ____itemIndex < itemsCount; ++____itemIndex) {\n    _______item = itemsArray[____itemIndex];\n    const {\n      fullSize: boxFullSize\n    } = _______item.box;\n    const stackHeight = processedInput[_______item.stack];\n    const _stackWeightRatio = stackHeight && _______item.stackWeight / stackHeight.weight;\n    if (_______item.horizontal) {\n      _______item.width = _stackWeightRatio ? _stackWeightRatio * vBoxMaxWidth : boxFullSize && boxDimensions.availableWidth;\n      _______item.height = maxBoxHeight;\n    } else {\n      _______item.width = vBoxMaxWidth;\n      _______item.height = _stackWeightRatio ? _stackWeightRatio * maxBoxHeight : boxFullSize && boxDimensions.availableHeight;\n    }\n  }\n  return processedInput;\n}\nfunction processInputData(__inputData) {\n  const __processedItems = processItems(__inputData);\n  const fullSizeSortedItems = sortByWeightAndIndex(__processedItems.filter(fullSizeBox => fullSizeBox.box.fullSize), true);\n  const leftItemsSortedByWeight = sortByWeightAndIndex(filterByPosition(__processedItems, \"left\"), true);\n  const rightPositionedItems = sortByWeightAndIndex(filterByPosition(__processedItems, \"right\"));\n  const topSortedItems = sortByWeightAndIndex(filterByPosition(__processedItems, \"top\"), true);\n  const sortedItemsBottom = sortByWeightAndIndex(filterByPosition(__processedItems, \"bottom\"));\n  const dataItemX = _dataItem(__processedItems, \"x\");\n  const yPositionData = _dataItem(__processedItems, \"y\");\n  return {\n    fullSize: fullSizeSortedItems,\n    leftAndTop: leftItemsSortedByWeight.concat(topSortedItems),\n    rightAndBottom: rightPositionedItems.concat(yPositionData).concat(sortedItemsBottom).concat(dataItemX),\n    chartArea: filterByPosition(__processedItems, \"chartArea\"),\n    vertical: leftItemsSortedByWeight.concat(rightPositionedItems).concat(yPositionData),\n    horizontal: topSortedItems.concat(sortedItemsBottom).concat(dataItemX)\n  };\n}\nfunction _________________________________________index(array1, secondArray, __________________________________________index, secondIndex) {\n  return Math.max(array1[__________________________________________index], secondArray[__________________________________________index]) + Math.max(array1[secondIndex], secondArray[secondIndex]);\n}\nfunction _____boundingBox(boundingRect, _rectangle) {\n  boundingRect.top = Math.max(boundingRect.top, _rectangle.top);\n  boundingRect.left = Math.max(boundingRect.left, _rectangle.left);\n  boundingRect.bottom = Math.max(boundingRect.bottom, _rectangle.bottom);\n  boundingRect.right = Math.max(boundingRect.right, _rectangle.right);\n}\nfunction updatePaddingDimensions(paddingDimensions, stackDetails, item, stackSizingInfo) {\n  const {\n    pos: paddingPosition,\n    box: _boxDimensions\n  } = item;\n  const _maxPaddingValue = paddingDimensions.maxPadding;\n  if (!currentAnimationIndex(paddingPosition)) {\n    if (item.size) {\n      paddingDimensions[paddingPosition] -= item.size;\n    }\n    const stackSizing = stackSizingInfo[item.stack] || {\n      size: 0,\n      count: 1\n    };\n    stackSizing.size = Math.max(stackSizing.size, item.horizontal ? _boxDimensions.height : _boxDimensions.width);\n    item.size = stackSizing.size / stackSizing.count;\n    paddingDimensions[paddingPosition] += item.size;\n  }\n  if (_boxDimensions.getPadding) {\n    _____boundingBox(_maxPaddingValue, _boxDimensions.getPadding());\n  }\n  const remainingWidth = Math.max(0, stackDetails.outerWidth - _________________________________________index(_maxPaddingValue, paddingDimensions, \"left\", \"right\"));\n  const remainingVerticalPadding = Math.max(0, stackDetails.outerHeight - _________________________________________index(_maxPaddingValue, paddingDimensions, \"top\", \"bottom\"));\n  const isWidthChanged = remainingWidth !== paddingDimensions.w;\n  const isHeightChanged = remainingVerticalPadding !== paddingDimensions.h;\n  paddingDimensions.w = remainingWidth;\n  paddingDimensions.h = remainingVerticalPadding;\n  if (item.horizontal) {\n    return {\n      same: isWidthChanged,\n      other: isHeightChanged\n    };\n  } else {\n    return {\n      same: isHeightChanged,\n      other: isWidthChanged\n    };\n  }\n}\nfunction adjustPadding(_paddingAdjustment) {\n  const maxPaddingValues = _paddingAdjustment.maxPadding;\n  function calculatePaddingAdjustment(______________________________________________________________index) {\n    const maxAdjustedValue = Math.max(maxPaddingValues[______________________________________________________________index] - _paddingAdjustment[______________________________________________________________index], 0);\n    _paddingAdjustment[______________________________________________________________index] += maxAdjustedValue;\n    return maxAdjustedValue;\n  }\n  _paddingAdjustment.y += calculatePaddingAdjustment(\"top\");\n  _paddingAdjustment.x += calculatePaddingAdjustment(\"left\");\n  calculatePaddingAdjustment(\"right\");\n  calculatePaddingAdjustment(\"bottom\");\n}\nfunction calculatePadding(isHorizontal, _paddingConfig) {\n  const maxPaddingValue = _paddingConfig.maxPadding;\n  function _paddingValues(paddingSizes) {\n    const paddingValues = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    paddingSizes.forEach(_________________________________________________index => {\n      paddingValues[_________________________________________________index] = Math.max(_paddingConfig[_________________________________________________index], maxPaddingValue[_________________________________________________index]);\n    });\n    return paddingValues;\n  }\n  return _paddingValues(isHorizontal ? [\"left\", \"right\"] : [\"top\", \"bottom\"]);\n}\nfunction processDimensions(_inputArray, dimensions, _________index, updateStatus) {\n  const nonFullSizeItems = [];\n  let ___________________________________________________________________currentIndex;\n  let ________inputArrayLength;\n  let currentDimension;\n  let boxReference;\n  let hasSameDimensionsFlag;\n  let otherDimensionResult;\n  ___________________________________________________________________currentIndex = 0;\n  ________inputArrayLength = _inputArray.length;\n  hasSameDimensionsFlag = 0;\n  for (; ___________________________________________________________________currentIndex < ________inputArrayLength; ++___________________________________________________________________currentIndex) {\n    currentDimension = _inputArray[___________________________________________________________________currentIndex];\n    boxReference = currentDimension.box;\n    boxReference.update(currentDimension.width || dimensions.w, currentDimension.height || dimensions.h, calculatePadding(currentDimension.horizontal, dimensions));\n    const {\n      same: sameDimensionStatus,\n      other: otherDimension\n    } = updatePaddingDimensions(dimensions, _________index, currentDimension, updateStatus);\n    hasSameDimensionsFlag |= sameDimensionStatus && nonFullSizeItems.length;\n    otherDimensionResult = otherDimensionResult || otherDimension;\n    if (!boxReference.fullSize) {\n      nonFullSizeItems.push(currentDimension);\n    }\n  }\n  return hasSameDimensionsFlag && processDimensions(nonFullSizeItems, dimensions, _________index, updateStatus) || otherDimensionResult;\n}\nfunction setBoundingBox(__rectangle, leftCoordinate, topPosition, rectangleWidth, height) {\n  __rectangle.top = topPosition;\n  __rectangle.left = leftCoordinate;\n  __rectangle.right = leftCoordinate + rectangleWidth;\n  __rectangle.bottom = topPosition + height;\n  __rectangle.width = rectangleWidth;\n  __rectangle.height = height;\n}\nfunction layoutItems(items, positionData, paddingConfig, stackMetrics) {\n  const __paddingValues = paddingConfig.padding;\n  let {\n    x: currentStartX,\n    y: currentYPosition\n  } = positionData;\n  for (const ________item of items) {\n    const boxElement = ________item.box;\n    const stackMetricsEntry = stackMetrics[________item.stack] || {\n      count: 1,\n      placed: 0,\n      weight: 1\n    };\n    const stackWeightRatio = ________item.stackWeight / stackMetricsEntry.weight || 1;\n    if (________item.horizontal) {\n      const stackedItemSize = positionData.w * stackWeightRatio;\n      const currentHeightOrWidth = stackMetricsEntry.size || boxElement.height;\n      if (canvasContext(stackMetricsEntry.start)) {\n        currentYPosition = stackMetricsEntry.start;\n      }\n      if (boxElement.fullSize) {\n        setBoundingBox(boxElement, __paddingValues.left, currentYPosition, paddingConfig.outerWidth - __paddingValues.right - __paddingValues.left, currentHeightOrWidth);\n      } else {\n        setBoundingBox(boxElement, positionData.left + stackMetricsEntry.placed, currentYPosition, stackedItemSize, currentHeightOrWidth);\n      }\n      stackMetricsEntry.start = currentYPosition;\n      stackMetricsEntry.placed += stackedItemSize;\n      currentYPosition = boxElement.bottom;\n    } else {\n      const calculatedSize = positionData.h * stackWeightRatio;\n      const currentStartPosition = stackMetricsEntry.size || boxElement.width;\n      if (canvasContext(stackMetricsEntry.start)) {\n        currentStartX = stackMetricsEntry.start;\n      }\n      if (boxElement.fullSize) {\n        setBoundingBox(boxElement, currentStartX, __paddingValues.top, currentStartPosition, paddingConfig.outerHeight - __paddingValues.bottom - __paddingValues.top);\n      } else {\n        setBoundingBox(boxElement, currentStartX, positionData.top + stackMetricsEntry.placed, currentStartPosition, calculatedSize);\n      }\n      stackMetricsEntry.start = currentStartX;\n      stackMetricsEntry.placed += calculatedSize;\n      currentStartX = boxElement.right;\n    }\n  }\n  positionData.x = currentStartX;\n  positionData.y = currentYPosition;\n}\nvar ___________animationIndex = {\n  addBox(boxContainer, boxOptions) {\n    boxContainer.boxes ||= [];\n    boxOptions.fullSize = boxOptions.fullSize || false;\n    boxOptions.position = boxOptions.position || \"top\";\n    boxOptions.weight = boxOptions.weight || 0;\n    boxOptions._layers = boxOptions._layers || function () {\n      return [{\n        z: 0,\n        draw(drawTime) {\n          boxOptions.draw(drawTime);\n        }\n      }];\n    };\n    boxContainer.boxes.push(boxOptions);\n  },\n  removeBox(_boxContainer, boxToRemove) {\n    const boxIndex = _boxContainer.boxes ? _boxContainer.boxes.indexOf(boxToRemove) : -1;\n    if (boxIndex !== -1) {\n      _boxContainer.boxes.splice(boxIndex, 1);\n    }\n  },\n  configure(configurationObject, elementConfig, _inputConfig) {\n    elementConfig.fullSize = _inputConfig.fullSize;\n    elementConfig.position = _inputConfig.position;\n    elementConfig.weight = _inputConfig.weight;\n  },\n  update(chart, outerWidth, availableHeight, layoutData) {\n    if (!chart) {\n      return;\n    }\n    const layoutPadding = __animationElement(chart.options.layout.padding);\n    const availableWidth = Math.max(outerWidth - layoutPadding.width, 0);\n    const _availableHeight = Math.max(availableHeight - layoutPadding.height, 0);\n    const boxLayout = processInputData(chart.boxes);\n    const verticalBoxes = boxLayout.vertical;\n    const horizontalBoxes = boxLayout.horizontal;\n    __lastDateUpdated(chart.boxes, _layoutContext => {\n      if (typeof _layoutContext.beforeLayout == \"function\") {\n        _layoutContext.beforeLayout();\n      }\n    });\n    const visibleBoxCount = verticalBoxes.reduce((__________________________________currentIndex, _boxOptions) => _boxOptions.box.options && _boxOptions.box.options.display === false ? __________________________________currentIndex : __________________________________currentIndex + 1, 0) || 1;\n    const layoutDimensions = Object.freeze({\n      outerWidth: outerWidth,\n      outerHeight: availableHeight,\n      padding: layoutPadding,\n      availableWidth: availableWidth,\n      availableHeight: _availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleBoxCount,\n      hBoxMaxHeight: _availableHeight / 2\n    });\n    const paddingCopy = Object.assign({}, layoutPadding);\n    _____boundingBox(paddingCopy, __animationElement(layoutData));\n    const layoutDimensionsAndPosition = Object.assign({\n      maxPadding: paddingCopy,\n      w: availableWidth,\n      h: _availableHeight,\n      x: layoutPadding.left,\n      y: layoutPadding.top\n    }, layoutPadding);\n    const layoutPositionData = calculateBoxDimensions(verticalBoxes.concat(horizontalBoxes), layoutDimensions);\n    processDimensions(boxLayout.fullSize, layoutDimensionsAndPosition, layoutDimensions, layoutPositionData);\n    processDimensions(verticalBoxes, layoutDimensionsAndPosition, layoutDimensions, layoutPositionData);\n    if (processDimensions(horizontalBoxes, layoutDimensionsAndPosition, layoutDimensions, layoutPositionData)) {\n      processDimensions(verticalBoxes, layoutDimensionsAndPosition, layoutDimensions, layoutPositionData);\n    }\n    adjustPadding(layoutDimensionsAndPosition);\n    layoutItems(boxLayout.leftAndTop, layoutDimensionsAndPosition, layoutDimensions, layoutPositionData);\n    layoutDimensionsAndPosition.x += layoutDimensionsAndPosition.w;\n    layoutDimensionsAndPosition.y += layoutDimensionsAndPosition.h;\n    layoutItems(boxLayout.rightAndBottom, layoutDimensionsAndPosition, layoutDimensions, layoutPositionData);\n    chart.chartArea = {\n      left: layoutDimensionsAndPosition.left,\n      top: layoutDimensionsAndPosition.top,\n      right: layoutDimensionsAndPosition.left + layoutDimensionsAndPosition.w,\n      bottom: layoutDimensionsAndPosition.top + layoutDimensionsAndPosition.h,\n      height: layoutDimensionsAndPosition.h,\n      width: layoutDimensionsAndPosition.w\n    };\n    __lastDateUpdated(boxLayout.chartArea, _____event => {\n      const chartBox = _____event.box;\n      Object.assign(chartBox, chart.chartArea);\n      chartBox.update(layoutDimensionsAndPosition.w, layoutDimensionsAndPosition.h, {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      });\n    });\n  }\n};\nclass DeviceInteraction {\n  acquireContext(contextToAcquire, __eventObject) {}\n  releaseContext(releaseInfo) {\n    return false;\n  }\n  addEventListener(_________eventType, _________eventHandler, __eventListenerOptions) {}\n  removeEventListener(________eventType, ________eventHandler, _eventListenerOptions) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(elementSize, maxWidth, heightFallback, aspectRatio) {\n    maxWidth = Math.max(0, maxWidth || elementSize.width);\n    heightFallback = heightFallback || elementSize.height;\n    return {\n      width: maxWidth,\n      height: Math.max(0, aspectRatio ? Math.floor(maxWidth / aspectRatio) : heightFallback)\n    };\n  }\n  isAttached(_elementId) {\n    return true;\n  }\n  updateConfig(configUpdates) {}\n}\nclass canvas2DContext extends DeviceInteraction {\n  acquireContext(______canvasElement) {\n    return ______canvasElement && ______canvasElement.getContext && ______canvasElement.getContext(\"2d\") || null;\n  }\n  updateConfig(_config) {\n    _config.options.animation = false;\n  }\n}\nconst _____animationController = \"$chartjs\";\nconst ___animationHandler = {\n  touchstart: \"mousedown\",\n  touchmove: \"mousemove\",\n  touchend: \"mouseup\",\n  pointerenter: \"mouseenter\",\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointerleave: \"mouseout\",\n  pointerout: \"mouseout\"\n};\nconst lastUpdateTimestamp = ________________inputValue => ________________inputValue === null || ________________inputValue === \"\";\nfunction updateElementDimensions(element, updatedWidth) {\n  const elementStyle = element.style;\n  const _currentHeight = element.getAttribute(\"height\");\n  const currentElementWidth = element.getAttribute(\"width\");\n  element[_____animationController] = {\n    initial: {\n      height: _currentHeight,\n      width: currentElementWidth,\n      style: {\n        display: elementStyle.display,\n        height: elementStyle.height,\n        width: elementStyle.width\n      }\n    }\n  };\n  elementStyle.display = elementStyle.display || \"block\";\n  elementStyle.boxSizing = elementStyle.boxSizing || \"border-box\";\n  if (lastUpdateTimestamp(currentElementWidth)) {\n    const chartAnimationIdWidth = chartAnimationId(element, \"width\");\n    if (chartAnimationIdWidth !== undefined) {\n      element.width = chartAnimationIdWidth;\n    }\n  }\n  if (lastUpdateTimestamp(_currentHeight)) {\n    if (element.style.height === \"\") {\n      element.height = element.width / (updatedWidth || 2);\n    } else {\n      const _updatedWidth = chartAnimationId(element, \"height\");\n      if (_updatedWidth !== undefined) {\n        element.height = _updatedWidth;\n      }\n    }\n  }\n  return element;\n}\nconst ______animationController = !!_notificationFunction && {\n  passive: true\n};\nfunction addEventListenerToTarget(eventTarget, ____eventType, _____eventHandler) {\n  eventTarget.addEventListener(____eventType, _____eventHandler, ______animationController);\n}\nfunction removeCanvasEventListener(___canvasElement, ___eventType, ____eventHandler) {\n  ___canvasElement.canvas.removeEventListener(___eventType, ____eventHandler, ______animationController);\n}\nfunction ___________eventHandler(_eventData, ___________________chartData) {\n  const _____________eventType = ___animationHandler[_eventData.type] || _eventData.type;\n  const {\n    x: lastUpdatedX,\n    y: lastYValue\n  } = lastDateUpdated(_eventData, ___________________chartData);\n  return {\n    type: _____________eventType,\n    chart: ___________________chartData,\n    native: _eventData,\n    x: lastUpdatedX !== undefined ? lastUpdatedX : null,\n    y: lastYValue !== undefined ? lastYValue : null\n  };\n}\nfunction isElementPresent(_itemsArray, elementToFind) {\n  for (const ______item of _itemsArray) {\n    if (______item === elementToFind || ______item.contains(elementToFind)) {\n      return true;\n    }\n  }\n}\nfunction createMutationObserver(__canvasElement, isCanvasUpdated, _callbackFunction) {\n  const ____canvasElement = __canvasElement.canvas;\n  const mutationObserver = new MutationObserver(nodeList => {\n    let isNodeStateValid = false;\n    for (const nodeIterator of nodeList) {\n      isNodeStateValid = isNodeStateValid || isElementPresent(nodeIterator.addedNodes, ____canvasElement);\n      isNodeStateValid = isNodeStateValid && !isElementPresent(nodeIterator.removedNodes, ____canvasElement);\n    }\n    if (isNodeStateValid) {\n      _callbackFunction();\n    }\n  });\n  mutationObserver.observe(document, {\n    childList: true,\n    subtree: true\n  });\n  return mutationObserver;\n}\nfunction setupMutationObserver(mutationObserverConfig, isCanvasRemoved, __callbackFunction) {\n  const _____canvasElement = mutationObserverConfig.canvas;\n  const _mutationObserver = new MutationObserver(nodeMutations => {\n    let isElementDeleted = false;\n    for (const nodeMutation of nodeMutations) {\n      isElementDeleted = isElementDeleted || isElementPresent(nodeMutation.removedNodes, _____canvasElement);\n      isElementDeleted = isElementDeleted && !isElementPresent(nodeMutation.addedNodes, _____canvasElement);\n    }\n    if (isElementDeleted) {\n      __callbackFunction();\n    }\n  });\n  _mutationObserver.observe(document, {\n    childList: true,\n    subtree: true\n  });\n  return _mutationObserver;\n}\nconst ____animationManager = new Map();\nlet activeChart = 0;\nfunction updateActiveChartOnDeviceChange() {\n  const currentDevicePixelRatio = window.devicePixelRatio;\n  if (currentDevicePixelRatio !== activeChart) {\n    activeChart = currentDevicePixelRatio;\n    ____animationManager.forEach((executeOnDeviceChange, _callbackIndex) => {\n      if (_callbackIndex.currentDevicePixelRatio !== currentDevicePixelRatio) {\n        executeOnDeviceChange();\n      }\n    });\n  }\n}\nfunction handleAnimation(__animationKey, __animationProperties) {\n  if (!____animationManager.size) {\n    window.addEventListener(\"resize\", updateActiveChartOnDeviceChange);\n  }\n  ____animationManager.set(__animationKey, __animationProperties);\n}\nfunction removeAnimationById(animationId) {\n  ____animationManager.delete(animationId);\n  if (!____animationManager.size) {\n    window.removeEventListener(\"resize\", updateActiveChartOnDeviceChange);\n  }\n}\nfunction resizeObserverCallback(canvasElement, resizeObserverEntry, resizeHandler) {\n  const canvasElementReference = canvasElement.canvas;\n  const ________requestAnimationFrameId = canvasElementReference && requestAnimationFrameUniqueId(canvasElementReference);\n  if (!________requestAnimationFrameId) {\n    return;\n  }\n  const requestAnimationFrameCallback = _____requestAnimationFrameId((_eventTarget, ________________event) => {\n    const clientWidth = ________requestAnimationFrameId.clientWidth;\n    resizeHandler(_eventTarget, ________________event);\n    if (clientWidth < ________requestAnimationFrameId.clientWidth) {\n      resizeHandler();\n    }\n  }, window);\n  const resizeObserver = new ResizeObserver(resizeObserverEntries => {\n    const elementEntry = resizeObserverEntries[0];\n    const contentRectWidth = elementEntry.contentRect.width;\n    const contentRectHeight = elementEntry.contentRect.height;\n    if (contentRectWidth !== 0 || contentRectHeight !== 0) {\n      requestAnimationFrameCallback(contentRectWidth, contentRectHeight);\n    }\n  });\n  resizeObserver.observe(________requestAnimationFrameId);\n  handleAnimation(canvasElement, requestAnimationFrameCallback);\n  return resizeObserver;\n}\nfunction uiHandler(uiElement, __eventType, connectionInstance) {\n  if (connectionInstance) {\n    connectionInstance.disconnect();\n  }\n  if (__eventType === \"resize\") {\n    removeAnimationById(uiElement);\n  }\n}\nfunction initializeCanvasAnimation(______________canvasContext, _________event, _eventHandler) {\n  const _______canvasElement = ______________canvasContext.canvas;\n  const _______animationFrameId = _____requestAnimationFrameId(__________________event => {\n    if (______________canvasContext.ctx !== null) {\n      _eventHandler(___________eventHandler(__________________event, ______________canvasContext));\n    }\n  }, ______________canvasContext);\n  addEventListenerToTarget(_______canvasElement, _________event, _______animationFrameId);\n  return _______animationFrameId;\n}\nclass CanvasInteraction extends DeviceInteraction {\n  acquireContext(__________canvasElement, ___________canvasElement) {\n    const _canvas2DContext = __________canvasElement && __________canvasElement.getContext && __________canvasElement.getContext(\"2d\");\n    if (_canvas2DContext && _canvas2DContext.canvas === __________canvasElement) {\n      updateElementDimensions(__________canvasElement, ___________canvasElement);\n      return _canvas2DContext;\n    } else {\n      return null;\n    }\n  }\n  releaseContext(________canvasElement) {\n    const _________canvasElement = ________canvasElement.canvas;\n    if (!_________canvasElement[_____animationController]) {\n      return false;\n    }\n    const animationControllerInitialValues = _________canvasElement[_____animationController].initial;\n    [\"height\", \"width\"].forEach(attributeKey => {\n      const valueAtIndex = animationControllerInitialValues[attributeKey];\n      if (chartUpdateInterval(valueAtIndex)) {\n        _________canvasElement.removeAttribute(attributeKey);\n      } else {\n        _________canvasElement.setAttribute(attributeKey, valueAtIndex);\n      }\n    });\n    const initialStyles = animationControllerInitialValues.style || {};\n    Object.keys(initialStyles).forEach(styleProperty => {\n      _________canvasElement.style[styleProperty] = initialStyles[styleProperty];\n    });\n    _________canvasElement.width = _________canvasElement.width;\n    delete _________canvasElement[_____animationController];\n    return true;\n  }\n  addEventListener(___________eventType, ____________eventType, __________options) {\n    this.removeEventListener(___________eventType, ____________eventType);\n    const proxies = ___________eventType.$proxies ||= {};\n    const eventHandlerFunction = {\n      attach: createMutationObserver,\n      detach: setupMutationObserver,\n      resize: resizeObserverCallback\n    }[____________eventType] || initializeCanvasAnimation;\n    proxies[____________eventType] = eventHandlerFunction(___________eventType, ____________eventType, __________options);\n  }\n  removeEventListener(_________targetElement, __________eventType) {\n    const eventProxies = _________targetElement.$proxies ||= {};\n    const __________eventHandler = eventProxies[__________eventType];\n    if (!__________eventHandler) {\n      return;\n    }\n    ({\n      attach: uiHandler,\n      detach: uiHandler,\n      resize: uiHandler\n    }[__________eventType] || removeCanvasEventListener)(_________targetElement, __________eventType, __________eventHandler);\n    eventProxies[__________eventType] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(animationInput, _______________element, ______animationIndex, __scaleFactor) {\n    return _____animationIndex(animationInput, _______________element, ______animationIndex, __scaleFactor);\n  }\n  isAttached(____animationFrameId) {\n    const _____animationFrameId = requestAnimationFrameUniqueId(____animationFrameId);\n    return !!_____animationFrameId && !!_____animationFrameId.isConnected;\n  }\n}\nfunction getCanvasContext(canvasObject) {\n  if (!_________animationManager() || typeof OffscreenCanvas != \"undefined\" && canvasObject instanceof OffscreenCanvas) {\n    return canvas2DContext;\n  } else {\n    return CanvasInteraction;\n  }\n}\nclass _AnimationController {\n  static defaults = {};\n  static defaultRoutes = undefined;\n  x;\n  y;\n  active = false;\n  options;\n  $animations;\n  tooltipPosition(______tooltipData) {\n    const {\n      x: tooltipXPosition,\n      y: tooltipYPosition\n    } = this.getProps([\"x\", \"y\"], ______tooltipData);\n    return {\n      x: tooltipXPosition,\n      y: tooltipYPosition\n    };\n  }\n  hasValue() {\n    return requestId(this.x) && requestId(this.y);\n  }\n  getProps(timeIndices, animationProps) {\n    const animationsMap = this.$animations;\n    if (!animationProps || !animationsMap) {\n      return this;\n    }\n    const animationStates = {};\n    timeIndices.forEach(timeIndex => {\n      animationStates[timeIndex] = animationsMap[timeIndex] && animationsMap[timeIndex].active() ? animationsMap[timeIndex]._to : this[timeIndex];\n    });\n    return animationStates;\n  }\n}\nfunction calculateChartTicks(_____chartData, ______chartData) {\n  const tickOptions = _____chartData.options.ticks;\n  const __tickCount = calculateTickCount(_____chartData);\n  const maxTicksLimit = Math.min(tickOptions.maxTicksLimit || __tickCount, __tickCount);\n  const majorTickIndices = tickOptions.major.enabled ? findMajorIndices(______chartData) : [];\n  const majorIndicesCount = majorTickIndices.length;\n  const firstMajorIndex = majorTickIndices[0];\n  const lastMajorIndex = majorTickIndices[majorIndicesCount - 1];\n  const tickIndices = [];\n  if (majorIndicesCount > maxTicksLimit) {\n    targetStep(______chartData, tickIndices, majorTickIndices, majorIndicesCount / maxTicksLimit);\n    return tickIndices;\n  }\n  const sequenceMaxValue = calculateSequenceMax(majorTickIndices, ______chartData, maxTicksLimit);\n  if (majorIndicesCount > 0) {\n    let _______________________________________currentIndex;\n    let __tickOptions;\n    const ___tickCount = majorIndicesCount > 1 ? Math.round((lastMajorIndex - firstMajorIndex) / (majorIndicesCount - 1)) : null;\n    calculateAnimationIndex(______chartData, tickIndices, sequenceMaxValue, chartUpdateInterval(___tickCount) ? 0 : firstMajorIndex - ___tickCount, firstMajorIndex);\n    _______________________________________currentIndex = 0;\n    __tickOptions = majorIndicesCount - 1;\n    for (; _______________________________________currentIndex < __tickOptions; _______________________________________currentIndex++) {\n      calculateAnimationIndex(______chartData, tickIndices, sequenceMaxValue, majorTickIndices[_______________________________________currentIndex], majorTickIndices[_______________________________________currentIndex + 1]);\n    }\n    calculateAnimationIndex(______chartData, tickIndices, sequenceMaxValue, lastMajorIndex, chartUpdateInterval(___tickCount) ? ______chartData.length : lastMajorIndex + ___tickCount);\n    return tickIndices;\n  }\n  calculateAnimationIndex(______chartData, tickIndices, sequenceMaxValue);\n  return tickIndices;\n}\nfunction calculateTickCount(chartDimension) {\n  const ____offsetValue = chartDimension.options.offset;\n  const tickSize = chartDimension._tickSize();\n  const _tickCount = chartDimension._length / tickSize + (____offsetValue ? 0 : 1);\n  const maxTicksCount = chartDimension._maxLength / tickSize;\n  return Math.floor(Math.min(_tickCount, maxTicksCount));\n}\nfunction calculateSequenceMax(__inputValue, sequenceLength, _segmentLength) {\n  const hasConstantDifference = isConstantDifference(__inputValue);\n  const numberOfSegments = sequenceLength.length / _segmentLength;\n  if (!hasConstantDifference) {\n    return Math.max(numberOfSegments, 1);\n  }\n  const currentFrameTimestamps = _currentFrameTimestamp(hasConstantDifference);\n  for (let ________________________________________________________currentIndex = 0, _____lastIndex = currentFrameTimestamps.length - 1; ________________________________________________________currentIndex < _____lastIndex; ________________________________________________________currentIndex++) {\n    const ___lastIndex = currentFrameTimestamps[________________________________________________________currentIndex];\n    if (___lastIndex > numberOfSegments) {\n      return ___lastIndex;\n    }\n  }\n  return Math.max(numberOfSegments, 1);\n}\nfunction findMajorIndices(__________inputArray) {\n  const majorIndices = [];\n  let _____________________________________________currentIndex;\n  let ____inputArrayLength;\n  _____________________________________________currentIndex = 0;\n  ____inputArrayLength = __________inputArray.length;\n  for (; _____________________________________________currentIndex < ____inputArrayLength; _____________________________________________currentIndex++) {\n    if (__________inputArray[_____________________________________________currentIndex].major) {\n      majorIndices.push(_____________________________________________currentIndex);\n    }\n  }\n  return majorIndices;\n}\nfunction targetStep(_________inputArray, extractedElements, indexThreshold, stepIndex) {\n  let currentInputIndex;\n  let ____________________________currentIndex = 0;\n  let currentIndexThreshold = indexThreshold[0];\n  stepIndex = Math.ceil(stepIndex);\n  currentInputIndex = 0;\n  for (; currentInputIndex < _________inputArray.length; currentInputIndex++) {\n    if (currentInputIndex === currentIndexThreshold) {\n      extractedElements.push(_________inputArray[currentInputIndex]);\n      ____________________________currentIndex++;\n      currentIndexThreshold = indexThreshold[____________________________currentIndex * stepIndex];\n    }\n  }\n}\nfunction calculateAnimationIndex(__inputArray, outputArray, intervalSize, animationStartIndex, animationFrameIndex) {\n  const startingAnimationIndex = chartAnimationRunning(animationStartIndex, 0);\n  const maxAnimationFrameIndex = Math.min(chartAnimationRunning(animationFrameIndex, __inputArray.length), __inputArray.length);\n  let ________animationDuration;\n  let ___animationIndex;\n  let animationCurrentStep;\n  let animationStepCount = 0;\n  intervalSize = Math.ceil(intervalSize);\n  if (animationFrameIndex) {\n    ________animationDuration = animationFrameIndex - animationStartIndex;\n    intervalSize = ________animationDuration / Math.floor(________animationDuration / intervalSize);\n  }\n  animationCurrentStep = startingAnimationIndex;\n  while (animationCurrentStep < 0) {\n    animationStepCount++;\n    animationCurrentStep = Math.round(startingAnimationIndex + animationStepCount * intervalSize);\n  }\n  for (___animationIndex = Math.max(startingAnimationIndex, 0); ___animationIndex < maxAnimationFrameIndex; ___animationIndex++) {\n    if (___animationIndex === animationCurrentStep) {\n      outputArray.push(__inputArray[___animationIndex]);\n      animationStepCount++;\n      animationCurrentStep = Math.round(startingAnimationIndex + animationStepCount * intervalSize);\n    }\n  }\n}\nfunction isConstantDifference(________inputArray) {\n  const ___inputArrayLength = ________inputArray.length;\n  let __________________________________________currentIndex;\n  let initialDifference;\n  if (___inputArrayLength < 2) {\n    return false;\n  }\n  initialDifference = ________inputArray[0];\n  __________________________________________currentIndex = 1;\n  for (; __________________________________________currentIndex < ___inputArrayLength; ++__________________________________________currentIndex) {\n    if (________inputArray[__________________________________________currentIndex] - ________inputArray[__________________________________________currentIndex - 1] !== initialDifference) {\n      return false;\n    }\n  }\n  return initialDifference;\n}\nconst _animationTask = directionToggle => directionToggle === \"left\" ? \"right\" : directionToggle === \"right\" ? \"left\" : directionToggle;\nconst listenerMap = (_positionAdjustment, __position, _____offsetValue) => __position === \"top\" || __position === \"left\" ? _positionAdjustment[__position] + _____offsetValue : _positionAdjustment[__position] - _____offsetValue;\nconst _animationRequestId = (minimumValue, optionalValue) => Math.min(optionalValue || minimumValue, minimumValue);\nfunction arraySliceByStep(sourceArray, _numSegments) {\n  const slicedArrayElements = [];\n  const segmentSize = sourceArray.length / _numSegments;\n  const totalElements = sourceArray.length;\n  let ____________________________________________currentIndex = 0;\n  for (; ____________________________________________currentIndex < totalElements; ____________________________________________currentIndex += segmentSize) {\n    slicedArrayElements.push(sourceArray[Math.floor(____________________________________________currentIndex)]);\n  }\n  return slicedArrayElements;\n}\nfunction calculateTickPosition(tickData, _tickIndex, __tickIndex) {\n  const totalTickCount = tickData.ticks.length;\n  const validTickIndex = Math.min(_tickIndex, totalTickCount - 1);\n  const startPixel = tickData._startPixel;\n  const endPixel = tickData._endPixel;\n  const tolerance = 0.000001;\n  let tickPositionAdjustment;\n  let currentTickPosition = tickData.getPixelForTick(validTickIndex);\n  if (!__tickIndex || !(tickPositionAdjustment = totalTickCount === 1 ? Math.max(currentTickPosition - startPixel, endPixel - currentTickPosition) : _tickIndex === 0 ? (tickData.getPixelForTick(1) - currentTickPosition) / 2 : (currentTickPosition - tickData.getPixelForTick(validTickIndex - 1)) / 2, currentTickPosition += validTickIndex < _tickIndex ? tickPositionAdjustment : -tickPositionAdjustment, currentTickPosition < startPixel - tolerance || currentTickPosition > endPixel + tolerance)) {\n    return currentTickPosition;\n  }\n}\nfunction handleDataCleanup(__dataObject, _threshold) {\n  __lastDateUpdated(__dataObject, gcData => {\n    const gcArray = gcData.gc;\n    const halfLengthOfGc = gcArray.length / 2;\n    let _____________________________________________index;\n    if (halfLengthOfGc > _threshold) {\n      for (_____________________________________________index = 0; _____________________________________________index < halfLengthOfGc; ++_____________________________________________index) {\n        delete gcData.data[gcArray[_____________________________________________index]];\n      }\n      gcArray.splice(0, halfLengthOfGc);\n    }\n  });\n}\nfunction getTickLength(lineStyle) {\n  if (lineStyle.drawTicks) {\n    return lineStyle.tickLength;\n  } else {\n    return 0;\n  }\n}\nfunction calculateChartSize(_____chartOptions, fontElement) {\n  if (!_____chartOptions.display) {\n    return 0;\n  }\n  const animationFrameResult = requestAnimationFrame(_____chartOptions.font, fontElement);\n  const __paddingAdjustment = __animationElement(_____chartOptions.padding);\n  return (animatedChartItems(_____chartOptions.text) ? _____chartOptions.text.length : 1) * animationFrameResult.lineHeight + __paddingAdjustment.height;\n}\nfunction __tooltipHandlerFunction(_____tooltipData, _scaleValue) {\n  return tooltipHandler(_____tooltipData, {\n    scale: _scaleValue,\n    type: \"scale\"\n  });\n}\nfunction _____tooltipHandler(__tooltipElement, ___tickIndex, _tickValue) {\n  return tooltipHandler(__tooltipElement, {\n    tick: _tickValue,\n    index: ___tickIndex,\n    type: \"tick\"\n  });\n}\nfunction animatedTarget(targetAnimation, animationDirection, isAnimationTriggered) {\n  let animatedTargetResult = animationTarget(targetAnimation);\n  if (isAnimationTriggered && animationDirection !== \"right\" || !isAnimationTriggered && animationDirection === \"right\") {\n    animatedTargetResult = _animationTask(animatedTargetResult);\n  }\n  return animatedTargetResult;\n}\nfunction calculateChartPositions(chartDimensions, offsetValue, animationIndex, animationValue) {\n  const {\n    top: chartTop,\n    left: leftOffset,\n    bottom: chartBottomPosition,\n    right: rightBoundary,\n    chart: ____________________________chartData\n  } = chartDimensions;\n  const {\n    chartArea: chartAreaDimensions,\n    scales: chartScales\n  } = ____________________________chartData;\n  let maxChartWidth;\n  let calculatedPosition;\n  let titleYPosition;\n  let rotationTimestamp = 0;\n  const chartHeight = chartBottomPosition - chartTop;\n  const _chartWidth = rightBoundary - leftOffset;\n  if (chartDimensions.isHorizontal()) {\n    calculatedPosition = animationQueue(animationValue, leftOffset, rightBoundary);\n    if (currentAnimationIndex(animationIndex)) {\n      const _chartDimensions = Object.keys(animationIndex)[0];\n      const _animationValue = animationIndex[_chartDimensions];\n      titleYPosition = chartScales[_chartDimensions].getPixelForValue(_animationValue) + chartHeight - offsetValue;\n    } else {\n      if (animationIndex === \"center\") {\n        titleYPosition = (chartAreaDimensions.bottom + chartAreaDimensions.top) / 2 + chartHeight - offsetValue;\n      } else {\n        titleYPosition = listenerMap(chartDimensions, animationIndex, offsetValue);\n      }\n    }\n    maxChartWidth = rightBoundary - leftOffset;\n  } else {\n    if (currentAnimationIndex(animationIndex)) {\n      const __chartDimensions = Object.keys(animationIndex)[0];\n      const __animationValue = animationIndex[__chartDimensions];\n      calculatedPosition = chartScales[__chartDimensions].getPixelForValue(__animationValue) - _chartWidth + offsetValue;\n    } else {\n      if (animationIndex === \"center\") {\n        calculatedPosition = (chartAreaDimensions.left + chartAreaDimensions.right) / 2 - _chartWidth + offsetValue;\n      } else {\n        calculatedPosition = listenerMap(chartDimensions, animationIndex, offsetValue);\n      }\n    }\n    titleYPosition = animationQueue(animationValue, chartBottomPosition, chartTop);\n    if (animationIndex === \"left\") {\n      rotationTimestamp = -currentFrameTimestamp;\n    } else {\n      rotationTimestamp = currentFrameTimestamp;\n    }\n  }\n  return {\n    titleX: calculatedPosition,\n    titleY: titleYPosition,\n    maxWidth: maxChartWidth,\n    rotation: rotationTimestamp\n  };\n}\nclass fs extends _AnimationController {\n  constructor(t) {\n    super();\n    this.id = t.id;\n    this.type = t.type;\n    this.options = undefined;\n    this.ctx = t.ctx;\n    this.chart = t.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(________chartConfig) {\n    this.options = ________chartConfig.setContext(this.getContext());\n    this.axis = ________chartConfig.axis;\n    this._userMin = this.parse(________chartConfig.min);\n    this._userMax = this.parse(________chartConfig.max);\n    this._suggestedMin = this.parse(________chartConfig.suggestedMin);\n    this._suggestedMax = this.parse(________chartConfig.suggestedMax);\n  }\n  parse(__________________inputValue, ______________element) {\n    return __________________inputValue;\n  }\n  getUserBounds() {\n    let {\n      _userMin: userMin,\n      _userMax: userMax,\n      _suggestedMin: suggestedMin,\n      _suggestedMax: suggestedMax\n    } = this;\n    userMin = __tooltipHandler(userMin, Number.POSITIVE_INFINITY);\n    userMax = __tooltipHandler(userMax, Number.NEGATIVE_INFINITY);\n    suggestedMin = __tooltipHandler(suggestedMin, Number.POSITIVE_INFINITY);\n    suggestedMax = __tooltipHandler(suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: __tooltipHandler(userMin, suggestedMin),\n      max: __tooltipHandler(userMax, suggestedMax),\n      minDefined: chartUpdateTrigger(userMin),\n      maxDefined: chartUpdateTrigger(userMax)\n    };\n  }\n  getMinMax(t) {\n    let e;\n    let {\n      min: i,\n      max: s,\n      minDefined: isMinMaxNotCalculated,\n      maxDefined: isMaxValueCalculated\n    } = this.getUserBounds();\n    if (isMinMaxNotCalculated && isMaxValueCalculated) {\n      return {\n        min: i,\n        max: s\n      };\n    }\n    const a = this.getMatchingVisibleMetas();\n    for (let ______________index = 0, _arrayLength = a.length; ______________index < _arrayLength; ++______________index) {\n      e = a[______________index].controller.getMinMax(this, t);\n      if (!isMinMaxNotCalculated) {\n        i = Math.min(i, e.min);\n      }\n      if (!isMaxValueCalculated) {\n        s = Math.max(s, e.max);\n      }\n    }\n    if (isMaxValueCalculated && i > s) {\n      i = s;\n    } else {\n      i = i;\n    }\n    if (isMinMaxNotCalculated && i > s) {\n      s = i;\n    } else {\n      s = s;\n    }\n    return {\n      min: __tooltipHandler(i, __tooltipHandler(s, i)),\n      max: __tooltipHandler(s, __tooltipHandler(i, s))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const ______________________________chartData = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? ______________________________chartData.xLabels : ______________________________chartData.yLabels) || ______________________________chartData.labels || [];\n  }\n  getLabelItems(__chartArea = this.chart.chartArea) {\n    return this._labelItems ||= this._computeLabelItems(__chartArea);\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    $(this.options.beforeUpdate, [this]);\n  }\n  update(t, e, i) {\n    const {\n      beginAtZero: s,\n      grace: n,\n      ticks: o\n    } = this.options;\n    const a = o.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = t;\n    this.maxHeight = e;\n    this._margins = i = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, i);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _______requestAnimationFrameId(this, n, s);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const r = a < this.ticks.length;\n    this._convertTicksToLabels(r ? arraySliceByStep(this.ticks, a) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (o.display && (o.autoSkip || o.source === \"auto\")) {\n      this.ticks = calculateChartTicks(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n    if (r) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let _startPixel;\n    let _endPixel;\n    let isReverse = this.options.reverse;\n    if (this.isHorizontal()) {\n      _startPixel = this.left;\n      _endPixel = this.right;\n    } else {\n      _startPixel = this.top;\n      _endPixel = this.bottom;\n      isReverse = !isReverse;\n    }\n    this._startPixel = _startPixel;\n    this._endPixel = _endPixel;\n    this._reversePixels = isReverse;\n    this._length = _endPixel - _startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    $(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    $(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    $(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(hookEventType) {\n    this.chart.notifyPlugins(hookEventType, this.getContext());\n    $(this.options[hookEventType], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks(\"beforeDataLimits\");\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks(\"afterDataLimits\");\n  }\n  beforeBuildTicks() {\n    this._callHooks(\"beforeBuildTicks\");\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks(\"afterBuildTicks\");\n  }\n  beforeTickToLabelConversion() {\n    $(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(tickValues) {\n    const ___tickOptions = this.options.ticks;\n    let ______________________________________index;\n    let tickValuesCount;\n    let currentTickValue;\n    ______________________________________index = 0;\n    tickValuesCount = tickValues.length;\n    for (; ______________________________________index < tickValuesCount; ______________________________________index++) {\n      currentTickValue = tickValues[______________________________________index];\n      currentTickValue.label = $(___tickOptions.callback, [currentTickValue.value, ______________________________________index, tickValues], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    $(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    $(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const t = this.options;\n    const e = t.ticks;\n    const i = _animationRequestId(this.ticks.length, t.ticks.maxTicksLimit);\n    const s = e.minRotation || 0;\n    const n = e.maxRotation;\n    let o;\n    let a;\n    let r;\n    let h = s;\n    if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) {\n      this.labelRotation = s;\n      return;\n    }\n    const l = this._getLabelSizes();\n    const c = l.widest.width;\n    const d = l.highest.height;\n    const u = chartAnimationState(this.chart.width - c, 0, this.maxWidth);\n    if (t.offset) {\n      o = this.maxWidth / i;\n    } else {\n      o = u / (i - 1);\n    }\n    if (c + 6 > o) {\n      o = u / (i - (t.offset ? 0.5 : 1));\n      a = this.maxHeight - getTickLength(t.grid) - e.padding - calculateChartSize(t.title, this.chart.options.font);\n      r = Math.sqrt(c * c + d * d);\n      h = _____animationState(Math.min(Math.asin(chartAnimationState((l.highest.height + 6) / o, -1, 1)), Math.asin(chartAnimationState(a / r, -1, 1)) - Math.asin(chartAnimationState(d / r, -1, 1))));\n      h = Math.max(s, Math.min(n, h));\n    }\n    this.labelRotation = h;\n  }\n  afterCalculateLabelRotation() {\n    $(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n  beforeFit() {\n    $(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const t = {\n      width: 0,\n      height: 0\n    };\n    const {\n      chart: e,\n      options: {\n        ticks: i,\n        title: s,\n        grid: n\n      }\n    } = this;\n    const o = this._isVisible();\n    const a = this.isHorizontal();\n    if (o) {\n      const isChartVisible = calculateChartSize(s, e.options.font);\n      if (a) {\n        t.width = this.maxWidth;\n        t.height = getTickLength(n) + isChartVisible;\n      } else {\n        t.height = this.maxHeight;\n        t.width = getTickLength(n) + isChartVisible;\n      }\n      if (i.display && this.ticks.length) {\n        const {\n          first: chartData,\n          last: titleText,\n          widest: gridSpacing,\n          highest: isVisible\n        } = this._getLabelSizes();\n        const labelPadding = i.padding * 2;\n        const labelRotationRadians = requestAnimation(this.labelRotation);\n        const labelRotationCosine = Math.cos(labelRotationRadians);\n        const sinLabelRotation = Math.sin(labelRotationRadians);\n        if (a) {\n          const _chartInstance = i.mirror ? 0 : sinLabelRotation * gridSpacing.width + labelRotationCosine * isVisible.height;\n          t.height = Math.min(this.maxHeight, t.height + _chartInstance + labelPadding);\n        } else {\n          const chartConfig = i.mirror ? 0 : labelRotationCosine * gridSpacing.width + sinLabelRotation * isVisible.height;\n          t.width = Math.min(this.maxWidth, t.width + chartConfig + labelPadding);\n        }\n        this._calculatePadding(chartData, titleText, sinLabelRotation, labelRotationCosine);\n      }\n    }\n    this._handleMargins();\n    if (a) {\n      this.width = this._length = e.width - this._margins.left - this._margins.right;\n      this.height = t.height;\n    } else {\n      this.width = t.width;\n      this.height = this._length = e.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(t, e, i, s) {\n    const {\n      ticks: {\n        align: n,\n        padding: o\n      },\n      position: a\n    } = this.options;\n    const r = this.labelRotation !== 0;\n    const h = a !== \"top\" && this.axis === \"x\";\n    if (this.isHorizontal()) {\n      const _labelPosition = this.getPixelForTick(0) - this.left;\n      const remainingRightPadding = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let horizontalPaddingAdjustment = 0;\n      let paddingAdjustment = 0;\n      if (r) {\n        if (h) {\n          horizontalPaddingAdjustment = s * t.width;\n          paddingAdjustment = i * e.height;\n        } else {\n          horizontalPaddingAdjustment = i * t.height;\n          paddingAdjustment = s * e.width;\n        }\n      } else if (n === \"start\") {\n        paddingAdjustment = e.width;\n      } else if (n === \"end\") {\n        horizontalPaddingAdjustment = t.width;\n      } else if (n !== \"inner\") {\n        horizontalPaddingAdjustment = t.width / 2;\n        paddingAdjustment = e.width / 2;\n      }\n      this.paddingLeft = Math.max((horizontalPaddingAdjustment - _labelPosition + o) * this.width / (this.width - _labelPosition), 0);\n      this.paddingRight = Math.max((paddingAdjustment - remainingRightPadding + o) * this.width / (this.width - remainingRightPadding), 0);\n    } else {\n      let tickIndex = e.height / 2;\n      let tickCount = t.height / 2;\n      if (n === \"start\") {\n        tickIndex = 0;\n        tickCount = t.height;\n      } else if (n === \"end\") {\n        tickIndex = e.height;\n        tickCount = 0;\n      }\n      this.paddingTop = tickIndex + o;\n      this.paddingBottom = tickCount + o;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    $(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {\n      axis: ___axisDirection,\n      position: positionVertical\n    } = this.options;\n    return positionVertical === \"top\" || positionVertical === \"bottom\" || ___axisDirection === \"x\";\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(_tickArray) {\n    let __________________________currentIndex;\n    let ____endIndex;\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(_tickArray);\n    __________________________currentIndex = 0;\n    ____endIndex = _tickArray.length;\n    for (; __________________________currentIndex < ____endIndex; __________________________currentIndex++) {\n      if (chartUpdateInterval(_tickArray[__________________________currentIndex].label)) {\n        _tickArray.splice(__________________________currentIndex, 1);\n        ____endIndex--;\n        __________________________currentIndex--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizesCache = this._labelSizes;\n    if (!labelSizesCache) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let sampledTicks = this.ticks;\n      if (sampleSize < sampledTicks.length) {\n        sampledTicks = arraySliceByStep(sampledTicks, sampleSize);\n      }\n      this._labelSizes = labelSizesCache = this._computeLabelSizes(sampledTicks, sampledTicks.length, this.options.ticks.maxTicksLimit);\n    }\n    return labelSizesCache;\n  }\n  _computeLabelSizes(t, e, i) {\n    const {\n      ctx: s,\n      _longestTextCache: n\n    } = this;\n    const o = [];\n    const r = [];\n    const h = Math.floor(e / _animationRequestId(e, i));\n    let l;\n    let _____________________currentIndex;\n    let d;\n    let u;\n    let g;\n    let p;\n    let m;\n    let x;\n    let b;\n    let _;\n    let y;\n    let v = 0;\n    let M = 0;\n    for (l = 0; l < e; l += h) {\n      u = t[l].label;\n      g = this._resolveTickFontOptions(l);\n      s.font = p = g.string;\n      m = n[p] = n[p] || {\n        data: {},\n        gc: []\n      };\n      x = g.lineHeight;\n      b = _ = 0;\n      if (chartUpdateInterval(u) || animatedChartItems(u)) {\n        if (animatedChartItems(u)) {\n          _____________________currentIndex = 0;\n          d = u.length;\n          for (; _____________________currentIndex < d; ++_____________________currentIndex) {\n            y = u[_____________________currentIndex];\n            if (!chartUpdateInterval(y) && !animatedChartItems(y)) {\n              b = __chartUpdateTrigger(s, m.data, m.gc, b, y);\n              _ += x;\n            }\n          }\n        }\n      } else {\n        b = __chartUpdateTrigger(s, m.data, m.gc, b, u);\n        _ = x;\n      }\n      o.push(b);\n      r.push(_);\n      v = Math.max(b, v);\n      M = Math.max(_, M);\n    }\n    handleDataCleanup(n, e);\n    const w = o.indexOf(v);\n    const k = r.indexOf(M);\n    const S = __________________________________________________________index => ({\n      width: o[__________________________________________________________index] || 0,\n      height: r[__________________________________________________________index] || 0\n    });\n    return {\n      first: S(0),\n      last: S(e - 1),\n      widest: S(w),\n      highest: S(k),\n      widths: o,\n      heights: r\n    };\n  }\n  getLabelForValue(valueToLabel) {\n    return valueToLabel;\n  }\n  getPixelForValue(__value, __pixelValue) {\n    return NaN;\n  }\n  getValueForPixel(_pixelValue) {}\n  getPixelForTick(_____tickIndex) {\n    const ticksArray = this.ticks;\n    if (_____tickIndex < 0 || _____tickIndex > ticksArray.length - 1) {\n      return null;\n    } else {\n      return this.getPixelForValue(ticksArray[_____tickIndex].value);\n    }\n  }\n  getPixelForDecimal(_normalizedPixelValue) {\n    if (this._reversePixels) {\n      _normalizedPixelValue = 1 - _normalizedPixelValue;\n    }\n    const calculatedPixelValue = this._startPixel + _normalizedPixelValue * this._length;\n    return _chartUpdateInterval(this._alignToPixels ? __chartAnimationQueue(this.chart, calculatedPixelValue, 0) : calculatedPixelValue);\n  }\n  getDecimalForPixel(_____pixelValue) {\n    const decimalPosition = (_____pixelValue - this._startPixel) / this._length;\n    if (this._reversePixels) {\n      return 1 - decimalPosition;\n    } else {\n      return decimalPosition;\n    }\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {\n      min: _____minValue,\n      max: ____maxValue\n    } = this;\n    if (_____minValue < 0 && ____maxValue < 0) {\n      return ____maxValue;\n    } else if (_____minValue > 0 && ____maxValue > 0) {\n      return _____minValue;\n    } else {\n      return 0;\n    }\n  }\n  getContext(_______tickIndex) {\n    const tickArray = this.ticks || [];\n    if (_______tickIndex >= 0 && _______tickIndex < tickArray.length) {\n      const tickValue = tickArray[_______tickIndex];\n      return tickValue.$context ||= _____tooltipHandler(this.getContext(), _______tickIndex, tickValue);\n    }\n    return this.$context ||= __tooltipHandlerFunction(this.chart.getContext(), this);\n  }\n  _tickSize() {\n    const ______tickOptions = this.options.ticks;\n    const _labelRotationRadians = requestAnimation(this.labelRotation);\n    const cosineOfRotation = Math.abs(Math.cos(_labelRotationRadians));\n    const sinValue = Math.abs(Math.sin(_labelRotationRadians));\n    const labelSizes = this._getLabelSizes();\n    const autoSkipPadding = ______tickOptions.autoSkipPadding || 0;\n    const maxLabelWidthWithPadding = labelSizes ? labelSizes.widest.width + autoSkipPadding : 0;\n    const labelHeightWithPadding = labelSizes ? labelSizes.highest.height + autoSkipPadding : 0;\n    if (this.isHorizontal()) {\n      if (labelHeightWithPadding * cosineOfRotation > maxLabelWidthWithPadding * sinValue) {\n        return maxLabelWidthWithPadding / cosineOfRotation;\n      } else {\n        return labelHeightWithPadding / sinValue;\n      }\n    } else if (labelHeightWithPadding * sinValue < maxLabelWidthWithPadding * cosineOfRotation) {\n      return labelHeightWithPadding / cosineOfRotation;\n    } else {\n      return maxLabelWidthWithPadding / sinValue;\n    }\n  }\n  _isVisible() {\n    const displayOption = this.options.display;\n    if (displayOption !== \"auto\") {\n      return !!displayOption;\n    } else {\n      return this.getMatchingVisibleMetas().length > 0;\n    }\n  }\n  _computeGridLineItems(t) {\n    const e = this.axis;\n    const i = this.chart;\n    const s = this.options;\n    const {\n      grid: o,\n      position: a,\n      border: h\n    } = s;\n    const l = o.offset;\n    const c = this.isHorizontal();\n    const d = this.ticks.length + (l ? 1 : 0);\n    const u = getTickLength(o);\n    const g = [];\n    const p = h.setContext(this.getContext());\n    const f = p.display ? p.width : 0;\n    const m = f / 2;\n    const getPixelForValue = function (t) {\n      return __chartAnimationQueue(i, t, f);\n    };\n    let b;\n    let _;\n    let y;\n    let v;\n    let M;\n    let w;\n    let k;\n    let S;\n    let D;\n    let P;\n    let C;\n    let A;\n    if (a === \"top\") {\n      b = getPixelForValue(this.bottom);\n      w = this.bottom - u;\n      S = b - m;\n      P = getPixelForValue(t.top) + m;\n      A = t.bottom;\n    } else if (a === \"bottom\") {\n      b = getPixelForValue(this.top);\n      P = t.top;\n      A = getPixelForValue(t.bottom) - m;\n      w = b + m;\n      S = this.top + u;\n    } else if (a === \"left\") {\n      b = getPixelForValue(this.right);\n      M = this.right - u;\n      k = b - m;\n      D = getPixelForValue(t.left) + m;\n      C = t.right;\n    } else if (a === \"right\") {\n      b = getPixelForValue(this.left);\n      D = t.left;\n      C = getPixelForValue(t.right) - m;\n      M = b + m;\n      k = this.left + u;\n    } else if (e === \"x\") {\n      if (a === \"center\") {\n        b = getPixelForValue((t.top + t.bottom) / 2 + 0.5);\n      } else if (currentAnimationIndex(a)) {\n        const tickCoordinates = Object.keys(a)[0];\n        const axisType = a[tickCoordinates];\n        b = getPixelForValue(this.chart.scales[tickCoordinates].getPixelForValue(axisType));\n      }\n      P = t.top;\n      A = t.bottom;\n      w = b + m;\n      S = w + u;\n    } else if (e === \"y\") {\n      if (a === \"center\") {\n        b = getPixelForValue((t.left + t.right) / 2);\n      } else if (currentAnimationIndex(a)) {\n        const tickPositions = Object.keys(a)[0];\n        const _axisType = a[tickPositions];\n        b = getPixelForValue(this.chart.scales[tickPositions].getPixelForValue(_axisType));\n      }\n      M = b - m;\n      k = M - u;\n      D = t.left;\n      C = t.right;\n    }\n    const L = chartAnimationRunning(s.ticks.maxTicksLimit, d);\n    const O = Math.max(1, Math.ceil(d / L));\n    for (_ = 0; _ < d; _ += O) {\n      const context = this.getContext(_);\n      const contextSettings = o.setContext(context);\n      const _contextSettings = h.setContext(context);\n      const lineWidth = contextSettings.lineWidth;\n      const contextColor = contextSettings.color;\n      const borderDashArray = _contextSettings.dash || [];\n      const dashOffset = _contextSettings.dashOffset;\n      const tickWidth = contextSettings.tickWidth;\n      const tickColor = contextSettings.tickColor;\n      const tickBorderDash = contextSettings.tickBorderDash || [];\n      const tickBorderDashOffset = contextSettings.tickBorderDashOffset;\n      y = calculateTickPosition(this, _, l);\n      if (y !== undefined) {\n        v = __chartAnimationQueue(i, y, lineWidth);\n        if (c) {\n          M = k = D = C = v;\n        } else {\n          w = S = P = A = v;\n        }\n        g.push({\n          tx1: M,\n          ty1: w,\n          tx2: k,\n          ty2: S,\n          x1: D,\n          y1: P,\n          x2: C,\n          y2: A,\n          width: lineWidth,\n          color: contextColor,\n          borderDash: borderDashArray,\n          borderDashOffset: dashOffset,\n          tickWidth: tickWidth,\n          tickColor: tickColor,\n          tickBorderDash: tickBorderDash,\n          tickBorderDashOffset: tickBorderDashOffset\n        });\n      }\n    }\n    this._ticksLength = d;\n    this._borderValue = b;\n    return g;\n  }\n  _computeLabelItems(t) {\n    const e = this.axis;\n    const i = this.options;\n    const {\n      position: s,\n      ticks: o\n    } = i;\n    const r = this.isHorizontal();\n    const h = this.ticks;\n    const {\n      align: l,\n      crossAlign: c,\n      padding: d,\n      mirror: u\n    } = o;\n    const g = getTickLength(i.grid);\n    const p = g + d;\n    const f = u ? -d : p;\n    const m = -requestAnimation(this.labelRotation);\n    const b = [];\n    let currentTickIndex;\n    let y;\n    let v;\n    let M;\n    let w;\n    let k;\n    let S;\n    let D;\n    let P;\n    let C;\n    let labelItemCount;\n    let L;\n    let O = \"middle\";\n    if (s === \"top\") {\n      k = this.bottom - f;\n      S = this._getXAxisLabelAlignment();\n    } else if (s === \"bottom\") {\n      k = this.top + f;\n      S = this._getXAxisLabelAlignment();\n    } else if (s === \"left\") {\n      const labelAlignment = this._getYAxisLabelAlignment(g);\n      S = labelAlignment.textAlign;\n      w = labelAlignment.x;\n    } else if (s === \"right\") {\n      const _labelAlignment = this._getYAxisLabelAlignment(g);\n      S = _labelAlignment.textAlign;\n      w = _labelAlignment.x;\n    } else if (e === \"x\") {\n      if (s === \"center\") {\n        k = (t.top + t.bottom) / 2 + p;\n      } else if (currentAnimationIndex(s)) {\n        const yAxisLabelAlignment = Object.keys(s)[0];\n        const axisReference = s[yAxisLabelAlignment];\n        k = this.chart.scales[yAxisLabelAlignment].getPixelForValue(axisReference) + p;\n      }\n      S = this._getXAxisLabelAlignment();\n    } else if (e === \"y\") {\n      if (s === \"center\") {\n        w = (t.left + t.right) / 2 - p;\n      } else if (currentAnimationIndex(s)) {\n        const __labelAlignment = Object.keys(s)[0];\n        const _axisReference = s[__labelAlignment];\n        w = this.chart.scales[__labelAlignment].getPixelForValue(_axisReference);\n      }\n      S = this._getYAxisLabelAlignment(g).textAlign;\n    }\n    if (e === \"y\") {\n      if (l === \"start\") {\n        O = \"top\";\n      } else if (l === \"end\") {\n        O = \"bottom\";\n      }\n    }\n    const E = this._getLabelSizes();\n    currentTickIndex = 0;\n    y = h.length;\n    for (; currentTickIndex < y; ++currentTickIndex) {\n      v = h[currentTickIndex];\n      M = v.label;\n      const labelContext = o.setContext(this.getContext(currentTickIndex));\n      D = this.getPixelForTick(currentTickIndex) + o.labelOffset;\n      P = this._resolveTickFontOptions(currentTickIndex);\n      C = P.lineHeight;\n      if (animatedChartItems(M)) {\n        labelItemCount = M.length;\n      } else {\n        labelItemCount = 1;\n      }\n      const halfLabelCount = labelItemCount / 2;\n      const textColor = labelContext.color;\n      const textStrokeColor = labelContext.textStrokeColor;\n      const textStrokeWidth = labelContext.textStrokeWidth;\n      let labelBackdropOptions;\n      let textAlign = S;\n      if (r) {\n        w = D;\n        if (S === \"inner\") {\n          if (currentTickIndex === y - 1) {\n            if (this.options.reverse) {\n              textAlign = \"left\";\n            } else {\n              textAlign = \"right\";\n            }\n          } else if (currentTickIndex === 0) {\n            if (this.options.reverse) {\n              textAlign = \"right\";\n            } else {\n              textAlign = \"left\";\n            }\n          } else {\n            textAlign = \"center\";\n          }\n        }\n        if (s === \"top\") {\n          if (c === \"near\" || m !== 0) {\n            L = -labelItemCount * C + C / 2;\n          } else if (c === \"center\") {\n            L = -E.highest.height / 2 - halfLabelCount * C + C;\n          } else {\n            L = -E.highest.height + C / 2;\n          }\n        } else if (c === \"near\" || m !== 0) {\n          L = C / 2;\n        } else if (c === \"center\") {\n          L = E.highest.height / 2 - halfLabelCount * C;\n        } else {\n          L = E.highest.height - labelItemCount * C;\n        }\n        if (u) {\n          L *= -1;\n        }\n        if (m !== 0 && !labelContext.showLabelBackdrop) {\n          w += C / 2 * Math.sin(m);\n        }\n      } else {\n        k = D;\n        L = (1 - labelItemCount) * C / 2;\n      }\n      if (labelContext.showLabelBackdrop) {\n        const _halfLabelCount = __animationElement(labelContext.backdropPadding);\n        const _textColor = E.heights[currentTickIndex];\n        const labelPosition = E.widths[currentTickIndex];\n        let _textStrokeColor = L - _halfLabelCount.top;\n        let contextSetter = 0 - _halfLabelCount.left;\n        switch (O) {\n          case \"middle\":\n            _textStrokeColor -= _textColor / 2;\n            break;\n          case \"bottom\":\n            _textStrokeColor -= _textColor;\n        }\n        switch (S) {\n          case \"center\":\n            contextSetter -= labelPosition / 2;\n            break;\n          case \"right\":\n            contextSetter -= labelPosition;\n        }\n        labelBackdropOptions = {\n          left: contextSetter,\n          top: _textStrokeColor,\n          width: labelPosition + _halfLabelCount.width,\n          height: _textColor + _halfLabelCount.height,\n          color: labelContext.backdropColor\n        };\n      }\n      b.push({\n        label: M,\n        font: P,\n        textOffset: L,\n        options: {\n          rotation: m,\n          color: textColor,\n          strokeColor: textStrokeColor,\n          strokeWidth: textStrokeWidth,\n          textAlign: textAlign,\n          textBaseline: O,\n          translation: [w, k],\n          backdrop: labelBackdropOptions\n        }\n      });\n    }\n    return b;\n  }\n  _getXAxisLabelAlignment() {\n    const {\n      position: xAxisLabelPosition,\n      ticks: xAxisTicks\n    } = this.options;\n    if (-requestAnimation(this.labelRotation)) {\n      if (xAxisLabelPosition === \"top\") {\n        return \"left\";\n      } else {\n        return \"right\";\n      }\n    }\n    let xAxisTickAlignment = \"center\";\n    if (xAxisTicks.align === \"start\") {\n      xAxisTickAlignment = \"left\";\n    } else if (xAxisTicks.align === \"end\") {\n      xAxisTickAlignment = \"right\";\n    } else if (xAxisTicks.align === \"inner\") {\n      xAxisTickAlignment = \"inner\";\n    }\n    return xAxisTickAlignment;\n  }\n  _getYAxisLabelAlignment(t) {\n    const {\n      position: e,\n      ticks: {\n        crossAlign: i,\n        mirror: s,\n        padding: n\n      }\n    } = this.options;\n    const o = t + n;\n    const a = this._getLabelSizes().widest.width;\n    let r;\n    let h;\n    if (e === \"left\") {\n      if (s) {\n        h = this.right + n;\n        if (i === \"near\") {\n          r = \"left\";\n        } else if (i === \"center\") {\n          r = \"center\";\n          h += a / 2;\n        } else {\n          r = \"right\";\n          h += a;\n        }\n      } else {\n        h = this.right - o;\n        if (i === \"near\") {\n          r = \"right\";\n        } else if (i === \"center\") {\n          r = \"center\";\n          h -= a / 2;\n        } else {\n          r = \"left\";\n          h = this.left;\n        }\n      }\n    } else if (e === \"right\") {\n      if (s) {\n        h = this.left + n;\n        if (i === \"near\") {\n          r = \"right\";\n        } else if (i === \"center\") {\n          r = \"center\";\n          h -= a / 2;\n        } else {\n          r = \"left\";\n          h -= a;\n        }\n      } else {\n        h = this.left + o;\n        if (i === \"near\") {\n          r = \"left\";\n        } else if (i === \"center\") {\n          r = \"center\";\n          h += a / 2;\n        } else {\n          r = \"right\";\n          h = this.right;\n        }\n      }\n    } else {\n      r = \"right\";\n    }\n    return {\n      textAlign: r,\n      x: h\n    };\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const __________________________chartInstance = this.chart;\n    const __labelPosition = this.options.position;\n    if (__labelPosition === \"left\" || __labelPosition === \"right\") {\n      return {\n        top: 0,\n        left: this.left,\n        bottom: __________________________chartInstance.height,\n        right: this.right\n      };\n    } else if (__labelPosition === \"top\" || __labelPosition === \"bottom\") {\n      return {\n        top: this.top,\n        left: 0,\n        bottom: this.bottom,\n        right: __________________________chartInstance.width\n      };\n    } else {\n      return undefined;\n    }\n  }\n  drawBackground() {\n    const {\n      ctx: ______________________canvasContext,\n      options: {\n        backgroundColor: backgroundColor\n      },\n      left: _leftCoordinate,\n      top: __topPosition,\n      width: backgroundWidth,\n      height: backgroundHeight\n    } = this;\n    if (backgroundColor) {\n      ______________________canvasContext.save();\n      ______________________canvasContext.fillStyle = backgroundColor;\n      ______________________canvasContext.fillRect(_leftCoordinate, __topPosition, backgroundWidth, backgroundHeight);\n      ______________________canvasContext.restore();\n    }\n  }\n  getLineWidthForValue(________________________inputValue) {\n    const gridOptions = this.options.grid;\n    if (!this._isVisible() || !gridOptions.display) {\n      return 0;\n    }\n    const inputValueIndex = this.ticks.findIndex(____________inputValue => ____________inputValue.value === ________________________inputValue);\n    if (inputValueIndex >= 0) {\n      return gridOptions.setContext(this.getContext(inputValueIndex)).lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(t) {\n    const e = this.options.grid;\n    const i = this.ctx;\n    const s = this._gridLineItems ||= this._computeGridLineItems(t);\n    let ______index;\n    let o;\n    const drawGridLine = (_startPoint, _endPoint, strokeOptions) => {\n      if (strokeOptions.width && strokeOptions.color) {\n        i.save();\n        i.lineWidth = strokeOptions.width;\n        i.strokeStyle = strokeOptions.color;\n        i.setLineDash(strokeOptions.borderDash || []);\n        i.lineDashOffset = strokeOptions.borderDashOffset;\n        i.beginPath();\n        i.moveTo(_startPoint.x, _startPoint.y);\n        i.lineTo(_endPoint.x, _endPoint.y);\n        i.stroke();\n        i.restore();\n      }\n    };\n    if (e.display) {\n      ______index = 0;\n      o = s.length;\n      for (; ______index < o; ++______index) {\n        const gridLineProperties = s[______index];\n        if (e.drawOnChartArea) {\n          drawGridLine({\n            x: gridLineProperties.x1,\n            y: gridLineProperties.y1\n          }, {\n            x: gridLineProperties.x2,\n            y: gridLineProperties.y2\n          }, gridLineProperties);\n        }\n        if (e.drawTicks) {\n          drawGridLine({\n            x: gridLineProperties.tx1,\n            y: gridLineProperties.ty1\n          }, {\n            x: gridLineProperties.tx2,\n            y: gridLineProperties.ty2\n          }, {\n            color: gridLineProperties.tickColor,\n            width: gridLineProperties.tickWidth,\n            borderDash: gridLineProperties.tickBorderDash,\n            borderDashOffset: gridLineProperties.tickBorderDashOffset\n          });\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {\n      chart: t,\n      ctx: e,\n      options: {\n        border: i,\n        grid: s\n      }\n    } = this;\n    const n = i.setContext(this.getContext());\n    const o = i.display ? n.width : 0;\n    if (!o) {\n      return;\n    }\n    const a = s.setContext(this.getContext(0)).lineWidth;\n    const r = this._borderValue;\n    let h;\n    let l;\n    let c;\n    let d;\n    if (this.isHorizontal()) {\n      h = __chartAnimationQueue(t, this.left, o) - o / 2;\n      l = __chartAnimationQueue(t, this.right, a) + a / 2;\n      c = d = r;\n    } else {\n      c = __chartAnimationQueue(t, this.top, o) - o / 2;\n      d = __chartAnimationQueue(t, this.bottom, a) + a / 2;\n      h = l = r;\n    }\n    e.save();\n    e.lineWidth = n.width;\n    e.strokeStyle = n.color;\n    e.beginPath();\n    e.moveTo(h, c);\n    e.lineTo(l, d);\n    e.stroke();\n    e.restore();\n  }\n  drawLabels(labelItems) {\n    if (!this.options.ticks.display) {\n      return;\n    }\n    const ________________________canvasContext = this.ctx;\n    const labelArea = this._computeLabelArea();\n    if (labelArea) {\n      __________animationManager(________________________canvasContext, labelArea);\n    }\n    const labelItemsArray = this.getLabelItems(labelItems);\n    for (const textItem of labelItemsArray) {\n      const optionsArray = textItem.options;\n      const fontStyle = textItem.font;\n      const _labelText = textItem.label;\n      const textOffset = textItem.textOffset;\n      Z(________________________canvasContext, _labelText, 0, textOffset, fontStyle, optionsArray);\n    }\n    if (labelArea) {\n      Q(________________________canvasContext);\n    }\n  }\n  drawTitle() {\n    const {\n      ctx: t,\n      options: {\n        position: e,\n        title: i,\n        reverse: s\n      }\n    } = this;\n    if (!i.display) {\n      return;\n    }\n    const o = requestAnimationFrame(i.font);\n    const r = __animationElement(i.padding);\n    const h = i.align;\n    let l = o.lineHeight / 2;\n    if (e === \"bottom\" || e === \"center\" || currentAnimationIndex(e)) {\n      l += r.bottom;\n      if (animatedChartItems(i.text)) {\n        l += o.lineHeight * (i.text.length - 1);\n      }\n    } else {\n      l += r.top;\n    }\n    const {\n      titleX: c,\n      titleY: d,\n      maxWidth: u,\n      rotation: g\n    } = calculateChartPositions(this, l, e, h);\n    Z(t, i.text, 0, 0, o, {\n      color: i.color,\n      maxWidth: u,\n      rotation: g,\n      textAlign: animatedTarget(h, e, s),\n      textBaseline: \"middle\",\n      translation: [c, d]\n    });\n  }\n  draw(__timeElapsed) {\n    if (this._isVisible()) {\n      this.drawBackground();\n      this.drawGrid(__timeElapsed);\n      this.drawBorder();\n      this.drawTitle();\n      this.drawLabels(__timeElapsed);\n    }\n  }\n  _layers() {\n    const ________________________options = this.options;\n    const ticksZValue = ________________________options.ticks && ________________________options.ticks.z || 0;\n    const i = chartAnimationRunning(________________________options.grid && ________________________options.grid.z, -1);\n    const s = chartAnimationRunning(________________________options.border && ________________________options.border.z, 0);\n    if (this._isVisible() && this.draw === fs.prototype.draw) {\n      return [{\n        z: i,\n        draw: gridTick => {\n          this.drawBackground();\n          this.drawGrid(gridTick);\n          this.drawTitle();\n        }\n      }, {\n        z: s,\n        draw: () => {\n          this.drawBorder();\n        }\n      }, {\n        z: ticksZValue,\n        draw: currentLabel => {\n          this.drawLabels(currentLabel);\n        }\n      }];\n    } else {\n      return [{\n        z: ticksZValue,\n        draw: timestamp => {\n          this.draw(timestamp);\n        }\n      }];\n    }\n  }\n  getMatchingVisibleMetas(typeFilter) {\n    const ___sortedVisibleDatasetMetas = this.chart.getSortedVisibleDatasetMetas();\n    const axisIdKey = this.axis + \"AxisID\";\n    const __matchingVisibleMetas = [];\n    let _______________________currentIndex;\n    let sortedDatasetMetasCount;\n    _______________________currentIndex = 0;\n    sortedDatasetMetasCount = ___sortedVisibleDatasetMetas.length;\n    for (; _______________________currentIndex < sortedDatasetMetasCount; ++_______________________currentIndex) {\n      const _____currentItem = ___sortedVisibleDatasetMetas[_______________________currentIndex];\n      if (_____currentItem[axisIdKey] === this.id && (!typeFilter || _____currentItem.type === typeFilter)) {\n        __matchingVisibleMetas.push(_____currentItem);\n      }\n    }\n    return __matchingVisibleMetas;\n  }\n  _resolveTickFontOptions(tickFontOptions) {\n    const _tickFontOptions = this.options.ticks.setContext(this.getContext(tickFontOptions));\n    return requestAnimationFrame(_tickFontOptions.font);\n  }\n  _maxDigits() {\n    const lineHeight = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / lineHeight;\n  }\n}\nclass AnimationRegistry {\n  constructor(type, scope, overrideValue) {\n    this.type = type;\n    this.scope = scope;\n    this.override = overrideValue;\n    this.items = Object.create(null);\n  }\n  isForType(prototypeInput) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, prototypeInput.prototype);\n  }\n  register(classInstance) {\n    const prototypeOfObject = Object.getPrototypeOf(classInstance);\n    let registeredItem;\n    if (hasIdAndDefaults(prototypeOfObject)) {\n      registeredItem = this.register(prototypeOfObject);\n    }\n    const registeredItems = this.items;\n    const itemId = classInstance.id;\n    const itemScopedId = this.scope + \".\" + itemId;\n    if (!itemId) {\n      throw new Error(\"class does not have id: \" + classInstance);\n    }\n    if (!(itemId in registeredItems)) {\n      registeredItems[itemId] = classInstance;\n      ___animationSettings(classInstance, itemScopedId, registeredItem);\n      if (this.override) {\n        animationDuration.override(classInstance.id, classInstance.overrides);\n      }\n    }\n    return itemScopedId;\n  }\n  get(______itemIndex) {\n    return this.items[______itemIndex];\n  }\n  unregister(itemToUnregister) {\n    const itemsMap = this.items;\n    const __itemId = itemToUnregister.id;\n    const currentScope = this.scope;\n    if (__itemId in itemsMap) {\n      delete itemsMap[__itemId];\n    }\n    if (currentScope && __itemId in animationDuration[currentScope]) {\n      delete animationDuration[currentScope][__itemId];\n      if (this.override) {\n        delete animationStep[__itemId];\n      }\n    }\n  }\n}\nfunction ___animationSettings(animationConfig, animationKey, animationDurationIndex) {\n  const calculatedAnimationDuration = _animationDuration(Object.create(null), [animationDurationIndex ? animationDuration.get(animationDurationIndex) : {}, animationDuration.get(animationKey), animationConfig.defaults]);\n  animationDuration.set(animationKey, calculatedAnimationDuration);\n  if (animationConfig.defaultRoutes) {\n    animateProperty(animationKey, animationConfig.defaultRoutes);\n  }\n  if (animationConfig.descriptors) {\n    animationDuration.describe(animationKey, animationConfig.descriptors);\n  }\n}\nfunction animateProperty(target, _animationProperties) {\n  Object.keys(_animationProperties).forEach(__inputString => {\n    const splitPathSegments = __inputString.split(\".\");\n    const fileNameExtension = splitPathSegments.pop();\n    const animationRoute = [target].concat(splitPathSegments).join(\".\");\n    const animationPropertiesArray = _animationProperties[__inputString].split(\".\");\n    const animationPropertyLastSegment = animationPropertiesArray.pop();\n    const propertyPath = animationPropertiesArray.join(\".\");\n    animationDuration.route(animationRoute, fileNameExtension, propertyPath, animationPropertyLastSegment);\n  });\n}\nfunction hasIdAndDefaults(__inputObject) {\n  return \"id\" in __inputObject && \"defaults\" in __inputObject;\n}\nclass ys {\n  constructor() {\n    this.controllers = new AnimationRegistry(Se, \"datasets\", true);\n    this.elements = new AnimationRegistry(_AnimationController, \"elements\");\n    this.plugins = new AnimationRegistry(Object, \"plugins\");\n    this.scales = new AnimationRegistry(fs, \"scales\");\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...eventArgs) {\n    this._each(\"register\", eventArgs);\n  }\n  remove(...unregisterArgs) {\n    this._each(\"unregister\", unregisterArgs);\n  }\n  addControllers(...controllerArgs) {\n    this._each(\"register\", controllerArgs, this.controllers);\n  }\n  addElements(...elementArgs) {\n    this._each(\"register\", elementArgs, this.elements);\n  }\n  addPlugins(...pluginArgs) {\n    this._each(\"register\", pluginArgs, this.plugins);\n  }\n  addScales(...scaleArgs) {\n    this._each(\"register\", scaleArgs, this.scales);\n  }\n  getController(controllerType) {\n    return this._get(controllerType, this.controllers, \"controller\");\n  }\n  getElement(__elementId) {\n    return this._get(__elementId, this.elements, \"element\");\n  }\n  getPlugin(pluginIdentifier) {\n    return this._get(pluginIdentifier, this.plugins, \"plugin\");\n  }\n  getScale(__scaleValue) {\n    return this._get(__scaleValue, this.scales, \"scale\");\n  }\n  removeControllers(...controllerList) {\n    this._each(\"unregister\", controllerList, this.controllers);\n  }\n  removeElements(...elementsToRemove) {\n    this._each(\"unregister\", elementsToRemove, this.elements);\n  }\n  removePlugins(..._pluginArgs) {\n    this._each(\"unregister\", _pluginArgs, this.plugins);\n  }\n  removeScales(...scaleToRemove) {\n    this._each(\"unregister\", scaleToRemove, this.scales);\n  }\n  _each(____________eventHandler, eventsArray, _currentRegistry) {\n    [...eventsArray].forEach(event => {\n      const registryForType = _currentRegistry || this._getRegistryForType(event);\n      if (_currentRegistry || registryForType.isForType(event) || registryForType === this.plugins && event.id) {\n        this._exec(____________eventHandler, registryForType, event);\n      } else {\n        __lastDateUpdated(event, _eventType => {\n          const registry = _currentRegistry || this._getRegistryForType(_eventType);\n          this._exec(____________eventHandler, registry, _eventType);\n        });\n      }\n    });\n  }\n  _exec(__animationType, _____________________event, _______animationIndex) {\n    const animationItemsList = animationItems(__animationType);\n    $(_______animationIndex[\"before\" + animationItemsList], [], _______animationIndex);\n    _____________________event[__animationType](_______animationIndex);\n    $(_______animationIndex[\"after\" + animationItemsList], [], _______animationIndex);\n  }\n  _getRegistryForType(typeIdentifier) {\n    for (let typedRegistryIndex = 0; typedRegistryIndex < this._typedRegistries.length; typedRegistryIndex++) {\n      const currentRegistry = this._typedRegistries[typedRegistryIndex];\n      if (currentRegistry.isForType(typeIdentifier)) {\n        return currentRegistry;\n      }\n    }\n    return this.plugins;\n  }\n  _get(_key, entityManager, registrationType) {\n    const retrievedEntity = entityManager.get(_key);\n    if (retrievedEntity === undefined) {\n      throw new Error(\"\\\"\" + _key + \"\\\" is not a registered \" + registrationType + \".\");\n    }\n    return retrievedEntity;\n  }\n}\nvar vs = new ys();\nclass Ms {\n  constructor() {\n    this._init = [];\n  }\n  notify(descriptorTemplate, notificationPhase, _notificationCallback, filterFunction) {\n    if (notificationPhase === \"beforeInit\") {\n      this._init = this._createDescriptors(descriptorTemplate, true);\n      this._notify(this._init, descriptorTemplate, \"install\");\n    }\n    const filteredDescriptors = filterFunction ? this._descriptors(descriptorTemplate).filter(filterFunction) : this._descriptors(descriptorTemplate);\n    const notificationResult = this._notify(filteredDescriptors, descriptorTemplate, notificationPhase, _notificationCallback);\n    if (notificationPhase === \"afterDestroy\") {\n      this._notify(filteredDescriptors, descriptorTemplate, \"stop\");\n      this._notify(this._init, descriptorTemplate, \"uninstall\");\n    }\n    return notificationResult;\n  }\n  _notify(_pluginsList, _________________________event, _pluginIndex, __pluginOptions) {\n    __pluginOptions = __pluginOptions || {};\n    for (const pluginItem of _pluginsList) {\n      const pluginsArray = pluginItem.plugin;\n      const pluginInstance = pluginsArray[_pluginIndex];\n      const pluginArguments = [_________________________event, __pluginOptions, pluginItem.options];\n      if ($(pluginInstance, pluginArguments, pluginsArray) === false && __pluginOptions.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!chartUpdateInterval(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(_________inputData) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptorsCache = this._cache = this._createDescriptors(_________inputData);\n    this._notifyStateChanges(_________inputData);\n    return descriptorsCache;\n  }\n  _createDescriptors(chartDescriptor, _pluginOptions) {\n    const _______chartConfig = chartDescriptor && chartDescriptor.config;\n    const __isChartAnimationRunning = chartAnimationRunning(_______chartConfig.options && _______chartConfig.options.plugins, {});\n    const workspaceOptions = updateWorkspacePlugins(_______chartConfig);\n    if (__isChartAnimationRunning !== false || _pluginOptions) {\n      return initializePlugins(chartDescriptor, workspaceOptions, __isChartAnimationRunning, _pluginOptions);\n    } else {\n      return [];\n    }\n  }\n  _notifyStateChanges(notificationMeta) {\n    const oldCachePlugins = this._oldCache || [];\n    const currentCache = this._cache;\n    const filterPluginsByDifferentCache = (pluginFilter, excludedPlugins) => pluginFilter.filter(currentPluginId => !excludedPlugins.some(currentPlugin => currentPluginId.plugin.id === currentPlugin.plugin.id));\n    this._notify(filterPluginsByDifferentCache(oldCachePlugins, currentCache), notificationMeta, \"stop\");\n    this._notify(filterPluginsByDifferentCache(currentCache, oldCachePlugins), notificationMeta, \"start\");\n  }\n}\nfunction updateWorkspacePlugins(workspace) {\n  const localPluginIdsMap = {};\n  const __pluginsList = [];\n  const pluginKeys = Object.keys(vs.plugins.items);\n  for (let stringIndex = 0; stringIndex < pluginKeys.length; stringIndex++) {\n    __pluginsList.push(vs.getPlugin(pluginKeys[stringIndex]));\n  }\n  const workspacePlugins = workspace.plugins || [];\n  for (let ______________________________________________________________currentIndex = 0; ______________________________________________________________currentIndex < workspacePlugins.length; ______________________________________________________________currentIndex++) {\n    const ___currentItem = workspacePlugins[______________________________________________________________currentIndex];\n    if (__pluginsList.indexOf(___currentItem) === -1) {\n      __pluginsList.push(___currentItem);\n      localPluginIdsMap[___currentItem.id] = true;\n    }\n  }\n  return {\n    plugins: __pluginsList,\n    localIds: localPluginIdsMap\n  };\n}\nfunction getResponseObject(responseCondition, _responseCondition) {\n  if (_responseCondition || responseCondition !== false) {\n    if (responseCondition === true) {\n      return {};\n    } else {\n      return responseCondition;\n    }\n  } else {\n    return null;\n  }\n}\nfunction initializePlugins(_canvasElement, {\n  plugins: pluginsList,\n  localIds: localIdMapping\n}, pluginOptions, pluginReference) {\n  const initializedPlugins = [];\n  const _________________canvasContext = _canvasElement.getContext();\n  for (const plugin of pluginsList) {\n    const pluginReferenceList = plugin.id;\n    const pluginOptionsConfig = getResponseObject(pluginOptions[pluginReferenceList], pluginReference);\n    if (pluginOptionsConfig !== null) {\n      initializedPlugins.push({\n        plugin: plugin,\n        options: configurePlugin(_canvasElement.config, {\n          plugin: plugin,\n          local: localIdMapping[pluginReferenceList]\n        }, pluginOptionsConfig, _________________canvasContext)\n      });\n    }\n  }\n  return initializedPlugins;\n}\nfunction configurePlugin(contextHandler, {\n  plugin: pluginConfig,\n  local: localPluginConfig\n}, optionScopeKeys, resolverOptions) {\n  const pluginScopeKeys = contextHandler.pluginScopeKeys(pluginConfig);\n  const optionScopes = contextHandler.getOptionScopes(optionScopeKeys, pluginScopeKeys);\n  if (localPluginConfig && pluginConfig.defaults) {\n    optionScopes.push(pluginConfig.defaults);\n  }\n  return contextHandler.createResolver(optionScopes, resolverOptions, [\"\"], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\nfunction getDatasetIndexAxis(______________________datasetIndex, _inputParameters) {\n  const datasetProperties = animationDuration.datasets[______________________datasetIndex] || {};\n  return ((_inputParameters.datasets || {})[______________________datasetIndex] || {}).indexAxis || _inputParameters.indexAxis || datasetProperties.indexAxis || \"x\";\n}\nfunction getValueOrIndex(_____inputValue, ______inputValue) {\n  let resultValueOrIndex = _____inputValue;\n  if (_____inputValue === \"_index_\") {\n    resultValueOrIndex = ______inputValue;\n  } else if (_____inputValue === \"_value_\") {\n    if (______inputValue === \"x\") {\n      resultValueOrIndex = \"y\";\n    } else {\n      resultValueOrIndex = \"x\";\n    }\n  }\n  return resultValueOrIndex;\n}\nfunction compareValues(_firstValue, __comparisonValue) {\n  if (_firstValue === __comparisonValue) {\n    return \"_index_\";\n  } else {\n    return \"_value_\";\n  }\n}\nfunction validateCoordinateInput(______axisIdentifier) {\n  if (______axisIdentifier === \"x\" || ______axisIdentifier === \"y\" || ______axisIdentifier === \"r\") {\n    return ______axisIdentifier;\n  }\n}\nfunction _axisDirection(positionDirection) {\n  if (positionDirection === \"top\" || positionDirection === \"bottom\") {\n    return \"x\";\n  } else if (positionDirection === \"left\" || positionDirection === \"right\") {\n    return \"y\";\n  } else {\n    return undefined;\n  }\n}\nfunction determineAxisValue(inputAxis, ...extraAxisOptions) {\n  if (validateCoordinateInput(inputAxis)) {\n    return inputAxis;\n  }\n  for (const ____________element of extraAxisOptions) {\n    const axisValue = ____________element.axis || _axisDirection(____________element.position) || inputAxis.length > 1 && validateCoordinateInput(inputAxis[0].toLowerCase());\n    if (axisValue) {\n      return axisValue;\n    }\n  }\n  throw new Error(`Cannot determine type of '${inputAxis}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction axisCheck(targetAxisID, __axisDirection, _____axisIdentifier) {\n  if (_____axisIdentifier[__axisDirection + \"AxisID\"] === targetAxisID) {\n    return {\n      axis: __axisDirection\n    };\n  }\n}\nfunction retrieveAxisData(axisId, __________________chartData) {\n  if (__________________chartData.data && __________________chartData.data.datasets) {\n    const filteredDatasets = __________________chartData.data.datasets.filter(_______axisIdentifier => _______axisIdentifier.xAxisID === axisId || _______axisIdentifier.yAxisID === axisId);\n    if (filteredDatasets.length) {\n      return axisCheck(axisId, \"x\", filteredDatasets[0]) || axisCheck(axisId, \"y\", filteredDatasets[0]);\n    }\n  }\n  return {};\n}\nfunction updateChartAnimation(__chartConfig, scaleConfiguration) {\n  const currentAnimationConfig = animationStep[__chartConfig.type] || {\n    scales: {}\n  };\n  const scaleConfigurations = scaleConfiguration.scales || {};\n  const datasetIndexAxis = getDatasetIndexAxis(__chartConfig.type, scaleConfiguration);\n  const animationUpdates = Object.create(null);\n  Object.keys(scaleConfigurations).forEach(_scaleKey => {\n    const _scaleConfiguration = scaleConfigurations[_scaleKey];\n    if (!currentAnimationIndex(_scaleConfiguration)) {\n      return console.error(`Invalid scale configuration for scale: ${_scaleKey}`);\n    }\n    if (_scaleConfiguration._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${_scaleKey}`);\n    }\n    const ____axisValue = determineAxisValue(_scaleKey, _scaleConfiguration, retrieveAxisData(_scaleKey, __chartConfig), animationDuration.scales[_scaleConfiguration.type]);\n    const valueComparisonResult = compareValues(____axisValue, datasetIndexAxis);\n    const _scaleConfigurations = currentAnimationConfig.scales || {};\n    animationUpdates[_scaleKey] = lastUpdateDate(Object.create(null), [{\n      axis: ____axisValue\n    }, _scaleConfiguration, _scaleConfigurations[____axisValue], _scaleConfigurations[valueComparisonResult]]);\n  });\n  __chartConfig.data.datasets.forEach(____________inputData => {\n    const __chartType = ____________inputData.type || __chartConfig.type;\n    const _indexAxis = ____________inputData.indexAxis || getDatasetIndexAxis(__chartType, scaleConfiguration);\n    const scaleAnimations = (animationStep[__chartType] || {}).scales || {};\n    Object.keys(scaleAnimations).forEach(_______inputValue => {\n      const __axisIdentifier = getValueOrIndex(_______inputValue, _indexAxis);\n      const ___axisIdentifier = ____________inputData[__axisIdentifier + \"AxisID\"] || __axisIdentifier;\n      animationUpdates[___axisIdentifier] = animationUpdates[___axisIdentifier] || Object.create(null);\n      lastUpdateDate(animationUpdates[___axisIdentifier], [{\n        axis: __axisIdentifier\n      }, scaleConfigurations[___axisIdentifier], scaleAnimations[_______inputValue]]);\n    });\n  });\n  Object.keys(animationUpdates).forEach(animationTypeIndex => {\n    const ________________element = animationUpdates[animationTypeIndex];\n    lastUpdateDate(________________element, [animationDuration.scales[________________element.type], animationDuration.scale]);\n  });\n  return animationUpdates;\n}\nfunction isChartDataValid(inputChartData) {\n  const _optionsConfig = inputChartData.options ||= {};\n  _optionsConfig.plugins = chartAnimationRunning(_optionsConfig.plugins, {});\n  _optionsConfig.scales = updateChartAnimation(inputChartData, _optionsConfig);\n}\nfunction prepareChartOptions(_configOptions) {\n  (_configOptions = _configOptions || {}).datasets = _configOptions.datasets || [];\n  _configOptions.labels = _configOptions.labels || [];\n  return _configOptions;\n}\nfunction ___________chartOptions(_______chartOptions) {\n  (_______chartOptions = _______chartOptions || {}).data = prepareChartOptions(_______chartOptions.data);\n  isChartDataValid(_______chartOptions);\n  return _______chartOptions;\n}\nconst _____animationManager = new Map();\nconst chartsMap = new Set();\nfunction getOrCreateAnimationInstance(_animationKey, createAnimationInstance) {\n  let _animationInstance = _____animationManager.get(_animationKey);\n  if (!_animationInstance) {\n    _animationInstance = createAnimationInstance();\n    _____animationManager.set(_animationKey, _animationInstance);\n    chartsMap.add(_animationInstance);\n  }\n  return _animationInstance;\n}\nconst isAnimationRunning = (animationFrameIdSet, _animationFrameId, _animationFrameIndex) => {\n  const __animationFrameId = _requestAnimationFrameId(_animationFrameId, _animationFrameIndex);\n  if (__animationFrameId !== undefined) {\n    animationFrameIdSet.add(__animationFrameId);\n  }\n};\nclass ChartConfiguration {\n  constructor(____________chartOptions) {\n    this._config = ___________chartOptions(____________chartOptions);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(newType) {\n    this._config.type = newType;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(__________chartOptions) {\n    this._config.data = prepareChartOptions(__________chartOptions);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(optionsParam) {\n    this._config.options = optionsParam;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const __config = this._config;\n    this.clearCache();\n    isChartDataValid(__config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetKey) {\n    return getOrCreateAnimationInstance(datasetKey, () => [[`datasets.${datasetKey}`, \"\"]]);\n  }\n  datasetAnimationScopeKeys(__datasetKey, transitionKey) {\n    return getOrCreateAnimationInstance(`${__datasetKey}.transition.${transitionKey}`, () => [[`datasets.${__datasetKey}.transitions.${transitionKey}`, `transitions.${transitionKey}`], [`datasets.${__datasetKey}`, \"\"]]);\n  }\n  datasetElementScopeKeys(_datasetKey, __elementKey) {\n    return getOrCreateAnimationInstance(`${_datasetKey}-${__elementKey}`, () => [[`datasets.${_datasetKey}.elements.${__elementKey}`, `datasets.${_datasetKey}`, `elements.${__elementKey}`, \"\"]]);\n  }\n  pluginScopeKeys(pluginScopeKey) {\n    const _pluginId = pluginScopeKey.id;\n    return getOrCreateAnimationInstance(`${this.type}-plugin-${_pluginId}`, () => [[`plugins.${_pluginId}`, ...(pluginScopeKey.additionalOptionScopes || [])]]);\n  }\n  _cachedScopes(scopeKey, shouldReinitialize) {\n    const scopeCache = this._scopeCache;\n    let scopeMap = scopeCache.get(scopeKey);\n    if (!scopeMap || !!shouldReinitialize) {\n      scopeMap = new Map();\n      scopeCache.set(scopeKey, scopeMap);\n    }\n    return scopeMap;\n  }\n  getOptionScopes(animationTrigger, eventList, eventListIndex) {\n    const {\n      options: _____________animationOptions,\n      type: ____animationType\n    } = this;\n    const cachedAnimationScopes = this._cachedScopes(animationTrigger, eventListIndex);\n    const animationResult = cachedAnimationScopes.get(eventList);\n    if (animationResult) {\n      return animationResult;\n    }\n    const activeAnimationSet = new Set();\n    eventList.forEach(_elementList => {\n      if (animationTrigger) {\n        activeAnimationSet.add(animationTrigger);\n        _elementList.forEach(_____________event => isAnimationRunning(activeAnimationSet, animationTrigger, _____________event));\n      }\n      _elementList.forEach(_time => isAnimationRunning(activeAnimationSet, _____________animationOptions, _time));\n      _elementList.forEach(time => isAnimationRunning(activeAnimationSet, animationStep[____animationType] || {}, time));\n      _elementList.forEach(animationStartTime => isAnimationRunning(activeAnimationSet, animationDuration, animationStartTime));\n      _elementList.forEach(timeParameter => isAnimationRunning(activeAnimationSet, animationTask, timeParameter));\n    });\n    const animationHandles = Array.from(activeAnimationSet);\n    if (animationHandles.length === 0) {\n      animationHandles.push(Object.create(null));\n    }\n    if (chartsMap.has(eventList)) {\n      cachedAnimationScopes.set(eventList, animationHandles);\n    }\n    return animationHandles;\n  }\n  chartOptionScopes() {\n    const {\n      options: ______________chartOptions,\n      type: _chartType\n    } = this;\n    return [______________chartOptions, animationStep[_chartType] || {}, animationDuration.datasets[_chartType] || {}, {\n      type: _chartType\n    }, animationDuration, animationTask];\n  }\n  resolveNamedOptions(namedOptions, elementKeys, __animationFrameRequestId, _defaultOptions = [\"\"]) {\n    const _resolverOptions = {\n      $shared: true\n    };\n    const {\n      resolver: __resolverOptions,\n      subPrefixes: subPrefixes\n    } = elementMap(this._resolverCache, namedOptions, _defaultOptions);\n    let ___resolverOptions = __resolverOptions;\n    if (checkElementAnimation(__resolverOptions, elementKeys)) {\n      _resolverOptions.$shared = false;\n      if (___requestAnimationFrameId(__animationFrameRequestId)) {\n        __animationFrameRequestId = __animationFrameRequestId();\n      } else {\n        __animationFrameRequestId = __animationFrameRequestId;\n      }\n      const optionValue = this.createResolver(namedOptions, __animationFrameRequestId, subPrefixes);\n      ___resolverOptions = chartAnimationItems(__resolverOptions, __animationFrameRequestId, optionValue);\n    }\n    for (const _elementKey of elementKeys) {\n      _resolverOptions[_elementKey] = ___resolverOptions[_elementKey];\n    }\n    return _resolverOptions;\n  }\n  createResolver(animationResolver, _currentAnimation, animationFrames = [\"\"], __________animationDuration) {\n    const {\n      resolver: animationResolverContents\n    } = elementMap(this._resolverCache, animationResolver, animationFrames);\n    if (currentAnimationIndex(_currentAnimation)) {\n      return chartAnimationItems(animationResolverContents, _currentAnimation, undefined, __________animationDuration);\n    } else {\n      return animationResolverContents;\n    }\n  }\n}\nfunction elementMap(targetMap, elementKey, ______inputArray) {\n  let elementMapCache = targetMap.get(elementKey);\n  if (!elementMapCache) {\n    elementMapCache = new Map();\n    targetMap.set(elementKey, elementMapCache);\n  }\n  const inputArrayJoined = ______inputArray.join();\n  let __elementData = elementMapCache.get(inputArrayJoined);\n  if (!__elementData) {\n    __elementData = {\n      resolver: lastTickValue(elementKey, ______inputArray),\n      subPrefixes: ______inputArray.filter(isNotHoverText => !isNotHoverText.toLowerCase().includes(\"hover\"))\n    };\n    elementMapCache.set(inputArrayJoined, __elementData);\n  }\n  return __elementData;\n}\nconst ___animationContext = currentAnimation => currentAnimationIndex(currentAnimation) && Object.getOwnPropertyNames(currentAnimation).reduce((isAnimationFrameActive, _currentAnimationIndex) => isAnimationFrameActive || ___requestAnimationFrameId(currentAnimation[_currentAnimationIndex]), false);\nfunction checkElementAnimation(inputParameter, elementList) {\n  const {\n    isScriptable: getElementAnimationInfo,\n    isIndexable: isElementIndexable\n  } = _chartAnimationItems(inputParameter);\n  for (const _____________element of elementList) {\n    const elementInfo = getElementAnimationInfo(_____________element);\n    const sourceValue = isElementIndexable(_____________element);\n    const isElementActive = (sourceValue || elementInfo) && inputParameter[_____________element];\n    if (elementInfo && (___requestAnimationFrameId(isElementActive) || ___animationContext(isElementActive)) || sourceValue && animatedChartItems(isElementActive)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar chartAnimationList = \"4.4.0\";\nconst __animationQueue = [\"top\", \"bottom\", \"left\", \"right\", \"chartArea\"];\nfunction isVerticalPosition(positionType, _positionType) {\n  return positionType === \"top\" || positionType === \"bottom\" || __animationQueue.indexOf(positionType) === -1 && _positionType === \"x\";\n}\nfunction compareByField(comparisonKey, propertyToCompare) {\n  return function (itemToCompare, secondItem) {\n    if (itemToCompare[comparisonKey] === secondItem[comparisonKey]) {\n      return itemToCompare[propertyToCompare] - secondItem[propertyToCompare];\n    } else {\n      return itemToCompare[comparisonKey] - secondItem[comparisonKey];\n    }\n  };\n}\nfunction chartDataProcessingFunction(jsChartData) {\n  const _____________chartOptions = jsChartData.chart;\n  const ______animationOptions = _____________chartOptions.options.animation;\n  _____________chartOptions.notifyPlugins(\"afterRender\");\n  $(______animationOptions && ______animationOptions.onComplete, [jsChartData], _____________chartOptions);\n}\nfunction __processChartData(_________________________chartData) {\n  const __chart = _________________________chartData.chart;\n  const _____animationOptions = __chart.options.animation;\n  $(_____animationOptions && _____animationOptions.onProgress, [_________________________chartData], __chart);\n}\nfunction getElementFromSelector(elementOrSelector) {\n  if (_________animationManager() && typeof elementOrSelector == \"string\") {\n    elementOrSelector = document.getElementById(elementOrSelector);\n  } else if (elementOrSelector && elementOrSelector.length) {\n    elementOrSelector = elementOrSelector[0];\n  }\n  if (elementOrSelector && elementOrSelector.canvas) {\n    elementOrSelector = elementOrSelector.canvas;\n  }\n  return elementOrSelector;\n}\nconst currentStep = {};\nconst __notificationFunction = selectedElement => {\n  const _selectedElement = getElementFromSelector(selectedElement);\n  return Object.values(currentStep).filter(targetCanvas => targetCanvas.canvas === _selectedElement).pop();\n};\nfunction shiftedIndex(inputObject, threshold, indexOffset) {\n  const inputKeys = Object.keys(inputObject);\n  for (const _currentValue of inputKeys) {\n    const numberValue = +_currentValue;\n    if (numberValue >= threshold) {\n      const ________inputValue = inputObject[_currentValue];\n      delete inputObject[_currentValue];\n      if (indexOffset > 0 || numberValue > threshold) {\n        inputObject[numberValue + indexOffset] = ________inputValue;\n      }\n    }\n  }\n}\nfunction determineReturnValue(_______event, ________event, isConditionMet, _isConditionMet) {\n  if (isConditionMet && _______event.type !== \"mouseout\") {\n    if (_isConditionMet) {\n      return ________event;\n    } else {\n      return _______event;\n    }\n  } else {\n    return null;\n  }\n}\nfunction getValueBasedOnClip(___target, ________element, _____________________________________index) {\n  if (___target.options.clip) {\n    return ___target[_____________________________________index];\n  } else {\n    return ________element[_____________________________________index];\n  }\n}\nfunction calculateChartBounds(_____chartDimensions, _event) {\n  const {\n    xScale: xScale,\n    yScale: yScale\n  } = _____chartDimensions;\n  if (xScale && yScale) {\n    return {\n      left: getValueBasedOnClip(xScale, _event, \"left\"),\n      right: getValueBasedOnClip(xScale, _event, \"right\"),\n      top: getValueBasedOnClip(yScale, _event, \"top\"),\n      bottom: getValueBasedOnClip(yScale, _event, \"bottom\")\n    };\n  } else {\n    return _event;\n  }\n}\nclass rn {\n  static defaults = animationDuration;\n  static instances = currentStep;\n  static overrides = animationStep;\n  static registry = vs;\n  static version = chartAnimationList;\n  static getChart = __notificationFunction;\n  static register(...registrationParams) {\n    vs.add(...registrationParams);\n    updateLastDate();\n  }\n  static unregister(..._unregisterArgs) {\n    vs.remove(..._unregisterArgs);\n    updateLastDate();\n  }\n  constructor(t, e) {\n    const i = this.config = new ChartConfiguration(e);\n    const s = getElementFromSelector(t);\n    const n = __notificationFunction(s);\n    if (n) {\n      throw new Error(\"Canvas is already in use. Chart with ID '\" + n.id + \"' must be destroyed before the canvas with ID '\" + n.canvas.id + \"' can be reused.\");\n    }\n    const o = i.createResolver(i.chartOptionScopes(), this.getContext());\n    this.platform = new (i.platform || getCanvasContext(s))();\n    this.platform.updateConfig(i);\n    const a = this.platform.acquireContext(s, o.aspectRatio);\n    const r = a && a.canvas;\n    const h = r && r.height;\n    const l = r && r.width;\n    this.id = animationController();\n    this.ctx = a;\n    this.canvas = r;\n    this.width = l;\n    this.height = h;\n    this._options = o;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new Ms();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = animationFrameRequestId(updateTimestamp => this.update(updateTimestamp), o.resizeDelay || 0);\n    this._dataChanges = [];\n    currentStep[this.id] = this;\n    if (a && r) {\n      animationControllerInstance.listen(this, \"complete\", chartDataProcessingFunction);\n      animationControllerInstance.listen(this, \"progress\", __processChartData);\n      this._initialize();\n      if (this.attached) {\n        this.update();\n      }\n    } else {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n    }\n  }\n  get aspectRatio() {\n    const {\n      options: {\n        aspectRatio: aspectRatioValue,\n        maintainAspectRatio: isMaintainAspectRatio\n      },\n      width: widthValue,\n      height: heightValue,\n      _aspectRatio: aspectRatioValueOverride\n    } = this;\n    if (chartUpdateInterval(aspectRatioValue)) {\n      if (isMaintainAspectRatio && aspectRatioValueOverride) {\n        return aspectRatioValueOverride;\n      } else if (heightValue) {\n        return widthValue / heightValue;\n      } else {\n        return null;\n      }\n    } else {\n      return aspectRatioValue;\n    }\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(________inputData) {\n    this.config.data = ________inputData;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(optionsSetting) {\n    this.config.options = optionsSetting;\n  }\n  get registry() {\n    return vs;\n  }\n  _initialize() {\n    this.notifyPlugins(\"beforeInit\");\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      _animationFrameRequestId(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins(\"afterInit\");\n    return this;\n  }\n  clear() {\n    animationFrameRequest(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animationControllerInstance.stop(this);\n    return this;\n  }\n  resize(___width, resizeHeight) {\n    if (animationControllerInstance.running(this)) {\n      this._resizeBeforeDraw = {\n        width: ___width,\n        height: resizeHeight\n      };\n    } else {\n      this._resize(___width, resizeHeight);\n    }\n  }\n  _resize(_newWidth, canvasSize) {\n    const _______________________options = this.options;\n    const _____________canvasElement = this.canvas;\n    const isAspectRatioMaintained = _______________________options.maintainAspectRatio && this.aspectRatio;\n    const maximumCanvasSize = this.platform.getMaximumSize(_____________canvasElement, _newWidth, canvasSize, isAspectRatioMaintained);\n    const devicePixelRatio = _______________________options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const resizeAction = this.width ? \"resize\" : \"attach\";\n    this.width = maximumCanvasSize.width;\n    this.height = maximumCanvasSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (_animationFrameRequestId(this, devicePixelRatio, true)) {\n      this.notifyPlugins(\"resize\", {\n        size: maximumCanvasSize\n      });\n      $(_______________________options.onResize, [this, maximumCanvasSize], this);\n      if (this.attached && this._doResize(resizeAction)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const scaleOptions = this.options.scales || {};\n    __lastDateUpdated(scaleOptions, (___targetObject, elementId) => {\n      ___targetObject.id = elementId;\n    });\n  }\n  buildOrUpdateScales() {\n    const shouldDelete = this.options;\n    const e = shouldDelete.scales;\n    const i = this.scales;\n    const s = Object.keys(i).reduce((statusMap, key) => {\n      statusMap[key] = false;\n      return statusMap;\n    }, {});\n    let n = [];\n    if (e) {\n      n = n.concat(Object.keys(e).map(_____dataIndex => {\n        const currentDataPoint = e[_____dataIndex];\n        const chartType = determineAxisValue(_____dataIndex, currentDataPoint);\n        const isRadial = chartType === \"r\";\n        const isXAxis = chartType === \"x\";\n        return {\n          options: currentDataPoint,\n          dposition: isRadial ? \"chartArea\" : isXAxis ? \"bottom\" : \"left\",\n          dtype: isRadial ? \"radialLinear\" : isXAxis ? \"category\" : \"linear\"\n        };\n      }));\n    }\n    __lastDateUpdated(n, eventData => {\n      const eventOptions = eventData.options;\n      const optionId = eventOptions.id;\n      const seriesScale = determineAxisValue(optionId, eventOptions);\n      const isChartAnimationRunning = chartAnimationRunning(eventOptions.type, eventData.dtype);\n      if (eventOptions.position === undefined || isVerticalPosition(eventOptions.position, seriesScale) !== isVerticalPosition(eventData.dposition)) {\n        eventOptions.position = eventData.dposition;\n      }\n      s[optionId] = true;\n      let scaleInstance = null;\n      if (optionId in i && i[optionId].type === isChartAnimationRunning) {\n        scaleInstance = i[optionId];\n      } else {\n        scaleInstance = new (vs.getScale(isChartAnimationRunning))({\n          id: optionId,\n          type: isChartAnimationRunning,\n          ctx: this.ctx,\n          chart: this\n        });\n        i[scaleInstance.id] = scaleInstance;\n      }\n      scaleInstance.init(eventOptions, shouldDelete);\n    });\n    __lastDateUpdated(s, (isActive, ___propertyKey) => {\n      if (!isActive) {\n        delete i[___propertyKey];\n      }\n    });\n    __lastDateUpdated(i, task => {\n      ___________animationIndex.configure(this, task, task.options);\n      ___________animationIndex.addBox(this, task);\n    });\n  }\n  _updateMetasets() {\n    const ______________________________datasetIndex = this._metasets;\n    const _datasetsCount = this.data.datasets.length;\n    const metasetCount = ______________________________datasetIndex.length;\n    ______________________________datasetIndex.sort((targetIndex, _____elementIndex) => targetIndex.index - _____elementIndex.index);\n    if (metasetCount > _datasetsCount) {\n      for (let _____________________________datasetIndex = _datasetsCount; _____________________________datasetIndex < metasetCount; ++_____________________________datasetIndex) {\n        this._destroyDatasetMeta(_____________________________datasetIndex);\n      }\n      ______________________________datasetIndex.splice(_datasetsCount, metasetCount - _datasetsCount);\n    }\n    this._sortedMetasets = ______________________________datasetIndex.slice(0).sort(compareByField(\"order\", \"index\"));\n  }\n  _removeUnreferencedMetasets() {\n    const {\n      _metasets: metasetList,\n      data: {\n        datasets: _datasets\n      }\n    } = this;\n    if (metasetList.length > _datasets.length) {\n      delete this._stacks;\n    }\n    metasetList.forEach((datasetToCheck, _datasetMetaIndex) => {\n      if (_datasets.filter(isMatchingDataset => isMatchingDataset === datasetToCheck._dataset).length === 0) {\n        this._destroyDatasetMeta(_datasetMetaIndex);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const t = [];\n    const e = this.data.datasets;\n    let datasetIndex;\n    let s;\n    this._removeUnreferencedMetasets();\n    datasetIndex = 0;\n    s = e.length;\n    for (; datasetIndex < s; datasetIndex++) {\n      const _dataset = e[datasetIndex];\n      let __datasetMeta = this.getDatasetMeta(datasetIndex);\n      const datasetType = _dataset.type || this.config.type;\n      if (__datasetMeta.type && __datasetMeta.type !== datasetType) {\n        this._destroyDatasetMeta(datasetIndex);\n        __datasetMeta = this.getDatasetMeta(datasetIndex);\n      }\n      __datasetMeta.type = datasetType;\n      __datasetMeta.indexAxis = _dataset.indexAxis || getDatasetIndexAxis(datasetType, this.options);\n      __datasetMeta.order = _dataset.order || 0;\n      __datasetMeta.index = datasetIndex;\n      __datasetMeta.label = \"\" + _dataset.label;\n      __datasetMeta.visible = this.isDatasetVisible(datasetIndex);\n      if (__datasetMeta.controller) {\n        __datasetMeta.controller.updateIndex(datasetIndex);\n        __datasetMeta.controller.linkScales();\n      } else {\n        const __dataset = vs.getController(datasetType);\n        const {\n          datasetElementType: currentDataset,\n          dataElementType: dataElementTypeName\n        } = animationDuration.datasets[datasetType];\n        Object.assign(__dataset, {\n          dataElementType: vs.getElement(dataElementTypeName),\n          datasetElementType: currentDataset && vs.getElement(currentDataset)\n        });\n        __datasetMeta.controller = new __dataset(this, datasetIndex);\n        t.push(__datasetMeta.controller);\n      }\n    }\n    this._updateMetasets();\n    return t;\n  }\n  _resetElements() {\n    __lastDateUpdated(this.data.datasets, (_______________________________datasetIndex, __________datasetMeta) => {\n      this.getDatasetMeta(__________datasetMeta).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins(\"reset\");\n  }\n  update(______________datasetIndex) {\n    const e = this.config;\n    e.update();\n    const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext());\n    const isDatasetAbsent = this._animationsDisabled = !i.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins(\"beforeUpdate\", {\n      mode: ______________datasetIndex,\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    const n = this.buildOrUpdateControllers();\n    this.notifyPlugins(\"beforeElementsUpdate\");\n    let o = 0;\n    for (let _____________datasetIndex = 0, _datasetCount = this.data.datasets.length; _____________datasetIndex < _datasetCount; _____________datasetIndex++) {\n      const {\n        controller: datasetMetaController\n      } = this.getDatasetMeta(_____________datasetIndex);\n      const isDatasetNotIncluded = !isDatasetAbsent && n.indexOf(datasetMetaController) === -1;\n      datasetMetaController.buildOrUpdateElements(isDatasetNotIncluded);\n      o = Math.max(+datasetMetaController.getMaxOverflow(), o);\n    }\n    o = this._minPadding = i.layout.autoPadding ? o : 0;\n    this._updateLayout(o);\n    if (!isDatasetAbsent) {\n      __lastDateUpdated(n, resettableObject => {\n        resettableObject.reset();\n      });\n    }\n    this._updateDatasets(______________datasetIndex);\n    this.notifyPlugins(\"afterUpdate\", {\n      mode: ______________datasetIndex\n    });\n    this._layers.sort(compareByField(\"z\", \"_idx\"));\n    const {\n      _active: a,\n      _lastEvent: r\n    } = this;\n    if (r) {\n      this._eventHandler(r, true);\n    } else if (a.length) {\n      this._updateHoverStyles(a, a, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    __lastDateUpdated(this.scales, _boxToRemove => {\n      ___________animationIndex.removeBox(this, _boxToRemove);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const __eventOptions = this.options;\n    const listenerEventKeysSet = new Set(Object.keys(this._listeners));\n    const eventSet = new Set(__eventOptions.events);\n    if (!minimizedTime(listenerEventKeysSet, eventSet) || !!this._responsiveListeners !== __eventOptions.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {\n      _hiddenIndices: hiddenIndices\n    } = this;\n    const uniformDataChanges = this._getUniformDataChanges() || [];\n    for (const {\n      method: httpMethod,\n      start: ______startIndex,\n      count: _elementCount\n    } of uniformDataChanges) {\n      shiftedIndex(hiddenIndices, ______startIndex, httpMethod === \"_removeElements\" ? -_elementCount : _elementCount);\n    }\n  }\n  _getUniformDataChanges() {\n    const _currentIteration = this._dataChanges;\n    if (!_currentIteration || !_currentIteration.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const ___datasetCount = this.data.datasets.length;\n    const datasetFilterFunction = currentIterationIdentifier => new Set(_currentIteration.filter(currentIterationValue => currentIterationValue[0] === currentIterationIdentifier).map((_itemsList, firstElement) => firstElement + \",\" + _itemsList.splice(1).join(\",\")));\n    const filteredDatasetIdentifiers = datasetFilterFunction(0);\n    for (let currentIteration = 1; currentIteration < ___datasetCount; currentIteration++) {\n      if (!minimizedTime(filteredDatasetIdentifiers, datasetFilterFunction(currentIteration))) {\n        return;\n      }\n    }\n    return Array.from(filteredDatasetIdentifiers).map(commaSeparatedValues => commaSeparatedValues.split(\",\")).map(tokenArray => ({\n      method: tokenArray[1],\n      start: +tokenArray[2],\n      count: +tokenArray[3]\n    }));\n  }\n  _updateLayout(timeSinceStart) {\n    if (this.notifyPlugins(\"beforeLayout\", {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    ___________animationIndex.update(this, this.width, this.height, timeSinceStart);\n    const _chartAreaDimensions = this.chartArea;\n    const isInitialized = _chartAreaDimensions.width <= 0 || _chartAreaDimensions.height <= 0;\n    this._layers = [];\n    __lastDateUpdated(this.boxes, chartLayer => {\n      if (!isInitialized || chartLayer.position !== \"chartArea\") {\n        if (chartLayer.configure) {\n          chartLayer.configure();\n        }\n        this._layers.push(...chartLayer._layers());\n      }\n    }, this);\n    this._layers.forEach((___________________________________________________index, ____________________________________________________index) => {\n      ___________________________________________________index._idx = ____________________________________________________index;\n    });\n    this.notifyPlugins(\"afterLayout\");\n  }\n  _updateDatasets(__________________________datasetIndex) {\n    if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n      mode: __________________________datasetIndex,\n      cancelable: true\n    }) !== false) {\n      for (let _________________________datasetIndex = 0, datasetsCount = this.data.datasets.length; _________________________datasetIndex < datasetsCount; ++_________________________datasetIndex) {\n        this.getDatasetMeta(_________________________datasetIndex).controller.configure();\n      }\n      for (let ___________________datasetIndex = 0, __datasetCount = this.data.datasets.length; ___________________datasetIndex < __datasetCount; ++___________________datasetIndex) {\n        this._updateDataset(___________________datasetIndex, ___requestAnimationFrameId(__________________________datasetIndex) ? __________________________datasetIndex({\n          datasetIndex: ___________________datasetIndex\n        }) : __________________________datasetIndex);\n      }\n      this.notifyPlugins(\"afterDatasetsUpdate\", {\n        mode: __________________________datasetIndex\n      });\n    }\n  }\n  _updateDataset(_________________________________________datasetIndex, updateMode) {\n    const _______________datasetMeta = this.getDatasetMeta(_________________________________________datasetIndex);\n    const datasetUpdateInfo = {\n      meta: _______________datasetMeta,\n      index: _________________________________________datasetIndex,\n      mode: updateMode,\n      cancelable: true\n    };\n    if (this.notifyPlugins(\"beforeDatasetUpdate\", datasetUpdateInfo) !== false) {\n      _______________datasetMeta.controller._update(updateMode);\n      datasetUpdateInfo.cancelable = false;\n      this.notifyPlugins(\"afterDatasetUpdate\", datasetUpdateInfo);\n    }\n  }\n  render() {\n    if (this.notifyPlugins(\"beforeRender\", {\n      cancelable: true\n    }) !== false) {\n      if (animationControllerInstance.has(this)) {\n        if (this.attached && !animationControllerInstance.running(this)) {\n          animationControllerInstance.start(this);\n        }\n      } else {\n        this.draw();\n        chartDataProcessingFunction({\n          chart: this\n        });\n      }\n    }\n  }\n  draw() {\n    let indexForDrawing;\n    if (this._resizeBeforeDraw) {\n      const {\n        width: resizeWidth,\n        height: layerArray\n      } = this._resizeBeforeDraw;\n      this._resize(resizeWidth, layerArray);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins(\"beforeDraw\", {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    const layersArray = this._layers;\n    for (indexForDrawing = 0; indexForDrawing < layersArray.length && layersArray[indexForDrawing].z <= 0; ++indexForDrawing) {\n      layersArray[indexForDrawing].draw(this.chartArea);\n    }\n    for (this._drawDatasets(); indexForDrawing < layersArray.length; ++indexForDrawing) {\n      layersArray[indexForDrawing].draw(this.chartArea);\n    }\n    this.notifyPlugins(\"afterDraw\");\n  }\n  _getSortedDatasetMetas(__isConditionMet) {\n    const sortedMetasets = this._sortedMetasets;\n    const filteredMetas = [];\n    let _____________________________currentIndex;\n    let totalSortedMetas;\n    _____________________________currentIndex = 0;\n    totalSortedMetas = sortedMetasets.length;\n    for (; _____________________________currentIndex < totalSortedMetas; ++_____________________________currentIndex) {\n      const ___elementCount = sortedMetasets[_____________________________currentIndex];\n      if (!__isConditionMet || !!___elementCount.visible) {\n        filteredMetas.push(___elementCount);\n      }\n    }\n    return filteredMetas;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    const __sortedVisibleDatasetMetas = this.getSortedVisibleDatasetMetas();\n    for (let ____________________________datasetIndex = __sortedVisibleDatasetMetas.length - 1; ____________________________datasetIndex >= 0; --____________________________datasetIndex) {\n      this._drawDataset(__sortedVisibleDatasetMetas[____________________________datasetIndex]);\n    }\n    this.notifyPlugins(\"afterDatasetsDraw\");\n  }\n  _drawDataset(t) {\n    const e = this.ctx;\n    const i = t._clip;\n    const s = !i.disabled;\n    const n = calculateChartBounds(t, this.chartArea);\n    const o = {\n      meta: t,\n      index: t.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins(\"beforeDatasetDraw\", o) !== false) {\n      if (s) {\n        __________animationManager(e, {\n          left: i.left === false ? 0 : n.left - i.left,\n          right: i.right === false ? this.width : n.right + i.right,\n          top: i.top === false ? 0 : n.top - i.top,\n          bottom: i.bottom === false ? this.height : n.bottom + i.bottom\n        });\n      }\n      t.controller.draw();\n      if (s) {\n        Q(e);\n      }\n      o.cancelable = false;\n      this.notifyPlugins(\"afterDatasetDraw\", o);\n    }\n  }\n  isPointInArea(__pointCoordinates) {\n    return chartUpdater(__pointCoordinates, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(__eventTarget, eventModeIndex, _eventIndex, ___eventData) {\n    const eventMode = ____________animationController.modes[eventModeIndex];\n    if (typeof eventMode == \"function\") {\n      return eventMode(this, __eventTarget, _eventIndex, ___eventData);\n    } else {\n      return [];\n    }\n  }\n  getDatasetMeta(____________________________________________datasetIndex) {\n    const _________dataset = this.data.datasets[____________________________________________datasetIndex];\n    const metasetArray = this._metasets;\n    let __________________datasetMeta = metasetArray.filter(_____targetElement => _____targetElement && _____targetElement._dataset === _________dataset).pop();\n    if (!__________________datasetMeta) {\n      __________________datasetMeta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: _________dataset && _________dataset.order || 0,\n        index: ____________________________________________datasetIndex,\n        _dataset: _________dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasetArray.push(__________________datasetMeta);\n    }\n    return __________________datasetMeta;\n  }\n  getContext() {\n    return this.$context ||= tooltipHandler(null, {\n      chart: this,\n      type: \"chart\"\n    });\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(________________________________________datasetIndex) {\n    const ______dataset = this.data.datasets[________________________________________datasetIndex];\n    if (!______dataset) {\n      return false;\n    }\n    const ______________datasetMeta = this.getDatasetMeta(________________________________________datasetIndex);\n    if (typeof ______________datasetMeta.hidden == \"boolean\") {\n      return !______________datasetMeta.hidden;\n    } else {\n      return !______dataset.hidden;\n    }\n  }\n  setDatasetVisibility(datasetId, isDatasetVisible) {\n    this.getDatasetMeta(datasetId).hidden = !isDatasetVisible;\n  }\n  toggleDataVisibility(indexToToggle) {\n    this._hiddenIndices[indexToToggle] = !this._hiddenIndices[indexToToggle];\n  }\n  getDataVisibility(___________________________________________________________index) {\n    return !this._hiddenIndices[___________________________________________________________index];\n  }\n  _updateVisibility(__________________________________________datasetIndex, ___________________________________________datasetIndex, _isVisible) {\n    const visibilityState = _isVisible ? \"show\" : \"hide\";\n    const ________________datasetMeta = this.getDatasetMeta(__________________________________________datasetIndex);\n    const __animationResolver = ________________datasetMeta.controller._resolveAnimations(undefined, visibilityState);\n    if (canvasContext(___________________________________________datasetIndex)) {\n      ________________datasetMeta.data[___________________________________________datasetIndex].hidden = !_isVisible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(__________________________________________datasetIndex, _isVisible);\n      __animationResolver.update(________________datasetMeta, {\n        visible: _isVisible\n      });\n      this.update(datasetIndexMatch => datasetIndexMatch.datasetIndex === __________________________________________datasetIndex ? visibilityState : undefined);\n    }\n  }\n  hide(_______targetElement, ____isVisible) {\n    this._updateVisibility(_______targetElement, ____isVisible, false);\n  }\n  show(___isVisible, visibilityToggle) {\n    this._updateVisibility(___isVisible, visibilityToggle, true);\n  }\n  _destroyDatasetMeta(____________________________________datasetIndex) {\n    const _____________datasetMeta = this._metasets[____________________________________datasetIndex];\n    if (_____________datasetMeta && _____________datasetMeta.controller) {\n      _____________datasetMeta.controller._destroy();\n    }\n    delete this._metasets[____________________________________datasetIndex];\n  }\n  _stop() {\n    let ________________________________datasetIndex;\n    let totalDatasetCount;\n    this.stop();\n    animationControllerInstance.remove(this);\n    ________________________________datasetIndex = 0;\n    totalDatasetCount = this.data.datasets.length;\n    for (; ________________________________datasetIndex < totalDatasetCount; ++________________________________datasetIndex) {\n      this._destroyDatasetMeta(________________________________datasetIndex);\n    }\n  }\n  destroy() {\n    this.notifyPlugins(\"beforeDestroy\");\n    const {\n      canvas: ____________canvasElement,\n      ctx: __canvasRenderingContext\n    } = this;\n    this._stop();\n    this.config.clearCache();\n    if (____________canvasElement) {\n      this.unbindEvents();\n      animationFrameRequest(____________canvasElement, __canvasRenderingContext);\n      this.platform.releaseContext(__canvasRenderingContext);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    delete currentStep[this.id];\n    this.notifyPlugins(\"afterDestroy\");\n  }\n  toBase64Image(...base64ImageOptions) {\n    return this.canvas.toDataURL(...base64ImageOptions);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const eventListeners = this._listeners;\n    const eventPlatform = this.platform;\n    const addEventListenerWithCallback = (______eventType, ______eventHandler) => {\n      eventPlatform.addEventListener(this, ______eventType, ______eventHandler);\n      eventListeners[______eventType] = ______eventHandler;\n    };\n    const eventOffsetHandler = (eventOffset, eventOffsetX, offsetYValue) => {\n      eventOffset.offsetX = eventOffsetX;\n      eventOffset.offsetY = offsetYValue;\n      this._eventHandler(eventOffset);\n    };\n    __lastDateUpdated(this.options.events, _____eventType => addEventListenerWithCallback(_____eventType, eventOffsetHandler));\n  }\n  bindResponsiveEvents() {\n    this._responsiveListeners ||= {};\n    const t = this._responsiveListeners;\n    const e = this.platform;\n    const eventListenerCallback = (_______eventType, _______eventHandler) => {\n      e.addEventListener(this, _______eventType, _______eventHandler);\n      t[_______eventType] = _______eventHandler;\n    };\n    const removeEventListener = (eventTypeIndex, eventListenerOptions) => {\n      if (t[eventTypeIndex]) {\n        e.removeEventListener(this, eventTypeIndex, eventListenerOptions);\n        delete t[eventTypeIndex];\n      }\n    };\n    const handleCanvasResize = (canvasHeight, ______________event) => {\n      if (this.canvas) {\n        this.resize(canvasHeight, ______________event);\n      }\n    };\n    let o;\n    const onAttach = () => {\n      removeEventListener(\"attach\", onAttach);\n      this.attached = true;\n      this.resize();\n      eventListenerCallback(\"resize\", handleCanvasResize);\n      eventListenerCallback(\"detach\", o);\n    };\n    o = () => {\n      this.attached = false;\n      removeEventListener(\"resize\", handleCanvasResize);\n      this._stop();\n      this._resize(0, 0);\n      eventListenerCallback(\"attach\", onAttach);\n    };\n    if (e.isAttached(this.canvas)) {\n      onAttach();\n    } else {\n      o();\n    }\n  }\n  unbindEvents() {\n    __lastDateUpdated(this._listeners, (__eventHandler, eventListener) => {\n      this.platform.removeEventListener(this, eventListener, __eventHandler);\n    });\n    this._listeners = {};\n    __lastDateUpdated(this._responsiveListeners, (___eventHandler, _eventListener) => {\n      this.platform.removeEventListener(this, _eventListener, ___eventHandler);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(hoverDatasetArray, hoverType, hoverDatasetIndex) {\n    const hoverAction = hoverDatasetIndex ? \"set\" : \"remove\";\n    let _________________datasetMeta;\n    let hoverDataset;\n    let ____________________currentIndex;\n    let hoverDatasetCount;\n    if (hoverType === \"dataset\") {\n      _________________datasetMeta = this.getDatasetMeta(hoverDatasetArray[0].datasetIndex);\n      _________________datasetMeta.controller[\"_\" + hoverAction + \"DatasetHoverStyle\"]();\n    }\n    ____________________currentIndex = 0;\n    hoverDatasetCount = hoverDatasetArray.length;\n    for (; ____________________currentIndex < hoverDatasetCount; ++____________________currentIndex) {\n      hoverDataset = hoverDatasetArray[____________________currentIndex];\n      const _datasetController = hoverDataset && this.getDatasetMeta(hoverDataset.datasetIndex).controller;\n      if (_datasetController) {\n        _datasetController[hoverAction + \"HoverStyle\"](hoverDataset.element, hoverDataset.datasetIndex, hoverDataset.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(elementDataArray) {\n    const _activeElements = this._active || [];\n    const ________datasetMeta = elementDataArray.map(({\n      datasetIndex: ____________datasetIndex,\n      index: _elementIndex\n    }) => {\n      const _______datasetMeta = this.getDatasetMeta(____________datasetIndex);\n      if (!_______datasetMeta) {\n        throw new Error(\"No dataset found at index \" + ____________datasetIndex);\n      }\n      return {\n        datasetIndex: ____________datasetIndex,\n        element: _______datasetMeta.data[_elementIndex],\n        index: _elementIndex\n      };\n    });\n    if (!_animationController(________datasetMeta, _activeElements)) {\n      this._active = ________datasetMeta;\n      this._lastEvent = null;\n      this._updateHoverStyles(________datasetMeta, _activeElements);\n    }\n  }\n  notifyPlugins(notificationData, __eventData, pluginIndex) {\n    return this._plugins.notify(this, notificationData, __eventData, pluginIndex);\n  }\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(pluginEvent => pluginEvent.plugin.id === pluginId).length === 1;\n  }\n  _updateHoverStyles(_excludedEvents, excludedDataPoints, _excludedDataPoints) {\n    const _hoverOptions = this.options.hover;\n    const filterOutDataPoints = (_filteredData, excludedEvents) => _filteredData.filter(__currentDataPoint => !excludedEvents.some(currentEvent => __currentDataPoint.datasetIndex === currentEvent.datasetIndex && __currentDataPoint.index === currentEvent.index));\n    const filteredDataPoints = filterOutDataPoints(excludedDataPoints, _excludedEvents);\n    const filteredExcludedEvents = _excludedDataPoints ? _excludedEvents : filterOutDataPoints(_excludedEvents, excludedDataPoints);\n    if (filteredDataPoints.length) {\n      this.updateHoverStyle(filteredDataPoints, _hoverOptions.mode, false);\n    }\n    if (filteredExcludedEvents.length && _hoverOptions.mode) {\n      this.updateHoverStyle(filteredExcludedEvents, _hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(_____________________________event, eventReplay) {\n    const __eventDetails = {\n      event: _____________________________event,\n      replay: eventReplay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(_____________________________event)\n    };\n    const isEventTriggeredByNative = _eventOptions => (_eventOptions.options.events || this.options.events).includes(_____________________________event.native.type);\n    if (this.notifyPlugins(\"beforeEvent\", __eventDetails, isEventTriggeredByNative) === false) {\n      return;\n    }\n    const eventHandledSuccessfully = this._handleEvent(_____________________________event, eventReplay, __eventDetails.inChartArea);\n    __eventDetails.cancelable = false;\n    this.notifyPlugins(\"afterEvent\", __eventDetails, isEventTriggeredByNative);\n    if (eventHandledSuccessfully || __eventDetails.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(_eventContext, ________eventData, hoverEventIndex) {\n    const {\n      _active: __activeElements = [],\n      options: ____eventOptions\n    } = this;\n    const _________eventData = ________eventData;\n    const ___activeElements = this._getActiveElements(_eventContext, __activeElements, hoverEventIndex, _________eventData);\n    const _animationId = animationIdentifier(_eventContext);\n    const returnValue = determineReturnValue(_eventContext, this._lastEvent, hoverEventIndex, _animationId);\n    if (hoverEventIndex) {\n      this._lastEvent = null;\n      $(____eventOptions.onHover, [_eventContext, ___activeElements, this], this);\n      if (_animationId) {\n        $(____eventOptions.onClick, [_eventContext, ___activeElements, this], this);\n      }\n    }\n    const isAnimationControllerActive = !_animationController(___activeElements, __activeElements);\n    if (isAnimationControllerActive || ________eventData) {\n      this._active = ___activeElements;\n      this._updateHoverStyles(___activeElements, __activeElements, ________eventData);\n    }\n    this._lastEvent = returnValue;\n    return isAnimationControllerActive;\n  }\n  _getActiveElements(________________________event, ____eventObject, isActiveElement, activeElementsCount) {\n    if (________________________event.type === \"mouseout\") {\n      return [];\n    }\n    if (!isActiveElement) {\n      return ____eventObject;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(________________________event, hoverOptions.mode, hoverOptions, activeElementsCount);\n  }\n}\nfunction updateLastDate() {\n  return __lastDateUpdated(rn.instances, pluginHandler => pluginHandler._plugins.invalidate());\n}\nfunction lineMarginRatio(_________canvasContext, ___shapeProperties, __endAngle) {\n  const {\n    startAngle: ____startAngle,\n    pixelMargin: _pixelMargin,\n    x: ____centerX,\n    y: __centerY,\n    outerRadius: _outerRadius,\n    innerRadius: innerRadius\n  } = ___shapeProperties;\n  let marginRatio = _pixelMargin / _outerRadius;\n  _________canvasContext.beginPath();\n  _________canvasContext.arc(____centerX, __centerY, _outerRadius, ____startAngle - marginRatio, __endAngle + marginRatio);\n  if (innerRadius > _pixelMargin) {\n    marginRatio = _pixelMargin / innerRadius;\n    _________canvasContext.arc(____centerX, __centerY, innerRadius, __endAngle + marginRatio, ____startAngle - marginRatio, true);\n  } else {\n    _________canvasContext.arc(____centerX, __centerY, _pixelMargin, __endAngle + currentFrameTimestamp, ____startAngle - currentFrameTimestamp);\n  }\n  _________canvasContext.closePath();\n  _________canvasContext.clip();\n}\nfunction createAnimation(_______animationDuration) {\n  return __animationController(_______animationDuration, [\"outerStart\", \"outerEnd\", \"innerStart\", \"innerEnd\"]);\n}\nfunction animateBorderRadius(borderOptions, outerRadius, currentCoordinate, _scaleFactor) {\n  const ___animationProperties = createAnimation(borderOptions.options.borderRadius);\n  const halfDistanceToOuterRadius = (currentCoordinate - outerRadius) / 2;\n  const maxBorderRadius = Math.min(halfDistanceToOuterRadius, _scaleFactor * outerRadius / 2);\n  const borderAnimationFunction = timeProgress => {\n    const scaledDistanceToChartEdge = (currentCoordinate - Math.min(halfDistanceToOuterRadius, timeProgress)) * _scaleFactor / 2;\n    return chartAnimationState(timeProgress, 0, Math.min(halfDistanceToOuterRadius, scaledDistanceToChartEdge));\n  };\n  return {\n    outerStart: borderAnimationFunction(___animationProperties.outerStart),\n    outerEnd: borderAnimationFunction(___animationProperties.outerEnd),\n    innerStart: chartAnimationState(___animationProperties.innerStart, 0, maxBorderRadius),\n    innerEnd: chartAnimationState(___animationProperties.innerEnd, 0, maxBorderRadius)\n  };\n}\nfunction calculateCoordinates(_radius, _angle, angleOffset, offsetY) {\n  return {\n    x: angleOffset + _radius * Math.cos(_angle),\n    y: offsetY + _radius * Math.sin(_angle)\n  };\n}\nfunction drawShapeWithArcs(_canvasContext, shapeProperties, additionalOffset, additionalRadius, offsetAngle, isArcVisible) {\n  const {\n    x: centerX,\n    y: centerYCoordinate,\n    startAngle: startAngle,\n    pixelMargin: pixelMargin,\n    innerRadius: innerRadiusValue\n  } = shapeProperties;\n  const calculatedOffsetRadius = Math.max(shapeProperties.outerRadius + additionalRadius + additionalOffset - pixelMargin, 0);\n  const calculatedInnerRadius = innerRadiusValue > 0 ? innerRadiusValue + additionalRadius + additionalOffset + pixelMargin : 0;\n  let arcOffsetAdjustment = 0;\n  const angleDifference = offsetAngle - startAngle;\n  if (additionalRadius) {\n    const arcOffset = ((innerRadiusValue > 0 ? innerRadiusValue - additionalRadius : 0) + (calculatedOffsetRadius > 0 ? calculatedOffsetRadius - additionalRadius : 0)) / 2;\n    arcOffsetAdjustment = (angleDifference - (arcOffset !== 0 ? angleDifference * arcOffset / (arcOffset + additionalRadius) : angleDifference)) / 2;\n  }\n  const _angleOffset = (angleDifference - Math.max(0.001, angleDifference * calculatedOffsetRadius - additionalOffset / notificationListener) / calculatedOffsetRadius) / 2;\n  const totalAngleOffset = startAngle + _angleOffset + arcOffsetAdjustment;\n  const finalArcAngle = offsetAngle - _angleOffset - arcOffsetAdjustment;\n  const {\n    outerStart: outerArcStart,\n    outerEnd: outerEndAngle,\n    innerStart: innerEndArcRadius,\n    innerEnd: innerEndArcRadiusValue\n  } = animateBorderRadius(shapeProperties, calculatedInnerRadius, calculatedOffsetRadius, finalArcAngle - totalAngleOffset);\n  const remainingDistance = calculatedOffsetRadius - outerArcStart;\n  const shapeRadiusDifference = calculatedOffsetRadius - outerEndAngle;\n  const arcMidpointAdjustment = totalAngleOffset + outerArcStart / remainingDistance;\n  const _angleDifference = finalArcAngle - outerEndAngle / shapeRadiusDifference;\n  const innerArcTotalRadius = calculatedInnerRadius + innerEndArcRadius;\n  const _innerArcTotalRadius = calculatedInnerRadius + innerEndArcRadiusValue;\n  const angleAdjustment = totalAngleOffset + innerEndArcRadius / innerArcTotalRadius;\n  const finalArcAngleAdjustment = finalArcAngle - innerEndArcRadiusValue / _innerArcTotalRadius;\n  _canvasContext.beginPath();\n  if (isArcVisible) {\n    const midArcAngle = (arcMidpointAdjustment + _angleDifference) / 2;\n    _canvasContext.arc(centerX, centerYCoordinate, calculatedOffsetRadius, arcMidpointAdjustment, midArcAngle);\n    _canvasContext.arc(centerX, centerYCoordinate, calculatedOffsetRadius, midArcAngle, _angleDifference);\n    if (outerEndAngle > 0) {\n      const geometry = calculateCoordinates(shapeRadiusDifference, _angleDifference, centerX, centerYCoordinate);\n      _canvasContext.arc(geometry.x, geometry.y, outerEndAngle, _angleDifference, finalArcAngle + currentFrameTimestamp);\n    }\n    const arcCoordinates = calculateCoordinates(_innerArcTotalRadius, finalArcAngle, centerX, centerYCoordinate);\n    _canvasContext.lineTo(arcCoordinates.x, arcCoordinates.y);\n    if (innerEndArcRadiusValue > 0) {\n      const _shapeProperties = calculateCoordinates(_innerArcTotalRadius, finalArcAngleAdjustment, centerX, centerYCoordinate);\n      _canvasContext.arc(_shapeProperties.x, _shapeProperties.y, innerEndArcRadiusValue, finalArcAngle + currentFrameTimestamp, finalArcAngleAdjustment + Math.PI);\n    }\n    const arcEndAngle = (finalArcAngle - innerEndArcRadiusValue / calculatedInnerRadius + (totalAngleOffset + innerEndArcRadius / calculatedInnerRadius)) / 2;\n    _canvasContext.arc(centerX, centerYCoordinate, calculatedInnerRadius, finalArcAngle - innerEndArcRadiusValue / calculatedInnerRadius, arcEndAngle, true);\n    _canvasContext.arc(centerX, centerYCoordinate, calculatedInnerRadius, arcEndAngle, totalAngleOffset + innerEndArcRadius / calculatedInnerRadius, true);\n    if (innerEndArcRadius > 0) {\n      const __shapeProperties = calculateCoordinates(innerArcTotalRadius, angleAdjustment, centerX, centerYCoordinate);\n      _canvasContext.arc(__shapeProperties.x, __shapeProperties.y, innerEndArcRadius, angleAdjustment + Math.PI, totalAngleOffset - currentFrameTimestamp);\n    }\n    const _endPointCoordinates = calculateCoordinates(remainingDistance, totalAngleOffset, centerX, centerYCoordinate);\n    _canvasContext.lineTo(_endPointCoordinates.x, _endPointCoordinates.y);\n    if (outerArcStart > 0) {\n      const shapeCoordinates = calculateCoordinates(remainingDistance, arcMidpointAdjustment, centerX, centerYCoordinate);\n      _canvasContext.arc(shapeCoordinates.x, shapeCoordinates.y, outerArcStart, totalAngleOffset - currentFrameTimestamp, arcMidpointAdjustment);\n    }\n  } else {\n    _canvasContext.moveTo(centerX, centerYCoordinate);\n    const arcMidpoint = Math.cos(arcMidpointAdjustment) * calculatedOffsetRadius + centerX;\n    const arcEndCoordinates = Math.sin(arcMidpointAdjustment) * calculatedOffsetRadius + centerYCoordinate;\n    _canvasContext.lineTo(arcMidpoint, arcEndCoordinates);\n    const _arcMidpoint = Math.cos(_angleDifference) * calculatedOffsetRadius + centerX;\n    const calculatedCoordinates = Math.sin(_angleDifference) * calculatedOffsetRadius + centerYCoordinate;\n    _canvasContext.lineTo(_arcMidpoint, calculatedCoordinates);\n  }\n  _canvasContext.closePath();\n}\nfunction drawArcSegments(___________canvasContext, arcProperties, ____________index, segmentIndex, arcSegmentCount) {\n  const {\n    fullCircles: fullCircleCount,\n    startAngle: ___startAngle,\n    circumference: arcCircumference\n  } = arcProperties;\n  let ____endAngle = arcProperties.endAngle;\n  if (fullCircleCount) {\n    drawShapeWithArcs(___________canvasContext, arcProperties, ____________index, segmentIndex, ____endAngle, arcSegmentCount);\n    for (let _loopIndex = 0; _loopIndex < fullCircleCount; ++_loopIndex) {\n      ___________canvasContext.fill();\n    }\n    if (!isNaN(arcCircumference)) {\n      ____endAngle = ___startAngle + (arcCircumference % lastAnimationUpdateTimestamp || lastAnimationUpdateTimestamp);\n    }\n  }\n  drawShapeWithArcs(___________canvasContext, arcProperties, ____________index, segmentIndex, ____endAngle, arcSegmentCount);\n  ___________canvasContext.fill();\n  return ____endAngle;\n}\nfunction _drawShapeWithStroke(canvasRenderingContext, drawingConfig, endAngleValue, endAngle, _endAngle) {\n  const {\n    fullCircles: _fullCircleCount,\n    startAngle: ______startAngle,\n    circumference: circularCircumference,\n    options: drawingOptions\n  } = drawingConfig;\n  const {\n    borderWidth: _borderWidth,\n    borderJoinStyle: borderJoinStyle,\n    borderDash: _borderDashArray,\n    borderDashOffset: borderDashOffset\n  } = drawingOptions;\n  const isBorderAlignedInner = drawingOptions.borderAlign === \"inner\";\n  if (!_borderWidth) {\n    return;\n  }\n  canvasRenderingContext.setLineDash(_borderDashArray || []);\n  canvasRenderingContext.lineDashOffset = borderDashOffset;\n  if (isBorderAlignedInner) {\n    canvasRenderingContext.lineWidth = _borderWidth * 2;\n    canvasRenderingContext.lineJoin = borderJoinStyle || \"round\";\n  } else {\n    canvasRenderingContext.lineWidth = _borderWidth;\n    canvasRenderingContext.lineJoin = borderJoinStyle || \"bevel\";\n  }\n  let currentEndAngle = drawingConfig.endAngle;\n  if (_fullCircleCount) {\n    drawShapeWithArcs(canvasRenderingContext, drawingConfig, endAngleValue, endAngle, currentEndAngle, _endAngle);\n    for (let strokeIteration = 0; strokeIteration < _fullCircleCount; ++strokeIteration) {\n      canvasRenderingContext.stroke();\n    }\n    if (!isNaN(circularCircumference)) {\n      currentEndAngle = ______startAngle + (circularCircumference % lastAnimationUpdateTimestamp || lastAnimationUpdateTimestamp);\n    }\n  }\n  if (isBorderAlignedInner) {\n    lineMarginRatio(canvasRenderingContext, drawingConfig, currentEndAngle);\n  }\n  if (!_fullCircleCount) {\n    drawShapeWithArcs(canvasRenderingContext, drawingConfig, endAngleValue, endAngle, currentEndAngle, _endAngle);\n    canvasRenderingContext.stroke();\n  }\n}\nclass mn extends _AnimationController {\n  static id = \"arc\";\n  static defaults = {\n    borderAlign: \"center\",\n    borderColor: \"#fff\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true\n  };\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\"\n  };\n  static descriptors = {\n    _scriptable: true,\n    _indexable: isBorderDash => isBorderDash !== \"borderDash\"\n  };\n  circumference;\n  endAngle;\n  fullCircles;\n  innerRadius;\n  outerRadius;\n  pixelMargin;\n  startAngle;\n  constructor(________________options) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (________________options) {\n      Object.assign(this, ________________options);\n    }\n  }\n  inRange(coordinateX, __coordinateY, ____________animationIndex) {\n    const propsForCoordinate = this.getProps([\"x\", \"y\"], ____________animationIndex);\n    const {\n      angle: _currentAngle,\n      distance: distanceValue\n    } = _lastAnimationUpdateTimestamp(propsForCoordinate, {\n      x: coordinateX,\n      y: __coordinateY\n    });\n    const {\n      startAngle: _______startAngle,\n      endAngle: _endAngleValue,\n      innerRadius: _innerRadiusValue,\n      outerRadius: outerRadiusValue,\n      circumference: _circumferenceValue\n    } = this.getProps([\"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], ____________animationIndex);\n    const halfSpacingPlusBorderWidth = (this.options.spacing + this.options.borderWidth) / 2;\n    const isChartAnimating = chartAnimationRunning(_circumferenceValue, _endAngleValue - _______startAngle) >= lastAnimationUpdateTimestamp || _animatedChartItems(_currentAngle, _______startAngle, _endAngleValue);\n    const animationRequestIdValue = animationRequestId(distanceValue, _innerRadiusValue + halfSpacingPlusBorderWidth, outerRadiusValue + halfSpacingPlusBorderWidth);\n    return isChartAnimating && animationRequestIdValue;\n  }\n  getCenterPoint(props) {\n    const {\n      x: _centerPointX,\n      y: ___centerY,\n      startAngle: _____startAngle,\n      endAngle: _____endAngle,\n      innerRadius: _innerRadius,\n      outerRadius: __outerRadius\n    } = this.getProps([\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"], props);\n    const {\n      offset: radiusOffset,\n      spacing: spacingValue\n    } = this.options;\n    const averageAngle = (_____startAngle + _____endAngle) / 2;\n    const averageRadius = (_innerRadius + __outerRadius + spacingValue + radiusOffset) / 2;\n    return {\n      x: _centerPointX + Math.cos(averageAngle) * averageRadius,\n      y: ___centerY + Math.sin(averageAngle) * averageRadius\n    };\n  }\n  tooltipPosition(tooltipDimensions) {\n    return this.getCenterPoint(tooltipDimensions);\n  }\n  draw(t) {\n    const {\n      options: e,\n      circumference: i\n    } = this;\n    const s = (e.offset || 0) / 4;\n    const n = (e.spacing || 0) / 2;\n    const o = e.circular;\n    this.pixelMargin = e.borderAlign === \"inner\" ? 0.33 : 0;\n    this.fullCircles = i > lastAnimationUpdateTimestamp ? Math.floor(i / lastAnimationUpdateTimestamp) : 0;\n    if (i === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    t.save();\n    const a = (this.startAngle + this.endAngle) / 2;\n    t.translate(Math.cos(a) * s, Math.sin(a) * s);\n    const r = s * (1 - Math.sin(Math.min(notificationListener, i || 0)));\n    t.fillStyle = e.backgroundColor;\n    t.strokeStyle = e.borderColor;\n    drawArcSegments(t, this, r, n, o);\n    _drawShapeWithStroke(t, this, r, n, o);\n    t.restore();\n  }\n}\nfunction updateCanvasBorderStyles(__________canvasContext, borderStyles, borderStyleValues = borderStyles) {\n  __________canvasContext.lineCap = chartAnimationRunning(borderStyleValues.borderCapStyle, borderStyles.borderCapStyle);\n  __________canvasContext.setLineDash(chartAnimationRunning(borderStyleValues.borderDash, borderStyles.borderDash));\n  __________canvasContext.lineDashOffset = chartAnimationRunning(borderStyleValues.borderDashOffset, borderStyles.borderDashOffset);\n  __________canvasContext.lineJoin = chartAnimationRunning(borderStyleValues.borderJoinStyle, borderStyles.borderJoinStyle);\n  __________canvasContext.lineWidth = chartAnimationRunning(borderStyleValues.borderWidth, borderStyles.borderWidth);\n  __________canvasContext.strokeStyle = chartAnimationRunning(borderStyleValues.borderColor, borderStyles.borderColor);\n}\nfunction defineLineToPoint(lineToPoint, endPoint, _point) {\n  lineToPoint.lineTo(_point.x, _point.y);\n}\nfunction getAnimationFunction(curveOptions) {\n  if (curveOptions.stepped) {\n    return ___animationStep;\n  } else if (curveOptions.tension || curveOptions.cubicInterpolationMode === \"monotone\") {\n    return _chartAnimationState;\n  } else {\n    return defineLineToPoint;\n  }\n}\nfunction calculateOverlap(____inputArray, _range, inputRange = {}) {\n  const __inputArrayLength = ____inputArray.length;\n  const {\n    start: rangeStart = 0,\n    end: _____endIndex = __inputArrayLength - 1\n  } = inputRange;\n  const {\n    start: _rangeStart,\n    end: rangeEnd\n  } = _range;\n  const maxStartRange = Math.max(rangeStart, _rangeStart);\n  const overlapEnd = Math.min(_____endIndex, rangeEnd);\n  const isOutsideRange = rangeStart < _rangeStart && _____endIndex < _rangeStart || rangeStart > rangeEnd && _____endIndex > rangeEnd;\n  return {\n    count: __inputArrayLength,\n    start: maxStartRange,\n    loop: _range.loop,\n    ilen: overlapEnd < maxStartRange && !isOutsideRange ? __inputArrayLength + overlapEnd - maxStartRange : overlapEnd - maxStartRange\n  };\n}\nfunction animateUsingCanvas(_____canvasContext, _animationOptions, _____index, animationSettings) {\n  const {\n    points: __animationPoints,\n    options: ___________animationOptions\n  } = _animationOptions;\n  const {\n    count: _pointCount,\n    start: _____________startIndex,\n    loop: isLooping,\n    ilen: _overlapLength\n  } = calculateOverlap(__animationPoints, _____index, animationSettings);\n  const _getAnimationHandler = getAnimationFunction(___________animationOptions);\n  let __________________________________________________________________index;\n  let __currentPoint;\n  let previousPoint;\n  let {\n    move: shouldMove = true,\n    reverse: isAnimationReversed\n  } = animationSettings || {};\n  for (__________________________________________________________________index = 0; __________________________________________________________________index <= _overlapLength; ++__________________________________________________________________index) {\n    __currentPoint = __animationPoints[(_____________startIndex + (isAnimationReversed ? _overlapLength - __________________________________________________________________index : __________________________________________________________________index)) % _pointCount];\n    if (!__currentPoint.skip) {\n      if (shouldMove) {\n        _____canvasContext.moveTo(__currentPoint.x, __currentPoint.y);\n        shouldMove = false;\n      } else {\n        _getAnimationHandler(_____canvasContext, previousPoint, __currentPoint, isAnimationReversed, ___________animationOptions.stepped);\n      }\n      previousPoint = __currentPoint;\n    }\n  }\n  if (isLooping) {\n    __currentPoint = __animationPoints[(_____________startIndex + (isAnimationReversed ? _overlapLength : 0)) % _pointCount];\n    _getAnimationHandler(_____canvasContext, previousPoint, __currentPoint, isAnimationReversed, ___________animationOptions.stepped);\n  }\n  return !!isLooping;\n}\nfunction drawLineToCanvas(__canvasContext, pointsData, index, configOptions) {\n  const ___pointsArray = pointsData.points;\n  const {\n    count: totalPointCount,\n    start: ____________startIndex,\n    ilen: overlapLength\n  } = calculateOverlap(___pointsArray, index, configOptions);\n  const {\n    move: shouldMoveToStart = true,\n    reverse: _isReverse\n  } = configOptions || {};\n  let ________________________________________________________________________currentIndex;\n  let _currentPoint;\n  let _currentPixelCoordinate;\n  let currentMaxYCoordinate;\n  let maxCoordinateY;\n  let currentCoordinateY;\n  let _averageXCoordinate = 0;\n  let averageCount = 0;\n  const calculateWrappedIndex = _tempValue => (____________startIndex + (_isReverse ? overlapLength - _tempValue : _tempValue)) % totalPointCount;\n  const drawLineSegment = () => {\n    if (currentMaxYCoordinate !== maxCoordinateY) {\n      __canvasContext.lineTo(_averageXCoordinate, maxCoordinateY);\n      __canvasContext.lineTo(_averageXCoordinate, currentMaxYCoordinate);\n      __canvasContext.lineTo(_averageXCoordinate, currentCoordinateY);\n    }\n  };\n  if (shouldMoveToStart) {\n    _currentPoint = ___pointsArray[calculateWrappedIndex(0)];\n    __canvasContext.moveTo(_currentPoint.x, _currentPoint.y);\n  }\n  ________________________________________________________________________currentIndex = 0;\n  for (; ________________________________________________________________________currentIndex <= overlapLength; ++________________________________________________________________________currentIndex) {\n    _currentPoint = ___pointsArray[calculateWrappedIndex(________________________________________________________________________currentIndex)];\n    if (_currentPoint.skip) {\n      continue;\n    }\n    const positionX = _currentPoint.x;\n    const coordinateY = _currentPoint.y;\n    const currentPixelCoordinate = positionX | 0;\n    if (currentPixelCoordinate === _currentPixelCoordinate) {\n      if (coordinateY < currentMaxYCoordinate) {\n        currentMaxYCoordinate = coordinateY;\n      } else if (coordinateY > maxCoordinateY) {\n        maxCoordinateY = coordinateY;\n      }\n      _averageXCoordinate = (averageCount * _averageXCoordinate + positionX) / ++averageCount;\n    } else {\n      drawLineSegment();\n      __canvasContext.lineTo(positionX, coordinateY);\n      _currentPixelCoordinate = currentPixelCoordinate;\n      averageCount = 0;\n      currentMaxYCoordinate = maxCoordinateY = coordinateY;\n    }\n    currentCoordinateY = coordinateY;\n  }\n  drawLineSegment();\n}\nfunction chartDataProcessor(_________________chartData) {\n  const _______________chartOptions = _________________chartData.options;\n  const borderDashLength = _______________chartOptions.borderDash && _______________chartOptions.borderDash.length;\n  if (!_________________chartData._decimated && !_________________chartData._loop && !_______________chartOptions.tension && _______________chartOptions.cubicInterpolationMode !== \"monotone\" && !_______________chartOptions.stepped && !borderDashLength) {\n    return drawLineToCanvas;\n  } else {\n    return animateUsingCanvas;\n  }\n}\nfunction getAnimationHandler(___animationOptions) {\n  if (___animationOptions.stepped) {\n    return __chartUpdateInterval;\n  } else if (___animationOptions.tension || ___animationOptions.cubicInterpolationMode === \"monotone\") {\n    return animationHandler;\n  } else {\n    return _animationStep;\n  }\n}\nfunction currentPath(targetShape, shape, pathOptions, pathShouldClose) {\n  let shapePath = shape._path;\n  if (!shapePath) {\n    shapePath = shape._path = new Path2D();\n    if (shape.path(shapePath, pathOptions, pathShouldClose)) {\n      shapePath.closePath();\n    }\n  }\n  updateCanvasBorderStyles(targetShape, shape.options);\n  targetShape.stroke(shapePath);\n}\nfunction drawSegments(____________canvasContext, _elementOptions, segmentStartIndex, segmentLength) {\n  const {\n    segments: segments,\n    options: ___elementOptions\n  } = _elementOptions;\n  const ____processChartData = chartDataProcessor(_elementOptions);\n  for (const ___rectangle of segments) {\n    updateCanvasBorderStyles(____________canvasContext, ___elementOptions, ___rectangle.style);\n    ____________canvasContext.beginPath();\n    if (____processChartData(____________canvasContext, _elementOptions, ___rectangle, {\n      start: segmentStartIndex,\n      end: segmentStartIndex + segmentLength - 1\n    })) {\n      ____________canvasContext.closePath();\n    }\n    ____________canvasContext.stroke();\n  }\n}\nconst animationContext = typeof Path2D == \"function\";\nfunction animateWithOptions(animationData, ____animationOptions, frameIndex, ___animationState) {\n  if (animationContext && !____animationOptions.options.segment) {\n    currentPath(animationData, ____animationOptions, frameIndex, ___animationState);\n  } else {\n    drawSegments(animationData, ____animationOptions, frameIndex, ___animationState);\n  }\n}\nclass LineAnimationController extends _AnimationController {\n  static id = \"line\";\n  static defaults = {\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: \"default\",\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0\n  };\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  static descriptors = {\n    _scriptable: true,\n    _indexable: propertyType => propertyType !== \"borderDash\" && propertyType !== \"fill\"\n  };\n  constructor(constructorOptions) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (constructorOptions) {\n      Object.assign(this, constructorOptions);\n    }\n  }\n  updateControlPoints(______timestamp, _____animationContext) {\n    const ______________options = this.options;\n    if ((______________options.tension || ______________options.cubicInterpolationMode === \"monotone\") && !______________options.stepped && !this._pointsUpdated) {\n      const spanGapsEnabled = ______________options.spanGaps ? this._loop : this._fullLoop;\n      animationManager(this._points, ______________options, ______timestamp, spanGapsEnabled, _____animationContext);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(newPoints) {\n    this._points = newPoints;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments ||= _animationManager(this, this.options.segment);\n  }\n  first() {\n    const segmentsArray = this.segments;\n    const pointsArray = this.points;\n    return segmentsArray.length && pointsArray[segmentsArray[0].start];\n  }\n  last() {\n    const _segmentsArray = this.segments;\n    const _pointsArray = this.points;\n    const segmentsCount = _segmentsArray.length;\n    return segmentsCount && _pointsArray[_segmentsArray[segmentsCount - 1].end];\n  }\n  interpolate(_timeValue, ____propertyKey) {\n    const ___________________options = this.options;\n    const _______targetValue = _timeValue[____propertyKey];\n    const pointsList = this.points;\n    const animationTasks = animationTaskId(this, {\n      property: ____propertyKey,\n      start: _______targetValue,\n      end: _______targetValue\n    });\n    if (!animationTasks.length) {\n      return;\n    }\n    const interpolatedValues = [];\n    const getAnimationHandlerFunction = getAnimationHandler(___________________options);\n    let ______________currentIndex;\n    let animationTaskCount;\n    ______________currentIndex = 0;\n    animationTaskCount = animationTasks.length;\n    for (; ______________currentIndex < animationTaskCount; ++______________currentIndex) {\n      const {\n        start: length,\n        end: __endIndex\n      } = animationTasks[______________currentIndex];\n      const startValue = pointsList[length];\n      const _endValue = pointsList[__endIndex];\n      if (startValue === _endValue) {\n        interpolatedValues.push(startValue);\n        continue;\n      }\n      const _interpolatedValue = getAnimationHandlerFunction(startValue, _endValue, Math.abs((_______targetValue - startValue[____propertyKey]) / (_endValue[____propertyKey] - startValue[____propertyKey])), ___________________options.stepped);\n      _interpolatedValue[____propertyKey] = _timeValue[____propertyKey];\n      interpolatedValues.push(_interpolatedValue);\n    }\n    if (interpolatedValues.length === 1) {\n      return interpolatedValues[0];\n    } else {\n      return interpolatedValues;\n    }\n  }\n  pathSegment(pathSegmentValue, segmentValue, ____segmentIndex) {\n    return chartDataProcessor(this)(pathSegmentValue, this, segmentValue, ____segmentIndex);\n  }\n  path(_______dataPoint, ________startIndex, _______endIndex) {\n    const segmentsList = this.segments;\n    const chartDataProcessorResult = chartDataProcessor(this);\n    let isLoopActive = this._loop;\n    ________startIndex = ________startIndex || 0;\n    _______endIndex = _______endIndex || this.points.length - ________startIndex;\n    for (const __item of segmentsList) {\n      isLoopActive &= chartDataProcessorResult(_______dataPoint, this, __item, {\n        start: ________startIndex,\n        end: ________startIndex + _______endIndex - 1\n      });\n    }\n    return !!isLoopActive;\n  }\n  draw(____________________canvasContext, _____________________canvasContext, animationDelta, animationSpeed) {\n    const ___optionsConfig = this.options || {};\n    if ((this.points || []).length && ___optionsConfig.borderWidth) {\n      ____________________canvasContext.save();\n      animateWithOptions(____________________canvasContext, this, animationDelta, animationSpeed);\n      ____________________canvasContext.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nfunction isWithinHitRadius(_target, __________inputValue, propKey, propsSource) {\n  const targetOptions = _target.options;\n  const {\n    [propKey]: _targetPropertyValue\n  } = _target.getProps([propKey], propsSource);\n  return Math.abs(__________inputValue - _targetPropertyValue) < targetOptions.radius + targetOptions.hitRadius;\n}\nclass __AnimationController extends _AnimationController {\n  static id = \"point\";\n  parsed;\n  skip;\n  stop;\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: \"circle\",\n    radius: 3,\n    rotation: 0\n  };\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  constructor(optionsObject) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (optionsObject) {\n      Object.assign(this, optionsObject);\n    }\n  }\n  inRange(pointX, _coordinateY, _______________________________________________________________index) {\n    const ____________options = this.options;\n    const {\n      x: pointXCoordinate,\n      y: _pointYCoordinate\n    } = this.getProps([\"x\", \"y\"], _______________________________________________________________index);\n    return Math.pow(pointX - pointXCoordinate, 2) + Math.pow(_coordinateY - _pointYCoordinate, 2) < Math.pow(____________options.hitRadius + ____________options.radius, 2);\n  }\n  inXRange(targetXPosition, _________________event) {\n    return isWithinHitRadius(this, targetXPosition, \"x\", _________________event);\n  }\n  inYRange(_targetPosition, hitRadiusY) {\n    return isWithinHitRadius(this, _targetPosition, \"y\", hitRadiusY);\n  }\n  getCenterPoint(_timeParameter) {\n    const {\n      x: centerPointX,\n      y: centerPointY\n    } = this.getProps([\"x\", \"y\"], _timeParameter);\n    return {\n      x: centerPointX,\n      y: centerPointY\n    };\n  }\n  size(chartSizeOptions) {\n    let effectiveRadius = (chartSizeOptions = chartSizeOptions || this.options || {}).radius || 0;\n    effectiveRadius = Math.max(effectiveRadius, effectiveRadius && chartSizeOptions.hoverRadius || 0);\n    return (effectiveRadius + (effectiveRadius && chartSizeOptions.borderWidth || 0)) * 2;\n  }\n  draw(___________________canvasContext, __________________________event) {\n    const _____________options = this.options;\n    if (!this.skip && !(_____________options.radius < 0.1) && !!chartUpdater(this, __________________________event, this.size(_____________options) / 2)) {\n      ___________________canvasContext.strokeStyle = _____________options.borderColor;\n      ___________________canvasContext.lineWidth = _____________options.borderWidth;\n      ___________________canvasContext.fillStyle = _____________options.backgroundColor;\n      __animationStep(___________________canvasContext, _____________options, this.x, this.y);\n    }\n  }\n  getRange() {\n    const _______options = this.options || {};\n    return _______options.radius + _______options.hitRadius;\n  }\n}\nfunction calculateDiagramBounds(diagram, elevation) {\n  const {\n    x: __xCoordinate,\n    y: _____yCoordinate,\n    base: baseCoordinate,\n    width: diagramWidth,\n    height: __height\n  } = diagram.getProps([\"x\", \"y\", \"base\", \"width\", \"height\"], elevation);\n  let _leftBoundary;\n  let maxCoordinate;\n  let _topBoundary;\n  let bottom;\n  let halfDimension;\n  if (diagram.horizontal) {\n    halfDimension = __height / 2;\n    _leftBoundary = Math.min(__xCoordinate, baseCoordinate);\n    maxCoordinate = Math.max(__xCoordinate, baseCoordinate);\n    _topBoundary = _____yCoordinate - halfDimension;\n    bottom = _____yCoordinate + halfDimension;\n  } else {\n    halfDimension = diagramWidth / 2;\n    _leftBoundary = __xCoordinate - halfDimension;\n    maxCoordinate = __xCoordinate + halfDimension;\n    _topBoundary = Math.min(_____yCoordinate, baseCoordinate);\n    bottom = Math.max(_____yCoordinate, baseCoordinate);\n  }\n  return {\n    left: _leftBoundary,\n    top: _topBoundary,\n    right: maxCoordinate,\n    bottom: bottom\n  };\n}\nfunction isValidAndProcessEvent(_isValid, __________event, ________________________________________index, _____callbackFunction) {\n  if (_isValid) {\n    return 0;\n  } else {\n    return chartAnimationState(__________event, ________________________________________index, _____callbackFunction);\n  }\n}\nfunction calculateBorderAnimation(__chartElement, borderWidthValue, borderAnimationValue) {\n  const borderWidthOption = __chartElement.options.borderWidth;\n  const borderSkippedDirections = __chartElement.borderSkipped;\n  const animationStateResult = animationState(borderWidthOption);\n  return {\n    t: isValidAndProcessEvent(borderSkippedDirections.top, animationStateResult.top, 0, borderAnimationValue),\n    r: isValidAndProcessEvent(borderSkippedDirections.right, animationStateResult.right, 0, borderWidthValue),\n    b: isValidAndProcessEvent(borderSkippedDirections.bottom, animationStateResult.bottom, 0, borderAnimationValue),\n    l: isValidAndProcessEvent(borderSkippedDirections.left, animationStateResult.left, 0, borderWidthValue)\n  };\n}\nfunction calculateBorderRadius(__element, minBorderRadius, minimumBorderRadius) {\n  const {\n    enableBorderRadius: isBorderRadiusEnabled\n  } = __element.getProps([\"enableBorderRadius\"]);\n  const borderRadiusOptions = __element.options.borderRadius;\n  const borderRadiusValues = elementBorderRadius(borderRadiusOptions);\n  const minimumBorderRadiusValue = Math.min(minBorderRadius, minimumBorderRadius);\n  const borderSkipped = __element.borderSkipped;\n  const _isBorderRadiusEnabled = isBorderRadiusEnabled || currentAnimationIndex(borderRadiusOptions);\n  return {\n    topLeft: isValidAndProcessEvent(!_isBorderRadiusEnabled || borderSkipped.top || borderSkipped.left, borderRadiusValues.topLeft, 0, minimumBorderRadiusValue),\n    topRight: isValidAndProcessEvent(!_isBorderRadiusEnabled || borderSkipped.top || borderSkipped.right, borderRadiusValues.topRight, 0, minimumBorderRadiusValue),\n    bottomLeft: isValidAndProcessEvent(!_isBorderRadiusEnabled || borderSkipped.bottom || borderSkipped.left, borderRadiusValues.bottomLeft, 0, minimumBorderRadiusValue),\n    bottomRight: isValidAndProcessEvent(!_isBorderRadiusEnabled || borderSkipped.bottom || borderSkipped.right, borderRadiusValues.bottomRight, 0, minimumBorderRadiusValue)\n  };\n}\nfunction borderAnimation(inputElement) {\n  const diagramBounds = calculateDiagramBounds(inputElement);\n  const ___borderWidth = diagramBounds.right - diagramBounds.left;\n  const borderHeight = diagramBounds.bottom - diagramBounds.top;\n  const borderAnimationOffsets = calculateBorderAnimation(inputElement, ___borderWidth / 2, borderHeight / 2);\n  const _borderRadius = calculateBorderRadius(inputElement, ___borderWidth / 2, borderHeight / 2);\n  return {\n    outer: {\n      x: diagramBounds.left,\n      y: diagramBounds.top,\n      w: ___borderWidth,\n      h: borderHeight,\n      radius: _borderRadius\n    },\n    inner: {\n      x: diagramBounds.left + borderAnimationOffsets.l,\n      y: diagramBounds.top + borderAnimationOffsets.t,\n      w: ___borderWidth - borderAnimationOffsets.l - borderAnimationOffsets.r,\n      h: borderHeight - borderAnimationOffsets.t - borderAnimationOffsets.b,\n      radius: {\n        topLeft: Math.max(0, _borderRadius.topLeft - Math.max(borderAnimationOffsets.t, borderAnimationOffsets.l)),\n        topRight: Math.max(0, _borderRadius.topRight - Math.max(borderAnimationOffsets.t, borderAnimationOffsets.r)),\n        bottomLeft: Math.max(0, _borderRadius.bottomLeft - Math.max(borderAnimationOffsets.b, borderAnimationOffsets.l)),\n        bottomRight: Math.max(0, _borderRadius.bottomRight - Math.max(borderAnimationOffsets.b, borderAnimationOffsets.r))\n      }\n    }\n  };\n}\nfunction isAnimationRequired(___targetElement, ____element, _animationElement, __animationSettings) {\n  const isElementNull = ____element === null;\n  const isAnimationElementNull = _animationElement === null;\n  const __isAnimationActive = ___targetElement && (!isElementNull || !isAnimationElementNull) && calculateDiagramBounds(___targetElement, __animationSettings);\n  return __isAnimationActive && (isElementNull || animationRequestId(____element, __isAnimationActive.left, __isAnimationActive.right)) && (isAnimationElementNull || animationRequestId(_animationElement, __isAnimationActive.top, __isAnimationActive.bottom));\n}\nfunction getCornerValues(cornerCoordinates) {\n  return cornerCoordinates.topLeft || cornerCoordinates.topRight || cornerCoordinates.bottomLeft || cornerCoordinates.bottomRight;\n}\nfunction drawRectangle(________________canvasContext, rectangleCoordinates) {\n  ________________canvasContext.rect(rectangleCoordinates.x, rectangleCoordinates.y, rectangleCoordinates.w, rectangleCoordinates.h);\n}\nfunction adjustRectanglePosition(currentRectangle, offset, inputRectangle = {}) {\n  const horizontalOffset = currentRectangle.x !== inputRectangle.x ? -offset : 0;\n  const _verticalOffset = currentRectangle.y !== inputRectangle.y ? -offset : 0;\n  const widthAdjustment = (currentRectangle.x + currentRectangle.w !== inputRectangle.x + inputRectangle.w ? offset : 0) - horizontalOffset;\n  const _heightAdjustment = (currentRectangle.y + currentRectangle.h !== inputRectangle.y + inputRectangle.h ? offset : 0) - _verticalOffset;\n  return {\n    x: currentRectangle.x + horizontalOffset,\n    y: currentRectangle.y + _verticalOffset,\n    w: currentRectangle.w + widthAdjustment,\n    h: currentRectangle.h + _heightAdjustment,\n    radius: currentRectangle.radius\n  };\n}\nclass BarAnimationController extends _AnimationController {\n  static id = \"bar\";\n  static defaults = {\n    borderSkipped: \"start\",\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: \"auto\",\n    pointStyle: undefined\n  };\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  constructor(optionsInput) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (optionsInput) {\n      Object.assign(this, optionsInput);\n    }\n  }\n  draw(__________________________canvasContext) {\n    const {\n      inflateAmount: inflateAmount,\n      options: {\n        borderColor: borderColor,\n        backgroundColor: ___backgroundColor\n      }\n    } = this;\n    const {\n      inner: borderInnerDimensions,\n      outer: outerBorder\n    } = borderAnimation(this);\n    const drawFunction = getCornerValues(outerBorder.radius) ? ___animationController : drawRectangle;\n    __________________________canvasContext.save();\n    if (outerBorder.w !== borderInnerDimensions.w || outerBorder.h !== borderInnerDimensions.h) {\n      __________________________canvasContext.beginPath();\n      drawFunction(__________________________canvasContext, adjustRectanglePosition(outerBorder, inflateAmount, borderInnerDimensions));\n      __________________________canvasContext.clip();\n      drawFunction(__________________________canvasContext, adjustRectanglePosition(borderInnerDimensions, -inflateAmount, outerBorder));\n      __________________________canvasContext.fillStyle = borderColor;\n      __________________________canvasContext.fill(\"evenodd\");\n    }\n    __________________________canvasContext.beginPath();\n    drawFunction(__________________________canvasContext, adjustRectanglePosition(borderInnerDimensions, inflateAmount));\n    __________________________canvasContext.fillStyle = ___backgroundColor;\n    __________________________canvasContext.fill();\n    __________________________canvasContext.restore();\n  }\n  inRange(_____targetValue, endRangeValue, _________________________________________________________index) {\n    return isAnimationRequired(this, _____targetValue, endRangeValue, _________________________________________________________index);\n  }\n  inXRange(__inputParameter, ______callbackFunction) {\n    return isAnimationRequired(this, __inputParameter, null, ______callbackFunction);\n  }\n  inYRange(valueToCheck, checkRange) {\n    return isAnimationRequired(this, null, valueToCheck, checkRange);\n  }\n  getCenterPoint(targetProps) {\n    const {\n      x: ___centerX,\n      y: ____yCoordinate,\n      base: _baseValue,\n      horizontal: _isHorizontal\n    } = this.getProps([\"x\", \"y\", \"base\", \"horizontal\"], targetProps);\n    return {\n      x: _isHorizontal ? (___centerX + _baseValue) / 2 : ___centerX,\n      y: _isHorizontal ? ____yCoordinate : (____yCoordinate + _baseValue) / 2\n    };\n  }\n  getRange(axis) {\n    if (axis === \"x\") {\n      return this.width / 2;\n    } else {\n      return this.height / 2;\n    }\n  }\n}\nvar Hn = Object.freeze({\n  __proto__: null,\n  ArcElement: mn,\n  BarElement: BarAnimationController,\n  LineElement: LineAnimationController,\n  PointElement: __AnimationController\n});\nconst chartAnimationContext = [\"rgb(54, 162, 235)\", \"rgb(255, 99, 132)\", \"rgb(255, 159, 64)\", \"rgb(255, 205, 86)\", \"rgb(75, 192, 192)\", \"rgb(153, 102, 255)\", \"rgb(201, 203, 207)\"];\nconst ______requestAnimationFrameId = chartAnimationContext.map(rgbToRgbaWithOpacity => rgbToRgbaWithOpacity.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\nfunction getChartAnimationContext(__animationIndex) {\n  return chartAnimationContext[__animationIndex % chartAnimationContext.length];\n}\nfunction getRequestAnimationFrameId(__________________________________________________index) {\n  return ______requestAnimationFrameId[__________________________________________________index % ______requestAnimationFrameId.length];\n}\nfunction updateElementStyles(_elementStyles, iterationCount) {\n  _elementStyles.borderColor = getChartAnimationContext(iterationCount);\n  _elementStyles.backgroundColor = getRequestAnimationFrameId(iterationCount);\n  return ++iterationCount;\n}\nfunction setElementBackgroundColor(_________element, colorIndex) {\n  _________element.backgroundColor = _________element.data.map(() => getChartAnimationContext(colorIndex++));\n  return colorIndex;\n}\nfunction colorFrameId(dataContainer, _colorIndex) {\n  dataContainer.backgroundColor = dataContainer.data.map(() => getRequestAnimationFrameId(_colorIndex++));\n  return _colorIndex;\n}\nfunction updateChartStyles(chartDataset) {\n  let elementStyleIndex = 0;\n  return (________elementIndex, _______________________________________datasetIndex) => {\n    const ___chartController = chartDataset.getDatasetMeta(_______________________________________datasetIndex).controller;\n    if (___chartController instanceof $e) {\n      elementStyleIndex = setElementBackgroundColor(________elementIndex, elementStyleIndex);\n    } else if (___chartController instanceof Ye) {\n      elementStyleIndex = colorFrameId(________elementIndex, elementStyleIndex);\n    } else if (___chartController) {\n      elementStyleIndex = updateElementStyles(________elementIndex, elementStyleIndex);\n    }\n  };\n}\nfunction hasBorderOrBackgroundColor(__styleProperties) {\n  let stylePropertyKey;\n  for (stylePropertyKey in __styleProperties) {\n    if (__styleProperties[stylePropertyKey].borderColor || __styleProperties[stylePropertyKey].backgroundColor) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getBorderOrBackgroundColor(colorProperties) {\n  return colorProperties && (colorProperties.borderColor || colorProperties.backgroundColor);\n}\nvar _animationTaskId = {\n  id: \"colors\",\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  },\n  beforeLayout(________chartInstance, layoutContext, layoutOptions) {\n    if (!layoutOptions.enabled) {\n      return;\n    }\n    const {\n      data: {\n        datasets: datasetsArray\n      },\n      options: __chartOptions\n    } = ________chartInstance.config;\n    const {\n      elements: elementStyles\n    } = __chartOptions;\n    if (!layoutOptions.forceOverride && (hasBorderOrBackgroundColor(datasetsArray) || getBorderOrBackgroundColor(__chartOptions) || elementStyles && hasBorderOrBackgroundColor(elementStyles))) {\n      return;\n    }\n    const datasetProcessingFunction = updateChartStyles(________chartInstance);\n    datasetsArray.forEach(datasetProcessingFunction);\n  }\n};\nfunction extractSamples(_dataPoints, _startIndex, numSamples, samplesOrDefault, inputParameters) {\n  const _sampleCount = inputParameters.samples || samplesOrDefault;\n  if (_sampleCount >= numSamples) {\n    return _dataPoints.slice(_startIndex, _startIndex + numSamples);\n  }\n  const sampleExtractedPoints = [];\n  const sampleRatio = (numSamples - 2) / (_sampleCount - 2);\n  let outputIndex = 0;\n  const ____lastIndex = _startIndex + numSamples - 1;\n  let currentSampleIndex;\n  let closestDataPoint;\n  let maxArea;\n  let _maxArea;\n  let _currentSampleIndex;\n  let __currentSampleIndex = _startIndex;\n  sampleExtractedPoints[outputIndex++] = _dataPoints[__currentSampleIndex];\n  currentSampleIndex = 0;\n  for (; currentSampleIndex < _sampleCount - 2; currentSampleIndex++) {\n    let startSampleIndex;\n    let sumXValues = 0;\n    let sumY = 0;\n    const __startIndex = Math.floor((currentSampleIndex + 1) * sampleRatio) + 1 + _startIndex;\n    const _currentSampleEndIndex = Math.min(Math.floor((currentSampleIndex + 2) * sampleRatio) + 1, numSamples) + _startIndex;\n    const sampleCount = _currentSampleEndIndex - __startIndex;\n    for (startSampleIndex = __startIndex; startSampleIndex < _currentSampleEndIndex; startSampleIndex++) {\n      sumXValues += _dataPoints[startSampleIndex].x;\n      sumY += _dataPoints[startSampleIndex].y;\n    }\n    sumXValues /= sampleCount;\n    sumY /= sampleCount;\n    const startIndexAdjusted = Math.floor(currentSampleIndex * sampleRatio) + 1 + _startIndex;\n    const currentSampleEndIndex = Math.min(Math.floor((currentSampleIndex + 1) * sampleRatio) + 1, numSamples) + _startIndex;\n    const {\n      x: yCoordinate,\n      y: pointYValue\n    } = _dataPoints[__currentSampleIndex];\n    maxArea = _maxArea = -1;\n    startSampleIndex = startIndexAdjusted;\n    for (; startSampleIndex < currentSampleEndIndex; startSampleIndex++) {\n      _maxArea = Math.abs((yCoordinate - sumXValues) * (_dataPoints[startSampleIndex].y - pointYValue) - (yCoordinate - _dataPoints[startSampleIndex].x) * (sumY - pointYValue)) * 0.5;\n      if (_maxArea > maxArea) {\n        maxArea = _maxArea;\n        closestDataPoint = _dataPoints[startSampleIndex];\n        _currentSampleIndex = startSampleIndex;\n      }\n    }\n    sampleExtractedPoints[outputIndex++] = closestDataPoint;\n    __currentSampleIndex = _currentSampleIndex;\n  }\n  sampleExtractedPoints[outputIndex++] = _dataPoints[____lastIndex];\n  return sampleExtractedPoints;\n}\nfunction processDataPoints(dataPoints, currentIndex, rangeIndex, scaleFactor) {\n  let currentDataPointIndex;\n  let ___currentDataPoint;\n  let normalizedDataPointPosition;\n  let currentYValue;\n  let _resultingValue;\n  let lastValidIndex;\n  let maxIndexInRange;\n  let lastProcessedIndex;\n  let currentLowestYValue;\n  let maxYValue;\n  let averageXCoordinate = 0;\n  let countValidDataPoints = 0;\n  const processedDataPoints = [];\n  const lastIndexInRange = currentIndex + rangeIndex - 1;\n  const currentDataPointX = dataPoints[currentIndex].x;\n  const deltaX = dataPoints[lastIndexInRange].x - currentDataPointX;\n  for (currentDataPointIndex = currentIndex; currentDataPointIndex < currentIndex + rangeIndex; ++currentDataPointIndex) {\n    ___currentDataPoint = dataPoints[currentDataPointIndex];\n    normalizedDataPointPosition = (___currentDataPoint.x - currentDataPointX) / deltaX * scaleFactor;\n    currentYValue = ___currentDataPoint.y;\n    const resultingValue = normalizedDataPointPosition | 0;\n    if (resultingValue === _resultingValue) {\n      if (currentYValue < currentLowestYValue) {\n        currentLowestYValue = currentYValue;\n        lastValidIndex = currentDataPointIndex;\n      } else if (currentYValue > maxYValue) {\n        maxYValue = currentYValue;\n        maxIndexInRange = currentDataPointIndex;\n      }\n      averageXCoordinate = (countValidDataPoints * averageXCoordinate + ___currentDataPoint.x) / ++countValidDataPoints;\n    } else {\n      const previousIndex = currentDataPointIndex - 1;\n      if (!chartUpdateInterval(lastValidIndex) && !chartUpdateInterval(maxIndexInRange)) {\n        const currentYCoordinate = Math.min(lastValidIndex, maxIndexInRange);\n        const maxIndex = Math.max(lastValidIndex, maxIndexInRange);\n        if (currentYCoordinate !== lastProcessedIndex && currentYCoordinate !== previousIndex) {\n          processedDataPoints.push({\n            ...dataPoints[currentYCoordinate],\n            x: averageXCoordinate\n          });\n        }\n        if (maxIndex !== lastProcessedIndex && maxIndex !== previousIndex) {\n          processedDataPoints.push({\n            ...dataPoints[maxIndex],\n            x: averageXCoordinate\n          });\n        }\n      }\n      if (currentDataPointIndex > 0 && previousIndex !== lastProcessedIndex) {\n        processedDataPoints.push(dataPoints[previousIndex]);\n      }\n      processedDataPoints.push(___currentDataPoint);\n      _resultingValue = resultingValue;\n      countValidDataPoints = 0;\n      currentLowestYValue = maxYValue = currentYValue;\n      lastValidIndex = maxIndexInRange = lastProcessedIndex = currentDataPointIndex;\n    }\n  }\n  return processedDataPoints;\n}\nfunction processIo(ioObject) {\n  if (ioObject._decimated) {\n    const _decimatedData = ioObject._data;\n    delete ioObject._decimated;\n    delete ioObject._data;\n    Object.defineProperty(ioObject, \"data\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: _decimatedData\n    });\n  }\n}\nfunction processDatasetItem(datasetItem) {\n  datasetItem.data.datasets.forEach(ioData => {\n    processIo(ioData);\n  });\n}\nfunction calculateNotificationRange(userScale, notificationList) {\n  const notificationCount = notificationList.length;\n  let _notificationCount;\n  let notificationStartIndex = 0;\n  const {\n    iScale: userScaleDetails\n  } = userScale;\n  const {\n    min: ________minValue,\n    max: maxUserBound,\n    minDefined: ___isMinDefined,\n    maxDefined: _isMaxDefined\n  } = userScaleDetails.getUserBounds();\n  if (___isMinDefined) {\n    notificationStartIndex = chartAnimationState(notificationFunction(notificationList, userScaleDetails.axis, ________minValue).lo, 0, notificationCount - 1);\n  }\n  if (_isMaxDefined) {\n    _notificationCount = chartAnimationState(notificationFunction(notificationList, userScaleDetails.axis, maxUserBound).hi + 1, notificationStartIndex, notificationCount) - notificationStartIndex;\n  } else {\n    _notificationCount = notificationCount - notificationStartIndex;\n  }\n  return {\n    start: notificationStartIndex,\n    count: _notificationCount\n  };\n}\nvar ___isChartAnimationRunning = {\n  id: \"decimation\",\n  defaults: {\n    algorithm: \"min-max\",\n    enabled: false\n  },\n  beforeElementsUpdate: (__chartInstance, dataset, decimationSettings) => {\n    if (!decimationSettings.enabled) {\n      processDatasetItem(__chartInstance);\n      return;\n    }\n    const chartWidth = __chartInstance.width;\n    __chartInstance.data.datasets.forEach((__chartData, datasetMeta) => {\n      const {\n        _data: inputData,\n        indexAxis: indexAxis\n      } = __chartData;\n      const _datasetMeta = __chartInstance.getDatasetMeta(datasetMeta);\n      const _inputData = inputData || __chartData.data;\n      if (animationOptions([indexAxis, __chartInstance.options.indexAxis]) === \"y\") {\n        return;\n      }\n      if (!_datasetMeta.controller.supportsDecimation) {\n        return;\n      }\n      const xAxisScale = __chartInstance.scales[_datasetMeta.xAxisID];\n      if (xAxisScale.type !== \"linear\" && xAxisScale.type !== \"time\") {\n        return;\n      }\n      if (__chartInstance.options.parsing) {\n        return;\n      }\n      let {\n        start: startIndex,\n        count: decimatedCount\n      } = calculateNotificationRange(_datasetMeta, _inputData);\n      if (decimatedCount <= (decimationSettings.threshold || chartWidth * 4)) {\n        processIo(__chartData);\n        return;\n      }\n      let decimatedData;\n      if (chartUpdateInterval(inputData)) {\n        __chartData._data = _inputData;\n        delete __chartData.data;\n        Object.defineProperty(__chartData, \"data\", {\n          configurable: true,\n          enumerable: true,\n          get: function () {\n            return this._decimated;\n          },\n          set: function (______inputData) {\n            this._data = ______inputData;\n          }\n        });\n      }\n      switch (decimationSettings.algorithm) {\n        case \"lttb\":\n          decimatedData = extractSamples(_inputData, startIndex, decimatedCount, chartWidth, decimationSettings);\n          break;\n        case \"min-max\":\n          decimatedData = processDataPoints(_inputData, startIndex, decimatedCount, chartWidth);\n          break;\n        default:\n          throw new Error(`Unsupported decimation algorithm '${decimationSettings.algorithm}'`);\n      }\n      __chartData._decimated = decimatedData;\n    });\n  },\n  destroy(____target) {\n    processDatasetItem(____target);\n  }\n};\nfunction mapAnimationSegmentsToTargets(animationSegments, targetSegments, currentSegmentIndex) {\n  const animationSegmentsList = animationSegments.segments;\n  const animationPoints = animationSegments.points;\n  const targetPoints = targetSegments.points;\n  const mappedAnimationTargets = [];\n  for (const __animationTask of animationSegmentsList) {\n    let {\n      start: segment,\n      end: endSegment\n    } = __animationTask;\n    endSegment = findLastValidPointIndex(segment, endSegment, animationPoints);\n    const targetSegmentMapping = getAnimationProperty(currentSegmentIndex, animationPoints[segment], animationPoints[endSegment], __animationTask.loop);\n    if (!targetSegments.segments) {\n      mappedAnimationTargets.push({\n        source: __animationTask,\n        target: targetSegmentMapping,\n        start: animationPoints[segment],\n        end: animationPoints[endSegment]\n      });\n      continue;\n    }\n    const targetSegmentsList = animationTaskId(targetSegments, targetSegmentMapping);\n    for (const _segment of targetSegmentsList) {\n      const geometryData = getAnimationProperty(currentSegmentIndex, targetPoints[_segment.start], targetPoints[_segment.end], _segment.loop);\n      const requestAnimationFrameResult = _requestAnimationFrame(__animationTask, animationPoints, geometryData);\n      for (const animationFrameResultItem of requestAnimationFrameResult) {\n        mappedAnimationTargets.push({\n          source: animationFrameResultItem,\n          target: _segment,\n          start: {\n            [currentSegmentIndex]: arrayElementRetriever(targetSegmentMapping, geometryData, \"start\", Math.max)\n          },\n          end: {\n            [currentSegmentIndex]: arrayElementRetriever(targetSegmentMapping, geometryData, \"end\", Math.min)\n          }\n        });\n      }\n    }\n  }\n  return mappedAnimationTargets;\n}\nfunction getAnimationProperty(propertyKey, propertyValue, __endValue, isAnimationEnabled) {\n  if (isAnimationEnabled) {\n    return;\n  }\n  let ____startValue = propertyValue[propertyKey];\n  let _____endValue = __endValue[propertyKey];\n  if (propertyKey === \"angle\") {\n    ____startValue = animationRefreshRate(____startValue);\n    _____endValue = animationRefreshRate(_____endValue);\n  }\n  return {\n    property: propertyKey,\n    start: ____startValue,\n    end: _____endValue\n  };\n}\nfunction coordinateOutput(coordinateOptions, _pathData) {\n  const {\n    x: fixedXCoordinate = null,\n    y: ______yCoordinate = null\n  } = coordinateOptions || {};\n  const pathDataPoints = _pathData.points;\n  const outputCoordinates = [];\n  _pathData.segments.forEach(({\n    start: startCoordinate,\n    end: endValue\n  }) => {\n    endValue = findLastValidPointIndex(startCoordinate, endValue, pathDataPoints);\n    const __startPoint = pathDataPoints[startCoordinate];\n    const _endCoordinate = pathDataPoints[endValue];\n    if (______yCoordinate !== null) {\n      outputCoordinates.push({\n        x: __startPoint.x,\n        y: ______yCoordinate\n      });\n      outputCoordinates.push({\n        x: _endCoordinate.x,\n        y: ______yCoordinate\n      });\n    } else if (fixedXCoordinate !== null) {\n      outputCoordinates.push({\n        x: fixedXCoordinate,\n        y: __startPoint.y\n      });\n      outputCoordinates.push({\n        x: fixedXCoordinate,\n        y: _endCoordinate.y\n      });\n    }\n  });\n  return outputCoordinates;\n}\nfunction findLastValidPointIndex(indexOfValidPoint, ___endIndex, __________________________index) {\n  for (; ___endIndex > indexOfValidPoint; ___endIndex--) {\n    const pointAtEndIndex = __________________________index[___endIndex];\n    if (!isNaN(pointAtEndIndex.x) && !isNaN(pointAtEndIndex.y)) {\n      break;\n    }\n  }\n  return ___endIndex;\n}\nfunction arrayElementRetriever(_sourceArray, ___dataArray, ___________________index, ____callbackFunction) {\n  if (_sourceArray && ___dataArray) {\n    return ____callbackFunction(_sourceArray[___________________index], ___dataArray[___________________index]);\n  } else if (_sourceArray) {\n    return _sourceArray[___________________index];\n  } else if (___dataArray) {\n    return ___dataArray[___________________index];\n  } else {\n    return 0;\n  }\n}\nfunction createChartPoints(______________chartData, _______________chartData) {\n  let chartPoints = [];\n  let isAnimated = false;\n  if (animatedChartItems(______________chartData)) {\n    isAnimated = true;\n    chartPoints = ______________chartData;\n  } else {\n    chartPoints = coordinateOutput(______________chartData, _______________chartData);\n  }\n  if (chartPoints.length) {\n    return new LineAnimationController({\n      points: chartPoints,\n      options: {\n        tension: 0\n      },\n      _loop: isAnimated,\n      _fullLoop: isAnimated\n    });\n  } else {\n    return null;\n  }\n}\nfunction shouldFill(isFillEnabled) {\n  return isFillEnabled && isFillEnabled.fill !== false;\n}\nfunction getFillColor(dataSet, fillColorKey, filledChartIndex) {\n  let currentFillColor = dataSet[fillColorKey].fill;\n  const visitedFillColors = [fillColorKey];\n  let currentChartObject;\n  if (!filledChartIndex) {\n    return currentFillColor;\n  }\n  while (currentFillColor !== false && visitedFillColors.indexOf(currentFillColor) === -1) {\n    if (!chartUpdateTrigger(currentFillColor)) {\n      return currentFillColor;\n    }\n    currentChartObject = dataSet[currentFillColor];\n    if (!currentChartObject) {\n      return false;\n    }\n    if (currentChartObject.visible) {\n      return currentFillColor;\n    }\n    visitedFillColors.push(currentFillColor);\n    currentFillColor = currentChartObject.fill;\n  }\n  return false;\n}\nfunction chartAnimationHandler(_inputValue, _animationState, chartIndex) {\n  const chartAnimationOrigin = getChartAnimationOrigin(_inputValue);\n  if (currentAnimationIndex(chartAnimationOrigin)) {\n    return !isNaN(chartAnimationOrigin.value) && chartAnimationOrigin;\n  }\n  let parsedAnimationOrigin = parseFloat(chartAnimationOrigin);\n  if (chartUpdateTrigger(parsedAnimationOrigin) && Math.floor(parsedAnimationOrigin) === parsedAnimationOrigin) {\n    return operationResult(chartAnimationOrigin[0], _animationState, parsedAnimationOrigin, chartIndex);\n  } else {\n    return [\"origin\", \"start\", \"end\", \"stack\", \"shape\"].indexOf(chartAnimationOrigin) >= 0 && chartAnimationOrigin;\n  }\n}\nfunction operationResult(operationSign, __currentValue, result, maxValue) {\n  if (operationSign === \"-\" || operationSign === \"+\") {\n    result = __currentValue + result;\n  }\n  return result !== __currentValue && !(result < 0) && !(result >= maxValue) && result;\n}\nfunction animationPixelValue(__animationPosition, coordinateSystem) {\n  let _animationPixelValue = null;\n  if (__animationPosition === \"start\") {\n    _animationPixelValue = coordinateSystem.bottom;\n  } else if (__animationPosition === \"end\") {\n    _animationPixelValue = coordinateSystem.top;\n  } else if (currentAnimationIndex(__animationPosition)) {\n    _animationPixelValue = coordinateSystem.getPixelForValue(__animationPosition.value);\n  } else if (coordinateSystem.getBasePixel) {\n    _animationPixelValue = coordinateSystem.getBasePixel();\n  }\n  return _animationPixelValue;\n}\nfunction calculateAnimationValue(__animationState, __animationOptions, _inputParameter) {\n  let animatedValue;\n  if (__animationState === \"start\") {\n    animatedValue = _inputParameter;\n  } else if (__animationState === \"end\") {\n    if (__animationOptions.options.reverse) {\n      animatedValue = __animationOptions.min;\n    } else {\n      animatedValue = __animationOptions.max;\n    }\n  } else if (currentAnimationIndex(__animationState)) {\n    animatedValue = __animationState.value;\n  } else {\n    animatedValue = __animationOptions.getBaseValue();\n  }\n  return animatedValue;\n}\nfunction getChartAnimationOrigin(____chartOptions) {\n  const _________chartOptions = ____chartOptions.options;\n  const chartFillOptions = _________chartOptions.fill;\n  let isAnimationOriginDefined = chartAnimationRunning(chartFillOptions && chartFillOptions.target, chartFillOptions);\n  if (isAnimationOriginDefined === undefined) {\n    isAnimationOriginDefined = !!_________chartOptions.backgroundColor;\n  }\n  return isAnimationOriginDefined !== false && isAnimationOriginDefined !== null && (isAnimationOriginDefined === true ? \"origin\" : isAnimationOriginDefined);\n}\nfunction _processInputData(___inputData) {\n  const {\n    scale: ___scaleValue,\n    index: ________________________dataIndex,\n    line: lineData\n  } = ___inputData;\n  const interpolatedPoints = [];\n  const _lineSegments = lineData.segments;\n  const __pointsArray = lineData.points;\n  const visibleMetaData = getVisibleMetaDatasUntilIndex(___scaleValue, ________________________dataIndex);\n  visibleMetaData.push(createChartPoints({\n    x: null,\n    y: ___scaleValue.bottom\n  }, lineData));\n  for (let _____________________________________currentIndex = 0; _____________________________________currentIndex < _lineSegments.length; _____________________________________currentIndex++) {\n    const ____currentItem = _lineSegments[_____________________________________currentIndex];\n    for (let ____________________________________currentIndex = ____currentItem.start; ____________________________________currentIndex <= ____currentItem.end; ____________________________________currentIndex++) {\n      processInterpolation(interpolatedPoints, __pointsArray[____________________________________currentIndex], visibleMetaData);\n    }\n  }\n  return new LineAnimationController({\n    points: interpolatedPoints,\n    options: {}\n  });\n}\nfunction getVisibleMetaDatasUntilIndex(targetMetaIndex, _________________currentIndex) {\n  const visibleMetaDatas = [];\n  const matchingVisibleMetas = targetMetaIndex.getMatchingVisibleMetas(\"line\");\n  for (let currentMetaIndex = 0; currentMetaIndex < matchingVisibleMetas.length; currentMetaIndex++) {\n    const _____currentElement = matchingVisibleMetas[currentMetaIndex];\n    if (_____currentElement.index === _________________currentIndex) {\n      break;\n    }\n    if (!_____currentElement.hidden) {\n      visibleMetaDatas.unshift(_____currentElement.dataset);\n    }\n  }\n  return visibleMetaDatas;\n}\nfunction processInterpolation(_outputArray, externalParameter, ___inputArray) {\n  const pointsToPrepend = [];\n  for (let ____________________________________________________currentIndex = 0; ____________________________________________________currentIndex < ___inputArray.length; ____________________________________________________currentIndex++) {\n    const currentItem = ___inputArray[____________________________________________________currentIndex];\n    const {\n      first: firstName,\n      last: lastName,\n      point: pointValue\n    } = interpolationCheck(currentItem, externalParameter, \"x\");\n    if (!!pointValue && (!firstName || !lastName)) {\n      if (firstName) {\n        pointsToPrepend.unshift(pointValue);\n      } else {\n        _outputArray.push(pointValue);\n        if (!lastName) {\n          break;\n        }\n      }\n    }\n  }\n  _outputArray.push(...pointsToPrepend);\n}\nfunction interpolationCheck(interpolator, interpolatedValue, interpolationIndex) {\n  const interpolatedResult = interpolator.interpolate(interpolatedValue, interpolationIndex);\n  if (!interpolatedResult) {\n    return {};\n  }\n  const interpolatedPointValue = interpolatedResult[interpolationIndex];\n  const interpolatorSegments = interpolator.segments;\n  const interpolatorPoints = interpolator.points;\n  let isStartValue = false;\n  let isEndInterpolationValue = false;\n  for (let _currentSegmentIndex = 0; _currentSegmentIndex < interpolatorSegments.length; _currentSegmentIndex++) {\n    const currentAnimationFrame = interpolatorSegments[_currentSegmentIndex];\n    const __startValue = interpolatorPoints[currentAnimationFrame.start][interpolationIndex];\n    const endInterpolationValue = interpolatorPoints[currentAnimationFrame.end][interpolationIndex];\n    if (animationRequestId(interpolatedPointValue, __startValue, endInterpolationValue)) {\n      isStartValue = interpolatedPointValue === __startValue;\n      isEndInterpolationValue = interpolatedPointValue === endInterpolationValue;\n      break;\n    }\n  }\n  return {\n    first: isStartValue,\n    last: isEndInterpolationValue,\n    point: interpolatedResult\n  };\n}\nclass Circle {\n  constructor(circleProperties) {\n    this.x = circleProperties.x;\n    this.y = circleProperties.y;\n    this.radius = circleProperties.radius;\n  }\n  pathSegment(arcContext, arcAnimationFrame, isBoundsUndefined) {\n    const {\n      x: __centerX,\n      y: _centerY,\n      radius: arcRadius\n    } = this;\n    arcAnimationFrame = arcAnimationFrame || {\n      start: 0,\n      end: lastAnimationUpdateTimestamp\n    };\n    arcContext.arc(__centerX, _centerY, arcRadius, arcAnimationFrame.end, arcAnimationFrame.start, true);\n    return !isBoundsUndefined.bounds;\n  }\n  interpolate(angleParameter) {\n    const {\n      x: _centerX,\n      y: centerY,\n      radius: ___radius\n    } = this;\n    const _angleValue = angleParameter.angle;\n    return {\n      x: _centerX + Math.cos(_angleValue) * ___radius,\n      y: centerY + Math.sin(_angleValue) * ___radius,\n      angle: _angleValue\n    };\n  }\n}\nfunction processChartConfig(____chartConfig) {\n  const {\n    chart: __________chartConfig,\n    fill: _fillColor,\n    line: lineConfig\n  } = ____chartConfig;\n  if (chartUpdateTrigger(_fillColor)) {\n    return getDataset(__________chartConfig, _fillColor);\n  }\n  if (_fillColor === \"stack\") {\n    return _processInputData(____chartConfig);\n  }\n  if (_fillColor === \"shape\") {\n    return true;\n  }\n  const _processedChartData = ___processChartData(____chartConfig);\n  if (_processedChartData instanceof Circle) {\n    return _processedChartData;\n  } else {\n    return createChartPoints(_processedChartData, lineConfig);\n  }\n}\nfunction getDataset(________________chartInstance, _____________________datasetIndex) {\n  const ___________datasetMeta = ________________chartInstance.getDatasetMeta(_____________________datasetIndex);\n  if (___________datasetMeta && ________________chartInstance.isDatasetVisible(_____________________datasetIndex)) {\n    return ___________datasetMeta.dataset;\n  } else {\n    return null;\n  }\n}\nfunction ___processChartData(________________________chartData) {\n  if ((________________________chartData.scale || {}).getPointPositionForValue) {\n    return animationPointsGenerator(________________________chartData);\n  } else {\n    return createChartCoordinates(________________________chartData);\n  }\n}\nfunction createChartCoordinates(____________________chartData) {\n  const {\n    scale: scaleConfig = {},\n    fill: fillColor\n  } = ____________________chartData;\n  const animationPixelCoordinate = animationPixelValue(fillColor, scaleConfig);\n  if (chartUpdateTrigger(animationPixelCoordinate)) {\n    const isHorizontalScale = scaleConfig.isHorizontal();\n    return {\n      x: isHorizontalScale ? animationPixelCoordinate : null,\n      y: isHorizontalScale ? null : animationPixelCoordinate\n    };\n  }\n  return null;\n}\nfunction animationPointsGenerator(config) {\n  const {\n    scale: __scaleConfig,\n    fill: __fillColor\n  } = config;\n  const __________animationOptions = __scaleConfig.options;\n  const __labelCount = __scaleConfig.getLabels().length;\n  const minOrMaxValue = __________animationOptions.reverse ? __scaleConfig.max : __scaleConfig.min;\n  const ___animationValue = calculateAnimationValue(__fillColor, __scaleConfig, minOrMaxValue);\n  const _animationPoints = [];\n  if (__________animationOptions.grid.circular) {\n    const pointPositionForZero = __scaleConfig.getPointPositionForValue(0, minOrMaxValue);\n    return new Circle({\n      x: pointPositionForZero.x,\n      y: pointPositionForZero.y,\n      radius: __scaleConfig.getDistanceFromCenterForValue(___animationValue)\n    });\n  }\n  for (let __________________________________________________________currentIndex = 0; __________________________________________________________currentIndex < __labelCount; ++__________________________________________________________currentIndex) {\n    _animationPoints.push(__scaleConfig.getPointPositionForValue(__________________________________________________________currentIndex, ___animationValue));\n  }\n  return _animationPoints;\n}\nfunction _____processChartData(targetValue, ___chartConfig, area) {\n  const processedChartConfig = processChartConfig(___chartConfig);\n  const {\n    line: _lineConfig,\n    scale: _scaleConfig,\n    axis: axisOptions\n  } = ___chartConfig;\n  const lineOptions = _lineConfig.options;\n  const _chartFillOptions = lineOptions.fill;\n  const __backgroundColor = lineOptions.backgroundColor;\n  const {\n    above: defaultFillColor = __backgroundColor,\n    below: belowFillColor = __backgroundColor\n  } = _chartFillOptions || {};\n  if (processedChartConfig && _lineConfig.points.length) {\n    __________animationManager(targetValue, area);\n    renderPlot(targetValue, {\n      line: _lineConfig,\n      target: processedChartConfig,\n      above: defaultFillColor,\n      below: belowFillColor,\n      area: area,\n      scale: _scaleConfig,\n      axis: axisOptions\n    });\n    Q(targetValue);\n  }\n}\nfunction renderPlot(_______canvasContext, plotConfig) {\n  const {\n    line: __lineConfig,\n    target: ______targetValue,\n    above: aboveColor,\n    below: belowThresholdColor,\n    area: areaBounds,\n    scale: _____scaleFactor\n  } = plotConfig;\n  const axisProperty = __lineConfig._loop ? \"angle\" : plotConfig.axis;\n  _______canvasContext.save();\n  if (axisProperty === \"x\" && belowThresholdColor !== aboveColor) {\n    drawPathOnCanvas(_______canvasContext, ______targetValue, areaBounds.top);\n    drawPathSegments(_______canvasContext, {\n      line: __lineConfig,\n      target: ______targetValue,\n      color: aboveColor,\n      scale: _____scaleFactor,\n      property: axisProperty\n    });\n    _______canvasContext.restore();\n    _______canvasContext.save();\n    drawPathOnCanvas(_______canvasContext, ______targetValue, areaBounds.bottom);\n  }\n  drawPathSegments(_______canvasContext, {\n    line: __lineConfig,\n    target: ______targetValue,\n    color: belowThresholdColor,\n    scale: _____scaleFactor,\n    property: axisProperty\n  });\n  _______canvasContext.restore();\n}\nfunction drawPathOnCanvas(______canvasContext, pathData, _yCoordinate) {\n  const {\n    segments: __pathSegments,\n    points: ____pointsArray\n  } = pathData;\n  let isFirstSegment = true;\n  let isFirstSegmentCompleted = false;\n  ______canvasContext.beginPath();\n  for (const pathSegment of __pathSegments) {\n    const {\n      start: _pathSegments,\n      end: endCoordinate\n    } = pathSegment;\n    const startPoint = ____pointsArray[_pathSegments];\n    const endPointCoordinates = ____pointsArray[findLastValidPointIndex(_pathSegments, endCoordinate, ____pointsArray)];\n    if (isFirstSegment) {\n      ______canvasContext.moveTo(startPoint.x, startPoint.y);\n      isFirstSegment = false;\n    } else {\n      ______canvasContext.lineTo(startPoint.x, _yCoordinate);\n      ______canvasContext.lineTo(startPoint.x, startPoint.y);\n    }\n    isFirstSegmentCompleted = !!pathData.pathSegment(______canvasContext, pathSegment, {\n      move: isFirstSegmentCompleted\n    });\n    if (isFirstSegmentCompleted) {\n      ______canvasContext.closePath();\n    } else {\n      ______canvasContext.lineTo(endPointCoordinates.x, _yCoordinate);\n    }\n  }\n  ______canvasContext.lineTo(pathData.first().x, _yCoordinate);\n  ______canvasContext.closePath();\n  ______canvasContext.clip();\n}\nfunction drawPathSegments(___canvasContext, drawOptions) {\n  const {\n    line: lineSegments,\n    target: targetSegment,\n    property: _animationProperty,\n    color: pathSegmentColor,\n    scale: ___scaleFactor\n  } = drawOptions;\n  const _animationSegments = mapAnimationSegmentsToTargets(lineSegments, targetSegment, _animationProperty);\n  for (const {\n    source: pathSegmentData,\n    target: ________targetElement,\n    start: startPosition,\n    end: endPosition\n  } of _animationSegments) {\n    const {\n      style: {\n        backgroundColor: pathSegments = pathSegmentColor\n      } = {}\n    } = pathSegmentData;\n    const isNotInteractive = targetSegment !== true;\n    ___canvasContext.save();\n    ___canvasContext.fillStyle = pathSegments;\n    clipRectangle(___canvasContext, ___scaleFactor, isNotInteractive && getAnimationProperty(_animationProperty, startPosition, endPosition));\n    ___canvasContext.beginPath();\n    const isPathSegmentVisible = !!lineSegments.pathSegment(___canvasContext, pathSegmentData);\n    let isPathSegmentClosed;\n    if (isNotInteractive) {\n      if (isPathSegmentVisible) {\n        ___canvasContext.closePath();\n      } else {\n        drawLineIfInterpolated(___canvasContext, targetSegment, endPosition, _animationProperty);\n      }\n      const _element = !!targetSegment.pathSegment(___canvasContext, ________targetElement, {\n        move: isPathSegmentVisible,\n        reverse: true\n      });\n      isPathSegmentClosed = isPathSegmentVisible && _element;\n      if (!isPathSegmentClosed) {\n        drawLineIfInterpolated(___canvasContext, targetSegment, startPosition, _animationProperty);\n      }\n    }\n    ___canvasContext.closePath();\n    ___canvasContext.fill(isPathSegmentClosed ? \"evenodd\" : \"nonzero\");\n    ___canvasContext.restore();\n  }\n}\nfunction clipRectangle(_____________canvasContext, _chartArea, chartAreaStyle) {\n  const {\n    top: chartAreaTop,\n    bottom: bottomYCoordinate\n  } = _chartArea.chart.chartArea;\n  const {\n    property: clipAxisOrientation,\n    start: chartAreaStartX,\n    end: chartAreaEnd\n  } = chartAreaStyle || {};\n  if (clipAxisOrientation === \"x\") {\n    _____________canvasContext.beginPath();\n    _____________canvasContext.rect(chartAreaStartX, chartAreaTop, chartAreaEnd - chartAreaStartX, bottomYCoordinate - chartAreaTop);\n    _____________canvasContext.clip();\n  }\n}\nfunction drawLineIfInterpolated(_graphicsContext, _interpolator, interpolationValue, _interpolationValue) {\n  const interpolatedPoint = _interpolator.interpolate(interpolationValue, _interpolationValue);\n  if (interpolatedPoint) {\n    _graphicsContext.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\nvar _animationControllerInstance = {\n  id: \"filler\",\n  afterDatasetsUpdate(___chartInstance, updatedDatasets, indexPropagation) {\n    const datasetCount = (___chartInstance.data.datasets || []).length;\n    const datasetMetadataList = [];\n    let ___datasetMeta;\n    let _datasetIndex;\n    let ___dataset;\n    let datasetMetaInfo;\n    for (_datasetIndex = 0; _datasetIndex < datasetCount; ++_datasetIndex) {\n      ___datasetMeta = ___chartInstance.getDatasetMeta(_datasetIndex);\n      ___dataset = ___datasetMeta.dataset;\n      datasetMetaInfo = null;\n      if (___dataset && ___dataset.options && ___dataset instanceof LineAnimationController) {\n        datasetMetaInfo = {\n          visible: ___chartInstance.isDatasetVisible(_datasetIndex),\n          index: _datasetIndex,\n          fill: chartAnimationHandler(___dataset, _datasetIndex, datasetCount),\n          chart: ___chartInstance,\n          axis: ___datasetMeta.controller.options.indexAxis,\n          scale: ___datasetMeta.vScale,\n          line: ___dataset\n        };\n      }\n      ___datasetMeta.$filler = datasetMetaInfo;\n      datasetMetadataList.push(datasetMetaInfo);\n    }\n    for (_datasetIndex = 0; _datasetIndex < datasetCount; ++_datasetIndex) {\n      datasetMetaInfo = datasetMetadataList[_datasetIndex];\n      if (datasetMetaInfo && datasetMetaInfo.fill !== false) {\n        datasetMetaInfo.fill = getFillColor(datasetMetadataList, _datasetIndex, indexPropagation.propagate);\n      }\n    }\n  },\n  beforeDraw(______chartInstance, _________datasetIndex, datasetMetaIndex) {\n    const isBeforeDraw = datasetMetaIndex.drawTime === \"beforeDraw\";\n    const sortedVisibleDatasetMetas = ______chartInstance.getSortedVisibleDatasetMetas();\n    const chartArea = ______chartInstance.chartArea;\n    for (let visibleDatasetMetaIndex = sortedVisibleDatasetMetas.length - 1; visibleDatasetMetaIndex >= 0; --visibleDatasetMetaIndex) {\n      const fillerDatasetMeta = sortedVisibleDatasetMetas[visibleDatasetMetaIndex].$filler;\n      if (fillerDatasetMeta) {\n        fillerDatasetMeta.line.updateControlPoints(chartArea, fillerDatasetMeta.axis);\n        if (isBeforeDraw && fillerDatasetMeta.fill) {\n          _____processChartData(______chartInstance.ctx, fillerDatasetMeta, chartArea);\n        }\n      }\n    }\n  },\n  beforeDatasetsDraw(__________chartInstance, _visibleDatasetIndex, drawTimeIndicator) {\n    if (drawTimeIndicator.drawTime !== \"beforeDatasetsDraw\") {\n      return;\n    }\n    const _sortedVisibleDatasetMetas = __________chartInstance.getSortedVisibleDatasetMetas();\n    for (let ______________________currentIndex = _sortedVisibleDatasetMetas.length - 1; ______________________currentIndex >= 0; --______________________currentIndex) {\n      const _fillerDatasetMeta = _sortedVisibleDatasetMetas[______________________currentIndex].$filler;\n      if (shouldFill(_fillerDatasetMeta)) {\n        _____processChartData(__________chartInstance.ctx, _fillerDatasetMeta, __________chartInstance.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(drawTimeContext, metaFiller, drawCallbackIndex) {\n    const fillerMetaData = metaFiller.meta.$filler;\n    if (shouldFill(fillerMetaData) && drawCallbackIndex.drawTime === \"beforeDatasetDraw\") {\n      _____processChartData(drawTimeContext.ctx, fillerMetaData, drawTimeContext.chartArea);\n    }\n  },\n  defaults: {\n    propagate: true,\n    drawTime: \"beforeDatasetDraw\"\n  }\n};\nconst _chartUpdater = (______chartDimensions, defaultDimension) => {\n  let {\n    boxHeight = defaultDimension,\n    boxWidth = defaultDimension\n  } = ______chartDimensions;\n  if (______chartDimensions.usePointStyle) {\n    boxHeight = Math.min(boxHeight, defaultDimension);\n    boxWidth = ______chartDimensions.pointStyleWidth || Math.min(boxWidth, defaultDimension);\n  }\n  return {\n    boxWidth: boxWidth,\n    boxHeight: boxHeight,\n    itemHeight: Math.max(defaultDimension, boxHeight)\n  };\n};\nconst _______animationController = (targetData, ______targetElement) => targetData !== null && ______targetElement !== null && targetData.datasetIndex === ______targetElement.datasetIndex && targetData.index === ______targetElement.index;\nclass Bo extends _AnimationController {\n  constructor(t) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = t.chart;\n    this.options = t.options;\n    this.ctx = t.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidthValue, maxHeightValue, margins) {\n    this.maxWidth = maxWidthValue;\n    this.maxHeight = maxHeightValue;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOptions = this.options.labels || {};\n    let generatedLabels = $(labelOptions.generateLabels, [this.chart], this) || [];\n    if (labelOptions.filter) {\n      generatedLabels = generatedLabels.filter(itemToFilter => labelOptions.filter(itemToFilter, this.chart.data));\n    }\n    if (labelOptions.sort) {\n      generatedLabels = generatedLabels.sort((sortFunction, sortOrder) => labelOptions.sort(sortFunction, sortOrder, this.chart.data));\n    }\n    if (this.options.reverse) {\n      generatedLabels.reverse();\n    }\n    this.legendItems = generatedLabels;\n  }\n  fit() {\n    const {\n      options: t,\n      ctx: e\n    } = this;\n    if (!t.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const i = t.labels;\n    const s = requestAnimationFrame(i.font);\n    const n = s.size;\n    const o = this._computeTitleHeight();\n    const {\n      boxWidth: a,\n      itemHeight: r\n    } = _chartUpdater(i, n);\n    let h;\n    let l;\n    e.font = s.string;\n    if (this.isHorizontal()) {\n      h = this.maxWidth;\n      l = this._fitRows(o, n, a, r) + 10;\n    } else {\n      l = this.maxHeight;\n      h = this._fitCols(o, s, a, r) + 10;\n    }\n    this.width = Math.min(h, t.maxWidth || this.maxWidth);\n    this.height = Math.min(l, t.maxHeight || this.maxHeight);\n  }\n  _fitRows(t, e, i, s) {\n    const {\n      ctx: n,\n      maxWidth: o,\n      options: {\n        labels: {\n          padding: a\n        }\n      }\n    } = this;\n    const r = this.legendHitBoxes = [];\n    const h = this.lineWidths = [0];\n    const l = s + a;\n    let c = t;\n    n.textAlign = \"left\";\n    n.textBaseline = \"middle\";\n    let rowCount = -1;\n    let u = -l;\n    this.legendItems.forEach((textString, _____________currentIndex) => {\n      const calculatedTextWidth = i + e / 2 + n.measureText(textString.text).width;\n      if (_____________currentIndex === 0 || h[h.length - 1] + calculatedTextWidth + a * 2 > o) {\n        c += l;\n        h[h.length - (_____________currentIndex > 0 ? 0 : 1)] = 0;\n        u += l;\n        rowCount++;\n      }\n      r[_____________currentIndex] = {\n        left: 0,\n        top: u,\n        row: rowCount,\n        width: calculatedTextWidth,\n        height: s\n      };\n      h[h.length - 1] += calculatedTextWidth + a;\n    });\n    return c;\n  }\n  _fitCols(t, e, i, s) {\n    const {\n      ctx: n,\n      maxHeight: o,\n      options: {\n        labels: {\n          padding: a\n        }\n      }\n    } = this;\n    const r = this.legendHitBoxes = [];\n    const h = this.columnSizes = [];\n    const l = o - t;\n    let c = a;\n    let d = 0;\n    let u = 0;\n    let g = 0;\n    let columnIndex = 0;\n    this.legendItems.forEach((___________currentIndex, itemIndex) => {\n      const {\n        itemWidth: itemWidth,\n        itemHeight: itemHeight\n      } = calculateItemDimensions(i, e, n, ___________currentIndex, s);\n      if (itemIndex > 0 && u + itemHeight + a * 2 > l) {\n        c += d + a;\n        h.push({\n          width: d,\n          height: u\n        });\n        g += d + a;\n        columnIndex++;\n        d = u = 0;\n      }\n      r[itemIndex] = {\n        left: g,\n        top: u,\n        col: columnIndex,\n        width: itemWidth,\n        height: itemHeight\n      };\n      d = Math.max(d, itemWidth);\n      u += itemHeight + a;\n    });\n    c += d;\n    h.push({\n      width: d,\n      height: u\n    });\n    return c;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const t = this._computeTitleHeight();\n    const {\n      legendHitBoxes: e,\n      options: {\n        align: i,\n        labels: {\n          padding: s\n        },\n        rtl: n\n      }\n    } = this;\n    const o = __animationManager(n, this.left, this.width);\n    if (this.isHorizontal()) {\n      let isRtl = 0;\n      let _animationPosition = animationQueue(i, this.left + s, this.right - this.lineWidths[isRtl]);\n      for (const rowData of e) {\n        if (isRtl !== rowData.row) {\n          isRtl = rowData.row;\n          _animationPosition = animationQueue(i, this.left + s, this.right - this.lineWidths[isRtl]);\n        }\n        rowData.top += this.top + t + s;\n        rowData.left = o.leftForLtr(o.x(_animationPosition), rowData.width);\n        _animationPosition += rowData.width + s;\n      }\n    } else {\n      let _isRtl = 0;\n      let animationQueuePosition = animationQueue(i, this.top + t + s, this.bottom - this.columnSizes[_isRtl].height);\n      for (const row of e) {\n        if (row.col !== _isRtl) {\n          _isRtl = row.col;\n          animationQueuePosition = animationQueue(i, this.top + t + s, this.bottom - this.columnSizes[_isRtl].height);\n        }\n        row.top = animationQueuePosition;\n        row.left += this.left + s;\n        row.left = o.leftForLtr(o.x(row.left), row.width);\n        animationQueuePosition += row.height + s;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === \"top\" || this.options.position === \"bottom\";\n  }\n  draw() {\n    if (this.options.display) {\n      const _______________canvasContext = this.ctx;\n      __________animationManager(_______________canvasContext, this);\n      this._draw();\n      Q(_______________canvasContext);\n    }\n  }\n  _draw() {\n    const {\n      options: t,\n      columnSizes: e,\n      lineWidths: i,\n      ctx: s\n    } = this;\n    const {\n      align: n,\n      labels: a\n    } = t;\n    const h = animationDuration.color;\n    const l = __animationManager(t.rtl, this.left, this.width);\n    const c = requestAnimationFrame(a.font);\n    const {\n      padding: d\n    } = a;\n    const u = c.size;\n    const g = u / 2;\n    let p;\n    this.drawTitle();\n    s.textAlign = l.textAlign(\"left\");\n    s.textBaseline = \"middle\";\n    s.lineWidth = 0.5;\n    s.font = c.string;\n    const {\n      boxWidth: f,\n      boxHeight: m,\n      itemHeight: x\n    } = _chartUpdater(a, u);\n    const b = this.isHorizontal();\n    const _ = this._computeTitleHeight();\n    if (b) {\n      p = {\n        x: animationQueue(n, this.left + d, this.right - i[0]),\n        y: this.top + d + _,\n        line: 0\n      };\n    } else {\n      p = {\n        x: this.left + d,\n        y: animationQueue(n, this.top + _ + d, this.bottom - e[0].height),\n        line: 0\n      };\n    }\n    chartRequestAnimationFrame(this.ctx, t.textDirection);\n    const y = x + d;\n    this.legendItems.forEach((fontProperties, verticalOffset) => {\n      s.strokeStyle = fontProperties.fontColor;\n      s.fillStyle = fontProperties.fontColor;\n      const textWidth = s.measureText(fontProperties.text).width;\n      const textAlignAdjustment = l.textAlign(fontProperties.textAlign ||= a.textAlign);\n      const totalTextWidthIncludingPadding = f + g + textWidth;\n      let currentXPosition = p.x;\n      let positionY = p.y;\n      l.setWidth(this.width);\n      if (b) {\n        if (verticalOffset > 0 && currentXPosition + totalTextWidthIncludingPadding + d > this.right) {\n          positionY = p.y += y;\n          p.line++;\n          currentXPosition = p.x = animationQueue(n, this.left + d, this.right - i[p.line]);\n        }\n      } else if (verticalOffset > 0 && positionY + y > this.bottom) {\n        currentXPosition = p.x = currentXPosition + e[p.line].width + d;\n        p.line++;\n        positionY = p.y = animationQueue(n, this.top + _ + d, this.bottom - e[p.line].height);\n      }\n      (function (xCoordinate, yPosition, chartStyle) {\n        if (isNaN(f) || f <= 0 || isNaN(m) || m < 0) {\n          return;\n        }\n        s.save();\n        const animatedLineWidth = chartAnimationRunning(chartStyle.lineWidth, 1);\n        s.fillStyle = chartAnimationRunning(chartStyle.fillStyle, h);\n        s.lineCap = chartAnimationRunning(chartStyle.lineCap, \"butt\");\n        s.lineDashOffset = chartAnimationRunning(chartStyle.lineDashOffset, 0);\n        s.lineJoin = chartAnimationRunning(chartStyle.lineJoin, \"miter\");\n        s.lineWidth = animatedLineWidth;\n        s.strokeStyle = chartAnimationRunning(chartStyle.strokeStyle, h);\n        s.setLineDash(chartAnimationRunning(chartStyle.lineDash, []));\n        if (a.usePointStyle) {\n          const pointStyleProps = {\n            radius: m * Math.SQRT2 / 2,\n            pointStyle: chartStyle.pointStyle,\n            rotation: chartStyle.rotation,\n            borderWidth: animatedLineWidth\n          };\n          const borderRadius = l.xPlus(xCoordinate, f / 2);\n          __animationDuration(s, pointStyleProps, borderRadius, yPosition + g, a.pointStyleWidth && f);\n        } else {\n          const pointStyles = yPosition + Math.max((u - m) / 2, 0);\n          const _chartConfig = l.leftForLtr(xCoordinate, f);\n          const animationPosition = elementBorderRadius(chartStyle.borderRadius);\n          s.beginPath();\n          if (Object.values(animationPosition).some(isNonZero => isNonZero !== 0)) {\n            ___animationController(s, {\n              x: _chartConfig,\n              y: pointStyles,\n              w: f,\n              h: m,\n              radius: animationPosition\n            });\n          } else {\n            s.rect(_chartConfig, pointStyles, f, m);\n          }\n          s.fill();\n          if (animatedLineWidth !== 0) {\n            s.stroke();\n          }\n        }\n        s.restore();\n      })(l.x(currentXPosition), positionY, fontProperties);\n      currentXPosition = framerate(textAlignAdjustment, currentXPosition + f + g, b ? currentXPosition + totalTextWidthIncludingPadding : this.right, t.rtl);\n      (function (__textValue, textVerticalOffset, textIndex) {\n        Z(s, textIndex.text, __textValue, textVerticalOffset + x / 2, c, {\n          strikethrough: textIndex.hidden,\n          textAlign: l.textAlign(textIndex.textAlign)\n        });\n      })(l.x(currentXPosition), positionY, fontProperties);\n      if (b) {\n        p.x += totalTextWidthIncludingPadding + d;\n      } else if (typeof fontProperties.text != \"string\") {\n        const _animationContext = c.lineHeight;\n        p.y += textLengthMultiplier(fontProperties, _animationContext) + d;\n      } else {\n        p.y += y;\n      }\n    });\n    chartAnimationController(this.ctx, t.textDirection);\n  }\n  drawTitle() {\n    const t = this.options;\n    const e = t.title;\n    const i = requestAnimationFrame(e.font);\n    const s = __animationElement(e.padding);\n    if (!e.display) {\n      return;\n    }\n    const n = __animationManager(t.rtl, this.left, this.width);\n    const o = this.ctx;\n    const a = e.position;\n    const r = i.size / 2;\n    const h = s.top + r;\n    let l;\n    let c = this.left;\n    let d = this.width;\n    if (this.isHorizontal()) {\n      d = Math.max(...this.lineWidths);\n      l = this.top + h;\n      c = animationQueue(t.align, c, this.right - d);\n    } else {\n      const titleOptions = this.columnSizes.reduce((currentHeight, elementHeight) => Math.max(currentHeight, elementHeight.height), 0);\n      l = h + animationQueue(t.align, this.top, this.bottom - titleOptions - t.labels.padding - this._computeTitleHeight());\n    }\n    const u = animationQueue(a, c, c + d);\n    o.textAlign = n.textAlign(animationTarget(a));\n    o.textBaseline = \"middle\";\n    o.strokeStyle = e.color;\n    o.fillStyle = e.color;\n    o.font = i.string;\n    Z(o, e.text, u, l, i);\n  }\n  _computeTitleHeight() {\n    const _titleOptions = this.options.title;\n    const fontAnimationFrame = requestAnimationFrame(_titleOptions.font);\n    const animationElementHeight = __animationElement(_titleOptions.padding);\n    if (_titleOptions.display) {\n      return fontAnimationFrame.lineHeight + animationElementHeight.height;\n    } else {\n      return 0;\n    }\n  }\n  _getLegendItemAt(mouseX, mouseY) {\n    let legendItemIndex;\n    let legendHitBox;\n    let legendHitBoxesArray;\n    if (animationRequestId(mouseX, this.left, this.right) && animationRequestId(mouseY, this.top, this.bottom)) {\n      legendHitBoxesArray = this.legendHitBoxes;\n      legendItemIndex = 0;\n      for (; legendItemIndex < legendHitBoxesArray.length; ++legendItemIndex) {\n        legendHitBox = legendHitBoxesArray[legendItemIndex];\n        if (animationRequestId(mouseX, legendHitBox.left, legendHitBox.left + legendHitBox.width) && animationRequestId(mouseY, legendHitBox.top, legendHitBox.top + legendHitBox.height)) {\n          return this.legendItems[legendItemIndex];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(_______eventData) {\n    const ___eventOptions = this.options;\n    if (!eventHandler(_______eventData.type, ___eventOptions)) {\n      return;\n    }\n    const legendItem = this._getLegendItemAt(_______eventData.x, _______eventData.y);\n    if (_______eventData.type === \"mousemove\" || _______eventData.type === \"mouseout\") {\n      const hoveredItem = this._hoveredItem;\n      const isAnimationInProgress = _______animationController(hoveredItem, legendItem);\n      if (hoveredItem && !isAnimationInProgress) {\n        $(___eventOptions.onLeave, [_______eventData, hoveredItem, this], this);\n      }\n      this._hoveredItem = legendItem;\n      if (legendItem && !isAnimationInProgress) {\n        $(___eventOptions.onHover, [_______eventData, legendItem, this], this);\n      }\n    } else if (legendItem) {\n      $(___eventOptions.onClick, [_______eventData, legendItem, this], this);\n    }\n  }\n}\nfunction calculateItemDimensions(__textWidth, textWidthParameter, maxTextWidth, _textMeasurement, lineHeightValue) {\n  return {\n    itemWidth: getMaxTextWidth(_textMeasurement, __textWidth, textWidthParameter, maxTextWidth),\n    itemHeight: elementText(lineHeightValue, _textMeasurement, textWidthParameter.lineHeight)\n  };\n}\nfunction getMaxTextWidth(_textValue, _textWidth, textArraySize, textMeasurement) {\n  let longestTextValue = _textValue.text;\n  if (longestTextValue && typeof longestTextValue != \"string\") {\n    longestTextValue = longestTextValue.reduce((longerString, _longerString) => longerString.length > _longerString.length ? longerString : _longerString);\n  }\n  return _textWidth + textArraySize.size / 2 + textMeasurement.measureText(longestTextValue).width;\n}\nfunction elementText(inputText, _______element, callbackIndex) {\n  let outputText = inputText;\n  if (typeof _______element.text != \"string\") {\n    outputText = textLengthMultiplier(_______element, callbackIndex);\n  }\n  return outputText;\n}\nfunction textLengthMultiplier(textElement, _textLengthMultiplier) {\n  return _textLengthMultiplier * (textElement.text ? textElement.text.length : 0);\n}\nfunction eventHandler(eventType, eventConfig) {\n  return (eventType === \"mousemove\" || eventType === \"mouseout\") && (!!eventConfig.onHover || !!eventConfig.onLeave) || !!eventConfig.onClick && (eventType === \"click\" || eventType === \"mouseup\");\n}\nvar Uo = {\n  id: \"legend\",\n  _element: Bo,\n  start(_______________chartInstance, ______event, optionsConfig) {\n    const legendInstance = _______________chartInstance.legend = new Bo({\n      ctx: _______________chartInstance.ctx,\n      options: optionsConfig,\n      chart: _______________chartInstance\n    });\n    ___________animationIndex.configure(_______________chartInstance, legendInstance, optionsConfig);\n    ___________animationIndex.addBox(_______________chartInstance, legendInstance);\n  },\n  stop(boxToStop) {\n    ___________animationIndex.removeBox(boxToStop, boxToStop.legend);\n    delete boxToStop.legend;\n  },\n  beforeUpdate(__________________________chartData, updatedOptions, updateOptionIndex) {\n    const legendData = __________________________chartData.legend;\n    ___________animationIndex.configure(__________________________chartData, legendData, updateOptionIndex);\n    legendData.options = updateOptionIndex;\n  },\n  afterUpdate(___________________________chartData) {\n    const _legendInstance = ___________________________chartData.legend;\n    _legendInstance.buildLabels();\n    _legendInstance.adjustHitBoxes();\n  },\n  afterEvent(eventContext, _eventDetails) {\n    if (!_eventDetails.replay) {\n      eventContext.legend.handleEvent(_eventDetails.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: \"top\",\n    align: \"center\",\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(__event, ___event, ___________chartInstance) {\n      const _______________datasetIndex = ___event.datasetIndex;\n      const ____________chartInstance = ___________chartInstance.chart;\n      if (____________chartInstance.isDatasetVisible(_______________datasetIndex)) {\n        ____________chartInstance.hide(_______________datasetIndex);\n        ___event.hidden = true;\n      } else {\n        ____________chartInstance.show(_______________datasetIndex);\n        ___event.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: ________chartOptions => ________chartOptions.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(___chartData) {\n        const datasets = ___chartData.data.datasets;\n        const {\n          labels: {\n            usePointStyle: usePointStyle,\n            pointStyle: pointStyle,\n            textAlign: textAlignment,\n            color: fontColor,\n            useBorderRadius: useBorderRadius,\n            borderRadius: borderRadiusOption\n          }\n        } = ___chartData.legend.options;\n        return ___chartData._getSortedDatasetMetas().map(datasetContext => {\n          const styleProperties = datasetContext.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidthDimensions = __animationElement(styleProperties.borderWidth);\n          return {\n            text: datasets[datasetContext.index].label,\n            fillStyle: styleProperties.backgroundColor,\n            fontColor: fontColor,\n            hidden: !datasetContext.visible,\n            lineCap: styleProperties.borderCapStyle,\n            lineDash: styleProperties.borderDash,\n            lineDashOffset: styleProperties.borderDashOffset,\n            lineJoin: styleProperties.borderJoinStyle,\n            lineWidth: (borderWidthDimensions.width + borderWidthDimensions.height) / 4,\n            strokeStyle: styleProperties.borderColor,\n            pointStyle: pointStyle || styleProperties.pointStyle,\n            rotation: styleProperties.rotation,\n            textAlign: textAlignment || styleProperties.textAlign,\n            borderRadius: useBorderRadius && (borderRadiusOption || styleProperties.borderRadius),\n            datasetIndex: datasetContext.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: chartOptionsColor => chartOptionsColor.chart.options.color,\n      display: false,\n      position: \"center\",\n      text: \"\"\n    }\n  },\n  descriptors: {\n    _scriptable: isNotEventPrefix => !isNotEventPrefix.startsWith(\"on\"),\n    labels: {\n      _scriptable: _actionType => ![\"generateLabels\", \"filter\", \"sort\"].includes(_actionType)\n    }\n  }\n};\nclass Yo extends _AnimationController {\n  constructor(___________chartConfig) {\n    super();\n    this.chart = ___________chartConfig.chart;\n    this.options = ___________chartConfig.options;\n    this.ctx = ___________chartConfig.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(newWidth, _heightValue) {\n    const ____________________options = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!____________________options.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = newWidth;\n    this.height = this.bottom = _heightValue;\n    const textItemCount = animatedChartItems(____________________options.text) ? ____________________options.text.length : 1;\n    this._padding = __animationElement(____________________options.padding);\n    const calculatedHeight = textItemCount * requestAnimationFrame(____________________options.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = calculatedHeight;\n    } else {\n      this.width = calculatedHeight;\n    }\n  }\n  isHorizontal() {\n    const positionOption = this.options.position;\n    return positionOption === \"top\" || positionOption === \"bottom\";\n  }\n  _drawArgs(______offsetValue) {\n    const {\n      top: bottomEdge,\n      left: leftPosition,\n      bottom: bottomEdgePosition,\n      right: _rightEdge,\n      options: ______________________options\n    } = this;\n    const alignmentOption = ______________________options.align;\n    let maxWidthDifference;\n    let titleXPosition;\n    let __titleYPosition;\n    let rotationAdjustment = 0;\n    if (this.isHorizontal()) {\n      titleXPosition = animationQueue(alignmentOption, leftPosition, _rightEdge);\n      __titleYPosition = bottomEdge + ______offsetValue;\n      maxWidthDifference = _rightEdge - leftPosition;\n    } else {\n      if (______________________options.position === \"left\") {\n        titleXPosition = leftPosition + ______offsetValue;\n        __titleYPosition = animationQueue(alignmentOption, bottomEdgePosition, bottomEdge);\n        rotationAdjustment = notificationListener * -0.5;\n      } else {\n        titleXPosition = _rightEdge - ______offsetValue;\n        __titleYPosition = animationQueue(alignmentOption, bottomEdge, bottomEdgePosition);\n        rotationAdjustment = notificationListener * 0.5;\n      }\n      maxWidthDifference = bottomEdgePosition - bottomEdge;\n    }\n    return {\n      titleX: titleXPosition,\n      titleY: __titleYPosition,\n      maxWidth: maxWidthDifference,\n      rotation: rotationAdjustment\n    };\n  }\n  draw() {\n    const _________________________canvasContext = this.ctx;\n    const __________________options = this.options;\n    if (!__________________options.display) {\n      return;\n    }\n    const ________animationFrameId = requestAnimationFrame(__________________options.font);\n    const lineHeightOffset = ________animationFrameId.lineHeight / 2 + this._padding.top;\n    const {\n      titleX: titlePositionX,\n      titleY: _titleYPosition,\n      maxWidth: _maxTextWidth,\n      rotation: textRotation\n    } = this._drawArgs(lineHeightOffset);\n    Z(_________________________canvasContext, __________________options.text, 0, 0, ________animationFrameId, {\n      color: __________________options.color,\n      maxWidth: _maxTextWidth,\n      rotation: textRotation,\n      textAlign: animationTarget(__________________options.align),\n      textBaseline: \"middle\",\n      translation: [titlePositionX, _titleYPosition]\n    });\n  }\n}\nfunction createChartInstance(chartContext, ____options) {\n  const ___________________chartInstance = new Yo({\n    ctx: chartContext.ctx,\n    options: ____options,\n    chart: chartContext\n  });\n  ___________animationIndex.configure(chartContext, ___________________chartInstance, ____options);\n  ___________animationIndex.addBox(chartContext, ___________________chartInstance);\n  chartContext.titleBlock = ___________________chartInstance;\n}\nvar Go = {\n  id: \"title\",\n  _element: Yo,\n  start(startTime, ____________event, _____________________________________________________index) {\n    createChartInstance(startTime, _____________________________________________________index);\n  },\n  stop(_titleBlockData) {\n    const titleBlockReference = _titleBlockData.titleBlock;\n    ___________animationIndex.removeBox(_titleBlockData, titleBlockReference);\n    delete _titleBlockData.titleBlock;\n  },\n  beforeUpdate(titleBlockData, optionsUpdate, updateOptionsIndex) {\n    const titleBlock = titleBlockData.titleBlock;\n    ___________animationIndex.configure(titleBlockData, titleBlock, updateOptionsIndex);\n    titleBlock.options = updateOptionsIndex;\n  },\n  defaults: {\n    align: \"center\",\n    display: false,\n    font: {\n      weight: \"bold\"\n    },\n    fullSize: true,\n    padding: 10,\n    position: \"top\",\n    text: \"\",\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nconst chartManager = new WeakMap();\nvar qo = {\n  id: \"subtitle\",\n  start(_____________chartInstance, _eventObject, ___options) {\n    const ______________chartInstance = new Yo({\n      ctx: _____________chartInstance.ctx,\n      options: ___options,\n      chart: _____________chartInstance\n    });\n    ___________animationIndex.configure(_____________chartInstance, ______________chartInstance, ___options);\n    ___________animationIndex.addBox(_____________chartInstance, ______________chartInstance);\n    chartManager.set(_____________chartInstance, ______________chartInstance);\n  },\n  stop(boxId) {\n    ___________animationIndex.removeBox(boxId, chartManager.get(boxId));\n    chartManager.delete(boxId);\n  },\n  beforeUpdate(chartId, updatedChartOptions, updateOptions) {\n    const _________________chartInstance = chartManager.get(chartId);\n    ___________animationIndex.configure(chartId, _________________chartInstance, updateOptions);\n    _________________chartInstance.options = updateOptions;\n  },\n  defaults: {\n    align: \"center\",\n    display: false,\n    font: {\n      weight: \"normal\"\n    },\n    fullSize: true,\n    padding: 0,\n    position: \"top\",\n    text: \"\",\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nconst _____________animationController = {\n  average(__elementsArray) {\n    if (!__elementsArray.length) {\n      return false;\n    }\n    let ___________index;\n    let elementCount;\n    let sumTooltipPositionX = 0;\n    let totalTooltipY = 0;\n    let validElementCount = 0;\n    ___________index = 0;\n    elementCount = __elementsArray.length;\n    for (; ___________index < elementCount; ++___________index) {\n      const ____currentElement = __elementsArray[___________index].element;\n      if (____currentElement && ____currentElement.hasValue()) {\n        const ___tooltipPosition = ____currentElement.tooltipPosition();\n        sumTooltipPositionX += ___tooltipPosition.x;\n        totalTooltipY += ___tooltipPosition.y;\n        ++validElementCount;\n      }\n    }\n    return {\n      x: sumTooltipPositionX / validElementCount,\n      y: totalTooltipY / validElementCount\n    };\n  },\n  nearest(elementsArray, currentPoint) {\n    if (!elementsArray.length) {\n      return false;\n    }\n    let _______index;\n    let arrayLength;\n    let nearestElement;\n    let tooltipX = currentPoint.x;\n    let __yCoordinate = currentPoint.y;\n    let closestDistance = Number.POSITIVE_INFINITY;\n    _______index = 0;\n    arrayLength = elementsArray.length;\n    for (; _______index < arrayLength; ++_______index) {\n      const ___currentElement = elementsArray[_______index].element;\n      if (___currentElement && ___currentElement.hasValue()) {\n        const centerPoint = ___currentElement.getCenterPoint();\n        const animationDurationToClosestElement = ___animationDuration(currentPoint, centerPoint);\n        if (animationDurationToClosestElement < closestDistance) {\n          closestDistance = animationDurationToClosestElement;\n          nearestElement = ___currentElement;\n        }\n      }\n    }\n    if (nearestElement) {\n      const _elementsArray = nearestElement.tooltipPosition();\n      tooltipX = _elementsArray.x;\n      __yCoordinate = _elementsArray.y;\n    }\n    return {\n      x: tooltipX,\n      y: __yCoordinate\n    };\n  }\n};\nfunction updateTargetArray(targetArray, _chartItem) {\n  if (_chartItem) {\n    if (animatedChartItems(_chartItem)) {\n      Array.prototype.push.apply(targetArray, _chartItem);\n    } else {\n      targetArray.push(_chartItem);\n    }\n  }\n  return targetArray;\n}\nfunction splitStringByLine(_inputString) {\n  if ((typeof _inputString == \"string\" || _inputString instanceof String) && _inputString.indexOf(\"\\n\") > -1) {\n    return _inputString.split(\"\\n\");\n  } else {\n    return _inputString;\n  }\n}\nfunction getChartDetails(_____chartInstance, ____datasetMeta) {\n  const {\n    element: ______elementIndex,\n    datasetIndex: _________________________________datasetIndex,\n    index: ___________dataIndex\n  } = ____datasetMeta;\n  const controllerInstance = _____chartInstance.getDatasetMeta(_________________________________datasetIndex).controller;\n  const {\n    label: __label,\n    value: _formattedValue\n  } = controllerInstance.getLabelAndValue(___________dataIndex);\n  return {\n    chart: _____chartInstance,\n    label: __label,\n    parsed: controllerInstance.getParsed(___________dataIndex),\n    raw: _____chartInstance.data.datasets[_________________________________datasetIndex].data[___________dataIndex],\n    formattedValue: _formattedValue,\n    dataset: controllerInstance.getDataset(),\n    dataIndex: ___________dataIndex,\n    datasetIndex: _________________________________datasetIndex,\n    element: ______elementIndex\n  };\n}\nfunction calculateTooltipDimensions(_chartData, _tooltipOptions) {\n  const _canvasRenderingContext = _chartData.chart.ctx;\n  const {\n    body: tooltipBody,\n    footer: footerLines,\n    title: tooltipTitle\n  } = _chartData;\n  const {\n    boxWidth: tooltipBoxWidth,\n    boxHeight: _boxHeight\n  } = _tooltipOptions;\n  const tooltipBodyFontMetrics = requestAnimationFrame(_tooltipOptions.bodyFont);\n  const titleFontMetrics = requestAnimationFrame(_tooltipOptions.titleFont);\n  const footerFont = requestAnimationFrame(_tooltipOptions.footerFont);\n  const titleCount = tooltipTitle.length;\n  const footerItemCount = footerLines.length;\n  const tooltipBodyCount = tooltipBody.length;\n  const tooltipPadding = __animationElement(_tooltipOptions.padding);\n  let tooltipHeight = tooltipPadding.height;\n  let maxTooltipWidth = 0;\n  let totalTextLength = tooltipBody.reduce((totalLengthIncludingBeforeAndAfter, ____elementData) => totalLengthIncludingBeforeAndAfter + ____elementData.before.length + ____elementData.lines.length + ____elementData.after.length, 0);\n  totalTextLength += _chartData.beforeBody.length + _chartData.afterBody.length;\n  if (titleCount) {\n    tooltipHeight += titleCount * titleFontMetrics.lineHeight + (titleCount - 1) * _tooltipOptions.titleSpacing + _tooltipOptions.titleMarginBottom;\n  }\n  if (totalTextLength) {\n    tooltipHeight += tooltipBodyCount * (_tooltipOptions.displayColors ? Math.max(_boxHeight, tooltipBodyFontMetrics.lineHeight) : tooltipBodyFontMetrics.lineHeight) + (totalTextLength - tooltipBodyCount) * tooltipBodyFontMetrics.lineHeight + (totalTextLength - 1) * _tooltipOptions.bodySpacing;\n  }\n  if (footerItemCount) {\n    tooltipHeight += _tooltipOptions.footerMarginTop + footerItemCount * footerFont.lineHeight + (footerItemCount - 1) * _tooltipOptions.footerSpacing;\n  }\n  let _tooltipPadding = 0;\n  const measureTextWidth = function (text) {\n    maxTooltipWidth = Math.max(maxTooltipWidth, _canvasRenderingContext.measureText(text).width + _tooltipPadding);\n  };\n  _canvasRenderingContext.save();\n  _canvasRenderingContext.font = titleFontMetrics.string;\n  __lastDateUpdated(_chartData.title, measureTextWidth);\n  _canvasRenderingContext.font = tooltipBodyFontMetrics.string;\n  __lastDateUpdated(_chartData.beforeBody.concat(_chartData.afterBody), measureTextWidth);\n  if (_tooltipOptions.displayColors) {\n    _tooltipPadding = tooltipBoxWidth + 2 + _tooltipOptions.boxPadding;\n  } else {\n    _tooltipPadding = 0;\n  }\n  __lastDateUpdated(tooltipBody, dateUpdateEvent => {\n    __lastDateUpdated(dateUpdateEvent.before, measureTextWidth);\n    __lastDateUpdated(dateUpdateEvent.lines, measureTextWidth);\n    __lastDateUpdated(dateUpdateEvent.after, measureTextWidth);\n  });\n  _tooltipPadding = 0;\n  _canvasRenderingContext.font = footerFont.string;\n  __lastDateUpdated(_chartData.footer, measureTextWidth);\n  _canvasRenderingContext.restore();\n  maxTooltipWidth += tooltipPadding.width;\n  return {\n    width: maxTooltipWidth,\n    height: tooltipHeight\n  };\n}\nfunction getVerticalPosition(container, ____boundingBox) {\n  const {\n    y: verticalPositionY,\n    height: boundingBoxHeight\n  } = ____boundingBox;\n  if (verticalPositionY < boundingBoxHeight / 2) {\n    return \"top\";\n  } else if (verticalPositionY > container.height - boundingBoxHeight / 2) {\n    return \"bottom\";\n  } else {\n    return \"center\";\n  }\n}\nfunction isInputOverflowing(alignmentDirection, availableSpaceWidth, ___inputValue, selectionBounds) {\n  const {\n    x: selectionPositionX,\n    width: selectionWidth\n  } = selectionBounds;\n  const totalCaretSpace = ___inputValue.caretSize + ___inputValue.caretPadding;\n  return alignmentDirection === \"left\" && selectionPositionX + selectionWidth + totalCaretSpace > availableSpaceWidth.width || alignmentDirection === \"right\" && selectionPositionX - selectionWidth - totalCaretSpace < 0 || undefined;\n}\nfunction determinePositionAlignment(___chartDimensions, ___________chartData, ____chartDimensions, positionAlignment) {\n  const {\n    x: chartXPosition,\n    width: __chartWidth\n  } = ____chartDimensions;\n  const {\n    width: ___chartWidth,\n    chartArea: {\n      left: chartAreaLeft,\n      right: chartAreaRight\n    }\n  } = ___chartDimensions;\n  let _positionAlignment = \"center\";\n  if (positionAlignment === \"center\") {\n    if (chartXPosition <= (chartAreaLeft + chartAreaRight) / 2) {\n      _positionAlignment = \"left\";\n    } else {\n      _positionAlignment = \"right\";\n    }\n  } else if (chartXPosition <= __chartWidth / 2) {\n    _positionAlignment = \"left\";\n  } else if (chartXPosition >= ___chartWidth - __chartWidth / 2) {\n    _positionAlignment = \"right\";\n  }\n  if (isInputOverflowing(_positionAlignment, ___chartDimensions, ___________chartData, ____chartDimensions)) {\n    _positionAlignment = \"center\";\n  }\n  return _positionAlignment;\n}\nfunction alignElements(alignmentSettings, elementAlignment, alignmentOptions) {\n  const yAlignmentValue = alignmentOptions.yAlign || elementAlignment.yAlign || getVerticalPosition(alignmentSettings, alignmentOptions);\n  return {\n    xAlign: alignmentOptions.xAlign || elementAlignment.xAlign || determinePositionAlignment(alignmentSettings, elementAlignment, alignmentOptions, yAlignmentValue),\n    yAlign: yAlignmentValue\n  };\n}\nfunction calculateAdjustedX(______boundingBox, _alignment) {\n  let {\n    x: adjustedX,\n    width: boundingBoxWidth\n  } = ______boundingBox;\n  if (_alignment === \"right\") {\n    adjustedX -= boundingBoxWidth;\n  } else if (_alignment === \"center\") {\n    adjustedX -= boundingBoxWidth / 2;\n  }\n  return adjustedX;\n}\nfunction calculatePositionY(positionAttributes, positionAdjustment, _offsetValue) {\n  let {\n    y: ___yCoordinate,\n    height: _height\n  } = positionAttributes;\n  if (positionAdjustment === \"top\") {\n    ___yCoordinate += _offsetValue;\n  } else {\n    if (positionAdjustment === \"bottom\") {\n      ___yCoordinate -= _height + _offsetValue;\n    } else {\n      ___yCoordinate -= _height / 2;\n    }\n  }\n  return ___yCoordinate;\n}\nfunction calculateTooltipPosition(__tooltipOptions, elementWidth, alignmentConfig, boundingBox) {\n  const {\n    caretSize: caretSize,\n    caretPadding: caretPadding,\n    cornerRadius: cornerRadius\n  } = __tooltipOptions;\n  const {\n    xAlign: xAlignment,\n    yAlign: verticalAlignment\n  } = alignmentConfig;\n  const totalCaretOffset = caretSize + caretPadding;\n  const {\n    topLeft: topLeftBorderRadius,\n    topRight: bottomRightBorderRadius,\n    bottomLeft: bottomLeftBorderRadius,\n    bottomRight: _bottomRightBorderRadius\n  } = elementBorderRadius(cornerRadius);\n  let adjustedXPosition = calculateAdjustedX(elementWidth, xAlignment);\n  const calculatedPositionY = calculatePositionY(elementWidth, verticalAlignment, totalCaretOffset);\n  if (verticalAlignment === \"center\") {\n    if (xAlignment === \"left\") {\n      adjustedXPosition += totalCaretOffset;\n    } else if (xAlignment === \"right\") {\n      adjustedXPosition -= totalCaretOffset;\n    }\n  } else if (xAlignment === \"left\") {\n    adjustedXPosition -= Math.max(topLeftBorderRadius, bottomLeftBorderRadius) + caretSize;\n  } else if (xAlignment === \"right\") {\n    adjustedXPosition += Math.max(bottomRightBorderRadius, _bottomRightBorderRadius) + caretSize;\n  }\n  return {\n    x: chartAnimationState(adjustedXPosition, 0, boundingBox.width - elementWidth.width),\n    y: chartAnimationState(calculatedPositionY, 0, boundingBox.height - elementWidth.height)\n  };\n}\nfunction calculateAlignmentOffset(rectangle, alignment, paddingValue) {\n  const paddingAnimationValue = __animationElement(paddingValue.padding);\n  if (alignment === \"center\") {\n    return rectangle.x + rectangle.width / 2;\n  } else if (alignment === \"right\") {\n    return rectangle.x + rectangle.width - paddingAnimationValue.right;\n  } else {\n    return rectangle.x + paddingAnimationValue.left;\n  }\n}\nfunction processInputText(_inputText) {\n  return updateTargetArray([], splitStringByLine(_inputText));\n}\nfunction tooltipHandlerFunction(_tooltipElement, tooltipContent, tooltipItems) {\n  return tooltipHandler(_tooltipElement, {\n    tooltip: tooltipContent,\n    tooltipItems: tooltipItems,\n    type: \"tooltip\"\n  });\n}\nfunction getTooltipWithCallbacks(_tooltipHandler, tooltipCallbacks) {\n  const tooltipCallbacksArray = tooltipCallbacks && tooltipCallbacks.dataset && tooltipCallbacks.dataset.tooltip && tooltipCallbacks.dataset.tooltip.callbacks;\n  if (tooltipCallbacksArray) {\n    return _tooltipHandler.override(tooltipCallbacksArray);\n  } else {\n    return _tooltipHandler;\n  }\n}\nconst chartUpdateState = {\n  beforeTitle: width,\n  title(titleArray) {\n    if (titleArray.length > 0) {\n      const firstTitleElement = titleArray[0];\n      const chartLabels = firstTitleElement.chart.data.labels;\n      const labelCount = chartLabels ? chartLabels.length : 0;\n      if (this && this.options && this.options.mode === \"dataset\") {\n        return firstTitleElement.dataset.label || \"\";\n      }\n      if (firstTitleElement.label) {\n        return firstTitleElement.label;\n      }\n      if (labelCount > 0 && firstTitleElement.dataIndex < labelCount) {\n        return chartLabels[firstTitleElement.dataIndex];\n      }\n    }\n    return \"\";\n  },\n  afterTitle: width,\n  beforeBody: width,\n  beforeLabel: width,\n  label(____dataPoint) {\n    if (this && this.options && this.options.mode === \"dataset\") {\n      return ____dataPoint.label + \": \" + ____dataPoint.formattedValue || ____dataPoint.formattedValue;\n    }\n    let dataLabel = ____dataPoint.dataset.label || \"\";\n    if (dataLabel) {\n      dataLabel += \": \";\n    }\n    const formattedValue = ____dataPoint.formattedValue;\n    if (!chartUpdateInterval(formattedValue)) {\n      dataLabel += formattedValue;\n    }\n    return dataLabel;\n  },\n  labelColor(_____________chartData) {\n    const datasetStyle = _____________chartData.chart.getDatasetMeta(_____________chartData.datasetIndex).controller.getStyle(_____________chartData.dataIndex);\n    return {\n      borderColor: datasetStyle.borderColor,\n      backgroundColor: datasetStyle.backgroundColor,\n      borderWidth: datasetStyle.borderWidth,\n      borderDash: datasetStyle.borderDash,\n      borderDashOffset: datasetStyle.borderDashOffset,\n      borderRadius: 0\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(labelPointStyleContext) {\n    const ___pointStyle = labelPointStyleContext.chart.getDatasetMeta(labelPointStyleContext.datasetIndex).controller.getStyle(labelPointStyleContext.dataIndex);\n    return {\n      pointStyle: ___pointStyle.pointStyle,\n      rotation: ___pointStyle.rotation\n    };\n  },\n  afterLabel: width,\n  afterBody: width,\n  beforeFooter: width,\n  footer: width,\n  afterFooter: width\n};\nfunction invokePropertyMethod(__target, propertyName, contextualObject, callArgument) {\n  const propertyMethodResult = __target[propertyName].call(contextualObject, callArgument);\n  if (propertyMethodResult === undefined) {\n    return chartUpdateState[propertyName].call(contextualObject, callArgument);\n  } else {\n    return propertyMethodResult;\n  }\n}\nclass fa extends _AnimationController {\n  static positioners = _____________animationController;\n  constructor(t) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = t.chart;\n    this.options = t.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(________options) {\n    this.options = ________options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cachedAnimations = this._cachedAnimations;\n    if (cachedAnimations) {\n      return cachedAnimations;\n    }\n    const ________________________chartInstance = this.chart;\n    const contextOptions = this.options.setContext(this.getContext());\n    const _isAnimationEnabled = contextOptions.enabled && ________________________chartInstance.options.animation && contextOptions.animations;\n    const _animationResolver = new se(this.chart, _isAnimationEnabled);\n    if (_isAnimationEnabled._cacheable) {\n      this._cachedAnimations = Object.freeze(_animationResolver);\n    }\n    return _animationResolver;\n  }\n  getContext() {\n    return this.$context ||= tooltipHandlerFunction(this.chart.getContext(), this, this._tooltipItems);\n  }\n  getTitle(______targetObject, __titleOptions) {\n    const {\n      callbacks: _eventCallbacks\n    } = __titleOptions;\n    const beforeTitle = invokePropertyMethod(_eventCallbacks, \"beforeTitle\", this, ______targetObject);\n    const title = invokePropertyMethod(_eventCallbacks, \"title\", this, ______targetObject);\n    const afterTitle = invokePropertyMethod(_eventCallbacks, \"afterTitle\", this, ______targetObject);\n    let titleLinesArray = [];\n    titleLinesArray = updateTargetArray(titleLinesArray, splitStringByLine(beforeTitle));\n    titleLinesArray = updateTargetArray(titleLinesArray, splitStringByLine(title));\n    titleLinesArray = updateTargetArray(titleLinesArray, splitStringByLine(afterTitle));\n    return titleLinesArray;\n  }\n  getBeforeBody(__inputText, eventCallbacks) {\n    return processInputText(invokePropertyMethod(eventCallbacks.callbacks, \"beforeBody\", this, __inputText));\n  }\n  getBody(_lastUpdatedDate, _____________inputData) {\n    const {\n      callbacks: callbacks\n    } = _____________inputData;\n    const labelSectionsArray = [];\n    __lastDateUpdated(_lastUpdatedDate, _____inputData => {\n      const labelSections = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const __parsedData = getTooltipWithCallbacks(callbacks, _____inputData);\n      updateTargetArray(labelSections.before, splitStringByLine(invokePropertyMethod(__parsedData, \"beforeLabel\", this, _____inputData)));\n      updateTargetArray(labelSections.lines, invokePropertyMethod(__parsedData, \"label\", this, _____inputData));\n      updateTargetArray(labelSections.after, splitStringByLine(invokePropertyMethod(__parsedData, \"afterLabel\", this, _____inputData)));\n      labelSectionsArray.push(labelSections);\n    });\n    return labelSectionsArray;\n  }\n  getAfterBody(___inputParameter, afterBodyCallbacks) {\n    return processInputText(invokePropertyMethod(afterBodyCallbacks.callbacks, \"afterBody\", this, ___inputParameter));\n  }\n  getFooter(footerContext, footerConfig) {\n    const {\n      callbacks: footerCallbacks\n    } = footerConfig;\n    const beforeFooterContent = invokePropertyMethod(footerCallbacks, \"beforeFooter\", this, footerContext);\n    const footerContent = invokePropertyMethod(footerCallbacks, \"footer\", this, footerContext);\n    const afterFooterContent = invokePropertyMethod(footerCallbacks, \"afterFooter\", this, footerContext);\n    let footerContentLines = [];\n    footerContentLines = updateTargetArray(footerContentLines, splitStringByLine(beforeFooterContent));\n    footerContentLines = updateTargetArray(footerContentLines, splitStringByLine(footerContent));\n    footerContentLines = updateTargetArray(footerContentLines, splitStringByLine(afterFooterContent));\n    return footerContentLines;\n  }\n  _createItems(t) {\n    const e = this._active;\n    const i = this.chart.data;\n    const s = [];\n    const n = [];\n    const o = [];\n    let _chartIndex;\n    let r;\n    let h = [];\n    _chartIndex = 0;\n    r = e.length;\n    for (; _chartIndex < r; ++_chartIndex) {\n      h.push(getChartDetails(this.chart, e[_chartIndex]));\n    }\n    if (t.filter) {\n      h = h.filter((filterElement, filterCriteria, _filterCriteria) => t.filter(filterElement, filterCriteria, _filterCriteria, i));\n    }\n    if (t.itemSort) {\n      h = h.sort((___________element, _sortOrder) => t.itemSort(___________element, _sortOrder, i));\n    }\n    __lastDateUpdated(h, ____event => {\n      const callbackResult = getTooltipWithCallbacks(t.callbacks, ____event);\n      s.push(invokePropertyMethod(callbackResult, \"labelColor\", this, ____event));\n      n.push(invokePropertyMethod(callbackResult, \"labelPointStyle\", this, ____event));\n      o.push(invokePropertyMethod(callbackResult, \"labelTextColor\", this, ____event));\n    });\n    this.labelColors = s;\n    this.labelPointStyles = n;\n    this.labelTextColors = o;\n    this.dataPoints = h;\n    return h;\n  }\n  update(t, e) {\n    const i = this.options.setContext(this.getContext());\n    const s = this._active;\n    let n;\n    let o = [];\n    if (s.length) {\n      const tooltipPosition = _____________animationController[i.position].call(this, s, this._eventPosition);\n      o = this._createItems(i);\n      this.title = this.getTitle(o, i);\n      this.beforeBody = this.getBeforeBody(o, i);\n      this.body = this.getBody(o, i);\n      this.afterBody = this.getAfterBody(o, i);\n      this.footer = this.getFooter(o, i);\n      const tooltipReplay = this._size = calculateTooltipDimensions(this, i);\n      const mergedContext = Object.assign({}, tooltipPosition, tooltipReplay);\n      const _tooltipPosition = alignElements(this.chart, i, mergedContext);\n      const __tooltipPosition = calculateTooltipPosition(i, mergedContext, _tooltipPosition, this.chart);\n      this.xAlign = _tooltipPosition.xAlign;\n      this.yAlign = _tooltipPosition.yAlign;\n      n = {\n        opacity: 1,\n        x: __tooltipPosition.x,\n        y: __tooltipPosition.y,\n        width: tooltipReplay.width,\n        height: tooltipReplay.height,\n        caretX: tooltipPosition.x,\n        caretY: tooltipPosition.y\n      };\n    } else if (this.opacity !== 0) {\n      n = {\n        opacity: 0\n      };\n    }\n    this._tooltipItems = o;\n    this.$context = undefined;\n    if (n) {\n      this._resolveAnimations().update(this, n);\n    }\n    if (t && i.external) {\n      i.external.call(this, {\n        chart: this.chart,\n        tooltip: this,\n        replay: e\n      });\n    }\n  }\n  drawCaret(caretXPosition, __________________canvasContext, caretIndex, caretString) {\n    const caretPosition = this.getCaretPosition(caretXPosition, caretIndex, caretString);\n    __________________canvasContext.lineTo(caretPosition.x1, caretPosition.y1);\n    __________________canvasContext.lineTo(caretPosition.x2, caretPosition.y2);\n    __________________canvasContext.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(t, e, i) {\n    const {\n      xAlign: s,\n      yAlign: n\n    } = this;\n    const {\n      caretSize: o,\n      cornerRadius: a\n    } = i;\n    const {\n      topLeft: r,\n      topRight: h,\n      bottomLeft: l,\n      bottomRight: c\n    } = elementBorderRadius(a);\n    const {\n      x: d,\n      y: u\n    } = t;\n    const {\n      width: g,\n      height: p\n    } = e;\n    let f;\n    let m;\n    let x;\n    let b;\n    let _;\n    let y;\n    if (n === \"center\") {\n      _ = u + p / 2;\n      if (s === \"left\") {\n        f = d;\n        m = f - o;\n        b = _ + o;\n        y = _ - o;\n      } else {\n        f = d + g;\n        m = f + o;\n        b = _ - o;\n        y = _ + o;\n      }\n      x = f;\n    } else {\n      if (s === \"left\") {\n        m = d + Math.max(r, l) + o;\n      } else if (s === \"right\") {\n        m = d + g - Math.max(h, c) - o;\n      } else {\n        m = this.caretX;\n      }\n      if (n === \"top\") {\n        b = u;\n        _ = b - o;\n        f = m - o;\n        x = m + o;\n      } else {\n        b = u + p;\n        _ = b + o;\n        f = m + o;\n        x = m - o;\n      }\n      y = b;\n    }\n    return {\n      x1: f,\n      x2: m,\n      x3: x,\n      y1: b,\n      y2: _,\n      y3: y\n    };\n  }\n  drawTitle(titlePosition, _____________________________canvasContext, currentCharacterIndex) {\n    const _titleText = this.title;\n    const titleTextLength = _titleText.length;\n    let _________animationFrameId;\n    let titleSpacing;\n    let ___________________currentIndex;\n    if (titleTextLength) {\n      const animationParams = __animationManager(currentCharacterIndex.rtl, this.x, this.width);\n      titlePosition.x = calculateAlignmentOffset(this, currentCharacterIndex.titleAlign, currentCharacterIndex);\n      _____________________________canvasContext.textAlign = animationParams.textAlign(currentCharacterIndex.titleAlign);\n      _____________________________canvasContext.textBaseline = \"middle\";\n      _________animationFrameId = requestAnimationFrame(currentCharacterIndex.titleFont);\n      titleSpacing = currentCharacterIndex.titleSpacing;\n      _____________________________canvasContext.fillStyle = currentCharacterIndex.titleColor;\n      _____________________________canvasContext.font = _________animationFrameId.string;\n      ___________________currentIndex = 0;\n      for (; ___________________currentIndex < titleTextLength; ++___________________currentIndex) {\n        _____________________________canvasContext.fillText(_titleText[___________________currentIndex], animationParams.x(titlePosition.x), titlePosition.y + _________animationFrameId.lineHeight / 2);\n        titlePosition.y += _________animationFrameId.lineHeight + titleSpacing;\n        if (___________________currentIndex + 1 === titleTextLength) {\n          titlePosition.y += currentCharacterIndex.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(t, e, i, s, o) {\n    const a = this.labelColors[i];\n    const r = this.labelPointStyles[i];\n    const {\n      boxHeight: h,\n      boxWidth: l\n    } = o;\n    const c = requestAnimationFrame(o.bodyFont);\n    const d = calculateAlignmentOffset(this, \"left\", o);\n    const u = s.x(d);\n    const g = h < c.lineHeight ? (c.lineHeight - h) / 2 : 0;\n    const p = e.y + g;\n    if (o.usePointStyle) {\n      const pointCoordinates = {\n        radius: Math.min(l, h) / 2,\n        pointStyle: r.pointStyle,\n        rotation: r.rotation,\n        borderWidth: 1\n      };\n      const labelIndex = s.leftForLtr(u, l) + l / 2;\n      const centerYPosition = p + h / 2;\n      t.strokeStyle = o.multiKeyBackground;\n      t.fillStyle = o.multiKeyBackground;\n      __animationStep(t, pointCoordinates, labelIndex, centerYPosition);\n      t.strokeStyle = a.borderColor;\n      t.fillStyle = a.backgroundColor;\n      __animationStep(t, pointCoordinates, labelIndex, centerYPosition);\n    } else {\n      t.lineWidth = currentAnimationIndex(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1;\n      t.strokeStyle = a.borderColor;\n      t.setLineDash(a.borderDash || []);\n      t.lineDashOffset = a.borderDashOffset || 0;\n      const pointPosition = s.leftForLtr(u, l);\n      const _labelIndex = s.leftForLtr(s.xPlus(u, 1), l - 2);\n      const labelPointStyle = elementBorderRadius(a.borderRadius);\n      if (Object.values(labelPointStyle).some(_isNonZero => _isNonZero !== 0)) {\n        t.beginPath();\n        t.fillStyle = o.multiKeyBackground;\n        ___animationController(t, {\n          x: pointPosition,\n          y: p,\n          w: l,\n          h: h,\n          radius: labelPointStyle\n        });\n        t.fill();\n        t.stroke();\n        t.fillStyle = a.backgroundColor;\n        t.beginPath();\n        ___animationController(t, {\n          x: _labelIndex,\n          y: p + 1,\n          w: l - 2,\n          h: h - 2,\n          radius: labelPointStyle\n        });\n        t.fill();\n      } else {\n        t.fillStyle = o.multiKeyBackground;\n        t.fillRect(pointPosition, p, l, h);\n        t.strokeRect(pointPosition, p, l, h);\n        t.fillStyle = a.backgroundColor;\n        t.fillRect(_labelIndex, p + 1, l - 2, h - 2);\n      }\n    }\n    t.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(t, e, i) {\n    const {\n      body: s\n    } = this;\n    const {\n      bodySpacing: n,\n      bodyAlign: o,\n      displayColors: a,\n      boxHeight: r,\n      boxWidth: h,\n      boxPadding: l\n    } = i;\n    const c = requestAnimationFrame(i.bodyFont);\n    let d = c.lineHeight;\n    let u = 0;\n    const g = __animationManager(i.rtl, this.x, this.width);\n    const p = function (i) {\n      e.fillText(i, g.x(t.x + u), t.y + d / 2);\n      t.y += d + n;\n    };\n    const f = g.textAlign(o);\n    let m;\n    let x;\n    let b;\n    let ____________currentIndex;\n    let _________________________________currentIndex;\n    let v;\n    let M;\n    e.textAlign = o;\n    e.textBaseline = \"middle\";\n    e.font = c.string;\n    t.x = calculateAlignmentOffset(this, f, i);\n    e.fillStyle = i.bodyColor;\n    __lastDateUpdated(this.beforeBody, p);\n    if (a && f !== \"right\") {\n      if (o === \"center\") {\n        u = h / 2 + l;\n      } else {\n        u = h + 2 + l;\n      }\n    } else {\n      u = 0;\n    }\n    ____________currentIndex = 0;\n    v = s.length;\n    for (; ____________currentIndex < v; ++____________currentIndex) {\n      m = s[____________currentIndex];\n      x = this.labelTextColors[____________currentIndex];\n      e.fillStyle = x;\n      __lastDateUpdated(m.before, p);\n      b = m.lines;\n      if (a && b.length) {\n        this._drawColorBox(e, t, ____________currentIndex, g, i);\n        d = Math.max(c.lineHeight, r);\n      }\n      _________________________________currentIndex = 0;\n      M = b.length;\n      for (; _________________________________currentIndex < M; ++_________________________________currentIndex) {\n        p(b[_________________________________currentIndex]);\n        d = c.lineHeight;\n      }\n      __lastDateUpdated(m.after, p);\n    }\n    u = 0;\n    d = c.lineHeight;\n    __lastDateUpdated(this.afterBody, p);\n    t.y -= n;\n  }\n  drawFooter(footerPosition, ___________________________canvasContext, footerData) {\n    const footerItems = this.footer;\n    const _footerItemCount = footerItems.length;\n    let _animationFrameRequest;\n    let _textIndex;\n    if (_footerItemCount) {\n      const _animationSettings = __animationManager(footerData.rtl, this.x, this.width);\n      footerPosition.x = calculateAlignmentOffset(this, footerData.footerAlign, footerData);\n      footerPosition.y += footerData.footerMarginTop;\n      ___________________________canvasContext.textAlign = _animationSettings.textAlign(footerData.footerAlign);\n      ___________________________canvasContext.textBaseline = \"middle\";\n      _animationFrameRequest = requestAnimationFrame(footerData.footerFont);\n      ___________________________canvasContext.fillStyle = footerData.footerColor;\n      ___________________________canvasContext.font = _animationFrameRequest.string;\n      _textIndex = 0;\n      for (; _textIndex < _footerItemCount; ++_textIndex) {\n        ___________________________canvasContext.fillText(footerItems[_textIndex], _animationSettings.x(footerPosition.x), footerPosition.y + _animationFrameRequest.lineHeight / 2);\n        footerPosition.y += _animationFrameRequest.lineHeight + footerData.footerSpacing;\n      }\n    }\n  }\n  drawBackground(t, e, i, s) {\n    const {\n      xAlign: n,\n      yAlign: o\n    } = this;\n    const {\n      x: a,\n      y: r\n    } = t;\n    const {\n      width: h,\n      height: l\n    } = i;\n    const {\n      topLeft: c,\n      topRight: d,\n      bottomLeft: u,\n      bottomRight: g\n    } = elementBorderRadius(s.cornerRadius);\n    e.fillStyle = s.backgroundColor;\n    e.strokeStyle = s.borderColor;\n    e.lineWidth = s.borderWidth;\n    e.beginPath();\n    e.moveTo(a + c, r);\n    if (o === \"top\") {\n      this.drawCaret(t, e, i, s);\n    }\n    e.lineTo(a + h - d, r);\n    e.quadraticCurveTo(a + h, r, a + h, r + d);\n    if (o === \"center\" && n === \"right\") {\n      this.drawCaret(t, e, i, s);\n    }\n    e.lineTo(a + h, r + l - g);\n    e.quadraticCurveTo(a + h, r + l, a + h - g, r + l);\n    if (o === \"bottom\") {\n      this.drawCaret(t, e, i, s);\n    }\n    e.lineTo(a + u, r + l);\n    e.quadraticCurveTo(a, r + l, a, r + l - u);\n    if (o === \"center\" && n === \"left\") {\n      this.drawCaret(t, e, i, s);\n    }\n    e.lineTo(a, r + c);\n    e.quadraticCurveTo(a, r, a + c, r);\n    e.closePath();\n    e.fill();\n    if (s.borderWidth > 0) {\n      e.stroke();\n    }\n  }\n  _updateAnimationTarget(t) {\n    const e = this.chart;\n    const _animations = this.$animations;\n    const s = _animations && _animations.x;\n    const n = _animations && _animations.y;\n    if (s || n) {\n      const animations = _____________animationController[t.position].call(this, this._active, this._eventPosition);\n      if (!animations) {\n        return;\n      }\n      const updatedSize = this._size = calculateTooltipDimensions(this, t);\n      const animationTargetProperties = Object.assign({}, animations, this._size);\n      const animationTargetData = alignElements(e, t, animationTargetProperties);\n      const newAnimationPosition = calculateTooltipPosition(t, animationTargetProperties, animationTargetData, e);\n      if (s._to !== newAnimationPosition.x || n._to !== newAnimationPosition.y) {\n        this.xAlign = animationTargetData.xAlign;\n        this.yAlign = animationTargetData.yAlign;\n        this.width = updatedSize.width;\n        this.height = updatedSize.height;\n        this.caretX = animations.x;\n        this.caretY = animations.y;\n        this._resolveAnimations().update(this, newAnimationPosition);\n      }\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(t) {\n    const e = this.options.setContext(this.getContext());\n    let i = this.opacity;\n    if (!i) {\n      return;\n    }\n    this._updateAnimationTarget(e);\n    const s = {\n      width: this.width,\n      height: this.height\n    };\n    const n = {\n      x: this.x,\n      y: this.y\n    };\n    if (Math.abs(i) < 0.001) {\n      i = 0;\n    } else {\n      i = i;\n    }\n    const o = __animationElement(e.padding);\n    const a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (e.enabled && a) {\n      t.save();\n      t.globalAlpha = i;\n      this.drawBackground(n, t, s, e);\n      chartRequestAnimationFrame(t, e.textDirection);\n      n.y += o.top;\n      this.drawTitle(n, t, e);\n      this.drawBody(n, t, e);\n      this.drawFooter(n, t, e);\n      chartAnimationController(t, e.textDirection);\n      t.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(_dataElements, _eventPosition) {\n    const ______datasetMeta = this._active;\n    const activeDataElements = _dataElements.map(({\n      datasetIndex: ___________datasetIndex,\n      index: dataElementIndex\n    }) => {\n      const _____datasetMeta = this.chart.getDatasetMeta(___________datasetIndex);\n      if (!_____datasetMeta) {\n        throw new Error(\"Cannot find a dataset at index \" + ___________datasetIndex);\n      }\n      return {\n        datasetIndex: ___________datasetIndex,\n        element: _____datasetMeta.data[dataElementIndex],\n        index: dataElementIndex\n      };\n    });\n    const isAnimationCompleted = !_animationController(______datasetMeta, activeDataElements);\n    const isPositionChanged = this._positionChanged(activeDataElements, _eventPosition);\n    if (isAnimationCompleted || isPositionChanged) {\n      this._active = activeDataElements;\n      this._eventPosition = _eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(eventPosition, _____eventObject, isInitialEvent = true) {\n    if (_____eventObject && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const _____________________options = this.options;\n    const ____activeElements = this._active || [];\n    const _____activeElements = this._getActiveElements(eventPosition, ____activeElements, _____eventObject, isInitialEvent);\n    const positionChanged = this._positionChanged(_____activeElements, eventPosition);\n    const shouldProcessEvent = _____eventObject || !_animationController(_____activeElements, ____activeElements) || positionChanged;\n    if (shouldProcessEvent) {\n      this._active = _____activeElements;\n      if (_____________________options.enabled || _____________________options.external) {\n        this._eventPosition = {\n          x: eventPosition.x,\n          y: eventPosition.y\n        };\n        this.update(true, _____eventObject);\n      }\n    }\n    return shouldProcessEvent;\n  }\n  _getActiveElements(___________________________event, eventElements, activeElementIndex, isEventProcessed) {\n    const ____optionsConfig = this.options;\n    if (___________________________event.type === \"mouseout\") {\n      return [];\n    }\n    if (!isEventProcessed) {\n      return eventElements;\n    }\n    const activeElements = this.chart.getElementsAtEventForMode(___________________________event, ____optionsConfig.mode, ____optionsConfig, activeElementIndex);\n    if (____optionsConfig.reverse) {\n      activeElements.reverse();\n    }\n    return activeElements;\n  }\n  _positionChanged(positionDelta, ______________________event) {\n    const {\n      caretX: _caretXPosition,\n      caretY: caretY,\n      options: __optionsConfig\n    } = this;\n    const newPosition = _____________animationController[__optionsConfig.position].call(this, positionDelta, ______________________event);\n    return newPosition !== false && (_caretXPosition !== newPosition.x || caretY !== newPosition.y);\n  }\n}\nvar ma = {\n  id: \"tooltip\",\n  _element: fa,\n  positioners: _____________animationController,\n  afterInit(chartObject, ___tooltipOptions, ____tooltipOptions) {\n    if (____tooltipOptions) {\n      chartObject.tooltip = new fa({\n        chart: chartObject,\n        options: ____tooltipOptions\n      });\n    }\n  },\n  beforeUpdate(__tooltipData, _tooltipInstance, tooltipInitializationIndex) {\n    if (__tooltipData.tooltip) {\n      __tooltipData.tooltip.initialize(tooltipInitializationIndex);\n    }\n  },\n  reset(___tooltipData, _____tooltipOptions, ____tooltipData) {\n    if (___tooltipData.tooltip) {\n      ___tooltipData.tooltip.initialize(____tooltipData);\n    }\n  },\n  afterDraw(_______chartInstance) {\n    const tooltipInstance = _______chartInstance.tooltip;\n    if (tooltipInstance && tooltipInstance._willRender()) {\n      const tooltipDrawData = {\n        tooltip: tooltipInstance\n      };\n      if (_______chartInstance.notifyPlugins(\"beforeTooltipDraw\", {\n        ...tooltipDrawData,\n        cancelable: true\n      }) === false) {\n        return;\n      }\n      tooltipInstance.draw(_______chartInstance.ctx);\n      _______chartInstance.notifyPlugins(\"afterTooltipDraw\", tooltipDrawData);\n    }\n  },\n  afterEvent(eventTooltip, eventDetails) {\n    if (eventTooltip.tooltip) {\n      const replayEvent = eventDetails.replay;\n      if (eventTooltip.tooltip.handleEvent(eventDetails.event, replayEvent, eventDetails.inChartArea)) {\n        eventDetails.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: \"average\",\n    backgroundColor: \"rgba(0,0,0,0.8)\",\n    titleColor: \"#fff\",\n    titleFont: {\n      weight: \"bold\"\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: \"left\",\n    bodyColor: \"#fff\",\n    bodySpacing: 2,\n    bodyFont: {},\n    bodyAlign: \"left\",\n    footerColor: \"#fff\",\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: \"bold\"\n    },\n    footerAlign: \"left\",\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (_textElement, bodyFontSize) => bodyFontSize.bodyFont.size,\n    boxWidth: (textSize, _bodyFontSize) => _bodyFontSize.bodyFont.size,\n    multiKeyBackground: \"#fff\",\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: \"rgba(0,0,0,0)\",\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: \"easeOutQuart\"\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"width\", \"height\", \"caretX\", \"caretY\"]\n      },\n      opacity: {\n        easing: \"linear\",\n        duration: 200\n      }\n    },\n    callbacks: chartUpdateState\n  },\n  defaultRoutes: {\n    bodyFont: \"font\",\n    footerFont: \"font\",\n    titleFont: \"font\"\n  },\n  descriptors: {\n    _scriptable: filterType => filterType !== \"filter\" && filterType !== \"itemSort\" && filterType !== \"external\",\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: \"animation\"\n    }\n  },\n  additionalOptionScopes: [\"interaction\"]\n};\nvar xa = Object.freeze({\n  __proto__: null,\n  Colors: _animationTaskId,\n  Decimation: ___isChartAnimationRunning,\n  Filler: _animationControllerInstance,\n  Legend: Uo,\n  SubTitle: qo,\n  Title: Go,\n  Tooltip: ma\n});\nconst _animationItems = (__elementList, _____________inputValue, pushedIndex, stringLabelList) => {\n  if (typeof _____________inputValue == \"string\") {\n    pushedIndex = __elementList.push(_____________inputValue) - 1;\n    stringLabelList.unshift({\n      index: pushedIndex,\n      label: _____________inputValue\n    });\n  } else if (isNaN(_____________inputValue)) {\n    pushedIndex = null;\n  }\n  return pushedIndex;\n};\nfunction findFirstOccurrence(targetString, searchElement, _animationIndex, searchString) {\n  const firstOccurrenceIndex = targetString.indexOf(searchElement);\n  if (firstOccurrenceIndex === -1) {\n    return _animationItems(targetString, searchElement, _animationIndex, searchString);\n  }\n  if (firstOccurrenceIndex !== targetString.lastIndexOf(searchElement)) {\n    return _animationIndex;\n  } else {\n    return firstOccurrenceIndex;\n  }\n}\nconst chartLabel = (durationInMilliseconds, animationFrameTime) => durationInMilliseconds === null ? null : chartAnimationState(Math.round(durationInMilliseconds), 0, animationFrameTime);\nfunction getLabelByIndex(___labelIndex) {\n  const labelsArray = this.getLabels();\n  if (___labelIndex >= 0 && ___labelIndex < labelsArray.length) {\n    return labelsArray[___labelIndex];\n  } else {\n    return ___labelIndex;\n  }\n}\nclass Ma extends fs {\n  static id = \"category\";\n  static defaults = {\n    ticks: {\n      callback: getLabelByIndex\n    }\n  };\n  constructor(_constructorParameter) {\n    super(_constructorParameter);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(initializationParameter) {\n    const addedLabels = this._addedLabels;\n    if (addedLabels.length) {\n      const labelsToRemove = this.getLabels();\n      for (const {\n        index: __labelIndex,\n        label: _label\n      } of addedLabels) {\n        if (labelsToRemove[__labelIndex] === _label) {\n          labelsToRemove.splice(__labelIndex, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(initializationParameter);\n  }\n  parse(labelToParse, _______labelIndex) {\n    if (chartUpdateInterval(labelToParse)) {\n      return null;\n    }\n    const _labelsArray = this.getLabels();\n    if (isFinite(_______labelIndex) && _labelsArray[_______labelIndex] === labelToParse) {\n      _______labelIndex = _______labelIndex;\n    } else {\n      _______labelIndex = findFirstOccurrence(_labelsArray, labelToParse, chartAnimationRunning(_______labelIndex, labelToParse), this._addedLabels);\n    }\n    return chartLabel(_______labelIndex, _labelsArray.length - 1);\n  }\n  determineDataLimits() {\n    const {\n      minDefined: minDefinedValue,\n      maxDefined: maxDefinedUserBound\n    } = this.getUserBounds();\n    let {\n      min: _______minValue,\n      max: maxDefinedValue\n    } = this.getMinMax(true);\n    if (this.options.bounds === \"ticks\") {\n      if (!minDefinedValue) {\n        _______minValue = 0;\n      }\n      if (!maxDefinedUserBound) {\n        maxDefinedValue = this.getLabels().length - 1;\n      }\n    }\n    this.min = _______minValue;\n    this.max = maxDefinedValue;\n  }\n  buildTicks() {\n    const startValueIndex = this.min;\n    const ________maxValue = this.max;\n    const _____currentValue = this.options.offset;\n    const __tickValues = [];\n    let _labelCount = this.getLabels();\n    if (startValueIndex === 0 && ________maxValue === _labelCount.length - 1) {\n      _labelCount = _labelCount;\n    } else {\n      _labelCount = _labelCount.slice(startValueIndex, ________maxValue + 1);\n    }\n    this._valueRange = Math.max(_labelCount.length - (_____currentValue ? 0 : 1), 1);\n    this._startValue = this.min - (_____currentValue ? 0.5 : 0);\n    for (let ____currentValue = startValueIndex; ____currentValue <= ________maxValue; ____currentValue++) {\n      __tickValues.push({\n        value: ____currentValue\n      });\n    }\n    return __tickValues;\n  }\n  getLabelForValue(valueIndex) {\n    return getLabelByIndex.call(this, valueIndex);\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(_valueForPixel) {\n    if (typeof _valueForPixel != \"number\") {\n      _valueForPixel = this.parse(_valueForPixel);\n    }\n    if (_valueForPixel === null) {\n      return NaN;\n    } else {\n      return this.getPixelForDecimal((_valueForPixel - this._startValue) / this._valueRange);\n    }\n  }\n  getPixelForTick(______tickIndex) {\n    const _ticksArray = this.ticks;\n    if (______tickIndex < 0 || ______tickIndex > _ticksArray.length - 1) {\n      return null;\n    } else {\n      return this.getPixelForValue(_ticksArray[______tickIndex].value);\n    }\n  }\n  getValueForPixel(_pixelPosition) {\n    return Math.round(this._startValue + this.getDecimalForPixel(_pixelPosition) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nfunction calculateIntervalValues(inputParams, range) {\n  const calculatedIntervalValues = [];\n  const {\n    bounds: boundsType,\n    step: stepSize,\n    min: __minValue,\n    max: _maxValue,\n    precision: decimalPrecision,\n    count: intervalCount,\n    maxTicks: maxTicksAllowed,\n    maxDigits: maxDigits,\n    includeBounds: includeBounds\n  } = inputParams;\n  const _stepSize = stepSize || 1;\n  const maxTicksAdjusted = maxTicksAllowed - 1;\n  const {\n    min: rangeMin,\n    max: _maxRangeValue\n  } = range;\n  const isStartInterval = !chartUpdateInterval(__minValue);\n  const isMaxBoundUpdated = !chartUpdateInterval(_maxValue);\n  const isMaxCountValid = !chartUpdateInterval(intervalCount);\n  const intervalStepSize = (_maxRangeValue - rangeMin) / (maxDigits + 1);\n  let stepValue;\n  let __lowerBound;\n  let __maxValue;\n  let _intervalCount;\n  let intervalValue = __animationHandler((_maxRangeValue - rangeMin) / maxTicksAdjusted / _stepSize) * _stepSize;\n  if (intervalValue < 1e-14 && !isStartInterval && !isMaxBoundUpdated) {\n    return [{\n      value: rangeMin\n    }, {\n      value: _maxRangeValue\n    }];\n  }\n  _intervalCount = Math.ceil(_maxRangeValue / intervalValue) - Math.floor(rangeMin / intervalValue);\n  if (_intervalCount > maxTicksAdjusted) {\n    intervalValue = __animationHandler(_intervalCount * intervalValue / maxTicksAdjusted / _stepSize) * _stepSize;\n  }\n  if (!chartUpdateInterval(decimalPrecision)) {\n    stepValue = Math.pow(10, decimalPrecision);\n    intervalValue = Math.ceil(intervalValue * stepValue) / stepValue;\n  }\n  if (boundsType === \"ticks\") {\n    __lowerBound = Math.floor(rangeMin / intervalValue) * intervalValue;\n    __maxValue = Math.ceil(_maxRangeValue / intervalValue) * intervalValue;\n  } else {\n    __lowerBound = rangeMin;\n    __maxValue = _maxRangeValue;\n  }\n  if (isStartInterval && isMaxBoundUpdated && stepSize && __requestAnimationFrame((_maxValue - __minValue) / stepSize, intervalValue / 1000)) {\n    _intervalCount = Math.round(Math.min((_maxValue - __minValue) / intervalValue, maxTicksAllowed));\n    intervalValue = (_maxValue - __minValue) / _intervalCount;\n    __lowerBound = __minValue;\n    __maxValue = _maxValue;\n  } else if (isMaxCountValid) {\n    if (isStartInterval) {\n      __lowerBound = __minValue;\n    } else {\n      __lowerBound = __lowerBound;\n    }\n    if (isMaxBoundUpdated) {\n      __maxValue = _maxValue;\n    } else {\n      __maxValue = __maxValue;\n    }\n    _intervalCount = intervalCount - 1;\n    intervalValue = (__maxValue - __lowerBound) / _intervalCount;\n  } else {\n    _intervalCount = (__maxValue - __lowerBound) / intervalValue;\n    if (tooltipVisible(_intervalCount, Math.round(_intervalCount), intervalValue / 1000)) {\n      _intervalCount = Math.round(_intervalCount);\n    } else {\n      _intervalCount = Math.ceil(_intervalCount);\n    }\n  }\n  const maxTooltipOption = Math.max(tooltipOptions(intervalValue), tooltipOptions(__lowerBound));\n  stepValue = Math.pow(10, chartUpdateInterval(decimalPrecision) ? maxTooltipOption : decimalPrecision);\n  __lowerBound = Math.round(__lowerBound * stepValue) / stepValue;\n  __maxValue = Math.round(__maxValue * stepValue) / stepValue;\n  let numIntervals = 0;\n  for (isStartInterval && (includeBounds && __lowerBound !== __minValue ? (calculatedIntervalValues.push({\n    value: __minValue\n  }), __lowerBound < __minValue && numIntervals++, tooltipVisible(Math.round((__lowerBound + numIntervals * intervalValue) * stepValue) / stepValue, __minValue, calculateAnimation(__minValue, intervalStepSize, inputParams)) && numIntervals++) : __lowerBound < __minValue && numIntervals++); numIntervals < _intervalCount; ++numIntervals) {\n    const calculatedValue = Math.round((__lowerBound + numIntervals * intervalValue) * stepValue) / stepValue;\n    if (isMaxBoundUpdated && calculatedValue > _maxValue) {\n      break;\n    }\n    calculatedIntervalValues.push({\n      value: calculatedValue\n    });\n  }\n  if (isMaxBoundUpdated && includeBounds && __maxValue !== _maxValue) {\n    if (calculatedIntervalValues.length && tooltipVisible(calculatedIntervalValues[calculatedIntervalValues.length - 1].value, _maxValue, calculateAnimation(_maxValue, intervalStepSize, inputParams))) {\n      calculatedIntervalValues[calculatedIntervalValues.length - 1].value = _maxValue;\n    } else {\n      calculatedIntervalValues.push({\n        value: _maxValue\n      });\n    }\n  } else if (!isMaxBoundUpdated || __maxValue === _maxValue) {\n    calculatedIntervalValues.push({\n      value: __maxValue\n    });\n  }\n  return calculatedIntervalValues;\n}\nfunction calculateAnimation(____inputValue, angleValue, {\n  horizontal: isHorizontalAnimationEnabled,\n  minRotation: minRotationDegrees\n}) {\n  const animationProgress = requestAnimation(minRotationDegrees);\n  const trigonometricValue = (isHorizontalAnimationEnabled ? Math.sin(animationProgress) : Math.cos(animationProgress)) || 0.001;\n  const maxAnimationValue = angleValue * 0.75 * (\"\" + ____inputValue).length;\n  return Math.min(angleValue / trigonometricValue, maxAnimationValue);\n}\nclass Sa extends fs {\n  constructor(__initialValue) {\n    super(__initialValue);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(_________inputValue, inputParsingOptions) {\n    if (chartUpdateInterval(_________inputValue) || (typeof _________inputValue == \"number\" || _________inputValue instanceof Number) && !isFinite(+_________inputValue)) {\n      return null;\n    } else {\n      return +_________inputValue;\n    }\n  }\n  handleTickRangeOptions() {\n    const {\n      beginAtZero: _beginAtZero\n    } = this.options;\n    const {\n      minDefined: minDefined,\n      maxDefined: maxBoundary\n    } = this.getUserBounds();\n    let {\n      min: _________minValue,\n      max: _________maxValue\n    } = this;\n    const setMinIfNotDefined = fallbackValue => _________minValue = minDefined ? _________minValue : fallbackValue;\n    const updateMaxValue = tempValue => _________maxValue = maxBoundary ? _________maxValue : tempValue;\n    if (_beginAtZero) {\n      const beginAtZero = isPathClosed(_________minValue);\n      const isMinDefined = isPathClosed(_________maxValue);\n      if (beginAtZero < 0 && isMinDefined < 0) {\n        updateMaxValue(0);\n      } else if (beginAtZero > 0 && isMinDefined > 0) {\n        setMinIfNotDefined(0);\n      }\n    }\n    if (_________minValue === _________maxValue) {\n      let _isMinDefined = _________maxValue === 0 ? 1 : Math.abs(_________maxValue * 0.05);\n      updateMaxValue(_________maxValue + _isMinDefined);\n      if (!_beginAtZero) {\n        setMinIfNotDefined(_________minValue - _isMinDefined);\n      }\n    }\n    this.min = _________minValue;\n    this.max = _________maxValue;\n  }\n  getTickLimit() {\n    const ticksOptions = this.options.ticks;\n    let ____tickCount;\n    let {\n      maxTicksLimit: _maxTicksLimit,\n      stepSize: __stepSize\n    } = ticksOptions;\n    if (__stepSize) {\n      ____tickCount = Math.ceil(this.max / __stepSize) - Math.floor(this.min / __stepSize) + 1;\n      if (____tickCount > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${__stepSize} would result generating up to ${____tickCount} ticks. Limiting to 1000.`);\n        ____tickCount = 1000;\n      }\n    } else {\n      ____tickCount = this.computeTickLimit();\n      _maxTicksLimit = _maxTicksLimit || 11;\n    }\n    if (_maxTicksLimit) {\n      ____tickCount = Math.min(_maxTicksLimit, ____tickCount);\n    }\n    return ____tickCount;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const t = this.options;\n    const e = t.ticks;\n    let i = this.getTickLimit();\n    i = Math.max(2, i);\n    const s = calculateIntervalValues({\n      maxTicks: i,\n      bounds: t.bounds,\n      min: t.min,\n      max: t.max,\n      precision: e.precision,\n      step: e.stepSize,\n      count: e.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: e.minRotation || 0,\n      includeBounds: e.includeBounds !== false\n    }, this._range || this);\n    if (t.bounds === \"ticks\") {\n      _animationHandler(s, this, \"value\");\n    }\n    if (t.reverse) {\n      s.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return s;\n  }\n  configure() {\n    const _tickValues = this.ticks;\n    let _____startValue = this.min;\n    let ______maxValue = this.max;\n    super.configure();\n    if (this.options.offset && _tickValues.length) {\n      const tickSpacing = (______maxValue - _____startValue) / Math.max(_tickValues.length - 1, 1) / 2;\n      _____startValue -= tickSpacing;\n      ______maxValue += tickSpacing;\n    }\n    this._startValue = _____startValue;\n    this._endValue = ______maxValue;\n    this._valueRange = ______maxValue - _____startValue;\n  }\n  getLabelForValue(chartAnimationDuration) {\n    return _isChartAnimationRunning(chartAnimationDuration, this.chart.options.locale, this.options.ticks.format);\n  }\n}\nclass Da extends Sa {\n  static id = \"linear\";\n  static defaults = {\n    ticks: {\n      callback: tooltipActiveElements.formatters.numeric\n    }\n  };\n  determineDataLimits() {\n    const {\n      min: minDataLimit,\n      max: maxDataLimit\n    } = this.getMinMax(true);\n    this.min = chartUpdateTrigger(minDataLimit) ? minDataLimit : 0;\n    this.max = chartUpdateTrigger(maxDataLimit) ? maxDataLimit : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const isHorizontalOrientation = this.isHorizontal();\n    const tickLimitDimension = isHorizontalOrientation ? this.width : this.height;\n    const minRotationAnimation = requestAnimation(this.options.ticks.minRotation);\n    const tickRotationAdjustment = (isHorizontalOrientation ? Math.sin(minRotationAnimation) : Math.cos(minRotationAnimation)) || 0.001;\n    const resolvedTickFontOptions = this._resolveTickFontOptions(0);\n    return Math.ceil(tickLimitDimension / Math.min(40, resolvedTickFontOptions.lineHeight / tickRotationAdjustment));\n  }\n  getPixelForValue(valueForPixel) {\n    if (valueForPixel === null) {\n      return NaN;\n    } else {\n      return this.getPixelForDecimal((valueForPixel - this._startValue) / this._valueRange);\n    }\n  }\n  getValueForPixel(pixelPosition) {\n    return this._startValue + this.getDecimalForPixel(pixelPosition) * this._valueRange;\n  }\n}\nconst animationProgressIndex = __elapsedTime => Math.floor(___animationManager(__elapsedTime));\nconst animationCounter = (animationTime, animationOffset) => Math.pow(10, animationProgressIndex(animationTime) + animationOffset);\nfunction isNumberAtAnimationProgress(numberToCheck) {\n  return numberToCheck / Math.pow(10, animationProgressIndex(numberToCheck)) === 1;\n}\nfunction calculateDifference(___________inputValue, dividend, exponentPower) {\n  const _scalingFactor = Math.pow(10, exponentPower);\n  const dividendQuotient = Math.floor(___________inputValue / _scalingFactor);\n  return Math.ceil(dividend / _scalingFactor) - dividendQuotient;\n}\nfunction calculateIncrementalAdjustment(___startValue, ___endValue) {\n  let incrementalAdjustment = animationProgressIndex(___endValue - ___startValue);\n  while (calculateDifference(___startValue, ___endValue, incrementalAdjustment) > 10) {\n    incrementalAdjustment++;\n  }\n  while (calculateDifference(___startValue, ___endValue, incrementalAdjustment) < 10) {\n    incrementalAdjustment--;\n  }\n  return Math.min(incrementalAdjustment, animationProgressIndex(___startValue));\n}\nfunction calculateValueRange(value, {\n  min: currentMinValue,\n  max: ___maxValue\n}) {\n  currentMinValue = __tooltipHandler(value.min, currentMinValue);\n  const valueRangeArray = [];\n  const _animationProgressIndex = animationProgressIndex(currentMinValue);\n  let exponent = calculateIncrementalAdjustment(currentMinValue, ___maxValue);\n  let incrementScalingFactor = exponent < 0 ? Math.pow(10, Math.abs(exponent)) : 1;\n  const baseValue = Math.pow(10, exponent);\n  const currentPowerOfTen = _animationProgressIndex > exponent ? Math.pow(10, _animationProgressIndex) : 0;\n  const roundedValue = Math.round((currentMinValue - currentPowerOfTen) * incrementScalingFactor) / incrementScalingFactor;\n  const baseIncrementValue = Math.floor((currentMinValue - currentPowerOfTen) / baseValue / 10) * baseValue * 10;\n  let significandValue = Math.floor((roundedValue - baseIncrementValue) / Math.pow(10, exponent));\n  let ________currentValue = __tooltipHandler(value.min, Math.round((currentPowerOfTen + baseIncrementValue + significandValue * Math.pow(10, exponent)) * incrementScalingFactor) / incrementScalingFactor);\n  while (________currentValue < ___maxValue) {\n    valueRangeArray.push({\n      value: ________currentValue,\n      major: isNumberAtAnimationProgress(________currentValue),\n      significand: significandValue\n    });\n    if (significandValue >= 10) {\n      if (significandValue < 15) {\n        significandValue = 15;\n      } else {\n        significandValue = 20;\n      }\n    } else {\n      significandValue++;\n    }\n    if (significandValue >= 20) {\n      exponent++;\n      significandValue = 2;\n      if (exponent >= 0) {\n        incrementScalingFactor = 1;\n      } else {\n        incrementScalingFactor = incrementScalingFactor;\n      }\n    }\n    ________currentValue = Math.round((currentPowerOfTen + baseIncrementValue + significandValue * Math.pow(10, exponent)) * incrementScalingFactor) / incrementScalingFactor;\n  }\n  const maxValueWithTooltip = __tooltipHandler(value.max, ________currentValue);\n  valueRangeArray.push({\n    value: maxValueWithTooltip,\n    major: isNumberAtAnimationProgress(maxValueWithTooltip),\n    significand: significandValue\n  });\n  return valueRangeArray;\n}\nclass Ta extends fs {\n  static id = \"logarithmic\";\n  static defaults = {\n    ticks: {\n      callback: tooltipActiveElements.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n  constructor(_initialValue) {\n    super(_initialValue);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(__________inputData, parserOptions) {\n    const ______parsedData = Sa.prototype.parse.apply(this, [__________inputData, parserOptions]);\n    if (______parsedData !== 0) {\n      if (chartUpdateTrigger(______parsedData) && ______parsedData > 0) {\n        return ______parsedData;\n      } else {\n        return null;\n      }\n    }\n    this._zero = true;\n  }\n  determineDataLimits() {\n    const {\n      min: _minDataLimit,\n      max: _______maxValue\n    } = this.getMinMax(true);\n    this.min = chartUpdateTrigger(_minDataLimit) ? Math.max(0, _minDataLimit) : null;\n    this.max = chartUpdateTrigger(_______maxValue) ? Math.max(0, _______maxValue) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    if (this._zero && this.min !== this._suggestedMin && !chartUpdateTrigger(this._userMin)) {\n      this.min = _minDataLimit === animationCounter(this.min, 0) ? animationCounter(this.min, -1) : animationCounter(this.min, 0);\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {\n      minDefined: minValueDefined,\n      maxDefined: maxDefined\n    } = this.getUserBounds();\n    let currentMin = this.min;\n    let currentMaxValue = this.max;\n    const setMinIfUndefined = _______________event => currentMin = minValueDefined ? currentMin : _______________event;\n    const adjustMax = _fallbackValue => currentMaxValue = maxDefined ? currentMaxValue : _fallbackValue;\n    if (currentMin === currentMaxValue) {\n      if (currentMin <= 0) {\n        setMinIfUndefined(1);\n        adjustMax(10);\n      } else {\n        setMinIfUndefined(animationCounter(currentMin, -1));\n        adjustMax(animationCounter(currentMaxValue, 1));\n      }\n    }\n    if (currentMin <= 0) {\n      setMinIfUndefined(animationCounter(currentMaxValue, -1));\n    }\n    if (currentMaxValue <= 0) {\n      adjustMax(animationCounter(currentMin, 1));\n    }\n    this.min = currentMin;\n    this.max = currentMaxValue;\n  }\n  buildTicks() {\n    const _____tickOptions = this.options;\n    const valueRange = calculateValueRange({\n      min: this._userMin,\n      max: this._userMax\n    }, this);\n    if (_____tickOptions.bounds === \"ticks\") {\n      _animationHandler(valueRange, this, \"value\");\n    }\n    if (_____tickOptions.reverse) {\n      valueRange.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return valueRange;\n  }\n  getLabelForValue(_____value) {\n    if (_____value === undefined) {\n      return \"0\";\n    } else {\n      return _isChartAnimationRunning(_____value, this.chart.options.locale, this.options.ticks.format);\n    }\n  }\n  configure() {\n    const ____minValue = this.min;\n    super.configure();\n    this._startValue = ___animationManager(____minValue);\n    this._valueRange = ___animationManager(this.max) - ___animationManager(____minValue);\n  }\n  getPixelForValue(_______pixelValue) {\n    if (_______pixelValue === undefined || _______pixelValue === 0) {\n      _______pixelValue = this.min;\n    }\n    if (_______pixelValue === null || isNaN(_______pixelValue)) {\n      return NaN;\n    } else {\n      return this.getPixelForDecimal(_______pixelValue === this.min ? 0 : (___animationManager(_______pixelValue) - this._startValue) / this._valueRange);\n    }\n  }\n  getValueForPixel(___pixelValue) {\n    const _decimalValue = this.getDecimalForPixel(___pixelValue);\n    return Math.pow(10, this._startValue + _decimalValue * this._valueRange);\n  }\n}\nfunction calculateChartPadding(chartTicks) {\n  const chartTicksObject = chartTicks.ticks;\n  if (chartTicksObject.display && chartTicks.display) {\n    const backdropPaddingHeight = __animationElement(chartTicksObject.backdropPadding);\n    return chartAnimationRunning(chartTicksObject.font && chartTicksObject.font.size, animationDuration.font.size) + backdropPaddingHeight.height;\n  }\n  return 0;\n}\nfunction getChartDimensions(______animationDuration, _____chartConfig, chartItem) {\n  if (animatedChartItems(chartItem)) {\n    chartItem = chartItem;\n  } else {\n    chartItem = [chartItem];\n  }\n  return {\n    w: ____animationController(______animationDuration, _____chartConfig.string, chartItem),\n    h: chartItem.length * _____chartConfig.lineHeight\n  };\n}\nfunction calculateRange(_targetValue, referencePoint, __width, thresholdValue, boundaryValue) {\n  if (_targetValue === thresholdValue || _targetValue === boundaryValue) {\n    return {\n      start: referencePoint - __width / 2,\n      end: referencePoint + __width / 2\n    };\n  } else if (_targetValue < thresholdValue || _targetValue > boundaryValue) {\n    return {\n      start: referencePoint - __width,\n      end: referencePoint\n    };\n  } else {\n    return {\n      start: referencePoint,\n      end: referencePoint + __width\n    };\n  }\n}\nfunction generateChartPointLabels(____chartData) {\n  const _______boundingBox = {\n    l: ____chartData.left + ____chartData._padding.left,\n    r: ____chartData.right - ____chartData._padding.right,\n    t: ____chartData.top + ____chartData._padding.top,\n    b: ____chartData.bottom - ____chartData._padding.bottom\n  };\n  const ________boundingBox = Object.assign({}, _______boundingBox);\n  const pointLabelDimensionsArray = [];\n  const pointLabelPadding = [];\n  const pointLabelCount = ____chartData._pointLabels.length;\n  const pointLabelOptions = ____chartData.options.pointLabels;\n  const offsetCenterPointLabel = pointLabelOptions.centerPointLabels ? notificationListener / pointLabelCount : 0;\n  for (let currentPointIndex = 0; currentPointIndex < pointLabelCount; currentPointIndex++) {\n    const pointCount = pointLabelOptions.setContext(____chartData.getPointLabelContext(currentPointIndex));\n    pointLabelPadding[currentPointIndex] = pointCount.padding;\n    const __pointPosition = ____chartData.getPointPosition(currentPointIndex, ____chartData.drawingArea + pointLabelPadding[currentPointIndex], offsetCenterPointLabel);\n    const fontAnimationFrameId = requestAnimationFrame(pointCount.font);\n    const pointLabelDimensions = getChartDimensions(____chartData.ctx, fontAnimationFrameId, ____chartData._pointLabels[currentPointIndex]);\n    pointLabelDimensionsArray[currentPointIndex] = pointLabelDimensions;\n    const animationRefreshRateValue = animationRefreshRate(____chartData.getIndexAngle(currentPointIndex) + offsetCenterPointLabel);\n    const roundedAnimationRefreshRate = Math.round(_____animationState(animationRefreshRateValue));\n    adjustBoundingBox(________boundingBox, _______boundingBox, animationRefreshRateValue, calculateRange(roundedAnimationRefreshRate, __pointPosition.x, pointLabelDimensions.w, 0, 180), calculateRange(roundedAnimationRefreshRate, __pointPosition.y, pointLabelDimensions.h, 90, 270));\n  }\n  ____chartData.setCenterPoint(_______boundingBox.l - ________boundingBox.l, ________boundingBox.r - _______boundingBox.r, _______boundingBox.t - ________boundingBox.t, ________boundingBox.b - _______boundingBox.b);\n  ____chartData._pointLabelItems = calculateLabelPositions(____chartData, pointLabelDimensionsArray, pointLabelPadding);\n}\nfunction adjustBoundingBox(__boundingBox, elementBounds, angleInRadians, ___boundingBox, adjustmentArea) {\n  const sinAdjustmentFactor = Math.abs(Math.sin(angleInRadians));\n  const cosineAdjustmentFactor = Math.abs(Math.cos(angleInRadians));\n  let horizontalAdjustment = 0;\n  let heightAdjustment = 0;\n  if (___boundingBox.start < elementBounds.l) {\n    horizontalAdjustment = (elementBounds.l - ___boundingBox.start) / sinAdjustmentFactor;\n    __boundingBox.l = Math.min(__boundingBox.l, elementBounds.l - horizontalAdjustment);\n  } else if (___boundingBox.end > elementBounds.r) {\n    horizontalAdjustment = (___boundingBox.end - elementBounds.r) / sinAdjustmentFactor;\n    __boundingBox.r = Math.max(__boundingBox.r, elementBounds.r + horizontalAdjustment);\n  }\n  if (adjustmentArea.start < elementBounds.t) {\n    heightAdjustment = (elementBounds.t - adjustmentArea.start) / cosineAdjustmentFactor;\n    __boundingBox.t = Math.min(__boundingBox.t, elementBounds.t - heightAdjustment);\n  } else if (adjustmentArea.end > elementBounds.b) {\n    heightAdjustment = (adjustmentArea.end - elementBounds.b) / cosineAdjustmentFactor;\n    __boundingBox.b = Math.max(__boundingBox.b, elementBounds.b + heightAdjustment);\n  }\n}\nfunction calculateDrawingPosition(drawingObject, pointIndex, drawingProperties) {\n  const drawingArea = drawingObject.drawingArea;\n  const {\n    extra: extraPadding,\n    additionalAngle: additionalRotationAngle,\n    padding: _paddingValue,\n    size: sizeDimensions\n  } = drawingProperties;\n  const ___pointPosition = drawingObject.getPointPosition(pointIndex, drawingArea + extraPadding + _paddingValue, additionalRotationAngle);\n  const roundedAnimationState = Math.round(_____animationState(animationRefreshRate(___pointPosition.angle + currentFrameTimestamp)));\n  const adjustedYCoordinate = adjustedValue(___pointPosition.y, sizeDimensions.h, roundedAnimationState);\n  const __textAlignment = getAlignmentPosition(roundedAnimationState);\n  const adjustedLeftPosition = _adjustedPosition(___pointPosition.x, sizeDimensions.w, __textAlignment);\n  return {\n    visible: true,\n    x: ___pointPosition.x,\n    y: adjustedYCoordinate,\n    textAlign: __textAlignment,\n    left: adjustedLeftPosition,\n    top: adjustedYCoordinate,\n    right: adjustedLeftPosition + sizeDimensions.w,\n    bottom: adjustedYCoordinate + sizeDimensions.h\n  };\n}\nfunction _________________________________chartData(rectangleDimensions, ________________chartData) {\n  if (!________________chartData) {\n    return true;\n  }\n  const {\n    left: rectangleLeft,\n    top: _topPosition,\n    right: rightEdge,\n    bottom: bottomCoordinate\n  } = rectangleDimensions;\n  return !chartUpdater({\n    x: rectangleLeft,\n    y: _topPosition\n  }, ________________chartData) && !chartUpdater({\n    x: rectangleLeft,\n    y: bottomCoordinate\n  }, ________________chartData) && !chartUpdater({\n    x: rightEdge,\n    y: _topPosition\n  }, ________________chartData) && !chartUpdater({\n    x: rightEdge,\n    y: bottomCoordinate\n  }, ________________chartData);\n}\nfunction calculateLabelPositions(__________chartData, pointLabelSizes, _labelPadding) {\n  const labelPositions = [];\n  const _numberOfPointLabels = __________chartData._pointLabels.length;\n  const ________________________________________________________________index = __________chartData.options;\n  const {\n    centerPointLabels: shouldCenterPointLabels,\n    display: _displayOption\n  } = ________________________________________________________________index.pointLabels;\n  const labelPositionConfig = {\n    extra: calculateChartPadding(________________________________________________________________index) / 2,\n    additionalAngle: shouldCenterPointLabels ? notificationListener / _numberOfPointLabels : 0\n  };\n  let lastVisibleLabelPoint;\n  for (let ____labelIndex = 0; ____labelIndex < _numberOfPointLabels; ____labelIndex++) {\n    labelPositionConfig.padding = _labelPadding[____labelIndex];\n    labelPositionConfig.size = pointLabelSizes[____labelIndex];\n    const labelPoint = calculateDrawingPosition(__________chartData, ____labelIndex, labelPositionConfig);\n    labelPositions.push(labelPoint);\n    if (_displayOption === \"auto\") {\n      labelPoint.visible = _________________________________chartData(labelPoint, lastVisibleLabelPoint);\n      if (labelPoint.visible) {\n        lastVisibleLabelPoint = labelPoint;\n      }\n    }\n  }\n  return labelPositions;\n}\nfunction getAlignmentPosition(angleInDegrees) {\n  if (angleInDegrees === 0 || angleInDegrees === 180) {\n    return \"center\";\n  } else if (angleInDegrees < 180) {\n    return \"left\";\n  } else {\n    return \"right\";\n  }\n}\nfunction _adjustedPosition(positionOffset, ___offsetValue, alignmentPosition) {\n  if (alignmentPosition === \"right\") {\n    positionOffset -= ___offsetValue;\n  } else if (alignmentPosition === \"center\") {\n    positionOffset -= ___offsetValue / 2;\n  }\n  return positionOffset;\n}\nfunction adjustedValue(adjustedPosition, __offsetValue, angleDegrees) {\n  if (angleDegrees === 90 || angleDegrees === 270) {\n    adjustedPosition -= __offsetValue / 2;\n  } else if (angleDegrees > 270 || angleDegrees < 90) {\n    adjustedPosition -= __offsetValue;\n  }\n  return adjustedPosition;\n}\nfunction drawChartBackdrop(____canvasContext, chartOptions, _boundingBox) {\n  const {\n    left: boundingBoxLeft,\n    top: ___topPosition,\n    right: rightBound,\n    bottom: _rectangleHeight\n  } = _boundingBox;\n  const {\n    backdropColor: backdropColor\n  } = chartOptions;\n  if (!chartUpdateInterval(backdropColor)) {\n    const borderRadiusValue = elementBorderRadius(chartOptions.borderRadius);\n    const animationPadding = __animationElement(chartOptions.backdropPadding);\n    ____canvasContext.fillStyle = backdropColor;\n    const leftMarginAdjusted = boundingBoxLeft - animationPadding.left;\n    const topLeftY = ___topPosition - animationPadding.top;\n    const rectWidth = rightBound - boundingBoxLeft + animationPadding.width;\n    const rectangleHeight = _rectangleHeight - ___topPosition + animationPadding.height;\n    if (Object.values(borderRadiusValue).some(isNotZero => isNotZero !== 0)) {\n      ____canvasContext.beginPath();\n      ___animationController(____canvasContext, {\n        x: leftMarginAdjusted,\n        y: topLeftY,\n        w: rectWidth,\n        h: rectangleHeight,\n        radius: borderRadiusValue\n      });\n      ____canvasContext.fill();\n    } else {\n      ____canvasContext.fillRect(leftMarginAdjusted, topLeftY, rectWidth, rectangleHeight);\n    }\n  }\n}\nfunction drawChartWithPointLabels(_________chartData, numberOfPointLabels) {\n  const {\n    ctx: _chartContext,\n    options: {\n      pointLabels: pointLabelStyle\n    }\n  } = _________chartData;\n  for (let ____pointLabelIndex = numberOfPointLabels - 1; ____pointLabelIndex >= 0; ____pointLabelIndex--) {\n    const pointLabelItem = _________chartData._pointLabelItems[____pointLabelIndex];\n    if (!pointLabelItem.visible) {\n      continue;\n    }\n    const _pointLabelContext = pointLabelStyle.setContext(_________chartData.getPointLabelContext(____pointLabelIndex));\n    drawChartBackdrop(_chartContext, _pointLabelContext, pointLabelItem);\n    const animationFrameId = requestAnimationFrame(_pointLabelContext.font);\n    const {\n      x: pointLabelXCoordinate,\n      y: labelYPosition,\n      textAlign: _textAlignment\n    } = pointLabelItem;\n    Z(_chartContext, _________chartData._pointLabels[____pointLabelIndex], pointLabelXCoordinate, labelYPosition + animationFrameId.lineHeight / 2, animationFrameId, {\n      color: _pointLabelContext.color,\n      textAlign: _textAlignment,\n      textBaseline: \"middle\"\n    });\n  }\n}\nfunction drawCircle(circleParameters, radius, shouldAnimate, numSegments) {\n  const {\n    ctx: _______________________canvasContext\n  } = circleParameters;\n  if (shouldAnimate) {\n    _______________________canvasContext.arc(circleParameters.xCenter, circleParameters.yCenter, radius, 0, lastAnimationUpdateTimestamp);\n  } else {\n    let segmentPoint = circleParameters.getPointPosition(0, radius);\n    _______________________canvasContext.moveTo(segmentPoint.x, segmentPoint.y);\n    for (let _segmentIndex = 1; _segmentIndex < numSegments; _segmentIndex++) {\n      segmentPoint = circleParameters.getPointPosition(_segmentIndex, radius);\n      _______________________canvasContext.lineTo(segmentPoint.x, segmentPoint.y);\n    }\n  }\n}\nfunction drawShapeWithStroke(graphicsContext, shapeOptions, lineDashOffset, isStrokeEnabled, lineDashProperties) {\n  const __graphicsContext = graphicsContext.ctx;\n  const isCircularShape = shapeOptions.circular;\n  const {\n    color: _strokeColor,\n    lineWidth: __lineWidth\n  } = shapeOptions;\n  if ((!!isCircularShape || !!isStrokeEnabled) && !!_strokeColor && !!__lineWidth && !(lineDashOffset < 0)) {\n    __graphicsContext.save();\n    __graphicsContext.strokeStyle = _strokeColor;\n    __graphicsContext.lineWidth = __lineWidth;\n    __graphicsContext.setLineDash(lineDashProperties.dash);\n    __graphicsContext.lineDashOffset = lineDashProperties.dashOffset;\n    __graphicsContext.beginPath();\n    drawCircle(graphicsContext, lineDashOffset, isCircularShape, isStrokeEnabled);\n    __graphicsContext.closePath();\n    __graphicsContext.stroke();\n    __graphicsContext.restore();\n  }\n}\nfunction _tooltipHandlerFunction(tooltipPointLabel, pointLabelIndex, _pointLabelIndex) {\n  return tooltipHandler(tooltipPointLabel, {\n    label: _pointLabelIndex,\n    index: pointLabelIndex,\n    type: \"pointLabel\"\n  });\n}\nclass qa extends Sa {\n  static id = \"radialLinear\";\n  static defaults = {\n    display: true,\n    animate: true,\n    position: \"chartArea\",\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0\n    },\n    grid: {\n      circular: false\n    },\n    startAngle: 0,\n    ticks: {\n      showLabelBackdrop: true,\n      callback: tooltipActiveElements.formatters.numeric\n    },\n    pointLabels: {\n      backdropColor: undefined,\n      backdropPadding: 2,\n      display: true,\n      font: {\n        size: 10\n      },\n      callback: transformFunction => transformFunction,\n      padding: 5,\n      centerPointLabels: false\n    }\n  };\n  static defaultRoutes = {\n    \"angleLines.color\": \"borderColor\",\n    \"pointLabels.color\": \"color\",\n    \"ticks.color\": \"color\"\n  };\n  static descriptors = {\n    angleLines: {\n      _fallback: \"grid\"\n    }\n  };\n  constructor(constructorParam) {\n    super(constructorParam);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const chartPadding = this._padding = __animationElement(calculateChartPadding(this.options) / 2);\n    const ____chartWidth = this.width = this.maxWidth - chartPadding.width;\n    const _chartHeight = this.height = this.maxHeight - chartPadding.height;\n    this.xCenter = Math.floor(this.left + ____chartWidth / 2 + chartPadding.left);\n    this.yCenter = Math.floor(this.top + _chartHeight / 2 + chartPadding.top);\n    this.drawingArea = Math.floor(Math.min(____chartWidth, _chartHeight) / 2);\n  }\n  determineDataLimits() {\n    const {\n      min: ______minValue,\n      max: _____maxValue\n    } = this.getMinMax(false);\n    this.min = chartUpdateTrigger(______minValue) && !isNaN(______minValue) ? ______minValue : 0;\n    this.max = chartUpdateTrigger(_____maxValue) && !isNaN(_____maxValue) ? _____maxValue : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / calculateChartPadding(this.options));\n  }\n  generateTickLabels(tickInterval) {\n    Sa.prototype.generateTickLabels.call(this, tickInterval);\n    this._pointLabels = this.getLabels().map((pointLabelValue, _pointLabelValue) => {\n      const pointLabelCallbackResult = $(this.options.pointLabels.callback, [pointLabelValue, _pointLabelValue], this);\n      if (pointLabelCallbackResult || pointLabelCallbackResult === 0) {\n        return pointLabelCallbackResult;\n      } else {\n        return \"\";\n      }\n    }).filter((dataVisibility, dataVisibilityIndex) => this.chart.getDataVisibility(dataVisibilityIndex));\n  }\n  fit() {\n    const ___________options = this.options;\n    if (___________options.display && ___________options.pointLabels.display) {\n      generateChartPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(newCenterX, oldCenterX, newCenterY, _centerPointY) {\n    this.xCenter += Math.floor((newCenterX - oldCenterX) / 2);\n    this.yCenter += Math.floor((newCenterY - _centerPointY) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(newCenterX, oldCenterX, newCenterY, _centerPointY));\n  }\n  getIndexAngle(_timeElapsed) {\n    const animationUpdateRatio = lastAnimationUpdateTimestamp / (this._pointLabels.length || 1);\n    const _startAngle = this.options.startAngle || 0;\n    return animationRefreshRate(_timeElapsed * animationUpdateRatio + requestAnimation(_startAngle));\n  }\n  getDistanceFromCenterForValue(valueForDistanceCalculation) {\n    if (chartUpdateInterval(valueForDistanceCalculation)) {\n      return NaN;\n    }\n    const ____scaleFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - valueForDistanceCalculation) * ____scaleFactor;\n    } else {\n      return (valueForDistanceCalculation - this.min) * ____scaleFactor;\n    }\n  }\n  getValueForDistanceFromCenter(___distanceFromCenter) {\n    if (chartUpdateInterval(___distanceFromCenter)) {\n      return NaN;\n    }\n    const normalizedDistance = ___distanceFromCenter / (this.drawingArea / (this.max - this.min));\n    if (this.options.reverse) {\n      return this.max - normalizedDistance;\n    } else {\n      return this.min + normalizedDistance;\n    }\n  }\n  getPointLabelContext(__pointLabelIndex) {\n    const pointLabels = this._pointLabels || [];\n    if (__pointLabelIndex >= 0 && __pointLabelIndex < pointLabels.length) {\n      const pointLabel = pointLabels[__pointLabelIndex];\n      return _tooltipHandlerFunction(this.getContext(), __pointLabelIndex, pointLabel);\n    }\n  }\n  getPointPosition(____timestamp, __radius, _offsetAngle = 0) {\n    const angleFromIndex = this.getIndexAngle(____timestamp) - currentFrameTimestamp + _offsetAngle;\n    return {\n      x: Math.cos(angleFromIndex) * __radius + this.xCenter,\n      y: Math.sin(angleFromIndex) * __radius + this.yCenter,\n      angle: angleFromIndex\n    };\n  }\n  getPointPositionForValue(valuePosition, ___value) {\n    return this.getPointPosition(valuePosition, this.getDistanceFromCenterForValue(___value));\n  }\n  getBasePosition(___________________inputValue) {\n    return this.getPointPositionForValue(___________________inputValue || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(___pointLabelIndex) {\n    const {\n      left: pointLabelLeft,\n      top: pointLabelTop,\n      right: pointLabelRight,\n      bottom: pointLabelBottom\n    } = this._pointLabelItems[___pointLabelIndex];\n    return {\n      left: pointLabelLeft,\n      top: pointLabelTop,\n      right: pointLabelRight,\n      bottom: pointLabelBottom\n    };\n  }\n  drawBackground() {\n    const {\n      backgroundColor: _backgroundColor,\n      grid: {\n        circular: circleGrid\n      }\n    } = this.options;\n    if (_backgroundColor) {\n      const ________canvasContext = this.ctx;\n      ________canvasContext.save();\n      ________canvasContext.beginPath();\n      drawCircle(this, this.getDistanceFromCenterForValue(this._endValue), circleGrid, this._pointLabels.length);\n      ________canvasContext.closePath();\n      ________canvasContext.fillStyle = _backgroundColor;\n      ________canvasContext.fill();\n      ________canvasContext.restore();\n    }\n  }\n  drawGrid() {\n    const t = this.ctx;\n    const e = this.options;\n    const {\n      angleLines: i,\n      grid: s,\n      border: n\n    } = e;\n    const o = this._pointLabels.length;\n    let _____currentIndex;\n    let r;\n    let h;\n    if (e.pointLabels.display) {\n      drawChartWithPointLabels(this, o);\n    }\n    if (s.display) {\n      this.ticks.forEach((_value, contextValue) => {\n        if (contextValue !== 0) {\n          r = this.getDistanceFromCenterForValue(_value.value);\n          const _contextValue = this.getContext(contextValue);\n          const __contextSettings = s.setContext(_contextValue);\n          const dataContext = n.setContext(_contextValue);\n          drawShapeWithStroke(this, __contextSettings, r, o, dataContext);\n        }\n      });\n    }\n    if (i.display) {\n      t.save();\n      _____currentIndex = o - 1;\n      for (; _____currentIndex >= 0; _____currentIndex--) {\n        const pointLabelContext = i.setContext(this.getPointLabelContext(_____currentIndex));\n        const {\n          color: strokeColor,\n          lineWidth: _lineWidth\n        } = pointLabelContext;\n        if (_lineWidth && strokeColor) {\n          t.lineWidth = _lineWidth;\n          t.strokeStyle = strokeColor;\n          t.setLineDash(pointLabelContext.borderDash);\n          t.lineDashOffset = pointLabelContext.borderDashOffset;\n          r = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max);\n          h = this.getPointPosition(_____currentIndex, r);\n          t.beginPath();\n          t.moveTo(this.xCenter, this.yCenter);\n          t.lineTo(h.x, h.y);\n          t.stroke();\n        }\n      }\n      t.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const t = this.ctx;\n    const e = this.options;\n    const i = e.ticks;\n    if (!i.display) {\n      return;\n    }\n    const s = this.getIndexAngle(0);\n    let distanceFromCenter;\n    let labelWidth;\n    t.save();\n    t.translate(this.xCenter, this.yCenter);\n    t.rotate(s);\n    t.textAlign = \"center\";\n    t.textBaseline = \"middle\";\n    this.ticks.forEach((label, ____index) => {\n      if (____index === 0 && !e.reverse) {\n        return;\n      }\n      const contextualRenderer = i.setContext(this.getContext(____index));\n      const animationFrameData = requestAnimationFrame(contextualRenderer.font);\n      distanceFromCenter = this.getDistanceFromCenterForValue(this.ticks[____index].value);\n      if (contextualRenderer.showLabelBackdrop) {\n        t.font = animationFrameData.string;\n        labelWidth = t.measureText(label.label).width;\n        t.fillStyle = contextualRenderer.backdropColor;\n        const backdropPadding = __animationElement(contextualRenderer.backdropPadding);\n        t.fillRect(-labelWidth / 2 - backdropPadding.left, -distanceFromCenter - animationFrameData.size / 2 - backdropPadding.top, labelWidth + backdropPadding.width, animationFrameData.size + backdropPadding.height);\n      }\n      Z(t, label.label, 0, -distanceFromCenter, animationFrameData, {\n        color: contextualRenderer.color,\n        strokeColor: contextualRenderer.textStrokeColor,\n        strokeWidth: contextualRenderer.textStrokeWidth\n      });\n    });\n    t.restore();\n  }\n  drawTitle() {}\n}\nconst timeScaleConfig = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: 1000\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: 60\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: 60\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: 24\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: 30\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: 4\n  },\n  month: {\n    common: true,\n    size: 2628000000,\n    steps: 12\n  },\n  quarter: {\n    common: false,\n    size: 7884000000,\n    steps: 4\n  },\n  year: {\n    common: true,\n    size: 31540000000\n  }\n};\nconst timeScaleKeys = Object.keys(timeScaleConfig);\nfunction subtractValues(difference, subtractorValue) {\n  return difference - subtractorValue;\n}\nfunction transformInputValue(dataObject, inputValue) {\n  if (chartUpdateInterval(inputValue)) {\n    return null;\n  }\n  const dataAdapter = dataObject._adapter;\n  const {\n    parser: inputParser,\n    round: roundingUnit,\n    isoWeekday: isoWeekdayOption\n  } = dataObject._parseOpts;\n  let transformedInputValue = inputValue;\n  if (typeof inputParser == \"function\") {\n    transformedInputValue = inputParser(transformedInputValue);\n  }\n  if (!chartUpdateTrigger(transformedInputValue)) {\n    if (typeof inputParser == \"string\") {\n      transformedInputValue = dataAdapter.parse(transformedInputValue, inputParser);\n    } else {\n      transformedInputValue = dataAdapter.parse(transformedInputValue);\n    }\n  }\n  if (transformedInputValue === null) {\n    return null;\n  } else {\n    if (roundingUnit) {\n      if (roundingUnit !== \"week\" || !requestId(isoWeekdayOption) && isoWeekdayOption !== true) {\n        transformedInputValue = dataAdapter.startOf(transformedInputValue, roundingUnit);\n      } else {\n        transformedInputValue = dataAdapter.startOf(transformedInputValue, \"isoWeek\", isoWeekdayOption);\n      }\n    }\n    return +transformedInputValue;\n  }\n}\nfunction getNextTimeScale(currentTimeScale, _startValue, _currentTime, maxStepsAllowed) {\n  const totalTimeScaleKeys = timeScaleKeys.length;\n  for (let currentTimeScaleIndex = timeScaleKeys.indexOf(currentTimeScale); currentTimeScaleIndex < totalTimeScaleKeys - 1; ++currentTimeScaleIndex) {\n    const currentTimeScaleConfig = timeScaleConfig[timeScaleKeys[currentTimeScaleIndex]];\n    const maxStepsInTimeScale = currentTimeScaleConfig.steps ? currentTimeScaleConfig.steps : Number.MAX_SAFE_INTEGER;\n    if (currentTimeScaleConfig.common && Math.ceil((_currentTime - _startValue) / (maxStepsInTimeScale * currentTimeScaleConfig.size)) <= maxStepsAllowed) {\n      return timeScaleKeys[currentTimeScaleIndex];\n    }\n  }\n  return timeScaleKeys[totalTimeScaleKeys - 1];\n}\nfunction findMatchingTimeScale(timeDifferenceThreshold, _timeDifferenceThreshold, indexOfTimeScale, referenceTime, _thresholdValue) {\n  for (let ______________________________________________________currentIndex = timeScaleKeys.length - 1; ______________________________________________________currentIndex >= timeScaleKeys.indexOf(indexOfTimeScale); ______________________________________________________currentIndex--) {\n    const _currentTimeScale = timeScaleKeys[______________________________________________________currentIndex];\n    if (timeScaleConfig[_currentTimeScale].common && timeDifferenceThreshold._adapter.diff(_thresholdValue, referenceTime, _currentTimeScale) >= _timeDifferenceThreshold - 1) {\n      return _currentTimeScale;\n    }\n  }\n  return timeScaleKeys[indexOfTimeScale ? timeScaleKeys.indexOf(indexOfTimeScale) : 0];\n}\nfunction findNextCommonTimeScaleKey(__targetValue) {\n  for (let nextTimeScaleIndex = timeScaleKeys.indexOf(__targetValue) + 1, ______endIndex = timeScaleKeys.length; nextTimeScaleIndex < ______endIndex; ++nextTimeScaleIndex) {\n    if (timeScaleConfig[timeScaleKeys[nextTimeScaleIndex]].common) {\n      return timeScaleKeys[nextTimeScaleIndex];\n    }\n  }\n}\nfunction updateAnimationState(targetAnimationState, _____animationDuration, animationIndices) {\n  if (animationIndices) {\n    if (animationIndices.length) {\n      const {\n        lo: lowestAnimationIndex,\n        hi: _highIndex\n      } = _animationQueue(animationIndices, _____animationDuration);\n      targetAnimationState[animationIndices[lowestAnimationIndex] >= _____animationDuration ? animationIndices[lowestAnimationIndex] : animationIndices[_highIndex]] = true;\n    }\n  } else {\n    targetAnimationState[_____animationDuration] = true;\n  }\n}\nfunction calculateMajorIntervals(calendarAdapter, eventValues, ________________currentIndex, timeUnit) {\n  const calendarAdapterInstance = calendarAdapter._adapter;\n  const startOfFirstEvent = +calendarAdapterInstance.startOf(eventValues[0].value, timeUnit);\n  const lastEventValue = eventValues[eventValues.length - 1].value;\n  let __currentTime;\n  let currentIndexValue;\n  for (__currentTime = startOfFirstEvent; __currentTime <= lastEventValue; __currentTime = +calendarAdapterInstance.add(__currentTime, 1, timeUnit)) {\n    currentIndexValue = ________________currentIndex[__currentTime];\n    if (currentIndexValue >= 0) {\n      eventValues[currentIndexValue].major = true;\n    }\n  }\n  return eventValues;\n}\nfunction inputArrayElement(arrayToProcess, _______inputArray, _____________index) {\n  const processedElements = [];\n  const elementIndexMap = {};\n  const ______inputArrayLength = _______inputArray.length;\n  let __________________________________________________currentIndex;\n  let _________________inputValue;\n  for (__________________________________________________currentIndex = 0; __________________________________________________currentIndex < ______inputArrayLength; ++__________________________________________________currentIndex) {\n    _________________inputValue = _______inputArray[__________________________________________________currentIndex];\n    elementIndexMap[_________________inputValue] = __________________________________________________currentIndex;\n    processedElements.push({\n      value: _________________inputValue,\n      major: false\n    });\n  }\n  if (______inputArrayLength !== 0 && _____________index) {\n    return calculateMajorIntervals(arrayToProcess, processedElements, elementIndexMap, _____________index);\n  } else {\n    return processedElements;\n  }\n}\nclass rr extends fs {\n  static id = \"time\";\n  static defaults = {\n    bounds: \"data\",\n    adapters: {},\n    time: {\n      parser: false,\n      unit: false,\n      round: false,\n      isoWeekday: false,\n      minUnit: \"millisecond\",\n      displayFormats: {}\n    },\n    ticks: {\n      source: \"auto\",\n      callback: false,\n      major: {\n        enabled: false\n      }\n    }\n  };\n  constructor(_constructorParam) {\n    super(_constructorParam);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = \"day\";\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(timeData, __options = {}) {\n    const _timeOptions = timeData.time ||= {};\n    const dateAdapter = this._adapter = new ___animationInstance._date(timeData.adapters.date);\n    dateAdapter.init(__options);\n    lastUpdateDate(_timeOptions.displayFormats, dateAdapter.formats());\n    this._parseOpts = {\n      parser: _timeOptions.parser,\n      round: _timeOptions.round,\n      isoWeekday: _timeOptions.isoWeekday\n    };\n    super.init(timeData);\n    this._normalized = __options.normalized;\n  }\n  parse(____________________inputValue, _____________________inputValue) {\n    if (____________________inputValue === undefined) {\n      return null;\n    } else {\n      return transformInputValue(this, ____________________inputValue);\n    }\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const t = this.options;\n    const e = this._adapter;\n    const i = t.time.unit || \"day\";\n    let {\n      min: s,\n      max: n,\n      minDefined: isMinMaxUpdated,\n      maxDefined: isMaxValuePresent\n    } = this.getUserBounds();\n    function updateMinMaxValues(minMax) {\n      if (!isMinMaxUpdated && !isNaN(minMax.min)) {\n        s = Math.min(s, minMax.min);\n      }\n      if (!isMaxValuePresent && !isNaN(minMax.max)) {\n        n = Math.max(n, minMax.max);\n      }\n    }\n    if (!isMinMaxUpdated || !isMaxValuePresent) {\n      updateMinMaxValues(this._getLabelBounds());\n      if (t.bounds !== \"ticks\" || t.ticks.source !== \"labels\") {\n        updateMinMaxValues(this.getMinMax(false));\n      }\n    }\n    if (chartUpdateTrigger(s) && !isNaN(s)) {\n      s = s;\n    } else {\n      s = +e.startOf(Date.now(), i);\n    }\n    if (chartUpdateTrigger(n) && !isNaN(n)) {\n      n = n;\n    } else {\n      n = +e.endOf(Date.now(), i) + 1;\n    }\n    this.min = Math.min(s, n - 1);\n    this.max = Math.max(s + 1, n);\n  }\n  _getLabelBounds() {\n    const labelTimestamps = this.getLabelTimestamps();\n    let minLabelTimestamp = Number.POSITIVE_INFINITY;\n    let maxLabelTimestamp = Number.NEGATIVE_INFINITY;\n    if (labelTimestamps.length) {\n      minLabelTimestamp = labelTimestamps[0];\n      maxLabelTimestamp = labelTimestamps[labelTimestamps.length - 1];\n    }\n    return {\n      min: minLabelTimestamp,\n      max: maxLabelTimestamp\n    };\n  }\n  buildTicks() {\n    const t = this.options;\n    const e = t.time;\n    const i = t.ticks;\n    const s = i.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n    if (t.bounds === \"ticks\" && s.length) {\n      this.min = this._userMin || s[0];\n      this.max = this._userMax || s[s.length - 1];\n    }\n    const n = this.min;\n    const o = this.max;\n    const a = _chartAnimationQueue(s, n, o);\n    this._unit = e.unit || (i.autoSkip ? getNextTimeScale(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : findMatchingTimeScale(this, a.length, e.minUnit, this.min, this.max));\n    this._majorUnit = i.major.enabled && this._unit !== \"year\" ? findNextCommonTimeScaleKey(this._unit) : undefined;\n    this.initOffsets(s);\n    if (t.reverse) {\n      a.reverse();\n    }\n    return inputArrayElement(this, a, this._majorUnit);\n  }\n  afterAutoSkip() {\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(valueAsNumber => +valueAsNumber.value));\n    }\n  }\n  initOffsets(offsetValues = []) {\n    let initialOffset;\n    let lastOffsetValue;\n    let calculatedStartOffset = 0;\n    let endOffset = 0;\n    if (this.options.offset && offsetValues.length) {\n      initialOffset = this.getDecimalForValue(offsetValues[0]);\n      if (offsetValues.length === 1) {\n        calculatedStartOffset = 1 - initialOffset;\n      } else {\n        calculatedStartOffset = (this.getDecimalForValue(offsetValues[1]) - initialOffset) / 2;\n      }\n      lastOffsetValue = this.getDecimalForValue(offsetValues[offsetValues.length - 1]);\n      if (offsetValues.length === 1) {\n        endOffset = lastOffsetValue;\n      } else {\n        endOffset = (lastOffsetValue - this.getDecimalForValue(offsetValues[offsetValues.length - 2])) / 2;\n      }\n    }\n    const animationFactor = offsetValues.length < 3 ? 0.5 : 0.25;\n    calculatedStartOffset = chartAnimationState(calculatedStartOffset, 0, animationFactor);\n    endOffset = chartAnimationState(endOffset, 0, animationFactor);\n    this._offsets = {\n      start: calculatedStartOffset,\n      end: endOffset,\n      factor: 1 / (calculatedStartOffset + 1 + endOffset)\n    };\n  }\n  _generate() {\n    const _numericValue = this._adapter;\n    const e = this.min;\n    const i = this.max;\n    const s = this.options;\n    const n = s.time;\n    const o = n.unit || getNextTimeScale(n.minUnit, e, i, this._getLabelCapacity(e));\n    const a = chartAnimationRunning(s.ticks.stepSize, 1);\n    const h = o === \"week\" && n.isoWeekday;\n    const l = requestId(h) || h === true;\n    const c = {};\n    let d;\n    let _indexCounter;\n    let g = e;\n    if (l) {\n      g = +_numericValue.startOf(g, \"isoWeek\", h);\n    }\n    g = +_numericValue.startOf(g, l ? \"day\" : o);\n    if (_numericValue.diff(i, e, o) > a * 100000) {\n      throw new Error(e + \" and \" + i + \" are too far apart with stepSize of \" + a + \" \" + o);\n    }\n    const p = s.ticks.source === \"data\" && this.getDataTimestamps();\n    d = g;\n    _indexCounter = 0;\n    d = +_numericValue.add(d, a, o);\n    for (; d < i; _indexCounter++) {\n      updateAnimationState(c, d, p);\n    }\n    if (d === i || s.bounds === \"ticks\" || _indexCounter === 1) {\n      updateAnimationState(c, d, p);\n    }\n    return Object.keys(c).sort(subtractValues).map(numericValue => +numericValue);\n  }\n  getLabelForValue(_____timestamp) {\n    const adapter = this._adapter;\n    const timeOptions = this.options.time;\n    if (timeOptions.tooltipFormat) {\n      return adapter.format(_____timestamp, timeOptions.tooltipFormat);\n    } else {\n      return adapter.format(_____timestamp, timeOptions.displayFormats.datetime);\n    }\n  }\n  format(___timestamp, displayFormat) {\n    const displayFormatsOptions = this.options.time.displayFormats;\n    const _timeUnit = this._unit;\n    const formattedDisplay = displayFormat || displayFormatsOptions[_timeUnit];\n    return this._adapter.format(___timestamp, formattedDisplay);\n  }\n  _tickFormatFunction(__tickValue, ___tickValue, _________tickIndex, tickValueFormat) {\n    const _________________options = this.options;\n    const tickCallback = _________________options.ticks.callback;\n    if (tickCallback) {\n      return $(tickCallback, [__tickValue, ___tickValue, _________tickIndex], this);\n    }\n    const timeDisplayFormats = _________________options.time.displayFormats;\n    const currentUnit = this._unit;\n    const majorTimeUnit = this._majorUnit;\n    const currentUnitFormat = currentUnit && timeDisplayFormats[currentUnit];\n    const currentUnitTimeFormat = majorTimeUnit && timeDisplayFormats[majorTimeUnit];\n    const tickValueData = _________tickIndex[___tickValue];\n    const isMajorTimeUnit = majorTimeUnit && currentUnitTimeFormat && tickValueData && tickValueData.major;\n    return this._adapter.format(__tickValue, tickValueFormat || (isMajorTimeUnit ? currentUnitTimeFormat : currentUnitFormat));\n  }\n  generateTickLabels(tickLabels) {\n    let ______________________________currentIndex;\n    let tickLabelCount;\n    let tickLabel;\n    ______________________________currentIndex = 0;\n    tickLabelCount = tickLabels.length;\n    for (; ______________________________currentIndex < tickLabelCount; ++______________________________currentIndex) {\n      tickLabel = tickLabels[______________________________currentIndex];\n      tickLabel.label = this._tickFormatFunction(tickLabel.value, ______________________________currentIndex, tickLabels);\n    }\n  }\n  getDecimalForValue(____value) {\n    if (____value === null) {\n      return NaN;\n    } else {\n      return (____value - this.min) / (this.max - this.min);\n    }\n  }\n  getPixelForValue(valueToPixel) {\n    const offsets = this._offsets;\n    const __decimalValue = this.getDecimalForValue(valueToPixel);\n    return this.getPixelForDecimal((offsets.start + __decimalValue) * offsets.factor);\n  }\n  getValueForPixel(____pixelValue) {\n    const offsetData = this._offsets;\n    const normalizedPixelValue = this.getDecimalForPixel(____pixelValue) / offsetData.factor - offsetData.end;\n    return this.min + normalizedPixelValue * (this.max - this.min);\n  }\n  _getLabelSize(__labelText) {\n    const ____tickOptions = this.options.ticks;\n    const ___textWidth = this.ctx.measureText(__labelText).width;\n    const rotationAngle = requestAnimation(this.isHorizontal() ? ____tickOptions.maxRotation : ____tickOptions.minRotation);\n    const cosineRotation = Math.cos(rotationAngle);\n    const sinRotation = Math.sin(rotationAngle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: ___textWidth * cosineRotation + tickFontSize * sinRotation,\n      h: ___textWidth * sinRotation + tickFontSize * cosineRotation\n    };\n  }\n  _getLabelCapacity(________labelIndex) {\n    const __timeOptions = this.options.time;\n    const displayFormats = __timeOptions.displayFormats;\n    const _displayFormat = displayFormats[__timeOptions.unit] || displayFormats.millisecond;\n    const formattedLabel = this._tickFormatFunction(________labelIndex, 0, inputArrayElement(this, [________labelIndex], this._majorUnit), _displayFormat);\n    const labelSize = this._getLabelSize(formattedLabel);\n    const labelCapacity = Math.floor(this.isHorizontal() ? this.width / labelSize.w : this.height / labelSize.h) - 1;\n    if (labelCapacity > 0) {\n      return labelCapacity;\n    } else {\n      return 1;\n    }\n  }\n  getDataTimestamps() {\n    let ________________________________currentIndex;\n    let visibleMetaCount;\n    let cachedData = this._cache.data || [];\n    if (cachedData.length) {\n      return cachedData;\n    }\n    const visibleMetadatas = this.getMatchingVisibleMetas();\n    if (this._normalized && visibleMetadatas.length) {\n      return this._cache.data = visibleMetadatas[0].controller.getAllParsedValues(this);\n    }\n    ________________________________currentIndex = 0;\n    visibleMetaCount = visibleMetadatas.length;\n    for (; ________________________________currentIndex < visibleMetaCount; ++________________________________currentIndex) {\n      cachedData = cachedData.concat(visibleMetadatas[________________________________currentIndex].controller.getAllParsedValues(this));\n    }\n    return this._cache.data = this.normalize(cachedData);\n  }\n  getLabelTimestamps() {\n    const _labelTimestamps = this._cache.labels || [];\n    let ________________________________________currentIndex;\n    let totalLabelsCount;\n    if (_labelTimestamps.length) {\n      return _labelTimestamps;\n    }\n    const labelList = this.getLabels();\n    ________________________________________currentIndex = 0;\n    totalLabelsCount = labelList.length;\n    for (; ________________________________________currentIndex < totalLabelsCount; ++________________________________________currentIndex) {\n      _labelTimestamps.push(transformInputValue(this, labelList[________________________________________currentIndex]));\n    }\n    return this._cache.labels = this._normalized ? _labelTimestamps : this.normalize(_labelTimestamps);\n  }\n  normalize(valuesToNormalize) {\n    return adapterFunctions(valuesToNormalize.sort(subtractValues));\n  }\n}\nfunction calculateHorizontalRange(__dataPoints, position, isTimeBased) {\n  let lowerBoundValue;\n  let lastDataPointPos;\n  let _endPosition;\n  let lastDataPointTime;\n  let lowerBoundIndex = 0;\n  let _lastIndex = __dataPoints.length - 1;\n  if (isTimeBased) {\n    if (position >= __dataPoints[lowerBoundIndex].pos && position <= __dataPoints[_lastIndex].pos) {\n      ({\n        lo: lowerBoundIndex,\n        hi: _lastIndex\n      } = notificationFunction(__dataPoints, \"pos\", position));\n    }\n    ({\n      pos: lowerBoundValue,\n      time: _endPosition\n    } = __dataPoints[lowerBoundIndex]);\n    ({\n      pos: lastDataPointPos,\n      time: lastDataPointTime\n    } = __dataPoints[_lastIndex]);\n  } else {\n    if (position >= __dataPoints[lowerBoundIndex].time && position <= __dataPoints[_lastIndex].time) {\n      ({\n        lo: lowerBoundIndex,\n        hi: _lastIndex\n      } = notificationFunction(__dataPoints, \"time\", position));\n    }\n    ({\n      time: lowerBoundValue,\n      pos: _endPosition\n    } = __dataPoints[lowerBoundIndex]);\n    ({\n      time: lastDataPointPos,\n      pos: lastDataPointTime\n    } = __dataPoints[_lastIndex]);\n  }\n  const horizontalRangeDelta = lastDataPointPos - lowerBoundValue;\n  if (horizontalRangeDelta) {\n    return _endPosition + (lastDataPointTime - _endPosition) * (position - lowerBoundValue) / horizontalRangeDelta;\n  } else {\n    return _endPosition;\n  }\n}\nclass lr extends rr {\n  static id = \"timeseries\";\n  static defaults = rr.defaults;\n  constructor(constructorParameter) {\n    super(constructorParameter);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestampsForTable = this._getTimestampsForTable();\n    const lookupTable = this._table = this.buildLookupTable(timestampsForTable);\n    this._minPos = calculateHorizontalRange(lookupTable, this.min);\n    this._tableRange = calculateHorizontalRange(lookupTable, this.max) - this._minPos;\n    super.initOffsets(timestampsForTable);\n  }\n  buildLookupTable(t) {\n    const {\n      min: e,\n      max: i\n    } = this;\n    const s = [];\n    const n = [];\n    let __________________currentIndex;\n    let a;\n    let r;\n    let h;\n    let l;\n    __________________currentIndex = 0;\n    a = t.length;\n    for (; __________________currentIndex < a; ++__________________currentIndex) {\n      h = t[__________________currentIndex];\n      if (h >= e && h <= i) {\n        s.push(h);\n      }\n    }\n    if (s.length < 2) {\n      return [{\n        time: e,\n        pos: 0\n      }, {\n        time: i,\n        pos: 1\n      }];\n    }\n    __________________currentIndex = 0;\n    a = s.length;\n    for (; __________________currentIndex < a; ++__________________currentIndex) {\n      l = s[__________________currentIndex + 1];\n      r = s[__________________currentIndex - 1];\n      h = s[__________________currentIndex];\n      if (Math.round((l + r) / 2) !== h) {\n        n.push({\n          time: h,\n          pos: __________________currentIndex / (a - 1)\n        });\n      }\n    }\n    return n;\n  }\n  _generate() {\n    const minTimestamp = this.min;\n    const maxTimestamp = this.max;\n    let dataTimestamps = super.getDataTimestamps();\n    if (!dataTimestamps.includes(minTimestamp) || !dataTimestamps.length) {\n      dataTimestamps.splice(0, 0, minTimestamp);\n    }\n    if (!dataTimestamps.includes(maxTimestamp) || dataTimestamps.length === 1) {\n      dataTimestamps.push(maxTimestamp);\n    }\n    return dataTimestamps.sort((subtractValue, _subtractValue) => subtractValue - _subtractValue);\n  }\n  _getTimestampsForTable() {\n    let timestampsArray = this._cache.all || [];\n    if (timestampsArray.length) {\n      return timestampsArray;\n    }\n    const _dataTimestamps = this.getDataTimestamps();\n    const __labelTimestamps = this.getLabelTimestamps();\n    if (_dataTimestamps.length && __labelTimestamps.length) {\n      timestampsArray = this.normalize(_dataTimestamps.concat(__labelTimestamps));\n    } else if (_dataTimestamps.length) {\n      timestampsArray = _dataTimestamps;\n    } else {\n      timestampsArray = __labelTimestamps;\n    }\n    timestampsArray = this._cache.all = timestampsArray;\n    return timestampsArray;\n  }\n  getDecimalForValue(decimalValue) {\n    return (calculateHorizontalRange(this._table, decimalValue) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(______pixelValue) {\n    const _offsets = this._offsets;\n    const _decimalPosition = this.getDecimalForPixel(______pixelValue) / _offsets.factor - _offsets.end;\n    return calculateHorizontalRange(this._table, _decimalPosition * this._tableRange + this._minPos, true);\n  }\n}\nvar cr = Object.freeze({\n  __proto__: null,\n  CategoryScale: Ma,\n  LinearScale: Da,\n  LogarithmicScale: Ta,\n  RadialLinearScale: qa,\n  TimeScale: rr,\n  TimeSeriesScale: lr\n});\nconst dr = [qe, Hn, xa, cr];\nexport { ___AnimationController as Animation, se as Animations, mn as ArcElement, We as BarController, BarAnimationController as BarElement, DeviceInteraction as BasePlatform, canvas2DContext as BasicPlatform, He as BubbleController, Ma as CategoryScale, rn as Chart, _animationTaskId as Colors, Se as DatasetController, ___isChartAnimationRunning as Decimation, CanvasInteraction as DomPlatform, $e as DoughnutController, _AnimationController as Element, _animationControllerInstance as Filler, ____________animationController as Interaction, Uo as Legend, Ue as LineController, LineAnimationController as LineElement, Da as LinearScale, Ta as LogarithmicScale, PieChart as PieController, __AnimationController as PointElement, Ye as PolarAreaController, Ge as RadarController, qa as RadialLinearScale, fs as Scale, Ke as ScatterController, qo as SubTitle, tooltipActiveElements as Ticks, rr as TimeScale, lr as TimeSeriesScale, Go as Title, ma as Tooltip, ___animationInstance as _adapters, getCanvasContext as _detectPlatform, animationControllerInstance as animator, qe as controllers, animationDuration as defaults, Hn as elements, ___________animationIndex as layouts, xa as plugins, dr as registerables, vs as registry, cr as scales };",
  "originalFile": "test-samples/canonical/medium-chart/minified.js",
  "originalProvider": "openai",
  "originalModel": "gpt-4o-mini",
  "originalArgs": {
    "provider": "openai",
    "outputDir": "test-samples/canonical/medium-chart/output-turbo",
    "baseURL": "https://api.openai.com/v1",
    "contextSize": "100000",
    "maxConcurrent": "15",
    "minBatchSize": "3",
    "maxBatchSize": "100",
    "dependencyMode": "balanced",
    "perf": true,
    "maxMemory": "4096",
    "validate": true,
    "chunkSize": "100000",
    "chunking": false,
    "debugChunks": false,
    "turbo": true
  }
}